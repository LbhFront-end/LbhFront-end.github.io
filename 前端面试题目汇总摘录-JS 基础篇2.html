<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="前端面试题," />





  <link rel="alternate" href="/atom.xml" title="赖同学" type="application/atom+xml" />






<meta name="description" content="温故而知新，保持空杯心态,复习到一半的时间，突然发现了 前端面试之道，从第二道题目开始按学习这本书的路径来 JS 基础2React/Vue 项目时为什么要在组件中写 key，其作用是什么？ key是给每一个vnode的唯一id,可以依靠key,更准确, 更快的拿到oldVnode中对应的vnode节点。  key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度。 V">
<meta name="keywords" content="前端面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试题目汇总摘录（JS 基础篇2）">
<meta property="og:url" content="http://laibh.top/前端面试题目汇总摘录-JS 基础篇2.html">
<meta property="og:site_name" content="赖同学">
<meta property="og:description" content="温故而知新，保持空杯心态,复习到一半的时间，突然发现了 前端面试之道，从第二道题目开始按学习这本书的路径来 JS 基础2React/Vue 项目时为什么要在组件中写 key，其作用是什么？ key是给每一个vnode的唯一id,可以依靠key,更准确, 更快的拿到oldVnode中对应的vnode节点。  key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度。 V">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://laibh.top/images/前端面试题目汇总摘录-JS%20基础篇2-原型.png">
<meta property="og:updated_time" content="2022-03-04T10:00:38.468Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端面试题目汇总摘录（JS 基础篇2）">
<meta name="twitter:description" content="温故而知新，保持空杯心态,复习到一半的时间，突然发现了 前端面试之道，从第二道题目开始按学习这本书的路径来 JS 基础2React/Vue 项目时为什么要在组件中写 key，其作用是什么？ key是给每一个vnode的唯一id,可以依靠key,更准确, 更快的拿到oldVnode中对应的vnode节点。  key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度。 V">
<meta name="twitter:image" content="http://laibh.top/images/前端面试题目汇总摘录-JS%20基础篇2-原型.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '1YNH8Y3MP9',
      apiKey: '61c189facf700193dfcbb902369ce227',
      indexName: 'MyBlog',
      hits: {"per_page":10},
      labels: {"input_placeholder":"想要找些什么呢","hits_empty":"${query} 没有被找到，再试试","hits_stats":"在 ${time} ms 查找了${hits}个结果"}
    }
  };
</script>



  <link rel="canonical" href="http://laibh.top/前端面试题目汇总摘录-JS 基础篇2.html"/>





  <title>前端面试题目汇总摘录（JS 基础篇2） | 赖同学</title>
  








</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">赖同学</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-comment"></i> <br />
            
            留言
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://laibh.top/前端面试题目汇总摘录-JS 基础篇2.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖彬鸿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/myPhoto.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖同学">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">前端面试题目汇总摘录（JS 基础篇2）</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-01T09:30:54+08:00">
                2019-04-01
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2022-03-04T18:00:38+08:00">
                2022-03-04
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端面试/" itemprop="url" rel="index">
                    <span itemprop="name">前端面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/前端面试题目汇总摘录-JS 基础篇2.html" class="leancloud_visitors" data-flag-title="前端面试题目汇总摘录（JS 基础篇2）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  14,799
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>温故而知新，保持空杯心态,复习到一半的时间，突然发现了 <a href="https://yuchengkai.cn/docs/frontend">前端面试之道</a>，从第二道题目开始按学习这本书的路径来</p>
<h2 id="JS-基础2"><a href="#JS-基础2" class="headerlink" title="JS 基础2"></a>JS 基础2</h2><h3 id="React-Vue-项目时为什么要在组件中写-key，其作用是什么？"><a href="#React-Vue-项目时为什么要在组件中写-key，其作用是什么？" class="headerlink" title="React/Vue 项目时为什么要在组件中写 key，其作用是什么？"></a>React/Vue 项目时为什么要在组件中写 key，其作用是什么？</h3><blockquote>
<p>key是给每一个vnode的唯一id,可以<code>依靠key</code>,更<code>准确</code>, 更<code>快</code>的拿到oldVnode中对应的vnode节点。</p>
</blockquote>
<p>key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度。</p>
<p>Vue 和 React 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 中的 diff 函数，交叉对比中，当新节点跟旧节点 <code>头尾交叉对比</code>没有结果的时候，会根据新节点的 key 对比旧节点数组中的 key，从而找到对应旧节点。如果没有找到就认为是一个新增节点。而如果没有 key，那么就会采用遍历查找的方法找到对应的旧节点。。一种一个map 映射，另一种是遍历查找。相比之下，map 映射的速度更快。</p>
<p>vue 部分源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// oldCh 是一个旧虚拟节点数组</span></span><br><span class="line"><span class="keyword">if</span>(isUndef(oldKeyToIdx))&#123;</span><br><span class="line">   oldKeyToIdx = createKeyToOldIdx(oldCh,oldStartIdx,oldEndIdx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isDef(newStartVnode.key))&#123;</span><br><span class="line">   <span class="comment">// map 方式获取</span></span><br><span class="line">   idxInOld = oldKeyToIdx[newStartVnode.key]</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 遍历方式获取</span></span><br><span class="line">  idxInOld = findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 map 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createKeyToOldIdx</span>(<span class="params">children,beginIdx,endIdx</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i,key;</span><br><span class="line">    <span class="keyword">const</span> map = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i = beginIdx;i &lt;= endIdx,++i)&#123;</span><br><span class="line">        key = children[i].key;</span><br><span class="line">		<span class="keyword">if</span>(isDef(key) map[key] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历寻找</span></span><br><span class="line"><span class="comment">// sameVnode 是对比新旧节点是否相同的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findIdxInOld</span>(<span class="params">node,oldCh,start,end</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> c = oldCh[i];</span><br><span class="line">        <span class="keyword">if</span>(isDef(c) &amp;&amp; sameVnode(node,c)) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="“1”-”2”-”3”-map-parseInt-解析"><a href="#“1”-”2”-”3”-map-parseInt-解析" class="headerlink" title="[“1”,”2”,”3”].map(parseInt)解析"></a>[“1”,”2”,”3”].map(parseInt)解析</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>].map(<span class="built_in">parseInt</span>); <span class="comment">// [10,NaN,2,3,4]</span></span><br></pre></td></tr></table></figure>
<p><code>parseInt(string,radix)</code></p>
<p>参数：</p>
<p><code>string</code>:要被解析的值，如果参数不是一个字符串，则将其转换成字符串。字符串开头的空白符会被忽略。</p>
<p><code>radix</code>:一个介于2 和 36 的整数，表示上述字符串的基数。比如参数10 表示我们通常用的十进制数值系统。始终指定该参数可以消除阅读的困惑并且保证转换结果可预测。当未指定基数时，不同的实现会产生不同的结果，通常将值默认是10.</p>
<p><code>返回值</code>:返回解析的整数值。如果被解析参数的第一个字符无法被转换为数值类型，则返回 <code>NaN</code></p>
<p>注意：<code>radix</code>参数为n 会把第一个参数看做是一个数的 n 进制表示，而返回的值是十进制的。</p>
<ul>
<li>如果字符串string 是以 ‘0x‘ 或者 ‘0X’开头，则基数是16进制</li>
<li>如果字符串 string 是以 ’0‘ 开头，基数是8进制或者10进制。ES5 规定用10进制。</li>
<li>如果字符串string 以其他任何值开头，则默认是十进制</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">100</span>,<span class="number">10</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">100</span>,<span class="number">2</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p><code>map</code></p>
<p>map() 方法会创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数返回的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> new_array = arr.map(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[,index[,array]]</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// return element for new_array;</span></span><br><span class="line">&#125;[,thisArg]);</span><br></pre></td></tr></table></figure>
<p><code>callback</code>回调函数需要三个参数，我们通常只用了第一个参数（其他两个是可选的）</p>
<p><code>currentValue</code>:是 callback 数组中正在处理的当前元素。</p>
<p><code>index</code>:可选，是 callback 数组中正在处理的当前元素的索引</p>
<p><code>array</code>:可选，是 callback map 方法被调用的数组</p>
<p>另外还有 <code>thisAry</code>:执行 callback 函数使用的 this 值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>].map(<span class="built_in">parseInt</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">[<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>].map(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(item,index);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 即是</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>,<span class="number">0</span>); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>,<span class="number">1</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>,<span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>,<span class="number">3</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>,<span class="number">4</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>那么原题目也是同样的道理。</p>
<p>如果要将字符串数组循环变成数组可使用下面的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>].map(<span class="built_in">Number</span>);</span><br><span class="line"><span class="comment">// [10,10,10,10,10]</span></span><br></pre></td></tr></table></figure>
<h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><p>JS 中分为7种内置类型，内置类型又分为两大类型：基本类型和对象（Object）[Function,Object,Array,Boolean,Number,String,Date,Error,RegExp,全局对象]</p>
<p>基本类型有：<code>null</code>,<code>undefined</code>,<code>string</code>,<code>number</code>,<code>boolean</code>,<code>symbol</code></p>
<p>其中 JS 的数字类型是浮点类型，没有整型。<code>NaN</code>也是 <code>number</code>类型，并且 <code>NaN</code>等于自身</p>
<p>对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会被会转换为对应的类型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">111</span>; <span class="comment">// 这只是字面量，不是 number 类型</span></span><br><span class="line">a.toString(); <span class="comment">// 使用的时候才会被转换成为对象类型</span></span><br></pre></td></tr></table></figure>
<p>对象（Object ）是引用类型，在使用过程中会遇到浅拷贝和深拷贝的问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">name</span>:<span class="string">'haha'</span>&#125;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">b.name = <span class="string">'haha2'</span></span><br><span class="line">a.name; <span class="comment">// haha2</span></span><br></pre></td></tr></table></figure>
<h3 id="Typeof"><a href="#Typeof" class="headerlink" title="Typeof"></a>Typeof</h3><p>typeof 对于基本类型，除了 null 都可以显示正确的类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>; <span class="comment">//'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'1'</span>; <span class="comment">//'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">//'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">//'null'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">//'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(); <span class="comment">//'symbol'</span></span><br><span class="line"><span class="keyword">typeof</span> b <span class="comment">// b 没有声明，但是还会显示 undefined</span></span><br></pre></td></tr></table></figure>
<p>typeof 对于对象，除了函数都会显示 Object</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> []; <span class="string">'object'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="string">'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log; <span class="string">'function'</span></span><br></pre></td></tr></table></figure>
<p>对于 null 来说，虽然它是基本类型。但是会显示 object ，这是一个存在很久的 Bug。在JS 的最初版本，使用的是32位系统，为了性能问题使用低位储存了变量的内部信息，<code>000</code> 开头代表对象，然后 <code>null</code> 表示全为零，所以将它错误的判断为 object 。虽然现在内部类型判断代码已经更改了，但是这个 bug 却是一直流传下来的。</p>
<p>如果想要获得一个变量的正确类型，可以通过 <code>Object.prototype.call(xx)</code>，这样就可以获得类似 <code>[object type]</code>的字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let a</span><br><span class="line"><span class="comment">// 我们也可以这样判断 undefined</span></span><br><span class="line">a === undefined</span><br><span class="line"><span class="comment">// 但是 undefined 不是保留字，能够在低版本浏览器被赋值</span></span><br><span class="line">let undefined = <span class="number">1</span></span><br><span class="line"><span class="comment">// 这样判断就会出错</span></span><br><span class="line"><span class="comment">// 所以可以用下面的方式来判断，并且代码量更少</span></span><br><span class="line"><span class="comment">// 因为 void 后面随便跟上一个组成表达式</span></span><br><span class="line"><span class="comment">// 返回就是 undefined</span></span><br><span class="line">a === <span class="keyword">void</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="转Boolean"><a href="#转Boolean" class="headerlink" title="转Boolean"></a><strong>转Boolean</strong></h4><p>在条件判断时，除了 <code>undefined</code>,<code>null</code>,<code>false</code>,<code>NaN</code>,<code>&#39;&#39;</code>,<code>0</code>,<code>-0</code> 其他所有值都转为 true,包括所有对象。</p>
<h4 id="对象转基本类型"><a href="#对象转基本类型" class="headerlink" title="对象转基本类型"></a><strong>对象转基本类型</strong></h4><p>对象转基本类型时，首先会调用 <code>valueOf</code>然后调用 <code>toString</code>，并且这个两个方法是可以重写的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    valueOf()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以重写 <code>Symbol.toPrimitive</code>，该方法在转基本类型时调用优先级最高</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a =&#123;</span><br><span class="line">    valueOf()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    toString()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'1'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span> + a <span class="comment">// 3</span></span><br><span class="line"><span class="string">'1'</span> + a <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<h4 id="四则运算符"><a href="#四则运算符" class="headerlink" title="四则运算符"></a><strong>四则运算符</strong></h4><p>加法运算规则：</p>
<ol>
<li>其中一方是字符串类型，另外一方亦然</li>
<li>其中一方是数字类型，另外一方亦然</li>
<li>只会触发三种类型转换：值 =&gt; 原始值, =&gt; 数字，=&gt; 字符串</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">'1'</span> <span class="comment">// 11</span></span><br><span class="line"><span class="number">2</span> * <span class="string">'2'</span> <span class="comment">// 4</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>] +[<span class="number">2</span>,<span class="number">1</span>] <span class="comment">// '1,22,1'</span></span><br><span class="line"><span class="comment">// [1,2].toString -&gt; '1,2'</span></span><br><span class="line"><span class="comment">// [2,1].toString -&gt; '2,1'</span></span><br><span class="line"><span class="string">'1,2'</span>+ <span class="string">'2,1'</span> = <span class="string">'1,22,1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于加号要注意表达式 'a'++'b'</span></span><br><span class="line"><span class="string">'a'</span>++ <span class="string">'b'</span> <span class="comment">// 'aNaN'</span></span><br><span class="line"><span class="comment">// 因为 + 'b' 等于 NaN</span></span><br></pre></td></tr></table></figure>
<h4 id="操作符"><a href="#操作符" class="headerlink" title="== 操作符"></a><strong>== 操作符</strong></h4><p>比较运算 x==y,其中 x 和 y 是值，产生 true 或者 false ，这样的比较按下面的方式进行：</p>
<ol>
<li>若Type(x) 和 Type(y)相同，则<ol>
<li>若 Type(x) 为 undefined,返回 true</li>
<li>若 Type(x) 为 Null,返回 true</li>
<li>若 Type(x) 为 Number,则<ol>
<li>若 x 为 NaN,返回 false</li>
<li>若 y 为 NaN,返回 false</li>
<li>若 x 与 y 为相等数值，返回 true</li>
<li>若 x 为 +0, y 为 -0，返回 true</li>
<li>若 x 为 -0, y 为 +0，返回 true</li>
<li>返回 false</li>
</ol>
</li>
<li>若 Type(x) 为 String,则 x 和 y 为完全相同的字符序列（长度相等且相同字符在相同位置）时返回 true,否则，返回 false</li>
<li>若 Type(x) 为 Boolean,当 x 和 y 同为 true 或者同为 false 时返回 true,否则，返回 false。</li>
<li>当 x 和 y 为引用同一对象时返回 true,否则返回 false.</li>
</ol>
</li>
<li>若 x 为 null 且 y 为 undefined ，返回 true</li>
<li>若 x 为 undefined 且 y 为 null ,返回 true</li>
<li>若 Type(x) 为 Number,且 Type(y) 为 String,返回比较 x == toNumber(y) 的结果</li>
<li>若 Type(x) 为 String 且 Type(y) 为 Number,返回比较 ToNumber(x) == y 的结果</li>
<li>若 Type(x) 为 Boolean，返回 比较 ToNumber(x) ==y 的结果</li>
<li>若 Type(y) 为 Boolean,返回比较 ToNumber(y) ==x 的结果</li>
<li>若 Type(x) 为 String 或者 Number，且 Type(y) 为 Object,返回比较 x==ToPrimitive(y) 的结果</li>
<li>若 Type(y) 为 String 或者 Number，且 Type(x) 为 Object,返回比较 y==ToPrimitive(x) 的结果</li>
<li>返回 false</li>
</ol>
<p>toPrimitive 就是对象转基本类型</p>
<p>对照上面的规则，分析下面的案例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[] == ![] <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 由于 ！优先级大于 ==，所以先运算右边，[] 为 true, ![] 取反为 false，得出</span></span><br><span class="line">[] == <span class="literal">false</span></span><br><span class="line"><span class="comment">// 根据第7条规则 ToNumber(y) ==x ，得出</span></span><br><span class="line">[] == <span class="number">0</span></span><br><span class="line"><span class="comment">// 根据第9条规则， y==ToPrimitive(x)，得出</span></span><br><span class="line">ToPrimitive([]) == <span class="number">0</span></span><br><span class="line"><span class="comment">// 即是</span></span><br><span class="line">[].toString() == <span class="number">0</span></span><br><span class="line"><span class="comment">// 得出</span></span><br><span class="line"><span class="string">''</span> == <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 根据第5条规则，ToNumber(x) == y 得出</span></span><br><span class="line"><span class="number">0</span> == <span class="number">0</span> <span class="comment">// -&gt;true</span></span><br></pre></td></tr></table></figure>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a><strong>比较运算符</strong></h4><ol>
<li>如果是对象，就通过 toPrimitive 转换对象</li>
<li>如果是字符串，就通过 unicode 字符索引来比较</li>
</ol>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p><img src="./images/前端面试题目汇总摘录-JS 基础篇2-原型.png" alt="原型"></p>
<p>每个函数都有 prototype 属性，除了 Function.prototype.bind() 该属性指向原型。</p>
<p>每个对象都有 <code>__proto__</code>属性，指向了创建该对象的构造函数的原型，其实这个属性指向了 <code>[[proptotype]]</code>，但是 <code>[[proptotype]]</code>是内部属性，我们并不能访问到，所以使用 <code>__proto__</code>来访问。对象可以通过 <code>__proto__</code>来寻找不属于该对象的属性，<code>__proto__</code>将对象连接起来形成了原型链。</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><ol>
<li>新生成了一个对象</li>
<li>链接到原型</li>
<li>绑定 this</li>
<li>返回新对象</li>
</ol>
<p>在调用 new 的过程会发生上面四种事情，下面是自己实现的一个 new</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">// 获得构造函数</span></span><br><span class="line">    <span class="keyword">let</span> Con = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 链接到原型</span></span><br><span class="line">    Obj.__proto__. = Con.prototype;</span><br><span class="line">    <span class="comment">// 绑定 this,执行构造函数</span></span><br><span class="line">    <span class="keyword">let</span> result = Con.apply(obj,<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 确保 new 出来的是个对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result == <span class="string">'Object'</span> ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于实例对象来说，都是通过 new 产生的，无论是 function Foo(){} 还是 let a = {b:1}</p>
<p>对于创建一个对象来说，更推荐使用字面量的方式来创建对象（无论是性能上还是可读性）。使用 new Object 方式创建对象需要通过作用域链一层层找到 Object，但是使用字面量就没有这个困扰</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">// function 就是个语法糖，相当于 new Function()</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">b</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">// 这个字面量也是使用了 new Object();</span></span><br></pre></td></tr></table></figure>
<p>对于 new 来说，还需要注意下面的运算符优先级</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Foo.getName(); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>可以看出 new Foo() 优先级大于 new Foo,所以代码可以这样划分执行顺序</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (Foo.getName())</span><br><span class="line">(<span class="keyword">new</span> Foo).getName();</span><br></pre></td></tr></table></figure>
<p>对于第一个函数来说，先执行了 Foo.getName 所以结果为1，对于后者来说，先 new Foo() 产生了一个实例，然后通过原型链找到了 Foo 上面的 getName 函数，所以结果为 2</p>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instanceof 可以正确判断对象的类型，因为内部机制是通过判断对象的原型链是不是能找到类型的 prototype </p>
<p>我们也可以试着实现:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceof</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 获得类型的原型</span></span><br><span class="line">    <span class="keyword">let</span> prototype = right.prototype;</span><br><span class="line">    <span class="comment">// 获得对象的原型</span></span><br><span class="line">    left = left.__Proto__;</span><br><span class="line">    <span class="comment">// 判断对象的类型是否等于类型的原型</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left === <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(prototype === left)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        left = left.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this 记住几个规则就可以了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">foo();</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">2</span>,</span><br><span class="line">    foo:foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面两种情况 this 只依赖调用函数前的对象，优先级是第二个情况大于第一个情况</span></span><br><span class="line"><span class="comment">// 下面的优先级是最高的，this 只会绑定在c 上面，不会被任何方式修改 this 指向</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> foo();</span><br><span class="line">c.a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(c.a); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//还有一种情况是利用 call,apply或者 bind 改变 this，这个优先级仅次于 new</span></span><br></pre></td></tr></table></figure>
<p>箭头函数中的 this </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a()()());</span><br></pre></td></tr></table></figure>
<p>箭头函数其实是没有 this，这个函数中的 this 只取决于外面的第一个不是箭头函数的函数的this 。在上面的例子中，因为调用 a 符合前面代码的第一种情况，所以 this 是 window，并且一旦 this 绑定上下文了，就不会被任何代码改变。</p>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>当执行 JS 代码的时候，会产生三种执行上下文</p>
<ul>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
<li>eval 执行上下文</li>
</ul>
<p>每个执行上下文都有三个重要的属性</p>
<ul>
<li>变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问</li>
<li>作用域链（JS 采用词法作用域，也就是说变量的作用域是在定义时就决定的）</li>
<li>this</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>对于上述代码，执行栈中有两个上下文：全局上下文和函数 foo 上下文</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack = [</span><br><span class="line">    globalContext,</span><br><span class="line">    fooContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>对于全局上下文来说，VO 大概是这样的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">globalContext.VO === global</span><br><span class="line">globalContext.VO = &#123;</span><br><span class="line">    a:<span class="literal">undefined</span>,</span><br><span class="line">    foo:<span class="xml"><span class="tag">&lt;<span class="name">Function</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>对于 函数 foo 来说，VO 不能被访问，只能访问到活动对象（AO）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fooContext.VO === foo.AO</span><br><span class="line">fooContext.AO = &#123;</span><br><span class="line">    i:<span class="literal">undefined</span>,</span><br><span class="line">    b:<span class="literal">undefined</span>,</span><br><span class="line">    <span class="built_in">arguments</span>:<span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">// arguments 是函数底油的对象（箭头函数没有），这个对象是一个伪数组，有 length 属性可以通过下标访问元素，该对象的 callee 属性代表函数本身，caller 属性代表函数的调用者</span></span><br></pre></td></tr></table></figure>
<p>对于作用域链，可以把它理解为包含自身变量对象和上级变量对象的列表，通过 [[Scope]] 属性查找上级变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fooContext.[[Scope]] = [ globalContext.VO ]</span><br><span class="line">fooContext.Scope = fooContext.[[Scope]] + fooContext.VO</span><br><span class="line">fooContext.Scope = [</span><br><span class="line">    fooContext.Vo,</span><br><span class="line">    globalContext.Vo</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>举个例子，var</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b(); <span class="comment">// hehe</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'haha'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hehe'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的结果是因为函数和变量提升的原因。通常替身的解释是说将生命的代码移到了顶部，这其实没有什么错误，便于理解。但是更准确的解释应该是：在生成执行上下文时，会有两个阶段。第一个阶段是创建的阶段（具体步骤是创建 VO），JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数放入内存中，变量只声明并且赋值为 undefined，所以在第二个阶段，也就是代码的执行阶段，我们可以直接提前使用。</p>
<p>在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b(); <span class="comment">//2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'haha'</span>;</span><br></pre></td></tr></table></figure>
<p>var 会产生很多错误，所以现在 ES6 中引入了 let，let 不能在声明前使用，但是这并不是常说的 let 不会提升，let 提升了声明但是没有赋值，因为临时死区导致了并不能在声明前使用</p>
<p>对于非匿名立即执行函数需要注意下面的问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    foo = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**ƒ foo() &#123;</span></span><br><span class="line"><span class="comment">    foo = 10</span></span><br><span class="line"><span class="comment">    console.log(foo)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>因为当 JS 解释器在遇到非匿名的理解执行函数时，会创建一个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 foo，但是这个值又是只读的，所以对它的赋值并不会生效，所以打印出来的还是这个函数，并且外部的值也没有任何改变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">specialObject = &#123;&#125;</span><br><span class="line">Scope = specialObject + Scope;</span><br><span class="line">foo = <span class="keyword">new</span> FunctionExpression;</span><br><span class="line">foo.[[Scope]] = Scope;</span><br><span class="line">specialObject.foo = foo; <span class="comment">// &#123;DontDelete&#125;, &#123;ReadOnly&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> Scope[<span class="number">0</span>]; <span class="comment">// remove specialObject from the front of scope chain</span></span><br></pre></td></tr></table></figure>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包的定义很简单：函数 A 返回一个函数 B，并且函数 B 中使用了 函数 A 的变量，函数 B就被称为闭包</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数 A 中的变量这时候是存储在堆上的，JS 引擎可以通过逃逸分析辨别哪些变量需要存储在对上，哪些需要存储在栈上。</p>
<p>循环中使用闭包解决 var 定义函数的问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;,i*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，因为 setTimeout 是异步函数，所以回先把所有U型你换全部执行完毕，这时候 i 就是 6了，所以会输出一堆 6.</p>
<p>解决的方法有两种，第一种是使用闭包</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j)</span><br><span class="line">        &#125;,j*<span class="number">1000</span>);</span><br><span class="line">    &#125;)(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种是使用 setTimeout 的第三个参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;,i*<span class="number">1000</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三种就是使用 let 定义 i</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;,i*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为对于 let 来说，会创建一个块级作用域，相当于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 形成块级作用域</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> ii = i;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(ii);</span><br><span class="line">        &#125;,i*<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> ii = i</span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> ii = i</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">a.age = <span class="number">2</span>;</span><br><span class="line">b.age; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>从上述例子可以看出，如果给一个变量赋值一个对象，那么两者的值会是同一引用，其中一方改变，另一方也会相应改变。</p>
<p>通常在开发中，我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个问题。</p>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a><strong>浅拷贝</strong></h4><p>首先可以通过 <code>Object.assign</code> 来解决这个问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;,a);</span><br><span class="line">a.age = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.age); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>也可通过展开运算符（…）来解决</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">    ...a</span><br><span class="line">&#125;</span><br><span class="line">a.age = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.age); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>通常拷贝能解决大部分问题，但是当我们遇到下面的情况就需要使用深拷贝了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age:<span class="number">1</span>,</span><br><span class="line">    jobs:&#123;</span><br><span class="line">        first:<span class="string">'FE'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">    ...a</span><br><span class="line">&#125;</span><br><span class="line">a.job.first = <span class="string">'native'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first); <span class="comment">// native</span></span><br></pre></td></tr></table></figure>
<p>浅拷贝只解决了第一层问题，如果接下去的值中还有对象的话，那么两者又享有相同的引用，要解决这个问题，要引入深拷贝。</p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a><strong>深拷贝</strong></h4><p>这个问题通常可以通过 <code>JSON.parse(JSON.stringify(object))</code>来解决</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age:<span class="number">1</span>,</span><br><span class="line">    jobs:&#123;</span><br><span class="line">        first:<span class="string">'FE'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a));</span><br><span class="line">a.jobs.first = <span class="string">'native'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first); <span class="comment">// 'FE'</span></span><br></pre></td></tr></table></figure>
<p>但是该方法也是有局限性的：</p>
<ul>
<li>会忽略 <code>undefined</code></li>
<li>会忽略 <code>symbol</code></li>
<li>不能序列化函数</li>
<li>不能解决循环引用的对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:&#123;</span><br><span class="line">        c:<span class="number">2</span>,</span><br><span class="line">        d:<span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.c = obj.b;</span><br><span class="line">obj.e = obj.a;</span><br><span class="line">obj.b.c = obj.c</span><br><span class="line">obj.b.d = obj.b</span><br><span class="line">obj.b.e = obj.b.c</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(newObj);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Converting circular structure to JSON</span></span><br><span class="line"><span class="comment">//   at JSON.stringify (&lt;anonymous&gt;)</span></span><br><span class="line"><span class="comment">//   at &lt;anonymous&gt;:14:30</span></span><br></pre></td></tr></table></figure>
<p>在遇到函数、undefined或者 symbol 的时候，该对象也不能正常的序列化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age:<span class="literal">undefined</span>,</span><br><span class="line">    sex:<span class="built_in">Symbol</span>(<span class="string">'male'</span>),</span><br><span class="line">    jobs:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    name:<span class="string">'haha'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a));</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// &#123;name:'haha'&#125;</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，该方法会忽略掉函数和 <code>undefined</code></p>
<p>但是在通常情况下，复杂数据是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。数据中含有以上三种情况下，可以使用 <a href="https://lodash.com/docs##cloneDeep">lodash 的深拷贝函数</a>。</p>
<p>如果所需要拷贝的对象含有内置类型并且不包括函数的，可以使用 MessageChannel</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">structuralClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;port1,port2&#125; = <span class="keyword">new</span> MessageChannel;</span><br><span class="line">        port2.onmessage = <span class="function"><span class="params">ev</span> =&gt;</span> resolve(ev.data);</span><br><span class="line">        port1.postMessage(obj)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:&#123;</span><br><span class="line">       c:b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该方法是异步的</span></span><br><span class="line"><span class="comment">// 可以循环处理 undefined 和循环引用对象</span></span><br><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> clone = <span class="keyword">await</span> structualClone(obj)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>我们也可以自己创建一个 deepClone 函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字 字符串 function 不需要拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCline</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value == <span class="literal">null</span>) <span class="keyword">return</span> value;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> value !== <span class="string">'object'</span>) <span class="keyword">return</span> value;</span><br><span class="line">    <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(value);</span><br><span class="line">    <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value)</span><br><span class="line">    <span class="comment">// 判断是数组还是对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> value.constructor;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> ket <span class="keyword">in</span> value)&#123;</span><br><span class="line">        obj[key] = deepClone(value[key])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>在有 Babel 的情况下， 可以直接使用 ES6 的模块化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file a.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;a,b&#125; <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"><span class="keyword">import</span> XXX <span class="keyword">from</span> <span class="string">'./b.js'</span></span><br></pre></td></tr></table></figure>
<h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a><strong>CommonJS</strong></h4><p>CommonJS 是 Node 独有的规范，浏览器中使用就需要用到 Broserify 解析</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    a:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span>.a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="built_in">module</span>.a <span class="comment">// -&gt; log 1</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，module.export 和 export 很容易混淆，看看大致的内部实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="built_in">module</span>.a</span><br><span class="line"><span class="comment">// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，重要的是 module 这里，module 是 Node 独有的一个变量</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    a:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 基本实现</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">    exports:&#123;&#125; <span class="comment">// exports 就是空对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这也是为什么 exports 和 module.exports 用法相似的原因</span></span><br><span class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports;</span><br><span class="line"><span class="keyword">var</span> load = <span class="function"><span class="keyword">function</span>(<span class="params">module</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">module</span>.exports = a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>module.exports 和 exports 用法其实是相似的，但是不能对 exports 直接赋值，不会有任何效果。</p>
<p>对于 CommonJS 和 ES6 的模块化的两者区别是：</p>
<ul>
<li>前者支持动态导入，也就是 require(${path}/xx.js),后者不支持，但是已有提案</li>
<li>前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li>
<li>前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想要更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li>
<li>后者会编译成 require/exports 来执行</li>
</ul>
<h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a><strong>AMD</strong></h4><p>AMD 是由 RequireJS 提出的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'./a.js'</span>,<span class="string">'./b.js'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    a.do();</span><br><span class="line">    b.do();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require,exports,module</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line">    b.doSomething();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="节流和防抖的理解"><a href="#节流和防抖的理解" class="headerlink" title="节流和防抖的理解"></a>节流和防抖的理解</h3><p>防抖和节流都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于 wait，防抖的情况只会调用一次，而节流的情况会隔一定时间（参数wait）调用函数</p>
<h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a><strong>防抖</strong></h4><p>在滚动事件中需要做一个复杂计算或者是实现一个按钮防止第二次点击操作。这些需求都可以通过函数防抖来实现，尤其是第一个需求，如果在频繁的时间回调中做复杂计算，很有可能会导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。</p>
<p>通俗化：如果用手指一直按着弹簧，它将不会弹起知道你松手为止</p>
<p>袖珍版的防抖：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func 是用户传入需要防抖的函数</span></span><br><span class="line"><span class="comment">// wait 是等待时间</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">func,wait = <span class="number">50</span></span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 缓存一个定时器id</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 返回的函数是每次用户实际调用防抖函数，如果已经设定过定时器就清空上一次的定时器，开始一个新的定时器，延迟用户传入的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">..args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            func.apply(<span class="keyword">this</span>,args);</span><br><span class="line">        &#125;,wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不难看出来如果用户调用该函数间隔小于 wait 的情况下，上一次时间还未到就被清除了，并不会执行函数。</span></span><br></pre></td></tr></table></figure>
<p>这是一个简单的防抖，但是有缺陷，在于它只能最后调用。一般的防抖会有 immediate 选项，表示是否立即调用。这两者的区别：</p>
<ul>
<li>例如在搜索引擎搜索问题的时候，我们当然希望用户输入完最后一个字才调用查询接口，这个时候用 <code>延迟执行</code> 的防抖函数，它总是在一连串（间隔小于 wait）函数触发之后调用</li>
<li>例如用户给项目点 star 的时候，我们希望用户点第一下的时候就去调用接口，并成功之后改变 star 按钮的样子，用户就可以立马得到反馈是否 star 成功了，这个情况使用 <code>立即调用</code>的防抖函数，它总在第一次调用，并且下一次调用必须和前一次调用的时间间隔大于 wait 才会触发。</li>
</ul>
<p>带有立即执行的防抖函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个用来获取当前时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">now</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 防抖函数，返回函数连续调用，空闲时间必须大于或者等于 wait,func 才会执行</span></span><br><span class="line"><span class="comment">* @param &#123;function&#125; func 回调函数</span></span><br><span class="line"><span class="comment">* @param &#123;number&#125; wait 表示窗口的间隔</span></span><br><span class="line"><span class="comment">* @param &#123;boolean&#125; immediate 设置为 true时，是否立即调用函数</span></span><br><span class="line"><span class="comment">* @return &#123;function&#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait=<span class="number">50</span>,immediate=true</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer,context,args;</span><br><span class="line">    <span class="comment">// 延迟执行函数</span></span><br><span class="line">    <span class="keyword">const</span> later = <span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 延迟执行函数执行完毕，清除缓存的定时器序号</span></span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 延迟执行的情况下，函数会在延时函数中执行，使用到之前缓存的参数和上下文</span></span><br><span class="line">        <span class="keyword">if</span>(!immediate)&#123;</span><br><span class="line">           func.apply(context,args);</span><br><span class="line">            context = args = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,wait)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里返回的函数是每次实际调用的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...params</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 如果没有创建样式执行函数（later）,那就创建一个</span></span><br><span class="line">        <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">           timer = later();</span><br><span class="line">           <span class="comment">// 如果是立即执行，调用函数，否则缓存参数和调用上下文</span></span><br><span class="line">            <span class="keyword">if</span>(immediate)&#123;</span><br><span class="line">               func.apply(<span class="keyword">this</span>,params);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                context = <span class="keyword">this</span>;</span><br><span class="line">                args = params</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 如果已有延迟执行函数（later） ，调用的时候清除原来的并重新设定一个</span></span><br><span class="line">        <span class="comment">// 这样做延迟函数会重新计时</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = later();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总结一下：</p>
<ul>
<li>对于按钮点击来说的实现:如果函数是立即执行的，就理解调用，如果函数是延迟执行的，就缓存上下文和参数，放到延迟函数中执行，一旦开始一个定时器，只要定时器还在，每次点击都会重新计时。一旦定时器时间到了，定时器重置为null,就可以再次点击了。</li>
<li>对于延迟函数来说的实现：清除定时器ID，如果是延迟调用就调用函数</li>
</ul>
<h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a><strong>节流</strong></h4><p>防抖和节流本质上是不一样的。防抖是将多次执行变成最后一次执行，节流是将多次执行变成每隔一段时间执行。</p>
<p>通俗化：如果将水龙头拧紧直到水是以水滴的形式流出，那么你会发现隔一段时间，就会有一滴水溜出来。也就是会预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个周期</p>
<p>袖珍版实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">wait,func</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> curr = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">if</span>(curr - last &gt; wait)&#123;</span><br><span class="line">           func.apply(<span class="keyword">this</span>,args);</span><br><span class="line">            last = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* underscore 节流函数，返回函数连续调用，func 执行频率是 次/wait</span></span><br><span class="line"><span class="comment">* @param &#123;function&#125; func 回调函数</span></span><br><span class="line"><span class="comment">* @param &#123;number&#125; wait 表示窗口的间隔</span></span><br><span class="line"><span class="comment">* @param &#123;object&#125; options 如果想忽略开始函数的调用，传入&#123;leading:false&#125;,如果想忽略结尾函数则是&#123;trailing:false&#125;,两者不能共存，否则函数不执行。</span></span><br><span class="line"><span class="comment">* @return &#123;function&#125; 返回客户调用的函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">_.throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func,wait,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context,args,result;</span><br><span class="line">    <span class="keyword">let</span> timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 之间的时间戳</span></span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果 options 没传则设置为空对象</span></span><br><span class="line">    <span class="keyword">if</span>(!options) options = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 定时器回调函数</span></span><br><span class="line">    <span class="keyword">const</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 如果设置了 leading,就将 previous 设为0，用于下一个函数的第一个 if 判断</span></span><br><span class="line">        previous = options.length === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</span><br><span class="line">        <span class="comment">// 置空是为了防止内存泄露，也是为了下面定时器的判断</span></span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        result = func.apply(context,args);</span><br><span class="line">        <span class="keyword">if</span>(!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 获得当前的时间戳</span></span><br><span class="line">        <span class="keyword">const</span> now = _.now;</span><br><span class="line">        <span class="comment">// 首先进入前者肯定要为 true,如果需要第一次不执行函数，就将上次时间戳设定为当前的，就下来的计算中 remaining 的值时会大于0</span></span><br><span class="line">        <span class="keyword">if</span>(previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">        <span class="comment">// 计算剩下的时间</span></span><br><span class="line">        <span class="keyword">const</span> remaining = wait - (now - previous);</span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="comment">// 如果当前调用给意见大于上次时间 + wait，或者用户手动调了事件，如果设置 trailing，只会进入这个条件</span></span><br><span class="line">        <span class="keyword">if</span>(remaining &lt;= <span class="number">0</span> || remaining &gt; wait)&#123;</span><br><span class="line">            <span class="comment">// 如果存在定时器就清理掉否则会调用二次回调</span></span><br><span class="line">            <span class="keyword">if</span>(timeout)&#123;</span><br><span class="line">               clearTimeout(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line">            previous = now;</span><br><span class="line">            result = func.apply(context,args);</span><br><span class="line">            <span class="keyword">if</span>(!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!timeout &amp;&amp;options.trailing !== <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="comment">// 判断是否设置了定时器和 trailing ，没有的话就开启一个定时器，并且不能同时设置 leading 和 trailing</span></span><br><span class="line">            timeout = setTimeout(later,remaining);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在 ES5 中，可以使用下面的方式解决继承的问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Super.prototype.getNumber = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Sub();</span><br><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype,&#123;</span><br><span class="line">    <span class="keyword">constructor</span>:&#123;</span><br><span class="line">        value:Sub,</span><br><span class="line">        enumerable:<span class="literal">false</span>,</span><br><span class="line">        writable:<span class="literal">true</span>,</span><br><span class="line">        configurable:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的继承实现思路就是将子类的原型设置为父类的原型</p>
<p>在 ES6 中，可以通过 class 语法糖解决这个问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDate</span> <span class="keyword">extends</span> <span class="title">Date</span></span>&#123;</span><br><span class="line">    test()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myDate = <span class="keyword">new</span> MyDate();</span><br><span class="line">myDate.test();</span><br></pre></td></tr></table></figure>
<h3 id="call-apply-bind-区别"><a href="#call-apply-bind-区别" class="headerlink" title="call,apply,bind 区别"></a>call,apply,bind 区别</h3><p>call 和 apply 都是为了解决改变 this  的指向，作用都是相同的，只是传参的方式不同，除了第一个参数外，call 可以接受一个参数列表，apply 只接受一个参数数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a =&#123;</span><br><span class="line">    value:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line">getValue.call(a,<span class="string">'haha'</span>,<span class="string">'24'</span>);</span><br><span class="line">getValue.apply(a,[<span class="string">'haha'</span>,<span class="string">'24'</span>]);</span><br></pre></td></tr></table></figure>
<h4 id="模拟实现-call-和-apply"><a href="#模拟实现-call-和-apply" class="headerlink" title="模拟实现 call 和 apply"></a><strong>模拟实现 call 和 apply</strong></h4><p>可以从下面几点来考虑如何实现</p>
<ul>
<li>不传入第一个参数，那么默认可以为 window</li>
<li>改变了 this 指向，让新的对象可以执行该函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    <span class="comment">// 给 context 添加一个属性</span></span><br><span class="line">    <span class="comment">// getValue.call(a,'haha',24) -&gt; a.fn('haha','24');</span></span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 将 context 后面的参数取出来</span></span><br><span class="line">    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> result = context.fn(...args);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除 fn</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>apply 的实现也是类似的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="comment">// 判断是否存在第二个参数，如果存在就把第二个参数展开</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">1</span>])&#123;</span><br><span class="line">    	result = context.fn(...arguments[<span class="number">1</span>]);   </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bind 和其他两个方法作用也是一样的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化</p>
<p>模拟实现 bind</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'undefined'</span>)&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> F)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> _this(..args,...arguments);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context,args.concat(...arguments));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-实现"><a href="#Promise-实现" class="headerlink" title="Promise 实现"></a>Promise 实现</h3><p>Promise 是 ES6 新增的语法，解决了回调地狱的问题。</p>
<p>可以把 Promise 看成一个状态机。初始状态是 pending 状态，可以通过函数 resolve 和 reject ，将状态转变为 resolved 和 rejected 状态，状态一旦改变就不能再发生变化了。</p>
<p>then 函数会返回一个 Promise 实例，并且该返回值是一个新的实例而不是之前的实例。因为 Promise 规范规定了 pending 状态，其他状态是不可以改变的，如果返回的是同一个实例的话，多个 then 调用就失去意义了。</p>
<p>对于 then 来说，本质上可以把它看成 flatMap</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line">  <span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span>;</span><br><span class="line">  <span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// promise 接受一个函数参数，该函数会理解执行</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    _this.currentState = PENDING;</span><br><span class="line">    _this.value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 用于保存 then 中的回调，只有当 promise 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class="line">    _this.resolvedCallbacks = [];</span><br><span class="line">    _this.rejectedCallbacks = [];</span><br><span class="line">    _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">        <span class="comment">// 如果 value 是个 Promise ，递归执行</span></span><br><span class="line">        <span class="keyword">return</span> value.then(_this.resolve, _this.reject);</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 异步执行，保证执行顺序</span></span><br><span class="line">        <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">          _this.currentState = RESOLVED;</span><br><span class="line">          _this.value = value;</span><br><span class="line">          _this.resolvedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">          _this.currentState = REJECTED;</span><br><span class="line">          _this.value = reason;</span><br><span class="line">          _this.rejectedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于解决下面的问题</span></span><br><span class="line">    <span class="comment">// new Promise(()=&gt; throw Error('error'))</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fn(_this.resolve, _this.reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      _this.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// then 函数的作用是为 Promise 实例添加状态改变时的回调函数。then 方法的第一个参数是 resolved 状态的回调函数，第二个参数（可选）是 rejected 状态的回调函数。</span></span><br><span class="line"><span class="comment">// then 方法返回的是一个新的 promise 实例，因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。</span></span><br><span class="line">  MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// then 必须返回一个新的 promise</span></span><br><span class="line">    <span class="keyword">let</span> promise2;</span><br><span class="line">    <span class="comment">// 如果 onResolved 和 onRejected 都为可选参数，如果类型不是函数需要忽略，同时也实现了透传</span></span><br><span class="line">    <span class="comment">// Promise.resolve(4).then().then((value)=&gt;console.log(value))</span></span><br><span class="line">    onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">'function'</span> ? onResolved : <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">r</span> =&gt;</span> &#123; <span class="keyword">throw</span> r &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self.currentState === RESOLVED) &#123;</span><br><span class="line">      <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onResolve(self.value);</span><br><span class="line">            resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">            reject(reason)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (self.currentState === REJECTED) &#123;</span><br><span class="line">      <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(self.value);</span><br><span class="line">            resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">            reject(reason)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (self.currentState === PENDING) &#123;</span><br><span class="line">      <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        self.rejectedCallbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(self.value);</span><br><span class="line">            resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (r) &#123;</span><br><span class="line">            reject(r)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        self.resolvedCallbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onResolved(self.value);</span><br><span class="line">            resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (r) &#123;</span><br><span class="line">            reject(r)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolutionProcedure</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// x 不能与 promise2 相同，避免循环</span></span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">      <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 x 为 Promise ，状态为 pending 需要继续等待否则执行</span></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x.currentState === PENDING) &#123;</span><br><span class="line">        x.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 再次调用该函数是为了确认 x resolve 的 参数是什么类型，如果是基本类型就再次 resolve，把值传给下一个 then</span></span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">        &#125;, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x.then(resolve, reject);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reject 或者 resolve 其中一个执行得过的话，忽略其他的</span></span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 判断 x 是否为对象或者是函数</span></span><br><span class="line">    <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">      <span class="comment">// 如果不能取出 then ，就 reject</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> then = x.then;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">          then.call(</span><br><span class="line">            x,</span><br><span class="line">            y =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">              called = <span class="literal">true</span>;</span><br><span class="line">              resolutionProcedure(promise2, y, resolve, reject);</span><br><span class="line">            &#125;,</span><br><span class="line">            e =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">              called = <span class="literal">true</span>;</span><br><span class="line">              reject(e);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(x)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Generator-实现"><a href="#Generator-实现" class="headerlink" title="Generator 实现"></a>Generator 实现</h3><p>Generator 是 ES6 中新增的语法，和 Promise 一样，都可以用异步来编程。</p>
<p>Generator 函数也可以理解成为一个状态机，封装了多个内部状态。</p>
<p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<p>形式上，Generator 函数是一个普通函数，但是有两个特征。一个是 function 关键字与函数名之间有一个 星号，二是函数内部使用 yield 表达式，表示不同的内部状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 * 表示这是一个 Generator 函数</span></span><br><span class="line"><span class="comment">// 内部可以使用 yield 暂停代码</span></span><br><span class="line"><span class="comment">// 调用 next 恢复执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = test();</span><br><span class="line">b.next(); <span class="comment">// &#123;value:2,done:false&#125;</span></span><br><span class="line">b.next(); <span class="comment">// &#123;value:3,done:false&#125;</span></span><br><span class="line">b.next(); <span class="comment">// &#123;value:undefined,done:true&#125;</span></span><br></pre></td></tr></table></figure>
<p>上述代码可以发现，加上 * 的函数执行后拥有了 next 函数，也就是说函数执行后返回了一个对象。每次调用 next 函数可以继续执行被暂停的代码，下面是 Generator 的简单实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cb 也就是编译的 test 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyGerenator</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> object = &#123;</span><br><span class="line">      next: <span class="number">0</span>,</span><br><span class="line">      stop: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> ret = cb(obj);</span><br><span class="line">        <span class="keyword">if</span> (ret === <span class="literal">undefined</span>) <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: ret,</span><br><span class="line">          done: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 babel 编译后可以发现 test 函数变成了这样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a;</span><br><span class="line">  <span class="keyword">return</span> MyGerenator(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> ((_context.prev = _context.next)) &#123;</span><br><span class="line">        <span class="comment">// 可以发现通过 yield 将代码分成了几块，每次执行 next 函数就执行一块代码，并且表明下次需要执行哪块代码</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">          _context.next = <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">          _context.next = <span class="number">6</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'end'</span>:</span><br><span class="line">          <span class="keyword">return</span> _context.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一道题目"><a href="#一道题目" class="headerlink" title="一道题目"></a>一道题目</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span>(x+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">let</span> z = <span class="keyword">yield</span>(y/<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> (x+y+z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(it.next())   <span class="comment">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">12</span>)) <span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">13</span>)) <span class="comment">// =&gt; &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>分析：</p>
<ul>
<li>首先 <code>Generator</code> 函数调用和普通函数不同，它会返回一个迭代器</li>
<li>当执行第一次 <code>next</code> 时，传参会被忽略，并且函数暂停在 <code>yield (x + 1)</code> 处，所以返回 <code>5 + 1 = 6</code></li>
<li>当执行第二次 <code>next</code> 时，传入的参数等于上一个 <code>yield</code> 的返回值，如果你不传参，<code>yield</code> 永远返回 <code>undefined</code>。此时 <code>let y = 2 * 12</code>，所以第二个 <code>yield</code> 等于 <code>2 * 12 / 3 = 8</code></li>
<li>当执行第三次 <code>next</code> 时，传入的参数会传递给 <code>z</code>，所以 <code>z = 13, x = 5, y = 24</code>，相加等于 <code>42</code></li>
</ul>
<h3 id="Map、FlatMap-和-Reduce"><a href="#Map、FlatMap-和-Reduce" class="headerlink" title="Map、FlatMap 和 Reduce"></a>Map、FlatMap 和 Reduce</h3><p>Map 的作用是生成一个数组，遍历原数组，将每个元素拿出来然后做一些变换然后 append 到新的数组中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">v</span>=&gt;</span>v+<span class="number">1</span>);</span><br><span class="line"><span class="comment">// [2,3,4]</span></span><br></pre></td></tr></table></figure>
<p>Map 有三个参数，分别是当前索引元素，索引，原数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>].map(<span class="built_in">parseInt</span>);</span><br><span class="line"><span class="comment">// parseInt('1',0) -&gt; 1</span></span><br><span class="line"><span class="comment">// parseInt('2',1) -&gt; NaN</span></span><br><span class="line"><span class="comment">// parseInt('3',2) -&gt; NaN</span></span><br></pre></td></tr></table></figure>
<p>FlatMap 和 map 的作用几乎是相同的，但是对于多维数组来说，会将原数组降维。可以将 FlatMap 看成是 map + flatten ，目前该函数在浏览器中还不支持。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,[<span class="number">2</span>],<span class="number">3</span>].flatMap(v=v+<span class="number">1</span>);</span><br><span class="line"><span class="comment">// [2,3,4]</span></span><br></pre></td></tr></table></figure>
<p>如果想将一个多维数组彻底的降维，可以这样实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flattenDeep = <span class="function"><span class="params">arr</span> =&gt;</span> <span class="built_in">Array</span>.isArray(arr) ? arr.reduce(<span class="function">(<span class="params">a,b</span>)=&gt;</span>[...a,...flattenDeep(b)],[]):[arr];</span><br><span class="line">flattenDeep([<span class="number">1</span>,[[<span class="number">2</span>],[<span class="number">3</span>,[<span class="number">4</span>]],<span class="number">5</span>]]);</span><br><span class="line"><span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p>Reduce 作用是数组中的值组合起来，最终得到一个值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">[a,b].reduce(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a(b()));</span><br></pre></td></tr></table></figure>
<h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h3><p>一个函数如果加上 async,那么该函数就会返回一个 Promise</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test()); <span class="comment">// -&gt; Promise &#123;&lt;resolved&gt;: "1"&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以把 async 看成函数返回值使用 Promise.resolve() 包裹了下。</p>
<p>await 只能在 async 函数中使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'finish'</span>);</span><br><span class="line">            resolve(<span class="string">'sleep'</span>);</span><br><span class="line">        &#125;,<span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">await</span> sleep();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'object'</span>);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p>上面代码会先打印 <code>finish</code> 然后再打印 <code>object</code> 。因为 <code>await</code> 会等待 <code>sleep</code> 函数 <code>resolve</code> ，所以即使后面是同步代码，也不会先去执行同步代码再来执行异步代码。</p>
<p>async 和 await 相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码。缺点在于滥用 await 可能会导致性能问题，因为 await 会阻塞代码，也许之后的异步代码并不依赖前者，但仍然需要等待前者完成，导致代码失去了并发性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">async</span>() =&gt;&#123;</span><br><span class="line">    a = a + <span class="keyword">await</span> <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>,a);</span><br><span class="line">    a = (<span class="keyword">await</span> <span class="number">10</span>) + a;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>,a);</span><br><span class="line">&#125;</span><br><span class="line">b();</span><br><span class="line">a++</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>,a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// VM3859:10 1 1</span></span><br><span class="line"><span class="comment">// VM3859:4 2 10</span></span><br><span class="line"><span class="comment">// VM3859:6 3 20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>首先函数 b 执行，在执行到了 await 10 之前 a 的变量还是 0，因为在 await 内部实现了generators ,generators 会保留堆栈中东西，a=0 被保存下来。</li>
<li>因为 await 是异步操作，遇到 await 会立即返回一个 pending 状态的 promise 对象，暂时返回执行代码的控制权，使得函数外的代码得以继续执行，所以会先执行 同步代码 console.log(‘1’,a);</li>
<li>同步代码之后就是异步代码，将保存下来的值拿出来用，这时候 a = 10</li>
<li>后面就是常规的执行代码了</li>
</ul>
<h3 id="常用的定时器函数"><a href="#常用的定时器函数" class="headerlink" title="常用的定时器函数"></a>常用的定时器函数</h3><p>相关面试题：setTimeout、setInterval、requestAnimationFrame 各有什么特点？</p>
<h4 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a><strong>requestAnimationFrame</strong></h4><p>请求动画帧。屏幕刷新频率，也就是屏幕上的图像每秒钟出现的次数，它的单位是赫兹（HZ）。当对着电脑屏幕什么也不做的情况下，显示器也会以每秒60次的频率在不断更新屏幕上的图像。我们之所以感觉不到变化的原因是因为人的眼睛有视觉停留效应，画之间间隔时间只有16.7ms（1000/60)，所以我们会觉得屏幕上的图像是静止不动的。</p>
<p>动画的本质就是要让人眼看到图像被刷新而引起的变化的视觉效果，这个变化要以连贯的平滑的方式过渡。</p>
<p>我们在每次刷新前，将图像的位置移动一个像素，这样一来，屏幕每次刷新出来的图像位置都比前一个要差一个像素。因为你会看到图像在移动，由于人眼的视觉停留效应，当前位置的图像停留在大脑的影响还没有消失，紧接着图像又被移到了下一个位置，因为你会看到图像在流畅地移动，这就是视觉效果上形成的动画。</p>
<p>requestAnimationFrame最大的优势就是系统决定的回调函数的执行时机，大概的意思就是回调函数会随着屏幕刷新的频率的变化而产生对应的变化。它能保证回调函数在屏幕每一次的刷新间隔中只执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。</p>
<p>简单的调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> progress = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    progress +=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(progress&lt;<span class="number">100</span>)&#123;</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame(render)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一帧渲染</span></span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(render);</span><br></pre></td></tr></table></figure>
<p>另外它还有两个优势：</p>
<ul>
<li>Cpu节能：使用 setTimeout 实现的动画，当页面被隐藏到最小化时，仍然会在后台执行动画人物，由于此时页面处于不可见或者不可用状态，刷新画面也是没有意义的，完全是浪费资源。而 requestAnimationFrame 则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新人物也会被系统暂停，有效节省CPU 开销</li>
<li>函数节流：在高频率（resize,scroll）中吗，为了防止在一个刷新间隔内发生多出函数执行，使用 requestAnimationFrame 可以保证每个刷新的间隔内，函数只被执行一次，这样既可以保证流畅性，也能更好的节省函数执行的开销。一个刷新间隔内函数执行多次是没有意义的，因为显示器刷新的频率是一定的，多次绘制不会在屏幕上体现出来。</li>
</ul>
<p>由于浏览器兼容问题，需要优雅降级做兼容，具体代码,摘自 <a href="https://github.com/darius/requestAnimationFrame/blob/master/requestAnimationFrame.js">requestAnimationFrame</a>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Date</span>.now) &#123;</span><br><span class="line">  <span class="built_in">Date</span>.now = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> vendors = [<span class="string">'webkit'</span>, <span class="string">'moz'</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vendors.length &amp;&amp; !<span class="built_in">window</span>.requestAnimationFrame; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> vp = vendors[i];</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame = <span class="built_in">window</span>[vp + <span class="string">'RequestAnimationFrame'</span>];</span><br><span class="line">    <span class="built_in">window</span>.cancelAnimationFrame = <span class="built_in">window</span>[vp + <span class="string">'CancelAnimationFrame'</span>] || <span class="built_in">window</span>[vp + <span class="string">'CancelRequestAnimationFrame'</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/iP(ad|hone|od).*OS 6/</span>.test(<span class="built_in">window</span>.navigator.userAgent) || !<span class="built_in">window</span>.requestAnimationFrame || !<span class="built_in">window</span>.cancelAnimationFrame) &#123;</span><br><span class="line">      <span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">window</span>.requestAnimationFrame = <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">var</span> nextTime = <span class="built_in">Math</span>.max(lastTime + <span class="number">16</span>, now);</span><br><span class="line">        <span class="keyword">return</span> setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          cb(lastTime = nextTime)</span><br><span class="line">        &#125;, nextTime - now)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">window</span>.cancelAnimationFrame = clearTimeout;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a><strong>setTimeout</strong></h4><p>设置某个时间后执行某个动作，表示延时执行某个动作</p>
<h4 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a><strong>setInterval</strong></h4><p>设置每隔多久执行某个动作，循环的。setInterval 将注册函数植入 Event Queue,如果前面的任务耗能太久，那么就需要等待。</p>
<p>因为JS 单线程的问题，setTimeout 可能不会按期执行，可以通过代码去修正 setTimeout ，从而使定时器相对准确</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> period = <span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime + period;</span><br><span class="line"><span class="keyword">let</span> interval = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">let</span> currentInterval = interval;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="comment">// 代码执行所消耗的时间</span></span><br><span class="line">  <span class="keyword">let</span> offset = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * interval);</span><br><span class="line">  <span class="keyword">let</span> diff = end - <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  <span class="keyword">let</span> h = <span class="built_in">Math</span>.floor(diff / (<span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>))</span><br><span class="line">  <span class="keyword">let</span> hdiff = diff % (<span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>);</span><br><span class="line">  <span class="keyword">let</span> m = <span class="built_in">Math</span>.floor(hdiff / (<span class="number">60</span> * <span class="number">1000</span>));</span><br><span class="line">  <span class="keyword">let</span> mdiff = hdiff % (<span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">let</span> s = mdiff / (<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">let</span> sCeil = <span class="built_in">Math</span>.ceil(s);</span><br><span class="line">  <span class="keyword">let</span> sFloor = <span class="built_in">Math</span>.floor(s);</span><br><span class="line">  <span class="comment">// 得出下一次循环所消耗的时间</span></span><br><span class="line">  currentInterval = interval - offset;</span><br><span class="line">  setTimeout(loop, currentInterval);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'时：'</span> + h, <span class="string">'分：'</span> + m, <span class="string">'毫秒：'</span> + s, <span class="string">'秒向上取整：'</span> + sCeil, <span class="string">'代码执行时间：'</span> + offset, <span class="string">'下次循环间隔'</span> + currentInterval)</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(loop, currentInterval)</span><br></pre></td></tr></table></figure>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Proxy 是 ES6 中新增的功能，可以用来自定义对象中的操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,handler)</span><br><span class="line"><span class="comment">// target 代表需要添加代理的对象</span></span><br><span class="line"><span class="comment">// Handler 用来自定义对象中的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以很方便使用 Proxy 来实现一个数据的绑定和监听</span></span><br><span class="line"><span class="keyword">let</span> onWatch = <span class="function">(<span class="params">obj,setBind,getLogger</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> handler = &#123;</span><br><span class="line">        get(target,property,receiver)&#123;</span><br><span class="line">            getLogger(target,property)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target,property,receiver);</span><br><span class="line">        &#125;,</span><br><span class="line">        set(target,property,value,receiver)&#123;</span><br><span class="line">            setBind(value);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target,property,value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj,handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> value;</span><br><span class="line"><span class="keyword">let</span> pw = onWatch(obj,(v)=&gt;&#123;</span><br><span class="line">    value = v</span><br><span class="line">&#125;,(target,property)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Get <span class="subst">$&#123;property&#125;</span> = <span class="subst">$&#123;target[property]&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line">pw.a = <span class="number">2</span>; <span class="comment">// bind value to 2</span></span><br><span class="line">pw.a <span class="comment">// get a = 2</span></span><br></pre></td></tr></table></figure>
<h3 id="为什么-0-1-0-2-0-3"><a href="#为什么-0-1-0-2-0-3" class="headerlink" title="为什么 0.1 + 0.2 != 0.3"></a>为什么 0.1 + 0.2 != 0.3</h3><p>因为 JS 采用 IEEE 754 双精度版本（64位）,并且只要采用 IEEE 754 的语言都有该问题</p>
<p>原生解决方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>((<span class="number">0.1</span>+<span class="number">0.2</span>).toFixed(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><table>
<thead>
<tr>
<th>元字符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>匹配任意字符除了换行符和回车符</td>
</tr>
<tr>
<td>[]</td>
<td>匹配方括号内的任意字符。比如 [0-9] 就可以用来匹配任意数字</td>
</tr>
<tr>
<td>^</td>
<td>^9 这样使用匹配以 9 开头，[^9] 这样使用代表不匹配方括号内除了9的字符</td>
</tr>
<tr>
<td>{1,2}</td>
<td>匹配1到2位字符</td>
</tr>
<tr>
<td>(yck)</td>
<td>只匹配 yck 相同字符串</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>匹配 \</td>
<td>前后任意字符</td>
</tr>
<tr>
<td>\</td>
<td>转义</td>
</tr>
<tr>
<td>*</td>
<td>只匹配出现0次及以上 *前的字符</td>
</tr>
<tr>
<td>+</td>
<td>只匹配出现1次及以上 +前的字符</td>
</tr>
<tr>
<td>?</td>
<td>？ 之前字符可选</td>
</tr>
</tbody>
</table>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><table>
<thead>
<tr>
<th>修饰语</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>g</td>
<td>全局搜索</td>
</tr>
<tr>
<td>m</td>
<td>多行</td>
</tr>
</tbody>
</table>
<h4 id="字符简写"><a href="#字符简写" class="headerlink" title="字符简写"></a>字符简写</h4><table>
<thead>
<tr>
<th>简写</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>\w</td>
<td>匹配字母数字或下划线</td>
</tr>
<tr>
<td>\W</td>
<td>与上面相反</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意的空白符</td>
</tr>
<tr>
<td>\S</td>
<td>与上面相反</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\D</td>
<td>与上面相反</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词的开始或结束</td>
</tr>
<tr>
<td>\B</td>
<td>与上面相反</td>
</tr>
</tbody>
</table>
<h3 id="V8下的垃圾回收机制"><a href="#V8下的垃圾回收机制" class="headerlink" title="V8下的垃圾回收机制"></a>V8下的垃圾回收机制</h3><p>V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为了新生代和老生代两部分</p>
<h4 id="新生代算法"><a href="#新生代算法" class="headerlink" title="新生代算法"></a>新生代算法</h4><p>新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。</p>
<p>在新生代空间中，内存空间分为了两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满的时候，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成将 From 空间和 To 空间互换，这样 GC 就结束了。</p>
<h4 id="老生代算法"><a href="#老生代算法" class="headerlink" title="老生代算法"></a>老生代算法</h4><p>老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。</p>
<p>什么情况下对象会出现在老生代空间中：</p>
<ul>
<li>新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。</li>
<li>To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中</li>
</ul>
<p>老生代中的空间很复杂，有如下几个空间</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum AllocationSpace &#123;</span><br><span class="line">  // TODO(v8:7464): Actually map this space's memory as read-only.</span><br><span class="line">  RO_SPACE,    // 不变的对象空间</span><br><span class="line">  NEW_SPACE,   // 新生代用于 GC 复制算法的空间</span><br><span class="line">  OLD_SPACE,   // 老生代常驻对象空间</span><br><span class="line">  CODE_SPACE,  // 老生代代码对象空间</span><br><span class="line">  MAP_SPACE,   // 老生代 map 对象</span><br><span class="line">  LO_SPACE,    // 老生代大空间对象</span><br><span class="line">  NEW_LO_SPACE,  // 新生代大空间对象</span><br><span class="line"></span><br><span class="line">  FIRST_SPACE = RO_SPACE,</span><br><span class="line">  LAST_SPACE = NEW_LO_SPACE,</span><br><span class="line">  FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,</span><br><span class="line">  LAST_GROWABLE_PAGED_SPACE = MAP_SPACE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在老生代中，以下情况会先启动标记清除算法：</p>
<ul>
<li>某一个空间没有分块的时候</li>
<li>空间中被对象超过一定限制</li>
<li>空间不能保证新生代中的对象移动到老生代中</li>
</ul>
<p>在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行，你可以点击 <a href="https://v8project.blogspot.com/2018/06/concurrent-marking.html">该博客</a> 详细阅读。</p>
<p>清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。</p>
<h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p>两个名词都是 CPU 工作时间片的一个描述。</p>
<p>进程描述了 CPU 在运行指令以及记载和保存上下文所需的时间，放在应用上来说就代表了一个程序。</p>
<p>线程是进程中更小的单位，描述了一段指令所需要的时间。</p>
<p>在浏览器中，打开一个 Tab 页面，就是创建了一个进程，一个进程里面可以有多个线程，例如渲染线程，JS 引擎线程，HTTP 请求线程。当发起一个请求时，就是在创建一个线程，当请求结束的时候，该线程就可能会被销毁掉。</p>
<p>众所周知，JS 运行时会阻止 UI 渲染，这两个线程是互斥的，因为 JS 可以修改 Dom ，如果在 JS 执行的时候 Ui 线程还在工作，就可能会导致不能正常安全渲染 UI。这也是单线程的一个好处，得益于 JS 是单线程与很像的，可以达到节省呢欧村，节约上下文切换时间，没有锁的问题的好处。</p>
<h4 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h4><p>可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</p>
<h4 id="浏览器中的-Event-Loop"><a href="#浏览器中的-Event-Loop" class="headerlink" title="浏览器中的 Event Loop"></a>浏览器中的 Event Loop</h4><p>当遇到异步代码的时候，会被挂起并在需要执行的时候加入到 Task  队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要你执行的代码并放入执行栈中执行，所以本质上 JS 中的异步还是同步行为。</p>
<p>不同的任务源会被分配到不同的 Task 队列中，任务源可以分成 微任务（mocrotask） 和 宏任务（macrotask)。在 ES6 规范中，macrotask 被称为 task,microtask 被称为 jobs 。下面举个例子看看代码的执行顺序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br></pre></td></tr></table></figure>
<p>当我们调用 async1 函数的时候，会马上输出 async2 end,并且函数返回一个 Promise，接下来在遇到 await 的时候就让出线程开始执行 async1 外的代码，可以完全把 await 看成是让出线程的标志。</p>
<p>然后当同步代码全部执行完毕以后，就会执行所有的异步代码，那么就会又回到 await 的位置执行返回的 Promise 的 resolve 函数，这又会把 resolve 丢到微任务队列中，接下来执行 then 中的回调，当两个 then 中的回调全部执行完毕后，回到 await 的位置处理返回值，这时候可以看成 <code>Promise.resolve(返回值).then()</code>，然后 await 后的代码全部被包裹进了 then 的回调中，所以 <code>console.log(&#39;async1 end&#39;)</code> 会优先执行于 <code>setTimeout</code>。</p>
<p>微任务包括 <code>process.nextTick</code> ，<code>promise</code> ，<code>MutationObserver</code>。</p>
<p>宏任务包括 <code>script</code> ， <code>setTimeout</code> ，<code>setInterval</code> ，<code>setImmediate</code> ，<code>I/O</code> ，<code>UI rendering</code>。</p>
<p>Event Loop 执行顺序如下所示：</p>
<ul>
<li>首先执行同步代码，这属于宏任务</li>
<li>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li>
<li>执行所有微任务</li>
<li>当执行完所有微任务后，如有必要会渲染页面</li>
<li>然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 <code>setTimeout</code> 中的回调函数</li>
</ul>
<p>Node 中的 Event Loop</p>
<p>涉及的面试题：Node 中 Event Loop 和 浏览器的有什么不同？process.nextTick 执行顺序</p>
<p>Node 中的 Event Loop 分成6个阶段，它们会按照顺序反复运行，每当进入某一个阶段的时候，都会从对应的回调队列取出函数去执行。当队列为空或者执行的回调函数数量达到系统设定的阈值，就会进入下一个阶段</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure>
<p><strong>timer</strong></p>
<p>timer 阶段会执行 setTimeout 和 setInerval 回调，并是由 poll 阶段控制的</p>
<p> 同样，在 Node 中定时器指定的时间也不是准确的时间，只是尽快执行。</p>
<p><strong>I/O</strong></p>
<p>I/O 阶段会处理上一轮循环中少数未执行的的 I/O 回调</p>
<p><strong>dle,prepare</strong></p>
<p>idle,prepare 阶段内部实现</p>
<p><strong>poll</strong></p>
<p>poll 阶段很重要，在这一阶段中，系统会做两件事情</p>
<ol>
<li>执行到点的定时器</li>
<li>执行 poll 队列中的事件</li>
</ol>
<p>并且当 poll 中没有定时器的情况下，会发现以下两件事情</p>
<ul>
<li>如果poll队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制</li>
<li>如果poll队列为空,会发生两件事情<ul>
<li>如果有 setImmediate 需要执行的时候，poll 阶段会停止并且进入到 check 阶段执行 setImmediate</li>
<li>如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去</li>
</ul>
</li>
</ul>
<p>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</p>
<p><strong>check</strong></p>
<p>check 阶段执行 <code>setImmediate</code></p>
<p><strong>close callbacks</strong></p>
<p>close callbacks 阶段执行了 close 事件。</p>
<p>首先在有些情况下，定时器的执行顺序其实是<strong>随机</strong>的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;setImmediate&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>对于以上代码来说，<code>setTimeout</code> 可能执行在前，也可能执行在后</p>
<ul>
<li>首先 <code>setTimeout(fn, 0) === setTimeout(fn, 1)</code>，这是由源码决定的</li>
<li>进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 <code>setTimeout</code> 回调</li>
<li>那么如果准备时间花费小于 1ms，那么就是 <code>setImmediate</code> 回调先执行了</li>
</ul>
<p>当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码：</p>
<p>当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;timeout&apos;);</span><br><span class="line">    &#125;, 0)</span><br><span class="line">    setImmediate(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;immediate&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在上述代码中，<code>setImmediate</code> 永远<strong>先执行</strong>。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 <code>setImmediate</code> 回调，所以就直接跳转到 check 阶段去执行回调了。</p>
<p><strong>process.nextTick</strong></p>
<p>这个函数是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成之后，如果存在 nextTick 阶段，就会清空队列中的所有回调函数，并优于其他 microtask 执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line"></span><br><span class="line"> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line"> process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">   process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">     process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// nextTick</span></span><br><span class="line"><span class="comment">// nextTick</span></span><br><span class="line"><span class="comment">// nextTick</span></span><br><span class="line"><span class="comment">// nextTick</span></span><br><span class="line"><span class="comment">// timer1</span></span><br><span class="line"><span class="comment">// promise1</span></span><br></pre></td></tr></table></figure>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md">前端面试题目已经答案汇总</a></p>
<p><a href="https://yuchengkai.cn/docs/frontend/#%E9%98%B2%E6%8A%96">防抖</a></p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    赖彬鸿
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://laibh.top/前端面试题目汇总摘录-JS 基础篇2.html" title="前端面试题目汇总摘录（JS 基础篇2）">http://laibh.top/前端面试题目汇总摘录-JS 基础篇2.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/前端面试题/" <i class="fa fa-tag"></i> 前端面试题</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019-03-26-mongoose.html" rel="next" title="Mongoose">
                <i class="fa fa-chevron-left"></i> Mongoose
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/前端面试题目汇总摘录-浏览器基础篇.html" rel="prev" title="前端面试题目汇总摘录（浏览器与性能基础篇）">
                前端面试题目汇总摘录（浏览器与性能基础篇） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "1",
        "bdMiniList": false,
        "bdPic": ""
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      },
      "slide": {
        "bdImg": "5",
        "bdPos": "left",
        "bdTop": "100"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?'+~(-new Date()/36e5)];;
</script>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zOTcwMy8xNjIzMA"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/myPhoto.jpg"
                alt="赖彬鸿" />
            
              <p class="site-author-name" itemprop="name">赖彬鸿</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">135</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          
          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/LbhFront-end" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.cnblogs.com/lbh2018/" target="_blank" title="博客园">
                      
                        <i class="fa fa-fw fa-globe"></i>博客园</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://yq.aliyun.com/users/1802204154913774?spm=a2c4e.11153940.blogcont662526.4.6c0a34f6E2lR5o" target="_blank" title="云栖">
                      
                        <i class="fa fa-fw fa-globe"></i>云栖</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:544289495@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=544289495&website=www.oicqzone.com" target="_blank" title="QQ">
                      
                        <i class="fa fa-fw fa-qq"></i>QQ</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.google.com.hk/search?safe=strict&source=hp&ei=JtLCXIriJ8G4-gS_-4qABQ&q=site%3Alaibh.top&btnK=Google+%E6%90%9C%E7%B4%A2&oq=site%3Alaibh.top&gs_l=psy-ab.3...1158.6834..7051...5.0..1.246.3720.2-17......0....1..gws-wiz.....0..0j0i10.rJMUHvdrbds" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
            </div>
          
         <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=90  src="//music.163.com/outchain/player?type=0&id=2353471182&auto=0&height=90"></iframe>
          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.chjtx.com/JRoll/" title="醉萝卜" target="_blank">醉萝卜</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://hzd.plus/" title="Zhendong" target="_blank">Zhendong</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.cnblogs.com/cnyball" title="cnyballk" target="_blank">cnyballk</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://johnzz.top/" title="John" target="_blank">John</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://xiaojun1994.top/" title="xiaojun1994" target="_blank">xiaojun1994</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://me.ursb.me" title="Airing" target="_blank">Airing</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.iyouhun.com" title="游魂" target="_blank">游魂</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://icoty.github.io/" title="荒野之萍" target="_blank">荒野之萍</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://im-one.github.io/" title="imOne" target="_blank">imOne</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.hourxu.com/" title="Ambre" target="_blank">Ambre</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.huyujs.com" title="胡雨" target="_blank">胡雨</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.andou.live" title="安逗" target="_blank">安逗</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.jianshu.com/u/701a8bbf4f7e" title="陈健斌" target="_blank">陈健斌</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://itobys.github.io/" title="汤姆Tom酱" target="_blank">汤姆Tom酱</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://breeze2.github.io/blog/" title="林毅锋" target="_blank">林毅锋</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.qzroc.com/" title="大鹏博客" target="_blank">大鹏博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://lyreal666.com/" title="余腾靖的博客" target="_blank">余腾靖的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://buzuosheng.com/" title="不作声" target="_blank">不作声</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.baidu.com/s?ie=UTF-8&wd=site%3Alaibh.top" title="百度" target="_blank">百度</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.google.com.hk/search?safe=strict&source=hp&ei=zXdWXfemLJbO0PEP8qyXyA0&q=site%3Alaibh.top&oq=site%3Alaibh.top&gs_l=psy-ab.3...580.8501..8767...0.0..0.397.934.2-1j2......0....2j1..gws-wiz.QESXfWGadT0&ved=0ahUKEwi3wbusiofkAhUWJzQIHXLWBdkQ4dUDCAU&uact=5" title="谷歌" target="_blank">谷歌</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#JS-基础2"><span class="nav-number">1.</span> <span class="nav-text">JS 基础2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#React-Vue-项目时为什么要在组件中写-key，其作用是什么？"><span class="nav-number">1.1.</span> <span class="nav-text">React/Vue 项目时为什么要在组件中写 key，其作用是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#“1”-”2”-”3”-map-parseInt-解析"><span class="nav-number">1.2.</span> <span class="nav-text">[“1”,”2”,”3”].map(parseInt)解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内置类型"><span class="nav-number">1.3.</span> <span class="nav-text">内置类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Typeof"><span class="nav-number">1.4.</span> <span class="nav-text">Typeof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型转换"><span class="nav-number">1.5.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#转Boolean"><span class="nav-number">1.5.1.</span> <span class="nav-text">转Boolean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象转基本类型"><span class="nav-number">1.5.2.</span> <span class="nav-text">对象转基本类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四则运算符"><span class="nav-number">1.5.3.</span> <span class="nav-text">四则运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作符"><span class="nav-number">1.5.4.</span> <span class="nav-text">== 操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#比较运算符"><span class="nav-number">1.5.5.</span> <span class="nav-text">比较运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型"><span class="nav-number">1.6.</span> <span class="nav-text">原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new"><span class="nav-number">1.7.</span> <span class="nav-text">new</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#instanceof"><span class="nav-number">1.8.</span> <span class="nav-text">instanceof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this"><span class="nav-number">1.9.</span> <span class="nav-text">this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行上下文"><span class="nav-number">1.10.</span> <span class="nav-text">执行上下文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包"><span class="nav-number">1.11.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深浅拷贝"><span class="nav-number">1.12.</span> <span class="nav-text">深浅拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#浅拷贝"><span class="nav-number">1.12.1.</span> <span class="nav-text">浅拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#深拷贝"><span class="nav-number">1.12.2.</span> <span class="nav-text">深拷贝</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块化"><span class="nav-number">1.13.</span> <span class="nav-text">模块化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CommonJS"><span class="nav-number">1.13.1.</span> <span class="nav-text">CommonJS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AMD"><span class="nav-number">1.13.2.</span> <span class="nav-text">AMD</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#节流和防抖的理解"><span class="nav-number">1.14.</span> <span class="nav-text">节流和防抖的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#防抖"><span class="nav-number">1.14.1.</span> <span class="nav-text">防抖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#节流"><span class="nav-number">1.14.2.</span> <span class="nav-text">节流</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承"><span class="nav-number">1.15.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#call-apply-bind-区别"><span class="nav-number">1.16.</span> <span class="nav-text">call,apply,bind 区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模拟实现-call-和-apply"><span class="nav-number">1.16.1.</span> <span class="nav-text">模拟实现 call 和 apply</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-实现"><span class="nav-number">1.17.</span> <span class="nav-text">Promise 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Generator-实现"><span class="nav-number">1.18.</span> <span class="nav-text">Generator 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一道题目"><span class="nav-number">1.18.1.</span> <span class="nav-text">一道题目</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map、FlatMap-和-Reduce"><span class="nav-number">1.19.</span> <span class="nav-text">Map、FlatMap 和 Reduce</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#async-和-await"><span class="nav-number">1.20.</span> <span class="nav-text">async 和 await</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用的定时器函数"><span class="nav-number">1.21.</span> <span class="nav-text">常用的定时器函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#requestAnimationFrame"><span class="nav-number">1.21.1.</span> <span class="nav-text">requestAnimationFrame</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setTimeout"><span class="nav-number">1.21.2.</span> <span class="nav-text">setTimeout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setInterval"><span class="nav-number">1.21.3.</span> <span class="nav-text">setInterval</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy"><span class="nav-number">1.22.</span> <span class="nav-text">Proxy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么-0-1-0-2-0-3"><span class="nav-number">1.23.</span> <span class="nav-text">为什么 0.1 + 0.2 != 0.3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正则表达式"><span class="nav-number">1.24.</span> <span class="nav-text">正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#元字符"><span class="nav-number">1.24.1.</span> <span class="nav-text">元字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修饰符"><span class="nav-number">1.24.2.</span> <span class="nav-text">修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符简写"><span class="nav-number">1.24.3.</span> <span class="nav-text">字符简写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#V8下的垃圾回收机制"><span class="nav-number">1.25.</span> <span class="nav-text">V8下的垃圾回收机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#新生代算法"><span class="nav-number">1.25.1.</span> <span class="nav-text">新生代算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#老生代算法"><span class="nav-number">1.25.2.</span> <span class="nav-text">老生代算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-Loop"><span class="nav-number">1.26.</span> <span class="nav-text">Event Loop</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程和线程"><span class="nav-number">1.26.1.</span> <span class="nav-text">进程和线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#执行栈"><span class="nav-number">1.26.2.</span> <span class="nav-text">执行栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#浏览器中的-Event-Loop"><span class="nav-number">1.26.3.</span> <span class="nav-text">浏览器中的 Event Loop</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考链接："><span class="nav-number">2.</span> <span class="nav-text">参考链接：</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart throb" style="color: #d43f57;"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">赖彬鸿</span>

  
</div>

  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>

<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>



-->
<div>
<span id="busuanzi_container_site_pv" title="访问量">
    <i class="fa fa fa-eye"></i> <span id="busuanzi_value_site_pv"></span>
</span>
<span id="busuanzi_container_site_uv" title="访问人数">
  <i class="fa fa-user"></i> <span id="busuanzi_value_site_uv"></span>
</span>
<span class="post-count" title="博客总字数"><i class="fa fa-pagelines" aria-hidden="true"></i>745.9k</span>
</div>
<i class="fa fa-shield" aria-hidden="true" title="本站安全运行时间"></i> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("01/29/2018 09:47:04");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds);
        if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>
  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("JcDzlAxx8A0MJDQ9xpJTOBUe-gzGzoHsz", "hih724suAgjSWQnvOuIEvxza");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script>


  

  <!-- 代码块复制功能 -->
  <script type="text/javascript" src="/js/src/clipboard.js"></script>  
  <script type="text/javascript" src="/js/src/clipboard-use.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
