<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="数据库相关," />





  <link rel="alternate" href="/atom.xml" title="赖同学" type="application/atom+xml" />






<meta name="description" content="MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 Mongoose是在node.js环境下对">
<meta name="keywords" content="数据库相关">
<meta property="og:type" content="article">
<meta property="og:title" content="Mongoose">
<meta property="og:url" content="http://laibh.top/2019-03-26-mongoose.html">
<meta property="og:site_name" content="赖同学">
<meta property="og:description" content="MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 Mongoose是在node.js环境下对">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2022-03-04T10:00:38.464Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mongoose">
<meta name="twitter:description" content="MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 Mongoose是在node.js环境下对">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '1YNH8Y3MP9',
      apiKey: '61c189facf700193dfcbb902369ce227',
      indexName: 'MyBlog',
      hits: {"per_page":10},
      labels: {"input_placeholder":"想要找些什么呢","hits_empty":"${query} 没有被找到，再试试","hits_stats":"在 ${time} ms 查找了${hits}个结果"}
    }
  };
</script>



  <link rel="canonical" href="http://laibh.top/2019-03-26-mongoose.html"/>





  <title>Mongoose | 赖同学</title>
  








</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">赖同学</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-comment"></i> <br />
            
            留言
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://laibh.top/2019-03-26-mongoose.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖彬鸿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/myPhoto.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖同学">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Mongoose</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-26T16:30:00+08:00">
                2019-03-26
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2022-03-04T18:00:38+08:00">
                2022-03-04
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库相关/" itemprop="url" rel="index">
                    <span itemprop="name">数据库相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019-03-26-mongoose.html" class="leancloud_visitors" data-flag-title="Mongoose">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  16,131
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p>
<p>Mongoose是在node.js环境下对mongodb进行便捷操作的对象模型工具</p>
<p><a href="https://cn.mongoosedoc.top/docs/guide.html">学习链接</a></p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p><em>请先安装 MongoDB 和 Node.js。</em></p>
<p>下一步，<code>npm</code>安装Mongoose:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mongoose</span><br></pre></td></tr></table></figure>
<p>连接数据库test</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line">mongoose.connect(<span class="string">'mongodb://localhost/test'</span>);</span><br></pre></td></tr></table></figure>
<p><code>connect()</code>返回一个状态待定（pending）的连接，接着我们加上成功和失败的提醒：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db = mongoose.connection;</span><br><span class="line">db.on(<span class="string">'error'</span>,<span class="built_in">console</span>.error.bind(<span class="built_in">console</span>,<span class="string">'connection error:'</span>));</span><br><span class="line">db.once(<span class="string">'open'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// .. </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>连接成功的时候，回调函数会被调用，假设下面所有函数都在这个回调函数里面。</p>
<p>Mongoose 里面一切始于 Schema。看一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> KittySchema = mongoose.Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们得到了一个带有 <code>String</code>类型的 <code>name</code> 属性的 schema,接着把这个 schema 编译成一个 Model:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Kitten = mongoose.model(<span class="string">'Kitten'</span>,kittySchema);</span><br></pre></td></tr></table></figure>
<p>model 是我们创造的 document 的 Class。在例子中，每个 document 都是一个实例，它的属性和行为都会被声明在 schema 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> felyne = <span class="keyword">new</span> Kitten(&#123;<span class="attr">name</span>:<span class="string">'Felyne'</span>&#125;);</span><br><span class="line">felyne.name <span class="comment">// 'Felyne';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 document 加一个 speak 方法</span></span><br><span class="line">KittySchema.methods.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> greeting = <span class="keyword">this</span>.name ?  <span class="string">"Meow name is "</span> + <span class="keyword">this</span>.name: <span class="string">"I don't have a name"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(greeting);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Kitten = mongoose.model(<span class="string">'Kitten'</span>,kittySchema);</span><br></pre></td></tr></table></figure>
<p>加在 schema 的 <code>methods</code> 属性的函数会编译到 <code>Model</code> 的prototype,也会暴露搭配每个 document 实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Kitten(&#123;<span class="attr">name</span>:<span class="string">'A'</span>&#125;);</span><br><span class="line">a.speak(); <span class="comment">// Meow name is A</span></span><br></pre></td></tr></table></figure>
<p>每个 document 会在调用它的 save 方法后保存到数据库中，注意回调函数的第一个参数永远是 error</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.save(<span class="function"><span class="keyword">function</span>(<span class="params">err,A</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">    A.speak();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果有很多个实例，可以用下面的方法来获取 model 里面的所有数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Kitten.find(<span class="function"><span class="keyword">function</span>(<span class="params">err,kittens</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">    <span class="built_in">console</span>.log(kittens);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="模式（Schemas）"><a href="#模式（Schemas）" class="headerlink" title="模式（Schemas）"></a>模式（Schemas）</h2><h4 id="定义一个schema"><a href="#定义一个schema" class="headerlink" title="定义一个schema"></a>定义一个schema</h4><p>Mongoose 的一切始于 Schema,每个 schama 都会映射到一个 MongoDB collection，并定义这个 collection 里面的文档的构成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema;</span><br><span class="line"><span class="keyword">const</span> blog = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    title:<span class="built_in">String</span>,</span><br><span class="line">    author:<span class="built_in">String</span>,</span><br><span class="line">    body:<span class="built_in">String</span>,</span><br><span class="line">    comments:[&#123;<span class="attr">body</span>:<span class="built_in">String</span>,<span class="attr">date</span>:<span class="built_in">Date</span>&#125;],</span><br><span class="line">    date:&#123;</span><br><span class="line">        type:<span class="built_in">Date</span>,</span><br><span class="line">        defalut:<span class="built_in">Date</span>.now</span><br><span class="line">    &#125;,</span><br><span class="line">    hidden:<span class="built_in">Boolean</span>,</span><br><span class="line">    meta:&#123;</span><br><span class="line">        votes:<span class="built_in">Number</span>,</span><br><span class="line">        favs:<span class="built_in">Number</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>document 里面的每个属性都会被转换成在 blogSchema 里面对应的 SchemaType。例如 <code>title</code> 属性会被转换成为 SchemaType String,而 <code>date</code>属性会被转换成为 SchemaType Date。还可以像 <code>meta</code>属性一样，更加详细地指定嵌套在里面的属性类型。</p>
<p>运行使用的 SchemaTypes 有：</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Date</li>
<li>Buffer</li>
<li>Mixed</li>
<li>ObjectId</li>
<li>Array</li>
</ul>
<p>Schema 的功能不只是定义文档结构和属性类型，还可以定义</p>
<ul>
<li>document 的 instance methods</li>
<li>model 的 static Model methods</li>
<li>复合索引</li>
<li>文档的生命周期钩子，也称为中间件</li>
</ul>
<h4 id="创建一个-model"><a href="#创建一个-model" class="headerlink" title="创建一个 model"></a>创建一个 model</h4><p><code>mongoose.model(modelName,schema)</code> 函数把 schema 转换为一个 Model:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Blog = mongoose.model(<span class="string">'Blob'</span>,blogSchema);</span><br></pre></td></tr></table></figure>
<h4 id="实例方法（method）"><a href="#实例方法（method）" class="headerlink" title="实例方法（method）"></a>实例方法（method）</h4><p>document 是 Models 的实例。Document 有很多自带的实例方法，当然也可以自定义我们自己的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个 schema</span></span><br><span class="line"><span class="keyword">const</span> animalSchema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>,<span class="attr">type</span>:<span class="built_in">String</span>&#125;);</span><br><span class="line"></span><br><span class="line">animalSchema.methods.findSimilarTypes = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.model(<span class="string">'Animal'</span>).find(&#123;<span class="attr">type</span>:<span class="keyword">this</span>.type&#125;,cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在所有的 <code>animal</code> 实例都有 <code>findSimilarTypes</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Animal = mongoose.model(<span class="string">'Animal'</span>,animalSchema);</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Animal(&#123;type：<span class="string">'dog'</span>&#125;);</span><br><span class="line"></span><br><span class="line">dog.findSimilarTypes(<span class="function"><span class="keyword">function</span>(<span class="params">err,dogs</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(dogs); <span class="comment">// woof</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>重写 mongoose 的默认方法会造成无法预料的结果</li>
<li>不要在自定义方法中使用 ES6 箭头函数，会造成 this 指向错误</li>
</ul>
<h4 id="静态方法（static）"><a href="#静态方法（static）" class="headerlink" title="静态方法（static）"></a>静态方法（static）</h4><p>添加 <code>Model</code> 的静态方法也十分简单，继续使用 <code>animalSchema</code> 举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">animalSchema.statics.findByName = <span class="function"><span class="keyword">function</span>(<span class="params">name,cb</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.find(&#123;<span class="attr">name</span>:<span class="keyword">new</span> <span class="built_in">RegExp</span>(name,<span class="string">'i'</span>)&#125;,cb)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Animal = mongoose.model(<span class="string">'Animal'</span>,animalSchema);</span><br><span class="line">Animal.findByName(<span class="string">'fido'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,animals</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animals);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>同样注意的是不要在静态方法中使用 ES6 的箭头函数</p>
<h4 id="查询助手（query-helper）"><a href="#查询助手（query-helper）" class="headerlink" title="查询助手（query helper）"></a>查询助手（query helper）</h4><p>查询助手作用于 query 实例，方便自定义扩展链式查询</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">animalSchema.query.byName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.find(&#123;<span class="attr">name</span>:<span class="keyword">new</span> <span class="built_in">RegExp</span>(name,<span class="string">'i'</span>)&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Animal = mongoose.model(<span class="string">'Animal'</span>,animalSchema);</span><br><span class="line">Animal.find().byName(<span class="string">'fido'</span>).exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,animal</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animals);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="索引（index）"><a href="#索引（index）" class="headerlink" title="索引（index）"></a>索引（index）</h4><p>MongoDB 支持 secondary indexes。在 mongoose 中，我们在 Schema 定义索引。索引分字段级别和 schema 级别，复合索引需要在 schema 级别定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animalSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    type:<span class="built_in">String</span>,</span><br><span class="line">    tags:&#123;</span><br><span class="line">        type:[<span class="built_in">String</span>],</span><br><span class="line">        index:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">animalSchema.index(&#123;<span class="attr">name</span>:<span class="number">1</span>,<span class="attr">type</span>:<span class="number">-1</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>应用启动的时候，Mongoose 会自动调用 <code>createIndex</code> 初始化定义的索引。Mongoose 顺序处理每一个 createIndex，然后在 model 触发 ‘index’ 事件。在生产中建议禁止这种行为，因为创建索引会对性能造成重大影响。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://user:pass@localhost:port/database'</span>,&#123;<span class="attr">autoIndex</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">mongoose.createConnection(<span class="string">'mongodb://user:pass@localhost:port/database'</span>,&#123;<span class="attr">autoIndex</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">new</span> Schema(&#123;..&#125;,&#123;<span class="attr">autoIndex</span>:<span class="literal">false</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>索引创建完成或者失败，Mongoose 会触发 index 事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Will cause an error because mongodb has an _id index by default that is not sparse</span></span><br><span class="line">animalSchema.index(&#123;<span class="attr">_id</span>:<span class="number">1</span>&#125;,&#123;<span class="attr">sparse</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Animal = mongoose.model(<span class="string">'Animal'</span>,animalSchema);</span><br><span class="line">Animal.on(<span class="string">'index'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// _id index cannot be sparse</span></span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="虚拟值（Virtual）"><a href="#虚拟值（Virtual）" class="headerlink" title="虚拟值（Virtual）"></a>虚拟值（Virtual）</h4><p>Virtual 是 document 的属性，但是不会被保存到 MongoDB.getter 可以用于格式化和组合字段数据，setter 可以很方便地分解一个值到多个字段。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> personSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        first:<span class="built_in">String</span>,</span><br><span class="line">        last:<span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Person = mongoose.model(<span class="string">'Person'</span>,personSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> axl = <span class="keyword">new</span> Person(&#123;</span><br><span class="line">    name:&#123;<span class="attr">first</span>:<span class="string">'Axl'</span>,<span class="attr">last</span>:<span class="string">'Rose'</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(axl.name.first + <span class="string">' '</span> + axl.name.last); <span class="comment">//Axl Rose</span></span><br></pre></td></tr></table></figure>
<p>但是每次都要这样拼接就太麻烦了，使用 virtual property getter 这个方法允许定义一个 fullName 属性，但不必保存到数据库。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">personSchema.virtual(<span class="string">'fullName'</span>).get(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name.first + <span class="string">' '</span> + <span class="keyword">this</span>.name.last</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(axl.fullName); <span class="comment">// Axl Rose</span></span><br></pre></td></tr></table></figure>
<p>如果对 document 使用 <code>toJSON（）</code> 或 <code>toObject()</code> 默认不包括虚拟值，需要额外向 toObject 或者 toJSON 传入参数 <code>{virtuals:true}</code></p>
<p>也可以设定虚拟值的 setter，下面的例子中，当赋值到虚拟值的时候，会自动拆分到其他属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">personSchema.virtual(<span class="string">'fullName'</span>).get(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name.first + <span class="string">' '</span> + <span class="keyword">this</span>.name.last</span><br><span class="line">&#125;).set(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name.first = v.substr(<span class="number">0</span>,v.indexOf(<span class="string">' '</span>));</span><br><span class="line">    <span class="keyword">this</span>.name.last = v.substr(v.indexOf(<span class="string">' '</span>)+<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">axl.fullName = <span class="string">'William Rose'</span> <span class="comment">// Now `axl.name.first` is "William"</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，虚拟值不能用于查询和字段选择，因为虚拟值不存储在 MongoDB</p>
<h4 id="别名（Alias）"><a href="#别名（Alias）" class="headerlink" title="别名（Alias）"></a>别名（Alias）</h4><p>Aliase 是一种特殊的虚拟值，它的getter 和 setter 会无缝链接到另一个值，这是一个节省带宽的做法，可以存储一个更短的属性名到数据库，同时在调用的时候保持可读性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> personSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    n:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        alias:<span class="string">'name'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(&#123;<span class="attr">name</span>:<span class="string">'Val'</span>&#125;);</span><br><span class="line">person <span class="comment">//&#123;n:'Val'&#125;</span></span><br><span class="line">person.toObject(&#123;<span class="attr">virtuals</span>:<span class="literal">true</span>&#125;) <span class="comment">//&#123;n:'Val',name:'Val'&#125;</span></span><br><span class="line">person.name <span class="comment">// Val</span></span><br><span class="line">person.name = <span class="string">'Not Val'</span>;</span><br><span class="line">person <span class="comment">// &#123;n:'Not Val'&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><p>Schema 有很多可配置选项，可以在构造时传入或者直接 set</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Schema(&#123;...&#125;,options);</span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;...&#125;);</span><br><span class="line"></span><br><span class="line">schema.set(option,value);</span><br></pre></td></tr></table></figure>
<p>有效的选项：</p>
<ul>
<li>autoIndex</li>
<li>bufferCommands</li>
<li>capped</li>
<li>collection</li>
<li>id</li>
<li>_id</li>
<li>minimize</li>
<li>read</li>
<li>shardKey</li>
<li>strict</li>
<li>strictQuery</li>
<li>toJSON</li>
<li>toObject</li>
<li>typekey</li>
<li>validateBeforeSave</li>
<li>versionKey</li>
<li>skipVersioning</li>
<li>timestamps</li>
<li>useNestedStrict</li>
</ul>
<p><strong>option：autoIndex</strong></p>
<p>应用启动的时候，Mongoose 自动发送 <code>createIndex</code> 指令，schema 里面的每个 index 都会被创建，如果需要关闭自动创建功能或者需要在创建后进行一系列操作，可以把 <code>autoIndex</code> 设为 <code>false</code>，然后对 model 调用 ensureIndexes：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;,&#123;<span class="attr">autoIndex</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Clock = mongoose.model(<span class="string">'Clock'</span>,schema);</span><br><span class="line">Clock.ensureIndexes(callback);</span><br></pre></td></tr></table></figure>
<p><strong>option：bufferCommands</strong></p>
<p>默认情况下，mongoose buffers会在连接中断时发出命令，直到驱动程序重新连接为止。若要禁用缓冲，请将bufferCommands设置为false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;,&#123;<span class="attr">bufferCommands</span>:<span class="literal">false</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>schema 的bufferCommands 会重写全局的 bufferCommands 选项。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mongoose.set(<span class="string">'bufferCommands'</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;,&#123;<span class="attr">bufferCommands</span>:<span class="literal">false</span>&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>option：capped</strong></p>
<p>Mongoose 支持 MongoDB 的 capped collections ，要从底层把 collection 设定为 capped(封顶)，可以把collection 的最大容量设定到 <code>capped</code> 选项（单位 bytes）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Schema(&#123;..&#125;,&#123;<span class="attr">capped</span>:<span class="number">1024</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>如果要传递多个选项，capped 也可以作为对象传递.这个试试需要显式传入必要值 <code>size</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Schema(&#123;..&#125;,&#123;<span class="attr">size</span>:<span class="number">1024</span>,<span class="attr">max</span>:<span class="number">1000</span>,<span class="attr">autoIndexId</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>option：collection</strong></p>
<p>Mongoose 通过 utils.toCollectionName 方法，默认生成 collection 的名称（生成 model 名称的复数形式）。设置这个选项可以自定义名称</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dataSchema = <span class="keyword">new</span> Schema(&#123;..&#125;,&#123;<span class="attr">collection</span>:<span class="string">'data'</span>&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>option：id</strong></p>
<p>Mongoose 会默认生成一个虚拟值 <code>id</code>，指向文档的 <code>_id</code>字段。如果你不需要 <code>id</code> 虚拟值，可以通过这个选项禁用此功能。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认行为</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Page = mongoose.model(<span class="string">'Page'</span>,schema);</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Page(&#123;<span class="attr">name</span>:<span class="string">'mongodb.org'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(p.id); <span class="comment">// 50341373e894ad16347efe01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//禁止 id</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;,&#123;<span class="attr">id</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Page = mongoose.model(<span class="string">'Page'</span>,schema);</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Page(&#123;<span class="attr">name</span>:<span class="string">'mongodb.org'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(p.id); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p><strong>option：_id</strong></p>
<p>Mongoose 默认给你的 Schema 赋值一个 <code>_id</code>，这个值的类型是 ObjectId，这与 MongoDB 的默认表现一致。如果需要，可以禁止</p>
<p>此选项<strong>只能</strong>用于 subdocument。 Mongoose 不能保存没有id的文档，如果硬是要这么做，会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认行为</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Page = mongoose.model(<span class="string">'Page'</span>,schema);</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Page(&#123;<span class="attr">name</span>:<span class="string">'mongodb.org'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// &#123; _id: '50341373e894ad16347efe01', name: 'mongodb.org' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止 _id</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;,&#123;<span class="attr">_id</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Page = mongoose.model(<span class="string">'Page'</span>,schema);</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Page(&#123;<span class="attr">name</span>:<span class="string">'mongodb.org'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// &#123; name: 'mongodb.org' &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>option：minimize</strong></p>
<p>Mongoose 默认不保存空对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>,<span class="attr">inventory</span>:&#123;&#125;&#125;);</span><br><span class="line"><span class="keyword">const</span> Character = mongoose.model(<span class="string">'Character'</span>,schema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> frodo = <span class="keyword">new</span> Character(&#123;<span class="attr">name</span>:<span class="string">'Frodo'</span>,<span class="attr">inventory</span>:&#123;<span class="attr">ringOfPower</span>:<span class="number">1</span>&#125;&#125;);</span><br><span class="line">Character.findOne(&#123;<span class="attr">name</span>:<span class="string">'Frodo'</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,character</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(character); <span class="comment">// &#123;name: 'Frodo', inventory: &#123; ringOfPower: 1 &#125;&#125;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Sam = <span class="keyword">new</span> Character(&#123;<span class="attr">name</span>:<span class="string">'Sam'</span>,<span class="attr">inventory</span>:&#123;&#125;&#125;);</span><br><span class="line">Character.findOne(&#123;<span class="attr">name</span>:<span class="string">'Sam'</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,character</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(character); <span class="comment">// &#123;name: 'Sam'&#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果把 minimize 设定为 false,Mongoose 将保存空对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Sam = <span class="keyword">new</span> Character(&#123;<span class="attr">name</span>:<span class="string">'Sam'</span>,<span class="attr">inventory</span>:&#123;&#125;&#125;,&#123;<span class="attr">minimize</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">Character.findOne(&#123;<span class="attr">name</span>:<span class="string">'Sam'</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,character</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(character); <span class="comment">// &#123;name: 'Sam',inventory:&#123;&#125;&#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>option：read</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">read</span>: <span class="string">'primary'</span> &#125;);<span class="comment">// also aliased as 'p'</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">read</span>: <span class="string">'primaryPreferred'</span> &#125;);<span class="comment">// aliased as 'pp'</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">read</span>: <span class="string">'secondary'</span> &#125;);<span class="comment">// aliased as 's'</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">read</span>: <span class="string">'secondaryPreferred'</span> &#125;);<span class="comment">// aliased as 'sp'</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">read</span>: <span class="string">'nearest'</span> &#125;);<span class="comment">// aliased as 'n'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123; <span class="attr">replset</span>: &#123; <span class="attr">strategy</span>: <span class="string">'ping'</span> &#125;&#125;;</span><br><span class="line">mongoose.connect(uri, options);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">read</span>: [<span class="string">'nearest'</span>, &#123; <span class="attr">disk</span>: <span class="string">'ssd'</span> &#125;] &#125;);</span><br><span class="line">mongoose.model(<span class="string">'JellyBean'</span>, schema);</span><br></pre></td></tr></table></figure>
<p><strong>option：shardKey</strong></p>
<p>分片相关.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Schema(&#123; .. &#125;, &#123; <span class="attr">shardKey</span>: &#123; <span class="attr">tag</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="number">1</span> &#125;&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>option：strict</strong></p>
<p>Strict 选项默认为 true，这意味着你不能 <code>save</code> schema 里没有声明的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thingSchema = <span class="keyword">new</span> Schema(&#123;..&#125;)</span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>, thingSchema);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing(&#123; <span class="attr">iAmNotInTheSchema</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">thing.save(); <span class="comment">// iAmNotInTheSchema is not saved to the db</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set to false..</span></span><br><span class="line"><span class="keyword">const</span> thingSchema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">strict</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing(&#123; <span class="attr">iAmNotInTheSchema</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">thing.save(); <span class="comment">// iAmNotInTheSchema is now saved to the db!!</span></span><br></pre></td></tr></table></figure>
<p><code>doc.set()</code> 也受该选项影响：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thingSchema = <span class="keyword">new</span> Schema(&#123;..&#125;)</span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>, thingSchema);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing;</span><br><span class="line">thing.set(<span class="string">'iAmNotInTheSchema'</span>, <span class="literal">true</span>);</span><br><span class="line">thing.save(); <span class="comment">// iAmNotInTheSchema is not saved to the db</span></span><br></pre></td></tr></table></figure>
<p>这个值可以在 model 级别重写，在第二个参数值传入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing(doc, <span class="literal">true</span>);  <span class="comment">// enables strict mode</span></span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing(doc, <span class="literal">false</span>); <span class="comment">// disables strict mode</span></span><br></pre></td></tr></table></figure>
<p>还可以将strict选项设置为“throw”，这将导致产生错误，而不是删除坏数据。</p>
<p>注意:在 schema 中不存在的实例上设置的任何键/值总是被忽略，不管模式选项是什么。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thingSchema = <span class="keyword">new</span> Schema(&#123;..&#125;)</span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>, thingSchema);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing;</span><br><span class="line">thing.iAmNotInTheSchema = <span class="literal">true</span>;</span><br><span class="line">thing.save(); <span class="comment">// iAmNotInTheSchema is never saved to the db</span></span><br></pre></td></tr></table></figure>
<p><strong>option：strictQuery</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">field</span>: <span class="built_in">Number</span> &#125;, &#123; <span class="attr">strict</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> MyModel = mongoose.model(<span class="string">'Test'</span>, mySchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mongoose will **not** filter out `notInSchema: 1`, despite `strict: true`</span></span><br><span class="line">MyModel.find(&#123; <span class="attr">notInSchema</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>严格的选择适用于更新</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mongoose will strip out `notInSchema` from the update if `strict` is not `false`</span></span><br><span class="line">MyModel.updateMany(&#123;&#125;, &#123; <span class="attr">$set</span>: &#123; <span class="attr">notInSchema</span>: <span class="number">1</span> &#125; &#125;);</span><br></pre></td></tr></table></figure>
<p>Mongoose 有一个单独的 strictQuery 选项，用于将过滤器参数的strict模式切换到查询。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">field</span>: <span class="built_in">Number</span> &#125;, &#123;</span><br><span class="line">  strict: <span class="literal">true</span>,</span><br><span class="line">  strictQuery: <span class="literal">true</span> <span class="comment">// Turn on strict mode for query filters</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> MyModel = mongoose.model(<span class="string">'Test'</span>, mySchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mongoose will strip out `notInSchema: 1` because `strictQuery` is `true`</span></span><br><span class="line">MyModel.find(&#123; <span class="attr">notInSchema</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>option：toJSON</strong></p>
<p>与toObject选项完全相同，但仅在调用documents toJSON方法时才适用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;);</span><br><span class="line">schema.path(<span class="string">'name'</span>).get(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v +<span class="string">' is my name'</span>;</span><br><span class="line">&#125;);</span><br><span class="line">schema.set(<span class="string">'toJSON'</span>,&#123;<span class="attr">getters</span>:<span class="literal">true</span>,<span class="attr">virituals</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> M = mongoose.model(<span class="string">'Person'</span>,schema);</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> M(&#123;<span class="attr">name</span>:<span class="string">'Max Headroom'</span>&#125;);     </span><br><span class="line">m.toObject(); <span class="comment">// &#123;_id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom' &#125;</span></span><br><span class="line">m.toJSON(); <span class="comment">//  &#123;_id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom is my name' &#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringfy(m); <span class="comment">// &#123; "_id": "504e0cd7dd992d9be2f20b6f", "name": "Max Headroom is my name" &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>option：toObject</strong></p>
<p>Documents 的 toObject 方法可以把文档转换成一个 plain javascript object （也就是去掉里面的方法）。 这是一个可以接收多个参数的方法，我们可以在 schemas 定义这些参数。</p>
<p>例如要打印出虚拟值，可以向 <code>toObject</code> 传入 <code>{ getters: true }</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;);</span><br><span class="line">schema.path(<span class="string">'name'</span>).get(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v + <span class="string">'is my name'</span></span><br><span class="line">&#125;);</span><br><span class="line">schema.set(<span class="string">'toObject'</span>,&#123;<span class="attr">getters</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> M = mongoose.model(<span class="string">'Person'</span>,schema);</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> M(&#123;<span class="attr">name</span>:<span class="string">'HAHA'</span>&#125;);</span><br><span class="line">m <span class="comment">// &#123; _id: 504e0cd7dd992d9be2f20b6f, name: 'HAHA is my name' &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>option：typekey</strong></p>
<p>类型声明</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">loc</span>:&#123;<span class="attr">type</span>:<span class="built_in">String</span>,<span class="attr">coordinates</span>:[<span class="built_in">Number</span>]&#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>对于像geoJSON这样的应用程序，“type”属性非常重要。控制使用哪个键mongoose来查找类型声明，要设置“typeKey”模式选项</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    loc:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        coordinates:[<span class="built_in">Number</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    name:&#123;</span><br><span class="line">        $type:<span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,&#123;<span class="attr">typeKey</span>:<span class="string">'$type'</span>&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>option：validateBeforeSave</strong></p>
<p>默认情况下，文档在保存到数据库之前会自动验证。这是为了防止保存无效的文档。如果希望手动处理验证，并能够保存没有通过验证的对象，可以将validatebeforeave设置为false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123; <span class="attr">name</span>: <span class="built_in">String</span> &#125;);</span><br><span class="line">schema.set(<span class="string">'validateBeforeSave'</span>, <span class="literal">false</span>);</span><br><span class="line">schema.path(<span class="string">'name'</span>).validate(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v != <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> M = mongoose.model(<span class="string">'Person'</span>, schema);</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> M(&#123; <span class="attr">name</span>: <span class="literal">null</span> &#125;);</span><br><span class="line">m.validate(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// Will tell you that null is not allowed.</span></span><br><span class="line">&#125;);</span><br><span class="line">m.save(); <span class="comment">// Succeeds despite being invalid</span></span><br></pre></td></tr></table></figure>
<p><strong>option：versionKey</strong></p>
<p><code>versionKey</code> 是 Mongoose 在文件创建时自动设定的。 这个值包含文件的内部<a href="http://aaronheckmann.tumblr.com/post/48943525537/mongoose-v3-part-1-versioning">修订号</a>。 <code>versionKey</code> 是一个字符串，代表版本号的属性名， 默认值为 <code>__v</code>。如果这个值与你的计划冲突，你可以设定为其他名称：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123; <span class="attr">name</span>: <span class="string">'string'</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>, schema);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing(&#123; <span class="attr">name</span>: <span class="string">'mongoose v3'</span> &#125;);</span><br><span class="line">thing.save(); <span class="comment">// &#123; __v: 0, name: 'mongoose v3' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// customized versionKey</span></span><br><span class="line"><span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">versionKey</span>: <span class="string">'_somethingElse'</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>, schema);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing(&#123; <span class="attr">name</span>: <span class="string">'mongoose v3'</span> &#125;);</span><br><span class="line">thing.save(); <span class="comment">// &#123; _somethingElse: 0, name: 'mongoose v3' &#125;</span></span><br></pre></td></tr></table></figure>
<p>你也可以赋值为 <code>false</code> 禁用 <code>versionKey</code>。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Schema(&#123;..&#125;, &#123; <span class="attr">versionKey</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>, schema);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing(&#123; <span class="attr">name</span>: <span class="string">'no versioning please'</span> &#125;);</span><br><span class="line">thing.save(); <span class="comment">// &#123; name: 'no versioning please' &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>option：collation</strong></p>
<p>为 查询（query）和 聚合（aggregation）设置 collation</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">    collaction:&#123;</span><br><span class="line">        locale:<span class="string">'en_US'</span>,</span><br><span class="line">        strength:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyModel = db.model(<span class="string">'MyModel'</span>,schema);</span><br><span class="line">myModel.create([&#123;<span class="attr">name</span>:<span class="string">'val'</span>,&#123;<span class="attr">name</span>:<span class="string">'Val'</span>&#125;]).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MyModel.find(&#123;<span class="attr">name</span>:<span class="string">'Val'</span>&#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">docs</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// docs 里面会包含上面两个值，因为 strength：1 代表着忽略大小写</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>option：skipVersioning</strong></p>
<p>跳过版本控制允许从版本控制中排除路径(例如。，即使更新了这些路径，也不会增加内部修订)。除非你知道你在做什么，否则不要这样做。对于子文档，使用完全限定路径将其包含在父文档中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">skipVersioning</span>: &#123; <span class="attr">dontVersionMe</span>: <span class="literal">true</span> &#125; &#125;);</span><br><span class="line">thing.dontVersionMe.push(<span class="string">'hey'</span>);</span><br><span class="line">thing.save(); <span class="comment">// version is not incremented</span></span><br></pre></td></tr></table></figure>
<p><strong>option：timestamps</strong></p>
<p>如果设置了 <code>timestamps</code> 选项, mongoose 会在你的 schema 自动添加 <code>createdAt</code> 和 <code>updatedAt</code> 字段， 其类型为Date。这两个字段的默认名称是 <code>createAt</code>和 <code>updateAt</code>，你可以通过设定 <code>timestamps.createAt</code> 和 <code>timestamps.updateAt</code> 自定义名称。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thingSchema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">timestamps</span>: &#123; <span class="attr">createdAt</span>: <span class="string">'created_at'</span> &#125; &#125;);</span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>, thingSchema);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing();</span><br><span class="line">thing.save(); <span class="comment">// `created_at` &amp; `updatedAt` will be included</span></span><br></pre></td></tr></table></figure>
<p><strong>option：useNestedStrict</strong></p>
<p>在 mongoose4 中，<code>update()</code> 和 <code>findOneAndUpdate()</code>只检查顶层 schema 的严格模式设定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> childSchema = <span class="keyword">new</span> Schema(&#123;&#125;, &#123; <span class="attr">strict</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> parentSchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">child</span>: childSchema &#125;, &#123; <span class="attr">strict</span>: <span class="string">'throw'</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> Parent = mongoose.model(<span class="string">'Parent'</span>, parentSchema);</span><br><span class="line">Parent.update(&#123;&#125;, &#123; <span class="string">'child.name'</span>: <span class="string">'Luke Skywalker'</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 报错！原因是父Schema设定为`strict: throw`，但是因为只检查顶层，导致</span></span><br><span class="line">  <span class="comment">// 子Schema的 `strict: false` 遭到无情忽视</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> update = &#123; <span class="string">'child.name'</span>: <span class="string">'Luke Skywalker'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> opts = &#123; <span class="attr">strict</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">Parent.update(&#123;&#125;, update, opts, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这样可以，因为重写了父Schema的 strict 选项</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果你把 <code>useNestedStrict</code> 设为 true，mongoose 就不会忽略嵌套的 strict 设定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> childSchema = <span class="keyword">new</span> Schema(&#123;&#125;, &#123; <span class="attr">strict</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> parentSchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">child</span>: childSchema &#125;,</span><br><span class="line">  &#123; <span class="attr">strict</span>: <span class="string">'throw'</span>, <span class="attr">useNestedStrict</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> Parent = mongoose.model(<span class="string">'Parent'</span>, parentSchema);</span><br><span class="line">Parent.update(&#123;&#125;, &#123; <span class="string">'child.name'</span>: <span class="string">'Luke Skywalker'</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Works!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="模式类型（SchemaTypes）"><a href="#模式类型（SchemaTypes）" class="headerlink" title="模式类型（SchemaTypes）"></a>模式类型（SchemaTypes）</h3><p>SchemaTypes 是处理字段路径各种属性的定义（默认值、验证、getter、setter、查询的字段选择默认值，以及字符串和数字的其他一般特性）</p>
<p>下面是合法的 SchemaTypes：</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Date</li>
<li>Buffer</li>
<li>Boolean</li>
<li>Mixed</li>
<li>ObjectId</li>
<li>Array</li>
<li>Decimal128</li>
</ul>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    binary:Buffer,</span><br><span class="line">    living:<span class="built_in">Boolean</span>,</span><br><span class="line">    updated:&#123;</span><br><span class="line">        type:<span class="built_in">Date</span>,</span><br><span class="line">        <span class="keyword">default</span>:<span class="built_in">Date</span>.now</span><br><span class="line">    &#125;,</span><br><span class="line">    age:&#123;</span><br><span class="line">        type:<span class="built_in">Number</span>,</span><br><span class="line">        min:<span class="number">18</span>,</span><br><span class="line">        max:<span class="number">65</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mixed:Schema.Types.Mixed,</span><br><span class="line">    _someId:Schema.Types.ObjectId,</span><br><span class="line">    decimal:Schema.Types.Decimal128,</span><br><span class="line">    array:[],</span><br><span class="line">    ofString:[<span class="built_in">String</span>],</span><br><span class="line">    ofNumber:[<span class="built_in">Number</span>],</span><br><span class="line">    ofDates:[<span class="built_in">Date</span>],</span><br><span class="line">    ofBuffer:[Buffer],</span><br><span class="line">    ofBoolean:[<span class="built_in">Boolean</span>],</span><br><span class="line">    ofMixed:[Schema.Types.Mixed],</span><br><span class="line">    ofObjectId:[Schema.Types.ObjectId],</span><br><span class="line">    ofArrays:[[]],</span><br><span class="line">    ofArrayOfNumbers:[[<span class="built_in">Number</span>]],</span><br><span class="line">    nested:&#123;</span><br><span class="line">        stuff:&#123;</span><br><span class="line">            type:<span class="built_in">String</span>,</span><br><span class="line">            lowercase:<span class="literal">true</span>,</span><br><span class="line">            trim:<span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>,schema);</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> Thing;</span><br><span class="line">m.name = <span class="string">'haha'</span>;</span><br><span class="line">m.age = <span class="number">125</span>;</span><br><span class="line">m.updated = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line">m.binary = <span class="keyword">new</span> Buffer(<span class="number">0</span>);</span><br><span class="line">m.mixed = &#123;</span><br><span class="line">    any:&#123;</span><br><span class="line">        thing:<span class="string">'i want'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">m.markModified(<span class="string">'mixed'</span>);</span><br><span class="line">m._someId = <span class="keyword">new</span> mongoose.Typed.ObjectId;</span><br><span class="line">m.array.push(<span class="number">1</span>);</span><br><span class="line">m.ofString.push(<span class="string">'strings!'</span>);</span><br><span class="line">m.ofNumber.unshift(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">m.ofDates.addToSet(<span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">m.ofBuffer.pop();</span><br><span class="line">m.ofMixed = [<span class="number">1</span>,[],<span class="string">'three'</span>,&#123;<span class="attr">four</span>:<span class="number">5</span>&#125;]</span><br><span class="line">m.nested.stuff = <span class="string">'good'</span>;</span><br><span class="line">m.save(callback);</span><br></pre></td></tr></table></figure>
<h4 id="SchemaType-选项"><a href="#SchemaType-选项" class="headerlink" title="SchemaType 选项"></a>SchemaType 选项</h4><p>可以直接声明 schema type 为某一种 type，或者赋值一个含有 type 属性的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    test:<span class="built_in">String</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> schema2 = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    test:&#123;</span><br><span class="line">        type:<span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>除了 type 属性，还可以对这个字段路径指定其他属性，如果要在保存之前把字母都改成小写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema2 = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    test:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        lowercase:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>lowercase</code> 属性只作用于字符串。以下有一些全部type 可用的选项和一些限定部分 type 使用的选项。</p>
<p><strong>全部可用</strong></p>
<ul>
<li><code>required</code>：布尔值或者函数，如果值为真，为此属性添加 required 验证器</li>
<li><code>default</code>：任何值或者函数设置此路径默认值，如果是函数，函数返回值为默认值</li>
<li><code>select</code>：布尔值执行query 默认 projections</li>
<li><code>validate</code>：属性验证函数</li>
<li><code>get</code>：函数 使用 <code>Object.defineProperty()</code> 定义自定义 getter</li>
<li><code>set</code>：函数 使用 <code>Object.defineProperty()</code> 定义自定义 setter</li>
<li><code>alias</code>：字符串 仅mongoose &gt;= 4.10.0。 为该字段路径定义虚拟值 gets/sets</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numberSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    integerOnly:&#123;</span><br><span class="line">        type:<span class="built_in">Number</span>,</span><br><span class="line">        get:<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">Math</span>.round(v),</span><br><span class="line">        set:<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">Math</span>.round(v),</span><br><span class="line">        alias:<span class="string">'i'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Number</span> = mongoose.model(<span class="string">'Number'</span>,numberSchema);</span><br><span class="line"><span class="keyword">const</span> doc = <span class="keyword">new</span> <span class="built_in">Number</span>();</span><br><span class="line">doc.integerOnly = <span class="number">2.001</span>;</span><br><span class="line">doc.integerOnly <span class="comment">// 2</span></span><br><span class="line">doc.i <span class="comment">// 2</span></span><br><span class="line">doc.i = <span class="number">3.001</span>;</span><br><span class="line">doc.integerOnly <span class="comment">//3</span></span><br><span class="line">doc.i <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p><strong>索引相关</strong></p>
<p>可以使用 schema type 选项定义 MongoDB  indexex</p>
<ul>
<li><code>index</code>:布尔值 是否对这个属性创建索引</li>
<li><code>unique</code>:布尔值 是否对这个属性创建唯一索引</li>
<li><code>sparse</code>:布尔值 是否对这个属性创建稀疏索引</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    test:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        index:<span class="literal">true</span>,</span><br><span class="line">        unique:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>String</p>
<ul>
<li><code>lowercase</code>: 布尔值 是否保存前对此值调用 <code>.toLowerCase()</code></li>
<li><code>uppercase</code>: 布尔值 是否保存前对此值调用 <code>.toUpperCase()</code></li>
<li><code>trim</code>: 布尔值 是否在保存前对此值调用  <code>trim()</code></li>
<li><code>match</code>:正则表达式 创建验证器检查这个值是否匹配给定正则表达式</li>
<li><code>enum</code>:数组 创建验证器检查这个值是否包含于给定数组</li>
</ul>
<p>Number </p>
<ul>
<li><code>min</code>:数值 创建验证器检查属性是否大于或者等于该值</li>
<li><code>max</code>:数值 创建验证器检查属性是否小于或者等于该值</li>
</ul>
<p>Date</p>
<ul>
<li><code>min</code>:Date</li>
<li><code>max</code>:Date</li>
</ul>
<h4 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a><strong>使用注意</strong></h4><p><strong>Dates</strong></p>
<p>内建的 Date 方法不会触发 mongoose 修改跟踪逻辑，如果使用 <code>setMonth()</code> 修改文档里面的 <code>Date</code>,mongoose 在 <code>doc.save()</code> 的时候是察觉不到这个文档发生了变化的，因此保存不到数据库中。如果一定要用内建的 Date 方法，需要手动调用 <code>doc.markModified(&#39;pathToYourDate&#39;)</code>告诉 mongoose 修改了数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Assignment = mongoose.model(<span class="string">'Assignment'</span>,&#123;<span class="attr">dueDate</span>:<span class="built_in">Date</span>&#125;);</span><br><span class="line">Assignment.findOne(<span class="function"><span class="keyword">function</span>(<span class="params">err,doc</span>)</span>&#123;</span><br><span class="line">    doc.dueDate.setMonth(<span class="number">3</span>);</span><br><span class="line">    doc.save(callback); <span class="comment">// 这个不会保存你的修改</span></span><br><span class="line">    doc.markModified(<span class="string">'dueDate'</span>);</span><br><span class="line">    doc.save(callback);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>Mixed</strong></p>
<p>一个什么都可以放的 SchemaType,虽然遍历，但是也会让数据难以维护。Mixed 可以通过 Schema.Types.Mixed 或者传入 一个空对象定义。下面三种方法效果是一致的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Any = <span class="keyword">new</span> Schema(&#123;<span class="attr">any</span>:&#123;&#125;&#125;);</span><br><span class="line"><span class="keyword">const</span> Any = <span class="keyword">new</span> Schema(&#123;<span class="attr">any</span>:<span class="built_in">Object</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Any = <span class="keyword">new</span> Schema(&#123;<span class="attr">any</span>:Schema.Types.Mixed&#125;);</span><br></pre></td></tr></table></figure>
<p>因为这是个 schema-less type，所以可以赋值为任意类型，但是 mongoose 无法自动检测并保存修改。要告诉它修改了 Mixed type 的值，调用文档的 <code>.markModified(path)</code> 方法，传入你的 Mixed 字段路径</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person.anything = &#123;<span class="attr">x</span>:[<span class="number">3</span>,<span class="number">4</span>,&#123;<span class="attr">y</span>:<span class="string">'changed'</span>&#125;]&#125;</span><br><span class="line">person.markModified(<span class="string">'anything'</span>);</span><br><span class="line">person.save(); <span class="comment">// anything will now get changed</span></span><br></pre></td></tr></table></figure>
<p><strong>ObjectIds</strong></p>
<p>要指定类型为 ObjectId，在声明中使用 <code>Schema.Types.ObjectId</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> ObjectId = mongoose.Schema.Types.ObjectId;</span><br><span class="line"><span class="keyword">const</span> Car = <span class="keyword">new</span> Schema(&#123;<span class="attr">driver</span>:ObjectId&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>Arrays</strong></p>
<p>创造 SchemaTypes 或者子文档数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ToySchema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> ToyBox = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    toys:[ToySchema],</span><br><span class="line">    buffers:[Buffer],</span><br><span class="line">    string:[<span class="built_in">String</span>]，</span><br><span class="line">    number:[<span class="built_in">Number</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意：指定空数组相当于  <code>Mixed</code>,下面的操作相当于创建 <code>Mixed</code>数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Empty1 = <span class="keyword">new</span> Schema(&#123;<span class="attr">ary</span>:&#123;]&#125;&#125;);</span><br><span class="line"><span class="keyword">const</span> Empty2 = <span class="keyword">new</span> Schema(&#123;<span class="attr">any</span>:<span class="built_in">Array</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Empty3 = <span class="keyword">new</span> Schema(&#123;<span class="attr">any</span>:[Schema.Types.Mixed]&#125;);</span><br><span class="line"><span class="keyword">const</span> Empty4 = <span class="keyword">new</span> Schema(&#123;<span class="attr">any</span>:[&#123;&#125;]&#125;);</span><br></pre></td></tr></table></figure>
<p>数组的默认值是 <code>[]</code>（空数组）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Toy = mongoose.model(<span class="string">'Test'</span>,toySchema);</span><br><span class="line"><span class="keyword">new</span> Toy().toys <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>要手动把默认值设置为 <code>undefined</code>，从而覆盖 <code>[]</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ToySchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    toys:&#123;</span><br><span class="line">        type:[ToySchema],</span><br><span class="line">        defalut:<span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="创建自定义-Type"><a href="#创建自定义-Type" class="headerlink" title="创建自定义 Type"></a><strong>创建自定义 Type</strong></h4><p>Mongoose 可以扩展自定义 SchemaType.</p>
<p><strong><code>schema.path()</code>函数</strong></p>
<p>这个函数为给定字段路径返回实例化 schema type</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sampleSchema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:&#123;<span class="attr">type</span>:<span class="built_in">String</span>,<span class="attr">require</span>:<span class="literal">true</span>&#125;&#125;);</span><br><span class="line">sampleSchema.path(<span class="string">'name'</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* SchemaString &#123;</span></span><br><span class="line"><span class="comment"> *   enumValues: [],</span></span><br><span class="line"><span class="comment"> *   regExp: null,</span></span><br><span class="line"><span class="comment"> *   path: 'name',</span></span><br><span class="line"><span class="comment"> *   instance: 'String',</span></span><br><span class="line"><span class="comment"> *   validators: ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这个函数可以检查给定字段路径的检查器和类型等信息。</p>
<h3 id="连接（Connections）"><a href="#连接（Connections）" class="headerlink" title="连接（Connections）"></a>连接（Connections）</h3><p>可以使用 <code>mongoose.connect()</code>方法连接 MongoDB</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://localhost/myapp'</span>);</span><br></pre></td></tr></table></figure>
<p>这是连接本地 <code>myapp</code>数据库默认接口（27017）的最小配置。本地连接失败可以尝试 127.0.0.1.local hostname 被修改有时候会引起问题。</p>
<p>可以在 url 中指定多个参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://username:password@host:port/database?options'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="操作缓存"><a href="#操作缓存" class="headerlink" title="操作缓存"></a><strong>操作缓存</strong></h4><p>不必等等连接建立成功就可以使用 Mongoose models</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://localhost/myapp'</span>);</span><br><span class="line"><span class="keyword">const</span> MyModel = mongoose.model(<span class="string">'Test'</span>,<span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;));</span><br><span class="line">MyModel.findOne(<span class="function"><span class="keyword">function</span>(<span class="params">err,res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Mongoose 会缓存 model 操作。这个操作很方便，但也会引起一些疑惑，因为如果没有连上的话，Mongoose 不会抛错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyModel = mongoose.model(<span class="string">'Test'</span>,<span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;));</span><br><span class="line">MyModel.findOne(<span class="function"><span class="keyword">function</span>(<span class="params">err,res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    mongoose.connect(<span class="string">'mongodb://localhost/xxx'</span>);</span><br><span class="line">&#125;,<span class="number">6000</span>);</span><br></pre></td></tr></table></figure>
<p>要禁用缓存，修改 bufferCommands 配置。如果打开了这个选项连接被挂起，尝试关闭 bufferCommands 检查是否正确打开连接，也可以全局禁用 bufferCommands:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.set(<span class="string">'bufferCommands'</span>,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h4 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a><strong>选项</strong></h4><p><code>connect</code> 方法也接受 <code>options</code> 参数，这些参数会传入底层 MongoDB 驱动</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(uri,options);</span><br></pre></td></tr></table></figure>
<p>Mongoose 会不做修改直接把选项传到驱动，以下有一点例外</p>
<ul>
<li><code>bufferCommands</code> 是 mongoose 特有的选项，</li>
<li><code>user/pass</code>  用于认证的用户名和密码。mongoose 特有的，等价于 MongoDB 驱动的 <code>auth.user</code> 和 <code>auth.password</code>选项</li>
<li><code>autoIndex</code> 理想情况下，mongoose 在连接时会自动建立 schema 索引。这有利于开发，但是在大型生产环境中不是很理想，因为会导致性能下降。</li>
<li><code>dbName</code> 指定要连接的数据库名称（覆盖连接字符串）</li>
</ul>
<p>下面是一些重要的选项</p>
<ul>
<li><code>autoReconnect</code> 底层 MongoDB 驱动在连接后将自动重连。除非是管理连接池的高手，不然不建议设置为 false</li>
<li><code>bufferMaxEntries</code> MongoDB 驱动同样有自己的离线缓存机制。如果希望连接错误时终止数据库操作，可以设这个值为 0 以及把 bufferCommands 设为 false.</li>
<li><code>promiseLibrary</code> 设置底层 promise 库</li>
<li><code>poolSize</code> MongoDB 保持的最大 socket 连接数。默认是5.MongoDB 3.4 之前，只允许每个 socket 同时进行一个操作，所以如果有几个缓慢请求卡着后面快的请求，可以尝试增加连接数。</li>
</ul>
<p>举例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    useMongoClient:<span class="literal">true</span>,</span><br><span class="line">    autoIndex:<span class="literal">false</span>, <span class="comment">// 不要创建索引</span></span><br><span class="line">    reconnectTries:<span class="built_in">Number</span>.MAX_VALUE, <span class="comment">// 不要停止重连</span></span><br><span class="line">    reconnectInterval:<span class="number">500</span>, <span class="comment">// 每500毫秒重连</span></span><br><span class="line">    poolSize:<span class="number">10</span>, <span class="comment">// 维护最多10个socket</span></span><br><span class="line">    bufferMaxEntries:<span class="number">0</span> <span class="comment">// 如果没有连接，则立即返回错误，而不是等待重新连接</span></span><br><span class="line">&#125;</span><br><span class="line">mongoose.connect(uri,options);</span><br></pre></td></tr></table></figure>
<h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a><strong>回调</strong></h4><p><code>connect</code> 函数接受回调函数，或者返回一个 promise</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(uri,options,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line">mongoose.connect(uri,options).then(</span><br><span class="line">    ()=&gt;&#123;<span class="comment">/** ready to use. The `mongoose.connect()` promise resolves to undefined. */</span> &#125;</span><br><span class="line">    err=&gt;&#123;<span class="comment">/** handle initial connection error */</span>&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="连接字符串（Connectng-String）选项"><a href="#连接字符串（Connectng-String）选项" class="headerlink" title="连接字符串（Connectng String）选项"></a><strong>连接字符串（Connectng String）选项</strong></h4><p>可以在连接字符串填写驱动选项，这只适用于 MongoDB 驱动使用的选项，所以类似 bufferCommands 的 Mongoose 专用选项不能在连接字符串使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://localhost:27017/test?connectTimeoutMS=1000&amp;bufferCommands=false'</span>);</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">mongoose.connect(<span class="string">'mongodb://localhost:27017/test'</span>, &#123;</span><br><span class="line">  connectTimeoutMS: <span class="number">1000</span></span><br><span class="line">  <span class="comment">// Note that mongoose will **not** pull `bufferCommands` from the query string</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>把选项放在连接字符串的劣势是不便阅读。优势是简短。最佳实践是把区分生产环境和开发环境的选项，<code>socketTimeoutMS</code> 、 <code>connectTimeoutMS</code> 放在 uri ， 把通用的常量如 <code>connectTimeoutMS</code> 、 <code>poolSize</code> 放在选项对象里。</p>
<h4 id="keepAlive注意事项"><a href="#keepAlive注意事项" class="headerlink" title="keepAlive注意事项"></a><strong>keepAlive注意事项</strong></h4><p>对于长期运行的后台引用，启用毫秒级 <code>keepAlive</code>是一个精明的操作。不这么做偶尔会经常收到看似没有什么原因的 <code>connection closed</code> 错误</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(uri,&#123;<span class="attr">keepAlive</span>:<span class="number">120</span>&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="副本集（Replica-Set）连接"><a href="#副本集（Replica-Set）连接" class="headerlink" title="副本集（Replica Set）连接"></a><strong>副本集（Replica Set）连接</strong></h4><p>要连接到副本集，可以使用逗号分隔开，传入多个地址：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]'</span> [, options]);</span><br></pre></td></tr></table></figure>
<p>连接到单节点副本集，需要指定 <code>relicaSet</code> 选项</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://host1:port1/?replicaSet=rsName'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="多-mongos-支持"><a href="#多-mongos-支持" class="headerlink" title="多 mongos 支持"></a><strong>多 mongos 支持</strong></h4><p>使用高性能分片集群，需要连接<a href="https://docs.mongodb.com/manual/reference/program/mongos/">多个 mongos（MongoDB Shard） 实例</a>。 在 mongoose 5.x 中， 你在连接多个 mongos 时<a href="http://mongodb.github.io/node-mongodb-native/3.0/tutorials/connect/#connect-to-sharded-cluster">不需要传入任何特殊选项</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connect to 2 mongos servers</span></span><br><span class="line">mongoose.connect(<span class="string">'mongodb://mongosA:27501,mongosB:27501'</span>, cb);</span><br></pre></td></tr></table></figure>
<h4 id="多个连接"><a href="#多个连接" class="headerlink" title="多个连接"></a><strong>多个连接</strong></h4><p>之前我们了解如何使用 Mongoose 默认连接方法连接到 MongoDB。但有时候我们需要权限不同的多个连接， 或是连接到不同数据库。这个情况下我们可以使用 <code>mongoose.createConnection()</code>， 它接受之前提到的所有参数，给你返回一个新的连接。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> conn = mongoose.createConnection(<span class="string">'mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]'</span>, options);</span><br></pre></td></tr></table></figure>
<p>connection对象后续用于创建和检索models。 models 的范围总是局限于单个连接。</p>
<p>调用 <code>mongoose.connect()</code> 时，Mongoose 会自动创建<strong>默认连接</strong>。 你可以使用 <code>mongoose.connection</code> 访问默认连接。</p>
<h4 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a><strong>连接池</strong></h4><p>无论是使用 <code>mongoose.connect</code> 或是 <code>mongoose.createConnection</code> 创建的连接， 都被纳入默认最大为 5 的连接池，可以通过 poolSize 选项调整：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With object options</span></span><br><span class="line">mongoose.createConnection(uri, &#123; <span class="attr">poolSize</span>: <span class="number">4</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uri = <span class="string">'mongodb://localhost/test?poolSize=4'</span>;</span><br><span class="line">mongoose.createConnection(uri);</span><br></pre></td></tr></table></figure>
<h3 id="模型（Models）"><a href="#模型（Models）" class="headerlink" title="模型（Models）"></a>模型（Models）</h3><p>Models 是从 Schema 编译来的构造函数，它们的实例就代表着可以从数据保存和读取 documents，从数据创建和读取 document 的所有操作都是通过 model 进行的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="string">'string'</span>,<span class="attr">size</span>:<span class="string">'string'</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Tank = mongoose.model(<span class="string">'Tank'</span>,schema);</span><br></pre></td></tr></table></figure>
<p>第一个参数是跟 model 对应的集合（collection） 名字的单数形式。Mongoose 会自动找到名称是 model 名字复数形式的 collection。对于上例，Tank 这个model 就对应 数据库中 tanks 这个 collection.<code>.model()</code> 这个函数是对 <code>schema</code> 做了拷贝（生成了model）。要确保在调用 <code>.model()</code> 之前把所有需要的东西都加进去 <code>schema</code>里面。</p>
<h4 id="构造-documents"><a href="#构造-documents" class="headerlink" title="构造 documents"></a><strong>构造 documents</strong></h4><p>Documents 是 model 的实例，创建它们并保存到数据库非常简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Tank = mongoose.model(<span class="string">'Tank'</span>,yourSchema);</span><br><span class="line"><span class="keyword">const</span> small = <span class="keyword">new</span> Tank(&#123;<span class="attr">size</span>:<span class="string">'small'</span>&#125;);</span><br><span class="line">small.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Tank.create(&#123;<span class="attr">size</span>:<span class="string">'small'</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,small</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>要注意，知道 model 使用的数据连接（connection）被打开，tanks 才会被创建/删除，每个 model 都有一个绑定的连接。如果model 是通过调用 <code>mongoose.model()</code> 生成的，它将使用 mongoose 的默认连接。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'localhost'</span>,<span class="string">'gettingstarted'</span>)</span><br></pre></td></tr></table></figure>
<p>如果自行创建了连接，就需要使用 connection 的 <code>model</code>函数代替 mongoose 的 <code>model</code>函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> connection = mongoose.createConnection(<span class="string">'mongodb://localhost:27017/test'</span>);</span><br><span class="line"><span class="keyword">const</span> Tank = connection.model(<span class="string">'Tank'</span>,yourSchema);</span><br></pre></td></tr></table></figure>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a><strong>查询</strong></h4><p>用 mongoose 查询文档相当容易，它支持 mongoDB的高级查询语法（rich），查询文档可以使用 <code>model</code>的 find,findById,findOne,where 这些静态方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tank.find(&#123;<span class="attr">size</span>:<span class="string">'small'</span>&#125;).where(<span class="string">'createDate'</span>).gt(oneYearAgo).exec(callback);</span><br></pre></td></tr></table></figure>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a><strong>删除</strong></h4><p><code>model</code>的 <code>remove</code>方法可以删除所有匹配查询条件的文档</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tank.remove(&#123;<span class="attr">size</span>:<span class="string">'large'</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a><strong>更新</strong></h4><p><code>model</code>的 <code>update</code>方法可以修改数据库中的文档，不过不会把文档返回给应用层。</p>
<p>如果想更新单独一条文档并且返回给应用层，可以使用 findOneAndIUpdate 方法</p>
<h3 id="文档（Documents）"><a href="#文档（Documents）" class="headerlink" title="文档（Documents）"></a>文档（Documents）</h3><p>Mongoose documents代表着MongoDB 文档的一对一映射，每个 document 都是他的 Model 实例。</p>
<h4 id="检索"><a href="#检索" class="headerlink" title="检索"></a><strong>检索</strong></h4><p>MongoDB  有很多检索数据的方法。</p>
<h4 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a><strong>更新</strong></h4><p>Document 更新的方法同样也有很多,最基本的 findById</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Tank.findById(id,<span class="function"><span class="keyword">function</span>(<span class="params">err,tank</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    tank.size = <span class="string">'large'</span>;</span><br><span class="line">    tank.save(<span class="function"><span class="keyword">function</span>(<span class="params">err,updateTank</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">        res.send(updateTank);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>也可以用 <code>.set()</code> 修改 document 。在底层，<code>tank.size = &#39;large&#39;</code>，用 <code>tank.set({size:&#39;large&#39;})</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Tank.findById(id,<span class="function"><span class="keyword">function</span>(<span class="params">err,tank</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    tank.set(&#123;<span class="attr">size</span>:<span class="string">'large'</span>&#125;);</span><br><span class="line">    tank.save(<span class="function"><span class="keyword">function</span>(<span class="params">err,updateTank</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">        res.send(updateTank);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个方法先检索了数据，接着更新（使用了<code>save</code>）。如果我们仅仅需要更新而不是获取该数据，<code>model#update</code>就很适合我们：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tank.update(&#123;<span class="attr">_id</span>:id&#125;,&#123;<span class="attr">$set</span>:&#123;<span class="attr">size</span>:<span class="string">'large'</span>&#125;&#125;,callback);</span><br></pre></td></tr></table></figure>
<p>如果我们确实需要返回文档，下面的方法更加适合：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tank.findByIdAndUpdate(id,&#123;<span class="attr">$set</span>:&#123;<span class="attr">size</span>:<span class="string">'large'</span>&#125;&#125;,&#123;<span class="attr">new</span>:<span class="literal">true</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,tank</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    res.send(tank);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>findAndUpdate/Remove</code>系列静态方法查找并返回最多1个文档，模式的方法有不少。</p>
<p>注意：<code>findAndUpdata/Remove</code>不会修改数据库时执行任何钩子或者验证。可以使用 <code>runValidators</code> 选项获取一个验证的限制子集。但是需要钩子和全文档验证的，还是先query 在save </p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h4><p>Document 会在被保存之前验证。</p>
<h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a><strong>覆盖</strong></h4><p>可以用 <code>.set()</code> 覆盖整个文档。如果要修改在中间件中被保存的文档，这样就很方便了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tank.findById(id,<span class="function"><span class="keyword">function</span>(<span class="params">err,tank</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError();</span><br><span class="line">    <span class="comment">// otherTank 是 tank 的副本</span></span><br><span class="line">    otherTank.set(tank)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="子文档（Subdocuments）"><a href="#子文档（Subdocuments）" class="headerlink" title="子文档（Subdocuments）"></a>子文档（Subdocuments）</h3><p>子文档是指嵌套在另一个文档中的文档。在 Mongoose 中，这意味着可以在 里面嵌套一个 schema 。Mongoose 子文档有两种不同的概念：子文档数组和单个嵌套子文档。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> childSchema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="string">'string'</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> parentSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    children:[childSchema],</span><br><span class="line">    <span class="comment">// Single nested subdocuments. Caveat: single nested subdocs only work in mongoose &gt;= 4.2.0</span></span><br><span class="line">    child:childSchema</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>子文档和普通 docuemnt 类似。嵌套 schema 可以有自己的中间件，自定义检索逻辑、虚拟值已经其他顶层 schemas 可用的特性，两者主要的不同点是子文档不能单独保存，他们会在他们的顶级文档保存时保存。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Parent = mongoose.model(<span class="string">'Parent'</span>,parentSchema);</span><br><span class="line"><span class="keyword">const</span> parent = <span class="keyword">new</span> Parent([children:[&#123;<span class="attr">name</span>:<span class="string">'Matt'</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'Sarah'</span>&#125;]]);</span><br><span class="line">parent.children[<span class="number">0</span>].name = <span class="string">'HaHa'</span>;</span><br><span class="line"><span class="comment">// parent.children[0].save() 无操作，虽然他触发了中间件，但是没有保存文档，需要 save 他的文档、</span></span><br><span class="line">parent.save(callback);</span><br></pre></td></tr></table></figure>
<p>子文档跟普通文档一样有 save 和 validate 中间件，调用福文档的 save 会触发所有子文档的 save 中间件， validate 中间件同理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">childSchema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">'invalid'</span> == <span class="keyword">this</span>.name)&#123;</span><br><span class="line">       <span class="keyword">return</span> next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'#sadpanda'</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> parent = <span class="keyword">new</span> Parent(&#123;<span class="attr">children</span>:[&#123;<span class="attr">name</span>:<span class="string">'invalid'</span>&#125;]&#125;);</span><br><span class="line">parent.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.message); <span class="comment">//#sadpanda</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>子文档的 <code>pre(&#39;save&#39;)</code> 和 <code>pre(&#39;validate&#39;)</code>中间件执行于顶层 document <code>pre(&#39;save&#39;)</code> 之前，顶层 document 的 <code>pre(&#39;validate&#39;)</code>之后。因为 <code>save()</code>前的验证就是一个中间件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> childSchema = <span class="keyword">new</span> mongoose.Schema(&#123;<span class="attr">name</span>:<span class="string">'string'</span>&#125;);</span><br><span class="line">childSchema.pre(<span class="string">'validate'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line">childSchema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> parentSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    child:childSchema</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">parentSchema.pre(<span class="string">'validate'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line">parentSchema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 2 3 4</span></span><br></pre></td></tr></table></figure>
<h4 id="查找子文档"><a href="#查找子文档" class="headerlink" title="查找子文档"></a><strong>查找子文档</strong></h4><p>每个子文档都有一个默认 <code>_id</code>，Mongoose document 数组有一个特别的 id 方法，这个方法只要传入 <code>_id</code>就能返回文档数组中特定文档。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doc = parent.children.id(_id);</span><br></pre></td></tr></table></figure>
<h4 id="添加子文档到数组"><a href="#添加子文档到数组" class="headerlink" title="添加子文档到数组"></a><strong>添加子文档到数组</strong></h4><p>Mongoose 数组方法有 push、unshift、addToSet 等等：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Parent = mongoose.model(<span class="string">'Parent'</span>);</span><br><span class="line"><span class="keyword">const</span> parent = <span class="keyword">new</span> Parent;</span><br><span class="line"></span><br><span class="line">parent.children.push(&#123;<span class="attr">name</span>:<span class="string">'Haha'</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> subdoc = parent.children[<span class="number">0</span>];</span><br><span class="line">subdoc; <span class="comment">//  _id: '501d86090d371bab2c0341c5', name: 'Haha' &#125;</span></span><br><span class="line">subdoc.isNew; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">parent.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Success'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>create 方法可以新建文档但是不加入数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newdoc = parent.children.create(&#123;<span class="attr">name</span>:<span class="string">'Haha'</span>&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="删除子文档"><a href="#删除子文档" class="headerlink" title="删除子文档"></a><strong>删除子文档</strong></h4><p>每个子文档都有 remove 方法，另外，对于子文档数组，有一个等效的方法<code>.pull()</code>。对于单个嵌套子文档，remove 与把这个文档的值设为 null 等效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等效 parent.children.pull(_id)</span></span><br><span class="line">parent.children.id(_id).remove()</span><br><span class="line"><span class="comment">// 或者 parent.child = null</span></span><br><span class="line">parent.child.remove();</span><br><span class="line">parent.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'the subdocs were removed'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>代替声明语法的写法</strong></p>
<p>如果用对象的数组创建 schema,mongoose 会自动把对象转成 schema：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parentSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    children:[&#123;<span class="attr">name</span>:<span class="string">'string'</span>&#125;]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">const</span> parentSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    children:[<span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="string">'string'</span>&#125;)]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="查询（queries）"><a href="#查询（queries）" class="headerlink" title="查询（queries）"></a>查询（queries）</h3><p>Model 的多个静态辅助方法都可以查询文档。</p>
<p>Model 的方法中包含查询条件参数的（find findById count update）都可以按照下面两种方式执行：</p>
<ol>
<li>传入 callback 参数，操作会被立即执行，查询结果被传给回调函数（callback）</li>
<li>不传 callback 参数，Query 的一个实例（一个 query对象）被返回，这个 query 提供了 构建查询器的特殊接口。</li>
</ol>
<p>Query 实例有一个 <code>.then()</code>函数，用法类似 promise</p>
<p>如果执行查询时传入 callback,就需要用 JSON 文档的格式指定查询条件，JSON 文档的语法跟 MongoDB shell  一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Parent = mongoose.model(<span class="string">'Person'</span>,mySchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询 last name 是 haha 的 person,选中 name 和 occupation 字段</span></span><br><span class="line">Person.findOne(&#123;<span class="string">'name.last'</span>:<span class="string">'haha'</span>&#125;,<span class="string">'name occupation'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,person</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    <span class="built_in">console</span>.log(person.name.first,person.name.last,person.occupation);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的查询被立即执行，查询结果被传入回调函数。Mongoose 中所有的调用函数都是用 <code>callback(error,result)</code>这种模式。如果查询发生错误，<code>error</code>参数即是错误文档，<code>result</code>参数会是 null。如果查询成功，<code>error</code>参数是 null，<code>result</code>即是查询结果。</p>
<p>查询结果的格式取决于做什么操作：findOne() 是单个文档（或者null），find() 是文档列表，count() 是文档数量， update() 是被修改的文档数量。</p>
<p>下面看看不传入 callback 这个参数会是怎么样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找每个  last name 是 haha 的 person</span></span><br><span class="line"><span class="keyword">const</span> query = Person.findOne(&#123;<span class="string">'name.last'</span>:<span class="string">'haha'</span>&#125;);</span><br><span class="line"><span class="comment">// 选择 name 和 occupation 字段</span></span><br><span class="line">query.select(<span class="string">'name occupation'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后执行查询</span></span><br><span class="line">query.exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,person</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    <span class="built_in">console</span>.log(person.name.first,person.name.last,person.occupation);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码中，query 是 Query 类型的变量，Query 能够用链式语法构建查询器，无需要执行 JSON 对象。下面2个实例等效：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Person.find(&#123;</span><br><span class="line">    occupation:<span class="regexp">/host/</span>,</span><br><span class="line">    <span class="string">'name.last'</span>:<span class="string">'haha'</span>,</span><br><span class="line">    age:&#123;<span class="attr">$gt</span>:<span class="number">17</span>,<span class="attr">$lt</span>:<span class="number">66</span>&#125;,</span><br><span class="line">    likes:&#123;<span class="attr">$in</span>:[<span class="string">'vaporizing'</span>,<span class="string">'talking'</span>]&#125;</span><br><span class="line">&#125;).limit(<span class="number">10</span>).sort(&#123;<span class="attr">occupation</span>:<span class="number">-1</span>&#125;).</span><br><span class="line">select(&#123;<span class="attr">name</span>:<span class="number">1</span>,<span class="attr">ouccupation</span>:<span class="number">1</span>&#125;).</span><br><span class="line">exec(callback);</span><br><span class="line"></span><br><span class="line">Person.find(&#123;<span class="attr">occupation</span>:<span class="regexp">/host/</span>&#125;).</span><br><span class="line">where(<span class="string">'name.last'</span>).equals(<span class="string">'haha'</span>).</span><br><span class="line">where(<span class="string">'age'</span>).gt(<span class="number">17</span>).lt(<span class="number">66</span>).</span><br><span class="line">where(<span class="string">'likes'</span>).in([<span class="string">'vaporizing'</span>,<span class="string">'talking'</span>]).</span><br><span class="line">limit(<span class="number">10</span>).</span><br><span class="line">sort(<span class="string">'-occupation'</span>).</span><br><span class="line">select(<span class="string">'name occupation'</span>).</span><br><span class="line">exec(callback)</span><br></pre></td></tr></table></figure>
<h4 id="引用其他文档"><a href="#引用其他文档" class="headerlink" title="引用其他文档"></a><strong>引用其他文档</strong></h4><p>MongoDB 中没有表连接，但引用其他结合的文档有时候也会需要。population 就是这样当升的。</p>
<p><strong>Streaming</strong></p>
<p>可以用 流式处理 MongoDB 的查询结果，需要调用 Query.cursor() 函数获得 QueryCursor 的一个实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cursor = Person.find(&#123;<span class="attr">occupation</span>:<span class="regexp">/host/</span>&#125;).cursor();</span><br><span class="line"></span><br><span class="line">cursor.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">doc</span>)</span>&#123;<span class="comment">/**Called once for every document*/</span>&#125;);</span><br><span class="line">cursor.on(<span class="string">'close'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/**Called when done*/</span>&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="验证（validation）"><a href="#验证（validation）" class="headerlink" title="验证（validation）"></a>验证（validation）</h3><p>需要先注意下面几点：</p>
<ul>
<li>验证定义于 SchemaType</li>
<li>验证是一个中间件，它默认作为 <code>pre(save)</code>钩子注册在 schema 上</li>
<li>可以使用 <code>doc.validate(callback)</code>或者 <code>doc.validateSync()</code>手动验证</li>
<li>验证器不对未定义的值进行验证，唯一例外就是 require 验证器</li>
<li>验证是异步递归的。当调用 Model#save,子文档也会执行，出错的话 Model#save 回调会接受错误</li>
<li>验证是可以定制的。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="built_in">require</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> Cat = db.model(<span class="string">'Cat'</span>,schema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line">cat.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    assert.equal(error.errors[<span class="string">'name'</span>].message,<span class="string">'Path `name` is required.'</span>);</span><br><span class="line">    error = cat.validateSync();</span><br><span class="line">    assert.equal(error.errors[<span class="string">'name'</span>].message,<span class="string">'Path `name` is required.'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="内建-Validators"><a href="#内建-Validators" class="headerlink" title="内建 Validators"></a><strong>内建 Validators</strong></h4><p>Mongoose 有一些内建验证器</p>
<ul>
<li>所有 SchemaTypes 都有内建的 required 验证器。required 验证器使用 <code>checkRequired（）</code>函数判定这个值是否满足 required 验证器</li>
<li>Numbers 有 min 和 max 验证器</li>
<li>String 有 enum、match、maxlength 和 minlength 验证器</li>
</ul>
<p>上面的链接提供了使用和错误处理相关的详细信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> breakfastSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    eggs:&#123;</span><br><span class="line">        type:<span class="built_in">Number</span>,</span><br><span class="line">        min:[<span class="number">6</span>,<span class="string">'Too few eggs'</span>],</span><br><span class="line">        max:<span class="number">12</span></span><br><span class="line">    &#125;,</span><br><span class="line">    bacon:&#123;</span><br><span class="line">        type:<span class="built_in">Number</span>,</span><br><span class="line">        required:[<span class="literal">true</span>,<span class="string">'Why no bacon'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    drink:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        enum:[<span class="string">'Coffee'</span>,<span class="string">'Tea'</span>],</span><br><span class="line">        required:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.bacon &gt; <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> Breakfast = db.model(<span class="string">'Breakfast'</span>,breakfastSchema);</span><br><span class="line"><span class="keyword">const</span> badBreakfast = <span class="keyword">new</span> Breakfast(&#123;</span><br><span class="line">    eggs:<span class="number">2</span>,</span><br><span class="line">    bacon:<span class="number">0</span>,</span><br><span class="line">    drink:<span class="string">'Milk'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> error = badBreakfast.validateSync();</span><br><span class="line">assert.equal(error.errors[<span class="string">'eggs'</span>].message,<span class="string">'Too few eggs'</span>);</span><br><span class="line">assert.ok(!error.errors[<span class="string">'bacon'</span>]);</span><br><span class="line">assert.equal(error.errors[<span class="string">'drink'</span>].message,<span class="string">'`Milk` is not a valid enum value for path `drink`'</span>);</span><br><span class="line">badBreakfast.bacon = <span class="number">5</span>;</span><br><span class="line">badBreakfast.drink = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">error = badBreakfast.validateSync();</span><br><span class="line">assert.equal(error.errors[<span class="string">'drink'</span>].message,<span class="string">'Path `drink` is required'</span>);</span><br><span class="line"></span><br><span class="line">badBreakfast.bacon = <span class="literal">null</span>;</span><br><span class="line">error = badBreakfast.validateSync();</span><br><span class="line">assert.equal(error.errors[<span class="string">'bacon'</span>].message,<span class="string">'Why no bacon'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="unique不是验证器"><a href="#unique不是验证器" class="headerlink" title="unique不是验证器"></a><strong><code>unique</code>不是验证器</strong></h4><p>它是构建  MongoDB unique indexes 的辅助函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uniqueUsernameSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    username:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        unique:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> U1 = db.model(<span class="string">'U1'</span>,uniqueUsernameSchema);</span><br><span class="line"><span class="keyword">const</span> U2 = db.model(<span class="string">'U2'</span>,uniqueUsernameSchema);</span><br><span class="line"><span class="keyword">const</span> dup = [&#123;<span class="attr">username</span>:<span class="string">'Val'</span>&#125;,&#123;<span class="attr">username</span>:<span class="string">'val'</span>&#125;]</span><br><span class="line"></span><br><span class="line">U1.create(dup,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在保存之前需要等待索引完成构建，否则可能会违反惟一的约束。</span></span><br><span class="line">U2.once(<span class="string">'index'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    assert.ifError(err);</span><br><span class="line">    U2.create(dup,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 重复键错误</span></span><br><span class="line">        assert.ok(err);</span><br><span class="line">        assert.ok(!err.errors);</span><br><span class="line">        assert.ok(error.message.indexOf(<span class="string">'duplicate key error'</span>) != <span class="number">-1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">U2.init().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    U2.create(dup,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 重复键错误</span></span><br><span class="line">        assert.ok(err);</span><br><span class="line">        assert.ok(!err.errors);</span><br><span class="line">        assert.ok(error.message.indexOf(<span class="string">'duplicate key error'</span>) != <span class="number">-1</span>);</span><br><span class="line">    &#125;);   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="自定义验证器"><a href="#自定义验证器" class="headerlink" title="自定义验证器"></a><strong>自定义验证器</strong></h4><p>如果内建检验器不够用了，可以定义满足自己需要的验证器</p>
<p>自定义验证器通过传入一个验证函数来定义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    phone:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        validate:&#123;</span><br><span class="line">            validator:<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="regexp">/\d&#123;3&#125;-d&#123;3&#125;-d&#123;4&#125;/</span>.test(v);</span><br><span class="line">            &#125;,</span><br><span class="line">            message:<span class="string">'&#123;VALUE&#125; is not a valid phone number!'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        required:[<span class="literal">true</span>,<span class="string">'User phone number required'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> User = db.model(<span class="string">'user'</span>,userSchema);</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="keyword">let</span> error;</span><br><span class="line"></span><br><span class="line">user.phone = <span class="string">'555.0123'</span>;</span><br><span class="line">error = user.validateSync();</span><br><span class="line">assert.equal(error.errors[<span class="string">'phone'</span>].message,<span class="string">'555.0123 is not a valid phone number!'</span>);</span><br><span class="line"></span><br><span class="line">user.phone = <span class="string">''</span>;</span><br><span class="line">rror = user.validateSync();</span><br><span class="line">assert.equal(error.errors[<span class="string">'phone'</span>].message,<span class="string">'User phonse number required!'</span>);</span><br><span class="line"></span><br><span class="line">user.phone = <span class="string">'201-555-0123'</span>;</span><br><span class="line">rror = user.validateSync();</span><br><span class="line">assert.equal(error,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h4 id="异步自定义验证器"><a href="#异步自定义验证器" class="headerlink" title="异步自定义验证器"></a><strong>异步自定义验证器</strong></h4><p>自定义验证器可以是异步的，如果检验函数返回 promise (像 <code>async</code>函数)，mongoose 将会等待该 promise 完成。如果更喜欢使用回调函数，设置 <code>isAsync</code>选项，mongoose 会将回调函数作为验证函数的第二个参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="comment">// 可以通过返回一个promise使验证器异步。如果返回一个promise，不要指定' isAsync '选项。</span></span><br><span class="line">        validate:<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                   resolve(<span class="literal">false</span>) </span><br><span class="line">                &#125;,<span class="number">5</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    phone:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        validate:&#123;</span><br><span class="line">            isAsync:<span class="literal">true</span>,</span><br><span class="line">            validator:<span class="function"><span class="keyword">function</span>(<span class="params">v,cb</span>)</span>&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                   <span class="keyword">const</span> phoneRegex = <span class="regexp">/\d&#123;3&#125;-d&#123;3&#125;-d&#123;4&#125;/</span>;</span><br><span class="line">                   <span class="keyword">const</span> msg = v + <span class="string">'is not a valid phone number!'</span>;</span><br><span class="line">                    <span class="comment">// 第一个参数是布尔值代表验证结果</span></span><br><span class="line">                    <span class="comment">// 第二个参数是报错信息</span></span><br><span class="line">                    cb(phoneRegex.test(v),msg);</span><br><span class="line">                &#125;,<span class="number">5</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 默认报错信息会被 cb 的第二个参数覆盖</span></span><br><span class="line">            message:<span class="string">'Default error message'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        required:[<span class="literal">true</span>,<span class="string">'User phone number required'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> User = db.model(<span class="string">'User'</span>,userSchema);</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="keyword">let</span> error;</span><br><span class="line">user.phone = <span class="string">'555.0123'</span>;</span><br><span class="line">user.name = <span class="string">'test'</span>;</span><br><span class="line">user.validate(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    assert.ok(error);</span><br><span class="line">	assert.equal(error.errors[<span class="string">'phone'</span>].message,<span class="string">'555.0123 is not a valid phone number!'</span>);</span><br><span class="line">    assert.equal(error.errors[<span class="string">'name'</span>].message,<span class="string">'Validator failed for path `name` with value `test`'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="验证错误"><a href="#验证错误" class="headerlink" title="验证错误"></a><strong>验证错误</strong></h4><p>验证失败返回 的err 包含一个 <code>ValidatorError</code>对象。每一个 ValidatorError 都有 kind、path、value 和 message 属性。ValidatorError 也有可能有 reason 属性如果验证器抛出错误，这个属性会包含该错误原因。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toySchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    color:<span class="built_in">String</span>,</span><br><span class="line">    name:<span class="built_in">String</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> validator = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/red|white|gold/i</span>.test(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">toySchema.path(<span class="string">'color'</span>）.validate(validator,<span class="string">'Color `&#123;VALUE&#125;` not valid'</span>,<span class="string">'Invalid color'</span>);</span><br><span class="line">toySchema.path(<span class="string">'name'</span>).validate(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v !== <span class="string">'Turbo Man'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Need to get a Turbo Man for Christmas'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;,<span class="string">'Name `&#123;VALUE&#125;` is not valid'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Toy = db.model(<span class="string">'Toy'</span>,toySchema);</span><br><span class="line"><span class="keyword">const</span> toy = <span class="keyword">new</span> Toy(&#123;<span class="attr">color</span>:<span class="string">'Green'</span>,<span class="attr">name</span>:<span class="string">'Power Ranger'</span>&#125;);</span><br><span class="line">toy.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    assert.equal(err.errors.color.message, <span class="string">'Color `Green` not valid'</span>);</span><br><span class="line">    assert.equal(err.errors.color.kind, <span class="string">'Invalid color'</span>);</span><br><span class="line">    assert.equal(err.errors.color.path, <span class="string">'color'</span>);</span><br><span class="line">    assert.equal(err.errors.color.value, <span class="string">'Green'</span>);</span><br><span class="line">    assert.equal(err.errors.name.message,<span class="string">'Need to get a Turbo Man for Christmas'</span>);</span><br><span class="line">    assert.equal(err.errors.name.value, <span class="string">'Power Ranger'</span>);</span><br><span class="line">	assert.equal(err.errors.name.reason.message,<span class="string">'Need to get a Turbo Man for Christmas'</span>);</span><br><span class="line">    assert.equal(err.name, <span class="string">'ValidationError'</span>);    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="嵌套对象中的-Required-验证器"><a href="#嵌套对象中的-Required-验证器" class="headerlink" title="嵌套对象中的 Required 验证器"></a><strong>嵌套对象中的 Required 验证器</strong></h4><p>定义嵌套对象的验证器需要特别注意</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        first:<span class="built_in">String</span>,</span><br><span class="line">        last:<span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">assert.throws(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 这里会报错，因为 name 不是完整路径</span></span><br><span class="line">    personSchema.path(<span class="string">'name'</span>).required(<span class="literal">true</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要让嵌套对象 required 要使用单独的嵌套 schema</span></span><br><span class="line"><span class="keyword">const</span> nameSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:nameSchema,</span><br><span class="line">        required:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">personSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:nameSchema,</span><br><span class="line">        required:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = db.model(<span class="string">'Person'</span>,personSchema);</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">const</span> error = person.validateSync();</span><br><span class="line">assert.ok(error.errors[<span class="string">'name'</span>]);</span><br></pre></td></tr></table></figure>
<h4 id="Update-验证器"><a href="#Update-验证器" class="headerlink" title="Update 验证器"></a><strong>Update 验证器</strong></h4><p>Mongoose 还支持验证 update() 和 findOneAndUpdate() 操作，Update 验证器默认关闭，如果需要打开，需要配置 runValidators</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toySchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">      color: <span class="built_in">String</span>,</span><br><span class="line">      name: <span class="built_in">String</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Toy = db.model(<span class="string">'Toys'</span>, toySchema);</span><br><span class="line"></span><br><span class="line">Toy.schema.path(<span class="string">'color'</span>).validate(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/blue|green|white|red|orange|periwinkle/i</span>.test(value);</span><br><span class="line">&#125;, <span class="string">'Invalid color'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> opts = &#123; <span class="attr">runValidators</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">Toy.update(&#123;&#125;, &#123; <span class="attr">color</span>: <span class="string">'bacon'</span> &#125;, opts, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  assert.equal(err.errors.color.message,<span class="string">'Invalid color'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Update-验证器-与-this"><a href="#Update-验证器-与-this" class="headerlink" title="Update 验证器 与 this"></a><strong>Update 验证器 与 <code>this</code></strong></h4><p>update 验证器和 document 验证器有很多不同。上面的颜色验证函数，this 指向验证中的 document，然后update 验证器运行时，被更新文档不一定存在于服务器内存，所以 this 值未定义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toySchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  color: <span class="built_in">String</span>,</span><br><span class="line">  name: <span class="built_in">String</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">toySchema.path(<span class="string">'color'</span>).validate(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在运行“validate()”或“validateSync()”时</span></span><br><span class="line">  <span class="comment">// 验证器可以使用“this”访问文档。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.name.toLowerCase().indexOf(<span class="string">'red'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value !== <span class="string">'red'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Toy = db.model(<span class="string">'ActionFigure'</span>, toySchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toy = <span class="keyword">new</span> Toy(&#123; <span class="attr">color</span>: <span class="string">'red'</span>, <span class="attr">name</span>: <span class="string">'Red Power Ranger'</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> error = toy.validateSync();</span><br><span class="line">assert.ok(error.errors[<span class="string">'color'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> update = &#123; <span class="attr">color</span>: <span class="string">'red'</span>, <span class="attr">name</span>: <span class="string">'Red Power Ranger'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> opts = &#123; <span class="attr">runValidators</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">Toy.update(&#123;&#125;, update, opts, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// The update validator throws an error:</span></span><br><span class="line">  <span class="comment">// "TypeError: Cannot read property 'toLowerCase' of undefined",</span></span><br><span class="line">  <span class="comment">// because `this` is **not** the document being updated when using</span></span><br><span class="line">  <span class="comment">// update validators</span></span><br><span class="line">  assert.ok(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="context选项"><a href="#context选项" class="headerlink" title="context选项"></a><strong><code>context</code>选项</strong></h4><p>context 选项运行把 update 验证器的 this 设定为 query</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">toySchema.path(<span class="string">'color'</span>).validate(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// When running update validators with the `context` option set to</span></span><br><span class="line">    <span class="comment">// 'query', `this` refers to the query object.</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.getUpdate().$set.name.toLowerCase().indexOf(<span class="string">'red'</span>) !== <span class="number">-1</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> value == <span class="string">'red'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Toy = db.model(<span class="string">'Figure'</span>,toySchema);</span><br><span class="line"><span class="keyword">const</span> update = &#123;<span class="attr">color</span>:<span class="string">'blue'</span>,<span class="attr">name</span>:<span class="string">'haha'</span>&#125;</span><br><span class="line"><span class="comment">// Note the context option</span></span><br><span class="line"><span class="keyword">const</span> opts = &#123;<span class="attr">runValidators</span>:<span class="literal">true</span>,<span class="attr">context</span>:<span class="string">'query'</span>&#125;</span><br><span class="line">Toy.update(&#123;&#125;,update,opts,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    assert.ok(error.errors[<span class="string">'color'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Update-验证器字段路径"><a href="#Update-验证器字段路径" class="headerlink" title="Update 验证器字段路径"></a><strong>Update 验证器字段路径</strong></h4><p>另一个关键不同点是 update 验证器只运行于更新的字段。 下例中，因为 ‘name’ 在更新操作未被指定，所以此次更新操作成功。</p>
<p>使用 update 验证器的时候， <code>required</code> 验证器<strong>只会</strong>在你对某个字段显式使用 <code>$unset</code> 才会触发。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> kittenSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  name: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  age: <span class="built_in">Number</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Kitten = db.model(<span class="string">'Kitten'</span>, kittenSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> update = &#123; <span class="attr">color</span>: <span class="string">'blue'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> opts = &#123; <span class="attr">runValidators</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">Kitten.update(&#123;&#125;, update, opts, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 即使 'name' 没有指定也操作成功了</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> unset = &#123; <span class="attr">$unset</span>: &#123; <span class="attr">name</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line">Kitten.update(&#123;&#125;, unset, opts, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 'name' required， 操作失败</span></span><br><span class="line">  assert.ok(err);</span><br><span class="line">  assert.ok(err.errors[<span class="string">'name'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Update-验证器只运行于指定字段路径"><a href="#Update-验证器只运行于指定字段路径" class="headerlink" title="Update 验证器只运行于指定字段路径"></a><strong>Update 验证器只运行于指定字段路径</strong></h4><p>最后要注意的是：update 验证器<strong>只</strong>运行于下列更新操作：</p>
<ul>
<li><code>$set</code></li>
<li><code>$unset</code></li>
<li><code>$push</code> (&gt;= 4.8.0)</li>
<li><code>$addToSet</code> (&gt;= 4.8.0)</li>
<li><code>$pull</code> (&gt;= 4.12.0)</li>
<li><code>$pullAll</code> (&gt;= 4.12.0)</li>
</ul>
<p>例如，以下 update 成功执行，不管 <code>number</code> 的值，因为 update 验证器 无视 <code>$inc</code> 。同样， <code>$push</code>、<code>$addToSet</code>、 <code>$pull</code>和 <code>$pullAll</code> 验证器 不会对数组自身验证，只会对数组中的元素验证。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  number: &#123; <span class="attr">type</span>: <span class="built_in">Number</span>, <span class="attr">max</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  arr: [&#123; <span class="attr">message</span>: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">maxlength</span>: <span class="number">10</span> &#125; &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update 验证器不会作检查，所以你再仍然可以 `$push` 两个元素到数组 </span></span><br><span class="line"><span class="comment">// 只要他们的 `message` 没有超长</span></span><br><span class="line">testSchema.path(<span class="string">'arr'</span>).validate(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v.length &lt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Test = db.model(<span class="string">'Test'</span>, testSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> update = &#123; <span class="attr">$inc</span>: &#123; <span class="attr">number</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> opts = &#123; <span class="attr">runValidators</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">Test.update(&#123;&#125;, update, opts, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里不会报错</span></span><br><span class="line">  update = &#123; <span class="attr">$push</span>: [&#123; <span class="attr">message</span>: <span class="string">'hello'</span> &#125;, &#123; <span class="attr">message</span>: <span class="string">'world'</span> &#125;] &#125;;</span><br><span class="line">  Test.update(&#123;&#125;, update, opts, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里也不会报错</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="push-和-addToSet"><a href="#push-和-addToSet" class="headerlink" title="\$push 和 \$addToSet"></a><strong>\$push 和 \$addToSet</strong></h4><p>4.8.0 新特性： update 验证器也运行于 <code>$push</code> 和 <code>$addToSet</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  numbers: [&#123; <span class="attr">type</span>: <span class="built_in">Number</span>, <span class="attr">max</span>: <span class="number">0</span> &#125;],</span><br><span class="line">  docs: [&#123;</span><br><span class="line">    name: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Test = db.model(<span class="string">'TestPush'</span>, testSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> update = &#123;</span><br><span class="line">  $push: &#123;</span><br><span class="line">    numbers: <span class="number">1</span>,</span><br><span class="line">    docs: &#123; <span class="attr">name</span>: <span class="literal">null</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> opts = &#123; <span class="attr">runValidators</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">Test.update(&#123;&#125;, update, opts, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  assert.ok(error.errors[<span class="string">'numbers'</span>]);</span><br><span class="line">  assert.ok(error.errors[<span class="string">'docs'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="中间件（middleware）"><a href="#中间件（middleware）" class="headerlink" title="中间件（middleware）"></a>中间件（middleware）</h3><p>中间件（pre 和 post）是在异步函数执行时函数传入的控制函数。中间件在 Schema 上指定，在写插件时很有用。Mongoose 4.x 有四种中间件：document、model、aggregate、query 中间件。对于 document 中间件，this 指向当前的 document，Document 中间件支持下面的 document 操作：</p>
<ul>
<li>init</li>
<li>validate</li>
<li>save</li>
<li>remove</li>
</ul>
<p>对于 query中间件，this 指向 query。Query 中间件支持一下 Model 和 Query 操作：</p>
<ul>
<li>count</li>
<li>find</li>
<li>findOne</li>
<li>findOneAndRemove</li>
<li>findOneAndUpdate</li>
<li>update</li>
</ul>
<p>Aggregate 中间件作用于 MyModel.aggregat(),它会在对 aggregate 对象调用 exec() 时执行。对于 aggregate 中间件，this 也是指向 aggregation 对象。</p>
<ul>
<li>aggregate</li>
</ul>
<p>对于 model 中间件来说，this 是指向当前的model.Model 中间件支持下面的操作：</p>
<ul>
<li>insertMany</li>
</ul>
<p>所有的中间件支持 pre 和 post 钩子，下面解释这两个钩子的细节。</p>
<p>注意：Query 是没有 remove 钩子的，只有 document有，如果设定了 remove 钩子，将会在调用 myDoc.remove()而不是MyModel.remove 的时候触发。只有 create() 函数会触发 save() 钩子。</p>
<h4 id="Pre"><a href="#Pre" class="headerlink" title="Pre"></a><strong>Pre</strong></h4><p>pre 钩子分为串行和并行两种。</p>
<p><strong>串行</strong></p>
<p>串行中间件一个接一个地执行，具体来说，上一个中间件调用 next 函数的时候，下一个执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;);</span><br><span class="line"></span><br><span class="line">schema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在 5.x 版本中，除了手动调用 next ，可以返回一个 promise ，甚至是 async/await。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">schema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doStuff().then(<span class="function"><span class="params">()</span>=&gt;</span>doMoreStuff())</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 或者 Node.js &gt;= 7.6.0:</span></span><br><span class="line">schema.pre(<span class="string">'save'</span>,<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> doStuff();</span><br><span class="line">    <span class="keyword">await</span> doMoreStuff();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>next() 不会阻止剩余代码的运行，可以使用提前 return 模式来阻止 next () 后面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;);</span><br><span class="line">schema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(foo())&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'calling next'</span>);</span><br><span class="line">       <span class="comment">// `return next();` will make sure the rest of this function doesn't run</span></span><br><span class="line">       next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Unless you comment out the `return` above, 'after next' will print</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'after next'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>并行</strong></p>
<p>并行中间件提供细粒度流控制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;);</span><br><span class="line"><span class="comment">// true 代表这是一个并行中间件，如果要使用并行中间件，必须指定 true 为第二个参数</span></span><br><span class="line">schema.pre(<span class="string">'save'</span>,<span class="literal">true</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next,done</span>)</span>&#123;</span><br><span class="line">    next();</span><br><span class="line">    setTimeout(done,<span class="number">100</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上述的例子中，save 方法将在所有中间件都调用了 done 的时候才会执行。</p>
<p>使用场景：</p>
<p>中间件对原子化模型逻辑很有帮助，这里有一些其他建议：</p>
<ul>
<li>复杂的数据校验</li>
<li>删除依赖文档（删除用户后删除其他所有文章）</li>
<li>某个操作触发的异步任务</li>
</ul>
<p>错误处理：</p>
<p>如果 pre 钩子出错，momgoose 将不会执行后面的函数。Mongoose 会向回调函数传入 err 参数，或者 reject 返回的 promise 。下面是几个错误的处理的方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">schema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'something went gone'</span>);</span><br><span class="line">    next(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">schema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'something went gone'</span>))</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">schema.pre(<span class="string">'save'</span>,<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'something went gone'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myDoc.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>多次调用 next 是无效的，如果调用 next 带有错误参数 err1 ，然后再抛出一个 err2，mongoose 只会传递 err1</p>
<h4 id="Post中间件"><a href="#Post中间件" class="headerlink" title="Post中间件"></a><strong>Post中间件</strong></h4><p>post 中间件在方法执行之后调用，这个时候每个 pre 中间件都已经完成了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">schema.post(<span class="string">'init'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'%s has been initialized from the db'</span>, doc._id);</span><br><span class="line">&#125;);</span><br><span class="line">schema.post(<span class="string">'validate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'%s has been validated (but not saved yet)'</span>, doc._id);</span><br><span class="line">&#125;);</span><br><span class="line">schema.post(<span class="string">'save'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'%s has been saved'</span>, doc._id);</span><br><span class="line">&#125;);</span><br><span class="line">schema.post(<span class="string">'remove'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'%s has been removed'</span>, doc._id);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="异步-Post-钩子"><a href="#异步-Post-钩子" class="headerlink" title="异步 Post 钩子"></a><strong>异步 Post 钩子</strong></h4><p>如果给回调函数传入两个参数，mongoose 会认为第二个参数 next 函数，可以通过 next 触发下一个中间件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">schema.post(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">doc,next</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'post1'</span>);</span><br><span class="line">        next();</span><br><span class="line">    &#125;,<span class="number">10</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 直到第一个中间件执行 next() 才会执行</span></span><br><span class="line">schema.post(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">doc,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'post2'</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Save-Validate钩子"><a href="#Save-Validate钩子" class="headerlink" title="Save/Validate钩子"></a><strong>Save/Validate钩子</strong></h4><p>save() 函数触发 validate 钩子，mongoose validate() 其实就是 pre(‘save’)钩子，这意味着所有 pre(‘validate’) 和 post(‘validate’)都会在 pre(‘save’)钩子之前调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">schema.pre(<span class="string">'validate'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this gets printed first'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">schema.post(<span class="string">'validate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this gets printed second'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">schema.pre(<span class="string">'save'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this gets printed third'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">schema.post(<span class="string">'save'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this gets printed fourth'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="finAndUpdate-与-Query-中间件使用注意"><a href="#finAndUpdate-与-Query-中间件使用注意" class="headerlink" title="finAndUpdate() 与 Query 中间件使用注意"></a><strong>finAndUpdate() 与 Query 中间件使用注意</strong></h4><p>pre 和 post save() 钩子都不执行于 update ,findOneAndUpdate 等情况。Mongoose4.0 为这些函数制定了新钩子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">schema.pre(<span class="string">'find'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> <span class="keyword">instanceof</span> mongoose.Query); <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">this</span>.start = <span class="built_in">Date</span>.now()</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">schema.post(<span class="string">'find'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span> <span class="keyword">instanceof</span> mongoose.Query); <span class="comment">// true</span></span><br><span class="line">  <span class="comment">// prints returned documents</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'find() returned '</span> + <span class="built_in">JSON</span>.stringify(result));</span><br><span class="line">  <span class="comment">// prints number of milliseconds the query took</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'find() took '</span> + (<span class="built_in">Date</span>.now() - <span class="keyword">this</span>.start) + <span class="string">' millis'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Query 中间件不同于 document 中间件，document 中间件中，this 指向被更新 document,query 中间件中，this 指向query 对象而不是被更新 document</p>
<p>例如，如果要每次 update 之前更新 updateAt 时间戳，可以使用 pre 钩子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">schema.pre(<span class="string">'update'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.update(&#123;&#125;,&#123;<span class="attr">$set</span>:&#123;<span class="attr">updateAt</span>:<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a><strong>错误处理中间件</strong></h4><p>错误处理中间件比普通中间件多一个 <code>error</code> 参数，并且 <code>err</code> 作为第一个参数传入。 而后错误处理中间件可以让你自由地做错误的后续处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="comment">// // Will trigger a MongoError with code 11000 when you save a duplicate</span></span><br><span class="line">        unique:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理函数必须传入3个参数：发生的错误，返回文件，以及 next 函数</span></span><br><span class="line">schema.post(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error,doc,next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(error.name === <span class="string">'MongoError'</span> &amp;&amp; error.code === <span class="number">11000</span>)&#123;</span><br><span class="line">        next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'There was a duplicate key error'</span>))</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Will trigger the `post('save')` error handler</span></span><br><span class="line">Person.create([&#123;<span class="attr">name</span>:<span class="string">'Axl Rose'</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'Axl Rose'</span>&#125;]);</span><br></pre></td></tr></table></figure>
<p>对于query 中间件也可以使用错误处理，可以定义一个 post update 钩子，它可以捕获 MongoDB 重复 key 错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">schema.post(<span class="string">'update'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(error.name === <span class="string">'MongoError'</span> &amp;&amp; error.code === <span class="number">11000</span>)&#123;</span><br><span class="line">        next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'There was a duplicate key error'</span>))</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> people = [&#123;<span class="attr">name</span>:<span class="string">'Axl Rose'</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'Axl Rose'</span>&#125;];</span><br><span class="line">Person.create(people,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    Person.update(&#123;<span class="attr">name</span>:<span class="string">'haha'</span>&#125;,&#123;<span class="attr">$set</span>:&#123;<span class="attr">name</span>:<span class="string">'Axl Rose'</span>&#125;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// error.message` will be "There was a duplicate key error"</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="填充（Populate）"><a href="#填充（Populate）" class="headerlink" title="填充（Populate）"></a>填充（Populate）</h3><p>像sql 里面的 join 的聚合操作，populate 可以让你在别的 collection 中引用 document</p>
<p>Population 可以自动替换 document 中的指定字段，替换内容从其他 collection 获取。我们可以填充单个或者每个 document、单个或者多个纯对象，甚至是 query 返回的一切对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema;</span><br><span class="line"><span class="keyword">const</span> personSchema = Schema(&#123;</span><br><span class="line">    _id:Schema.Types.ObjectId,</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    age:<span class="built_in">Number</span>,</span><br><span class="line">    stories:[&#123;<span class="attr">type</span>:Schema.Types.ObjectId,<span class="attr">ref</span>:<span class="string">'Story'</span>&#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storySchema = Schema(&#123;</span><br><span class="line">    author:&#123;</span><br><span class="line">        type:Schema.Types.ObjectId,</span><br><span class="line">        ref:<span class="string">'Person'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    title:<span class="built_in">String</span>,</span><br><span class="line">    fans:[&#123;</span><br><span class="line">        type:Schema.Types.ObjectId,</span><br><span class="line">        ref:<span class="string">'Person'</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Story = mongoose.model(<span class="string">'Story'</span>,storySchema);</span><br><span class="line"><span class="keyword">const</span> Person = mongoose.model(<span class="string">'Person'</span>,personSchema);</span><br></pre></td></tr></table></figure>
<p>上面创建了两个 Model，Person model 的 stories 字段设为 ObjectId 数组。ref 选项告诉 Mongoose 在填充的时候使用哪个 model，上例中为 Story 的 model.所有存储在此的 _id 必须是 Story model 中的 document 的 _id。</p>
<p>注意：ObjectId、Number、String 以及 Buffer 都可以作为 refs 使用。但是最好还是用 ObjectId</p>
<h4 id="保存-refs"><a href="#保存-refs" class="headerlink" title="保存 refs"></a><strong>保存 refs</strong></h4><p>保存 refs 与保存普通属性一样，把 _id 的值赋给它就好了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> author = <span class="keyword">new</span> Person(&#123;</span><br><span class="line">  _id: <span class="keyword">new</span> mongoose.Types.ObjectId(),</span><br><span class="line">  name: <span class="string">'Ian Fleming'</span>,</span><br><span class="line">  age: <span class="number">50</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">author.save(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> story1 = <span class="keyword">new</span> Story(&#123;</span><br><span class="line">    title: <span class="string">'Casino Royale'</span>,</span><br><span class="line">    author: author._id    <span class="comment">// assign the _id from the person</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  story1.save(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    <span class="comment">// thats it!</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Population"><a href="#Population" class="headerlink" title="Population"></a><strong>Population</strong></h4><p>我们做的东西还是跟平时差不多，只是创建了 <code>Person</code> 和 <code>Story</code>。现在试试对query 填充 story 的 author。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Story.findOne(&#123;</span><br><span class="line">    title:<span class="string">'haha'</span></span><br><span class="line">&#125;).population(<span class="string">'author'</span>).exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,story</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The author is %s'</span>, story.author.name);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>被填充的字段已经不再是原来的 _id，而是被指定的 document 替代，这个 document 由另一条 query 从数据库返回。refs 数组的原理也是相似的。对 query 对象调用 populate 方法，就能返回装载对应 _id 的 document 数组。</p>
<h4 id="设置被填充字段"><a href="#设置被填充字段" class="headerlink" title="设置被填充字段"></a><strong>设置被填充字段</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Story.findOne(&#123; <span class="attr">title</span>: <span class="string">'Casino Royale'</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error, story</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="keyword">return</span> handleError(error);</span><br><span class="line">  &#125;</span><br><span class="line">  story.author = author;</span><br><span class="line">  <span class="built_in">console</span>.log(story.author.name); <span class="comment">// prints "Ian Fleming"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="字段选择"><a href="#字段选择" class="headerlink" title="字段选择"></a><strong>字段选择</strong></h4><p>如果我们只需要填充 document 其中一部分字段，第二个参数传入 field name syntax 就可以实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Story.</span><br><span class="line">findOne(&#123;<span class="attr">title</span>:<span class="regexp">/casino royale/i</span>&#125;).</span><br><span class="line">populate(<span class="string">'author'</span>,<span class="string">'name'</span>).<span class="comment">// only return the Persons name</span></span><br><span class="line">exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,story</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'The author is %s'</span>, story.author.name); <span class="comment">// The author is Ian Fleming</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'The author is %s'</span>, story.author.age); <span class="comment">// The authors age is null</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="填充多个字段"><a href="#填充多个字段" class="headerlink" title="填充多个字段"></a><strong>填充多个字段</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Story.</span><br><span class="line">  find(...).</span><br><span class="line">  populate(<span class="string">'fans'</span>).</span><br><span class="line">  populate(<span class="string">'author'</span>).</span><br><span class="line">  exec();</span><br></pre></td></tr></table></figure>
<p>如果对同一路径 populate 两次，只有最后一次生效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个会覆盖第一个的</span></span><br><span class="line">Story.</span><br><span class="line">  find().</span><br><span class="line">  populate(&#123; <span class="attr">path</span>: <span class="string">'fans'</span>, <span class="attr">select</span>: <span class="string">'name'</span> &#125;).</span><br><span class="line">  populate(&#123; <span class="attr">path</span>: <span class="string">'fans'</span>, <span class="attr">select</span>: <span class="string">'email'</span> &#125;);</span><br><span class="line"><span class="comment">// The above is equivalent to:</span></span><br><span class="line">Story.find().populate(&#123; <span class="attr">path</span>: <span class="string">'fans'</span>, <span class="attr">select</span>: <span class="string">'email'</span> &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Query-条件与其他选项"><a href="#Query-条件与其他选项" class="headerlink" title="Query 条件与其他选项"></a><strong>Query 条件与其他选项</strong></h4><p>如果要根据年龄来填充，只填充 name,并且值返回最多5个数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Story.</span><br><span class="line">  find(...).</span><br><span class="line">  populate(&#123;</span><br><span class="line">    path: <span class="string">'fans'</span>,</span><br><span class="line">    match: &#123; <span class="attr">age</span>: &#123; <span class="attr">$gte</span>: <span class="number">21</span> &#125;&#125;,</span><br><span class="line">    <span class="comment">// Explicitly exclude `_id`, see http://bit.ly/2aEfTdB</span></span><br><span class="line">    select: <span class="string">'name -_id'</span>,</span><br><span class="line">    options: &#123; <span class="attr">limit</span>: <span class="number">5</span> &#125;</span><br><span class="line">  &#125;).</span><br><span class="line">  exec();</span><br></pre></td></tr></table></figure>
<h4 id="Refs-到-children"><a href="#Refs-到-children" class="headerlink" title="Refs 到 children"></a><strong>Refs 到 children</strong></h4><p>我们发现，用 author 对象没有办法获取 story 列表，因为 author.stories 没有被 pushed 任何 story 对象</p>
<p>我们希望 author 知道哪些 story 属于他们，通常，schema 应该通过在 多 的一方使用指向它们的父节点（parent pointer）解决一对多关系问题。另一方面，如果有充分理由得到指向子节点的数组，可以像下面代码一样把 document push() 到数组中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">author.stories.push(story1);</span><br><span class="line">author.save(callback);</span><br></pre></td></tr></table></figure>
<p>然后我们就能 find 和 populate 了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person.findOne(&#123;<span class="attr">name</span>:<span class="string">'Ian Fleming'</span>&#125;).</span><br><span class="line">populate(<span class="string">'stories'</span>).</span><br><span class="line">exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,person</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> handleError(err);</span><br><span class="line">    <span class="built_in">console</span>.log(person);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果父子节点互相指向，数据可能会在某一时刻失去同步。为此我们可以不使用填充，直接 <code>find()</code>我们需要的 story</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Story.find(&#123;<span class="attr">author</span>:author._id&#125;).</span><br><span class="line">exec(<span class="function"><span class="keyword">function</span>(<span class="params">err, stories</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The stories are an array: '</span>, stories);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>query 填充后返回的 document 功能齐全，除非设置 lean 选项，否则它就是可 remove，可 save 的。调用 remove 不单是从数组中删除也是从数据库中删除它们。</p>
<h4 id="填充现有-document"><a href="#填充现有-document" class="headerlink" title="填充现有 document"></a><strong>填充现有 document</strong></h4><p>document#populate()</p>
<h4 id="填充多个现有-document"><a href="#填充多个现有-document" class="headerlink" title="填充多个现有 document"></a><strong>填充多个现有 document</strong></h4><p>如果需要填充一个或者多个 document 对象，我们可以使用 Model.populate 方法。</p>
<h4 id="多级填充"><a href="#多级填充" class="headerlink" title="多级填充"></a><strong>多级填充</strong></h4><p>假设 user schema 记录了 user 的 friends</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    friends:[&#123;</span><br><span class="line">        type:ObjectId,</span><br><span class="line">        ref:<span class="string">'User'</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当然可以填充得到用户的 friends 列表，但是如果要在获得他们朋友的朋友呢？指定 <code>populate</code>选项就可以了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User.findOne(&#123;<span class="attr">name</span>:<span class="string">'Val'</span>&#125;).</span><br><span class="line">populate(&#123;</span><br><span class="line">    path:<span class="string">'friends'</span>,</span><br><span class="line">    populate:&#123;</span><br><span class="line">        path:<span class="string">'friends'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="跨数据库填充"><a href="#跨数据库填充" class="headerlink" title="跨数据库填充"></a><strong>跨数据库填充</strong></h4><p>假设现在有 event schema 和 conversation schema,每个 event 对应一个 conversation 线程</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    conversation:ObjectId</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> conversationSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    numMessage:<span class="built_in">Number</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>并且，event 和 conversation 保存在不同的 MongoDB 实例中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db1 = mongoose.createConnection(<span class="string">'localhost:27000/db1'</span>);</span><br><span class="line"><span class="keyword">const</span> db2 = mongoose.createConnection(<span class="string">'localhost:27001/db2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Event = db1.model(<span class="string">'Event'</span>, eventSchema);</span><br><span class="line"><span class="keyword">const</span> Conversation = db2.model(<span class="string">'Conversation'</span>, conversationSchema);</span><br></pre></td></tr></table></figure>
<p>这个情况就<strong>不能</strong>直接使用 <code>populate()</code> 了，因为 <code>populate()</code> 不知道应该使用什么填充。 可以显式指定一个 model</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Event.find().population(&#123;<span class="attr">path</span>:<span class="string">'conversation'</span>,<span class="attr">model</span>:Conversation&#125;).</span><br><span class="line">exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,docs</span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="动态引用"><a href="#动态引用" class="headerlink" title="动态引用"></a><strong>动态引用</strong></h4><p>Mongoose 也可以从多个 collection 填充。假设 user schema 有一系列 connection，一个 user 可以连接到其他 user 或者组织。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    connection:[&#123;</span><br><span class="line">        kind:<span class="built_in">String</span>,</span><br><span class="line">        item:&#123;</span><br><span class="line">            type:ObjectId,</span><br><span class="line">            refPath:<span class="string">'connections.kind'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> organizationSchema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>,<span class="attr">kind</span>:<span class="built_in">String</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> User = mongoose.model(<span class="string">'User,userSchema'</span>);</span><br><span class="line"><span class="keyword">const</span> Organization = mongoose.model(<span class="string">'Organization'</span>,organizationSchema);</span><br></pre></td></tr></table></figure>
<p>上面的 <code>refPath</code> 属性意味着 mongoose 会查找 <code>connections.kind</code> 路径， 以此确定 <code>populate()</code> 使用的 model。换句话说，<code>refPath</code> 属性可以让你动态寻找 <code>ref</code>。</p>
<h3 id="鉴别器（Discriminators）"><a href="#鉴别器（Discriminators）" class="headerlink" title="鉴别器（Discriminators）"></a>鉴别器（Discriminators）</h3><p>Discriminator 是一种 schema 继承机制。它允许在相同的底层 MongoDB  collection 上使用部分重叠的 schema 建立多个 model。</p>
<p>假设要在单个 collection 中记录多种 event ，每个 event 都有时间戳字段，但是 click 事件还有 URL 字段，可以用 model.discriminator 实现上面的要求。这个函数需要两个参数，model 名称和 discriminator  schema,返回 model 结合原 model 的 schema 和 discriminator schema.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123; <span class="attr">discriminatorKey</span>:<span class="string">'kind'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> eventSchema = <span class="keyword">new</span> mongoose.Schema(&#123;<span class="attr">tiem</span>:<span class="built_in">Date</span>&#125;,options);</span><br><span class="line"><span class="keyword">const</span> Event = mongoose.model(<span class="string">'Event'</span>.eventSchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClickedLinkEvent 是一个有 URL 的特别 event</span></span><br><span class="line"><span class="keyword">const</span> ClickedLinkEvent = Event.discriminator(<span class="string">'ClickedLink'</span>,</span><br><span class="line">  <span class="keyword">new</span> mongoose.Schema(&#123;<span class="attr">url</span>: <span class="built_in">String</span>&#125;, options));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当你创建通用 event，他将没有 URL 字段...</span></span><br><span class="line"><span class="keyword">const</span> genericEvent = <span class="keyword">new</span> Event(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">url</span>: <span class="string">'google.com'</span>&#125;);</span><br><span class="line">assert.ok(!genericEvent.url);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是 ClickedLinkEvent 可以有</span></span><br><span class="line"><span class="keyword">const</span> clickedEvent =</span><br><span class="line">  <span class="keyword">new</span> ClickedLinkEvent(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">url</span>: <span class="string">'google.com'</span>&#125;);</span><br><span class="line">assert.ok(clickedEvent.url);</span><br></pre></td></tr></table></figure>
<h4 id="Discriminator-储存在-Event-model-的-collection"><a href="#Discriminator-储存在-Event-model-的-collection" class="headerlink" title="Discriminator 储存在 Event model 的 collection"></a><strong>Discriminator 储存在 Event model 的 collection</strong></h4><p>现在假设你要创建另一个 discriminator，记录用户注册 event。 <code>SignedUpEvent</code> 实例将跟 通用 events 和 <code>ClickedLinkEvent</code> 实例 一样储存在同一个 collection。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> event1 = <span class="keyword">new</span> Event(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now()&#125;);</span><br><span class="line"><span class="keyword">const</span> event2 = <span class="keyword">new</span> ClickedLinkEvent(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">url</span>: <span class="string">'google.com'</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> event3 = <span class="keyword">new</span> SignedUpEvent(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">user</span>: <span class="string">'testuser'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> save = <span class="function"><span class="keyword">function</span> (<span class="params">doc, callback</span>) </span>&#123;</span><br><span class="line">  doc.save(<span class="function"><span class="keyword">function</span> (<span class="params">error, doc</span>) </span>&#123;</span><br><span class="line">    callback(error, doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>.map([event1, event2, event3], save, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  Event.count(&#123;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error, count</span>) </span>&#123;</span><br><span class="line">    assert.equal(count, <span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Discriminator-keys"><a href="#Discriminator-keys" class="headerlink" title="Discriminator keys"></a><strong>Discriminator keys</strong></h4><p>Mongoose 通过 ‘discriminator key’ 识别两个不同的 discriminator， 这个值默认是 <code>__t</code> 。Mongoose 自动在你的 schema 添加 <code>__t</code> 字段， 记录你的 document 是哪个 discriminator 的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> event1 = <span class="keyword">new</span> Event(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now()&#125;);</span><br><span class="line"><span class="keyword">const</span> event2 = <span class="keyword">new</span> ClickedLinkEvent(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">url</span>: <span class="string">'google.com'</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> event3 = <span class="keyword">new</span> SignedUpEvent(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">user</span>: <span class="string">'testuser'</span>&#125;);</span><br><span class="line"></span><br><span class="line">assert.ok(!event1.__t);</span><br><span class="line">assert.equal(event2.__t, <span class="string">'ClickedLink'</span>);</span><br><span class="line">assert.equal(event3.__t, <span class="string">'SignedUp'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Discriminator-在查询中添加-discriminator-key"><a href="#Discriminator-在查询中添加-discriminator-key" class="headerlink" title="Discriminator 在查询中添加 discriminator key"></a><strong>Discriminator 在查询中添加 discriminator key</strong></h4><p>Discriminator model 的特别之处在于：他们会把 discriminator key 附到 query 上。换句话说，<code>find()</code>, <code>count()</code>, <code>aggregate()</code> 等方法 都能适配 discriminators。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> event1 = <span class="keyword">new</span> Event(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now()&#125;);</span><br><span class="line"><span class="keyword">const</span> event2 = <span class="keyword">new</span> ClickedLinkEvent(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">url</span>: <span class="string">'google.com'</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> event3 = <span class="keyword">new</span> SignedUpEvent(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">user</span>: <span class="string">'testuser'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> save = <span class="function"><span class="keyword">function</span> (<span class="params">doc, callback</span>) </span>&#123;</span><br><span class="line">  doc.save(<span class="function"><span class="keyword">function</span> (<span class="params">error, doc</span>) </span>&#123;</span><br><span class="line">    callback(error, doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>.map([event1, event2, event3], save, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  ClickedLinkEvent.find(&#123;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error, docs</span>) </span>&#123;</span><br><span class="line">    assert.equal(docs.length, <span class="number">1</span>);</span><br><span class="line">    assert.equal(docs[<span class="number">0</span>]._id.toString(), event2._id.toString());</span><br><span class="line">    assert.equal(docs[<span class="number">0</span>].url, <span class="string">'google.com'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Discriminator-复制-pre-post-钩子"><a href="#Discriminator-复制-pre-post-钩子" class="headerlink" title="Discriminator 复制 pre / post 钩子"></a><strong>Discriminator 复制 pre / post 钩子</strong></h4><p>Discriminator 会继承他的基础 schema 的 pre 和 post 中间件。 不过，你也可以为 discriminator 添加中间件，这不回影响到基础 schema。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;<span class="attr">discriminatorKey</span>: <span class="string">'kind'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eventSchema = <span class="keyword">new</span> mongoose.Schema(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>&#125;, options);</span><br><span class="line"><span class="keyword">const</span> eventSchemaCalls = <span class="number">0</span>;</span><br><span class="line">eventSchema.pre(<span class="string">'validate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">next</span>) </span>&#123;</span><br><span class="line">  ++eventSchemaCalls;</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> Event = mongoose.model(<span class="string">'GenericEvent'</span>, eventSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clickedLinkSchema = <span class="keyword">new</span> mongoose.Schema(&#123;<span class="attr">url</span>: <span class="built_in">String</span>&#125;, options);</span><br><span class="line"><span class="keyword">const</span> clickedSchemaCalls = <span class="number">0</span>;</span><br><span class="line">clickedLinkSchema.pre(<span class="string">'validate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">next</span>) </span>&#123;</span><br><span class="line">  ++clickedSchemaCalls;</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> ClickedLinkEvent = Event.discriminator(<span class="string">'ClickedLinkEvent'</span>,</span><br><span class="line">  clickedLinkSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> event1 = <span class="keyword">new</span> ClickedLinkEvent();</span><br><span class="line">event1.validate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  assert.equal(eventSchemaCalls, <span class="number">1</span>);</span><br><span class="line">  assert.equal(clickedSchemaCalls, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> generic = <span class="keyword">new</span> Event();</span><br><span class="line">  generic.validate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    assert.equal(eventSchemaCalls, <span class="number">2</span>);</span><br><span class="line">    assert.equal(clickedSchemaCalls, <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="处理自定义-id-字段"><a href="#处理自定义-id-字段" class="headerlink" title="处理自定义 _id 字段"></a><strong>处理自定义 _id 字段</strong></h4><p>Discriminator 的字段是基础 schema 加 discriminator schema ， 并且以 discriminator schema 的字段优先。 但有一个例外，<code>_id</code> 字段。</p>
<p>You can work around this by setting the <code>_id</code> option to false in the discriminator schema as shown below.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;<span class="attr">discriminatorKey</span>: <span class="string">'kind'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础 schema 有字符串格式的 `_id` 字段和 Data 格式的 `time` 字段...</span></span><br><span class="line"><span class="keyword">const</span> eventSchema = <span class="keyword">new</span> mongoose.Schema(&#123;<span class="attr">_id</span>: <span class="built_in">String</span>, <span class="attr">time</span>: <span class="built_in">Date</span>&#125;,</span><br><span class="line">  options);</span><br><span class="line"><span class="keyword">const</span> Event = mongoose.model(<span class="string">'BaseEvent'</span>, eventSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clickedLinkSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  url: <span class="built_in">String</span>,</span><br><span class="line">  time: <span class="built_in">String</span></span><br><span class="line">&#125;, options);</span><br><span class="line"><span class="comment">// 但是 Discriminator schema 有字符串格式的 `time`，并且有</span></span><br><span class="line"><span class="comment">// 隐式添加的 ObjectId 格式的 `_id`</span></span><br><span class="line">assert.ok(clickedLinkSchema.path(<span class="string">'_id'</span>));</span><br><span class="line">assert.equal(clickedLinkSchema.path(<span class="string">'_id'</span>).instance, <span class="string">'ObjectID'</span>);</span><br><span class="line"><span class="keyword">const</span> ClickedLinkEvent = Event.discriminator(<span class="string">'ChildEventBad'</span>,</span><br><span class="line">  clickedLinkSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> event1 = <span class="keyword">new</span> ClickedLinkEvent(&#123; <span class="attr">_id</span>: <span class="string">'custom id'</span>, <span class="attr">time</span>: <span class="string">'4pm'</span> &#125;);</span><br><span class="line"><span class="comment">// 问题来了，clickedLinkSchema 重写了 `time` 路径，但是**没有**</span></span><br><span class="line"><span class="comment">// 重写 `_id` 路径，因为已经隐式添加（没看懂）</span></span><br><span class="line">assert.ok(<span class="keyword">typeof</span> event1._id === <span class="string">'string'</span>);</span><br><span class="line">assert.ok(<span class="keyword">typeof</span> event1.time === <span class="string">'string'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="discriminator-与-Model-create"><a href="#discriminator-与-Model-create" class="headerlink" title="discriminator 与 Model.create()"></a><strong>discriminator 与 <code>Model.create()</code></strong></h4><p>当你使用 <code>Model.create()</code>，Mongoose 会自动帮你适配 discriminator key ~</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema;</span><br><span class="line"><span class="keyword">const</span> shapeSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  name: <span class="built_in">String</span></span><br><span class="line">&#125;, &#123; <span class="attr">discriminatorKey</span>: <span class="string">'kind'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Shape = db.model(<span class="string">'Shape'</span>, shapeSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Circle = Shape.discriminator(<span class="string">'Circle'</span>,</span><br><span class="line">  <span class="keyword">new</span> Schema(&#123; <span class="attr">radius</span>: <span class="built_in">Number</span> &#125;));</span><br><span class="line"><span class="keyword">const</span> Square = Shape.discriminator(<span class="string">'Square'</span>,</span><br><span class="line">  <span class="keyword">new</span> Schema(&#123; <span class="attr">side</span>: <span class="built_in">Number</span> &#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shapes = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'Test'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">kind</span>: <span class="string">'Circle'</span>, <span class="attr">radius</span>: <span class="number">5</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">kind</span>: <span class="string">'Square'</span>, <span class="attr">side</span>: <span class="number">10</span> &#125;</span><br><span class="line">];</span><br><span class="line">Shape.create(shapes, <span class="function"><span class="keyword">function</span>(<span class="params">error, shapes</span>) </span>&#123;</span><br><span class="line">  assert.ifError(error);</span><br><span class="line">  <span class="comment">// 重点看这里</span></span><br><span class="line">  assert.ok(shapes[<span class="number">0</span>] <span class="keyword">instanceof</span> Shape);</span><br><span class="line">  assert.ok(shapes[<span class="number">1</span>] <span class="keyword">instanceof</span> Circle);</span><br><span class="line">  assert.equal(shapes[<span class="number">1</span>].radius, <span class="number">5</span>);</span><br><span class="line">  assert.ok(shapes[<span class="number">2</span>] <span class="keyword">instanceof</span> Square);</span><br><span class="line">  assert.equal(shapes[<span class="number">2</span>].side, <span class="number">10</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="数组中的嵌套-discriminator"><a href="#数组中的嵌套-discriminator" class="headerlink" title="数组中的嵌套 discriminator"></a><strong>数组中的嵌套 discriminator</strong></h4><p>你也可以为嵌套文档数组定义 discriminator。 嵌套 discriminator 的特点是：不同 discriminator 类型储存在相同的文档而不是同一个 mongoDB collection。 换句话说，嵌套 discriminator 让你 在同一个数组储存符合不同 schema 的子文档。</p>
<p>最佳实践：确保你声明了钩子再使用他们。 你<strong>不应当</strong>在调用 <code>discriminator()</code> 之后调用 <code>pre()</code> 或 <code>post()</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventSchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">message</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">discriminatorKey</span>: <span class="string">'kind'</span>, <span class="attr">_id</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> batchSchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">events</span>: [eventSchema] &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// `batchSchema.path('events')` gets the mongoose `DocumentArray`</span></span><br><span class="line"><span class="keyword">const</span> docArray = batchSchema.path(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 `events` 数组可以包含 2 种不同的 event 类型，</span></span><br><span class="line"><span class="comment">// 'clicked' event that requires an element id that was clicked...</span></span><br><span class="line"><span class="keyword">const</span> clickedSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  element: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    required: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123; <span class="attr">_id</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="comment">// 确定在调用 `discriminator()` **之前**</span></span><br><span class="line"><span class="comment">// 对 `eventSchema` 和 `clickedSchema` 赋予钩子</span></span><br><span class="line"><span class="keyword">const</span> Clicked = docArray.discriminator(<span class="string">'Clicked'</span>, clickedSchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... and a 'purchased' event that requires the product that was purchased.</span></span><br><span class="line"><span class="keyword">const</span> Purchased = docArray.discriminator(<span class="string">'Purchased'</span>, <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  product: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    required: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123; <span class="attr">_id</span>: <span class="literal">false</span> &#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Batch = db.model(<span class="string">'EventBatch'</span>, batchSchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new batch of events with different kinds</span></span><br><span class="line"><span class="keyword">const</span> batch = &#123;</span><br><span class="line">  events: [</span><br><span class="line">    &#123; <span class="attr">kind</span>: <span class="string">'Clicked'</span>, <span class="attr">element</span>: <span class="string">'#hero'</span>, <span class="attr">message</span>: <span class="string">'hello'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">kind</span>: <span class="string">'Purchased'</span>, <span class="attr">product</span>: <span class="string">'action-figure-1'</span>, <span class="attr">message</span>: <span class="string">'world'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Batch.create(batch).</span><br><span class="line">  then(<span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    assert.equal(doc.events.length, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    assert.equal(doc.events[<span class="number">0</span>].element, <span class="string">'#hero'</span>);</span><br><span class="line">    assert.equal(doc.events[<span class="number">0</span>].message, <span class="string">'hello'</span>);</span><br><span class="line">    assert.ok(doc.events[<span class="number">0</span>] <span class="keyword">instanceof</span> Clicked);</span><br><span class="line"></span><br><span class="line">    assert.equal(doc.events[<span class="number">1</span>].product, <span class="string">'action-figure-1'</span>);</span><br><span class="line">    assert.equal(doc.events[<span class="number">1</span>].message, <span class="string">'world'</span>);</span><br><span class="line">    assert.ok(doc.events[<span class="number">1</span>] <span class="keyword">instanceof</span> Purchased);</span><br><span class="line"></span><br><span class="line">    doc.events.push(&#123; <span class="attr">kind</span>: <span class="string">'Purchased'</span>, <span class="attr">product</span>: <span class="string">'action-figure-2'</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span> doc.save();</span><br><span class="line">  &#125;).</span><br><span class="line">  then(<span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    assert.equal(doc.events.length, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    assert.equal(doc.events[<span class="number">2</span>].product, <span class="string">'action-figure-2'</span>);</span><br><span class="line">    assert.ok(doc.events[<span class="number">2</span>] <span class="keyword">instanceof</span> Purchased);</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line">  &#125;).</span><br><span class="line">  <span class="keyword">catch</span>(done);</span><br></pre></td></tr></table></figure>
<h4 id="检索数组中的嵌套-discriminator"><a href="#检索数组中的嵌套-discriminator" class="headerlink" title="检索数组中的嵌套 discriminator"></a><strong>检索数组中的嵌套 discriminator</strong></h4><p>检索嵌套 discriminator</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> singleEventSchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">message</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">discriminatorKey</span>: <span class="string">'kind'</span>, <span class="attr">_id</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eventListSchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">events</span>: [singleEventSchema] &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subEventSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">   sub_events: [singleEventSchema]</span><br><span class="line">&#125;, &#123; <span class="attr">_id</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SubEvent = subEventSchema.path(<span class="string">'sub_events'</span>).discriminator(<span class="string">'SubEvent'</span>, subEventSchema)</span><br><span class="line">eventListSchema.path(<span class="string">'events'</span>).discriminator(<span class="string">'SubEvent'</span>, subEventSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Eventlist = db.model(<span class="string">'EventList'</span>, eventListSchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new batch of events with different kinds</span></span><br><span class="line"><span class="keyword">const</span> list = &#123;</span><br><span class="line">  events: [</span><br><span class="line">    &#123; <span class="attr">kind</span>: <span class="string">'SubEvent'</span>, <span class="attr">sub_events</span>: [&#123;<span class="attr">kind</span>:<span class="string">'SubEvent'</span>, <span class="attr">sub_events</span>:[], <span class="attr">message</span>:<span class="string">'test1'</span>&#125;], <span class="attr">message</span>: <span class="string">'hello'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">kind</span>: <span class="string">'SubEvent'</span>, <span class="attr">sub_events</span>: [&#123;<span class="attr">kind</span>:<span class="string">'SubEvent'</span>, <span class="attr">sub_events</span>:[&#123;<span class="attr">kind</span>:<span class="string">'SubEvent'</span>, <span class="attr">sub_events</span>:[], <span class="attr">message</span>:<span class="string">'test3'</span>&#125;], <span class="attr">message</span>:<span class="string">'test2'</span>&#125;], <span class="attr">message</span>: <span class="string">'world'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Eventlist.create(list).</span><br><span class="line">  then(<span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    assert.equal(doc.events.length, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    assert.equal(doc.events[<span class="number">0</span>].sub_events[<span class="number">0</span>].message, <span class="string">'test1'</span>);</span><br><span class="line">    assert.equal(doc.events[<span class="number">0</span>].message, <span class="string">'hello'</span>);</span><br><span class="line">    assert.ok(doc.events[<span class="number">0</span>].sub_events[<span class="number">0</span>] <span class="keyword">instanceof</span> SubEvent);</span><br><span class="line"></span><br><span class="line">    assert.equal(doc.events[<span class="number">1</span>].sub_events[<span class="number">0</span>].sub_events[<span class="number">0</span>].message, <span class="string">'test3'</span>);</span><br><span class="line">    assert.equal(doc.events[<span class="number">1</span>].message, <span class="string">'world'</span>);</span><br><span class="line">    assert.ok(doc.events[<span class="number">1</span>].sub_events[<span class="number">0</span>].sub_events[<span class="number">0</span>] <span class="keyword">instanceof</span> SubEvent);</span><br><span class="line"></span><br><span class="line">    doc.events.push(&#123;<span class="attr">kind</span>:<span class="string">'SubEvent'</span>, <span class="attr">sub_events</span>:[&#123;<span class="attr">kind</span>:<span class="string">'SubEvent'</span>, <span class="attr">sub_events</span>:[], <span class="attr">message</span>:<span class="string">'test4'</span>&#125;], <span class="attr">message</span>:<span class="string">'pushed'</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> doc.save();</span><br><span class="line">  &#125;).</span><br><span class="line">  then(<span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    assert.equal(doc.events.length, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    assert.equal(doc.events[<span class="number">2</span>].message, <span class="string">'pushed'</span>);</span><br><span class="line">    assert.ok(doc.events[<span class="number">2</span>].sub_events[<span class="number">0</span>] <span class="keyword">instanceof</span> SubEvent);</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line">  &#125;).</span><br><span class="line">  <span class="keyword">catch</span>(done);</span><br></pre></td></tr></table></figure>
<p>### </p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    赖彬鸿
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://laibh.top/2019-03-26-mongoose.html" title="Mongoose">http://laibh.top/2019-03-26-mongoose.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据库相关/" <i class="fa fa-tag"></i> 数据库相关</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019-03-22-JavaScript设计原则和编程技巧——单一职责原则.html" rel="next" title="JavaScript设计原则和编程技巧——单一职责原则">
                <i class="fa fa-chevron-left"></i> JavaScript设计原则和编程技巧——单一职责原则
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/前端面试题目汇总摘录-JS 基础篇2.html" rel="prev" title="前端面试题目汇总摘录（JS 基础篇2）">
                前端面试题目汇总摘录（JS 基础篇2） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "1",
        "bdMiniList": false,
        "bdPic": ""
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      },
      "slide": {
        "bdImg": "5",
        "bdPos": "left",
        "bdTop": "100"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?'+~(-new Date()/36e5)];;
</script>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zOTcwMy8xNjIzMA"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/myPhoto.jpg"
                alt="赖彬鸿" />
            
              <p class="site-author-name" itemprop="name">赖彬鸿</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">135</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          
          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/LbhFront-end" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.cnblogs.com/lbh2018/" target="_blank" title="博客园">
                      
                        <i class="fa fa-fw fa-globe"></i>博客园</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://yq.aliyun.com/users/1802204154913774?spm=a2c4e.11153940.blogcont662526.4.6c0a34f6E2lR5o" target="_blank" title="云栖">
                      
                        <i class="fa fa-fw fa-globe"></i>云栖</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:544289495@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=544289495&website=www.oicqzone.com" target="_blank" title="QQ">
                      
                        <i class="fa fa-fw fa-qq"></i>QQ</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.google.com.hk/search?safe=strict&source=hp&ei=JtLCXIriJ8G4-gS_-4qABQ&q=site%3Alaibh.top&btnK=Google+%E6%90%9C%E7%B4%A2&oq=site%3Alaibh.top&gs_l=psy-ab.3...1158.6834..7051...5.0..1.246.3720.2-17......0....1..gws-wiz.....0..0j0i10.rJMUHvdrbds" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
            </div>
          
         <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=90  src="//music.163.com/outchain/player?type=0&id=2353471182&auto=0&height=90"></iframe>
          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.chjtx.com/JRoll/" title="醉萝卜" target="_blank">醉萝卜</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://hzd.plus/" title="Zhendong" target="_blank">Zhendong</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.cnblogs.com/cnyball" title="cnyballk" target="_blank">cnyballk</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://johnzz.top/" title="John" target="_blank">John</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://xiaojun1994.top/" title="xiaojun1994" target="_blank">xiaojun1994</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://me.ursb.me" title="Airing" target="_blank">Airing</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.iyouhun.com" title="游魂" target="_blank">游魂</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://icoty.github.io/" title="荒野之萍" target="_blank">荒野之萍</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://im-one.github.io/" title="imOne" target="_blank">imOne</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.hourxu.com/" title="Ambre" target="_blank">Ambre</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.huyujs.com" title="胡雨" target="_blank">胡雨</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.andou.live" title="安逗" target="_blank">安逗</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.jianshu.com/u/701a8bbf4f7e" title="陈健斌" target="_blank">陈健斌</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://itobys.github.io/" title="汤姆Tom酱" target="_blank">汤姆Tom酱</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://breeze2.github.io/blog/" title="林毅锋" target="_blank">林毅锋</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.qzroc.com/" title="大鹏博客" target="_blank">大鹏博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://lyreal666.com/" title="余腾靖的博客" target="_blank">余腾靖的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://buzuosheng.com/" title="不作声" target="_blank">不作声</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.baidu.com/s?ie=UTF-8&wd=site%3Alaibh.top" title="百度" target="_blank">百度</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.google.com.hk/search?safe=strict&source=hp&ei=zXdWXfemLJbO0PEP8qyXyA0&q=site%3Alaibh.top&oq=site%3Alaibh.top&gs_l=psy-ab.3...580.8501..8767...0.0..0.397.934.2-1j2......0....2j1..gws-wiz.QESXfWGadT0&ved=0ahUKEwi3wbusiofkAhUWJzQIHXLWBdkQ4dUDCAU&uact=5" title="谷歌" target="_blank">谷歌</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#快速上手"><span class="nav-number">1.</span> <span class="nav-text">快速上手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模式（Schemas）"><span class="nav-number">2.</span> <span class="nav-text">模式（Schemas）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义一个schema"><span class="nav-number">2.0.1.</span> <span class="nav-text">定义一个schema</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建一个-model"><span class="nav-number">2.0.2.</span> <span class="nav-text">创建一个 model</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例方法（method）"><span class="nav-number">2.0.3.</span> <span class="nav-text">实例方法（method）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态方法（static）"><span class="nav-number">2.0.4.</span> <span class="nav-text">静态方法（static）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询助手（query-helper）"><span class="nav-number">2.0.5.</span> <span class="nav-text">查询助手（query helper）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引（index）"><span class="nav-number">2.0.6.</span> <span class="nav-text">索引（index）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟值（Virtual）"><span class="nav-number">2.0.7.</span> <span class="nav-text">虚拟值（Virtual）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#别名（Alias）"><span class="nav-number">2.0.8.</span> <span class="nav-text">别名（Alias）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选项"><span class="nav-number">2.0.9.</span> <span class="nav-text">选项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式类型（SchemaTypes）"><span class="nav-number">2.1.</span> <span class="nav-text">模式类型（SchemaTypes）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SchemaType-选项"><span class="nav-number">2.1.1.</span> <span class="nav-text">SchemaType 选项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用注意"><span class="nav-number">2.1.2.</span> <span class="nav-text">使用注意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建自定义-Type"><span class="nav-number">2.1.3.</span> <span class="nav-text">创建自定义 Type</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接（Connections）"><span class="nav-number">2.2.</span> <span class="nav-text">连接（Connections）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#操作缓存"><span class="nav-number">2.2.1.</span> <span class="nav-text">操作缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选项-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">选项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#回调"><span class="nav-number">2.2.3.</span> <span class="nav-text">回调</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#连接字符串（Connectng-String）选项"><span class="nav-number">2.2.4.</span> <span class="nav-text">连接字符串（Connectng String）选项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#keepAlive注意事项"><span class="nav-number">2.2.5.</span> <span class="nav-text">keepAlive注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#副本集（Replica-Set）连接"><span class="nav-number">2.2.6.</span> <span class="nav-text">副本集（Replica Set）连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多-mongos-支持"><span class="nav-number">2.2.7.</span> <span class="nav-text">多 mongos 支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多个连接"><span class="nav-number">2.2.8.</span> <span class="nav-text">多个连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#连接池"><span class="nav-number">2.2.9.</span> <span class="nav-text">连接池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模型（Models）"><span class="nav-number">2.3.</span> <span class="nav-text">模型（Models）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造-documents"><span class="nav-number">2.3.1.</span> <span class="nav-text">构造 documents</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询"><span class="nav-number">2.3.2.</span> <span class="nav-text">查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除"><span class="nav-number">2.3.3.</span> <span class="nav-text">删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更新"><span class="nav-number">2.3.4.</span> <span class="nav-text">更新</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文档（Documents）"><span class="nav-number">2.4.</span> <span class="nav-text">文档（Documents）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#检索"><span class="nav-number">2.4.1.</span> <span class="nav-text">检索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更新-1"><span class="nav-number">2.4.2.</span> <span class="nav-text">更新</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#验证"><span class="nav-number">2.4.3.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#覆盖"><span class="nav-number">2.4.4.</span> <span class="nav-text">覆盖</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子文档（Subdocuments）"><span class="nav-number">2.5.</span> <span class="nav-text">子文档（Subdocuments）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#查找子文档"><span class="nav-number">2.5.1.</span> <span class="nav-text">查找子文档</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#添加子文档到数组"><span class="nav-number">2.5.2.</span> <span class="nav-text">添加子文档到数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除子文档"><span class="nav-number">2.5.3.</span> <span class="nav-text">删除子文档</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查询（queries）"><span class="nav-number">2.6.</span> <span class="nav-text">查询（queries）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#引用其他文档"><span class="nav-number">2.6.1.</span> <span class="nav-text">引用其他文档</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证（validation）"><span class="nav-number">2.7.</span> <span class="nav-text">验证（validation）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内建-Validators"><span class="nav-number">2.7.1.</span> <span class="nav-text">内建 Validators</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unique不是验证器"><span class="nav-number">2.7.2.</span> <span class="nav-text">unique不是验证器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义验证器"><span class="nav-number">2.7.3.</span> <span class="nav-text">自定义验证器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异步自定义验证器"><span class="nav-number">2.7.4.</span> <span class="nav-text">异步自定义验证器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#验证错误"><span class="nav-number">2.7.5.</span> <span class="nav-text">验证错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#嵌套对象中的-Required-验证器"><span class="nav-number">2.7.6.</span> <span class="nav-text">嵌套对象中的 Required 验证器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Update-验证器"><span class="nav-number">2.7.7.</span> <span class="nav-text">Update 验证器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Update-验证器-与-this"><span class="nav-number">2.7.8.</span> <span class="nav-text">Update 验证器 与 this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#context选项"><span class="nav-number">2.7.9.</span> <span class="nav-text">context选项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Update-验证器字段路径"><span class="nav-number">2.7.10.</span> <span class="nav-text">Update 验证器字段路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Update-验证器只运行于指定字段路径"><span class="nav-number">2.7.11.</span> <span class="nav-text">Update 验证器只运行于指定字段路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#push-和-addToSet"><span class="nav-number">2.7.12.</span> <span class="nav-text">\$push 和 \$addToSet</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中间件（middleware）"><span class="nav-number">2.8.</span> <span class="nav-text">中间件（middleware）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Pre"><span class="nav-number">2.8.1.</span> <span class="nav-text">Pre</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Post中间件"><span class="nav-number">2.8.2.</span> <span class="nav-text">Post中间件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异步-Post-钩子"><span class="nav-number">2.8.3.</span> <span class="nav-text">异步 Post 钩子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Save-Validate钩子"><span class="nav-number">2.8.4.</span> <span class="nav-text">Save/Validate钩子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finAndUpdate-与-Query-中间件使用注意"><span class="nav-number">2.8.5.</span> <span class="nav-text">finAndUpdate() 与 Query 中间件使用注意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#错误处理中间件"><span class="nav-number">2.8.6.</span> <span class="nav-text">错误处理中间件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#填充（Populate）"><span class="nav-number">2.9.</span> <span class="nav-text">填充（Populate）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#保存-refs"><span class="nav-number">2.9.1.</span> <span class="nav-text">保存 refs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Population"><span class="nav-number">2.9.2.</span> <span class="nav-text">Population</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设置被填充字段"><span class="nav-number">2.9.3.</span> <span class="nav-text">设置被填充字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字段选择"><span class="nav-number">2.9.4.</span> <span class="nav-text">字段选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#填充多个字段"><span class="nav-number">2.9.5.</span> <span class="nav-text">填充多个字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Query-条件与其他选项"><span class="nav-number">2.9.6.</span> <span class="nav-text">Query 条件与其他选项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Refs-到-children"><span class="nav-number">2.9.7.</span> <span class="nav-text">Refs 到 children</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#填充现有-document"><span class="nav-number">2.9.8.</span> <span class="nav-text">填充现有 document</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#填充多个现有-document"><span class="nav-number">2.9.9.</span> <span class="nav-text">填充多个现有 document</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多级填充"><span class="nav-number">2.9.10.</span> <span class="nav-text">多级填充</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#跨数据库填充"><span class="nav-number">2.9.11.</span> <span class="nav-text">跨数据库填充</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态引用"><span class="nav-number">2.9.12.</span> <span class="nav-text">动态引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#鉴别器（Discriminators）"><span class="nav-number">2.10.</span> <span class="nav-text">鉴别器（Discriminators）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Discriminator-储存在-Event-model-的-collection"><span class="nav-number">2.10.1.</span> <span class="nav-text">Discriminator 储存在 Event model 的 collection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Discriminator-keys"><span class="nav-number">2.10.2.</span> <span class="nav-text">Discriminator keys</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Discriminator-在查询中添加-discriminator-key"><span class="nav-number">2.10.3.</span> <span class="nav-text">Discriminator 在查询中添加 discriminator key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Discriminator-复制-pre-post-钩子"><span class="nav-number">2.10.4.</span> <span class="nav-text">Discriminator 复制 pre / post 钩子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理自定义-id-字段"><span class="nav-number">2.10.5.</span> <span class="nav-text">处理自定义 _id 字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#discriminator-与-Model-create"><span class="nav-number">2.10.6.</span> <span class="nav-text">discriminator 与 Model.create()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组中的嵌套-discriminator"><span class="nav-number">2.10.7.</span> <span class="nav-text">数组中的嵌套 discriminator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#检索数组中的嵌套-discriminator"><span class="nav-number">2.10.8.</span> <span class="nav-text">检索数组中的嵌套 discriminator</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart throb" style="color: #d43f57;"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">赖彬鸿</span>

  
</div>

  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>

<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>



-->
<div>
<span id="busuanzi_container_site_pv" title="访问量">
    <i class="fa fa fa-eye"></i> <span id="busuanzi_value_site_pv"></span>
</span>
<span id="busuanzi_container_site_uv" title="访问人数">
  <i class="fa fa-user"></i> <span id="busuanzi_value_site_uv"></span>
</span>
<span class="post-count" title="博客总字数"><i class="fa fa-pagelines" aria-hidden="true"></i>745.9k</span>
</div>
<i class="fa fa-shield" aria-hidden="true" title="本站安全运行时间"></i> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("01/29/2018 09:47:04");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds);
        if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>
  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("JcDzlAxx8A0MJDQ9xpJTOBUe-gzGzoHsz", "hih724suAgjSWQnvOuIEvxza");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script>


  

  <!-- 代码块复制功能 -->
  <script type="text/javascript" src="/js/src/clipboard.js"></script>  
  <script type="text/javascript" src="/js/src/clipboard-use.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
