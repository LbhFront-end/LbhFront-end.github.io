<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赖同学</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://laibh.top/"/>
  <updated>2022-03-04T10:00:38.468Z</updated>
  <id>http://laibh.top/</id>
  
  <author>
    <name>赖彬鸿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>区块链开发入门</title>
    <link href="http://laibh.top/2022-03-03-BlockChain.html"/>
    <id>http://laibh.top/2022-03-03-BlockChain.html</id>
    <published>2022-03-03T09:13:25.000Z</published>
    <updated>2022-03-04T10:00:38.468Z</updated>
    
    <content type="html"><![CDATA[<p>失踪人员回归，学习记录点区块链知识…</p><h1 id="区块链开发入门：从0到1构建基于以太坊智能合约的ICO-DApp"><a href="#区块链开发入门：从0到1构建基于以太坊智能合约的ICO-DApp" class="headerlink" title="区块链开发入门：从0到1构建基于以太坊智能合约的ICO DApp"></a>区块链开发入门：从0到1构建基于以太坊智能合约的ICO DApp</h1><h2 id="区块链简明发展史"><a href="#区块链简明发展史" class="headerlink" title="区块链简明发展史"></a>区块链简明发展史</h2><h3 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h3><p>区块链技术起源于2008年10月31日中本聪发表的比特币论文：<a href="https://bitcoin.org/bitcoin.pdf">《Bitcoin: A Peer to Peer Electronic Cash System》</a>，即比特币白皮书，论文论述了基于P2P网络的电子现金系统的设计，系统中产生和流通的现金就是比特币(Bitcoin)。</p><h3 id="白皮书中文"><a href="#白皮书中文" class="headerlink" title="白皮书中文"></a>白皮书中文</h3><blockquote><p>比特币：一种点对点的电子现金系统<br>一个完全的点对点版本的电子现金将允许一方不通过金融机构直接在线支付给另一方。电子签名提供了部分解决方案，但是如果还需要一个可信任的第三方来防止双花，那么这个最大的好处也就没有意义。我们提出一个用点对点网络来解决双花的方案。这个网络给每笔交易打上时间戳，并进行哈希计算，放进一条基于哈希工作量证明的链，这形成了一个不可改变的记录，除非重做这些工作量。最长的链不仅是见证序列的证明，还证明了它来自最大的CPU算力池。因为大部分的算力由诚实的节点控制，他们将会产生一条比攻击者要长的链。网络本身需要极小化结构。消息被尽力广播，并且节点可以随意离开或重新加入网络，接受最长的工作量证明的链作为它离开这段时间发生事情的证明</p></blockquote><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>互联网上的商业几乎完全依赖信任的第三方金融机构来处理电子支付。对于大多数交易来说，这套系统工作的足够好了，但是依然受到了基于信任模型的天然缺点的困扰。完全不能撤销的交易是不可能的，因为第三方金融机构不可避免的要调解纠纷。调解的代价增加了交易的成本，限制了最小实际交易的大小，切断了临时交易的可能性，丧失了对不可撤销服务提供不可撤销支付的可能性，这又是一个广义成本。因为撤销的可能性，信任的需求不断蔓延开来。商户必须提防他们的客户，越来越多的他们本不该需要的信息困扰他们。不得不接受一定比例的骗子。这些成本和支付的不确定问题可以用面对面使用现金避免，但是还没有机制存在使得通过通信信道支付而不需要信任的第三方。</p><p>需要的是一个电子支付系统，这个系统建立在密码学证明基础上而不是信任，运行任意有这个意愿的双方直接互相转账而不需要一个可信任的第三方。交易从计算上不可撤销的，这将保护卖方权利防止被骗，并且常规的托管机制很容易实现来保护买方权益。下面提出一个防止双花的解决方案，使用点对点分布式时间戳服务器来产生按时间排序的交易的计算证明。只要城市节点控制的CPU的算力大于攻击者节点的算力，这个系统就是安全的。</p><h4 id="2-交易"><a href="#2-交易" class="headerlink" title="2.交易"></a>2.交易</h4><p>我们把一种电子币定义成一条数字签名链。每一个所有者把币转给下一个人的时候，是通过将前一个交易的哈希和下一个所有者的公钥进行数字签名，并把这些追加在币的后面。收款人可以通过验证签名来确定链的所有者。</p><p><img src="/images/2022-03-03-blockChain-trade_coin.jpg" alt=""></p><p>当然，问题是收款人无法验证其中一个所有者是否同一个币花了两次。一个普遍的做法是引入一个信任的中央机关，或铸币厂，他们可以检查每一笔交易来防止双花问题。每次交易后，这个币必须返回到铸币厂，这样才能发行新币，只有直接从铸币厂发行的币才被相信是没有被双花的。这个方案的问题是，整个金钱系统的命运掌握在经营铸币厂的公司，每一笔交易都要经他们，就像银行一样。</p><p>我们需要一种方法，这种方法让收款人知道上一个所有者没有签署任何以前的交易。我们的目的是让最早的交易是可信的，我们不关心后面是不是有人企图进行双花。仅有的可以确认某一个交易存在的办法是要知道所有交易。在基于铸币厂的模型中，铸币厂知道所有交易，并且可以确定哪个交易先发生。为了在无信任第三方的情况下达到共识，这个共识就是认同同一个按接收的交易顺序排列的历史记录。收款人需要证据来说明在每一笔交易的时候，大多数节点一致认为这个交易是第一时间到达的。</p><h4 id="3-时间戳服务器"><a href="#3-时间戳服务器" class="headerlink" title="3.时间戳服务器"></a>3.时间戳服务器</h4><p>我们提出的解决方案是从一个时间戳服务开始，这个服务器工作的方式是，对条目所在的区块的哈希加盖时间戳，并且广泛地公开这些哈希，比如通过报纸或者新闻组邮件。显然，为了能进入这个哈希序列，时间戳证明的数据在那个时间必须存在。每一个时间戳和以前的时间戳，形成了一条链，每一个追加的时间戳都是对前一个时间戳进行加强。</p><p><img src="/images/2022-03-03-blockChain-hash.jpg" alt=""></p><h4 id="4-工作量证明"><a href="#4-工作量证明" class="headerlink" title="4.工作量证明"></a>4.工作量证明</h4><p>为了基于点对点的基础实现一个分布式的时间戳服务器，我们将需要一个工作量证明的系统，这个系统和亚当贝克创造的“哈希现金”类似，而不是报纸或新闻组邮件。这个工作量包含寻找一个哈希值，比如用哈希算法SHA-256,这个哈希值以若干0开头。平均工作量和开头的0的个数是指数关系，并且验证很简单，只需要执行一次单独的哈希计算。</p><p>在我们的时间戳网络里，是这样实现工作量证明的，就是不断增加区块里的一个临时的数值，直到找到一个值使得区块的哈希值满足开头0的个数要求。一旦CPU花费计算满足了工作量证明的要求，这个区块链就无法修改，除非重新计算。随着后面的区块不断产生，想要改变这个区块，需要重做它后面所有区块的工作量。</p><p><img src="/images/2022-03-03-blockChain-workload.jpg" alt=""></p><p>工作量证明还解决了在多数决策法中决定展示的问题。如果大多数是基于一个IP一票，这可能会被可以支配多个IP的人破坏。工作量证明本质上也是一个IP一票。最长的链代表了大多数人的决定，这个链投入了最大的工作量。如果大多数的CPU算力由诚实节点控制，诚实的链就会增长的很快，超过任何竞争链。为了修改过去的一个块，攻击者需要重新投入算力完成这个却快和它以后的区块的工作量，然后追上并超越诚实节点的工作量。我们后面讨论落后的攻击者追上的概率，这个概率随着后面区块的增加呈现指数级减少。</p><p>硬件的速度越来越快，参与运行的节点随着时间兴趣也随着经常变化，为了抵消这些因素的影响，工作量的难度是由每小时区块产生的数量的浮点型来决定的，如果区块产生的太快，难度就相应的增加。</p><h4 id="5-网络"><a href="#5-网络" class="headerlink" title="5.网络"></a>5.网络</h4><p>运行这个网络的步骤如下：</p><ol><li>新交易给所有节点广播</li><li>每个节点将新交易放到一个区块</li><li>每个节点开始为这个区块寻找相应难度的工作量证明</li><li>当一个节点找到了这个工作量证明，把这个区块广播给所有节点</li><li>如果区块里所有的交易是有效的并且是没有被花费的，节点就会接受这个区块</li><li>节点把这个区块的哈希作为上一个哈希，并开始进行工作以竞争创建下一个区块</li></ol><p>节点总是认为最长的链是正确的，并且不断的工作去延长它。如果两个节点同时广播下一个区块，一些节点可能接受其中一个，也可能是另一个。这种情况下，他们在最先接收到的区块上工作，但是也会保存另外一个分支以防止它会变得更长。当下一个工作量被找到并且一个分支变得更长时，这种情况就会被打破，在另外一个分支上工作的节点就会切换到这个长的链上。</p><p>新交易广播不一定要广播到所有节点。只要他们能到达很多节点，这个交易很快就会进入下一个块。区块广播也能接受消息丢失。如果一个节点没有收到区块，当它收到下一个块时会发现自己少了一个区块，它就会请求来获得少的这个区块。</p><h4 id="6-激励"><a href="#6-激励" class="headerlink" title="6.激励"></a>6.激励</h4><p>按照惯例，区块的第一个交易是一个特别的交易，这个交易会发行新币并且所有者是这个区块的创建者。这为节点支持网络引入了激励机制，并且这提供了一个初始发行货币进入流通的方式，因为没有一个中央机构去发行他们。不断增加新货币的过程类似于黄金矿工消耗资源来增加黄金的流通。在这里，消耗的是CPU的时间和电费。</p><p>激励还包括提供交易手续费。如果交易中输出值比输入值小，这个差值就是手续费，它被加入到这个区块激励值里。一旦预定数量的币全部进入流通，激励就全部转为交易手续费，完全没有通货膨胀。</p><p>激励有助于鼓励节点保持诚实，如果一个贪婪的攻击者掌握比所有诚实节点还要大的算力，他将面临一个选择，是通过偷回他支付的钱来诈骗人，还是用算力产生新的币。他应该会发现遵守规则有更多的好处，这个规则可以让他比其他人组合得到更多的新币，比破坏这个系统得到的更多，而且财产合法。</p><h4 id="7-回收磁盘空间"><a href="#7-回收磁盘空间" class="headerlink" title="7.回收磁盘空间"></a>7.回收磁盘空间</h4><p>一旦一个币最新的交易被足够多的区块埋没，它之前的花费的交易就可以丢掉来节省空间。为了促成这个而不破坏区块的哈希，用这些交易生成一个默克尔树，仅仅根保存在区块的哈希里。那么旧区块可以通过去除树的一些分支进行压缩。这些内部的哈希就不用保存了。</p><p><img src="/images/2022-03-03-blockChain-recycle.jpg" alt=""></p><p>一个区块头大概80字节，如果我们假设每十分钟产生一个区块，一年就是80字节x6x24x365=4.2兆字节。2008年出售的电脑典型的配置是2G内存，根据摩尔定律预测，每年增加1.2G，即使区块头全部放在内存里，存储也不是问题。</p><h4 id="8-简化支付验证"><a href="#8-简化支付验证" class="headerlink" title="8.简化支付验证"></a>8.简化支付验证</h4><p>即使不允许网络节点，验证支付也是可能的。用户仅需要保存最长工作量证明链的区块头的拷贝，他通过查询网络节点直到确信它有最长的链来获取区块头，并且可以得到默尔克分支，分支连接了交易和这个打了时间戳的区块。他本身不能验证交易，但是通过连接到链上的一个地方，他可以看到网络节点已经接受了它，后面的区块进一步确定网络接受了它。</p><p><img src="/images/2022-03-03-blockChain-confirm.jpg" alt=""></p><p>因此，如果诚实节点控制着网络，验证就是可靠的，如果网络被攻击者控制，验证就是很弱的。虽然网络节点本身可以验证交易，但这种简化验证的方法会被攻击者编造的交易欺骗，因为攻击者可能持续控制网络。防止这种情况的一种策略是接收网络节点的告警，当他们检测到无效块的时候，提示用户软件下载整个区块，并且提醒确认交易的一致性。频繁接收支付的企业可能仍然想运行他们自己的节点，为了更独立的安全性和更快的验证。</p><h4 id="9-组合和分割价值"><a href="#9-组合和分割价值" class="headerlink" title="9.组合和分割价值"></a>9.组合和分割价值</h4><p>虽然可以单独处理硬币，为转账的每一分单独交易是很不方便的。为了能是价值分割和组合，交易包含多个输入和输出。正常的会有一个单独的以前交易来的大额输入或多个小额输入组合在一起，最多两个输出：一个用来支付，一个用来找零，有零钱的话会返回给发送者。</p><p><img src="/images/2022-03-03-blockChain-combine.jpg" alt=""></p><p>应该注意的是，一个交易依赖几个交易，这些交易依赖更多的交易，看起来很分散，但在这里不是一个问题，从不需要提取一个交易全部历史的独立的拷贝</p><h4 id="10-隐私"><a href="#10-隐私" class="headerlink" title="10.隐私"></a>10.隐私</h4><p>传统的银行通过限制向有关方和信任的第三方提供信息来达到一个保护隐私的目的。向公众广播所有交易的必须性将这个方法排除了。通过打破信息在其他地方流动性仍然可以保护隐私：通过保持公钥匿名性。公众可以看到一个人给其他人转钱了，但是没有信息可以把交易和某人联系起来。这类似于证券交易所公布的信息水平，交易时间和个人交易的规模是可以公开的，但不告诉当事人是谁。</p><p><img src="/images/2022-03-03-blockChain-personal.jpg" alt=""></p><p>作为一个附加的防火墙，每次交易都是使用一个新的密钥对，防止和一个共同的所有者联系起来。对于多输入交易来说，这个联系无法避免，所有的输入必须表明由同一个人所有。风险是如果表明了某一个秘钥的所有者，这种联系将表明其他交易也属于同一个人。</p><h4 id="11-计算"><a href="#11-计算" class="headerlink" title="11.计算"></a>11.计算</h4><p>我们想象一个场景，攻击者想要攻击用比诚实节点更快的速度产生一个替代链，即使成功了，也不会让系统能任意被修改，比如凭空产生价值或拿到不属于攻击者的钱。节点将不会接受一个无效的支付，并且诚实节点绝不会接受包含这种支付的区块。攻击者只能试着改变自己的交易来拿回本该花出去的钱。</p><p>诚实的链和攻击链的竞争可以说是二项式随机走动。成功事件是诚实链延长一个区块，领先优势加一，失败事件是攻击链延长一个区块，缩小一个差距。</p><p>一个攻击者从一个给定的赤字中追上的概率类似于赌徒破产问题。假设一个信用无限的赌徒从赤字开始，开始进行潜在次数无数的赌博，试图达到盈亏平衡。我们可以计算他达到盈亏平衡的概率，或者说从下次攻击链赶上诚实链的概率，如下：<br>p=诚实节点发现下一个区块的概率</p><p>q=攻击者找到下一个区块的概率</p><p>qz=攻击者在落后z个区块的情况下，追上的概率</p><p><img src="/images/2022-03-03-blockChain-formula.jpg" alt=""></p><p>假设p&gt;q,随着落后区块数量z增加，攻击者追上的概率呈指数下降。这个概率情况对攻击者不利，如果他没有幸运的提前向前冲刺，落后越多希望越渺茫。</p><p>我们现在考虑接收者在收到新的交易的时候，需要等待多长时间才能完全确定交易不能被发送者修改。我们假设发送者是攻击者，他想让接收者暂时相信他已经付款了，然后过了一段时间又换成是支付给自己。这事发生的时候接收者会受到警告，但是发送者希望一起都晚了。</p><p>接收者创建一个新的密钥对，签名之前很短的时间把公钥给发送者。这防止发送者提前准备一条链，持续在上面工作，直到他足够幸运达到了领先的程度，正好执行到这条交易。一旦这个交易发送了，不诚实的发送者开始在一个并行的链上秘密工作，这条链包含他的交易的另一个版本。</p><p>接收者一直等到知道交易被添加到一个区块中，并且后面已经追加了z个区块了。他并不知道攻击者的准确进展，但是可以假设诚实区块每个区块花费的时间是平均期望时间，攻击者潜在的进展将服从泊松分布，期望值：</p><p><img src="/images/2022-03-03-blockChain-formula2.jpg" alt=""></p><p>为了得到目前的攻击者仍能追上的概率，我们将他所取得的每一步进展的泊松密度乘以他可能从那一点追上的概率。</p><p><img src="/images/2022-03-03-blockChain-formula3.jpg" alt=""></p><p>变换一下避免对分布的无穷尾部求和…</p><p><img src="/images/2022-03-03-blockChain-formula4.jpg" alt=""></p><p>转换为c代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">AttackerSuccessProbability</span><span class="params">(<span class="keyword">double</span> q, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> p = <span class="number">1.0</span> - q;</span><br><span class="line">    <span class="keyword">double</span> lambda = z * (q / p);</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">int</span> i, k;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= z; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> poisson = <span class="built_in">exp</span>(-lambda);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">        poisson *= lambda / i;</span><br><span class="line">        sum -= poisson * (<span class="number">1</span> - <span class="built_in">pow</span>(q / p, z - k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果， 可以看到概率随着z的增加呈指数下降</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">q=0.1</span><br><span class="line">z=0 P=1.0000000</span><br><span class="line">z=1 P=0.2045873</span><br><span class="line">z=2 P=0.0509779</span><br><span class="line">z=3 P=0.0131722</span><br><span class="line">z=4 P=0.0034552</span><br><span class="line">z=5 P=0.0009137</span><br><span class="line">z=6 P=0.0002428</span><br><span class="line">z=7 P=0.0000647</span><br><span class="line">z=8 P=0.0000173</span><br><span class="line">z=9 P=0.0000046</span><br><span class="line">z=10 P=0.0000012</span><br><span class="line">q=0.3</span><br><span class="line">z=0 P=1.0000000</span><br><span class="line">z=5 P=0.1773523</span><br><span class="line">z=10 P=0.0416605</span><br><span class="line">z=15 P=0.0101008</span><br><span class="line">z=20 P=0.0024804</span><br><span class="line">z=25 P=0.0006132</span><br><span class="line">z=30 P=0.0001522</span><br><span class="line">z=35 P=0.0000379</span><br><span class="line">z=40 P=0.0000095</span><br><span class="line">z=45 P=0.0000024</span><br><span class="line">z=50 P=0.0000006</span><br><span class="line">对于p&lt;0.1%的求解…</span><br><span class="line">p &lt; 0.001</span><br><span class="line">q=0.10 z=5</span><br><span class="line">q=0.15 z=8</span><br><span class="line">q=0.20 z=11</span><br><span class="line">q=0.25 z=15</span><br><span class="line">q=0.30 z=24</span><br><span class="line">q=0.35 z=41</span><br><span class="line">q=0.40 z=89</span><br><span class="line">q=0.45 z=340</span><br></pre></td></tr></table></figure><h4 id="12-结论"><a href="#12-结论" class="headerlink" title="12.结论"></a>12.结论</h4><p>我们为无信任电子交易提出了一个系统，我们从数字签名币的常用框架开始，它对所有者有很强的控制，但是因为不能避免双花，所以还不完整。为了解决双花，我们提出了一个点对点网络，这个网络使用工作量证明记录一个公共的交易历史，只要诚实节点控制大部分的CPU算力，很快使得攻击者无法通过计算来改变交易历史。该网络的非结构化简单性使得它很稳健。节点同时工作，很少需要相互协调。他们不需要被识别，因为消息不需要路由到任何特定的位置，只需尽力传递就好。节点可以离开网络，也可以需要的时候重新加入网络，接受工作量链作为他离开的时候发生了什么的证据。他们用CPU算力投票，通过在有效的区块上工作并延续它来表达对区块的接受，通过不在新区块上工作表示拒绝无效区块。任何需要的规则和激励都可以在这种共识机制下进行。</p><p>基于论文的比特币网络于2009年初正式上线，其主要目的是存储该电子现金系统里所有账户间的转账交易，并且确保这些交易记录无法被篡改。</p><h3 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h3><p>比特币网络的功能仅限于让用户进行财务交易Finanicial Transaction，之后没有多久，很多就意识到可以用比特币创意中的区块链技术来进行金钱之外的价值交换，Vatalik Buterin 于 2013 年末发布了以太坊的白皮书：<a href="http://web.archive.org/web/20131228111141/http://vbuterin.com/ethereum.html">《Ethereum: The Ultimate Smart Contract and Decentralized Application Platform》</a></p><p>相比比特币网络的简洁，V提出了基于区块链技术创建更加复杂的去中心化应用Decentralized Application，简称为DApp的技术设计，典型的去中心化例子：</p><ul><li>基于以太坊创建新的加密货币 CroptoCurrency,这种能力是2017年各种ICO泛滥的技术动因。</li><li>基于以太坊创建域名注册系统、博彩系统</li><li>基于以太坊开发去中心化游戏，2017的以太猫等</li></ul><p>这些功能的实现都依赖于以太坊内建的智能合约Smart Contract，智能合约是存储在以太坊网络上的可以通过发送消息与之交互的代码片段。</p><p>基于以太坊智能合约可以方便的发行遵循ERC20规范的数字货币，这个过程常常被称为首次代币发行Initial Coin Offering，简称ICO,这给区块链企业融资提供了极大的便利，但由于成本极低被很多人滥用了，因为ICO过程是不受监管、且完全中心化的，项目方拿到募集来的以太坊随便花，而投资者拿到代币之后对项目运作和资金开销没有任何约束力。</p><p>2017年底V提出了 <a href="https://medium.com/@bonpay/daico-review-vitalik-buterins-new-model-of-ico-2091d5b1f873">DAICO</a> 的理念，即筹集的资金会被智能合约锁定在账户里面，区块链创业团队在资金支出时先提出请求，多数投资者投票同意后，募集来的资金才可以被花出去，这在很大程度上保障了投资者的利益，也是在鼓励创业团队踏实做事。实战小册灵感源于此，不算是严格意义上的ICO App，因此不涉及发币过程，但现有众筹版本。</p><h3 id="区块链-vs-WEB"><a href="#区块链-vs-WEB" class="headerlink" title="区块链 vs WEB"></a>区块链 vs WEB</h3><p>如果回顾区块链的发展历史，业内通常把区块链技术的发展分成3个阶段，作为前端工程师，我们可以将其和WEB技术的发展历史做如下类比：</p><ul><li>区块链1.0，代表是<a href="https://github.com/bitcoin/bitcoin">比特币</a>，只支持转账，类似于刚刚诞生的万维网，网页只支持静态内容的展示、链接等；</li><li>区块链2.0，代表是<a href="https://www.ethereum.org">以太坊</a>，能够在转账的基础上支持一定复杂度的业务逻辑定制即智能合约，类似于有了JS的万维网，即在静态展示的基础上自定义动态内容，但是浏览器的JS执行效率还是比较弱，不能在浏览器做非常复杂的事情；</li><li>区块链3.0，代表是各种高性能底层公链，比如<a href="https://eos.io">EOS</a>,是目前整个社区努力的方向，但开发生态的成熟还需要时间，能够支持高并发商业应用的运行，类似于为能各种复杂的端应用提供运行环境的现代浏览器，比如Chrome;</li></ul><h2 id="区块链中的核心概念和原理"><a href="#区块链中的核心概念和原理" class="headerlink" title="区块链中的核心概念和原理"></a>区块链中的核心概念和原理</h2><h3 id="账户、交易、区块、区块链"><a href="#账户、交易、区块、区块链" class="headerlink" title="账户、交易、区块、区块链"></a>账户、交易、区块、区块链</h3><p>如果说比特币是最早最成功的区块链应用，即基于区块链技术实现的银行系统，负责记账和发行货币，那么银行系统中存在的概念在区块链系统中也会存在，可以用银行账本中的概念来类比理解区块链的概念：</p><ul><li>账户Account：是用户在银行的户头+密码的组合，在区块链世界中也是如此，无论是比特币还是以太坊的账户都是由地址、公钥、私钥3部分构成，其中地址相当于用户名，而公钥+私钥相当于密码，尤其是私钥，丢失或者泄露就意味着是去账户（敏感信息、资金）的控制权</li><li>交易Transaction：是账本中的任意一条收支记录，在区块链世界中可以指两个账户之间的转账交易、或者智能合约调用请求；</li><li>区块Block：是账本中的一页，账本的每页可能包含多笔收入和支出，同样，区块链中的每个区块都可能包含多笔交易</li><li>区块链Blockchain：是装订成册的多页账本，账本不同页按照记录时间先后顺序组织，区块链中不同区块按被矿工打包的时间先后组织</li></ul><p>区块链技术通常被简单描述为：公开的、分布式、不可篡改的数据库技术或记账技术</p><h3 id="块高度、出块时间"><a href="#块高度、出块时间" class="headerlink" title="块高度、出块时间"></a>块高度、出块时间</h3><p>长时间记录的账本都会是多页的，在区块链世界也是如此，长时间运行的区块链网络记录下来的数据量也是巨大的。</p><p>块高度可以理解为账本的页数，在区块链世界里，块高度可以理解为自该区块链开始运行到现在共产生了多少区块，换个角度，我们可以认为块高度就是区块链时间的时间，每产生一个新的区块，快高度就会加1，<a href="https://blockexplorer.com/">比特币最新块高度</a>，<a href="https://etherscan.io/blocks">以太坊最新快高度</a></p><p>出块时间可以类比为记完每页账户并在上面按完手印需要花多少时间，在区块链世界里，即区块链上相邻两个块产生出来的时间间隔，或者常说的交易确认时间Transaction Confirm time，这里说的交易确认时间指某笔交易从发起到被打包进区块链的时间，和部分钱包、交易所的交易确认时间小很多，比如比特币的区块时间通常控制在10分钟，而以太坊则是15秒左右。任何打包的交易在分布式网络上达成共识都需要时间，共识算法决定了时间的长短。<a href="https://mp.weixin.qq.com/s?__biz=MzU1NjYyNzE0MA==&amp;mid=2247484622&amp;idx=1&amp;sn=34988179926bcf732d2e12ca1cb7fec9&amp;source=41#wechat_redirect">POW</a>、<a href="https://mp.weixin.qq.com/s?__biz=MzU1NjYyNzE0MA==&amp;mid=2247484616&amp;idx=1&amp;sn=96bcc002720edfb705752269638c7e64&amp;source=41#wechat_redirect">POS</a>、<a href="https://mp.weixin.qq.com/s?__biz=MzU1NjYyNzE0MA==&amp;mid=2247484615&amp;idx=1&amp;sn=7794501159e1da70117ed1dfd2fb88d9&amp;source=41#wechat_redirect">DPOS</a></p><h3 id="本章图解"><a href="#本章图解" class="headerlink" title="本章图解"></a>本章图解</h3><p><img src="/images/2022-03-03-blockChain-blockchain.jpg" alt=""></p><h2 id="以太坊核心概念和原理"><a href="#以太坊核心概念和原理" class="headerlink" title="以太坊核心概念和原理"></a>以太坊核心概念和原理</h2><h3 id="以太坊网络"><a href="#以太坊网络" class="headerlink" title="以太坊网络"></a>以太坊网络</h3><p>分两个视角来看：</p><h4 id="整体视角"><a href="#整体视角" class="headerlink" title="整体视角"></a>整体视角</h4><p>以太坊网络本质是P2P网络系统，其用途是发起交易、存储交易历史，这里的交易可以是转账或者是调用智能合约中的方法，而以太坊区块链是存储了以太坊网络上发生过的每笔交易的数据库。以太坊网络通常情况下是指主网，实际上社区中存在很多用途各异的以太坊网络，类比到Web工程里面3套环境，可以将其归类如下：</p><ul><li>主网：Mainnet,就是以太坊的线上环境，记录、保存用户和智能合约的交易，主网中存储的代币才具有真正的价值；</li><li>测试网：Testnet，就是以太坊的测试环境，目的是方便社区和开发者测试智能合约、转账等功能，典型的测试网络有Rinkeby/Ropsten/Kovan等，其中代币不具有任何价值，<a href="https://testnet.etherscan.io/">完整列表</a></li><li>其他网：就是以太坊的开发环境，常通过开发者在本地运行以太坊节点组成，或者使用各种便捷的工具启动的本地测试网，以及以内部测试为目的而搭建的私有网络等，随着以太坊区块链数据的累计，运行全节点的时间和硬件的成本也越来越大，实战会用更加轻量的开发环境搭建方式</li></ul><h4 id="个体视角"><a href="#个体视角" class="headerlink" title="个体视角"></a>个体视角</h4><p>P2P网络通常包含多个节点，每个节点都需要运行以太坊客户端，而任何人都可以运行以太坊节点，每个以太坊网络上的节点都包含了以太坊区块链数据库的整体副本，每个以太坊网络节点都可以接收RPC交易请求并将请求广播给网络中的其他节点，每个以太坊节点都会尝试进行交易的校验、打包（常说的挖坑），即区块生产的任务，生产出的区块也会被广播给其他网络节点。</p><blockquote><p>以太坊不同网络之间的账户可以完全相同，就好比我们可以把线上数据库的数据全部同步到我们测试环境数据库一样，但是不同测试网络之间、测试网络和主网之间、本地开发网络和主网之间是完全隔离的，即无法进行转账和智能合约功能调用</p></blockquote><h3 id="如何进行以太坊网络交互"><a href="#如何进行以太坊网络交互" class="headerlink" title="如何进行以太坊网络交互"></a>如何进行以太坊网络交互</h3><p>交互的具体定义是：向以太坊网络发送转账请求，或调用智能合约函数，用我们熟悉的计算术语来说，就是发起读取或者修改以太坊区块链上数据的请求，并拿到反馈的过程。</p><p>类似于现有世界中支持开发者自行开发应用的平台，比如微博开发平台、微信小程序等，我们可以把与平台交互的用户分成两大类：开发者、普通用户，两者与平台本身的交互方式、交互途径不同。</p><p>比如微信小程序生态下，开发者。普通用户、平台之间的交互方式可以简化如下：</p><p><img src="/images/2022-03-03-blockChain-miniwechat.jpg" alt=""></p><p>类似的，以太坊生态中，开发者、普通用户、平台的交互方式可简化为：</p><p><img src="/images/2022-03-03-blockChain-etch.jpg" alt=""></p><p>其中，<a href="https://github.com/ethereum/web3.js">web3.js</a>是前端工程师通过代码和以太坊网络交互的桥梁，而实际的DApp测试离不开使用钱包。</p><blockquote><p>不论是开发者，还是普通用户，与以太坊网络的交互都会落地到具体的网络节点上，因为只有节点可以接收RPC请求并将其广播给其他节点，任何代码或者应用如果需要同以太坊网络交互，都需要通过某个具体的节点。</p></blockquote><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><p>智能合约指以太坊网络上被代码控制的一个账户，不同于我们使用各种钱包软件创建的账户（由创建账户的用户来控制），智能合约对应的账户是由代码控制的，其他账户（包括智能合约账户、普通用户账户）可以通过交易Transcation的方式与智能合约账户交互，社区中也会把智能合约账户称为内部账户，而普通用户称为外部账户。这两种账户的关系可以用下图描述：</p><p><img src="/images/2022-03-03-blockChain-relation.jpg" alt=""></p><p>此外还需要注意的是，我们也常常用智能合约指代智能合约源代码或部署在以太坊网络上的智能合约账户，但本质上两者是有明显的区别的：如果把智能合约源代码比如设计图，那么智能合约账户就是根据蓝图造出来的车或者建筑。相同的源代码可以部署到不同的网络上，或者在相同的网络上部署很多次，都会产生不同的合约地址。整个过程可以用下图示意：</p><p><img src="/images/2022-03-03-blockChain-deploy.jpg" alt=""></p><p>无论部署到哪个网络，源代码是完全相同的，而部署所产生的智能合约账户只存在于其被部署到的那个网络，比如部署到Mainnet主网的智能合约不能通过Rinkeby测试网络去访问，反过来亦然，普通账户则在不同网络间是通用的。</p><p>每个智能合约会有下面几个关键属性：</p><ul><li>balance,即该智能合约账户所控制的资产余额，比如某个抽奖智能合约中奖池的资金；</li><li>storage,智能合约的相关数据会存储在这里，可粗暴的将其看做是DApp的数据库，比如抽奖智能合约里面存储参与人的地址；</li><li>code,智能合约的字节码，由智能合约源代码编译儿而来的，存储在区块链上方方便任何节点接受智能合约的函数调用</li></ul><h2 id="使用Metamask创建第一个以太坊HD钱包"><a href="#使用Metamask创建第一个以太坊HD钱包" class="headerlink" title="使用Metamask创建第一个以太坊HD钱包"></a>使用Metamask创建第一个以太坊HD钱包</h2><p>接触任何区块链网络都需要我们有自己的账户，管理账户的软件可称之为钱包，在创建钱包和账户之前，我们有必要了解以太坊网络中账户的组成：</p><p><img src="/images/2022-03-03-blockChain-account.jpg" alt=""></p><p>如上图，以太坊网络中的账户和典型的区块链账户没有太大区别，都由地址、公钥、私钥3部分构成，不论使用何种钱包构建的以太坊账户，在不同的以太网网络之间都是可以通用的，比如我在主网构建了钱包账户，而切换到Rinkeby测试网络时依然可以使用同样的账户，这和传统的Web应用有很大的区别，比如我们在微信创建的账户就不能到百度上。这种跨网络的账户机制实际上是内置在以太坊客户端之内的，无需关心细节。</p><p>不论是在以太坊网络上发起转账交易，还是部署智能合约，亦或是调用智能合约中的函数，我们都需要账户，方便以太坊记录和验证谁、在什么时间、做了什么。</p><p>区块链世界里面的钱包其实借鉴自现实世界的钱包，区块链世界里面，每张银行卡对应一个账户，每家银行对应一个区块链网络，而能管理你所有银行卡的软件叫做钱包，对应关系如下:</p><p><img src="/images/2022-03-03-blockChain-wallet.jpg" alt=""></p><h3 id="钱包运行环境"><a href="#钱包运行环境" class="headerlink" title="钱包运行环境"></a>钱包运行环境</h3><p>Metamask是浏览器插件，虽然能运行在多个浏览器，但考虑到Solidity调试工具运行环境、前端调试工具的丰富程度建议在Google浏览器进行</p><h3 id="创建钱包和账户"><a href="#创建钱包和账户" class="headerlink" title="创建钱包和账户"></a>创建钱包和账户</h3><p><a href="https://metamask.io/">Metamask</a> 为我们提供了非常便捷的以太坊浏览器钱包插件，Google Chrome WebStore 的下载地址猛击<a href="https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn/related?hl=en">这里</a></p><p>助记词是用来生成账户的公钥和私钥的，也就是用来恢复钱包里面所有的账户的。如果创建的是存在真实资产的账户，不要泄露助记词。</p><p>从密码学角度，地址、公钥、私钥本质都是非常大的数字，不论是转换为16进制或者base58格式，对普通用户来说看起来都是杂乱无章的随机字符串，如果区块链用户非要记住这些数字才能使用区块链的话，会非常麻烦。于是比特币社区提出了<a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP39</a>提议，技术上该提议可以在任意区块链中实现，比如使用完全相同的助记词在比特币和区块链上生成的地址可以是不同的，用户只需要记住满足一定规则的词组，钱包软件就可以基于该词组创建一些列的账户，并且保障无论是在什么硬件、什么时间创建出来的账户、公钥、私钥都完全相同，这样解决了账户识住的问题，也吧账户恢复的门槛降低了很多。支持BIP提议的钱包也可以归并为HD钱包，Hierarchical Deterministic Wallet,Metamask当属此类。</p><h2 id="深入理解以太坊中的交易Transaction"><a href="#深入理解以太坊中的交易Transaction" class="headerlink" title="深入理解以太坊中的交易Transaction"></a>深入理解以太坊中的交易Transaction</h2><p>从测试网络的充值不会马上成功，而是有15秒左右的延迟，正确理解区块链网络的交易Transaction是做区块链开发必要条件，正确理解以太坊网络上的交易是设计、开发出合理智能合约+DApp的基础条件。</p><p>交易详情中的几组关键信息：</p><ul><li>Transaction Hash：交易流水号，就像是去银行转账给你业务回折的那个流水号</li><li>Block：说明这笔交易被打包进了编号（快高）为xxx的区块， xxx Block Confirmations 表示这笔交易被打包以后，以太坊的Rinkey 测试网有产生了149个区块</li><li>Form/To/Value：交易的发起账户、接收账户、以及转账金额，如果是智能合约调用也会有这三个字段，但是会有说明调用了智能合约什么函数</li><li>Gas Price：交易手续费，Gas是交易手续单位，Ether,Gwei是以太坊中代币的单位，<ul><li>Limit表示在交易执行时最多消耗的汽油数量</li><li>Used 表示实际使用了多少汽油</li></ul></li></ul><p>以太坊交易中的汽油和现实中的汽油有异曲同工之妙，如果把以太坊交易比作开车去长途旅行，不难得出结论：</p><ul><li>长途旅游必然消耗汽油，而旅行消耗汽油的单位为升，在以太坊里面汽油的单位就叫做Gas</li><li>加油询问油价，以太坊中汽油的价格是用自己的货币比好标识的，可以为0.0000000039 Ether/Gas，也可以说 3.9 Gwei/Gas，其中的 Ether 和 Gwei 是以太坊中的货币单位</li><li>现实中货币单位精度为2为小数，即精确到分，区块链世界中的货币单位精度可以多达18小数</li><li>现实世界中如果中途没有油了，可以停在原地请求支援，以太坊中Gas不够，交易就会被直接回滚</li><li>如果现实里面的汽车行驶不需要消耗任何能源，即不支付任何经济成本，就很容易堵车。如果把以太坊比作高速公路，而各种交易比作行驶的汽车，设计汽油机制以及可以调控的汽油价格就是很好的网络拥塞避免措施，如果想降低汽油车出行，发改委可以把油价提的很高</li></ul><p>这里说的Ether就是在各种数字货币交易市场上的以太坊的交易单位，即ETH,以太坊的货币单位精度很高，所以不同精度货币单位的列表也很长，不同单位之间的换算可以参考：<a href="https://etherconverter.online/">etherconverter.online</a></p><h3 id="Gas-LImit-和-Gas-Price-详解"><a href="#Gas-LImit-和-Gas-Price-详解" class="headerlink" title="Gas LImit 和 Gas Price 详解"></a>Gas LImit 和 Gas Price 详解</h3><h3 id="Gas机制"><a href="#Gas机制" class="headerlink" title="Gas机制"></a>Gas机制</h3><p>为什么以太坊选择使用Gas去调节手续费，而没有选择像比特币那样使用比特币本身作为交易手续费</p><p>Gas是以太坊虚拟机EVM内部流通的货币，以太坊虚拟机用Gas来对交易打包、智能合约执行等操作收取费用。</p><p>调用某智能合约的接口需要执行如下操作，合约源代码编译出来的opcode就对应EVM中的操作，每个操作会产生特定的费用：</p><ul><li>执行加法运算：1Gas</li><li>存储某个变量的值：100Gas</li><li>调用其他智能合约：20Gas</li></ul><p>上会举例，完整的操作、手续费表在<a href="https://github.com/djrtwo/evm-opcode-gas-costs/blob/master/opcode-gas-costs_EIP-150_revision-1e18248_2017-04-12.csv">这里</a></p><p>在这种机制下，以太坊就可以对更加复杂的智能合约收取更多的费用，这样做很公平合理，因为需要更多存储和计算的智能合约消耗的资源更多，跟比特币不同的地方在于，比特币本身不支持在交易中包含复杂的计算逻辑，比特币是不支持智能合约的。</p><p>向以太坊提交一笔交易时，我们需要在交易中设定下面两个参数，虽然大多数时候只需要设定Gas Limit：</p><ul><li>Gas Price：指定我们愿意为每单位Gas支付的最高价格，Gas Price的单位才是以太坊中的单位，比如Wei,GWei</li><li>Gas Limit：指定我们最多愿意为执行该笔交易支付多少个 Gas</li></ul><h3 id="家政服务公司的类比"><a href="#家政服务公司的类比" class="headerlink" title="家政服务公司的类比"></a>家政服务公司的类比</h3><p>假设有家家政服务公司，主营业务是个客户提供清洁服务，运行让雇员在开展业务的收入随着市场供需的变化而变化，为了实现这种灵活性，家政服务公司发行了一种代币叫做清洁币QJB,客户在支付清洁费用时不实际支付人民币，而是支付代币，而清洁不同类型的房间收取不同的QJB，数量由家政服务公司设定，并且不允许修改：</p><ul><li>主卧，1QJB</li><li>客户，3</li><li>厨房，15</li><li>卫生间，10</li></ul><p>客户只需要支付家政公司QJB，而雇员收入的是QJB,QJB可以随时换成发币</p><p>这种机制下，家政公司的雇员实际上就客户愿意为每个QJB支付多少钱进行谈判，选择对自己有利的需求去满足，比如雇员希望每个QJB能换算为100人民币，而客户却只愿意支付80元，这时雇员就可以选择放弃为该客户服务，而且服务愿意支付更高价格的客户，自由度和灵活性就这样产生了。</p><p>以太坊中的Gas Price有异曲同工之妙，雇员扮演矿工的角色，客户的清洁需求好比提交到网络中的转账交易，如果交易的Gas Price设置过低，矿工可以选择不理会这笔交易，只打包Gas Price满足自己设定的最低值交易。实际上以太坊网络上的矿工也是这么做的，他们在启动节点时会设置能接受的最小Gas Price，低于设定值的交易都会被过滤掉，不同的矿工对于把这个值设为多少是有自由的。</p><p>Gas Limit在家政服务中是这样的：</p><p>假如你租了个别墅，里面房间特别多，生日那天开了一个Party，结束后需要有人来清理，但是因为办完派对，能支付清洁费用的资金有限，这时会跟说家政公司雇员说，我最多愿意为整个清洁支付50QJB,每个QJB价值是100元，如果费用不够打扫整个别墅，扫到哪里是哪里吧，剩下的我自己搞定。家政公司雇员开始工作后会多退少就停止。</p><p>这就好比执行复杂智能合约时，填写了如下的参数：</p><ul><li>Gas Price：100GWei/Gas</li><li>Gas Limit：50Gas</li></ul><p>EVM在执行你的交易时如果实际消耗的费用在50个单位以内，交易就会成功被执行和打包，如果不够，消耗到50个单位汽油时就会停止并回滚交易，这点和家政服务不同，清洁工作停止的时候，已经打扫过的房间会保持干净的状态，但是在EVM里面，不存在执行一半的交易，要么成功，要么回滚，即使Gas不够，不成功的执行也是消耗了计算资源。</p><p>Gas是EVM对各种操作收取费用的机制，如果你需要发起交易，Gas Price是你实际报给矿工的Gas单价，而Gas Limit表示你最多愿意为这笔交易支出多少个单位的Gas。</p><p>EVM执行每笔交易时实际要消耗多个Gas计算过程相关文章<a href="https://hackernoon.com/ether-purchase-power-df40a38c5a2f">在此</a></p><h3 id="几个重要的细节"><a href="#几个重要的细节" class="headerlink" title="几个重要的细节"></a>几个重要的细节</h3><h4 id="纯转账交易的手续费"><a href="#纯转账交易的手续费" class="headerlink" title="纯转账交易的手续费"></a>纯转账交易的手续费</h4><p>以太坊纯转账交易的Gas消耗是21000个单位，这里的纯转账指转的是ETH,不包括各种ERC20的代币，因为代币本身是智能合约，转账的时候需要调用智能合约的接口。</p><h4 id="Block-Gas-Limit"><a href="#Block-Gas-Limit" class="headerlink" title="Block Gas Limit"></a>Block Gas Limit</h4><p>如果把Gas Limit设置过高，会直接抛出错误：Exceeds block gas limit，这是以太坊从经济角度的独特设计，如果大家的 Gas Limit都可以设置得无限大，那么最后需要回退的 Gas 就很多了。</p><h4 id="合理的Gas-Price"><a href="#合理的Gas-Price" class="headerlink" title="合理的Gas Price"></a>合理的Gas Price</h4><p>etherscan.io 上有个实时变动的数据说明交易中合理的 Gas Price 应该设置为多少，猛击链接 [<a href="https://etherscan.io/gastracker">https://etherscan.io/gastracker</a>) 查看，如果想查看历史变化趋势，有下面两个链接供参考：</p><ul><li>Gas Limit 均值变化趋势可参考：[<a href="https://etherscan.io/chart/gaslimit)。">https://etherscan.io/chart/gaslimit)。</a></li><li>Gas Price 均值变化趋势可参考：[<a href="https://etherscan.io/chart/gasprice)。">https://etherscan.io/chart/gasprice)。</a></li></ul><h2 id="智能合约编程语言-Solidity介绍以及开发入门"><a href="#智能合约编程语言-Solidity介绍以及开发入门" class="headerlink" title="智能合约编程语言 Solidity介绍以及开发入门"></a>智能合约编程语言 Solidity介绍以及开发入门</h2><h3 id="什么是Solidity"><a href="#什么是Solidity" class="headerlink" title="什么是Solidity?"></a>什么是Solidity?</h3><p><a href="https://docs.soliditylang.org/en/v0.8.12/">Solidity</a>官方文档如是说：</p><blockquote><p>Solidity 是一种面向对象的高级语言，用于实现智能合约。智能合约是管理以太坊状态内账户行为的程序。</p><p>Solidity 是一种<a href="https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Curly-bracket_languages">花括号语言</a>。它受 C++、Python 和 JavaScript 的影响，旨在针对以太坊虚拟机 (EVM)。<a href="https://docs.soliditylang.org/en/v0.8.12/language-influences.html">您可以在语言影响</a>部分找到有关 Solidity 受到哪些语言启发的更多详细信息。</p><p>Solidity 是静态类型的，支持继承、库和复杂的用户定义类型等特性。</p><p>使用 Solidity，您可以创建用于投票、众筹、盲拍和多重签名钱包等用途的合约。</p></blockquote><p>Solidity属于强类型语言，内涵的类型除了常见的编程语言中的标准类型，还包括address等以太坊独有的类型，Solidity源码文件通常以.sol作为扩展名，</p><p>Solidity源代码要成为可以运行在以太坊的智能合约需要经历如下的步骤：</p><ul><li>用Solidity编写的智能合约源代码徐还要先使用编译器编译为字节码Bytecode,编译过程中会同时产生智能合约的二进制接口规范 Application Binary Interface,简称为ABI</li><li>通过简易Transaction的方式将字节码部署到以太坊网络，每次成功部署都会产生一个新的智能合约账户；</li></ul><p>而使用JavaScript编写的DApp通常通过web3.js+ABI去调用智能合约中的函数来实现数据的读取和修改，整个过程可以用下图示意：</p><p><img src="/images/2022-03-03-blockChain-program.jpg" alt=""></p><p>Bytecode和ABI可以认为是智能合约源代码的两种外在表现形式，其中Bytecode是给机器执行的，而ABI是给DApp开发者用的自然语言描述的合约接口规范。</p><p>从整体上来看，开发智能合约+DApp 不需要我们精通Solidity,但需要理解他和我们所熟知的语言的最大区别，就可以顺利开发出正确的智能合约。</p><h3 id="怎么开发Solidity"><a href="#怎么开发Solidity" class="headerlink" title="怎么开发Solidity?"></a>怎么开发Solidity?</h3><p>Remix是以太坊社区开发出来的在线智能合约集成开发环境，包含开发、部署、调试支持，官方还提供了桌面版，但桌面版仍然需要网络才可以正确运行</p><p>在前端开发环境中构建自己的智能合约的工作流，则需要组合使用现有的工具实现智能合约的编写、编译、部署、测试等环节。</p><h2 id="使用Solidity开发实现智能合约Hello-World"><a href="#使用Solidity开发实现智能合约Hello-World" class="headerlink" title="使用Solidity开发实现智能合约Hello World"></a>使用Solidity开发实现智能合约Hello World</h2><p>使用Remix开发和调试第一个智能合约，浏览器打开<a href="https://remix.ethereum.org">https://remix.ethereum.org</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.17;</span><br><span class="line"></span><br><span class="line">contract Car &#123;</span><br><span class="line">    string public brand;</span><br><span class="line"></span><br><span class="line">    constructor(string  initialBrand) public &#123;</span><br><span class="line">        brand = initialBrand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setBrand(string newBrand) public &#123;</span><br><span class="line">        brand = newBrand;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function getBrand() public view returns (string)&#123;</span><br><span class="line">        return brand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Solidity遇到public变量时，会认为其实需要持久化存储在以太坊区块链上的合约数据，即不仅仅是public variable,还是storage variable:</p><ul><li>public variable 中的 public 和传统面向对象语言中的 public 作用完全相同，运行运行时任何代码读取它</li><li>storage variable 中的 public 暗示着 Solidity 编译器智能合约生成 ABI 的时候自动为合约生成同名的 getter函数</li><li>Car 合约中除了 brand 变量，其他变量比如 initialBrand/newBrand 都属于临时变量、本地变量，声明周期仅限于合约函数被调用时</li></ul><p>Car合约中没有任何复杂的逻辑控制结构比如条件、循环，典型的函数声明格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getBrand() public view returns (string)&#123;</span><br><span class="line">return brand;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> getBrand 函数名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> public view 函数类型</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> returns (string) 返回类型</span></span><br></pre></td></tr></table></figure><p>其中典型的函数类型有以下几种：</p><ul><li>public,任何人都可以调用该函数，包括智能合约内部，或者外部账户、其他合约账户的调用</li><li>private，只有合约内部可以调用的函数</li><li>view，能够返回数据，并且不修改合约数据存储状态的函数</li><li>constant,和view的含义完全相同，不修改合约数据的函数</li><li>pure,纯粹的计算函数，和编程语言里面的 Pure Function含义完全相同，具体到智能合约领域，就是既不会读取，也不会修改合约数据</li><li>payable,标记付款类函数，调用该函数的用户在完成交易时会支付实际的资金</li></ul><p>合约部署后，最下面能看到新的合约账户，账户下面有按钮，每个按钮代表可以调用合约函数，如getBrand，如果按钮旁边有输入框，表示调用该函数的时候需要输入参数，如setBrand。我们直接点击brand或者getBrand按钮，会看到按钮右边立即显示了部署合约时设定的参数，点击了setBrand，没有输入内容则置空。这也是Remix的一个坑：不做参数校验。</p><p>我们合约没有声明brand方法，但部署后的合约里面有，这就是Solidity为公共访问的存储变量生成的getter方法，实际上源码的getBrand方法可以直接删除</p><h2 id="部署智能合约时发生了什么？"><a href="#部署智能合约时发生了什么？" class="headerlink" title="部署智能合约时发生了什么？"></a>部署智能合约时发生了什么？</h2><p>合约部署Create和合约实例Contract Instance有几个问题需要理解：</p><ul><li>智能合约部署的时候发生了什么，发送了什么？</li><li>部署合约用的是哪个账户，消耗的汽油哪里来的？</li><li>合约账户的形式是怎么样的，和普通用户的区别?</li><li>新创建合约实例3个方法对应的按钮，为什么set是红色，get和brand是不同颜色，有无区别，对后续DApp有什么影响？</li><li>Metamask账户重置的时候以太坊单笔交易确认时间平均要15s左右，为什么Remix测试的时候那么快？</li><li>如果合约源代码修改了，能否直接在旧的合约实例上测试，如果不能是为什么，要测试新合约需要怎么做？</li><li>合约编译的时候虽然没有报红色的错误，但是报了Waning是什么？</li></ul><h3 id="合约部署的本质"><a href="#合约部署的本质" class="headerlink" title="合约部署的本质"></a>合约部署的本质</h3><p>合约部署实际上是发起了一笔交易，交易的接受者为空，以太坊将接受者为空的交易默认认为是合约创建请求，这类交易中会修改当前部署合约的机器码ByteCode，部署成功的话会返回新建的合约账户，合约部署本身需要消耗Gas，这个费用是发起者支付的。合约部署的交易细节在Remix上通过调试日志可以看到，打开Remix调试日志区域，通过点击合约创建右上角的Details按钮可以看到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[vm]from: 0x5B3...eddC4to: Car.(constructor)value: 0 weidata: 0x608...00000logs: 0hash: 0x975...9483b</span><br><span class="line">statustrue Transaction mined and execution succeed</span><br><span class="line">transaction hash0x975cea2d7f3173162027050..2489e7e419483b</span><br><span class="line">from0x5B38Da...3FcB875f56beddC4</span><br><span class="line">toCar.(constructor)</span><br><span class="line">gas80000000 gas</span><br><span class="line">transaction cost263067 gas </span><br><span class="line">execution cost263067 gas </span><br><span class="line">hash0x975cea2d7f3...a52489e7e419483b</span><br><span class="line">input0x608...00000</span><br><span class="line">decoded input&#123;</span><br><span class="line">"string initialBrand": "A"</span><br><span class="line">&#125;</span><br><span class="line">decoded output - </span><br><span class="line">logs[]</span><br><span class="line">val0 wei</span><br></pre></td></tr></table></figure><p>input是智能合约字节码bytecode 跟在car.json 里面的 data bytecode object一样</p><h3 id="汽油哪里来的？"><a href="#汽油哪里来的？" class="headerlink" title="汽油哪里来的？"></a>汽油哪里来的？</h3><p>部署交易中的form字段跟JavaScript VM下出现的Account列表中的第一个账户完全相同，部署完之后选中的账户余额互少一点，少掉的这部分就是使用该账户部署智能合约时消耗的汽油</p><h3 id="合约账户的本质"><a href="#合约账户的本质" class="headerlink" title="合约账户的本质"></a>合约账户的本质</h3><p>合约部署的直观结果是我们得到一个账户，但是我们仅仅有这个账户的地址，而没有账户的公钥、私钥、这就是合约的定义，contract instance is an account controlled by code 的准确含义，后续和合约的交互也只能通过代码，即智能合约的函数调用。</p><h3 id="Remix带来的幻觉"><a href="#Remix带来的幻觉" class="headerlink" title="Remix带来的幻觉"></a>Remix带来的幻觉</h3><p>因为在测试时以太坊网络运行在内存中，并且是单节点，速度自然很快，但是缺陷是每次页面加载，这个测试网络中的合约实例、合约中的数据都会丢失，网络中的账户及余额也会重建</p><p>然后实际的以太坊网络，不论是测试网络还是主网，都不会那么快，在分布式网络上达成共识是个很复杂的过程，由于是对于使用POW共识算法的以太坊来说</p><h3 id="如何重新发布？"><a href="#如何重新发布？" class="headerlink" title="如何重新发布？"></a>如何重新发布？</h3><p>如果智能合约的源代码被修改，同样需要部署智能合约的示例，并测试这个全新的合约实例。与前端页面开发不同是，浏览器刷新后，老的页面样式、DOM接口、应用状态都被销毁了，而以太坊老的合约实例是不会被销毁 的，即使部署了新的版本，如果愿意也可以和老版本继续交互。</p><h3 id="Solidity其实和JS区别很大"><a href="#Solidity其实和JS区别很大" class="headerlink" title="Solidity其实和JS区别很大"></a>Solidity其实和JS区别很大</h3><p>Car合约自动生成的brand函数可能会消耗无限的汽油，这是在智能合约设计时需要避免的，因为智能合约中的任何代码都是需要消耗汽油的，如果不加限制，很容易出现汽油不够而操作被回滚、调用失败的情况。具体到例子：brand属性为字符串，在静态类型语言中字符串本质是动态长度的字节数组dynamically-sized byte array，也就是说我们的brand属性可能是非常长的字符数组，如果长度超过某个临界值，就会消耗超出预期的汽油，只需要把brand类型从string设置byte32即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.17;</span><br><span class="line"></span><br><span class="line">contract Car &#123;</span><br><span class="line">    bytes32 public brand;</span><br><span class="line"></span><br><span class="line">    function Car(bytes32 initialBrand) public &#123;</span><br><span class="line">        brand = initialBrand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setBrand(bytes32 newBrand) public &#123;</span><br><span class="line">        brand = newBrand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBrand() public view returns (bytes32) &#123;</span><br><span class="line">        return brand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用智能合约时发生了什么？"><a href="#调用智能合约时发生了什么？" class="headerlink" title="调用智能合约时发生了什么？"></a>调用智能合约时发生了什么？</h2><p>setBrand被标记为红色，调用它实际发起的是transaction,任何交易都是异步的。getBrand被标记为蓝色，调用它就是简单的函数调用 call</p><p>智能合约中的函数要么是transaction类型，要么是call类型，两种类型函数的本质都是接口请求，但是又存在很大的区别，对比如下表：</p><table><thead><tr><th>函数类型</th><th>call纯粹函数调用</th><th>transaction通过交易调用</th></tr></thead><tbody><tr><td>是否能修改合约数据</td><td>不能修改</td><td>可以修改</td></tr><tr><td>是否能返回数据</td><td>能返回数据</td><td>只能返回交易地址 TxHash</td></tr><tr><td>调用耗时长短</td><td>通常比较短</td><td>通常需要15s</td></tr><tr><td>是否需要花钱</td><td>免费调用</td><td>要花钱</td></tr></tbody></table><p>对于前端工程师，如果用同步、异步函数来类比则很好理解</p><ul><li>合约中的纯粹函数调用相当于同步的，而通过交易去调用的函数相当于异步的</li><li>通常我们不指望异步函数马上返回结果，除非给他传入了回调，也就预示着智能合约中会修改合约数据的函数即使声明了返回值，也是无效，让人不解的是Rexmix不会因为这个报错，因为调用的时候只会返回交易哈希</li></ul><h2 id="自建智能合约工作流的动机和目标"><a href="#自建智能合约工作流的动机和目标" class="headerlink" title="自建智能合约工作流的动机和目标"></a>自建智能合约工作流的动机和目标</h2><h3 id="Remix的局限性"><a href="#Remix的局限性" class="headerlink" title="Remix的局限性"></a>Remix的局限性</h3><ul><li>源代码没有版本控制，不存在编写一次就不用修改的代码，没有版本控制</li><li>智能合约只能在浏览器中运行，不能方便把合约部署到以太坊的主网或者测试网络</li><li>智能合约的测试都是手动的，手动的过程是不可靠的，如果有自动化的智能合约测试是最好的</li></ul><h3 id="Truffle的困扰"><a href="#Truffle的困扰" class="headerlink" title="Truffle的困扰"></a>Truffle的困扰</h3><p><a href="https://trufflesuite.com/">Truffle</a>s对自己的定位是以太坊开发的瑞士军刀，就好比前端领域的各种全家桶种子项目create-app,vue-cli等，帮你把各种关键模块react/webpack/vue/eslint组装好，只需要在上面开发应用逻辑即可，但对于刚入门区块链和以太坊的人来说，接触到的新概念、术语会比较多，不利于入门</p><h3 id="工作流目标"><a href="#工作流目标" class="headerlink" title="工作流目标"></a>工作流目标</h3><p>在Node开发环境使用几个最少的必要工具实现自己的智能合约编译、部署、测试工作流，整个工作流过程可以用下图：</p><p><img src="/images/2022-03-03-blockChain-node_work.jpg" alt=""></p><ol><li><a href="https://www.npmjs.com/package/solc">solc</a>工具把Solidity源代码编译成 Bytecode 和 ABI</li><li>把编译后的Bytecode 部署到本地测试网络<a href="https://www.npmjs.com/package/ganache-cli">ganache-cli</a>，公共测试网络<a href="https://www.npmjs.com/package/rinkeby">rinkeby</a>，使用到<a href="https://www.npmjs.com/package/web3">web3.js</a></li><li><p>单元测试中和部署完的智能合约实例交互，需要组合使用web3.js和<a href="https://www.npmjs.com/package/mocha">mochajs</a></p><p>其中ganache-cli是Truffle框架的一部分，能够让开发者快速启动本地测试网络，不需要在本地运行以太坊节点，web3.js在合约智能部署和自动化测试时会被大量使用，这也为后面开发DApp打下良好的基础。</p></li></ol><p>做完上面的事情后，重新Remix，看看我们如何在Remix中加载和测试使用脚本部署的智能合约实例</p><h2 id="编写智能合约编译脚本compile"><a href="#编写智能合约编译脚本compile" class="headerlink" title="编写智能合约编译脚本compile"></a>编写智能合约编译脚本compile</h2><p>scripts/compile.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> solc = <span class="built_in">require</span>(<span class="string">'solc'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> contractPath = path.resolve(__dirname, <span class="string">'../contracts'</span>, <span class="string">'Car.sol'</span>);</span><br><span class="line"><span class="keyword">const</span> contractSource = fs.readFileSync(contractPath, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = solc.compile(contractSource, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><p>运行Car.sol后得出下面的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  contracts: &#123;</span><br><span class="line">    ':Car': &#123;</span><br><span class="line">      assembly: [Object],</span><br><span class="line">      bytecode: '608060405234801...9d141bb3ee7074732b6b527fab31620b877c32f60029',</span><br><span class="line">      functionHashes: [Object],</span><br><span class="line">      gasEstimates: [Object],</span><br><span class="line">      interface: '[&#123;"constant":true,"inputs":[],"name":"brand","outputs":[&#123;"name":"","type":"string"&#125;],"payable":false,"stateMutability":"view","type":"function"&#125;,&#123;"constant":false,"inputs":[&#123;"name":"newBrand","type":"string"&#125;],"name":"setBrand","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"&#125;,&#123;"inputs":[&#123;"name":"initialBrand","type":"string"&#125;],"payable":false,"stateMutability":"nonpayable","type":"constructor"&#125;]',</span><br><span class="line">      metadata: '&#123;"compiler":&#123;"version":"0.4.26+commit.4563c3fc"&#125;,"language":"Solidity","output":&#123;"abi":[&#123;"constant":true,"inputs":[],"name":"brand","outputs":[&#123;"name":"","type":"string"&#125;],"payable":false,"stateMutability":"view","type":"function"&#125;,&#123;"constant":false,"inputs":[&#123;"name":"newBrand","type":"string"&#125;],"name":"setBrand","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"&#125;,&#123;"inputs":[&#123;"name":"initialBrand","type":"string"&#125;],"payable":false,"stateMutability":"nonpayable","type":"constructor"&#125;],"devdoc":&#123;"methods":&#123;&#125;&#125;,"userdoc":&#123;"methods":&#123;&#125;&#125;&#125;,"settings":&#123;"compilationTarget":&#123;"":"Car"&#125;,"evmVersion":"byzantium","libraries":&#123;&#125;,"optimizer":&#123;"enabled":true,"runs":200&#125;,"remappings":[]&#125;,"sources":&#123;"":&#123;"keccak256":"0x5cdc15332a2851cff3a4fb683f4779500af8a4e4c3f2456332d5643de8e9856b","urls":["bzzr://9e12529e71042b5ee545da27cab03c65921f2d4b69190f3e394589f32445913a"]&#125;&#125;,"version":1&#125;',</span><br><span class="line">      opcodes: 'PUSH1 0x80 PUSH1 ...527FAB31620B877C32F6 STOP 0x29 ',</span><br><span class="line">      runtimeBytecode: '608060405260043610...7074732b6b527fab31620b877c32f60029',        </span><br><span class="line">      srcmap: '28:215:0:-;;;76:79;8:9:-...-;;;;;;;;;;;;;;;;;;;;:::o;:::-;;;;;;;',</span><br><span class="line">      srcmapRuntime: '28:215:0:-;;;;;;...::i;:::-;;;:::o;:::-;;;;;;;;;;;;;;;;;;;;:::o'</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  sourceList: [ '' ],</span><br><span class="line">  sources: &#123; '': &#123; AST: [Object] &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>contracts属性包含了所有找到的合约，源代码中只有Car合约，每个合约下面都包括了assembly、bytecode、interface、metadata、opcodes等字段，目前阶段仅需要关心的字段有：</p><ul><li>bytecode，部署合约到以太坊测试网络需要使用</li><li>interface,ABI,使用web3初始化智能合约交互实例的时候需要使用</li></ul><p>interface</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"constant"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"inputs"</span>: [],</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"brand"</span>,</span><br><span class="line"><span class="attr">"outputs"</span>: [ &#123; <span class="attr">"name"</span>: <span class="string">""</span>, <span class="attr">"type"</span>: <span class="string">"string"</span> &#125; ],</span><br><span class="line"><span class="attr">"payable"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"stateMutability"</span>: <span class="string">"view"</span>,</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"function"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"constant"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"inputs"</span>: [ &#123; <span class="attr">"name"</span>: <span class="string">"newBrand"</span>, <span class="attr">"type"</span>: <span class="string">"string"</span> &#125; ],</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"setBrand"</span>,</span><br><span class="line"><span class="attr">"outputs"</span>: [],</span><br><span class="line"><span class="attr">"payable"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"stateMutability"</span>: <span class="string">"nonpayable"</span>,</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"function"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"inputs"</span>: [ &#123; <span class="attr">"name"</span>: <span class="string">"initialBrand"</span>, <span class="attr">"type"</span>: <span class="string">"string"</span> &#125; ],</span><br><span class="line"><span class="attr">"payable"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"stateMutability"</span>: <span class="string">"nonpayable"</span>,</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"constructor"</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以看到是内含三个元素的大数组：</p><ul><li>每个元素要么是合约构造函数，要么是可以调用的合约接口</li><li>每个元素里面有注明函数的类型、接收的参数类型、返回值的类型</li></ul><h3 id="保存编译结果"><a href="#保存编译结果" class="headerlink" title="保存编译结果"></a>保存编译结果</h3><p>使用 fs-extra,可以方便后续的部署和测试过程直接使用编译结果，需要把编译结果保存在文件系统中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> solc = <span class="built_in">require</span>(<span class="string">'solc'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> contractPath = path.resolve(__dirname, <span class="string">'../contracts'</span>, <span class="string">'Car.sol'</span>);</span><br><span class="line"><span class="keyword">const</span> contractSource = fs.readFileSync(contractPath, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = solc.compile(contractSource, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(result.contracts).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> contractName = name.replace(<span class="regexp">/^:/</span>, <span class="string">''</span>);</span><br><span class="line">    <span class="keyword">const</span> filePath = path.resolve(__dirname, <span class="string">'../compiled'</span>, <span class="string">`<span class="subst">$&#123;contractName&#125;</span>.json`</span>);</span><br><span class="line">    fs.outputJsonSync(filePath, result.contracts[name]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`save compiled contract <span class="subst">$&#123;contractName&#125;</span> to <span class="subst">$&#123;filePath&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后重新编译脚本，确保complied目录下包含了新生成的Car.json</p><p>类似于前端构建流程中编译步骤，编译之前需要把之前的结果清空，然后把最新的编译结果保存下来，对编译脚本作如下改动：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> solc = <span class="built_in">require</span>(<span class="string">'solc'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// cleanup</span></span><br><span class="line"><span class="keyword">const</span> compiledDir = path.resolve(__dirname, <span class="string">'../compiled'</span>);</span><br><span class="line">fs.removeSync(compiledDir);</span><br><span class="line">fs.ensureDirSync(compiledDir);</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile</span></span><br><span class="line"><span class="keyword">const</span> contractPath = path.resolve(__dirname, <span class="string">'../contracts'</span>, <span class="string">'Car.sol'</span>);</span><br><span class="line"><span class="keyword">const</span> contractSource = fs.readFileSync(contractPath, <span class="string">'utf8'</span>);</span><br><span class="line"><span class="keyword">const</span> result = solc.compile(contractSource, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// check errors</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(result.errors) &amp;&amp; result.errors.length) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(result.errors[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// save to disk</span></span><br><span class="line"><span class="built_in">Object</span>.keys(result.contracts).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> contractName = name.replace(<span class="regexp">/^:/</span>, <span class="string">''</span>);</span><br><span class="line">    <span class="keyword">const</span> filePath = path.resolve(__dirname, <span class="string">'../compiled'</span>, <span class="string">`<span class="subst">$&#123;contractName&#125;</span>.json`</span>);</span><br><span class="line">    fs.outputJsonSync(filePath, result.contracts[name]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`save compiled contract <span class="subst">$&#123;contractName&#125;</span> to <span class="subst">$&#123;filePath&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="编写智能合约部署脚本deploy"><a href="#编写智能合约部署脚本deploy" class="headerlink" title="编写智能合约部署脚本deploy"></a>编写智能合约部署脚本deploy</h2><h3 id="web3-js简介"><a href="#web3-js简介" class="headerlink" title="web3.js简介"></a>web3.js简介</h3><p>是把我们的前端世界和区块链世界连接起来的桥梁，web3js里面包含了多个以太坊生态中不同的模块，具体包含：</p><ul><li>web3-eth,方便js和以太坊区块链通信，部署、调用智能合约</li><li>web3-utils,为DApp开发者提供了大量的工具函数，比如单位换算等，DApp开发时会使用里面的函数</li><li>web3-shh,方便做基于whisper协议的P2P通信和广播</li><li>web3-bzz,方便做基于swarm协议的去中心化文件存储</li></ul><p>以太坊的主网、测试网络、本地私有网络非常多，以太坊的钱包应用也非常多，web3.js没有选择兼容所有的情况，而是自己定制了一个接口规范，让社区开发者为之贡献插件，插件在web3.js体系叫做provider，可以理解为webpack生态的plugin.</p><p>web3js通过插件机制和以太坊不通过网络通信的模式可以用下面的图示：</p><p><img src="/images/2022-03-03-blockChain-bridge.jpg" alt=""></p><h3 id="部署的必要条件"><a href="#部署的必要条件" class="headerlink" title="部署的必要条件"></a>部署的必要条件</h3><p>客户端和以太坊网络的任何交互都可以定性为接口调用和介意，智能部署属于后者，部署时除了必须要有bytecode。发起靠谱哦的必要条件也应算在内，具体来说包含如下几个方面：</p><h4 id="余额大于0的账户"><a href="#余额大于0的账户" class="headerlink" title="余额大于0的账户"></a>余额大于0的账户</h4><p>以太坊的任何交易都需要账户发起，账户中必须要有足够多的余额来支付手续费Transcation Fee，我们之前创建并充值的Metamask账户可以派上用场</p><h3 id="与目标网络的通信"><a href="#与目标网络的通信" class="headerlink" title="与目标网络的通信"></a>与目标网络的通信</h3><p>区块链上的任何交易都会被发送到某个网络，并被这个网络中的节点打包确认，可以考虑把智能合约部署到Rinkeby网络中，这样我们的交易通过自己运行的节点广播给Rinkeby测试网络中的其他节点，就能被打包确认，但是实际上前端自己跑节点成本还是很高的，还在社区有人做了各种以太坊的入口节点，为广发开发者提供接口可以直接调用。</p><p><a href="https://infura.io/">Infura</a>就提供了这样的服务</p><h3 id="合约部署脚本"><a href="#合约部署脚本" class="headerlink" title="合约部署脚本"></a>合约部署脚本</h3><p>scripts/deploy.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'config'</span>);</span><br><span class="line"><span class="keyword">const</span> Web3 = <span class="built_in">require</span>(<span class="string">'web3'</span>);</span><br><span class="line"><span class="keyword">const</span> HDWalletProvider = <span class="built_in">require</span>(<span class="string">'truffle-hdwallet-provider'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get ByteCode</span></span><br><span class="line"><span class="keyword">const</span> contractPath = path.resolve(__dirname, <span class="string">'../compiled/Car.json'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; interface, bytecode &#125; = <span class="built_in">require</span>(contractPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configuration Provider</span></span><br><span class="line"><span class="keyword">const</span> provider = <span class="keyword">new</span> HDWalletProvider(</span><br><span class="line">    config.get(<span class="string">'hdwallet'</span>),</span><br><span class="line">    config.get(<span class="string">'infuraUrl'</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initial Web3 Instance</span></span><br><span class="line"><span class="keyword">const</span> web3 = <span class="keyword">new</span> Web3(provider);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// Get Wallet Money</span></span><br><span class="line">    <span class="keyword">const</span> accounts = <span class="keyword">await</span> web3.eth.getAccounts();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'部署合约的账户：'</span>, accounts[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create Contract Instance And Deploy</span></span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">'合约部署耗时'</span>)</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="keyword">new</span> web3.eth.Contract(<span class="built_in">JSON</span>.parse(interface))</span><br><span class="line">        .deploy(&#123; <span class="attr">data</span>: bytecode, <span class="attr">arguments</span>: [<span class="string">'BINHONG'</span>] &#125;)</span><br><span class="line">        .send(&#123;</span><br><span class="line">            <span class="keyword">from</span>: accounts[<span class="number">0</span>],</span><br><span class="line">            gas:<span class="string">'1000000'</span>,</span><br><span class="line">            gasPrice: web3.utils.toHex(web3.utils.toWei(<span class="string">'10'</span>, <span class="string">'gwei'</span>)),</span><br><span class="line">            gasLimit: web3.utils.toHex(<span class="number">21000</span>),</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'合约部署耗时'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> contractAddress = result.options.address;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'合约部署成功'</span>, contractAddress);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'合约查看地址'</span>, <span class="string">`https://rinkeby.etherscan.io/address/<span class="subst">$&#123;contractAddress&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write Contract Address Into File System</span></span><br><span class="line">    <span class="keyword">const</span> addressFile = path.resolve(__dirname, <span class="string">'../address.json'</span>);</span><br><span class="line">    fs.writeFileSync(addressFile, <span class="built_in">JSON</span>.stringify(contractAddress));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'地址写入成功:'</span>, addressFile);</span><br><span class="line"></span><br><span class="line">    process.exit();</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>Configuration Provider 初始化了 Infura 提供的 HTTP 接口的测试网入口以及助记词钱包的provider，钱包助记词是 Metamask的钱包助记词</p><p>接着使用配置好的插件实例生成新的web3 实例</p><p>调用 web3.eth.getAccounts 方法解锁助记词钱包里面的第1个账户作为部署合约的账户，我们充值的也是Metamask钱包的第一个账户，而实际上这个助记词是可以派生出很多账户的，其他账户没有余额，也就无法使用</p><p>Create Contract Instance And Deploy 的代码也可以分开来写，链式的代码调用实际上做了合约初始化、交易初始化、交易发送3件事情：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contract = <span class="keyword">new</span> web3.eth.Contract(<span class="built_in">JSON</span>.parse(interface));</span><br><span class="line"><span class="keyword">const</span> transaction = contract.deploy(&#123;<span class="attr">data</span>:bytecode,<span class="attr">arguments</span>:[<span class="string">'BINHONG'</span>]&#125;);</span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> transaction.send(&#123;<span class="attr">from</span>:accounts[<span class="number">0</span>],<span class="attr">gas</span>:<span class="number">100000</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="使用etherscan-和-remix-查看和测试合约实例"><a href="#使用etherscan-和-remix-查看和测试合约实例" class="headerlink" title="使用etherscan 和 remix 查看和测试合约实例"></a>使用etherscan 和 remix 查看和测试合约实例</h2><p>智能合约实例是存储在以太坊网络上被代码控制的账户，部署完之后，可以通过echerscan/remix去访问它、和它交互</p><h3 id="用etherscan查看合约"><a href="#用etherscan查看合约" class="headerlink" title="用etherscan查看合约"></a>用etherscan查看合约</h3><p>用什么网络就用xxtestnet.etherscan.io/tx/contractAddress,点击列表最左侧的TxHash字段，可以看到合约部署的交易细节：</p><p><img src="./public/images/transation_detail.jpg" alt="transation_detail"></p><h3 id="用Remix测试智能合约"><a href="#用Remix测试智能合约" class="headerlink" title="用Remix测试智能合约"></a>用Remix测试智能合约</h3><p>可以使用Remix加载测试网络上特定的合约实例，并与之交互，下面是具体步骤</p><h4 id="配置合约源码"><a href="#配置合约源码" class="headerlink" title="配置合约源码"></a>配置合约源码</h4><p>run transactions里面环境选择你的测试网络，编译原来的源码，At Address输入你的合约地址，然后进行调试，getbrand可以很快拿到值，但是setBrand却是处于pending状态，在账户那里会显示可能需要花费的汽油，确定后15s内返回结果，并消耗了汽油</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">statustrue Transaction mined and execution succeed</span><br><span class="line">transaction hash0xa45...08e7eb67d003d936ad0d6591c83cf</span><br><span class="line">from0x95...14c</span><br><span class="line">toCar.setBrand(string) 0xc32eDBd9...C46</span><br><span class="line">gas29457 gas</span><br><span class="line">transaction cost29453 gas </span><br><span class="line">hash0xa45e1443c2f61b3...cf</span><br><span class="line">input0xc1f...00000</span><br><span class="line">decoded input&#123;</span><br><span class="line">"string newBrand": "Test"</span><br><span class="line">&#125;</span><br><span class="line">decoded output - </span><br><span class="line">logs[]</span><br><span class="line">val0 wei</span><br></pre></td></tr></table></figure><p>再次点击brand，就是返回刚刚输入的”Test”了</p><h2 id="使用mocha-web3-js-ganache编写合约测试"><a href="#使用mocha-web3-js-ganache编写合约测试" class="headerlink" title="使用mocha+web3.js+ganache编写合约测试"></a>使用mocha+web3.js+ganache编写合约测试</h2><p>针对部署后的合约实例进行测试，而不是合约源代码，可以看为端到端测试</p><p>自动化测试可以跟测试网络上的合约实例交互，但是每次跑测试都需要花点几分钟时间，此外还要自己进行复杂的账户管理。</p><p>因为区块链网络交易确认的异步性，在工具选择时需要做些权衡，ganache-cli就像是Remix中运行在内容中的JavaScript VM测试网络，其方法调用，交易确认速度非常快，为开发者提供了成本极低的本地测试网络，很适合用来测试。</p><p>而ganache-cli为web3.js提供了兼容的provider，这样就可以通过web3.js把合约部署到ganache-cli提供的本地测试网络上，并且跟合约实例交互。</p><h3 id="编写测试"><a href="#编写测试" class="headerlink" title="编写测试"></a>编写测试</h3><p>测试时我们通常会把每次测试运行的环境隔离开，对应到智能合约测试，每次测试需要部署新的合约实例，然后针对新的实例做功能测试</p><p>Car合约的功能比较简答，设计如下2个测试用例：</p><ul><li>合约部署时传入的brand属性被正确存储</li><li>调用setBrand之后合约的brand属性被正确更新</li></ul><p>测试代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</span><br><span class="line"><span class="keyword">const</span> ganache = <span class="built_in">require</span>(<span class="string">'ganache-cli'</span>);</span><br><span class="line"><span class="keyword">const</span> Web3 = <span class="built_in">require</span>(<span class="string">'web3'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> contractPath = path.resolve(__dirname, <span class="string">'../compiled/Car.json'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; interface, bytecode &#125; = <span class="built_in">require</span>(contractPath);</span><br><span class="line"><span class="keyword">const</span> web3 = <span class="keyword">new</span> Web3(ganache.provider());</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> accounts;</span><br><span class="line"><span class="keyword">let</span> contract;</span><br><span class="line"><span class="keyword">const</span> initialBrand = <span class="string">'BinHong'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'contract'</span>, () =&gt; &#123;</span><br><span class="line">    beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        accounts = <span class="keyword">await</span> web3.eth.getAccounts();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'合约部署账户：'</span>, accounts[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        contract = <span class="keyword">await</span> <span class="keyword">new</span> web3.eth.Contract(<span class="built_in">JSON</span>.parse(interface))</span><br><span class="line">            .deploy(&#123; <span class="attr">data</span>: bytecode, <span class="attr">argument</span>: [initialBrand] &#125;)</span><br><span class="line">            .send(&#123; <span class="attr">from</span>: accounts[<span class="number">0</span>] &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'合约部署成功：'</span>, contract.options.address)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(<span class="string">'deploy a contract'</span>, () =&gt; &#123;</span><br><span class="line">        assert.ok(contract.options.address);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(<span class="string">'has initial brand'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> brand = <span class="keyword">await</span> contract.methods.brand().call();</span><br><span class="line">        assert.equal(brand, initialBrand)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(<span class="string">'can change the brand'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> newBrand = <span class="string">'LBH'</span>;</span><br><span class="line">        <span class="keyword">await</span> contract.methods.setBrand(&#123; newBrand &#125;).send(&#123; <span class="attr">form</span>: accounts[<span class="number">0</span>] &#125;)</span><br><span class="line">        <span class="keyword">const</span> brand = <span class="keyword">await</span> contract.methods.brand().call();</span><br><span class="line">        assert.equal(brand, newBrand);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>代码使用的断言库是nodejs内置的assert模块，ganache-cli的provider自己在内部管理了一些账户。web3.js智能合约实例交互的方法，在DApp开发时会大量使用：</p><ul><li>contract.methods.brand().call()，调用合约上的方法，通常是取数据，立即返回</li><li>contract.methods.setBrand(‘xxx’).send(),对合约发起交易，通常是修改数据，返回是交易Hash</li></ul><p>send必须指定发起的账户地址，而call可以直接调用</p><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ mocha tests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  contract</span><br><span class="line">合约部署账户： 0x25E0EAE6B1A9D09Ad3B8f20E1945B6Aa03055275</span><br><span class="line">合约部署成功： 0xC9640efE6f4AE6561BC5CE294C814f71f465E04f</span><br><span class="line">    ✔ deploy a contract</span><br><span class="line">合约部署账户： 0x25E0EAE6B1A9D09Ad3B8f20E1945B6Aa03055275</span><br><span class="line">合约部署成功： 0x72af628dE4b4C09D82aA66846aD3317EA6B818f4</span><br><span class="line">    ✔ has initial brand</span><br><span class="line">合约部署账户： 0x25E0EAE6B1A9D09Ad3B8f20E1945B6Aa03055275</span><br><span class="line">合约部署成功： 0xB572717DFc65236F6a07631A5b02a80FaAD29CB1</span><br><span class="line">    ✔ can change the brand (295ms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  3 passing (1s)</span><br><span class="line"></span><br><span class="line">Done <span class="keyword">in</span> 3.47s.</span><br></pre></td></tr></table></figure><h3 id="完整的工作流"><a href="#完整的工作流" class="headerlink" title="完整的工作流"></a>完整的工作流</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "predeploy": "yarn compile",</span><br><span class="line">  "pretest": "yarn compile",</span><br><span class="line">  "compile": "node scripts/compile.js",</span><br><span class="line">  "deploy": "node scripts/deploy.js",</span><br><span class="line">  "test": "mocha tests/"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;失踪人员回归，学习记录点区块链知识…&lt;/p&gt;
&lt;h1 id=&quot;区块链开发入门：从0到1构建基于以太坊智能合约的ICO-DApp&quot;&gt;&lt;a href=&quot;#区块链开发入门：从0到1构建基于以太坊智能合约的ICO-DApp&quot; class=&quot;headerlink&quot; title=&quot;区块
      
    
    </summary>
    
      <category term="区块链" scheme="http://laibh.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://laibh.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>RxJS</title>
    <link href="http://laibh.top/2021-04-25-rxjs.html"/>
    <id>http://laibh.top/2021-04-25-rxjs.html</id>
    <published>2021-04-25T01:50:25.000Z</published>
    <updated>2022-03-04T10:00:38.464Z</updated>
    
    <content type="html"><![CDATA[<p>学习抄录加强记忆…</p><h1 id="RxJS"><a href="#RxJS" class="headerlink" title="RxJS"></a>RxJS</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>RxJS 是一个库，通过使用 observable 序列来编写异步和基于事件的程序，提供一个核心的类型 Observable,附属类型（Observer/Schedulers/Subjects）和受[Array#extras]启发的操作符（map,filter,reduce,every等等），这些数组操作符可以把异步事件作为集合来处理。</p><blockquote><p>可以把 Rxjs当做是用来处理事件的 Lodash</p></blockquote><p>ReactiveX 结合了观察者模式、迭代器模式和使用集合的函数式编程，以满足以一种理想方式来管理序列所需要的一切。</p><p>在 RxJS中用来解决异步事件管理的基本概念是：</p><ul><li>Observable（可观察对象）：表示一个概念，这个概念是一个可调用的未来值或事件的集合</li><li>Observer（观察者）：一个回调函数的集合，它知道如何去监听由 Observable提供的值</li><li>Subscription（订阅）：表示 Observable的执行，主要用于取消 Observable的执行。</li><li>Operators（操作符）：采用函数式编程风格的纯函数（pure function）,使用像map/filter/concat/flatMap等这样的操作符来处理集合</li><li>Subject（主体）：相当于 EventEmitter,并且是将值或事件多路推送给多个 Observer 的唯一方式</li><li>Schedulers（调度器）：用来控制并发并且是中央集权的调度员，运行我们在发生计算时进行协调，例如 setTimeout 或 requestAnimationFrame或其他。</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>注册事件监听器常规写法与 RxJS写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const button = document.querySelector(&apos;button&apos;);</span><br><span class="line">button.addEventListener(&apos;click&apos;,()=&gt;console.log(&apos;Clicked!&apos;))</span><br><span class="line"></span><br><span class="line">// RxJS</span><br><span class="line">Rx.Observable.fromEvent(button,&apos;click&apos;).subscribe(()=&gt;console.log(&apos;Clicked!&apos;))</span><br></pre></td></tr></table></figure><h4 id="纯净性（Purity）"><a href="#纯净性（Purity）" class="headerlink" title="纯净性（Purity）"></a>纯净性（Purity）</h4><p>RxJS 强大的正是它使用纯函数来产生值的能力，这意味这代码不容易出错。</p><p>通常会创建一个非纯函数，在这个函数之外也使用了共享变量的代码，使得应用状态一团糟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let count = 0;</span><br><span class="line">button.addEventListener(&apos;click&apos;,()=&gt;console.log(`Clicked $&#123;++count&#125; times`))</span><br><span class="line"></span><br><span class="line">// RxJS</span><br><span class="line">Rx.Observable.fromEvent(button,&apos;click&apos;).scan(count=&gt;count+1,0).subscribe(count=&gt;console.log(`Clicked $&#123;count&#125; times`))</span><br></pre></td></tr></table></figure><p><code>scan</code>操作符的工作原理与数组的 reduce类似，它需要一个暴露给回调函数当参数的初始值，每次回调函数运行后的返回值会作为下次回调函数运行时的参数。</p><h4 id="流动性（Flow）"><a href="#流动性（Flow）" class="headerlink" title="流动性（Flow）"></a>流动性（Flow）</h4><p>RxJS 提供一整套操作符来帮助控制事件如何流经 observables.</p><p>下面的代码展示的是如何控制一秒钟内最多点击一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const count = 0;</span><br><span class="line">const rate = 1000;</span><br><span class="line">const lastClick = Date.now() - rate;</span><br><span class="line">const button = document.querySelector(&apos;button&apos;);</span><br><span class="line">button.addEventListener(&apos;click&apos;,()=&gt;&#123;</span><br><span class="line">    if(Date.now() - lastClick &gt;= rate)&#123;</span><br><span class="line">        console.log(`Clicked $&#123;++count&#125; times`)</span><br><span class="line">        lastClick = Date.now();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// RxJS</span><br><span class="line">Rx.Observable.fromEvent(button,&apos;click&apos;).throttleTime(1000).scan(count=&gt;count+1,0).subscribe(count=&gt;console.log(`Clicked $&#123;count&#125; times`))</span><br></pre></td></tr></table></figure><h4 id="值（Values）"><a href="#值（Values）" class="headerlink" title="值（Values）"></a>值（Values）</h4><p>对于流经 observables 的值，可以对其进行转换</p><p>下面代码展示的是如何累加每次点击的鼠标x坐标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">button.addEventListener(&apos;click&apos;,(event)=&gt;&#123;</span><br><span class="line">    if(Date.now() - lastClick &gt;= rate)&#123;</span><br><span class="line">        count += event.clientX;</span><br><span class="line">        lastClick = Date.now();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// RxJS</span><br><span class="line">Rx.Observable.FromEvent(button,&apos;click&apos;).throttleTime(1000).map(event=&gt;event.clickX).scan((count,clientX)=&gt;count+clientX,0).subscribe(count=&gt;console.log(count));</span><br></pre></td></tr></table></figure><h2 id="Observable（可观察对象）"><a href="#Observable（可观察对象）" class="headerlink" title="Observable（可观察对象）"></a>Observable（可观察对象）</h2><p>Observable 是多个值的惰性推送集合，填补了下面表格的空白：</p><table><thead><tr><th></th><th>单个值</th><th>多个值</th></tr></thead><tbody><tr><td>拉取</td><td>Function</td><td>Iterator</td></tr><tr><td>推送</td><td>Promise</td><td>Observable</td></tr></tbody></table><p>实例：当订阅下面代码中的 Observable的时候会立即（同步地）推送值1，2，3，然后1秒后会推送值4，再然后是完成流：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const &#123; Observable &#125; = require(&apos;rxjs&apos;);</span><br><span class="line"></span><br><span class="line">const observable = new Observable(obeserver =&gt; &#123;</span><br><span class="line">  obeserver.next(1);</span><br><span class="line">  obeserver.next(2);</span><br><span class="line">  obeserver.next(3);</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    obeserver.next(4);</span><br><span class="line">    obeserver.complete();</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 要调用 Observable 并看到这些值，我们需要订阅 Observable</span><br><span class="line">console.log(&apos;just before subscribe&apos;);</span><br><span class="line"></span><br><span class="line">observable.subscribe(&#123;</span><br><span class="line">  next: x =&gt; console.log(`got value $&#123;x&#125;`),</span><br><span class="line">  error: err =&gt; console.error(`something wrong occurred: $&#123;err&#125;`),</span><br><span class="line">  complete: () =&gt; console.log(&apos;done&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&apos;just after subscribe&apos;)</span><br></pre></td></tr></table></figure><h4 id="拉取（Pull）vs-推送（Push）"><a href="#拉取（Pull）vs-推送（Push）" class="headerlink" title="拉取（Pull）vs. 推送（Push）"></a>拉取（Pull）vs. 推送（Push）</h4><p>拉取和推送是两种不同的协议，用来描述数据生产者（Producer）如何与数据消费者（Consumer）进行通信的。</p><p>拉取-在拉取体系中，由消费者来决定何时从生产者那里接收数据。生产者本身不知道数据是何时交付到消费者手中的。</p><p>每个JS函数都是拉取体系，函数是数据的生产者，调用该函数的代码通过从函数调用中取出一个单个返回值来对该函数进行消费。</p><p>ES2015引入了 generator 函数和 iterators(function*) 这是另外一种类型的拉取体系。调用 iterator.next() 的代码是消费者，它会从 iterator(生产者)取出多个值</p><table><thead><tr><th></th><th>生产者</th><th>消费者</th></tr></thead><tbody><tr><td>拉取</td><td>被动的：当被请求时产生数据</td><td>主动的：决定何时请求数据</td></tr><tr><td>推送</td><td>主动的：按自己的节奏产生数据</td><td>被动的：对收到的数据做出反应</td></tr></tbody></table><p>推送-在推送体系中，由生产者来决定何时把数据发送给消费者，消费者本身不知道何时会接受到数据</p><p>Promise是最常见的推送体系类型。由Promise(生产者)将一个解析过的值传递给已注册的回调函数（消费者），但不同于函数的是，由Promise来决定何时把值推送给回调函数。</p><p>RxJS引入了 Observables 一个新的推送体系。Observable 是多个值的生存者，并将值推送给观察者（消费者）。</p><ul><li>Function 是惰性的评估运算，调用时会同步地返回一个单一值</li><li>Generator 是惰性的评估运算，调用时会同步地返回零到（有可能的）无限多个值</li><li>Promise 是最终可能（或可能不）返回单个值的运算</li><li>Observable 是惰性的评估运算，它可以从它被调用的时刻起同步或异步地返回零到（有可能的）无限多个值</li></ul><h4 id="Observable作为函数的泛化"><a href="#Observable作为函数的泛化" class="headerlink" title="Observable作为函数的泛化"></a>Observable作为函数的泛化</h4><p>与流行的说法相反，Observable 既不像 EventEmitters，也不像多个值的Promises，在某些情况下，即当使用RxJS的Subjects进行多播时，Observables的行为可能会比较像EventEmitters，但通常情况下Observables的行为并不像EventEmitters.</p><blockquote><p>Observables 像是没有参数，但可以泛化为多个值的函数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    console.log(&apos;Hello&apos;);</span><br><span class="line">    return 42;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const x = foo.call(); // 相当于 foo()</span><br><span class="line">console.log(x)</span><br><span class="line"></span><br><span class="line">const y = foo.call(); // 等同于 foo()</span><br><span class="line">console.log(y)</span><br><span class="line"></span><br><span class="line">// 输出 &quot;Hello&quot; 42 &quot;Hello&quot; 42</span><br><span class="line">// Observables</span><br><span class="line">const &#123; Observable &#125; = require(&apos;rxjs&apos;);</span><br><span class="line"></span><br><span class="line">const foo = new Observable(observer =&gt; &#123;</span><br><span class="line">  console.log(&apos;Hello&apos;);</span><br><span class="line">  observer.next(42)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">foo.subscribe(x =&gt; console.log(x))</span><br><span class="line">foo.subscribe(y =&gt; console.log(y))</span><br></pre></td></tr></table></figure><p>因为函数和 Observables 都是惰性运算，如果不调用函数，不会执行<code>console.log(&#39;Hello&#39;)</code>。Observable 也是如此，不调用（使用 <code>subscribe</code>）,<code>console.log(&#39;Hello&#39;)</code>也不会执行。此外，调用或订阅是独立的操作；两个函数调用会触发两个单独的副作用，两个Observable订阅同样也是触发两个单独的副作用。EventEmitters共享副作用并且无论是否存在订阅者都会尽早执行，Observables与之相反，不会共享副作用并且是延迟执行。</p><blockquote><p>订阅 Observable 类似于调用函数</p></blockquote><p>一些人声称Observables是异步的，那不是真的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;before&apos;);</span><br><span class="line">foo.subscribe(x=&gt;console.log(x))</span><br><span class="line">console.log(&apos;after&apos;);</span><br><span class="line">/**</span><br><span class="line">before</span><br><span class="line">Hello</span><br><span class="line">42</span><br><span class="line">after</span><br><span class="line">*/</span><br><span class="line">// 这说明了foo订阅是完全同步的，就像函数一样</span><br></pre></td></tr></table></figure><p>那么 Observable 和函数的区别是什么？Observable可以随着时间的推移返回多个值，这是函数所做不到的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    console.log(&apos;Hello&apos;);</span><br><span class="line">    return 45;</span><br><span class="line">    return 100; // 死代码，不会执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数只能返回一个值，但 Observables 可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const foo = new Observable(observer =&gt; &#123;</span><br><span class="line">  console.log(&apos;Hello&apos;);</span><br><span class="line">  observer.next(42);</span><br><span class="line">  observer.next(100);</span><br><span class="line">  observer.next(200);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&apos;before&apos;)</span><br><span class="line">foo.subscribe(x =&gt; console.log(x))</span><br><span class="line">console.log(&apos;after&apos;)</span><br><span class="line">/**</span><br><span class="line">before</span><br><span class="line">Hello</span><br><span class="line">42</span><br><span class="line">100</span><br><span class="line">200</span><br><span class="line">after</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>也可以异步地返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const foo = new Observable(observer =&gt; &#123;</span><br><span class="line">  console.log(&apos;Hello&apos;);</span><br><span class="line">  observer.next(42);</span><br><span class="line">  observer.next(100);</span><br><span class="line">  observer.next(200);</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    observer.next(300);</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&apos;before&apos;)</span><br><span class="line">foo.subscribe(x =&gt; console.log(x))</span><br><span class="line">console.log(&apos;after&apos;)</span><br><span class="line">/**</span><br><span class="line">before</span><br><span class="line">Hello</span><br><span class="line">42</span><br><span class="line">100</span><br><span class="line">200</span><br><span class="line">after</span><br><span class="line">300</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>结论：</p><ul><li>func.call() 意思是同步地给一个值</li><li>observable.subscribe() 意思是给我任意数量的值，无论是同步还是异步的</li></ul><h4 id="Observable剖析"><a href="#Observable剖析" class="headerlink" title="Observable剖析"></a>Observable剖析</h4><p>Observables使用观察者来订阅，然后执行并发送 <code>next/error/complete</code>给观察者，而且执行可能会被清理。这四个方面全部编码在Observables实例中，但某些方面是与其他类型相关的，像 Observer观察者和Subscription订阅</p><p>Observable的核心关注点：</p><ul><li>创建 Observables</li><li>订阅 Observables</li><li>执行 Observables</li><li>清理 Observables</li></ul><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const observable = new Observable(observer =&gt; &#123;</span><br><span class="line">  const id = setInterval(() =&gt; observer.next(&apos;hi&apos;), 1000)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const observable = new Observable(observer =&gt; &#123;</span><br><span class="line">  const id = setInterval(() =&gt; observer.next(&apos;hi&apos;), 1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">observable.subscribe(x =&gt; console.log(x))</span><br></pre></td></tr></table></figure><p>subscribe调用在同一 Observable 的多个观察者之间是不共享的，当使用一个观察者调用 observable.subscribe时，new Observable(subscrive)中的 subscribe函数只服务给定的观察者，对于observable.subscribe的每次调用都会触发针对给定观察者的独立设置</p><blockquote><p>订阅 Observable 像是调用函数，并提供接收数据的回调函数</p></blockquote><p>这与像 addEventListener/removeEventListener 这样的事件处理方法API是完全不同的。使用 observable.subscribe 在 Observable中不会将给定的 观察者注册为监听器。Observable甚至不会去维护一个附加的观察者列表</p><p>subscribe 调用是启用Observable执行的一种简单方式，并将值或事件传递给本次执行的观察者</p><h5 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h5><p>Observable 是惰性运算，只有在每个观察者订阅后才会执行，随着时间的推移，执行会以同步或异步的方式产生值</p><p>Observable执行可以传递三种类型的值：</p><ul><li>Next通知：发送一个值，比如数字、字符串、对象等等</li><li>Error通知：发送一个JS错误或异常</li><li>Complete通知：不再发送任何值</li></ul><p>Next通知是最重要，也是最常见的类型，它们表示传递给观察者的实际数据，Error和Complete通知只会在Observable执行期间发生一次，并且只会执行其中的一个</p><p>这些约束用所谓的 Observable语法或合约表达最好，写为正则是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next*(error|complete)?</span><br></pre></td></tr></table></figure><p>三个next然后是complete</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const observable = new Observable(observer =&gt; &#123;</span><br><span class="line">  observer.next(1);</span><br><span class="line">  observer.next(2);</span><br><span class="line">  observer.next(3);</span><br><span class="line">  observer.complete();</span><br><span class="line">&#125;)</span><br><span class="line">// Observable严格遵守自身的规约，complete之后不会再发送</span><br></pre></td></tr></table></figure><p>try/catch可以捕获异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const observable = new Observable(observer =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    observer.next(1);</span><br><span class="line">    observer.next(2);</span><br><span class="line">    observer.next(3);</span><br><span class="line">    observer.complete();</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    observer.error(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h5><p>因为Observable执行可能是无限的，并且观察者通常希望能在有限的时间内中止执行，所以我们需要一个API来取消执行，因为每个执行都是其对应观察者专属的，一旦观察者完成接收值，它必须要一种方法来停止执行，以避免浪费计算能力和内存资源。</p><p>当调用了 observable.subcribe 观察者会被附加到新创建的 Observable 执行中，这个调用还返回了一个对象，即 Subscription(订阅)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const subscription = observable.subscribe(x=&gt;console.log(x))</span><br></pre></td></tr></table></figure><p>Subscription表示进行中的执行，有最小化的API以允许你取消执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const &#123; from &#125; = require(&apos;rxjs&apos;);</span><br><span class="line"></span><br><span class="line">const observable = from([10,20,30])</span><br><span class="line">const subscription = observable.subscribe(x=&gt;console.log(x));</span><br><span class="line">subscription.unsubscribe();</span><br></pre></td></tr></table></figure><blockquote><p>当订阅了 Observable会得到一个 Subscription，它表示进行中的执行，只要调用 unsubscribe方法就可以取消执行</p></blockquote><p>Observable可以通过返回一个自定义 unsubscribe函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const observable = new Observable(observer =&gt; &#123;</span><br><span class="line">  const intervalID = setInterval(() =&gt; &#123;</span><br><span class="line">    observer.next(&apos;hi&apos;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">  return function unsubscribe() &#123;</span><br><span class="line">    clearInterval(intervalID)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const subscription = observable.subscribe(x =&gt; console.log(x));</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  subscription.unsubscribe();</span><br><span class="line">&#125;, 2000)</span><br></pre></td></tr></table></figure><h2 id="Observer（观察者）"><a href="#Observer（观察者）" class="headerlink" title="Observer（观察者）"></a>Observer（观察者）</h2><p>观察者是由 Observable发送的值的消费者，观察者只是一组回调函数的集合，每个回调函数对应一种 Observable发送的通知类型：next/error和complete，下面是一个典型的观察者对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const observable = new Observable(observer =&gt; &#123;</span><br><span class="line">  const intervalID = setInterval(() =&gt; &#123;</span><br><span class="line">    observer.next(&apos;hi&apos;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">  return function unsubscribe() &#123;</span><br><span class="line">    clearInterval(intervalID)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const observer = &#123;</span><br><span class="line">  next: x =&gt; console.log(`Observer got a next value: $&#123;x&#125;`),</span><br><span class="line">  error: err =&gt; console.log(`Observer got a error: $&#123;err&#125;`),</span><br><span class="line">  complete: () =&gt; console.log(`Observer got a complete notification`),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const subscription = observable.subscribe(observer);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  subscription.unsubscribe();</span><br><span class="line">&#125;, 2000)</span><br></pre></td></tr></table></figure><blockquote><p>观察者只是有三个回调函数的对象，每个回调函数对应一种 Observable发送的通知类型</p></blockquote><p>RxJS的观察者也可能是部分的，如果没有提供某个回调函数，Observable的执行也会正常执行，只是某些通知类型可能会被忽略，因为观察者中没有相对应的回调函数</p><h2 id="Subscription（订阅）"><a href="#Subscription（订阅）" class="headerlink" title="Subscription（订阅）"></a>Subscription（订阅）</h2><p>Subscription是表示可清理资源的对象，通常是 Observable的执行，Subscription中有一个重要的方法，即 unsubscribe，不需要任何参数，只是用来清理 Subscription占用的资源，上个版本又叫做 Disposable（可清理对象）</p><blockquote><p>Subscription基本上只有一个 unsubscribe() 函数，这个函数用来释放资源或去取消 Observable执行</p></blockquote><p>Subscription还可以合在一起，这样一个 Subscription调用 unsubscribe 方法，可能会有多个 Subscription取消订阅，可以通过把一个Subscription添加到另外一个来做这件事</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const observable1 = interval(400);</span><br><span class="line">const observable2 = interval(300);</span><br><span class="line"></span><br><span class="line">const subscription = observable1.subscribe(x =&gt; console.log(&apos;first:&apos;, x))</span><br><span class="line">const childSubscription = observable2.subscribe(x =&gt; console.log(&apos;second:&apos;, x))</span><br><span class="line"></span><br><span class="line">subscription.add(childSubscription);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  subscription.unsubscribe();</span><br><span class="line">&#125;, 1000)</span><br><span class="line">/*</span><br><span class="line">second: 0</span><br><span class="line">first: 0</span><br><span class="line">second: 1</span><br><span class="line">first: 1</span><br><span class="line">second: 2</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// Subscriptions 还有一个 remove(otherSubscription)方法，用来撤销一个已添加的子 Subscription</span><br></pre></td></tr></table></figure><h2 id="Subject（主体）"><a href="#Subject（主体）" class="headerlink" title="Subject（主体）"></a>Subject（主体）</h2><p>Subject是一种特殊类型的 Observable,它允许将值多播给多个观察者，所以Subject是多播，而普通的 Observable是单播的（每个已订阅的观察者都拥有 Observable的独立执行）</p><blockquote><p>Subject 像是 Observable,但是可以多播给多个观察者，Subject还像是 EventEmitters，维护着多个监听器的注册表</p></blockquote><p>每个 Subject都是 Observable，对于 Subject，可以提供一个观察者并使用 subscribe方法，就可以开始正常接收值，从观察者角度，无法判断 Observable执行是普通的 Observable还是 Subject</p><p>在Subject内部，subscribe 不会调用发送值的新执行，它只是将给定的观察者注册到观察者列表中，类似于其他库或语言中的 addListener的工作方式</p><p>每个 Subject都是观察者，Subject是一个有如下方法的对象：next(v)/error(e)/complete()，要给 Subject提供新值，只要调用 next(theValue)，它会将值多播给已注册监听该Subject的观察者们。</p><p>下面的例子给 Subject添加两个观察者，然后给 Subject提供一些值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const subject = new Subject();</span><br><span class="line"></span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: (v) =&gt; console.log(`ObserverA: `, v)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: (v) =&gt; console.log(`ObserverB: `, v)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">subject.next(1);</span><br><span class="line">subject.next(2);</span><br><span class="line">/*</span><br><span class="line">ObserverA:  1</span><br><span class="line">ObserverB:  1</span><br><span class="line">ObserverA:  2</span><br><span class="line">ObserverB:  2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>因为 Subject是观察者，这也就意味着可以把 Subject作为参数传给任何 Observable的 subscribe方法，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const subject = new Subject();</span><br><span class="line"></span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: (v) =&gt; console.log(`ObserverA: `, v)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: (v) =&gt; console.log(`ObserverB: `, v)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const observable = from([1, 2, 3])</span><br><span class="line">observable.subscribe(subject)</span><br><span class="line">/*</span><br><span class="line">ObserverA:  1</span><br><span class="line">ObserverB:  1</span><br><span class="line">ObserverA:  2</span><br><span class="line">ObserverB:  2</span><br><span class="line">ObserverA:  3</span><br><span class="line">ObserverB:  3</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>使用上面的方法基本上只是通过 Subject将单播的 Observable执行转换为多播的，也说明了Subjects是将任意的 Observable 执行共享给多个观察者的唯一方式。</p><p>还有一些特殊的类型的Subject: BehaviorSubject/ReplaySubject和AsyncSubject</p><h3 id="多播的Observables"><a href="#多播的Observables" class="headerlink" title="多播的Observables"></a>多播的Observables</h3><p>多播的Observable通过Subject来发送通知，这个Subject可能有多个订阅者，然后普通的单播 Observable值发送通知给单个观察者。</p><blockquote><p>多播 Observable在底层是通过使用 Subject使得多个观察者可以看到同一个 Observable执行</p></blockquote><p>在低层，这是 multicast操作符的工作原理：观察者订阅一个基础的Subject，然后Subject订阅源Observable</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const source = from([1, 2, 3]);</span><br><span class="line">const subject = new Subject();</span><br><span class="line">const multicasted = source.multicast(subject);</span><br><span class="line"></span><br><span class="line">// 在底层使用了 `subject.subscribe(&#123;...&#125;)`:</span><br><span class="line">multicasted.subscribe(&#123;</span><br><span class="line">  next: (v) =&gt; console.log(`ObserverA: `, v)</span><br><span class="line">&#125;)</span><br><span class="line">multicasted.subscribe(&#123;</span><br><span class="line">  next: (v) =&gt; console.log(`ObserverB: `, v)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 在底层使用了 `source.subscribe(subject)`:</span><br><span class="line">multicasted.connect();</span><br></pre></td></tr></table></figure><p>multicast操作符返回一个Observable，看起来和普通的Observable没有什么区别，但当订阅就像是Subject,multicast返回的是ConnectableObservable，它只是一个有connect方法的 Observable.</p><p>connect决定了何时启动共享的Observable执行，因为connect在底层执行了source.subscribe(subject)。它返回的是Subscription，可以取消订阅以取消共享的Observable执行</p><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>手动调用 connect并处理 Subscription过于笨重，当第一个观察者到达时我们要自动连接，而当最后一个观察者取消订阅时我们想要自动地取消共享执行。</p><ol><li>第一个观察者订阅了多播的Observable</li><li>多播Observable已连接</li><li>next值0发送给第一个观察者</li><li>第二个观察者订阅了多播Observable</li><li>next值1发送给第一个观察者</li><li>next值1发送给第二个观察者</li><li>第一个观察者取消了多播的Observable订阅</li><li>next值2发送给第二个观察者</li><li>第二个观察者取消了多播 Observable 的订阅</li><li>多播 Observable的连接已中断(底层进行的操作是取消订阅)</li></ol><p>要实现这点，需要显式调用 connect:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const &#123; interval, Subject  &#125; = require(&apos;rxjs&apos;);</span><br><span class="line">const &#123; multicast &#125; = require(&apos;rxjs/operators&apos;);</span><br><span class="line"></span><br><span class="line">const source = interval(500);</span><br><span class="line">const multicasted = source.pipe(multicast(() =&gt; new Subject()));</span><br><span class="line">let subscription1, subscription2, subscriptionConnect;</span><br><span class="line"></span><br><span class="line">subscription1 = multicasted.subscribe(&#123;</span><br><span class="line">    next: v =&gt; console.log(`ObserverA: $&#123;v&#125;`)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">subscriptionConnect = multicasted.connect();</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    subscription2 = multicasted.subscribe(&#123;</span><br><span class="line">        next: v =&gt; console.log(`ObserverB: $&#123;v&#125;`)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, 600)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    subscription1.unsubscribe();</span><br><span class="line">&#125;, 1200)</span><br><span class="line"></span><br><span class="line">// 取消共享的 observable执行的订阅，因此此后 multicasted将不再有订阅者</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    subscription2.unsubscribe();</span><br><span class="line">    subscriptionConnect.unsubscribe();</span><br><span class="line">&#125;, 2000)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">ObserverA: 0</span><br><span class="line">ObserverA: 1</span><br><span class="line">ObserverB: 1</span><br><span class="line">ObserverB: 2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>如果不想显式调用 connect ,可以使用 ConnectableObservable的 refCount 方法引用计数，这个方法返回 Observable,这个 Observable会追踪多个订阅者。当订阅者的数量从0变成1，它会调用connect以开启共享的执行，当订阅者数量从1变成0时，它会完全取消订阅，停止进一步的执行。</p><blockquote><p>refCount的作用是，当有第一个订阅者时，多播 Observable会自动地启动执行，当最后一个订阅者离开时，多播 Observable会自定地停止执行。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">const &#123; interval, Subject &#125; = require(&apos;rxjs&apos;);</span><br><span class="line">const &#123; multicast, refCount &#125; = require(&apos;rxjs/operators&apos;);</span><br><span class="line"></span><br><span class="line">const source = interval(500);</span><br><span class="line">const subject = new Subject();</span><br><span class="line">/*</span><br><span class="line">const refCounted = source.pipe(</span><br><span class="line">    multicast(subject),</span><br><span class="line">    refCount()</span><br><span class="line">)</span><br><span class="line">*/</span><br><span class="line">const refCounted = source.pipe(multicast(subject)).pipe(refCount())</span><br><span class="line"></span><br><span class="line">let subscription1, subscription2;</span><br><span class="line"></span><br><span class="line">// 这里其实调用了 `connect()`，</span><br><span class="line">// 因为 `refCounted` 有了第一个订阅者</span><br><span class="line">console.log(&apos;observerA subscribed&apos;);</span><br><span class="line"></span><br><span class="line">subscription1 = refCounted.subscribe(&#123;</span><br><span class="line">    next: v =&gt; console.log(`ObserverA: $&#123;v&#125;`)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    subscription2 = refCounted.subscribe(&#123;</span><br><span class="line">        next: v =&gt; console.log(`ObserverB: $&#123;v&#125;`)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, 600)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;observerA unsubscribed&apos;);</span><br><span class="line">    subscription1.unsubscribe();</span><br><span class="line">&#125;, 1200)</span><br><span class="line"></span><br><span class="line">// 这里共享的 Observable 执行会停止，</span><br><span class="line">// 因为此后 `refCounted` 将不再有订阅者</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;observerB unsubscribed&apos;);</span><br><span class="line">    subscription2.unsubscribe();</span><br><span class="line">&#125;, 2000)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">observerA subscribed</span><br><span class="line">ObserverA: 0</span><br><span class="line">ObserverA: 1</span><br><span class="line">ObserverB: 1</span><br><span class="line">observerA unsubscribed</span><br><span class="line">ObserverB: 2</span><br><span class="line">observerB unsubscribed</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h3><p>Subject的其中一个变体就是 BehaviorSubject，它有一个当前值的概念，它保存了发送给消费者的最新值，并且当有新的观察者订阅时，会立即从 BehaviorSubject那接收到当前值</p><blockquote><p>BehaviorSubjects适合用来表示随着时间推移的值，例如生日的流是一个Subject,但年龄的流应该是一个BehaviorSubject</p></blockquote><p>下面例子中，BehaviorSubject使用值0进行初始化，当第一个观察者订阅时会得到0，第二个观察者订阅时会得到值2，尽管它是在值2发送之后订阅的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const beSubject = new BehaviorSubject(0);</span><br><span class="line"></span><br><span class="line">beSubject.subscribe(&#123;</span><br><span class="line">    next: v =&gt; console.log(`observerA: $&#123;v&#125;`)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">beSubject.next(1);</span><br><span class="line">beSubject.next(2);</span><br><span class="line"></span><br><span class="line">beSubject.subscribe(&#123;</span><br><span class="line">    next: v =&gt; console.log(`observerB: $&#123;v&#125;`)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">beSubject.next(3)</span><br><span class="line">/*</span><br><span class="line">observerA: 0</span><br><span class="line">observerA: 1</span><br><span class="line">observerA: 2</span><br><span class="line">observerB: 2</span><br><span class="line">observerA: 3</span><br><span class="line">observerB: 3</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h3><p>ReplaySubject 类似于 BehaviorSubject,它可以发送旧值给新的订阅者，但它还可以记录Observable执行的一部分</p><blockquote><p>ReplaySubject 记录 Observable 执行中的多个值并将其回放给新的订阅者</p></blockquote><p>当创建 ReplaySubject时，可以指定回放多个值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const reSubject = new ReplaySubject(3);</span><br><span class="line"></span><br><span class="line">reSubject.subscribe(&#123;</span><br><span class="line">    next: v =&gt; console.log(`observerA: $&#123;v&#125;`)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">reSubject.next(1);</span><br><span class="line">reSubject.next(2);</span><br><span class="line">reSubject.next(3)</span><br><span class="line">reSubject.next(4)</span><br><span class="line"></span><br><span class="line">reSubject.subscribe(&#123;</span><br><span class="line">    next: v =&gt; console.log(`observerB: $&#123;v&#125;`)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">reSubject.next(5)</span><br><span class="line">/*</span><br><span class="line">observerA: 1</span><br><span class="line">observerA: 2</span><br><span class="line">observerA: 3</span><br><span class="line">observerA: 4</span><br><span class="line">observerB: 2</span><br><span class="line">observerB: 3</span><br><span class="line">observerB: 4</span><br><span class="line">observerA: 5</span><br><span class="line">observerB: 5</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>除了缓冲数量，还可以指定 window time(以毫秒为单位)来确定多久之前的值可以记录，在下面的示例中，使用了较大的缓存数量100，但 window time 参数只设置了500毫秒。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const reSubject = new ReplaySubject(100, 500);</span><br><span class="line"></span><br><span class="line">reSubject.subscribe(&#123;</span><br><span class="line">    next: v =&gt; console.log(`observerA: $&#123;v&#125;`)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let i = 1;</span><br><span class="line"></span><br><span class="line">setInterval(() =&gt; reSubject.next(i++), 200)</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    reSubject.subscribe(&#123;</span><br><span class="line">        next: v =&gt; console.log(`observerB: $&#123;v&#125;`)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, 1000)</span><br></pre></td></tr></table></figure><p>从下面的输出可以看出，第二个观察者得到的值是<code>3</code>、<code>4</code>，这两个值是订阅发生前的<code>500</code>毫秒内发生的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">observerA: 1</span><br><span class="line">observerA: 2</span><br><span class="line">observerA: 3</span><br><span class="line">observerA: 4</span><br><span class="line">observerB: 3</span><br><span class="line">observerB: 4</span><br><span class="line">observerA: 5</span><br><span class="line">observerB: 5</span><br><span class="line">observerA: 6</span><br><span class="line">observerB: 6</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="AsyncSubject"><a href="#AsyncSubject" class="headerlink" title="AsyncSubject"></a>AsyncSubject</h3><p>只当 Observable 执行完成时（执行complete）它才会将执行的最后一个值发送给观察者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const asSubject = new AsyncSubject(100, 500);</span><br><span class="line"></span><br><span class="line">asSubject.subscribe(&#123;</span><br><span class="line">    next: v =&gt; console.log(`observerA: $&#123;v&#125;`)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">asSubject.next(1);</span><br><span class="line">asSubject.next(2);</span><br><span class="line">asSubject.next(3);</span><br><span class="line">asSubject.next(4);</span><br><span class="line"></span><br><span class="line">asSubject.subscribe(&#123;</span><br><span class="line">    next: v =&gt; console.log(`observerB: $&#123;v&#125;`)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">asSubject.next(5);</span><br><span class="line">asSubject.complete();</span><br><span class="line">/*</span><br><span class="line">observerA: 5</span><br><span class="line">observerB: 5</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>AsyncSubject和last操作符类似，因为它也是等待complete通知，一发送一个单一值</p><h2 id="Operators（操作符）"><a href="#Operators（操作符）" class="headerlink" title="Operators（操作符）"></a>Operators（操作符）</h2><p>操作符是运行复杂的异步代码以声明的方式进行轻松组合的基础代码单元</p><h3 id="什么是操作符？"><a href="#什么是操作符？" class="headerlink" title="什么是操作符？"></a>什么是操作符？</h3><p>操作符是Observable类似上的方法。当操作符被调用时，它们不会改变已经存在的 Observable实例。相反，它们返回一个新的 observable，它的 subscription逻辑基于第一个 Observable.</p><blockquote><p>操作符是函数，它基于当前的 Observable 创建一个新的 Observable，这是一个无副作用的操作：前面的 Observable保持不变</p></blockquote><p>操作符本质上是一个纯函数，它接收一个 observable 作为输入，并生成一个新的 observable 作为输出。订阅输出 Observable 同样会订阅输入 Observable。下面实例中，我们创建一个自定义操作符函数，它将输入 Observable 接受的每个值都乘以10</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function multiplyByTen(input) &#123;</span><br><span class="line">    return new Observable(observer =&gt; &#123;</span><br><span class="line">        input.subscribe(&#123;</span><br><span class="line">            next: v =&gt; observer.next(10 * v),</span><br><span class="line">            error: err =&gt; observer.error(err),</span><br><span class="line">            complete: () =&gt; observer.complete(),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const input = from([1, 2, 3, 4]);</span><br><span class="line">const output = multiplyByTen(input);</span><br><span class="line">output.subscribe(x =&gt; console.log(x))</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">10</span><br><span class="line">20</span><br><span class="line">30</span><br><span class="line">40</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>注意，订阅 <code>output</code> 会导致 <code>input</code> Observable 也被订阅。我们称之为“操作符订阅链”。</p><h3 id="实例操作符-vs-静态操作符"><a href="#实例操作符-vs-静态操作符" class="headerlink" title="实例操作符 vs. 静态操作符"></a>实例操作符 vs. 静态操作符</h3><p>通常提到的操作符是实例操作符，是 Observable 实例上的方法，如果上面的 <code>multiplyByTen</code>是官方提供的实例操作符，看起来大概是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.prototype.multiplyByTen = function multiplyByTen() &#123;</span><br><span class="line">  const input = this;</span><br><span class="line">  return Rx.Observable.create(function subscribe(observer) &#123;</span><br><span class="line">    input.subscribe(&#123;</span><br><span class="line">      next: (v) =&gt; observer.next(10 * v),</span><br><span class="line">      error: (err) =&gt; observer.error(err),</span><br><span class="line">      complete: () =&gt; observer.complete()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实例运算是使用 this 关键字来指代输入的 Observable 函数</p></blockquote><p>注意，这里的 <code>input</code> Observable 不再是一个函数参数，它现在是 <code>this</code> 对象。下面是我们如何使用这样的实例运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const observable = from([1, 2, 3, 4]).multiplyByTen();</span><br><span class="line">observable.subscribe(x =&gt; console.log(x));</span><br></pre></td></tr></table></figure><p>而静态操作符是直接附加到 Observable类上的。静态操作符在内部不使用 this关键字，而是完全依赖于它的参数</p><blockquote><p>静态操作符是附加到 Observable 类上的纯函数，通常用来从头开始创建 Observable</p></blockquote><p>最常见的 静态操作符是所谓的创建操作符，它们只接收非 Observable参数，比如数字，然后创建一个新的Observable，而不是将一个输入 Observable转换为输出 Observable</p><p>一个典型的静态操作符例子就是 interval函数，它接收一个数字非Observable作为参数，并生产一个 Observable作为输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const observable = interval(1000);</span><br></pre></td></tr></table></figure><p>然而，有些静态操作符可能不同于简单的创建。一些<strong>组合操作符</strong>可能是静态的，比如 <code>merge</code>、<code>combineLatest</code>、<code>concat</code>，等等。这些作为静态运算符是有道理的，因为它们将<strong>多个</strong> Observables 作为输入，而不仅仅是一个，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const &#123; interval, merge &#125; = require(&apos;rxjs&apos;);</span><br><span class="line"></span><br><span class="line">const observable1 = interval(1000);</span><br><span class="line">const observable2 = interval(400);</span><br><span class="line">const merged = merge(observable1, observable2);</span><br></pre></td></tr></table></figure><h3 id="操作符分类"><a href="#操作符分类" class="headerlink" title="操作符分类"></a>操作符分类</h3><p>可分类：创建、转换、过滤、组合、错误处理、工具等等。</p><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><ul><li>ajax</li><li>bindCallback</li><li>bindNodeCallback</li><li>defer</li><li>empty</li><li>from</li><li>fromEvent</li><li>fromEventPattern</li><li>generate</li><li>interval</li><li>of</li><li>range</li><li>throwError</li><li>timer</li><li>iif</li></ul><h4 id="合并组合"><a href="#合并组合" class="headerlink" title="合并组合"></a>合并组合</h4><ul><li>combineLasted</li><li>concact</li><li>forkJoin</li><li>merge</li><li>race</li><li>zip</li><li>combineAll</li><li>concatAll</li><li>exhaust</li><li>mergeAll</li><li>startWith</li><li>withLastestFrom</li></ul><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><ul><li>buffer</li><li>bufferCount</li><li>bufferTime</li><li>bufferToggle</li><li>bufferWhen</li><li>concatMap</li><li>concatMapTo</li><li>exhaust</li><li>exhaustMap</li><li>expand</li><li>groupBy</li><li>map</li><li>mapTo</li><li>mergeMap</li><li>mergeMapTo</li><li>mergeScan</li><li>pairwise</li><li>partition</li><li>pluck</li><li>scan</li><li>switchMap</li><li>switchMapTo</li><li>window</li><li>windowCount</li><li>windowTime</li><li>windowToggle</li><li>windowWhen</li></ul><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><ul><li>audit</li><li>auditTime</li><li>debounce</li><li>debounceTime</li><li>distinct</li><li>distinctKey</li><li>distinctUnitlChanged</li><li>distinctUnitKeyChanged</li><li>elementAt</li><li>filter</li><li>first</li><li>ignoreElements</li><li>last</li><li>sample</li><li>sampleTime</li><li>single</li><li>skip</li><li>skipLast</li><li>skipUntil</li><li>take</li><li>takeLast</li><li>takeUnit</li><li>takeWhile</li><li>throttle</li><li>throttleTime</li></ul><h4 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h4><ul><li>multicast</li><li>publish</li><li>publishBehaivior</li><li>publishLast</li><li>pulishReplay</li><li>share</li></ul><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><ul><li>catchError</li><li>retry</li><li>retryWhen</li></ul><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><ul><li>tap</li><li>delay</li><li>delayWhen</li><li>dematerizlize</li><li>materialize</li><li>observeOn</li><li>subscribeOn</li><li>timeInterval</li><li>timestamp</li><li>timeout</li><li>timeoutWith</li><li>toArray</li></ul><h4 id="条件与布尔"><a href="#条件与布尔" class="headerlink" title="条件与布尔"></a>条件与布尔</h4><ul><li>defaultIfEmpty</li><li>every</li><li>find</li><li>findIndex</li><li>isEmpty</li></ul><h4 id="数字和聚合"><a href="#数字和聚合" class="headerlink" title="数字和聚合"></a>数字和聚合</h4><ul><li>count</li><li>max</li><li>min</li><li>reduce</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习抄录加强记忆…&lt;/p&gt;
&lt;h1 id=&quot;RxJS&quot;&gt;&lt;a href=&quot;#RxJS&quot; class=&quot;headerlink&quot; title=&quot;RxJS&quot;&gt;&lt;/a&gt;RxJS&lt;/h1&gt;&lt;h2 id=&quot;入门&quot;&gt;&lt;a href=&quot;#入门&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="RxJS" scheme="http://laibh.top/categories/RxJS/"/>
    
    
      <category term="RxJS" scheme="http://laibh.top/tags/RxJS/"/>
    
  </entry>
  
  <entry>
    <title>oauth2 nodejs实战</title>
    <link href="http://laibh.top/2020-07-17-oauth2%20nodejs%E5%AE%9E%E6%88%98.html"/>
    <id>http://laibh.top/2020-07-17-oauth2 nodejs实战.html</id>
    <published>2020-07-17T03:17:40.000Z</published>
    <updated>2022-03-04T10:00:38.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="oauth2-nodejs实战"><a href="#oauth2-nodejs实战" class="headerlink" title="oauth2 nodejs实战"></a>oauth2 nodejs实战</h1><h2 id="第一章：OAuth2-0是什么"><a href="#第一章：OAuth2-0是什么" class="headerlink" title="第一章：OAuth2.0是什么"></a>第一章：OAuth2.0是什么</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>OAuth2.0是一个授权协议，允许软件应用代表资源拥有者去访问资源拥有者的资源。应用向资源拥有者请求授权，然后取得令牌token并用它来访问资源。这一切都不需要应用去充当资源拥有者的身份，因为令牌明确表示了被授予的访问权，限制客户端只能执行资源拥有者授权的操作，或者OAuth2.0是一个安全协议，能让第三方应用以有限的权限访问HTTP服务，可以通过构建资源拥有者与HTTP服务间的许可交互机制，让第三方应用代表资源拥有者访问服务，或者通过授权权限给第三方应用，让其代表自己访问服务。</p><p>作为一个授权框架，OAuth关注的是如何让一个系统组件获取对另一个系统㢟的访问权限，最常见的情形是客户端应用代表资源拥有者（通常是最终用户）访问受保护资源。三个角色：</p><ul><li><p>资源拥有者有权访问API,并将API访问权限委托出去。资源拥有者一般是能够使用浏览器的人</p></li><li><p>受保护资源是资源拥有者有限权限访问的组件。这样的组件有多种形式，一般是某种形式的Web API，资源听起来像是某种能下载的东西，但其实这些API支持读、写和其他操作。</p></li><li><p>客户端是代表资源拥有者访问受保护资源的软件。在OAuth中，只要软件使用了受保护的资源的API,就是客户端。</p></li></ul><p>例子：假设度假拍的照片上传到了照片存储网站，现在想将它们打印出来。照片存储网络的API就是资源，打印服务则是那个API的客户端。作为资源拥有者，需要将一部分权利委托给照片打印服务，让它能读取照片。但你不想让打印服务读取所有照片也不想它有删除或者上传的权限。</p><h3 id="旧时代：凭证共享与凭证盗用"><a href="#旧时代：凭证共享与凭证盗用" class="headerlink" title="旧时代：凭证共享与凭证盗用"></a>旧时代：凭证共享与凭证盗用</h3><h4 id="复制凭证"><a href="#复制凭证" class="headerlink" title="复制凭证"></a>复制凭证</h4><p>之前流行的做法是复制用户的凭证并用它登录另一个服务。就是照片打印服务假设用户在照片存储服务商使用的凭证与在打印服务上的相同。当用户登录照片打印服务后，该服务使用用户的用户名和密码登录照片存储网络，获取用户的账号访问权，假装用户。</p><p>这种情况下，用户需要使用某种凭证与客户端进行身份认证，这些凭证通常是被集中控制的，并受客户端和受保护资源一致认可。客户端先得到用户的用户名和密码或者会话cookie，然后用它们访问受保护资源，假装是用户。受保护资源将客户端视为用户并直接通过身份认证，而实际上与受保护资源建立连接的是客户端。</p><p>这种方法要求用户在客户端和受保护资源端使用相同的凭据，使得这种凭据盗用技术只能在同一安全域内使用。也就是说，如果是一个公司控制着客户端、授权服务器和受保护资源，并且这些组件都使用相同的策略和网络控制下运作，这种方法才行得通。如果打印服务和存储服务是由同一个公司提供的，就能采用这种方法，因为用户可以在两个服务使用相同的账户凭据。</p><p>这一技术还会将用户的密码暴露给客户端应用，即使在单一安全域使用同一组凭据，这也基本上无法避免。但无论如何，客户端是在扮演用户，受保护资源无法区分资源拥有者和扮演资源拥有者的客户端，因此两者都用相同的用户名和密码。</p><h4 id="索取并复制密码"><a href="#索取并复制密码" class="headerlink" title="索取并复制密码"></a>索取并复制密码</h4><p>如果两个服务处于不同的安全域中，如照片打印例子中的情况，不能复制用户提供的用于登录当前应用的密码了，因为这个密码对于另一个应用来说是无效的。对于这个问题可以采取另一种老套的手段来获取密码：向用户索取。</p><p>打印服务想要获取用户的照片，可以提示用户输入照片存储网络上的用户名和密码，打印服务用这些凭据访问受保护资源，扮演用户。在这种情况下，用户用于登录客户端的凭据和用于访问受保护资源的凭据可以不同。很多用户在实际中会运行这样的要求，特别是当使用受保护资源的是一个很有用的服务时。</p><p>因此这仍然是当前移动应用通过用户账号访问后端服务的最常见的方法之一：移动应用让用户输入用户名和密码，然后直接将这些凭证通过网络发送给后端API。为了可以持续访问API,客户端应用会保存用户的凭据，以便在必要的时候访问受保护资源，这种做法很危险，一旦任何一个正在使用中的客户端被攻破，这意味着用户在所有系统的账号都被攻破。</p><h4 id="开发者密钥"><a href="#开发者密钥" class="headerlink" title="开发者密钥"></a>开发者密钥</h4><p>复制用户密码并不是一个好方法，如果授予打印服务全局的访问权限，使它能代表由它指定的任何用户并访问存储服务上的所有照片，常见的方式是为客户端颁发一个开发者密钥，让客户端使用该密钥直接调用受保护资源。</p><p>开发者密钥是一种全局的密钥，客户端可以用它来充当任意一个由其指定的用户，用户的指定很可能通过一个API参数来完成。这样做的好处是避免了向客户端暴露用户凭据，但代价是要向客户端提供功能强大的开发者密钥。有了这种密钥，打印服务随时都能任意地打印所有用户的所有照片，因此它实际上拥有了自由访问受保护资源的权利。这在一定程度上是可行，但前提是受保护资源充分了解并信任客户端。但是这样的关系几乎不可能存在于两个组织之间，例如照片打印例子中的两个服务。此外，如果客户端的密钥被盗，将对受保护资源造成灾难性损害，因为存储服务的所有用户都将受到影响，无论他们是否使用打印服务。</p><h4 id="特殊密码"><a href="#特殊密码" class="headerlink" title="特殊密码"></a>特殊密码</h4><p>给用户一个特殊密码，此密码仅用于透露给第三方服务。用户自己不会使用这个密码来登录，只是将它粘贴到所使用的第三方应用里。用户不再需要想客户端透露登录密码，受保护资源也不在需要相信客户端都能代表所有用户执行正确的操作。但是这种系统的可用性不好。要求用户除了管理自己的主密码之外，还要创建、分发、管理特殊凭据。因为需要用户来管理这些凭据，一般来说，客户端与凭据本身并没有对应关系，这使得撤销某个应用的访问权限变得很困难。</p><h4 id="更好的方法"><a href="#更好的方法" class="headerlink" title="更好的方法"></a>更好的方法</h4><p>如果能为每个客户端和每个用户的组合分别颁发这种受保护资源具有受限访问的凭据，就可以将受限访问分别与受限凭据绑定。如果有一个基于网络的协议，能够部署到整个互联网上，跨安全边界地生成安全分发这些首先呢的凭据，同时具有良好的用户体验。</p><h3 id="授权访问"><a href="#授权访问" class="headerlink" title="授权访问"></a>授权访问</h3><p>OAuth协议的设计目的是：让最终用户通过OAuth将他们在受保护资源上的部分权限委托给客户端应用，使客户端应用代表他们执行操作。为实现这一点，OAuth在系统中引入了另外一个组件：授权服务器。</p><p>受保护资源依赖授权服务器向客户端颁发专用的安全凭据——OAuth访问令牌。为了获取令牌，客户端首先将资源拥有者引导至授权服务器，请求资源拥有者为其授权。授权服务器先对资源拥有者进行身份认证，然后一般会让资源拥有者选择是否对客户端授权。客户端可以请求授权功能或权限范围的子集，该子集可能会被资源拥有者进一步缩小。一旦授权请求被许可，客户端就可以向授权服务器请求访问令牌。按照资源拥有者的许可，客户端可以使用该令牌对受保护资源上的API进行访问。</p><p>在这个过程中，没有讲资源拥有者的凭据暴露给客户端：资源拥有者向授权服务器进去身份认证的过程中所用的信息是独立于客户端交互的。客户端没有功能强大的开发者密钥，无法随意访问任何资源，而是必须在得到有效的资源拥有者的授权之后才能访问受保护资源。虽然大多数OAuth客户端可以向授权服务器进行身份认证，但仍然需要得到授权后才能访问资源。</p><p>用户通常不必查看或者直接处理访问令牌，OAuth不需要由用户生成令牌并粘贴到客户端，而是简化了这一过程：客户端请求令牌，用户对客户端授权，然后由客户端管理令牌，用户管理客户端应用。</p><h4 id="超越HTTP基本认证协议和密码共享反模式"><a href="#超越HTTP基本认证协议和密码共享反模式" class="headerlink" title="超越HTTP基本认证协议和密码共享反模式"></a>超越HTTP基本认证协议和密码共享反模式</h4><p>上面很多传统方法都是密码反模式的案例，通过共享机密信息（密码）来直接代表当事方（用户）。用户通过与应用共享密码，使应用能够访问受保护的API，然而这种方式非常不安全。</p><p>HTTP API最开始是如何引入密码保护功能的呢？可以从 HTTP 协议的历史及其安全手段入手，HTTP 协议制定了一个机制，用户可以凭借该机制在浏览器中使用用户名和密码向一个网页进行身份认证，这就是所谓的 HTTP 基本认证协议 （HTTP basic auth）。还有一种更安全的认证协议，叫做 HTTP 摘要认证（HTTP digest auth）。它们都假设用户在场，并且要求 HTTP 服务器呈现用户的用户名和密码，此外由于 HTTP 是一个无状态的协议，因此每一个 HTTP 事务都要呈现这些凭据。</p><p>HTTP不会区分一个事务是由用户通过浏览器发起的，还是通过其他软件发起的，这种基本的灵活性是HTTP协议得到普及的关键原因。这样有一个问题是除了面向用户的网页或服务之外，当 HTTP 用于直接访问 API时，现有的安全机制顺理成章被沿用到新的应用场景，为API和网页服务不断呈现 密码。虽然浏览器可以使用cookie技术或其他会话管理技术，但是访问Web API的HTTP客户端没有这样的机制可用。</p><p>OAuth从一开始就被设计成一个可用的API协议，其中主要的交互过程都是在浏览器之外进行的。OAuth的整个流程通常是由最终用户在浏览器中启动的，实际上这也正是委托模式的灵活性和优势所在。但是最终接收令牌、使用令牌访问受保护资源的步骤对用户是不可见的。实际上，OAuth的一些主要事务过程都是发生在用户不在场的情况下，客户端仍然能够代表用户执行操作。OAuth让我们摒弃HTTP基本协议中的观念和假设，将一种功能强大、安全的方式引入现如今的API体系</p><h4 id="授权委托：重要性及应用"><a href="#授权委托：重要性及应用" class="headerlink" title="授权委托：重要性及应用"></a>授权委托：重要性及应用</h4><p>委托概念是OAuth强大功能的根基，虽然OAuth经常被称作授权协议，但它也是一个委托协议。通常，被委托的是用户权限的子集，但是OAuth本身并不承载或者传递权限。相反，它提供一种方法，让客户端可以请求用户将部分权限委托给自己，然后用户可以批准这个委托请求，被批准后，客户端就可以去执行那些操作了。</p><p>以照片打印为例子，照片打印服务可以询问用户：是否在这个存储服务存放了照片？如果是我可以帮打印出来。然后用户被引导至照片存储服务，存储服务也会问：打印服务想要获取照片，同意吗？用户可以决定是否同意，即决定是否将访问权限委托给打印服务。</p><p>委托协议和授权协议的区别很重要，因为OAuth令牌中携带的授权信息对系统中的大部分组件是不透明的。只有受保护资源需要了解授权信息，只要它能从令牌得知授权信息（既可以直接从令牌中获取，也可以通过某种服务来获取），就可以按照要求提供API服务</p><h4 id="用户主导的安全与用户的选择"><a href="#用户主导的安全与用户的选择" class="headerlink" title="用户主导的安全与用户的选择"></a>用户主导的安全与用户的选择</h4><p>由于OAuth的委托过程需要资源拥有者的参与，因此它提供了一种在很多其他安全模型中不存在的可能性：重要的安全决策可以由最终用户来做。传统上，安全决策一直由集权机构负责。由集权机构决定谁可以使用服务、使用什么客户端以及以何种目的使用。OAuth则允许集权机构将某些决策权交到最终使用软件的用户手中。</p><p>OAuth系统常遵循TOFU原则：首次使用时信任（trust on first use）。在TOFU模型中，需要用户在第一次运行时进行安全决策，而且并不为安全决策预设任何先决条件或者配置，仅提示用户做出决策。这个过程可以简单到只是询问用户“要连接新的应用吗”。很多实现运行在这个步骤中进行更多控制。无论用户遇到的是哪种情况，只要具有对应的权限，就能做出安全决策。系统会记住用户的决策，以便以后使用。只要首次建立了授权关系，系统就会在后续的处理过程中继续信任用户的决策：首次使用时信任。</p><h3 id="OAuth2-0：优点、缺点和丑陋方面"><a href="#OAuth2-0：优点、缺点和丑陋方面" class="headerlink" title="OAuth2.0：优点、缺点和丑陋方面"></a>OAuth2.0：优点、缺点和丑陋方面</h3><p>OAuth2.0非常善于获取用户的委托决策，并通过网络传递出去。运行多方参与安全决策过程，尤其是在运行期间让最终用户参与决策。由多个可移动的组件构成的协议，但是在很多方面都比其他方案更简单、更安全。</p><p>OAuth2.0设计中有一个重要的阶段，就是不受控的客户端总是比授权服务器或者受保护资源多出好几个数量级。因为单个授权服务器可以很轻松地保护多个资源服务器，并且很可能有许多不同类型的客户端想要访问特定的API。一台授权服务器甚至可以有多个不同的客户端信任等级。这样的架构决策导致的结果就是， 尽可能将复杂性从客户端转移到服务端。这对于客户端开发人员来说是好事，因为客户端成了系统最简单的部分。客户端人员不再需要像在先前的安全协议中，处理签名规范化以及解析复杂的安全策略文档，也不需要担心处理敏感的用户凭据。OAuth令牌提供了一种比密码略复杂的机制，如果使用得当，其安全性比密码高很多。</p><p>另一方面，授权服务和受保护资源要承担更多复杂性和安全性方面的责任。客户端只要保护好自身的客户端凭据和用户的令牌即可，单个客户端被攻破会造成损害，但只有该客户端的用户会受到影响。被攻破的客户端也不会泄露资源拥有者的凭据，因此客户端根本没有机会接触这些凭据。然而，授权服务器则需要管理和保护系统中所有客户端和用户的凭证和令牌。虽然这确实使它更容易称为攻击目标，但是保护单个授权服务器要比保护上千台由不同开发人员开发的客户端容易得多。</p><p>OAuth2.0的可拓展性和模块化是其最大的优势之一，因为这使得该协议适用于各种环境。然而正是这种灵活性导致不同的实现之间存在基本的兼容性问题。当开发人员想在不同的系统上实现OAuth时，它提供的众多自定义选项更让人困惑。</p><h3 id="OAuth2-0不能做什么"><a href="#OAuth2-0不能做什么" class="headerlink" title="OAuth2.0不能做什么"></a>OAuth2.0不能做什么</h3><h4 id="没有定义HTTP协议之外的情形"><a href="#没有定义HTTP协议之外的情形" class="headerlink" title="没有定义HTTP协议之外的情形"></a>没有定义HTTP协议之外的情形</h4><p>由于使用bearer令牌的OAuth2.0并不提供消息签名，因此不应该脱离HTTPS使用。机密信息需要在网络上传播，所以OAuth需要TLS这样的传输机制来保护这些信息。</p><h4 id="不是身份认证协议"><a href="#不是身份认证协议" class="headerlink" title="不是身份认证协议"></a>不是身份认证协议</h4><p>OAuth本身并不透露关于用户的信息，本质上是一个部件，能用于在更宏大的技术方案中提供其他功能，另外OAuth 在多个地方用到了身份认证，最典型的就是资源拥有者和客户端软件要向授权服务器进行身份认证。但这种内嵌身份认证的行为并不会使OAuth自身成为身份认证协议</p><h4 id="没有定义用户对用户的授权机制"><a href="#没有定义用户对用户的授权机制" class="headerlink" title="没有定义用户对用户的授权机制"></a>没有定义用户对用户的授权机制</h4><p>尽管它在根本上是一个用户向软件授权的协议。OAuth假设资源拥有者能够控制客户端。要使资源拥有者向另一个用户授权，仅适用OAuth是不行的。但这种授权并不罕见，User Managed Access协议就是为此而生，规定了如何使用OAuth 构建一个支持用户对用户授权的系统。</p><h4 id="没有定义授权处理机制"><a href="#没有定义授权处理机制" class="headerlink" title="没有定义授权处理机制"></a>没有定义授权处理机制</h4><p>提供了一种传达授权委托已发生这一事实，但是它并不定义授权的内容。相反，由服务API定义使用权限范围、令牌之类的OAuth组件来定义一个给定的令牌适用于哪些操作</p><h4 id="没有定义令牌格式"><a href="#没有定义令牌格式" class="headerlink" title="没有定义令牌格式"></a>没有定义令牌格式</h4><p>明确声明了令牌的内容对客户端是完全不透明的。颁发令牌的授权服务器和接收令牌的受保护资源需要理解令牌。这个层面的互操作性要求催发了 JSON Web Token(JWT)格式和令牌内省协议。虽然令牌本身对客户端还是不透明的，但现在它的格式能被其他组件理解。</p><h4 id="没有定义加密方法"><a href="#没有定义加密方法" class="headerlink" title="没有定义加密方法"></a>没有定义加密方法</h4><p>没有新的加密机制，而是允许借用通用的加密机制，这些加密机制不止适用于OAuth。这种有意的遗漏催生了JSON对象签名和加密（JOSE）规范套件，该套件提供了一系列通用的加密机制，可以配合OAuth使用，也可以脱离OAuth使用。</p><h4 id="不是单体协议"><a href="#不是单体协议" class="headerlink" title="不是单体协议"></a>不是单体协议</h4><p>规范被分成了多个定义和流程，每个定义和流程都有各自适用的场景。在某种程度上，可以将OAuth2.0视为一个安全协议生成器，因为它可用于许多不同的应用场景设计安全架构。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>OAuth是一个应用广泛的安全标准，提供了一种安全访问受保护资源的方式，特别适用于Web API</p><ul><li>关注的是如何获取令牌和如何使用令牌</li><li>是一个委托协议，提供跨系统授权的方案</li><li>用可用性和安全性更高的委托协议取代了密码共享反模式</li><li>专注于很好地解决小问题集，因而是整个安全系统中一颗很合用的螺丝钉</li></ul><h2 id="第二章：协议与组件"><a href="#第二章：协议与组件" class="headerlink" title="第二章：协议与组件"></a>第二章：协议与组件</h2><h3 id="获取和使用令牌"><a href="#获取和使用令牌" class="headerlink" title="获取和使用令牌"></a>获取和使用令牌</h3><p>OAuth是一个复杂的安全协议，需要不同的组件互相通信，从根本上说，OAuth事务中的两个重要步骤是颁发令牌和使用令牌。令牌表示授予客户端的访问权，在OAuth2的各个部分都起到了核心作用。尽管每个步骤的细节都会因多种因素而异，但是一个规范的OAuth事务包含以下事件</p><ol><li>资源拥有者向客户端表示他希望客户端代表他执行一些任务</li><li>客户端在授权服务器上向资源拥有者请求授权</li><li>资源拥有者许可客户端的授权请求</li><li>客户端接收到来自授权服务器的令牌</li><li>客户端向受保护的资源出示令牌</li></ol><h3 id="授权许可的完整过程"><a href="#授权许可的完整过程" class="headerlink" title="授权许可的完整过程"></a>授权许可的完整过程</h3><p>首先，资源拥有者访问客户端应用，并表明他希望客户端代表自己去使用某一受保护资源。例如，用户会在这一步示意打印服务去使用某个照片存储服务。该服务是个API,客户端知道如何调用它，并且还知道需要通过OAuth来调用。</p><p>当客户端发现需要获取一个新的OAuth访问令牌时，它会将资源拥有者重定向至授权服务器，并附带一个授权请求，表示它要向资源拥有者请求一些权限。例如，为了能读取照片，照片打印服务可以向照片存储服务请求访问权限。由于是的是Web客户端，因此采用HTTP重定向的方式将用户代理重定向至授权服务器的授权端点，客户端的响应如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">302</span> Moved Temporarily</span><br><span class="line"><span class="attribute">x-powered-by</span>: Express</span><br><span class="line"><span class="attribute">Location</span>: http://localhost:9001/authorize?response_type=code&amp;scope=foo&amp;client_id=oauth-client-1&amp;redirect_uri=http%3A%2F%2Flocalhost%3A9000%2Fcallback&amp;state=Lwt50DDQKUB8U7jtfLQCVGDL9cnmwHH1</span><br><span class="line"><span class="attribute">Vary</span>: Accept</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=utf-8</span><br><span class="line"><span class="attribute">Content-Length</span>: 444</span><br><span class="line"><span class="attribute">Date</span>: Fri, 31 Jul 2015 20:50:19 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br></pre></td></tr></table></figure><p>这个重定向响应导致浏览器向授权服务器发送一个GET请求。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/authorize?response_type=code&amp;scope=foo&amp;client_id=oauth-client-1&amp;redirect_uri=http%3A%2F%2Flocalhost%3A9000%2Fcallback&amp;state=Lwt50DDQKUB8U7jtfLQCVGDL9cnmwHH1</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: localhost:9001</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:39.0)Gecko/20100101 Firefox/39.0</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Referer</span>: http://localhost:9000/</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br></pre></td></tr></table></figure><p>客户端通过在发送给用户的URL中包含参数，来标识自己的身份和要请求的授权详情，如权限范围等。虽然请求并不是由客户端直接发出的，但授权服务器会解析这些参数并做出适当反应。</p><p>然后授权服务器会要求用户进行身份认证，进一步对确认资源拥有者的身份以及能向客户端授予哪些权限来说至关重要。</p><p>用户身份认证直接在用户（和用户浏览器）与授权服务器之间进行，这个过程对客户端应用不可见。这一重要特性避免了用户将自己的凭据透露给客户端应用，对抗这种反模式发明OAuth的原因。</p><p>另外因为资源拥有者通过浏览器与授权端点交互，所有也要通过浏览器来完成身份认证，因此，有很多身份认证技术可以用于用户身份认证流程。OAuth没有规定应该使用哪种身份认证技术，授权服务器可以自由选择，例如用户名/密码、加密证书、安全令牌、联合单点登录或者其他方式。</p><p>这种隔离方案还得客户端不会因用户身份认证方式发生变化而受到影响，让简答的客户端应用也能受益于授权服务器使用的一些新兴技术，例如基于风险的启发式认证（risk-based heuristic authentication）技术。然而这种做法并没有向客户端传递任何有关认证用户的信息。</p><p>然后用户向客户端应用授权，这一步，资源拥有者选择将一部分权限授予客户端应用，授权服务器提供了很多不同的选项来实现这一点。客户端可以在授权请求中指明其想要获得哪些权限。授权服务器可以运行用户拒绝一部分或者全部权限范围，也可以让用户批准或者拒绝整个授权请求。</p><p>此外，很多授权服务器允许将授权决策保存下来，以便以后使用。如果使用了这种方式，那么未来同一个客户端请求同样的授权时，用户将不会得到提示。用户仍然会被重定向到授权端点，并且仍然需要登录，但是会跳过批准授权环节而沿用前一次的授权决策。授权服务器甚至可以通过像客户端白名单或者黑名单这样的内部策略来否决用户的决策。</p><p>然后，授权服务器将用户重定向到客户端应用。这一步采用HTTP重定向的方式，回到客户端的 redirect_uro</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP 302 Found</span><br><span class="line"><span class="attribute">Location</span>: http://localhost:9000/oauth_callback?code=8V1pr0rJ&amp;state=Lwt50DDQKUB8U7jtfLQCVGDL9cnmwHH1</span><br></pre></td></tr></table></figure><p>这又导致浏览器向客户端发送如下请求</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /callback?code=8V1pr0rJ&amp;state=Lwt50DDQKUB8U7jtfLQCVGDL9cnmwHH1</span><br><span class="line">HTTP/1.1 Host: localhost:9000</span><br></pre></td></tr></table></figure><p>这个HTTP请求是发送给客户端不是给授权服务器的</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:39.0)Gecko/20100101 Firefox/39.0</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Referer</span>: http://localhost:9001/authorize?response_type=code&amp;scope=foo&amp;client_id=oauth-client-1&amp;redirect_uri=http%3A%2F%2Flocalhost%3A9000%2Fcallback&amp;state=Lwt50DDQKUB8U7jtfLQCVGDL9cnmwHH1</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br></pre></td></tr></table></figure><p>由于使用的是授权码许可类型，因此该重定向链接中包含了一个特殊的查询参数code，这个参数的值被解析为授权码，它是一次性的凭据，表示用户授权决策的结果。客户端会在接收到请求之后解析该参数以获取授权码，并在下一次使用授权码。客户端还会检查state参数值是否与它在前一个步骤中发送的值匹配。</p><p>现在客户端已经得到授权码，将其发送给授权服务器的令牌端点。客户端发送一个POST请求，在HTTP主体中以表单的格式传递参数，并在HTTP基本认证头部设置<code>client_id</code>和<code>client_secret</code>。这个HTTP请求由客户端直接发送给授权服务器，浏览器或者资源拥有者不参与此过程。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /token</span><br><span class="line"><span class="attribute">Host</span>: localhost:9001</span><br><span class="line"><span class="attribute">Accept</span>: application/json</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-encoded</span><br><span class="line"><span class="attribute">Authorization</span>: Basic b2F1dGgtY2xpZW50LTE6b2F1dGgtY2xpZW50LXNlY3JldC0x grant_type=authorization_code&amp;redirect_uri=http%3A%2F%2Flocalhost%3A9000%2Fcallback&amp;code=8V1pr0rJ</span><br></pre></td></tr></table></figure><p>这种将不同的HTTP连接分开的做法保证了客户端能够直接进行身份认证，让其他组件无法查看或操作令牌请求。</p><p>授权服务器接收该请求，如果请求有效，则办法令牌。授权服务器需要执行多个步骤以确保请求是合法的。首先，它需要验证客户端凭据（通过Authorization头部传递）以确定是哪个客户端请求授权。然后，从请求主体中读取code参数的值，并从中读取关于该授权码的信息，包括发起初始授权请求的是哪个客户端，执行授权的是哪个用户，授权的内容是什么。如果授权码有效尚未使用过，而且发起该请求的客户端与最初发起授权请求的客户端相同，则授权服务器会生成一个新的访问令牌并返回到客户端。</p><p>该令牌以JSON对象的格式通过HTTP响应返回给客户端</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP 200 OK</span><br><span class="line"><span class="attribute">Date</span>: Fri, 31 Jul 2016 21:32:32 GMT</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">"access_token": "987tghjkiu6trfghjuytrghj",</span><br><span class="line">"token_type": "Bearer"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后客户端可以解析令牌响应并从中获取令牌的值来访问受保护资源。在这个案例，使用了 OAuth bearer令牌，这是通过响应中的 token_type字段描述的。令牌响应还可以包含一个刷新令牌（用于获取新的访问令牌而不必重新请求授权），以及一些关于访问令牌的附加信息，比如令牌的权限访问和过期时间。客户端可以将访问令牌存储在一个安全的地方，以便以后在用户不在场的时候也能够随时访问。</p><p>有了令牌，客户端就可以在访问受保护资源时出示令牌。客户端出示的令牌的方式有很多种，备受推崇的方式，使用Authorization头部</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/resource</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: localhost:9002</span><br><span class="line"><span class="attribute">Accept</span>: application/json</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Authorization</span>: Bearer 987tghjkiu6trfghjuytrghj</span><br></pre></td></tr></table></figure><p>受保护资源可以从头部解析出令牌，判断它是否有效，从中得知授权者是谁以及授权内容，然后返回响应。受保护资源检查令牌的方式有很多种，最简单的就是让授权服务器和资源服务器共享存储令牌信息的数据库。授权服务器在生成新的令牌时将其写入数据库，资源服务器在收到令牌时从数据库中读取它们。</p><h3 id="OAuth中的角色：客户端、授权服务器、资源拥有者、受保护资源"><a href="#OAuth中的角色：客户端、授权服务器、资源拥有者、受保护资源" class="headerlink" title="OAuth中的角色：客户端、授权服务器、资源拥有者、受保护资源"></a>OAuth中的角色：客户端、授权服务器、资源拥有者、受保护资源</h3><p>这些组件分别负责OAuth协议的不同部分，并且相互协作使OAuth协议运转。</p><p>客户端：是代表资源拥有者访问受保护资源的软件，使用OAuth来获取访问权限，客户端通常是这系统中最简单的组件，它的职责主要是从授权服务器获取令牌以及在受保护资源上使用令牌。客户端不需要理解令牌，也不需要查看令牌的内容。相反，客户端只需要将令牌视为一个不透明的字符串即可。OAuth客户端可以是Web应用、原生应用，甚至是浏览器内的JavaScript应用。</p><p>受保护资源：通过HTTP服务进行访问，在访问时需要OAuth访问令牌，受保护资源需要验证收到的令牌，并决定是否响应以及如何响应请求，在OAuth架构中，受保护资源对是否认可令牌拥有最终决定权。在云打印的例子里面，照片存储网站就是属于受保护资源。</p><p>资源拥有者：有权将访问权限授权给客户端的主体，与OAuth系统中的其他组件不同，资源拥有者不是软件，在大多数情况下，资源拥有者是一个人，使用客户端软件访问受他控制的资源。至少在部分过程中，资源拥有者要使用Web浏览器（通常称为用户代理）与授权服务器交互。资源拥有者可能还会使用浏览器与客户端交互，但这完全取决于客户端性质。在云打印例子中，资源拥有者就是想要打印照片的最终用户。</p><p>OAuth授权服务器：是一个HTTP服务器，在OAuth系统中充当中央组件。授权服务器对资源拥有者和客户端进行身份认证，让资源拥有者向客户端授权、为客户端颁发令牌。某些授期服务器还会提供额外的功能，例如令牌内省、记忆授权决策。在云打印例子中，照片存储网络拥有自己的授权服务器，用户保护资源。</p><h3 id="OAuth组件：令牌、权限范围和授权许可"><a href="#OAuth组件：令牌、权限范围和授权许可" class="headerlink" title="OAuth组件：令牌、权限范围和授权许可"></a>OAuth组件：令牌、权限范围和授权许可</h3><h4 id="访问令牌"><a href="#访问令牌" class="headerlink" title="访问令牌"></a>访问令牌</h4><p>OAuth访问令牌，有时也被称为令牌，由授权服务器办法给客户端，表示客户端已被授予权限。OAuth没有定义令牌本身的格式和内容，但它总是代表着：客户端请求的访问权限、对客户端授予的资源拥有者，以及被授予的权限（通常包含一些受保护资源标志）。</p><p>令牌对客户端来说是不透明的，也就是说客户端不需要，通常也不能查看令牌内容。客户端要做的是持有令牌，向授权服务器请求令牌，并向受保护资源出示令牌。OAuth令牌并非对系统中所有组件都不透明：授权服务器的任务是颁发令牌，受保护资源的任务则是验证令牌。因此，它们都需要理解令牌本身，并知道其含义。然后客户端对这一切一无所知，这使得客户端简单地多，同时也使得授权服务器和受保护资源十分灵活地部署令牌。</p><h4 id="权限范围"><a href="#权限范围" class="headerlink" title="权限范围"></a>权限范围</h4><p>表示一组访问受保护资源的权限，OAuth协议中使用字符串表示权限范围，可以用空格隔开的列表将它们合并成为一个集合。因此，权限范围的值不能包含空格，OAuth并没有规定权限范围值的格式和结构。</p><p>权限范围是一种重要机制，界定了客户端的权限范围。权限范围是由受保护资源根据其自身提供的API来定义的。客户端可以请求某些权限范围，授权服务器则运行资源拥有者在客户端发出请求时许可或者否决特定的权限范围。权限范围具有可叠加的特征。</p><p>云打印的例子，照片存储服务的API为照片定义了多种权限范围：read-photo/read-metadata/update-photo/update-metadata/create/delete。照片打印服务只要能读取照片就足以完成工作，所以它会请求read-photo权限范围。只要拥有一个该权限范围的令牌，就能读取并按要求打印出来。如果用户想要依据照片日期将照片打印成册的高级功能，则打印服务还需要read-metadata权限范围。由于这是一个额外的访问权限，照片打印服务则需要通过正常的OAuth流程来请求用户授予它这个额外的权限范围。只要照片打印服务拥有包含这两个权限范围的令牌，就能使用该令牌执行相应的操作。</p><h4 id="刷新令牌"><a href="#刷新令牌" class="headerlink" title="刷新令牌"></a>刷新令牌</h4><p>OAuth刷新令牌在概念上与该令牌很相似，它也是由授权服务器颁发给客户端的令牌，客户端也不知道不关系该令牌的内容。但不同的是，该令牌从来不会被发送到保护资源。相反，客户端使用刷新令牌向授权服务器请新的访问令牌，而不需要用户参与。</p><p>为什么客户端需要刷新令牌？在OAuth中，访问令牌随时可能失效，令牌有可能被用户撤销，或者过期，或者其他系统导致令牌失效，客户端在使用时会受到错误响应。当然，客户端可以再次向资源拥有者请求权限，但是如果资源拥有者不在场呢？</p><p>在OAuth1.0客户端除了等资源拥有者回来重新授权之外别无他法。未避免这种情况，OAuth1.0的令牌玩玩会一直保持有效，直到被明确地撤销。这是有问题的，因此它增加了被盗令牌的攻击面：攻击者可以永远使用该令牌。OAuth2.0提供了让令牌自动过期的选项，但是需要在用户不在场的时候仍然能访问资源，现在刷洗令牌取代了永不过期的访问令牌，但它的作用不是访问令牌，而是获取新的访问令牌来访问资源。这种做法是一种独立但互补的方式，限制了刷新令牌和访问令牌的暴露范围。</p><p>刷新令牌还可以让客户端缩小它的权限范围，如果客户端被授予A/B/C三个权限范围，但是它知道某特定请求只需要A权限范围，则它可以使用刷新令牌重新获取一个仅包含A权限范围的访问令牌。这让足够智能的API可以遵循最小权限安全原则，但也不会给不那么智能的客户端带来负担，即无须查明某个API需要哪些权限。</p><p>如果刷新令牌失效了，用户在场，客户端可以随时劳烦用户再次授权，换句话说，客户端退回到了需要重新进行OAuth授权的状态。</p><h4 id="授权许可"><a href="#授权许可" class="headerlink" title="授权许可"></a>授权许可</h4><p>授权许可是OAuth协议中的权限获取方法，OAuth客户端用它来获取受保护资源的访问权限，成功之后客户端会得到一个令牌。令牌表示用户授权所使用的特定方式，也表示授权这个行为本身。开发人员看到回传给客户端的授权码，有时候会误认为这个授权码就是授权许可，虽然授权码代表用户的授权决策，但不是授权许可本身。相反，整个OAuth流程才是授权许可：客户端将用户重定向至授权端点，然后接收授权码，最后用授权码换取令牌。</p><p>换句话说，授权许可就是获取令牌的方式。</p><h3 id="OAuth的校色与组件的交互：后端信道、前端信道和端点"><a href="#OAuth的校色与组件的交互：后端信道、前端信道和端点" class="headerlink" title="OAuth的校色与组件的交互：后端信道、前端信道和端点"></a>OAuth的校色与组件的交互：后端信道、前端信道和端点</h3><p>OAuth是一个基于HTTP的协议，但是与大多数基于HTTP的协议不同，OAuth中的交互不总是简单的HTTP请求和响应来完成。</p><h4 id="后端通信信道"><a href="#后端通信信道" class="headerlink" title="后端通信信道"></a>后端通信信道</h4><p>OAuth流程中的很多部分都是用标准的HTTP请求和响应格式来互相通信，由于这些请求通常都发生在资源拥有者和用户代理的可见范围之外，因此它们统称为后端信道通信。</p><p>这些请求和响应使用了所有常规的HTTP机制来通信：头部，查询参数、HTTP方法和HTTP主体都能承载对OAuth事务至关重要的信息。</p><p>授权服务器提供一个授权端点，供客户端请求访问令牌和刷新令牌。客户端直接向该端点发出请求，携带一组表单格式的参数，授权服务器解析并处理这些参数，然后授权服务器返回一个代表令牌的JSON对象</p><p>另外当客户端连接受保护资源的时候，它也是在后端信道上直接发出HTTP请求。这种连接的细节完全依赖受保护资源，因为OAuth能保护的API和系统种类繁多、风格各异。对于任何类型的受保护资源，都需要客户端出示令牌，并且受保护资源必须能理解令牌以及其代表的权限。</p><h4 id="前端信道通信"><a href="#前端信道通信" class="headerlink" title="前端信道通信"></a>前端信道通信</h4><p>在标准HTTP通信中，HTTP客户端向服务器直接发送一个请求，其中包括头部、查询参数、主体以及其他信息。然后HTTP服务器可以查看这些信息，并决定如何响应请求，响应中包含头部、主体以及其他信息。然而，在OAuth中，在某些情况下两个组件是无法至二级相互发送请求和响应的。例如客户端与授权服务器的授权端点交互的时候。前端信道通信就是一种间接通信方法，它将Web浏览器作为媒介，使用HTTP请求实现两个系统间的间接通信。</p><p>这一技术隔离了浏览器两端的会话，实现了跨安全域工作。例如，如果用户需要向其中一个组件进行身份认证，并不需要将凭据暴露给另外一个系统。这样在保持信息隔离的情况下，仍然能让用户在通信中发挥作用。</p><p>两个互不交互的软件是如何实现通信的？前端信道通信是这样实现的：发起方在一个URL中附加参数并指示浏览器跳转到该URL。然后接收方可以解析该入站URL（由浏览器跳转来的），并使用其中包含的信息。之后，接收方可以将浏览器重定向至发起方托管的URL,并使用同样的方式在URL附加参数。这样两个软件就以Web浏览器为媒介，实现了间接通信。这样意味着每个前端信道的请求和响应实际上是一对HTTP请求/响应事务。</p><p>例如，授权码许可中，客户端需要将用户重定向至授权端点，但是也需要将其请求的内容信息传递给授权服务器。为此，客户端向浏览器发送一个HTTP重定向，这个重定向的目标是授权服务器的URL,并且其查询参数中附有特定参数。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP 302 Found</span><br><span class="line"><span class="attribute">Location</span>: http://localhost:9001/authorize?client_id=oauth-client-1&amp;response_type=code&amp;state=843hi43824h42tj</span><br></pre></td></tr></table></figure><p>授权服务器可以像处理一般的HTTP请求一样解析传入的URL,从参数中获取信息，这个环节中，授权服务器可以与资源拥有者进行交互，通过浏览器执行一系列HTTP事务，对资源拥有者进行身份认证并请求其授权。当需要给客户端返回授权码时，授权服务器也向浏览器返回重定向响应，但是这一次重定向的目标是客户端的redirect_uri。授权服务器也会在重定向的查询参数中附带信息。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP 302 Found</span><br><span class="line"><span class="attribute">Location</span>: http://localhost:9000/oauth_callback?code=23ASKBWe4&amp;state=843hi43824h42tj</span><br></pre></td></tr></table></figure><p>浏览器执行这个重定向时，会向客户端应用发送一个HTTP请求，然后客户端可以解析请求中的参数，这样客户端和授权服务器就以浏览器为媒介实现了通信，而不用直接交互。</p><blockquote><p>Web应用和原生应用都可以使用OAuth，但是都需要使用前端信道机制来接收授权端点返回的信息。前端信道通常需要使用到Web浏览器和HTTP重定向，但常规的Web服务器一般是不提供这些支持的。可以用内部Web服务器、应用专有的URI方案、使用后端服务向客户端推送通知等。只要能触发浏览器对该URI的调用即可。</p></blockquote><p>所有通过前端信道传递的信息都可供浏览器访问，既能被读取，也可能在最终请求发出之前被篡改。OAuth协议已经考虑到了这一点，它限制了能通过前端信道传输的信息类别，并确保只要是通过前端信道传输的信息，就不能在授权任务中单独使用。上面的典型案例中，授权码不能被浏览器直接使用，相反它必须通过后端信道与客户端凭据一并出示。这有些协议中，比如OpenID Connect，要求客户端或授权服务器对前端信道中传输的消息签名，通过这样的安全机制增加一层保护。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>虽然OAuth协议包含很多移动组件，但它将一些简单的操作组合起来，形成了一套安全的授权方法。</p><ul><li>OAuth是关于获取令牌和使用令牌的</li><li>OAuth系统中的不同组件各自负责授权流程中的不同环节</li><li>组件使用直接的后端信道和间接的前端信道HTTP链接相互通信</li></ul><h2 id="第三章：构建简单的OAuth客户端"><a href="#第三章：构建简单的OAuth客户端" class="headerlink" title="第三章：构建简单的OAuth客户端"></a>第三章：构建简单的OAuth客户端</h2><p>OAuth协议的焦点在于客户端如何获取令牌，以及如何使用令牌代表资源拥有访问受保护资源。在本章建立一个简单的OAuth客户端，使用授权码许可类型从授权服务器获取bearer令牌，并使用该令牌访问受保护资源。</p><h3 id="向授权服务器注册OAuth客户端"><a href="#向授权服务器注册OAuth客户端" class="headerlink" title="向授权服务器注册OAuth客户端"></a>向授权服务器注册OAuth客户端</h3><p>OAuth客户端和授权服务器需要互相了解才能通信，OAuth协议本身不关心如何实现这一点。OAuth客户端由一个称为“客户端标识符”的特殊字符串来标识。OAuth协议的多个组件被称为<code>client_id</code>，在给定一个授权服务器下，每个客户端的标识必须 唯一，因此，客户端标识几乎总是由授权服务器分配，这种分配可以通过开发者门户来完成，也可以使用动态客户端注册。</p><p>实例使用手动配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.js</span></span><br><span class="line"><span class="comment">// 授权服务器给客户端分配好了标识符以及共享密钥。另外还有redirect_uri、要请求的权限范围集合和其他选项由客户端软件设定</span></span><br><span class="line"><span class="keyword">const</span> client = &#123;</span><br><span class="line">  <span class="string">"client_id"</span>: <span class="string">"oauth-client-1"</span>,</span><br><span class="line">  <span class="string">"client_secret"</span>: <span class="string">"oauth-client-secret-1"</span>,</span><br><span class="line">  <span class="string">"redirect_uris"</span>: [<span class="string">"http://localhost:9000/callback"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 授权端点与令牌端点</span></span><br><span class="line"><span class="keyword">const</span> authServer = &#123;</span><br><span class="line">  authorizationEndpoint: <span class="string">'http://localhost:9001/authorize'</span>,</span><br><span class="line">  tokenEndpoint: <span class="string">'http://localhost:9001/token'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用授权码许可类型获取令牌"><a href="#使用授权码许可类型获取令牌" class="headerlink" title="使用授权码许可类型获取令牌"></a>使用授权码许可类型获取令牌</h3><p>OAuth客户端要从授权服务器获取令牌，需要资源拥有者以某种形式授权。下面使用一种被称为授权许可类型的交互授权形式，由客户端将资源拥有者重定向至授权服务器的授权端点，然后，服务器通过<code>redirect_uri</code>将授权码返回给客户端。最后，客户端将受到的授权码发送到授权服务器的令牌端点，换取OAuth访问令牌，再进行解析和存储。</p><h4 id="发送授权请求"><a href="#发送授权请求" class="headerlink" title="发送授权请求"></a>发送授权请求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; base</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; options</span></span><br><span class="line"><span class="comment"> * @returns &#123;String&#125; 函数接收一个URL基础和一个对象，对象包含所有要添加到URL中的查询参数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> buildUrl = <span class="function">(<span class="params">base, options, hash</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newUrl = url.parse(base, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">delete</span> newUrl.search;</span><br><span class="line">  <span class="keyword">if</span> (!newUrl.query) &#123;</span><br><span class="line">    newUrl.query = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  __.each(options, (value, key, list) =&gt; &#123;</span><br><span class="line">    newUrl.query[key] = value;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (hash) &#123;</span><br><span class="line">    newUrl.hash = hash;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> url.format(newUrl)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/authorize'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> authorizeUrl = buildUrl(authServer.authorizationEndpoint, &#123;</span><br><span class="line">    response_type: <span class="string">'code'</span>,</span><br><span class="line">    client_id: client.client_id,</span><br><span class="line">    redirect_uri: client.redirect_uris[<span class="number">0</span>]</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  res.redirect(authorizeUrl);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="处理授权响应"><a href="#处理授权响应" class="headerlink" title="处理授权响应"></a>处理授权响应</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> encodeClientCredentials = <span class="function">(<span class="params">clientId, clientSecret</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Buffer(querystring.escape(clientId) + <span class="string">':'</span> + querystring.escape(clientSecret).toString(<span class="string">'base64'</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看传入参数，并从code参数中读取授权服务器返回的授权码，授权服务器通过重定向让浏览器向客户端发起请求，而不是直接响应客户端请求</span></span><br><span class="line">app.get(<span class="string">'/callback'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">query</span>: &#123; code &#125; &#125; = req;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> form_data = qs.stringify(&#123;</span><br><span class="line">    grant_type: <span class="string">'authorization_code'</span>,</span><br><span class="line">    code,</span><br><span class="line">    <span class="comment">// 根据OAuth规范，如果在授权请求中重定向了URI，在令牌请求中也</span></span><br><span class="line">    <span class="comment">// 必须包含该URI,可以防止攻击者使用被篡改的重定向URI获取受害人授权码</span></span><br><span class="line">    <span class="comment">// 让并无恶意的客户端将受害用户的资源访问权限关联到攻击者账号</span></span><br><span class="line">    redirect_uri: client.redirect_uris[<span class="number">0</span>]</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// HTTP基本认证,Authorization 头部是一个base64 编码的字符串，编码内容是拼接后的用户名和密码，以冒号隔开。</span></span><br><span class="line">  <span class="comment">// OAuth2.0要求将客户端ID作为用户名，将客户端密钥作为密码，但是用之前应该先对它们进行URL编码</span></span><br><span class="line">  <span class="keyword">const</span> headers = &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">    <span class="string">'Authorization'</span>: <span class="string">`Basic <span class="subst">$&#123;encodeClientCredentials(client.client_id, client.client_secret)&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用POST请求将这些信息传送到服务器的授权端点</span></span><br><span class="line">  <span class="keyword">const</span> tokRes = request(<span class="string">'POST'</span>, authServer.tokenEndpoint, &#123;</span><br><span class="line">    body: form_data,</span><br><span class="line">    headers</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求成功，授权服务器将返回一个包含访问令牌以及其他信息的JSON对象：</span></span><br><span class="line">  <span class="comment">// &#123;"access_token":"987tghjkiu6trfghjuytrghj","token_type":"Bearer"&#125;</span></span><br><span class="line">  <span class="comment">// 应用需要读取结果并解析JSON对象，获取访问令牌，保存起来</span></span><br><span class="line">  <span class="keyword">const</span> body = <span class="built_in">JSON</span>.parse(tokRes.getBody());</span><br><span class="line">  access_token = body.access_token;</span><br><span class="line"></span><br><span class="line">  res.send(<span class="string">'index'</span>, &#123;</span><br><span class="line">    access_token: body.access_token</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="使用state参数添加跨站保护"><a href="#使用state参数添加跨站保护" class="headerlink" title="使用state参数添加跨站保护"></a>使用state参数添加跨站保护</h4><p>每当有人访问 <code>localhost:9000/callback</code>，客户端会接收收到的code值，并试图发送给授权服务器。这意味着攻击者有可能会用客户端向授权服务器暴力搜索有效授权码，浪费客户端和授权服务器资源，而且还有可能导致客户端获取一个从未请求过的令牌</p><p>可以使用名为state的可选OAuth参数缓解这个问题，将该参数设置为一随机值，应在应用中用变量保存，在丢弃旧的访问令牌后，创建一个state值</p><blockquote><p>state = randomstring.generate();</p></blockquote><p>需要将值保存起来，因为当通过回调访问 redirect_uri时，还要用到这个值。由于此阶段使用前端信道通信，因此重定向至授权端点的请求一旦发出，客户端应用就会放弃对OAuth协议流程的控制，直到该回调发生，还需要将state添加到通过授权端点URL发送的参数列表中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> authorizeUrl = buildUrl(authServer.authorizationEndpoint, &#123;</span><br><span class="line">  response_type: <span class="string">'code'</span>,</span><br><span class="line">  client_id: client.client_id,</span><br><span class="line">  redirect_uri: client.redirect_uris[<span class="number">0</span>],</span><br><span class="line">  state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当授权服务器收到一个带有state参数的授权请求时，必须总是该state参数和授权码一起原样返回客户端。意味着可以检查传入 <code>redirect_uri</code>页面的state值，并与之前保存的值对比，如果不一致，则向最终用户提示错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  query: &#123;</span><br><span class="line">    code,</span><br><span class="line">    error,</span><br><span class="line">    state: cbState</span><br><span class="line">  &#125;</span><br><span class="line">&#125; = req;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">  res.render(<span class="string">'error'</span>, &#123; error &#125;)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cbState !== state) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`State DOES NOT MATCH: expected <span class="subst">$&#123;cbState&#125;</span> got <span class="subst">$&#123;state&#125;</span>`</span>)</span><br><span class="line">  res.render(<span class="string">'error'</span>, &#123; <span class="attr">error</span>: <span class="string">'State value did not match'</span> &#125;)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果state与所期望的值不一样，可能是会话固化攻击、授权码暴力搜索或者其他恶意行为。此时客户端会终止所有授权去请求处理，并向用户展示错误页面</p><h3 id="使用令牌访问受保护资源"><a href="#使用令牌访问受保护资源" class="headerlink" title="使用令牌访问受保护资源"></a>使用令牌访问受保护资源</h3><p>受保护资源接收到有效的令牌后，会返回一些有用信息。客户端要做的就是使用令牌向保护资源发出调用请求，有3个合法的位置可用于携带令牌。在客户端中，使用HTTP Authorization头部来传递令牌。</p><blockquote><p>得到的这种访问令牌叫做bearer令牌，它意味着无论是谁，只要持有就可以向保护资源出示，OAuth bearer令牌使用规范明确给出了发送令牌值的3种方法：</p><p>使用HTTP Authorization 头部、使用表单格式的请求体参数、使用URL编码的查询参数</p><p>由于另外两种方法存在一定的局限性，因此建议尽可能使用Authorization头部。在使用查询参数时，访问令牌的值有可能被无意地泄露到服务端日志中吗，因为查询参数是URL请求的一部分；使用表单的方式，会限制受保护资源只能接受表单格式的输入参数，并且要使用POST方法。如果要API已经按这样的限制运行了，那这种方法没有问题，毕竟不会面临与查询参数方法一样的安全局限。</p><p>使用Authorization头部是这3种方法中最灵活和最安全的。由于对客户端来说，使用起来很困难。一个健壮的OAuth客户端或者服务端库应该完整地提供这3种方式，以适应不同情况。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/fetch_resource'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 确认是否已拥有访问令牌，没有需要向用户提示错误并退出</span></span><br><span class="line">  <span class="keyword">if</span> (!access_token) &#123;</span><br><span class="line">    res.render(<span class="string">'error'</span>, &#123;</span><br><span class="line">      error: <span class="string">'Missing access token.'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>请求受保护资源，并将获取的响应数据渲染到页面，protectedResource变量设置了一个URL,将向该URL发送请求并期待返回JSON响应。使用OAuth定义的Authorization头发送令牌，将令牌设置为这个头部的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/fetch_resource'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 确认是否已拥有访问令牌，没有需要向用户提示错误并退出</span></span><br><span class="line">  <span class="keyword">if</span> (!access_token) &#123;</span><br><span class="line">    res.render(<span class="string">'error'</span>, &#123;</span><br><span class="line">      error: <span class="string">'Missing access token.'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> headers = &#123;</span><br><span class="line">    Authorization: <span class="string">`Bearer <span class="subst">$&#123;access_token&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> resource = <span class="built_in">require</span>(<span class="string">'POST'</span>, protectedResource, &#123;</span><br><span class="line">    headers</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (resource.statusCode &gt;= <span class="number">200</span> &amp;&amp; resource.statusCode &lt; <span class="number">300</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> body = <span class="built_in">JSON</span>.parse(resource.getBody());</span><br><span class="line">    res.render(<span class="string">'data'</span>, &#123;</span><br><span class="line">      resource: body</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.render(<span class="string">'error'</span>, &#123;</span><br><span class="line">      error: <span class="string">`Server returned response code: <span class="subst">$&#123;resource.statusCode&#125;</span>`</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="刷新访问令牌"><a href="#刷新访问令牌" class="headerlink" title="刷新访问令牌"></a>刷新访问令牌</h3><p>OAuth2.0提供了一种无须用户参与的情况下最新访问令牌的方式：刷新令牌。用户在初次授权完成之后不会一直在场，而OAuth经常要在这样的情况下使用。</p><p>客户端如何才能知道自己的访问令牌是否有效，唯一的方法就是使用它，然后看结果。如果令牌具有预设的过期时间，授权服务器可以在令牌响应中使用一个可选的<code>expires_in</code>字段来表示预设的有效期。这是一个从令牌发放到预设失效时间之间的秒数值，一个中规中矩的客户端应该会关注这个值，并将过期的令牌丢弃掉。</p><p>然后，仅仅指定过期时间还不足以让客户端掌握令牌的状态。很多OAuth实现中，资源拥有者可以在令牌过期之前将其撤销。一个设计良好的客户端应该始终能预料到访问令牌可能随时突然失效，并能做出反应。</p><p>可以提示用户重新授权并获取一个新的令牌，刷新令牌最初是与访问令牌在同一个JSON对象中返回给客户端的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"access_token"</span>: <span class="string">"987tghjkiu6trfghjuytrghj"</span>,</span><br><span class="line">    <span class="attr">"token_type"</span>: <span class="string">"Bearer"</span>,</span><br><span class="line">    <span class="attr">"refresh_token"</span>: <span class="string">"j2r3oj32r23rmasd98uhjrk2o3i"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端将刷新令牌保存在 <code>refresh_token</code>变量中。授权服务器启动前先清空数据库，再将刷新令牌自动插入数据库。没有插入对应的访问令牌，模拟访问令牌失效但刷新令牌仍有效</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> access_token = <span class="string">'987tghjkiu6trfghjuytrghj'</span>;</span><br><span class="line"><span class="keyword">let</span> scope = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> refresh_token = <span class="string">'j2r3oj32r23rmasd98uhjrk2o3i'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(resource.statusCode &gt;=<span class="number">2000</span> &amp;&amp; resource.statusCode &lt; <span class="number">300</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> body = <span class="built_in">JSON</span>.parse(resource.getBody());</span><br><span class="line">    res.render(<span class="string">'data'</span>,&#123;<span class="attr">resource</span>:body&#125;)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    access_token = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(refresh_token)&#123;</span><br><span class="line">        refreshAccessToken(req,res)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.render(<span class="string">'error'</span>,&#123;<span class="attr">error</span>:resource.statusCode&#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向令牌端点发起一个请求，刷新访问令牌是授权许可的一种特殊情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refreshAccessToken</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 使用refresh_token作为grant_type参数的值，刷新令牌也作为参数包含在其中</span></span><br><span class="line">    <span class="keyword">const</span> form_data = qs.stringfy(&#123;</span><br><span class="line">        grant_type:<span class="string">'refresh_token'</span>,</span><br><span class="line">        refresh_token</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> header = &#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>:<span class="string">'application/x-www-form-unlencoded'</span>,</span><br><span class="line">        <span class="string">'Authorization'</span>:<span class="string">`Basic <span class="subst">$&#123;encodeClientCredentials(client.client_id,client.client.secret)&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> tokRes = requst(<span class="string">'POST'</span>,authServer.tokenEndpoint,&#123;</span><br><span class="line">        body:form_data,</span><br><span class="line">        headers,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span>(tokRes.statusCode &gt;=<span class="number">200</span> &amp;&amp; tokRes.statusCode &lt; <span class="number">300</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> body = <span class="built_in">JSON</span>.parse(tokRes.getBody)</span><br><span class="line">        access_token = body.access_token;</span><br><span class="line">        <span class="keyword">if</span>(body.refresh_token)&#123;</span><br><span class="line">            refresh_token = body.refresh_token</span><br><span class="line">        &#125;</span><br><span class="line">        scope = body.scope;</span><br><span class="line">        <span class="comment">// 重新获取受保护资源</span></span><br><span class="line">        res.redirect(<span class="string">'/fetch_resource'</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 如果刷新令牌失效，则将刷新令牌与访问领票都丢弃掉，并渲染一个错误提示</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'NO refresh token,asking the user to get a new access token'</span>);</span><br><span class="line">        refresh_token = <span class="literal">null</span>;</span><br><span class="line">        res.render(<span class="string">'error'</span>,&#123;</span><br><span class="line">            error:<span class="string">'Unable to refresh token.'</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Oauth客户单是OAuth生态系统中使用最广泛的部分：</p><ul><li>使用授权码许可类型获取令牌只需要几个简单的步骤</li><li>如果刷新令牌可用，则可以使用它获取新的访问令牌，而不需要用户参与</li><li>使用Oauth2.0的bearer令牌比获取令牌更简单，只需要将一个简单HTTP头部添加到所有HTTP请求中即可</li></ul><h2 id="第四章：构建简单的OAuth受保护资源"><a href="#第四章：构建简单的OAuth受保护资源" class="headerlink" title="第四章：构建简单的OAuth受保护资源"></a>第四章：构建简单的OAuth受保护资源</h2><p>受保护资源，供客户端用访问令牌调用。对于大多数基于Web的API,增加OAuth安全层是一个轻量级的过程。资源服务器需要做的就是传入的HTTP请求中解析出OAuth令牌，验证该令牌，并确定它能用于哪些请求。</p><p>尽管受保护资源和授权服务器在概念上是OAuth系统的不同组件，但许多OAuth实现将二者放在一起。这种做法在两个系统耦合紧密下的情况下适用。下面的例子，会在同一台机器使用独立进程运行受保护资源，但是它能够访问授权服务器所用的数据库。</p><h3 id="解析HTTP请求中的OAuth令牌"><a href="#解析HTTP请求中的OAuth令牌" class="headerlink" title="解析HTTP请求中的OAuth令牌"></a>解析HTTP请求中的OAuth令牌</h3><p>受保护资源接受OAuth bearer令牌，因为授权服务器生成的就是bearer令牌，OAuth bearer令牌使用规范定义了3种受保护传递 bearer令牌的方法：使用HTTP Authorization 头部、使用表单参数以及使用查询参数。首选 Authorization头部。</p><p>由于要在多个资源URL上执行此操作，会使用一个辅助函数来检查令牌。Express的方法第三个参数是 next，next是一个函数可以调用它来继续处理请求，使得可以使用多个函数处理单个请求，并把令牌检查功能添加到整个应用的请求处理流程中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getAccessToken = <span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OAuth bearer令牌使用规范规定，在使用HTTP Authorization头部传递令牌时，HTTP头的值以关键字 Bearer开头，后跟一个空格，再跟令牌值本身。而且，OAuth 规范还规定了 Bearer关键字不区分大小写。此外，HTTP规范还规定了Authorization头部关键字本身不区分大小写。这意味着下面的所有HTTP头都是等价的</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Authorization</span>: Bearer xxx</span><br><span class="line"><span class="attribute">Authorization</span>: bearer xxx</span><br><span class="line"><span class="attribute">authorization</span>: BEARER xxx</span><br></pre></td></tr></table></figure><p>首先，尝试从请求中获取Authorization头部，然后检查是否包含OAuth bearer令牌，由于express自动将所有HTTP头名称转为小写，我们使用字符authorization检查传入的请求对象，还要在头部值转为小写后检查关键字 bearer</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> inToken = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> auth = req.header[<span class="string">'authorization'</span>];</span><br><span class="line"><span class="keyword">if</span>(auth &amp;&amp; auth.toLowerCase().indexOf(<span class="string">'bearer'</span>) === <span class="number">0</span>)&#123;</span><br><span class="line">    inToken = auth.slice(<span class="string">'bearer '</span>.length);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(req.body &amp;&amp; req.body.access_token)&#123;</span><br><span class="line">    inToken = req.body.access_token;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(req.query&amp;&amp;req.query.access_token)&#123;</span><br><span class="line">    inToken = req.query.access_token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查通过，将头部的bearer关键字和后面的空格去掉，获取令牌值。令牌值本身不区分大小写的，所以要从从初始字符串提取令牌，而不是转换之后的字符串中提取</p><p>处理通过表单参数传递令牌，表单参数在请求主体中。OAuth规范不推荐这种方法，因为它认为限制了API的输入只能是表单形式。如果API的本来输入载体是JSON格式，那么客户端就无法在请求主体中加入令牌。在这种情况下，使用Authorization头部才是首选。但是对于那些输入载体就是表单格式的API，这种方法既简单又能和API保持一致，而且不需要处理Authorization头部。</p><p>最后一种方法是通过查询参数传递令牌。建议在其他两种方法不能使用的时候才采用该方法。使用这种方法，访问令牌很可能被无意地记录在服务器访问日志中或者通过HTTP Referrer头泄露，它们会整体复制URL。然而，有时候客户端应用无法直接访问HTTP Authorization头部（受限于平台或库），也不能使用表单参数（比如HTTP GET 方法）。另外，这种方法不仅可以在URL中包含资源本身的定位符，而且还可以包含访问方法。在这些情况下，只要有适当的安全措施，OAuth运行客户端通过查询参数来传递令牌。</p><h3 id="根据数据存储验证令牌"><a href="#根据数据存储验证令牌" class="headerlink" title="根据数据存储验证令牌"></a>根据数据存储验证令牌</h3><p>我们可以访问授权服务器用于存储令牌的数据库，这是小型OAuth系统中常用的配置方案，这样的系统将授权服务器与受保护的API放在一起。</p><p>例子的授权服务器使用了一个NoSQL数据库，它将数据库存储在磁盘上的文件中，通过一个简单Nodejs模块来访问。如果想实时查看程序运行时数据库的内容，可以监控联系目录的database.sql文件。</p><p>根据传入的令牌值执行简单的查找，从数据库中找出访问令牌，服务器将每一个访问令牌和刷新令牌分别作为单独的元素存储在数据中，所以只需要使用数据库的查询功能找出正确的令牌即可。查询函数的细节对于NoSQL数据库来说是特有的，但是其他数据库也会提供类似的查询方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nosql.one(<span class="function">(<span class="params">token</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(token.access_token === inToken)&#123;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,(err,token)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(token)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`We found a matching token: <span class="subst">$&#123;inToken&#125;</span>`</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'No matching token was found.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    req.access_token = token;</span><br><span class="line">    next();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>传入的第一个函数将获取令牌与数据库中的访问令牌进行对比，如果发现匹配项，就会停止搜索并返回令牌。第二个函数会在发生匹配的令牌时或者数据库遍历到尽头被调用。如果在数据库找到令牌，它会被作为token参数传入，否则为null。无论找到什么，都将它赋值个req对象的<code>access_token</code>成员，然后调用next函数，req对象会自动传递给处理函数的下一个处理步骤</p><p>返回的令牌对象与授权服务器在生成令牌时插入数据库的对象完全相同，例如，示例授权服务器会像下面这样将访问令牌以及权限范围保存在下一个JSON对象中</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    access_token:'xxx',</span><br><span class="line">    client_id:'xx',</span><br><span class="line">    scope:['xxx']</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用共享数据是一种非常常见的OAuth部署模式，但不是唯一的选择。有一个叫做令牌内省（token introspection）的Web协议，它可以有授权服务器提供接口，让资源服务器可以在运行时检查令牌的状态。这使得资源服务器可以像客户端那样将令牌本身视为不透明的。代价是使用而更加的网络流量。还有另一种方式：可以在令牌内包含受保护资源能够直接解析并理解的信息。JWT就是这样的一种数据结构，它可以使用受加密保护的JSON对象携带声明信息。</p><p>是否必须将令牌以原始值存储在数据中，虽然这是一种简单且常见的做法，也可以存储令牌的散列值，这种方式类似存储用户密码，在查询令牌时，要将令牌再次进行散列计算，并同数据库中内容进行比较。还可以将唯一标识符添加到令牌中，并使用服务器的密钥对它签名。在数据库中只存储这唯一的标识符。当需要查找这个令牌的时候，资源服务器可以验证签名，解析令牌得到标识符，然后在数据库中查找这个标识符对应的令牌信息。</p></blockquote><p>接入服务，在Express应用中，有两个选择，一个是用于每个请求，二是只将它用于需要检查OAuth令牌的请求。为了将这一处理应用到每个请求，需要设置一个新的监听器。将令牌检查函数链接到处理流程中。令牌检查函数需要在路由中其他所有函数之前连接，因为这些函数是按照在代码中被添加的顺序来执行的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.all(<span class="string">'*'</span>,getAccessToken)</span><br></pre></td></tr></table></figure><p>另外可以将新函数插入已有的处理函数设置，让新函数先被调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">'/resource'</span>,(req,res)=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure><p>要让令牌处理函数先被调用，需要在路由的处理函数定义之前添加函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">'/resource'</span>,getAccessToken,(req,res)=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure><p>当路由处理函数被调用时，请求对象会附加一个<code>access_token</code>成员，如果令牌被找到，这个字段就会包含从数据库中取出的令牌对象。如果令牌未被找到，这个字段就会是null,需要根据情况判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(req.access_token)&#123;</span><br><span class="line">    res.json(resource)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    res.status(<span class="number">401</span>).end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据令牌提供内容"><a href="#根据令牌提供内容" class="headerlink" title="根据令牌提供内容"></a>根据令牌提供内容</h3><p>很多API设计中，不同的操作需要不同访问权限，还有一些API会根据授权者不同而返回不同的结果，或者根据不同权限返回某一部分信息。加一个 <code>requireAccessToken</code>处理函数，会在令牌不存在时直接返回错误，在令牌存在时将控制权交给最终处理函数进行后续处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requireAccessToken = <span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.access_token)&#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.status(<span class="number">401</span>).end();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不同权限对应不同的操作"><a href="#不同权限对应不同的操作" class="headerlink" title="不同权限对应不同的操作"></a>不同权限对应不同的操作</h4><p>不同类型的操作需要不同的权限范围，才能使调用成功。这使得资源服务器可以根据客户端能执行的操作来划分功能。这也是单个授权服务器对应的多个资源服务器之间使用单个令牌的常用方法。</p><p>客户端有一个页面提供访问资源API的所有功能，读取显示并带上时间戳，用于资源服务器上添加新单词，删除功能等</p><p>应用中注册了三个路由，分别对应不同的动作，只要传入的令牌有效，无论什么类型，都会执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/words'</span>,getAccessToken,requireAccessToken,(req,res)=&gt;&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">        words:saveWords.json(<span class="string">' '</span>),</span><br><span class="line">        timestamp:<span class="built_in">Date</span>.now()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/words'</span>,getAccessToken,requireAccessToken,(req,res)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.body.word)&#123;</span><br><span class="line">        saveWords.push(req.body.word)</span><br><span class="line">    &#125;</span><br><span class="line">    res.status(<span class="number">201</span>).end();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.delete(<span class="string">'/words'</span>,getAccessToken,requireAccesToken,(req,res)=&gt;&#123;</span><br><span class="line">    saveWords.pop()</span><br><span class="line">    res.status(<span class="number">204</span>).end;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在，逐个修改它们，确保令牌中至少包含与各个功能对应的权限范围，鉴于在数据库中存储方式，需要获取令牌对应的<code>scope</code>成员，对于GET功能，我们需要客户端拥有与之对一个的read权限范围，客户端还可以拥有其他权限范围</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">'/words'</span>, getAccessToken, requireAccessToken, (req, res) =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (__.contains(req.access_token.scope, <span class="string">'write'</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (req.word.word) &#123;</span><br><span class="line">saveWords.push(req.body.word)</span><br><span class="line">&#125;</span><br><span class="line">res.status(<span class="number">201</span>).end()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res.set(<span class="string">'WWW-Authenticate'</span>, <span class="string">'Bearer realm=localhost:9002,error="insufficient_scope",scope="write"'</span>);</span><br><span class="line">res.status(<span class="number">403</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用 <code>WWW-Authenticate</code>头部返回错误，告诉客户端该资源需要接受一个OAuth bearer令牌，并且令牌中至少要包含read权限范围，才能调用成功。在另外两个函数中加入类似的代码，也会检查write,delete的权限范围，在任何情况下，即使令牌有效，只要权限范围不正确，就会返回错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">'/words'</span>, getAccessToken, requireAccessToken, (req, res) =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (__.container(req.access_token.scope, <span class="string">'write'</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (req.word.word) &#123;</span><br><span class="line">saveWords.push(req.body.word)</span><br><span class="line">&#125;</span><br><span class="line">res.status(<span class="number">201</span>).end()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res.set(<span class="string">'WWW-Authenticate'</span>, <span class="string">'Bearer realm=localhost:9002,error="insufficient_scope",scope="write"'</span>);</span><br><span class="line">res.status(<span class="number">403</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.delete(<span class="string">'/words'</span>, getAccessToken, requireAccessToken, (req, res) =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (__.container(req.access_token.scope, <span class="string">'delete'</span>)) &#123;</span><br><span class="line">saveWords.pop()</span><br><span class="line">res.status(<span class="number">204</span>).end()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res.set(<span class="string">'WWW-Authenticate'</span>, <span class="string">'Bearer realm=localhost:9002,error="insufficient_scope",scope="delete"'</span>);</span><br><span class="line">res.status(<span class="number">403</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样一来，要为客户端指定不同的权限范围组合，需要重新对客户端应用授权</p><h4 id="不同的权限范围对应不同的数据结果"><a href="#不同的权限范围对应不同的数据结果" class="headerlink" title="不同的权限范围对应不同的数据结果"></a>不同的权限范围对应不同的数据结果</h4><p>在这种风格的API设计中，同一个处理函数可以根据传入的令牌中包含的权限范围不同，而返回不同类别的信息。如果数据结构复杂，且希望通过同一个API端点为客户端提供多种信息子集的访问，这样设计就非常有用。</p><p>在受保护资源没有为不同的农产品类别提供多个独立的处理函数，而是在一个处理函数中处理对所有农产品的请求，这个处理函数返回的对象中包含所有种类的农产品列表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/produce'</span>,getAccessToken,requireAccessToken,(req,res)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> produce = &#123;</span><br><span class="line">        fruit:[<span class="string">'apple'</span>,<span class="string">'banana'</span>,<span class="string">'kiwi'</span>],</span><br><span class="line">        veggies:[<span class="string">'lettuce'</span>,<span class="string">'onion'</span>,<span class="string">'potato'</span>],</span><br><span class="line">        meats:[<span class="string">'bacon'</span>,<span class="string">'steak'</span>,<span class="string">'chicken breast'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    res.json(produce)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在做修改之前，使用有效的令牌访问该API,会得到包含所有农产品的列表，如果对客户端授权让它得到访问令牌，但是不勾选任何权限范围，就会得到所有数据。</p><p>切分数据结构，将数据片段放入控制语句，检查每个农产品类别的权限范围</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> produce = &#123;</span><br><span class="line">    fruit:[],</span><br><span class="line">    veggies:[],</span><br><span class="line">    meats:[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(__.contains(req.access_token.scope,<span class="string">'fruit'</span>))&#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(produce,&#123;<span class="attr">fruit</span>:[<span class="string">'apple'</span>,<span class="string">'banana'</span>,<span class="string">'kiwi'</span>]&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(__.contains(req.access_token.scope,<span class="string">'veggies'</span>))&#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(produce,&#123;<span class="attr">fruit</span>:[<span class="string">'lettuce'</span>,<span class="string">'onion'</span>,<span class="string">'potato'</span>]&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(__.contains(req.access_token.scope,<span class="string">'meats'</span>))&#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(produce,&#123;<span class="attr">fruit</span>:[<span class="string">'bacon'</span>,<span class="string">'steak'</span>,<span class="string">'chicken breast'</span>]&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不同用户对应不同的数据结果"><a href="#不同用户对应不同的数据结果" class="headerlink" title="不同用户对应不同的数据结果"></a>不同用户对应不同的数据结果</h4><p>同一个处理函数可以根据授权客户端的用户不同的信息。这是一种常见的API设计方式，使得客户端应用在不知道用户是谁的情况下，调用同一个URL也能获取个性化的结果。虽然客户端与受保护资源之间建立的连接上并没有资源拥有者的登录或者身份认证信息，但是生成的令牌中包含资源拥有者的信息，资源拥有者需要在授权批准的环节进行身份认证。</p><blockquote><p>授权服务器的批准页面会选择替哪个用户授权，通常这一步是通过授权服务器对资源拥有者进行身份认证来完成的，而且一般认为运行一个未经身份认证的用户随意冒充任何人是极不安全的做法。</p></blockquote><p>我们要做的就是根据授权者是谁来返回对应的数据，授权服务器已经讲资源拥有者的用户名存在访问令牌记录的user字段中，根据这个字段确定返回内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">app.get(<span class="string">'/favorites'</span>, getAccessToken, requireAccessToken, (req, res) =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">access_token: &#123;</span><br><span class="line">user</span><br><span class="line">&#125;</span><br><span class="line">&#125; = req;</span><br><span class="line"><span class="keyword">const</span> unknown = &#123; <span class="attr">user</span>: <span class="string">'Unknown'</span>, <span class="attr">favorites</span>: &#123; <span class="attr">movies</span>: [], <span class="attr">foods</span>: [] &#125; &#125;</span><br><span class="line"><span class="keyword">switch</span> (user) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'alice'</span>:</span><br><span class="line">res.json(&#123; <span class="attr">user</span>: <span class="string">'Alice'</span>, <span class="attr">favorites</span>: aliceFavorites &#125;)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'bob'</span>:</span><br><span class="line">res.json(&#123; <span class="attr">user</span>: <span class="string">'Bob'</span>, <span class="attr">favorites</span>: bobFavorites &#125;)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">res.json(unknown)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在授权服务器上以Alice或者Bob名义授权了客户端，就会在客户端上得到他们的个性化数据。</p><p>在OAuth处理流程中，客户端绝不知道与之交互的是Alice还是Bob或者其他的。客户端只是碰巧知道了Alice的名字，因为它调用的API的响应包含了她的名字，而这个人信息也很容易被去掉。这是一个重要的设计模式，因为它可以避免不必要的暴露资源拥有者的个人身份信息，从而保护隐私。如果与分享信息的API结合起来，可以用OAuth构建一个身份认证协议。</p><h4 id="额外的访问控制"><a href="#额外的访问控制" class="headerlink" title="额外的访问控制"></a>额外的访问控制</h4><p>使用OAuth能对受保护资源实现的访问控制远不止上面那些，而且当今使用OAuth的受保护资源都有各自的应用模式。因此，OAuth并不插手授权决策的过程，而只通过使用令牌和权限范围充当授权信息的载体。这样的设计思路使得OAuth广泛应用于互联网上各种类型的API.</p><p>资源服务器可以根据令牌及其附属信息（如权限范围）直接作出授权决策。资源服务器还可以将访问令牌中的权限范围与其他访问控制信息结合起来，用于决定是否响应API调用已经响应什么内容。例如,资源服务器可以限制特定的客户端和用户只能在特定的时间段内访问资源，无论令牌是否有效。资源服务器甚至可以以令牌作为输入，调用外部策略引擎，以实现组织内对复杂授权规则的集中管理。</p><p>在任何情况下，资源服务器都对访问令牌的含义拥有最终决定权，不管资源服务器外包了多少决策过程，最终都由它来决定如何处理给定请求。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>使用OAuth保护Web Api非常简单：</p><ul><li>从传入的请求中解析出令牌</li><li>通过授权服务器验证令牌</li><li>根据令牌的权限范围作出响应，令牌的权限范围有多种。</li></ul><h2 id="第五章：构建简单的OAuth授权服务器"><a href="#第五章：构建简单的OAuth授权服务器" class="headerlink" title="第五章：构建简单的OAuth授权服务器"></a>第五章：构建简单的OAuth授权服务器</h2><p>上面构建了OAuth客户端应用，可以从授权服务器获取令牌，并使用令牌访问受保护资源，还构建了一个供用户访问的受保护资源，下面构建了一个简单的授权服务器，支持授权码许可类型，这个组件要管理客户端，执行OAuth核心的授权操作，还要向客户端颁发令牌</p><p>授权服务器是OAuth生态系统中最复杂的组件，是整个OAuth系统的安全权威中心。只有授权服务器能够给用户进行身份认证，注册客户端，颁发令牌。在OAuth2.0规范的制定过程中，已经尽可能将复杂性从客户端和受保护资源转移到授权服务器。这很大程度是由各个组件的数量决定的：客户端的数量远多于受保护资源的数量，受保护资源的数量又远多于授权服务器的数量。</p><h3 id="管理OAuth客户端注册"><a href="#管理OAuth客户端注册" class="headerlink" title="管理OAuth客户端注册"></a>管理OAuth客户端注册</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;oauth2-nodejs实战&quot;&gt;&lt;a href=&quot;#oauth2-nodejs实战&quot; class=&quot;headerlink&quot; title=&quot;oauth2 nodejs实战&quot;&gt;&lt;/a&gt;oauth2 nodejs实战&lt;/h1&gt;&lt;h2 id=&quot;第一章：OAuth2-0是
      
    
    </summary>
    
      <category term="nodejs实战" scheme="http://laibh.top/categories/nodejs%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="docker" scheme="http://laibh.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker从入门到实践</title>
    <link href="http://laibh.top/2020-07-07-docker.html"/>
    <id>http://laibh.top/2020-07-07-docker.html</id>
    <published>2020-07-07T01:58:40.000Z</published>
    <updated>2022-03-04T10:00:38.464Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cntofu.com/book/139/index.html">docker学习，作者源于这里</a></p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="镜像Image"><a href="#镜像Image" class="headerlink" title="镜像Image"></a>镜像Image</h3><p>操作系统分为内核和用户空间，内核启动后，会挂载root文件系统为其提供用户空间支持。docker镜像就相当于是一个root文件系统。</p><p>是一个特殊文件系统，除了提供容器运行所需的程序、库、资源、配置等文件外，还包含一些为运行准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不会包含任何动态数据，其内容在构建之后也不会被改变</p><h4 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h4><p>镜像包含操作系统完整的root文件系统，体积庞大，在设计docker时，将其设计为分层存储架构。严格来说，镜像并非像一个ISO那要的打包文件，镜像只是一个虚拟概念，实际体现并非由一个文件组成，而是由一组文件系统组成，或说是多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础，每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己的这一层。例如删除前一层文件的操作并不是真的删除前一层文件，而是仅在当前层标记为该文件已珊瑚虫。在最终容器运行时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉</p><p>分层存储的特性还使得镜像的复用、定制变得更加容易，甚至可以使用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像</p><h3 id="容器Container"><a href="#容器Container" class="headerlink" title="容器Container"></a>容器Container</h3><p>镜像和容器的关系，就像是面向对象程序中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容易可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、自己的网络配置、自己的进程空间，设置自己的用户ID空间。容器内的进程是运行在一个隔离的环境里面，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。因为这种隔离特性，常常会混淆容器和虚拟机。</p><p>容易也是分层存储，每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，称这个为容器运行时读写而装备的存储层为容器存储层。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层随之消亡。任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有文件写入操作，都应该使用数据卷、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷的生存周期独立容器，使用数据卷后，容器删除或者重新运行之后，数据不会丢失。</p><h3 id="仓库Repository"><a href="#仓库Repository" class="headerlink" title="仓库Repository"></a>仓库Repository</h3><p>镜像构建后，容易在当前宿主机上运行，但是如果需要在其他服务器上使用这个镜像，就需要一个集中的存储、分发镜像的服务，docker register就是这样的服务。一个docker regisert中可以包含多个仓库，仓库可以包含多个标签Tag,每个标签对应一个镜像。</p><p>通常一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式指定具体这个软件哪个版本的镜像。如果不给出标签，将以lasest作为默认版本。</p><h2 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h2><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><blockquote><p>docker pull [选项] [Docker Register 地址[:端口号]/]仓库名[:标签]</p></blockquote><p>可通过<code>docker pull --help</code>命令看到。镜像名称格式：</p><ul><li>Docker 镜像仓库地址：地址的名称一般是<code>&lt;域名/IP&gt;[:端口号]</code>默认地址是Docker Hub</li><li>仓库名：仓库名是两段式名称，即<code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于Docker Hub不给出用户名，默认就是 library，也就是官方镜像</li></ul><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[1;32mdocker@default[0m:[1;34m~[0m</span><br><span class="line"><span class="meta">$</span><span class="bash"> docker pull ubuntu:16.04</span></span><br><span class="line">16.04: Pulling from library/ubuntu</span><br><span class="line"></span><br><span class="line">[1B8bd67045: Pulling fs layer</span><br><span class="line">[1Be4862c05: Pulling fs layer</span><br><span class="line">[1B8949dcb1: Pulling fs layer</span><br><span class="line">[1BDigest: sha256:69bc24edd22c270431d1a9e6dbf57cfc4a77b2da199462d0251b145fdd7fa538</span><br><span class="line">Status: Downloaded newer image for ubuntu:16.04</span><br></pre></td></tr></table></figure><p>上面命令没有给出docker镜像仓库地址，会从Docker Hub获取镜像，镜像名称是<code>ubuntu:16.04</code>,因此获取官方镜像<code>library/ubuntu</code>，仓库中标签为 16.04的镜像</p><p>下载过程中可以看出分层存储概念，镜像由多层存储所构成，下载也是一层层的去下载，并非单一文件。下载过程中给出每一层ID的前12位，并且下载结束后，给出该镜像sha256的完整摘要，以确保下载一致性</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>以镜像为基础启动并运行一个容器，启动里面的bash并镜像交互操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[1;32mdocker@default[0m:[1;34m~[0m$ [Kdocker run -it --rm ubuntu:16.04 bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前系统版本</span></span><br><span class="line">[K]0;root@0d248af097b5: /root@0d248af097b5:/# cat /etc/os-release</span><br><span class="line">NAME="Ubuntu"</span><br><span class="line">VERSION="16.04.6 LTS (Xenial Xerus)"</span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME="Ubuntu 16.04.6 LTS"</span><br><span class="line">VERSION_ID="16.04"</span><br><span class="line">HOME_URL="http://www.ubuntu.com/"</span><br><span class="line">SUPPORT_URL="http://help.ubuntu.com/"</span><br><span class="line">BUG_REPORT_URL="http://bugs.launchpad.net/ubuntu/"</span><br><span class="line">VERSION_CODENAME=xenial</span><br><span class="line">UBUNTU_CODENAME=xenial</span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出</span></span><br><span class="line">]0;root@0d248af097b5: /root@0d248af097b5:/# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p><code>docker run</code>是容器运行的命令：</p><ul><li><code>-it</code>:这是两个参数，也给是<code>-i</code>，交互式操作，一个是<code>-t</code>终端。进入<code>bash</code>执行一些命令并查看返回结果，因此需要交互式终端</li><li><code>--rm</code>：容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动<code>docker rm</code>。这里使用 <code>--rm</code>可以避免浪费空间，只是随便执行个命令，查看结果，不需要排障和保留结果</li><li><code>ubuntu:16.64</code>：这是用这个镜像为基础来启动容器</li><li><code>bash</code>：在镜像后的是命令，希望有个交互式的shell，使用的是<code>bash</code></li></ul><h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><p><code>docker image ls</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1;32mdocker@default[0m:[1;34m~[0m$ docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED        SIZE</span><br><span class="line">ubuntu              16.04               c522ac0d6194        8 hours ago    126MB</span><br><span class="line">nginx               latest              2622e6cca7eb        3 weeks ago    132MB</span><br><span class="line">hello-world         latest              fce289e99eb9        18 months ago  1.84kB</span><br></pre></td></tr></table></figure><p>列表包含了仓库名、标签、镜像ID、创建时间以及所占空间。</p><p>镜像ID是镜像的唯一标识，一个镜像可以对应多个标签。</p><h4 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h4><p>这里标识所占的空间和在Docker Hub上看到的镜像大小不一样，这是因为Docker Hub中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像总是保持着压缩状态，因此Docker Hub中显示的大小是网络传输中更关心的流量大小，而<code>docker image ls</code>显示的是镜像下载到本地后展开的大小，是展开后的各层所占空间的总和，因此镜像到本地后，查看空间的时候，更关心的是本地磁盘空间所用的大小。</p><p>列表中的镜像体积总和并非是所有镜像实际硬盘消耗，由于docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于Docker使用UnionFS，相同层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p><p>使用 <code>docker system df</code>查看镜像、容器、数据卷所占用的空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1;32mdocker@default[0m:[1;34m~[0m$ docker system df</span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE      RECLAIMABLE</span><br><span class="line">Images              3                   1                   258.2MB   258.2MB (99%)</span><br><span class="line">Containers          1                   0                   0B        0B</span><br><span class="line">Local Volumes       0                   0                   0B        0B</span><br><span class="line">Build Cache         0                   0                   0B        0B</span><br></pre></td></tr></table></figure><h4 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h4><p>有时候会特殊镜像，既没有仓库名，也没有标签，为none</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;none&gt;   &lt;none&gt;    09089dhs989  5 days ago 23MB</span><br></pre></td></tr></table></figure><p>这些镜像原来是镜像名和标签的，随着官方镜像维护发布新版本，重新pull这个镜像，镜像名被转移到了新下载的镜像上，而旧的镜像上的名称则被取消，从而成为了<code>&lt;none&gt;</code>。docker build也可能导致这样的问题。由于新旧镜像同名，旧镜像名称被取消，从而仓库名、标签均为<code>&lt;none&gt;</code>。这类无标签镜像也被成为虚悬镜像（dangling image）,可以用<code>docker image ls -f dangling=true</code>显示这些镜像</p><p>虚悬镜像也是失去了存在价值，可以随意删除，用<code>docker image prune</code>删除</p><h4 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h4><p>为了加速镜像构建、重复利用资源，Docker会利用中间镜像，在使用一段时间后，会看到一些依赖的中间镜像。默认的<code>docker image ls</code>列表只会显示顶层镜像，如果希望显示中间层镜像在内的所有镜像的话，用<code>docker image ls -a</code></p><p>出现无标签镜像，与虚悬镜像不同，这些镜像都是中间层镜像，是其他镜像所依赖的镜像，删除这些镜像会导致上层镜像因为依赖丢失出错。删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除</p><h4 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 根据仓库名</span></span><br><span class="line">docker image ls ubuntu</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定仓库名和标签</span></span><br><span class="line">docker image ls ubuntu:16.04</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 过滤器参数--filter,简写-f,希望看到在mongo:3.2之后建立的镜像</span></span><br><span class="line">docker image ls -f since=mongo:3.2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 之前则是用before</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果镜像构建时，定义了LABEL,可通过LABEL过滤</span></span><br><span class="line">docker image ls -f label=com.example.version=0.1</span><br></pre></td></tr></table></figure><h4 id="特定格式显示"><a href="#特定格式显示" class="headerlink" title="特定格式显示"></a>特定格式显示</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将所有镜像的ID列出</span></span><br><span class="line">docker image ls -q</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出镜像结果只包含镜像ID和仓库名，使用了GO模板语法</span></span><br><span class="line">docker image ls --format "&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"</span><br><span class="line">c522ac0d6194: ubuntu</span><br><span class="line">2622e6cca7eb: nginx</span><br><span class="line">fce289e99eb9: hello-world</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以表格等距显示，并且有标题行，和默认一样，不过自己定义列</span></span><br><span class="line">docker image ls --format "table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;"</span><br><span class="line">IMAGE ID            REPOSITORY          TAG</span><br><span class="line">c522ac0d6194        ubuntu              16.04</span><br><span class="line">2622e6cca7eb        nginx               latest</span><br><span class="line">fce289e99eb9        hello-world         latest</span><br></pre></td></tr></table></figure><h3 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [选项] &lt;镜像1&gt;[&lt;镜像2&gt;...]</span><br></pre></td></tr></table></figure><p>ID、镜像名、摘要删除镜像</p><p>镜像可以是短id,长id,镜像名或者镜像摘要，短id取前3个字符以上，能区分别的镜像就可以</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker image rm 502</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用镜像名，&lt;仓库名&gt;:&lt;标签&gt;</span></span><br><span class="line">docker image rm centos</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示镜像摘要</span></span><br><span class="line">docker image ls --digests</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用镜像摘要删除镜像</span></span><br><span class="line">docker image rm node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有仓库名为redis的镜像</span></span><br><span class="line">docker image rm $(docker image ls -q redis)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所在mongo:3.2之前的镜像</span></span><br><span class="line">docker image rm$(docker image ls -q -f before=mongo:3.2)</span><br></pre></td></tr></table></figure><h4 id="Untagged和Deleted"><a href="#Untagged和Deleted" class="headerlink" title="Untagged和Deleted"></a>Untagged和Deleted</h4><p>删除行为分为两种，一种是untagged，一种是deleted。镜像的唯一标识是其ID和摘要，而一个惊喜可以有多个标签。当我们删除指定标签后，可能还有别的标签指向这个镜像，那么delete行为不会发生，会显示untagged信息。</p><p>当该镜像所有标签都被取消了，改镜像可能就失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，在删除的时候也是从上层向基础层方法依次进行判断删除。镜像的多层结构使得复用变动镜像容易，因此很有可能某个其他镜像正依赖当前镜像的某一层。这种情况不会触发删除该层行为。直到没有任何层依赖当前层时，才会真实删除当前层。</p><p>除了镜像依赖还有容器对镜像的依赖。如果有用这个镜像启动的容器存在，即使容器没有运行，那么同样不可以删除这个镜像。容器是以经为基础，再加一层容器存储层，组成这样的多层存储结构去运行。因此该镜像如果被这个容器所依赖，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后来删除镜像。</p><h3 id="利用commit理解镜像构成"><a href="#利用commit理解镜像构成" class="headerlink" title="利用commit理解镜像构成"></a>利用commit理解镜像构成</h3><p>镜像是容器的基础，每次执行docker run的时候都会指定哪个镜像作为容器运行的基础。当Docker Hub的镜像无法满足需求时，我们就需要定制镜像。</p><p>定制Web服务器为例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nginx镜像启用一个容器，命名为webserver,映射80端口，在浏览器可以访问这个nginx服务器</span></span><br><span class="line">docker run --name webserver -d -p 80:80 nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改欢迎页面,以交互式终端方式进入webserver容器，并执行bash命令，获得一个可操作的shell，使用新内容覆盖指定文件的内容</span></span><br><span class="line">docker exec -it webserver bash</span><br><span class="line">root@xxx: /# echo '&lt;h1&gt;Hello,Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span><br><span class="line">root@xxx: /# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>修改了容器文件，也就是改动了容器的存储层，通过 <code>docker diff</code>可以看到具体的改变</p><p>定制好变化后，保存下来形成镜像。当我们运行一个容器（不使用卷），我们做的任何文件修改都会被记录于容器存储层里。而docker提供了docker commit命令，可以将容器的存储层保存下来成为镜像。在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原来容器最后的文件变化</p><blockquote><p>docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将容器保存为镜像</span></span><br><span class="line">docker commit --author "Laibh &lt;544289495@qq.com&gt;" --message "修改默认页面" webserver nginx:v2</span><br></pre></td></tr></table></figure><p>接着</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看新定制的镜像并使用，也可以使用docker <span class="built_in">history</span>具体查看镜像内的历史记录</span></span><br><span class="line">docker image ls </span><br><span class="line"></span><br><span class="line">docker run --name web2 -d -p 81:80 nginx:v2</span><br></pre></td></tr></table></figure><p>使用 docker commit 命令可以直观帮助理解镜像分层存储概念，但是实际环境不会这么做。</p><p>仔细观察docker diff webserver的结果，会发现除了修改的文件外，由于命令的执行，还有很多文件被改动或者添加了，这仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像尤为臃肿。</p><p>此外，使用docker commit都是黑箱操作。只有制作者才知道做了什么，docker diff可以看出一些线索，但不能保证生成一致的镜像。</p><h3 id="Dockerfile定制镜像"><a href="#Dockerfile定制镜像" class="headerlink" title="Dockerfile定制镜像"></a>Dockerfile定制镜像</h3><p>dockerfile是一个文本文件，其内包含了一天天的指令（Instruction）,每一条指令构建一层，因此每一条指令的内容就是描述该层应当如何构建</p><p>在一个空白目录，建立一个文件夹，并命名为Dockerfile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir myngix</span><br><span class="line"><span class="built_in">cd</span> mynginx </span><br><span class="line">touch Dockerfile</span><br><span class="line">vi Dockerfile</span><br><span class="line"><span class="comment"># 内容为</span></span><br><span class="line">FROM nginx</span><br><span class="line">Run <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello,Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure><h4 id="FROM指定基础镜像"><a href="#FROM指定基础镜像" class="headerlink" title="FROM指定基础镜像"></a>FROM指定基础镜像</h4><p>定制镜像是以一个镜像为基础，在其上进行定制，FROM就是指定基础镜像，因此FROM是Dockerfile文件的第一条指令，除了docker hub现有的镜像，还有一个特殊的镜像 <code>scratch</code>，虚拟镜像，表示一个空白的镜像</p><blockquote><p>FROM scratch</p></blockquote><p>以它为基础的话，意味着不以任何镜像为基础，接下来写的指令作为镜像的第一层开始存在。不以任何系统为基础，直接将可执行文件复制进镜像的做法不罕见，对于Linux下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接FROM scratch会让镜像体积更加小巧。使用GO语言开发的引用会使用这种方式，这也是为什么说Go是特别适合容器微服务架构的语言的原因之一</p><h4 id="RUN指定命令"><a href="#RUN指定命令" class="headerlink" title="RUN指定命令"></a>RUN指定命令</h4><p>RUN指令是定制镜像最常见的指令之一。格式有两种：</p><p>shell格式：<code>RUN&lt;命令&gt;</code>，就像直接在命令行输入的命令一样</p><p>exec格式：<code>RUN[&quot;可执行命令&quot;,&quot;参数1&quot;,&quot;参数2&quot;]</code>，这更像是函数调用中格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev make</span><br><span class="line">RUN wget -O redis.tar.gz <span class="string">"http://download.redios.io/release/redis-3.2.5.tar.gz"</span></span><br><span class="line">RUN mkdir -p /usr/src/redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --script-components=1</span><br><span class="line">RUN make -C /usr/src/redis</span><br><span class="line">RUN make -C /usr/src/redis install</span><br></pre></td></tr></table></figure><p>dockerfile中每个指令都会建立一层，RUN也不例外，每一个RUN的行为都会新建一层，在其上执行结果后，commit一层的修改，构成新的镜像，上面这种写法创建了7个镜像，这是完全没有意义的，运行时很多不需要的东西都被装进了镜像，比如编译、更新的软件包等，结果就是产生臃肿、非常多层的镜像，不仅增加了构建时间，也容易出错。UnionFS是有最大层数限制的，比如AUFS,曾经是最大不超过42层，现在是不超过127层。</p><p>上面的Dockerfile正确写法应该是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line"></span><br><span class="line">RUN buildDeps=<span class="string">'gcc libc6-dev make'</span> \</span><br><span class="line">&amp;&amp; apt-get update \</span><br><span class="line">&amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span><br><span class="line">&amp;&amp; wget -O redis.tar.gz <span class="string">"http://download.redios.io/release/redis-3.2.5.tar.gz"</span> \</span><br><span class="line">&amp;&amp; mkdir -p /usr/src/redis \ </span><br><span class="line">&amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --script-components=1 \</span><br><span class="line">&amp;&amp; make -C /usr/src/redis \</span><br><span class="line">&amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">&amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">&amp;&amp; rm redis.tar.gz \</span><br><span class="line">&amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">&amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span><br></pre></td></tr></table></figure><p>之前所有命令的目的只有一个，就是编译、安装redis可执行文件。因此没有必要建立多层，这里仅使用一个RUN，并使用 <code>&amp;&amp;</code>将各个需要命令串联起来，将之前的7层变成1层。并且为了格式化还进行了换行。Dockerfile支持Shell类的行尾添加 <code>\</code>的命令行，以及行首 <code>#</code>进行注释的格式。良好的格式会让排障更加容易。</p><p>此外，上面的命令还进行了清理工作，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了apt缓存文件，在镜像构建过程要确保每一层只添加真正需要添加的东西，任何无关的东西都应该被清理掉。</p><h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><p>在Dockerfile文件所在目录执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker@default:~/mynginx$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/2 : FROM nginx</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 2622e6cca7eb</span></span><br><span class="line">Step 2/2 : RUN echo '&lt;h1&gt;Hello,Docker!!!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 6b7204234c09</span></span><br><span class="line">Removing intermediate container 6b7204234c09</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 4021436fa2ed</span></span><br><span class="line">Successfully built 4021436fa2ed</span><br><span class="line">Successfully tagged nginx:v3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在Step2中，RUN启动了一个容器6b7204234c09，执行了要求的命令，并提交了这一层4021436fa2ed，删除所用到的容器RUN启动了一个容器6b7204234c09</span></span><br></pre></td></tr></table></figure><p><code>docker build</code>格式：</p><blockquote><p>docker build [选型] &lt;上下文路径/URL/-&gt;</p></blockquote><h4 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h4><p>docker build 命令最后一个 <code>.</code>，代表当前目录，而Dockerfile就在当前目录，所以会误以为这个路径是指定Dockerfile所在路径，这样的理解不准确，其实这是在指定上下文路径。</p><p>docker build的工作原理：Docker在运行时分为Docker引擎（也就是服务端守护进程）和客户端工具。Docker的引擎提供了一组REST API,被称为Docker Remote API，而docker命令这样的客户端工具，则是通过这组API与Dokcer引擎交互，从而完成各种功能。因此我们表面上好像在本机执行各种docker功能，实际上，一切都是使用的远程调用形式在服务端（Docker引擎）完成。也因为这种C/S设计，让我们操作远程服务器的Docker引擎变得轻而易举。</p><p>当我们进行镜像构建时，并非所有的定制都会通过RUN指令完成，经常会需要将一些本地文件复制进镜像，比如通过COPY指令，ADD指令。而docker build命令构建镜像，并非在本地构建，而是在服务端，也就是Docker引擎中构建。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文概念，当构建的时候，用户会指定构建镜像上下文路径，docker build命令得知这个路径后，会将路径下的所有内容打包，然后上传给Docker引擎，这样Docker引擎收到这个上下文之后，展开就会获得构建镜像所需要的一切文件。</p><p>例如在Dockerfile这样写：</p><blockquote><p>COPY ./package.json /app/</p></blockquote><p>这并不是要复制执行docker build命令所在的目录下的package.json，也不是复制Dockerfile所在目录下的package.json,而是复制上下文context目录下的package.json</p><p>因此，COPY这类指令中的源文件的路径都是相对路径，如果真的需要那些文件，应该将它们复制到上下文目录中去。观察docker build输出，可以看到这个发送上下文的过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker@default:~/mynginx$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br></pre></td></tr></table></figure><p>理解构建上下文对于镜像构建很重要，避免犯一些不应该的错误，比如初学者在发现 <code>Copy/opt/xxxx /app</code>不工作后，干脆把Dockerfile放到了硬盘跟目录去构建，结果发现docker build执行后，在发送一个几十GB的东西，极为缓慢而且容易构建失败，那是因为这种做法是让docker build打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将Docker置于一个空目录，或者根目录下面，如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给Docker引擎，那么可以用<code>.dockerignore</code>剔除不需要作为上下文传递给Docker引擎的。</p><p>在默认情况下，如果不额外指定Dockerfile的话，会将上下文目录下的名为Dockerfile的文件作为Dockerfile，实际上不要求名字必须为Dockerfile，并且不要求必须位于上下文目录中，比如用 <code>-f ../Dockerfile.php</code>参数指定某个文件作为 Dockerfile</p><h4 id="其他Docker-build用法"><a href="#其他Docker-build用法" class="headerlink" title="其他Docker build用法"></a>其他Docker build用法</h4><h5 id="直接用-git-repo进行构建"><a href="#直接用-git-repo进行构建" class="headerlink" title="直接用 git repo进行构建"></a>直接用 git repo进行构建</h5><p>docker build还支持从URL构建，比如从 Git repo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定构建所需要的git repo，并且指定默认的master分支，构建目录为/814/，然后docker就会自己去git <span class="built_in">clone</span>这个项目、切换到指定分支，并进入到指定目录后开始构建</span></span><br><span class="line">docker build https://github.com/twang2218/gitlab-ce-zh.git#:8.14</span><br><span class="line">docker build https://github.com/twang2218/gitlab-ce-zh.git\#:8.14</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM gitlab/gitlab-ce:8.14.0-ce.0</span><br><span class="line">8.14.0-ce.0: Pulling from gitlab/gitlab-ce</span><br><span class="line">aed15891ba52: Already exists</span><br><span class="line">773ae8583d14: Already exists</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="用tar压缩包构建"><a href="#用tar压缩包构建" class="headerlink" title="用tar压缩包构建"></a>用tar压缩包构建</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build http://server/context.tar.gz</span><br></pre></td></tr></table></figure><p>如果给出的URL不是Git repo，而是个tar压缩包，那么Docker引擎会下载这个包，并自动解压，以其作为上下文，并且构建。</p><h5 id="从标准输入中读取Dockerfile进行构建"><a href="#从标准输入中读取Dockerfile进行构建" class="headerlink" title="从标准输入中读取Dockerfile进行构建"></a>从标准输入中读取Dockerfile进行构建</h5><blockquote><p>docker build - &lt; Dockerfile</p></blockquote><p>或者</p><blockquote><p>cat Dockerfile | docker build -</p></blockquote><p>如果标准输入传入的是文本文件，则将其视为Dockerfile，并开始构建。这种形式由于直接从标准输入中读取Dockerfile的内容，没有上下文，因此不可以像其他方法那样可以将本地文件COPY进镜像之类的事情</p><h5 id="从标准输入中读取上下文压缩包镜像构建"><a href="#从标准输入中读取上下文压缩包镜像构建" class="headerlink" title="从标准输入中读取上下文压缩包镜像构建"></a>从标准输入中读取上下文压缩包镜像构建</h5><blockquote><p>docker build - &lt; context.tar.gz</p></blockquote><p>如果发现标准输入的文件格式是 gzip/bzip2/xz的话，将会使其成为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p><h4 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h4><h5 id="COPY复制文件"><a href="#COPY复制文件" class="headerlink" title="COPY复制文件"></a>COPY复制文件</h5><p>格式：</p><ul><li><code>COPY &lt;源路径&gt;...&lt;目标路径&gt;</code></li><li><code>COPY[&quot;&lt;源路径1&gt;&quot;,...&quot;&lt;目标路径&gt;&quot;]</code></li></ul><p>和RUN指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用</p><p>COPY指令将从构建上下文目录中<code>&lt;源路径&gt;</code>的文件/目录复制到新的一层的镜像内的<code>&lt;目标路径&gt;</code>位置，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY package.json /usr/src/app/</span><br></pre></td></tr></table></figure><p>源路径可以是多个，甚至是通配符，其通配符规则要满足GO的filepath.Match规则，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure><p><code>&lt;目标路径&gt;</code>可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作路径可以用WORKDIR指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>此外，还有一点使用COPY指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用，特别是构建相关文件都在使用Git进行管理时。</p><h5 id="ADD更高级的复制文件"><a href="#ADD更高级的复制文件" class="headerlink" title="ADD更高级的复制文件"></a>ADD更高级的复制文件</h5><p>ADD指令和COPY的格式和性质基本一致，但是在COPY基础上增加了一些功能。</p><p>比如 <code>&lt;源路径&gt;</code>可以是一个URL,这种情况下Docker引擎会视图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code>去。下载后的文件权限自动设置为600，如果这并不是想要的权限，还要增加额外的一层RUN进行权限调整。另外，如果下载但是个压缩包，需要解压缩，也一样需要额外的一层RUN指令进行解压缩。所以不如直接使用RUN,然后用wget或者curl工具下载，处理权限、解压缩、然后清理无用文件更合理。因此这个功能其实并不好用，而且不推荐使用</p><p>如果<code>&lt;源路径&gt;</code>为一个tar压缩文件，压缩格式为gzip,bzip2以及xz的情况下，ADD指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code>去。</p><p>在某些情况下，这个自动解压功能非常有用，比如官方镜像ubuntu中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span><br></pre></td></tr></table></figure><p>在某些情况下，希望复制压缩文件而不解压就不用ADD命令了，在Dockerfile最佳实践文档中要求，尽可能使用COPY，因为它的语义很明确，就是复制文件而已，而ADD则包含了更复杂的功能，其行为也不一定很清晰。最适合用ADD的场合就是所提及的需要自动解压缩的场合。ADD指令会令镜像构建缓存失败，从而可能会令镜像构建变得比较缓慢。</p><p>因此COPY与ADD指令选择可以遵循这样的原则，所有文件复制均使用COPY指令，仅在需要自动解压缩的时候使用ADD</p><h5 id="CMD容器启动命令"><a href="#CMD容器启动命令" class="headerlink" title="CMD容器启动命令"></a>CMD容器启动命令</h5><p>CMD 指令格式和 RUN相似，也是两种格式：</p><ul><li>shell格式：CMD<code>&lt;命令&gt;</code></li><li>exec格式：CMD[“可执行文件”，“参数1”,”参数2”…]</li><li>参数列表格式：CMD[“参数1”,”参数2”]。在指定了ENTRYPOINT后，用CMD指定具体参数</li></ul><p>Docker不是虚拟机，容器就是进程，在启动容器的时候，需要指定所运行的程序及参数。CMD指令就是用指定默认的容器主进程的启动命令。</p><p>在运行时可以指定新的命令来提点镜像设置中的这个默认命令，比如ubuntu镜像默认的CMD是<code>/bin/bash</code>，如果我们直接docker run -it ubuntu的话，会直接进入bash，也可以在运行的时候指定运行别的命令，如 <code>docker run -it ubuntn cat /etc/os-release</code>，这里就是使用<code>cat /etc/os-release</code>命令替换了默认的 <code>/bin/bash</code>命令，输出了系统版本信息。</p><p>在指令格式上，一般推荐 exec格式，这类格式在解析时会被解析为JSON数组，因此一定要使用双引号，而不是单引号。使用shell的话，实际的命令会被包装为sh-c的参数的形式进行执行，比如：</p><blockquote><p>CMD echo \$HOME =》 CMD[“sh”,”-c”,”echo \$HOME”]</p></blockquote><p>这就是为什么可以使用环境变量的原因，因此这些环境变量会被shell进行解析处理。</p><p>Docker不是虚拟机，容器的应用都应该是以前台运行，而不是像虚拟机、物理机用<code>upstart/systemd</code>去启动后台服务，容器没有后台服务概念。一些人将CMD写为：</p><blockquote><p>CMD service nginx start</p></blockquote><p>然后发现容器执行后立即退出了，甚至在容器内去使用systemtcl命令结果却发现根本执行不了。</p><p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就是去了生存的意义，从而退出，其他辅助进程不是它需要关心的东西。</p><p>而是用 service nginx start命令，则是希望upstart来以后台守护进程形式启动nginx，CMD service nginx start实际上是 <code>CMD[&quot;sh&quot;,&quot;-C&quot;,&quot;service nginx start&quot;]</code>，因此主进程实际上是sh,当 service nginx start命令结束后，sh也就结束了，sh作为主进程退出，自然容器退出。</p><p>正确的做法是直接执行nginx可执行文件，并且要求前台形式运行：</p><blockquote><p>CMD [“nginx”,”-g”,”daemon off”;]</p></blockquote><h5 id="ENTRYPOINT入口点"><a href="#ENTRYPOINT入口点" class="headerlink" title="ENTRYPOINT入口点"></a>ENTRYPOINT入口点</h5><p>与RUN指令一样，分为exec和shell格式。目的和CMD一样，都是在指定容器启动程序及参数。ENTRYPOINT在运行时也可以替代，不过比CMD要略繁琐，需要通过 docker run –entrypoint指定。</p><p>指定ENTRYPOINT后，CMD的含义就发生了变化，不再是直接的运行其命令，而是将CMD的内容作为参数传给ENTRYPOINT指令：</p><blockquote><p><ENTRYPOINT> “<CMD>“</p></blockquote><p>有了CMD后，为什么还要有ENTRYPOINT?</p><h6 id="场景一：让镜像变成像命令一样使用"><a href="#场景一：让镜像变成像命令一样使用" class="headerlink" title="场景一：让镜像变成像命令一样使用"></a>场景一：让镜像变成像命令一样使用</h6><p>假设我们需要一个得知自己当前公网IP的镜像，可以使用CMD实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN apt-age update \</span><br><span class="line">&amp;&amp; apt-age install -y curl \</span><br><span class="line">&amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">CMD [<span class="string">"curl"</span>,<span class="string">"-s"</span>,<span class="string">"http://ipinfo.cn"</span>]</span><br></pre></td></tr></table></figure><p>使用 <code>docker build -t myip .</code>来构建镜像的话，如果查询当前公网的ip，只需要执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run myip</span><br></pre></td></tr></table></figure><p>现在把镜像当做命令使用，如果命令有参数要怎么加上？CMD中实际的命令是curl，如果希望展示HTTP头部信息，就需要加上 <code>-i</code>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run myip -i</span><br><span class="line">docker: Error response from daemon: invalid header field value "oci runtime error: container_linux.go:247: starting container process caused \"exec: \\\"-i\\\": executable file not found in $PATH\"\n".</span><br></pre></td></tr></table></figure><p>可以看到执行文件找不到的报错，<code>executable file not found</code>。在镜像后面的是 command，运行时会替换CMD的默认值，这里的<code>-i</code>替换了CMD,而不是加在 <code>curl -s http://ip.cn</code>后面。而 <code>-i</code>不是命令，所以自然找不到。</p><p>如果希望加入 <code>-i</code>这参数，就必须重新完整的输入这个命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run myip curl -s http://ipinfo.cn -i</span><br></pre></td></tr></table></figure><p>这显然不是很好的解决方案，使用ENTRYPOINT可以解决这个问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">&amp;&amp; apt-get install -y curl \</span><br><span class="line">&amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">ENTRYPOINT [<span class="string">"curl"</span>,<span class="string">"-s"</span>,<span class="string">"http://ipinfo.cn"</span>]</span><br></pre></td></tr></table></figure><p>运行 docker run myip -i</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">docker@default:~/myip$ docker run myip</span><br><span class="line">&#123;</span><br><span class="line">  "ip": "113.70.180.56",</span><br><span class="line">  "city": "Foshan",</span><br><span class="line">  "region": "Guangdong",</span><br><span class="line">  "country": "CN",</span><br><span class="line">  "loc": "23.0268,113.1315",</span><br><span class="line">  "org": "AS4134 CHINANET-BACKBONE",</span><br><span class="line">  "timezone": "Asia/Shanghai",</span><br><span class="line">  "readme": "https://ipinfo.io/missingauth"</span><br><span class="line">&#125;docker@default:~/myip$ docker run myip -i</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Thu, 09 Jul 2020 03:16:44 GMT</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Content-Length: 233</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">X-Frame-Options: DENY</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">Referrer-Policy: strict-origin-when-cross-origin</span><br><span class="line">Set-Cookie: flash=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT</span><br><span class="line">Via: 1.1 google</span><br><span class="line">Expires: Thu, 09 Jul 2020 03:16:44 GMT</span><br><span class="line">Cache-Control: private</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "ip": "113.70.180.56",</span><br><span class="line">  "city": "Foshan",</span><br><span class="line">  "region": "Guangdong",</span><br><span class="line">  "country": "CN",</span><br><span class="line">  "loc": "23.0268,113.1315",</span><br><span class="line">  "org": "AS4134 CHINANET-BACKBONE",</span><br><span class="line">  "timezone": "Asia/Shanghai",</span><br><span class="line">  "readme": "https://ipinfo.io/missingauth"</span><br></pre></td></tr></table></figure><p>当存在ENTRYPOINT后，CMD的内容将会作为参数传给ENTRYPOINT,而 <code>-i</code>就是新的CMD,因此会作为参数传给curl。</p><h6 id="场景二：应用运行前的准备工作"><a href="#场景二：应用运行前的准备工作" class="headerlink" title="场景二：应用运行前的准备工作"></a>场景二：应用运行前的准备工作</h6><p>启动容器就是启动主进程，有时候在启动主进程前，需要一些准备工作。</p><p>例如mysql类的数据库，需要一些数据库配置、初始化工作，这些工作要在mysql服务器运行前解决。</p><p>另外，希望避免使用root用户去启动服务，从而提高安全性，而在启动前还需要以root身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其他命令依旧可以使用root身份执行，方便调试。</p><p>这些准备工作与容器CMD无关的，无论CMD为什么，都需要事先进行一个预处理的工作，这种情况可以写一个脚本，放入到ENTRYPOINT中去执行，而这个脚本也会将接收到的参数也就是CMD的命令作为命令，在脚本最后执行，官方镜像redis就是这样做的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:3.4</span><br><span class="line">...</span><br><span class="line">RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis</span><br><span class="line">...</span><br><span class="line">ENTRYPOINT [<span class="string">"docker-entrypoint.sh"</span>]</span><br><span class="line"></span><br><span class="line">EXPOSE 6379</span><br><span class="line">CMD [<span class="string">"redis-server"</span>]</span><br></pre></td></tr></table></figure><p>可以看到为了redis服务创建redis用户，并在最后指定了ENTRYPOINT为docker-entrypoint.sh脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> !/bin/sh</span></span><br><span class="line">..</span><br><span class="line"><span class="meta">#</span><span class="bash"> allow the container to be started with <span class="string">'--user'</span></span></span><br><span class="line">if ["$1"='redis-server' -a "$(id-u)"='0'];then</span><br><span class="line">chown -R redis .</span><br><span class="line">exec su-exec redis "$0" "$@"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exec "$@"</span><br></pre></td></tr></table></figure><p>脚本的内容根据CMD的内容来判断如果是redis-server就切换到redis用户身份去启动服务器，否则使用root身份执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it redis id</span><br><span class="line">uid=0(root) git=0(root) groups=0(root)</span><br></pre></td></tr></table></figure><h5 id="ENV设置环境变量"><a href="#ENV设置环境变量" class="headerlink" title="ENV设置环境变量"></a>ENV设置环境变量</h5><p>格式：</p><ul><li>ENV<code>&lt;key&gt;&lt;value&gt;</code></li><li>ENV<code>&lt;key1&gt;=&lt;value&gt; &lt;key2&gt;=&lt;value2&gt;</code></li></ul><p>设置环境变量，无论是后面的其他指令RUN，还是运行时的引用，都可以直接使用这里定义的环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENV VERSION=1.0 DEBUG=on \</span><br><span class="line">NAME=<span class="string">"Happy Feet"</span></span><br><span class="line"><span class="comment"># 换行符以及当有空格的值用双引号括起来</span></span><br></pre></td></tr></table></figure><p>定义了环境变量，在后续的指令里面就可以使用这个环境变量，比如官方node镜像Dockerfile中妈就有类似这样的代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line">RUN curl -SLO <span class="string">"https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz"</span> \</span><br><span class="line">  &amp;&amp; curl -SLO <span class="string">"https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc"</span> \</span><br><span class="line">  &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span><br><span class="line">  &amp;&amp; grep <span class="string">" node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz\$"</span> SHASUMS256.txt | sha256sum -c - \</span><br><span class="line">  &amp;&amp; tar -xJf <span class="string">"node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz"</span> -C /usr/<span class="built_in">local</span> --strip-components=1 \</span><br><span class="line">  &amp;&amp; rm <span class="string">"node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz"</span> SHASUMS256.txt.asc SHASUMS256.txt \</span><br><span class="line">  &amp;&amp; ln -s /usr/<span class="built_in">local</span>/bin/node /usr/<span class="built_in">local</span>/bin/nodejs</span><br></pre></td></tr></table></figure><p>定义了NODE_VERSION环境变量，其后RUN这层，多次使用<code>$NODE_VERSION</code>来进行操作定制。可以看到，升级镜像构建版本的时候，只要更新7.2.0既可，构建维护变得更轻松了</p><p>下列的指令可以支持环境变量展开：</p><p>ADD/COPY/ENV/EXPOSE/LABEL/USER/WORKDIR/VOLUME/STOPSIGNAL/ONBUILD</p><h5 id="ARG构建参数"><a href="#ARG构建参数" class="headerlink" title="ARG构建参数"></a>ARG构建参数</h5><p>格式：ARG<code>&lt;参数名&gt;[=&lt;默认值&gt;]</code></p><p>构建参数和ENV的效果一样，都是设置环境变量，不同的是，ARG所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用ARG保存密码之类的信息，因为docker history还是可以看到所有值的。</p><p>Dockerfile中ARG指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令docker build中用 <code>--build-arg&lt;参数名&gt;=&lt;值&gt;</code>来覆盖。</p><p>在1.13之前的版本，要求 <code>--build-arg</code>中的参数名，必须在Dockerfile中用ARG定义过了，如果没有则会报错退出构建。在1.13之后的版本，只是显示警告信息，并继续构建。这对于使用CI系统，用同样的构建流程构建不同的Dockerfile的时候比较有帮助，避免构建命令必须根据每个Dockerfile的内容修改</p><h5 id="VOLUME定义匿名卷"><a href="#VOLUME定义匿名卷" class="headerlink" title="VOLUME定义匿名卷"></a>VOLUME定义匿名卷</h5><p>格式为：</p><ul><li>VOLUME<code>[&quot;&lt;路径1&gt;&quot;,&quot;路径2&quot;...]</code></li><li>VOLUME<code>&lt;路径&gt;</code></li></ul><p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库需要保存动态数据的应用，其数据库文件应该保存于卷中，为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在Dockerfile中，我们实现指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据</p><blockquote><p>VOLUME /data</p></blockquote><p>这里的 <code>/data</code>目录就会在运行时自动挂载为匿名卷，任何向 <code>/data</code>中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。运行时也可以覆盖这个挂载设置：</p><blockquote><p>docker run -d -v mydata:/data xxx</p></blockquote><p>使用了 mydata这个命令卷挂载到了 <code>/data</code>这个位置，替代了Dockerfile中定义的匿名卷的挂载配置</p><h5 id="EXPOSE声明端口"><a href="#EXPOSE声明端口" class="headerlink" title="EXPOSE声明端口"></a>EXPOSE声明端口</h5><p>格式为：EXPOSE<code>&lt;端口1&gt;[&lt;端口2&gt;...]</code></p><p>EXPOSE指令是声明运行时容器提供服务端口，在运行时并不会因为这个声明应用就会开启这个端口的服务，在Dockerfile中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个好处就是运行时使用随机端口映射时，也就是docker run -P时，会自动随机映射EXPOSE端口</p><p>在早期Docker版本中还有一个特殊用处，以前所有的容器都是运行于默认桥接网络中，因此所有容器互相之间都可以直接访问，这样存在一定的安全性问题。于是有了一个Docker引擎参数 <code>--icc=false</code>，当指定该参数后，容器间将默认无法互访，除非互相使用了<code>--links</code>参数的容器才可以互通，并且只有镜像中EXPOSE所声明的端口才可以被访问。这个 <code>-icc=false</code>的用法在引入了docker network后已经基本不用了，通过自定义网络可以轻松实现容器间的互联与隔离。</p><p>要将 EXPOSE和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code>区分开，<code>-p</code>是映射宿主端口和容器端口，也就是将容器的对应端口服务公开给外界访问，而EXPOSE仅仅是声明容器打算使用什么端口而已，并不会自动在宿舍进行映射。</p><h5 id="WORKDIR指定工作目录"><a href="#WORKDIR指定工作目录" class="headerlink" title="WORKDIR指定工作目录"></a>WORKDIR指定工作目录</h5><p>格式：WORKDIR<code>&lt;工作目录路径&gt;</code></p><p>使用WORKDIR指令可以来指定工作目录（或者称为当前目录），以后各层的目录就被改成指定目录，如该目录不存在，WORKDIR就会帮你建立目录</p><p>错误例子：</p><blockquote><p>RUN cd /app</p><p>RUN echo “hello” &gt; world.txt</p></blockquote><p>把Dockerfile当做Shell脚本来书写，构建镜像运行后，会发现找不到 <code>/app/world.txt</code>文件，或者其内容不是hello.在shell中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响下一个命令；而在Dockerfile中，这两行RUN命令的执行环境根本不同，是两个完全不同的容器，这是对Dockerfile构建分层存储的概念不了解所导致的错误。</p><p>如果需要改变各层的工作目录位置，应该使用WORKDIR指令</p><h5 id="USER指定当前用户"><a href="#USER指定当前用户" class="headerlink" title="USER指定当前用户"></a>USER指定当前用户</h5><p>格式：USER<code>&lt;用户名&gt;</code></p><p>USER指令和WORKDIR相似，都是改变环境并影响以后的层，WORKDIR是改变工作目录，USER则是改变之后层的执行RUN,CMD以及ENTRYPOINT这类命令的身份</p><p>和WORKDIR一样，USER只是帮助切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line">USER redis</span><br><span class="line">RUN [<span class="string">"redis-server"</span>]</span><br></pre></td></tr></table></figure><p>如果以root执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程。不要使用su或者sudo，这些都需要比较麻烦的配置，而且在TTY缺失的环境下经常出错，建议使用 gosu</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 redis用户，并使用 gosu换另一个用户执行命令</span></span><br><span class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line"><span class="comment"># 下载 gosu</span></span><br><span class="line">RUN wget -O /usr/<span class="built_in">local</span>/bin/gosu <span class="string">"http://github.com/tianon/gosu/release/download/1.7/gosu-amd64"</span> \</span><br><span class="line">&amp;&amp; chmod +x /usr/<span class="built_in">local</span>/bin/gosu \</span><br><span class="line">&amp;&amp; gosu nobody <span class="literal">true</span></span><br><span class="line"><span class="comment"># 设置CMD,并以另外的用户执行</span></span><br><span class="line">CMD [<span class="string">"exec"</span>,<span class="string">"gosu"</span>,<span class="string">"redis"</span>,<span class="string">"redis-server"</span>]</span><br></pre></td></tr></table></figure><h5 id="HEALTHCHECK健康检查"><a href="#HEALTHCHECK健康检查" class="headerlink" title="HEALTHCHECK健康检查"></a>HEALTHCHECK健康检查</h5><p>格式：</p><ul><li>HEALTHCHECK <code>[选项] CMD &lt;命令&gt;</code>，设置检查容器健康状态的命令</li><li>HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽其健康检查指令。</li></ul><p>在没有HEALTHCHECK指令前，Docker引擎只可以通过容器内主进程是否退出来判断容器是否状态异常，很多情况下没问题，但是如果程序进入死锁状态，或者死循环，应用程序不会退出，但是该容器已经无法提供服务了。在1.12前，Docker不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务却还在接受用户请求。</p><p>在1.12之后，Docker提供了这个指令，通过改指令指定一行命令，用这行命令来判断容器主进程服务状态是否还正常，从而比较真实的反应容器实际状态。</p><p>当在一个镜像指定了HEALTHCHECK指令后，用其启动容器，初始状态为starting，在HEALTHCHECK指令检查成功后变为healthy，如果连续一定次数失败，则会变为unhealthy</p><p>支持系列选项：</p><blockquote><p>–interval=&lt;间隔&gt;：两次健康检查的间隔，默认为30s</p><p>–timeout=&lt;时长&gt;：健康检查命令运行超时时间，如果超过这个时间，本次健康检查视为失败，默认30s</p><p>–retries=&lt;次数&gt;：当连续失败指定次数后，则容器状态为unhealthy，默认3次</p></blockquote><p>和CMD/ENTRYPOINT一样，HEALTHYCHECK只出现一次，如果写了多个，只有最后一个生效。</p><p>在<code>HEALTHYCHECK [选项] CMD</code>后面命令，格式和ENTRYPOINT一样，分为shell，和exec。命令的返回值决定了该次健康检查的成功与否：0为成功1是失败，2保留，不要使用这个值</p><p>假设我们有个镜像简单的Web服务，希望增加健康检查判断Web服务是否正常工作，用curl判断，dockerfile可以这么写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx </span><br><span class="line">RUN agt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">HEALTHYCHECK --interval=5s --timeout=3s \</span><br><span class="line">CMD curl -fs http://localhost/ || <span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure><p>设置了每5秒检查一次，如果健康检查超过3秒没响应就是视为失败。构建并启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myweb:v1</span><br><span class="line">docker run -d --name web -p 80:80 myweb:v1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看状态</span></span><br><span class="line">docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                            PORTS               NAMES</span><br><span class="line">03e28eb00bd0        myweb:v1            "nginx -g 'daemon off"   3 seconds ago       Up 2 seconds (health: starting)   80/tcp, 443/tcp     web</span><br><span class="line"><span class="meta">#</span><span class="bash"> 等待几秒后再查看，发现健康状态变成了healthy,如果健康检查连续失败超过重试次数，状态就为unhealthy</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为帮助排障，健康检查命令的输出stdout/stderr等都会被存储在健康状态，可用docker inspect查看</span></span><br><span class="line">docker inspect --format‘&#123;&#123;json .State.Health&#125;&#125;’ web | python -m json.tool</span><br><span class="line">&#123;</span><br><span class="line">    "FailingStreak": 0,</span><br><span class="line">    "Log": [</span><br><span class="line">        &#123;</span><br><span class="line">            "End": "2016-11-25T14:35:37.940957051Z",</span><br><span class="line">            "ExitCode": 0,</span><br><span class="line">            "Output": "&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n&lt;style&gt;\n    body &#123;\n        width: 35em;\n        margin: 0 auto;\n        font-family: Tahoma, Verdana, Arial, sans-serif;\n    &#125;\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;/p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href=\"http://nginx.org/\"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;\nCommercial support is available at\n&lt;a href=\"http://nginx.com/\"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n",</span><br><span class="line">            "Start": "2016-11-25T14:35:37.780192565Z"</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    "Status": "healthy"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ONBUILD为他人做嫁衣裳"><a href="#ONBUILD为他人做嫁衣裳" class="headerlink" title="ONBUILD为他人做嫁衣裳"></a>ONBUILD为他人做嫁衣裳</h5><p>格式：ONBUILD<code>&lt;其他指令&gt;</code></p><p>ONBUILD是一个特殊的指令，后面跟着的是其他指令，例如RUN/COPY等，而这些指令，在当前镜像构建时不会被执行，只有当以当前镜像为基础，去构建下一个镜像才会执行</p><p>Dockerfile中的其他指令都是为了定制当前镜像而准备的，ONBUILD是为了帮助别人定制自己准备的。Nodejs使用npm管理，拿到程序后，一般会先安装依赖，然后启动，一般会这么写Dockerfile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim</span><br><span class="line">RUN mkdir /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY ./package.json /app</span><br><span class="line">RUN [<span class="string">"npm"</span>,<span class="string">"install"</span>]</span><br><span class="line">COPY . /app/</span><br><span class="line">CMD [<span class="string">"npm"</span>,<span class="string">"start"</span>]</span><br></pre></td></tr></table></figure><p>把这个Dockerfile放到Nodejs的根目录，构建好镜像后，就可以直接拿来启动容器运行，但是如果有第二个第三个差不多的项目，随着文件附件越多，版本控制就越难。</p><p>如果在第一个Nodejs项目发现了Dockerfile存在的问题，比如敲错字，或者需要安装额外的包，然后开发人员修复了这个Docker，再次构建，问题解决。但是其他项目呢？虽然最初Dockerfile是复制、粘贴自第一个项目，但是并不会因为第一个项目修复了Dockerfile就会自动修复</p><p>那么我们可以做一个基础镜像，然后各个项目使用这个基础镜像。镜像更新后就不用同步Dockerfile的变化，重新构建后就继续了基础镜像的更新：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim</span><br><span class="line">RUN mkdir /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">CMD [<span class="string">"npm"</span>,<span class="string">"start"</span>]</span><br></pre></td></tr></table></figure><p>这里把项目相关的构建指令拿出来，放在子项目去。假设这个基础镜像为my-node，各个项目内的Dockerfile就变成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM my-node</span><br><span class="line">COPY ./package.json /app</span><br><span class="line">RUN [<span class="string">"npm"</span>,<span class="string">"install"</span>]</span><br><span class="line">COPY . /app/</span><br></pre></td></tr></table></figure><p>基础镜像变化后，各个项目都用这个Dockerfile重新构建镜像，会基础基础镜像的更新。</p><p>但是问题并没有完全解决，这个Dockerfile如果有东西要修改，又要重新一个一个修改。这样制作镜像只解决了原来Dockerfile的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理</p><p>ONBUILD可以解决这个问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim</span><br><span class="line">RUN mkdir /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">ONBUILD COPY ./package.json /app</span><br><span class="line">ONBUILD RUN [<span class="string">"npm"</span>,<span class="string">"install"</span>]</span><br><span class="line">ONBULD COPY . /app/</span><br><span class="line">CMD [<span class="string">"npm"</span>,<span class="string">"start"</span>]</span><br></pre></td></tr></table></figure><p>在构建镜像的时候，这三行并不会被执行，然后各个项目的Dockerfile就变成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM my-node</span><br></pre></td></tr></table></figure><p>当在各个项目目录中，用这个只有一行的Dockerfile构建镜像时，之前基础镜像的那三行ONBUILD就会执行，成功的将当前项目的代码复制进镜像，并且针对本项目进行npm install，生成对应镜像</p><h4 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h4><p>在17.05之前，构建Docker镜像通常会采用两种方式</p><h5 id="全部放入一个Dockerfile"><a href="#全部放入一个Dockerfile" class="headerlink" title="全部放入一个Dockerfile"></a>全部放入一个Dockerfile</h5><p>一种方式是将所有的构建过程编包含在一个Dockerfile中，包括项目以及依赖库的编译、测试、打包等流程，这里可能会有一些问题：</p><ul><li>Dockerfile特别长，可维护性降低</li><li>镜像层次多，镜像体积较大，部署时间变长</li><li>源代码存在泄漏的问题</li></ul><p>例如：编写app.go文件，输出Hello World!</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line">function main()&#123;</span><br><span class="line">    fmt.Printf(<span class="string">'Hello World!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写Dockerfile.one文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.9-alpine</span><br><span class="line">RUN apk --no-cache add got ca-certificates</span><br><span class="line">WORKDIR /go/src/github.com/go/helloworld/</span><br><span class="line">COPY app.go .</span><br><span class="line">RUN go get -d -v github.com/go-sql-driver/mysql \</span><br><span class="line">&amp;&amp; CGO_ENABLED=0 GOOS=linux go buld -a -installsuffix cgo -o app . \</span><br><span class="line">&amp;&amp; cp /go/src/github.com/go/helloworld/app/root</span><br><span class="line"></span><br><span class="line">WORKDIR /root/</span><br><span class="line">CMD [<span class="string">"./app"</span>]</span><br></pre></td></tr></table></figure><p>构建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t go/helloworld:1 -f Dockerfile.one</span><br></pre></td></tr></table></figure><h5 id="分割到多个Dockerfile"><a href="#分割到多个Dockerfile" class="headerlink" title="分割到多个Dockerfile"></a>分割到多个Dockerfile</h5><p>另一种方式，就是事先在一个Dockerfile将项目以及其依赖库编译测试打包好后，再将其拷贝到运行环境中，这种方式需要编写两个Dockerfile和一些编译脚本才能将两个阶段自动整合起来，这种方式虽然可以很好规避第一种方式存在的风险，但明显部署过程比较复杂</p><p>Dockerfile.build文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.9-alpine</span><br><span class="line">RUN apk --no-cache add git</span><br><span class="line">WORKDIR /go/src/github.com/go/helloworld</span><br><span class="line">COPY app.go .</span><br><span class="line">RUN go get -d -v github.com/go-sql-driver/mysql \</span><br><span class="line">  &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br></pre></td></tr></table></figure><p>Dockerfile.copy文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:latest</span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR /root/</span><br><span class="line">COPY app .</span><br><span class="line">CMD [<span class="string">"./app"</span>]</span><br></pre></td></tr></table></figure><p>新建build.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">echo Building go/helloworld:build</span><br><span class="line"></span><br><span class="line">docker build -t go/helloworld:build . -f Dockerfile.build</span><br><span class="line"></span><br><span class="line">docker create --name extract go/helloworld:build</span><br><span class="line">docker cp extrace:go/src/github.com/go/helloworld/app ./app</span><br><span class="line">docker rm -f extract</span><br><span class="line"></span><br><span class="line">echo Building go/helloworld:2</span><br><span class="line"></span><br><span class="line">docker build --no-cache -t go/helloworld:2 -f Dockerfile.copy </span><br><span class="line">rm ./app</span><br></pre></td></tr></table></figure><p>运行脚本即可构建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x build.sh</span><br><span class="line">./build.sh</span><br></pre></td></tr></table></figure><p>对比两种生成的镜像大小</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br><span class="line"></span><br><span class="line">REPOSITORY      TAG    IMAGE ID        CREATED         SIZE</span><br><span class="line">go/helloworld   2      f7cf3465432c    22 seconds ago  6.47MB</span><br><span class="line">go/helloworld   1      f55d3e16affc    2 minutes ago   295MB</span><br></pre></td></tr></table></figure><h5 id="使用多阶段构建"><a href="#使用多阶段构建" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h5><p>为了解决以上的问题，17.05后开始支持多阶段构建（multistage builds）,使用多阶段构建可以解决上面的问题，并只需要编写一个Dockerfile：</p><p>例如：</p><p>编写Dockerfile文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.9-alpine as builder</span><br><span class="line">RUN apk --no-cache add git</span><br><span class="line">WORKDIR /go/src/github.com/go/helloworld/</span><br><span class="line">RUN go get -d -v github.com/go-sql-driver/mysql</span><br><span class="line">COPY app.go .</span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a installsuffix cgo -o app</span><br><span class="line">FROM alpine:latest as prod</span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR /root/</span><br><span class="line">COPY --from=0 /go/src/github.com/go/helloworld/app .</span><br><span class="line">CMD [<span class="string">"./APP"</span>]</span><br></pre></td></tr></table></figure><p>构建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t go/helloworld:3 .</span><br></pre></td></tr></table></figure><p>对比三个镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br><span class="line"></span><br><span class="line">REPOSITORY        TAG   IMAGE ID         CREATED            SIZE</span><br><span class="line">go/helloworld     3     d6911ed9c846     7 seconds ago      6.47MB</span><br><span class="line">go/helloworld     2     f7cf3465432c     22 seconds ago     6.47MB</span><br><span class="line">go/helloworld     1     f55d3e16affc     2 minutes ago      295MB</span><br></pre></td></tr></table></figure><p>很明显使用多阶段构建的镜像体积小，同时也解决了上边的问题</p><h5 id="只构建一阶段的镜像"><a href="#只构建一阶段的镜像" class="headerlink" title="只构建一阶段的镜像"></a>只构建一阶段的镜像</h5><p>使用as为某一阶段命令，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.9-alpine as builder</span><br></pre></td></tr></table></figure><p>只构建builder阶段的镜像，可以在使用 docker build的时候加上<code>--target</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --target builder -t username/imagename:tag .</span><br></pre></td></tr></table></figure><h5 id="构建时从其他镜像复制文件"><a href="#构建时从其他镜像复制文件" class="headerlink" title="构建时从其他镜像复制文件"></a>构建时从其他镜像复制文件</h5><p>上面的例子使用 <code>COPY --from=0 /go/src/github.com/go/helloworld/app .</code>从上一阶段的镜像中复制文件，我们可以复制任意镜像中的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY --from=nginx:latest /ect/nginx/nginx.conf /nginx.conf</span><br></pre></td></tr></table></figure><h4 id="其他制作镜像的方式"><a href="#其他制作镜像的方式" class="headerlink" title="其他制作镜像的方式"></a>其他制作镜像的方式</h4><h5 id="从rootfs压缩包导入"><a href="#从rootfs压缩包导入" class="headerlink" title="从rootfs压缩包导入"></a>从rootfs压缩包导入</h5><p>格式：<code>docker import [选项] &lt;文件&gt;|&lt;URL&gt;|- [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></p><p>压缩包可以是本地文件，远程Web文件，甚至是从标准输入中得出的，压缩包就会在镜像 <code>/</code>目录展开，并直接作为镜像第一层提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个OpenVZ的Ubuntu14.04模板的镜像：</span></span><br><span class="line">docker import \</span><br><span class="line">http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz \</span><br><span class="line">    openvz/ubuntu:14.04</span><br><span class="line">Downloading from http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz</span><br><span class="line">sha256:f477a6e18e989839d25223f301ef738b69621c4877600ae6467c4e5289822a79B/78.42 MB</span><br></pre></td></tr></table></figure><p>这条命令自动下载了 <code>ubuntu-14.04-x86_64-minimal.tar.gz</code> 文件，并且作为根文件系统展开导入，并保存为镜像 <code>openvz/ubuntu:14.04</code></p><p>导入成功后，使用 docker image ls可以看到这个导入的镜像</p><p>看到历史会看到描述中有导入的文件链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">history</span> openvz/ubuntu:14.04</span></span><br><span class="line">IMAGE               CREATED              CREATED BY          SIZE                COMMENT</span><br><span class="line">f477a6e18e98        About a minute ago                       214.9 MB            Imported from http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz</span><br></pre></td></tr></table></figure><h5 id="docker-save和docker-load"><a href="#docker-save和docker-load" class="headerlink" title="docker save和docker load"></a>docker save和docker load</h5><p>将镜像保存为一个tar文件，然后传输到另外一个位置，再加载进来。这是在没有Docker Registry的做法，现在已不推荐。镜像迁移直接使用Docker Registry，无论是直接使用Docker Hub还是使用内网私有Registry都可以</p><p><strong>保存镜像</strong></p><p>docker save将镜像保存为归档文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save alpine | gzip &gt; alpine-latest.tar.gz</span><br></pre></td></tr></table></figure><p>然后将它复制到另外一个机器上，用下面的命令加载镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker load -i alpine-latest.tar.gz</span><br><span class="line">Loaded image: alpine:latest</span><br></pre></td></tr></table></figure><p>结合这两个命令和ssh甚至是pv，利用Linux管道可以写一个命令完成从一个机器将镜像迁移到另外一个机器，并且带进度条的功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save &lt;镜像名&gt; | bzip2 | pv |ssh &lt;用户名&gt;@&lt;主机名&gt; 'cat|docker load'</span><br></pre></td></tr></table></figure><h4 id="镜像实现的原理"><a href="#镜像实现的原理" class="headerlink" title="镜像实现的原理"></a>镜像实现的原理</h4><p>Docker镜像是怎么实现增量的修改和维护的？</p><p>每个镜像都由多层次构成，Docker使用Union FS将这些不同层结合到一个镜像中去。</p><p>通常Union FS有两个用途，一方面可以实现不借助LVM,RAID将多个disk挂在同一个目录下，另一个更常用的就是讲一个只读的分支和一个可写的分支联合在一起。</p><h2 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h2><p>简单来说，容器似乎运行的一个或一组应用，以及它们的运行态环境，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用</p><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。因为Docker的容器很轻级，用户可以随时删除和新建容器。</p><h4 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出Hello World后终止容器</span></span><br><span class="line">docker run ubuntu:14.04 /bin/echo 'Hello world'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动一个bash终端，允许用户进行交互,-t选项让Docker分配一个伪终端pseudo-tty并绑定到容器的标准输入上，-i则让容器的标准输入保持打开。在交互模式下，用户可以通过所创建的终端来输入命令</span></span><br><span class="line">docker run -t -i ubuntu:14.04 /bin/bash</span><br></pre></td></tr></table></figure><p>当利用 docker run来创建容器时，Docker在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从共有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个ip地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h4 id="启动已终止的容器"><a href="#启动已终止的容器" class="headerlink" title="启动已终止的容器"></a>启动已终止的容器</h4><p>docker container start命令可以将一个已经终止的容器启动运行。</p><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的，除此之外没有其他资源。可以在伪终端中利用ps或top来查进程信息</p><h4 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h4><p>更多时候，需要让Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。可以通过添加 <code>-d</code>参数实现。</p><p>不用 <code>-d</code>参数运行容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run ubuntu:17.10 /bin/sh -c "while true;do echo hello world;sleep 1;done"</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>容器会把输出结果stdout打印到宿主主机上面</p><p>如果使用了 <code>-d</code>参数运行容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d ubuntu:17.10 /bin/sh -c "while true;do echo hello world; sleep 1;done"</span><br><span class="line">77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a</span><br></pre></td></tr></table></figure><p>此时容器会在后台运行并不会把输出结果打印到宿主机上面（输出结果可以用docker logs查看）。</p><p>注：容器是否会长久运行，和 docker run 指令的命令有关，和 <code>-d</code>参数无关。</p><p>使用 <code>-d</code>参数启动后返回一个唯一的id，可以通过 docker container ls命令来查看容器信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker container ls</span><br><span class="line">CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES</span><br><span class="line">77b2dc01fe0f  ubuntu:17.10  /bin/sh -c 'while tr  2 minutes ago  Up 1 minute        agitated_wright</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 docker icontainer logis获取容器的输出信息</span></span><br><span class="line">docker container logs[container ID or NEWS]</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h4 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h4><p>使用 docker container stop 来终止一个运行中的容器</p><p>当Docker 容器中指定的应用终结时，容器也会自动终止。上面只启动了一个容器，用户可以通过exit或者ctrl+d来推出终端，所创建的容器立刻终止。</p><p>终止状态的容器可以使用 docker containers ls -a命令看到例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">ba267838cc1b        ubuntu:14.04             "/bin/bash"            30 minutes ago      Exited (0) About a minute ago                       trusting_newton</span><br><span class="line">98e5efa7d997        training/webapp:latest   "python app.py"        About an hour ago   Exited (0) 34 minutes ago                           backstabbing_pike</span><br></pre></td></tr></table></figure><p>然后通过 docker run restart命令会让一个运行态的容器终止，然后再重新启动它。</p><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>使用 <code>-d</code>参数时，容器启动后会进入后台。某些时候需要进入容器操作，包括docker attch命令或docker exec命令，推荐使用docker exec</p><h4 id="attch命令"><a href="#attch命令" class="headerlink" title="attch命令"></a>attch命令</h4><p>docker attch是Docker自带命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit ubuntu</span><br><span class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</span><br><span class="line"></span><br><span class="line">docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">243c32535da7        ubuntu:latest       "/bin/bash"         18 seconds ago      Up 17 seconds                           nostalgic_hypatia</span><br><span class="line"></span><br><span class="line">docker attach 243c</span><br><span class="line">root@243c32535da7:/#</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果从这个stdin中<span class="built_in">exit</span>，会导致容器的停止</span></span><br></pre></td></tr></table></figure><h4 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a>exec命令</h4><p><strong>-i -t参数</strong></p><p>docker exec可以跟多个参数</p><p>只用 <code>-i</code>参数时，由于没有分配伪终端，界面没有Linux命令符，但命令执行结果仍然可以返回</p><p>当 <code>-i</code>/<code>-t</code>参数一起使用时，可以看到Linux命令提示符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit ubuntu</span><br><span class="line">69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6</span><br><span class="line"></span><br><span class="line">docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">69d137adef7a        ubuntu:latest       "/bin/bash"         18 seconds ago      Up 17 seconds                           zealous_swirles</span><br><span class="line"></span><br><span class="line">docker exec -i 69d1 bash</span><br><span class="line">ls </span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">docker exec -it 69d1 bash</span><br><span class="line">root@xxx:/#</span><br></pre></td></tr></table></figure><p>如果从这个stdin中exit，不会导致容器的停止。这就是为什么推荐使用 docker exec的原因</p><h3 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h3><h4 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES</span><br><span class="line">7691a814370e        ubuntu:14.04        "/bin/bash"         36 hours ago        Exited (0) 21 hours ago                       test</span><br><span class="line"></span><br><span class="line">docker export  7691a814370e &gt; ubuntn.tar</span><br><span class="line"><span class="meta">#</span><span class="bash">这样导出容器快照到本地文件</span></span><br></pre></td></tr></table></figure><h4 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker import 从容器快照文件中再导入为镜像</span></span><br><span class="line">cat ubuntu.tar | docker import - test/ubuntu:v1.0</span><br><span class="line">docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE</span><br><span class="line">test/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定URL或者某个目录来录入</span></span><br><span class="line">docker import http://example.com/exampleimage.tgz example/imagerepo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者区别在于容器快照文件将丢弃所有历史记录和元数据信息（即保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大，此外，从容器快照文件导入时可以重新制定标签等元数据信息</span></span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container rm haha</span><br><span class="line">haha</span><br></pre></td></tr></table></figure><p>删除一个运行中的容器，可以添加 <code>-f</code>，Docker会发送 <code>SIGKILL</code>信号给容器</p><p>清理所有处于终止状态的容器:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure><h2 id="访问仓库"><a href="#访问仓库" class="headerlink" title="访问仓库"></a>访问仓库</h2><p>仓库Repository是集中存放镜像的地方。</p><p>一个容易混淆的概念是注册服务器（Registry）。实际上注册服务器是管理仓库的具体服务器，每个服务器可以有多个仓库，而每个仓库下面可以有多个镜像。从这方面来说，仓库被认为是一个具体的项目或者目录。例如对于 仓库地址<code>dl.dockerpool.com/ubuntu</code>来说，<code>dl.dockerpool.com</code>是注册服务器地址，<code>ubuntu</code>是仓库名。大部分时候并不需要严格区分这两者的概念</p><h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><p>Docker官方维护了一个公共仓库Docker Hub，大部分需求可以在Docker Hub中直接下载镜像实现</p><p>在 <a href="https://cloud.docker.com">https://cloud.docker.com</a> 免费注册一个 Docker 账号，通过docker login命令交互式输入用户名和密码完成在命令行登录，docker logout退出登录。</p><p>docker search命令查找官方仓库镜像，利用 docker pull命令将它下载到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> centos为关键词</span></span><br><span class="line">docker search centos</span><br><span class="line">NAME                                            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">centos                                          The official build of CentOS.                   465       [OK]</span><br><span class="line">tianon/centos                                   CentOS 5 and 6, created using rinse instea...   28</span><br><span class="line">blalor/centos                                   Bare-bones base CentOS 6.5 image                6                    [OK]</span><br><span class="line">saltstack/centos-6-minimal                                                                      6                    [OK]</span><br><span class="line">tutum/centos-6.4                                DEPRECATED. Use tutum/centos:6.4 instead. ...   5                    [OK]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以看到返回包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建、是否自动创建。官方的镜像说明是官方项目组创建和维护的，automated资源允许用户验证镜像的来源和内容。根据是否官方提供，资源镜像可以分为两种：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一种是类centor这样的镜像，被称为基础镜像或根镜像。这些基础镜像由Docker公司创建、验证、支持、提供。这样的镜像往往使用单个名词作为名字</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 还有一种类型，比如tianon/centos镜像，由Docker用户创建并维护的，往往带有用户名称前缀，可以通过前缀username/来指定某个用户名提供的镜像，比如tianon用户</span></span><br></pre></td></tr></table></figure><p>查找的时候通过 <code>--filter=stars=N</code>参数可以指定仅显示收藏数量为N以上的镜像</p><h4 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h4><p>用户登录后通过docker push推送自己的镜像到Docker Hub。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> username替换为Docker 账户用户名</span></span><br><span class="line">docker tag ubuntu:17.10 username/ubuntu:17.10</span><br><span class="line"></span><br><span class="line">docker image ls</span><br><span class="line">REPOSITORY                                               TAG                    IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu                                                   17.10                  275d79972a86        6 days ago          94.6MB</span><br><span class="line">username/ubuntu                                          17.10                  275d79972a86        6 days ago          94.6MB</span><br><span class="line"></span><br><span class="line">docker push username/ubuntu:17.10</span><br><span class="line"></span><br><span class="line">docker search username</span><br><span class="line">NAME                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">username/ubuntu</span><br></pre></td></tr></table></figure><h4 id="自动创建"><a href="#自动创建" class="headerlink" title="自动创建"></a>自动创建</h4><p>Automated Builds功能对于需要经常升级镜像内程序来说，十分方便。</p><p>用户创建了镜像，安装了某个软件，如果软件发布新版本则需要手动更新镜像。而自动创建运行用户通过Docker Hub指定一个跟踪网站上的项目，Github/BitBucket等，一旦项目发生新的提交或者创建新的标签，Docker Hub会自动构建镜像并推送到 Docker Hub中</p><p>配置自动创建，有几个步骤：</p><ul><li>创建并登陆Docker Hub，以及目标网站</li><li>在目标网站中连接账户到Docker Hub</li><li>在Docker Hub中配置一个自动创建</li><li>选取一个目标网站的项目（需含有Dockerfile）和分支</li><li>指定Dockerfile的位置，并提交创建</li></ul><p>之后可以在Docker Hub的自动创建页面中跟踪每次创建的状态</p><h3 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h3><p>用户可以创建一个本地仓库供私人使用</p><p>docker-registry是官方提供的工具，用户构建私有镜像库</p><h4 id="安装docker-registry"><a href="#安装docker-registry" class="headerlink" title="安装docker-registry"></a>安装docker-registry</h4><p>通过官方registry镜像来运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart=always --name registry registry</span><br></pre></td></tr></table></figure><p>这将使用官方的registry镜像来启动私有仓库，默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code>目录下，可以通过<code>-v</code>参数指定镜像文件存在本地的指定路径。例如下面的例子将上传的镜像放到本地的<code>/opt/data/registry</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 5000:5000</span><br><span class="line">-v /opt/data/registry:/var/lib/registry \</span><br><span class="line">registry</span><br></pre></td></tr></table></figure><h4 id="上传、搜索、下载"><a href="#上传、搜索、下载" class="headerlink" title="上传、搜索、下载"></a>上传、搜索、下载</h4><p>创建好私有仓库后，可以使用docker tag来标记一个镜像，然后将它推送到仓库，例如私有仓库地址为 <code>127.0.0.1:5000</code>,现在本机已有的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure><p>docker tag将 ubuntu:latest镜像标记为 <code>127.0.0.1:5000/ubuntu/:latest</code>，格式为：</p><blockquote><p>docker tag IMAGE[:TAG] [REGISTRT_HOST[:REGISTRY_PROT]/]REGISTORY[:TAG]</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">docker image ls</span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br><span class="line">127.0.0.1:5000/ubuntu:latest      latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure><p>docker push上传标记的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker push 127.0.0.1:5000/ubtuntu:latest</span><br><span class="line">The push refers to repository [127.0.0.1:5000/ubuntu]</span><br><span class="line">373a30c24545: Pushed</span><br><span class="line">a9148f5200b0: Pushed</span><br><span class="line">cdd3de0940ab: Pushed</span><br><span class="line">fc56279bbb33: Pushed</span><br><span class="line">b38367233d37: Pushed</span><br><span class="line">2aebd096e0e2: Pushed</span><br><span class="line">latest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568</span><br></pre></td></tr></table></figure><p>curl查看仓库中的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1:5000/v2/_catalog</span><br><span class="line">&#123;"repositories":["ubuntu"]&#125;</span><br></pre></td></tr></table></figure><p>删除已有的镜像从私有仓库下载镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker image rm 127.0.0.1:5000/ubuntu:latest</span><br><span class="line"></span><br><span class="line">docker pull 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">Pulling repository 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">ba5877dc9bec: Download complete</span><br><span class="line">511136ea3c5a: Download complete</span><br><span class="line">9bad880da3d2: Download complete</span><br><span class="line">25f11f5fb0cb: Download complete</span><br><span class="line">ebc34468f71d: Download complete</span><br><span class="line">2318d26665ef: Download complete</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br><span class="line">REPOSITORY                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">127.0.0.1:5000/ubuntu:latest       latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果不想使用 <code>127.0.0.1:5000</code> 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。得把例如 <code>192.168.199.100:5000</code> 这样的内网地址作为私有仓库地址，这时会发现无法成功推送镜像。</p><p>这是因为 Docker 默认不允许非 <code>HTTPS</code> 方式推送镜像。通过 Docker 的配置选项来取消这个限制.</p><h4 id="Ubuntu-14-04-Debian-7-Wheezy"><a href="#Ubuntu-14-04-Debian-7-Wheezy" class="headerlink" title="Ubuntu 14.04, Debian 7 Wheezy"></a>Ubuntu 14.04, Debian 7 Wheezy</h4><p>对于使用 <code>upstart</code> 的系统而言，编辑 <code>/etc/default/docker</code> 文件，在其中的 <code>DOCKER_OPTS</code> 中增加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS=<span class="string">"--registry-mirror=https://registry.docker-cn.com --insecure-registries=192.168.199.100:5000"</span></span><br></pre></td></tr></table></figure><p>重新启动服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service docker restart</span><br></pre></td></tr></table></figure><h4 id="Ubuntu-16-04-Debian-8-centos-7"><a href="#Ubuntu-16-04-Debian-8-centos-7" class="headerlink" title="Ubuntu 16.04+, Debian 8+, centos 7"></a>Ubuntu 16.04+, Debian 8+, centos 7</h4><p>对于使用 <code>systemd</code> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在新建该文件）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirror"</span>: [</span><br><span class="line">    <span class="string">"https://registry.docker-cn.com"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"insecure-registries"</span>: [</span><br><span class="line">    <span class="string">"192.168.199.100:5000"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：该文件必须符合 <code>json</code> 规范，否则 Docker 将不能启动。</p></blockquote><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>对于 Docker for Windows 、 Docker for Mac 在设置中编辑 <code>daemon.json</code> 增加和上边一样的字符串即可。</p><h3 id="私有仓库高级配置"><a href="#私有仓库高级配置" class="headerlink" title="私有仓库高级配置"></a>私有仓库高级配置</h3><p>利用Docker Compose 搭建一个拥有权限认证、TLS的私有仓库。新建一个文件夹，以下步骤在该文件夹镜像</p><h4 id="准备站点证书"><a href="#准备站点证书" class="headerlink" title="准备站点证书"></a>准备站点证书</h4><p>国内各大云服务商提供免费的站点证书，也可以使用openssl自行签发证书。假设要搭建的私有仓库地址为<code>docker.domain.com</code>，使用openssl自行签发docker.domain.com的站点SSL证书</p><p>第一步创建CA私钥</p><blockquote><p>openssl genrsa -out “root-ca.key” 4096</p></blockquote><p>第二步利用私钥创建CA根证书请求文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">openssl req \</span><br><span class="line">-new -key "root-ca.key" \</span><br><span class="line">-out "root-ca.ssr" -sha256 \ </span><br><span class="line">-subj '/C=CN/ST/Shanxi/L=Datong/O=Your Company Name Name/CN=Your Company Name Docker Registry CA'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -subj参数里面的/C代表国家，/ST表示省，/L表示城市或者地区，/O表示组织名，/CN通用名称</span></span><br></pre></td></tr></table></figure><p>第三步创建CA根证书新建root-ca.cnf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root_ca]</span><br><span class="line">basicConstrains = critical,CA:TRUE,pathlen:1</span><br><span class="line">keyUsage = critical,nonRepudiation,cRLSign,keyCertSign</span><br><span class="line">subjectKetIdentifier=hash</span><br></pre></td></tr></table></figure><p>第四步签发根证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 3650 -in "root-ca.csr" \</span><br><span class="line"> -signkey "root-ca.key" -sha256 -out "root-ca.crt" \</span><br><span class="line"> -extfile "root-ca.cnf" -extensions \</span><br><span class="line"> root_ca</span><br></pre></td></tr></table></figure><p>第五步生成站点SSL私钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out "docker.domain.com.key" 4096</span><br></pre></td></tr></table></figure><p>第六步使用私钥生成证书请求文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key "docker.domain.docm.key" -out "site.csr" -sha256 \</span><br><span class="line">-subject '/C=CN/ST=ShanXi/L=Datong/O=Your Company Name/CN=docker.domain.com'</span><br></pre></td></tr></table></figure><p>第七步配置证书，新建site.cnf文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">authorityKeyIdentifier=keyid,issuer</span><br><span class="line">basicConstraints = critilcal,CA:FALSE</span><br><span class="line">extendedKeyUsage=serverAuth</span><br><span class="line">KeyUsage = critical,digitalSignature,keyEncipherment</span><br><span class="line">subjectAltName = DNS:docker.domain.com,IP:127.0.0.1</span><br><span class="line">subjectKeyIdentifier=hash</span><br></pre></td></tr></table></figure><p>第八步签署站点SSL证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 750 -in "site.csr" -sha256 \</span><br><span class="line">-CA "root-ca.crt" -CAkey "root-ca.key" -CAcreateserial \</span><br><span class="line">-out "docker.domain.com.crt" -extfile "site.cnf" -extensions server</span><br></pre></td></tr></table></figure><p>这样就拥有了<code>docker.domain.com</code>的网站SSL私钥<code>docker.domain.com.key</code>和SSL证书<code>docker.domain.com.crt</code>以及CA根证书<code>root-ca.crt</code></p><p>新建ssl文件夹将<code>docker.domain.com.key</code>、<code>docker.domain.com.crt</code>、<code>root-ca.crt</code>这三个文件移入，删除其他文件</p><h4 id="配置私有仓库"><a href="#配置私有仓库" class="headerlink" title="配置私有仓库"></a>配置私有仓库</h4><p>私有仓库默认的配置文件位于 <code>/etc/docker/registry/config.yml</code>，现在本地编辑 <code>config.yml</code>，之后挂载到容器中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">log:</span> </span><br><span class="line"><span class="attr">accesslog:</span></span><br><span class="line"><span class="attr">disabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">level:</span> <span class="string">debug</span></span><br><span class="line"><span class="attr">formatter:</span> <span class="string">text</span></span><br><span class="line"><span class="attr">fields:</span></span><br><span class="line"><span class="attr">service:</span> <span class="string">registry</span></span><br><span class="line"><span class="attr">environment:</span> <span class="string">staging</span></span><br><span class="line"><span class="attr">storage:</span> </span><br><span class="line"><span class="attr">delete:</span></span><br><span class="line"><span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">cache:</span> </span><br><span class="line"><span class="attr">blobdescriptor:</span> <span class="string">inmemory</span></span><br><span class="line"><span class="attr">filesystem:</span></span><br><span class="line"><span class="attr">rootdirectory:</span> <span class="string">/var/lib/registry</span></span><br><span class="line"><span class="attr">auth:</span></span><br><span class="line"><span class="attr">htpasswd:</span></span><br><span class="line"><span class="attr">realm:basic-realm</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">/etc/docker/registry/auth/nginx.htpasswd</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line"><span class="attr">addr:</span> <span class="string">:443</span></span><br><span class="line"><span class="attr">host:</span> <span class="attr">http://docker.domain.com</span></span><br><span class="line"><span class="attr">headers:</span></span><br><span class="line"><span class="attr">X-Content-Type-Options:</span> <span class="string">[nosniff]</span></span><br><span class="line"><span class="attr">http2:</span></span><br><span class="line"><span class="attr">disabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">tls:</span></span><br><span class="line"><span class="attr">certificate:</span> <span class="string">/etc/docker/registry/ssl/docker.domain.com.crt</span></span><br><span class="line"><span class="attr">key:</span> <span class="string">/etc/docker/registry/ssl/docker.domain.com.key</span></span><br><span class="line"><span class="attr">health:</span></span><br><span class="line"><span class="attr">storagedrive:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">interval:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="attr">threshold:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="生成http认证文件"><a href="#生成http认证文件" class="headerlink" title="生成http认证文件"></a>生成http认证文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir auth</span><br><span class="line">docker run --rm \</span><br><span class="line">--entrypoint htpasswd \</span><br><span class="line">registry \</span><br><span class="line">-Bbn username password &gt; auth/nginx.htpasswd</span><br><span class="line"><span class="meta">#</span><span class="bash"> username password对应用户名和密码</span></span><br></pre></td></tr></table></figure><p>编辑 docker-compose.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">registry:</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">registry</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">"443:443"</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">./:/etc/docker/registry</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">registry-data:/var/lib/registry</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">registry-data:</span></span><br></pre></td></tr></table></figure><h4 id="修改hosts"><a href="#修改hosts" class="headerlink" title="修改hosts"></a>修改hosts</h4><p>编辑 <code>/etc/hosts</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 docker.domain.com</span><br></pre></td></tr></table></figure><p>启动 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>这样就搭建好了一个具有权限认证、TLS的私有仓库。</p><p>由于自行签发的CA根证书不被系统信任，需要将CA根证书 <code>ssl/root-ca.crt</code>移入 <code>etc/docker/certs.d/docker.domain.com</code>文件夹中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker/certs.d/docker.domain.com</span><br><span class="line">sudo cp ssl/root-ca.crt /etc/docker/certs.d/docker.domain.com/ca.crt</span><br></pre></td></tr></table></figure><p>关键在于退出登录，尝试推送镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker logout docker.domain.com</span><br><span class="line">docker push docker.domain.com/username/ubuntu:18.04</span><br><span class="line">no basic auth credentials</span><br></pre></td></tr></table></figure><h2 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h2><h3 id="数据卷Volumes"><a href="#数据卷Volumes" class="headerlink" title="数据卷Volumes"></a>数据卷Volumes</h3><p>数据卷是一个可供一个或者多个容器使用的特殊目录，它绕过UFS,可以提供很多有用的特征：</p><ul><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新不会影响镜像</li><li>数据卷默认一直存在，即使容器被删除</li></ul><blockquote><p>数据的使用，类似于Linux下对目录或者文件进行mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷</p></blockquote><h4 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker volume create my-vol</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有数据卷</span></span><br><span class="line">docker volume ls</span><br><span class="line">local my-vol</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在主机里面使用以下命令可以查看指定数据卷的信息</span></span><br><span class="line">docker volume inspect my-vol</span><br><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">        "Driver": "local",</span><br><span class="line">        "Labels": &#123;&#125;,</span><br><span class="line">        "Mountpoint": "/var/lib/docker/volumes/my-vol/_data",</span><br><span class="line">        "Name": "my-vol",</span><br><span class="line">        "Options": &#123;&#125;,</span><br><span class="line">        "Scope": "local"</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 用 docker run命令的时候，使用 --mount标记将数据卷挂载容器里。在一次docker run 中可以挂载多个数据卷</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建一个名为web的容器，并加载一个数据卷到容器的/webapp没有来</span></span><br><span class="line">docker run -d - p \</span><br><span class="line">--name web \</span><br><span class="line"><span class="meta">#</span><span class="bash"> -v my-vol:/wepapp \</span></span><br><span class="line">--mount source=my-vol,target=/webapp \</span><br><span class="line">training/webapp \</span><br><span class="line">python app.py</span><br></pre></td></tr></table></figure><h4 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h4><p>主机里面使用以下命令可以查看web容器的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker inspect web</span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据卷信息在Mounts Keys下面</span></span><br><span class="line">"Mounts": [</span><br><span class="line">    &#123;</span><br><span class="line">        "Type": "volume",</span><br><span class="line">        "Name": "my-vol",</span><br><span class="line">        "Source": "/var/lib/docker/volumes/my-vol/_data",</span><br><span class="line">        "Destination": "/app",</span><br><span class="line">        "Driver": "local",</span><br><span class="line">        "Mode": "",</span><br><span class="line">        "RW": true,</span><br><span class="line">        "Propagation": ""</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><h4 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm my-vol</span><br></pre></td></tr></table></figure><p>数据卷是被设计用来持久化数据的，生命周期独立于容器，Docker不会在容器被删除后自动删除容器，并且也不会存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷，可以再删除容器的时候使用 <code>docker rm -v</code>的命令</p><p>无主的数据卷可能会占据很多空间，清理可以使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume prune</span><br></pre></td></tr></table></figure><h3 id="挂载主机目录Bind-mounts"><a href="#挂载主机目录Bind-mounts" class="headerlink" title="挂载主机目录Bind mounts"></a>挂载主机目录Bind mounts</h3><h4 id="挂载一个主机目录作为数据卷"><a href="#挂载一个主机目录作为数据卷" class="headerlink" title="挂载一个主机目录作为数据卷"></a>挂载一个主机目录作为数据卷</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 --mount标记可以指定挂载一个本地主机的目录到容器中去</span></span><br><span class="line">docker run -d -P \</span><br><span class="line">--name web \</span><br><span class="line"><span class="meta">#</span><span class="bash"> -v /src/webapp:/opt/webapp \</span></span><br><span class="line">--mout type=bind,source=/src/webapp,target=/opt/webapp \</span><br><span class="line">training/webapp \</span><br><span class="line">python app.py</span><br></pre></td></tr></table></figure><p>上面的命令加载主机的 <code>/src/webapp</code>目录到容器的 <code>/opt/webapp目录</code>，这个功能在进行测试比较方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，使用 <code>-v</code>参数时如果本地目录不存在Docker会自动创建一个文件夹，使用 <code>--mount</code>采纳数如果本地目录不存在，Docker会报错</p><p>Docker挂载主机目录默认权限是读写，用户可以通过增加 readonly指定为只读</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p \</span><br><span class="line">--name web \</span><br><span class="line"><span class="meta">#</span><span class="bash"> -v /src/webapp:/opt/webapp:ro \</span></span><br><span class="line">--mount type=bind,source=/src/webapp,target=/opt/webapp,readonly \</span><br><span class="line">training/webapp \</span><br><span class="line">python app.py</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加了 <span class="built_in">readonly</span>之后就挂载为只读，在容器内 /opt/webapp目录创建文件，会显示错误</span></span><br><span class="line">/opt/webapp # touch new.txt</span><br><span class="line">touch: new.txt: Read-only file system</span><br></pre></td></tr></table></figure><h4 id="查看数据卷的具体信息-1"><a href="#查看数据卷的具体信息-1" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h4><p>在主机里查看web容器的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker inspect web </span><br><span class="line"><span class="meta">#</span><span class="bash"> 挂载主机目录的配置信息在Mounts Key下面</span></span><br><span class="line">"Mounts": [</span><br><span class="line">    &#123;</span><br><span class="line">        "Type": "bind",</span><br><span class="line">        "Source": "/src/webapp",</span><br><span class="line">        "Destination": "/opt/webapp",</span><br><span class="line">        "Mode": "",</span><br><span class="line">        "RW": true,</span><br><span class="line">        "Propagation": "rprivate"</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>挂载一个本地主机文件作为数据卷</p><p><code>--mount</code>标记也可以从主机挂载单个文件到容器中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -it \</span><br><span class="line"><span class="meta">#</span><span class="bash"> -v <span class="variable">$HOME</span>/.bash_history:/root/.bash_history \</span></span><br><span class="line">--mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history \</span><br><span class="line">ubuntu:17.10 \</span><br><span class="line">bash</span><br><span class="line"></span><br><span class="line">root@2affd44b4667:/# history</span><br><span class="line">1  ls</span><br><span class="line">2  diskutil list </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">这样可以记录在容器输入过的命令</span></span><br></pre></td></tr></table></figure><h2 id="使用网络"><a href="#使用网络" class="headerlink" title="使用网络"></a>使用网络</h2><h3 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h3><p>容器中可以运行一些网络应用，让外部也可以访问，可以通过 <code>-P/p</code>参数来指定端口映射</p><p>当使用<code>-P</code>，Docker会随机映射一个 <code>49000~49900</code>的端口到内部容器开放的端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p training/webapp python app.py</span><br><span class="line">docker container ls -l</span><br><span class="line">CONTAINER ID  IMAGE                   COMMAND       CREATED        STATUS        PORTS                    NAMES</span><br><span class="line">bc533791f3f5  training/webapp:latest  python app.py 5 seconds ago  Up 2 seconds  0.0.0.0:49155-&gt;5000/tcp  nostalgic_morse</span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地主机的49155被映射到容器的5000端口，此时访问本机的49155端口既可以访问容器内web应用提供的界面</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以通过docker logs命令查看应用的信息</span></span><br><span class="line">docker logs -f nostalgic_morss</span><br><span class="line">* Running on http://0.0.0.0:5000/</span><br><span class="line">10.0.2.2 - - [23/May/2014 20:16:31] "GET / HTTP/1.1" 200 -</span><br><span class="line">10.0.2.2 - - [23/May/2014 20:16:31] "GET /favicon.ico HTTP/1.1" 404 -</span><br></pre></td></tr></table></figure><p><code>-p</code>则可以指定要映射的端口，并且在一个指定端口上只可以绑定一个容器。支持的格式为：</p><p><code>ip:hostPort:containerPort|ip::containerPort|hostPort:containerPort</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 映射所有接口地址:使用 hostPort:containerPort格式本地的5000端口映射到容器的5000端口，此时会默认绑定本地所有接口上的所有地址</span></span><br><span class="line">docker run -d -p 5000:5000 training/webapp python app.py</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">映射到指定地址的指定端口：ip:hostPort:containerPort映射使用一个特定地址，比如localhost地址127.0.0.1</span></span><br><span class="line">docker run -d -p 127.0.0.1::5000 training/webapp python app.py</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用udp来指定udp端口</span></span><br><span class="line">docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看映射端口配置:docker port，还可以查到绑定的地址</span></span><br><span class="line">docker port nostalgic_morse 5000</span><br><span class="line">127.0.0.1:49155 .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器有自己的内部网络和ip地址，-p标记可以多次使用来绑定多个端口</span></span><br><span class="line">docker run -d \</span><br><span class="line">-p 5000:5000 \</span><br><span class="line">-p 3000:80</span><br><span class="line">training/webapp \</span><br><span class="line">python app.py</span><br></pre></td></tr></table></figure><h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><p>随着Docker网络的完善，将容器加入自定义Docker网络来连接多个容器的做法优于使用 <code>--link</code>参数</p><h4 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个新的Docker网络，-d参数指定Docker网络类型，有bridge overlay，其中overlay网络类型适用于Swarm mode</span></span><br><span class="line">docker network create -d bridge my-net</span><br></pre></td></tr></table></figure><h4 id="链接容器"><a href="#链接容器" class="headerlink" title="链接容器"></a>链接容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行一个容器并连接到新建的my net网络</span></span><br><span class="line">docker run -it --rm --name busybox1 --network my-net busybox sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打开新的终端，再运行一个容器加入到my-net网络</span></span><br><span class="line">docker run -it --name busybox2 --newwork my-net busybox sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再打开一个新的终端查看容器信息</span></span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">b47060aca56b        busybox             "sh"                11 minutes ago      Up 11 minutes                           busybox2</span><br><span class="line">8720575823ec        busybox             "sh"                16 minutes ago      Up 16 minutes                           busybox1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">通过 ping来证明busybox1容器和busybox2容器建立了互联关系，在busybox1容器输入以下命令</span></span><br><span class="line">/ # ping busybox2</span><br><span class="line">PING busybox2 (172.19.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.072 ms</span><br><span class="line">64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.118 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用ping来测试连接busybox2容器，会被解析成172.19.0.3，同理busybox2容器执行 ping busybox1，也会成功连接到</span></span><br><span class="line">/ # ping busybox1</span><br><span class="line">PING busybox1 (172.19.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.064 ms</span><br><span class="line">64 bytes from 172.19.0.2: seq=1 ttl=64 time=0.143 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这样busybox1和busybox2容器就建立互联关系</span></span><br></pre></td></tr></table></figure><p>如果有多个容器之间需要互相连接，推荐使用Docker compose</p><h3 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h3><p>Docker利用虚拟文件来挂载容器的3个相关配置文件</p><p>在容器中使用 mount命令可以看到挂载信息。</p><p>这种机制可以让宿主主机DNS信息发生更新后，所有Docker容器的DNS配置通过 <code>/etc/resolv.conf</code>文件立刻得到更新。</p><p>配置全部容器的DNS，可以在<code>/etc/docker/daemon.json</code>文件中增加以下内容来设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">"dns":[</span><br><span class="line">"114.114.114.114",</span><br><span class="line">"8.8.8.8"</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样每次启动容器DNS自动配置为<code>114.114.114.114</code>和 <code>8.8.8.8</code>。证明已经生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm ubuntu:18.04 cat etc/resolv.conf</span><br><span class="line"></span><br><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>如果用户想要手动指定容器的配置，可以在使用docker run的时候加入参数：</p><ul><li><code>-h HOSTNAME</code>/<code>--hostname=HOSTNAME</code>设定容器的主机名，它会被写到容器内的<code>etc/hostname</code>和<code>/etc/hosts</code>，在容器外部看不到，既不会在docker container ls中显示，也不会在其他容器 /etc/hosts看到。</li><li><code>--dns=IP_ADDRESS</code>添加DNS服务器到容器的<code>/etc/resolv.conf</code>中，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code>中的主机名</li><li><code>--dns-search=DOMAIN</code>设定容器的搜索域，当设定搜索域为 <code>.example.com</code>时，在搜索一个名为host的主机，DNS不仅搜索host，还会搜索<code>host.example.com</code></li></ul><p>如果在容器启动时没有指定最后两个参数，Docker会默认用主机上的 <code>resolve.conf</code>配置容器</p><h2 id="Docker-Compose项目"><a href="#Docker-Compose项目" class="headerlink" title="Docker Compose项目"></a>Docker Compose项目</h2><p>Docker Compose是Docker 官方编排（Orchestration）项目之一，负责快速的部署分布式应用。</p><p>Compose定位是定义和运行多个Docker容器的应用。</p><p>使用一个Dockerfile模板文件可以很方便定义一个单独的容器，但经常会碰到需要多个容器互相配合来完成某项任务的情况，要实现一个Web项目，除了Web服务容器本身，玩玩还要加上后端的数据库服务容器，甚至负载均衡容器等。</p><p>Compose运行用户通过一个单独的docker-cmpose.yml模板文件来定义一组相关联应用容器为一个项目</p><p>Compose中有两个重要的概念：</p><ul><li>服务service：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例</li><li>项目project：由一组关联的应用容器组成一个完整业务单元，在docker-compose.yml文件中定义</li></ul><p>Compose的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷的生命周期管理</p><p>Compose项目由Python编写，实际上调用了Docker服务提供的API来对容器进行管理，因此只要所操作的平台支持Docker Api，就可以在其上利用Compose进行编排管理</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>常见的Web网络，该项目包含web应用和缓存，下面使用Python记录页面次数的web网站</p><p>app.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dockerTest/app.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">redis = Redis(host=<span class="string">'redis'</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    count = redis.incr(<span class="string">'hits'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World! 该页面已被访问 &#123;&#125; 次。\n'</span>.format(count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">"0.0.0.0"</span>, debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>Dockerfile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.6-alpine</span><br><span class="line">ADD . /code</span><br><span class="line">WORKDIR /code</span><br><span class="line">RUN pip install redis flask</span><br><span class="line">CMD [<span class="string">"python"</span>, <span class="string">"app.py"</span>]</span><br></pre></td></tr></table></figure><p>docker-compose.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">"5000:5000"</span></span><br><span class="line">     </span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">"redis:alpine"</span></span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><p>此时访问本地5000端口，每次刷新页面，计数就会增加1.</p><p>如果想要后台运行加 <code>-d</code></p><h3 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h3><h4 id="命令对象与格式"><a href="#命令对象与格式" class="headerlink" title="命令对象与格式"></a>命令对象与格式</h4><p>对于Compose来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有服务都会受到命令影响。</p><p><code>docker-compose [COMMAND] --help</code>或者 <code>docker-compose help [COMMAND]</code>可以查看具体某个命令的使用格式，基本的使用格式是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure><h4 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h4><ul><li><code>-f,--file FILE</code>指定使用的Compose模板文件，默认是<code>docker-compose.yml</code>，可以多次指定</li><li><code>-p,--project-name NAME</code>指定项目名称，默认将使用所在目录名称作为项目名</li><li><code>--x-networking</code>使用Docker的可拔插网络后端特性</li><li><code>--x-network-driver DRIVER</code>指定网络后端的驱动，默认为<code>bridge</code></li><li><code>--verbose</code>输出更多调试信息</li><li><code>-v,--version</code>打印版本并退出</li></ul><h4 id="命令使用说明"><a href="#命令使用说明" class="headerlink" title="命令使用说明"></a>命令使用说明</h4><p><strong>build</strong></p><p>格式：</p><blockquote><p>docker-compose build [options] [SERVICE…]</p></blockquote><p>构建（重新构建）项目中的服务容器。服务容器一旦构建后，将会带上一个标记名，对于web项目中的一个db容器，可能是web_db</p><p>可以随时在项目目录下运行 <code>docker-compose build</code>来重新构建服务</p><p>选项包括：</p><ul><li><code>--force-rm</code>删除构建过程中的临时容器</li><li><code>--no-cache</code>构建镜像过程中不使用cache(将加大构建过程)</li><li><code>--pull</code>始终尝试通过pull来获取更新版本的镜像</li></ul><p><strong>config</strong></p><p>验证Compose 文件格式是否正确，若格式错误显示原因</p><p><strong>down</strong></p><p>此命令会停止up命令所启动的容器，并移除网络</p><p><strong>exec</strong></p><p>进入指定容器</p><p><strong>help</strong></p><p>获得命令的帮助</p><p><strong>images</strong></p><p>列出Compose文件中包含的镜像</p><p><strong>kill</strong></p><p>格式：</p><blockquote><p>docker-compose kill [options] [SERVICE…]</p></blockquote><p>通过发送SIGKILL信号来强制停止服务容器。支持通过<code>-s</code>参数来指定发送信号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose kill -s SIGINT</span><br></pre></td></tr></table></figure><p><strong>logs</strong></p><p>格式：</p><blockquote><p>docker-compose logs [options] [SERVICE…]</p></blockquote><p>查看服务容器的输出。默认情况下，docker-compose将对不同的服务输出使用不同的颜色来区分，可以通过 <code>--no-color</code>来关闭颜色</p><p><strong>pause</strong></p><p>格式：</p><blockquote><p>docker-compose pause [SERVICE…]</p></blockquote><p>暂停一个服务容器</p><p><strong>port</strong></p><p>格式：</p><blockquote><p>docker-compose port [option] SERVICE PRIVIATE_PORT</p></blockquote><p>打印某个容器端口所映射的公共端口</p><p>选项：</p><ul><li><code>--protocol=proto</code>指定端口协议，tcp默认值或者udp</li><li><code>--index=index</code>如果同一服务存在多个容器，指定命令对象容器的序号（默认为1）</li></ul><p><strong>ps</strong></p><p>格式：</p><blockquote><p> docker-compose ps [options] [SERVICE…]</p></blockquote><p>列出项目中目前的所有容器</p><p>选项：</p><ul><li><code>-q</code>只打印容器的ID信息</li></ul><p><strong>pull</strong></p><p>格式：</p><blockquote><p>docker-compose pull [options] [SERVICE…]</p></blockquote><p>拉取服务依赖的镜像</p><p>选项：</p><ul><li><code>--ignore-pull-failures</code>忽略拉取镜像过程中的错误</li></ul><p><strong>push</strong></p><p>推送服务依赖的镜像到Docker镜像仓库</p><p><strong>restart</strong></p><p>格式：</p><blockquote><p>docker-compose restart [options] [SERVICE…]</p></blockquote><p>重启项目中的服务。</p><p>选项：</p><ul><li><code>-t,--timeout TIMEOUT</code>指定重启前停止容器的超时（默认为10秒）</li></ul><p><strong>rm</strong></p><p>格式</p><blockquote><p>docker-compose rm [options] [SERVICE…]</p></blockquote><p>删除所有停止状态服务容器，推荐先指定docker-compose stop命令来停止容器</p><p>选项：</p><ul><li><code>-f,--force</code>强制直接删除，包括非停止状态的容器，一般尽量不要使用该选项</li><li><code>-v</code>删除容器所挂载的数据卷</li></ul><p><strong>run</strong></p><p>格式：</p><blockquote><p>docker-compose run [options] [-p PORT…] [-e KEY=VAL…] SERVICE [COMMAND] [ARGS…]</p></blockquote><p>在指定服务上执行一个命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose run ubuntu ping docker.com</span><br></pre></td></tr></table></figure><p>将会启动一个ubuntu服务容器，并执行ping docker.com命令</p><p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中</p><p>该命令类似启动容器后执行指定的命令，相关卷、链接等等都会按照配置自动创建</p><p>两个不同点：给定命令将会覆盖原有的自动运行命令，不会自动创建端口，以避免冲突</p><p>如果不希望自动启动关联的容器，可以使用 <code>--no-deps</code>选项，例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose run --no-deps web python manage.py shell</span><br></pre></td></tr></table></figure><p>将不会启动web容器所关联的其他容器</p><p>选项：</p><ul><li><code>-d</code>后台运行容器</li><li><code>--name NAME</code>为容器指定一个名字</li><li><code>--entrypoint CMD</code>覆盖默认的容器启动指令</li><li><code>-e KEY=VAL</code>设置环境变量值，可多次使用选项来设置多个环境变量</li><li><code>-u,--user=&quot;&quot;</code>指定运行容器的用户名或者uid</li><li><code>--no-deps</code> 不自动启动关联的服务容器</li><li><code>--rm</code> 运行命令后自动删除容器，<code>d</code>默认下将忽略</li><li><code>-p,--publish=[]</code> 映射容器端口到本地主机</li><li><code>--service-ports</code> 配置服务端口并映射到本地主机</li><li><code>-T</code> 不分配伪tty，意味着依赖tty的指令将无法运行</li></ul><p><strong>scale</strong></p><p>格式:</p><blockquote><p>docker-compose scale [options] [SERVICE=NUM…]</p></blockquote><p>设置指定服务运行的容器个数</p><p>通过service-num的参数来设置数量。例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose scale web=3 db=2</span><br></pre></td></tr></table></figure><p><strong>start</strong></p><p>格式：</p><blockquote><p>docker-compose start [SERVIC…]</p></blockquote><p>启动已经存在的服务器</p><p><strong>stop</strong></p><p>格式：</p><blockquote><p>docker-compose stop [options] [SERVICE…]</p></blockquote><p>停止已经处于运行状态的容器，但不删除它，通过 docker-compose start可以再次启动这些容器</p><p><strong>top</strong></p><p>查看各个服务容器内运行的内存</p><p><strong>unpause</strong></p><p>格式：</p><blockquote><p>docker-compose unpause [SERVICE…]</p></blockquote><p>恢复处于暂停状态的服务</p><p><strong>up</strong></p><p>格式：</p><blockquote><p>docker-compose up [options] [SERVICE…]</p></blockquote><p>尝试自动完成包括构建镜像，重新创建服务，启动服务，并关联服务相关容器的一系列操作。链接的服务器都会被自动启动，除非已经处于运行状态</p><p>大部分时候都可以通过该命令来启动一个项目</p><p>默认情况下，docker-compose up启动的容器在前台，控制台将会同时打印所有容器的信息，可以方便调试，使用 ctrl-c停止命令时，所有容器将会停止</p><p>生产环境推荐使用 docker-compose up -d，这将会在后台启动并运行所有容器。</p><p>默认情况下，如果服务容器已经存在，docker-compose up将会尝试停止容器，然后重新创建（保持使用<code>volume-from</code>挂载的卷），以保证新的服务匹配docker-compose.yml文件的最新内容。如果不希望容器被停止并重新创建，可以使用 docker-compose up –no-recreate。这样只会启动处于停止状态的容器，而忽略已经运行的服务，如果用户只想重新部署某个服务，可以使用 <code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code>来重新创建服务并后台停止旧服务，启动新服务，并不会影响到期所依赖的服务。</p><p>选项：</p><ul><li><code>-d</code>在后台运行服务容器</li><li><code>--no-color</code>不使用颜色来区分不同的服务的控制台输出</li><li><code>--no-deps</code>不启动服务所链接的容器</li><li><code>--force-recreate</code>强制重新创建容器，不能与<code>--no-recreate</code>同时使用</li><li><code>--no-buld</code>不自动构建缺失的服务镜像</li><li><code></code>-t,timeout TIMEOUT`停止同期时候的超时（默认为10秒）</li></ul><p><strong>version</strong></p><p>打印版本信息</p><h3 id="模板文件"><a href="#模板文件" class="headerlink" title="模板文件"></a>模板文件</h3><p>模板文件就是使用compose的核心，大部分指令跟docker run相关参数的含义类似</p><p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为YAML格式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">webapp:</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">example/web</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">"80:80"</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">"/data"</span></span><br></pre></td></tr></table></figure><p>每个服务都必须通过image指令指定镜像或build（需要Dockerfile）指令等来自动构建生成镜像</p><p>如果使用build命令，在Dockerfile中设置的选项，例如CMD/EXPOSE/VOLUME/ENV等将会被自动获取，无需在docker-compose.yml中再次设置。</p><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>指定Dockerfile所在文件夹的路径（可以是绝对路径，或者相对docker-compose.yml文件路径），Compose将会利用它自动构建这个镜像，然后使用这个镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">webapps:</span><br><span class="line">build: ./dir</span><br></pre></td></tr></table></figure><p>也可以使用context指令指定Dockerfile所在文件夹的路径，dockerfile指令指定Dockerfile文件名，arg指令指定构建镜像时的变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">webapp:</span><br><span class="line">build:</span><br><span class="line">context: ./dir</span><br><span class="line">dockerfile: Dockerfile-alternate</span><br><span class="line">args:</span><br><span class="line">buildno: 1</span><br></pre></td></tr></table></figure><p>使用cache_from指定构建镜像的缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">build:</span><br><span class="line">context: .</span><br><span class="line">cache_from:</span><br><span class="line">- alpine:latest</span><br><span class="line">- corp/web_app:3.14</span><br></pre></td></tr></table></figure><h4 id="cap-add-cap-drop"><a href="#cap-add-cap-drop" class="headerlink" title="cap_add,cap_drop"></a>cap_add,cap_drop</h4><p>指定容器的内核能力（capacity）分配</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 让容器拥有所有能力</span></span><br><span class="line">cap_add:</span><br><span class="line">- ALL</span><br><span class="line"><span class="comment"># 去掉 NET_ADMIN能力</span></span><br><span class="line">cap_drop:</span><br><span class="line">- NET_ADMIN</span><br></pre></td></tr></table></figure><h4 id="configs、deploy"><a href="#configs、deploy" class="headerlink" title="configs、deploy"></a>configs、deploy</h4><p>仅用于Swarm mode</p><h4 id="cgroup-parent"><a href="#cgroup-parent" class="headerlink" title="cgroup_parent"></a>cgroup_parent</h4><p>指定父cgroup组，意味着将继承改组的资源限制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个cgroup组名称为cgroups_1</span></span><br><span class="line">cgroup_parent: cgroups_1</span><br></pre></td></tr></table></figure><h4 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h4><p>指定容器名称。默认使用<code>项目名称_服务名称_序号</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">container_name:docker-web-container</span><br><span class="line"><span class="comment"># 指定容器名称后，该服务将无法进行扩展（scale）,因此Docker不会允许多个容器具有相同的名称</span></span><br></pre></td></tr></table></figure><h4 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h4><p>指定设备映射关系</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devices:</span><br><span class="line">- <span class="string">"/dev/ttyUSB1:/dev/ttyUSB0"</span></span><br></pre></td></tr></table></figure><h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h4><p>解决容器的依赖、启动先后问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先启动redis db 再启动web</span></span><br><span class="line">version: <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">web:</span><br><span class="line">build: .</span><br><span class="line">depends_on:</span><br><span class="line">- db</span><br><span class="line">- redis</span><br><span class="line">redis:</span><br><span class="line">image: redis</span><br><span class="line">db:</span><br><span class="line">image:postgres</span><br><span class="line"><span class="comment"># web服务不会等待redis db完全启动之后才启动</span></span><br></pre></td></tr></table></figure><h4 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h4><p>自定义DNS服务器，可以是一个值，也可以是一个列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line">dns:</span><br><span class="line">- 8.8.8.8</span><br><span class="line">- 114.114.114.114</span><br></pre></td></tr></table></figure><h4 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a>dns_search</h4><p>配置DNS搜索域，可以是一个值，也可以是一个列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns_search:example.com</span><br><span class="line"></span><br><span class="line">dns_search:</span><br><span class="line">- domain1.example.com</span><br><span class="line">- domain2.example.com</span><br></pre></td></tr></table></figure><h4 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h4><p>挂载一个tmpfs文件系统到容器</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmpfs: /<span class="keyword">run</span><span class="bash"></span></span><br><span class="line"><span class="bash">tmpfs:</span></span><br><span class="line"><span class="bash">- /run</span></span><br><span class="line"><span class="bash">- /tmp</span></span><br></pre></td></tr></table></figure><h4 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h4><p>从文件中获取环境变量，可以为单独的文件路径或列表</p><p>通过 <code>docker-compose -f FILE</code>方式来指定Compose模板文件，则 <code>env_file</code>中变量的路径会基于模板文件路径。如果有变量名称与environment指令冲突，则按照惯例，以后者为准</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">env_file: .env</span><br><span class="line"></span><br><span class="line">env_file:</span><br><span class="line">- ./common.env</span><br><span class="line">- ./apps/web.env</span><br><span class="line">- /opt/secrets.env</span><br></pre></td></tr></table></figure><p>环境变量文件中每一行必须符合格式，支持<code>#</code>开头的注释行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># common.env: Set development environment</span></span><br><span class="line">FROG_ENV=development</span><br></pre></td></tr></table></figure><h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><p>设置环境变量，可以使用数组和字典两种格式</p><p>只给定名称的变量会自动获取运行Compose主机上对应变量的值，可以用阿里防止泄露不必要的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">RACK_ENV: development</span><br><span class="line">SESSION_SECRET:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">environment:</span><br><span class="line">- RACK_ENV=development</span><br><span class="line">- SESSION_SECRET</span><br></pre></td></tr></table></figure><p>如果变量名称或者值中用到<code>true|false,yse|no</code>等表示布尔含义的词汇，最好放到引号中，避免YAML自动解析某些内容为对应的布尔语义，这些特定词汇，包括</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y|Y|Yes|YES|n|N|no|NO|true|True|TRUE|false|False|FALSE|on|ON|off|Off|OFF</span><br></pre></td></tr></table></figure><h4 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h4><p>暴露端口，但不映射到宿主机，只被连接的服务访问。仅可以指定内部端口为参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expose:</span><br><span class="line">- <span class="string">"3000"</span></span><br><span class="line">- <span class="string">"8000"</span></span><br></pre></td></tr></table></figure><h4 id="external-links"><a href="#external-links" class="headerlink" title="external_links"></a>external_links</h4><p>链接到docker-compose.yml外部的容器，甚至并非Compose管理的外部容器，不建议使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">external_links:</span><br><span class="line">- redis_1</span><br><span class="line">- project_db_1:mysql</span><br><span class="line">- project_db_1:postgresql</span><br></pre></td></tr></table></figure><h4 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h4><p>类似Docker中的<code>--add-host</code>参数，指定额外的host名称映射信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line">- <span class="string">"googledns:8.8.8.8"</span></span><br><span class="line">- <span class="string">"dockerhub:52.1.157.61"</span></span><br></pre></td></tr></table></figure><p>会在启动后的服务容器中 <code>/etc/hosts</code>文件中添加如下两条条目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8.8.8.8 googledns</span><br><span class="line">52.1.157.61 dockerhub</span><br></pre></td></tr></table></figure><h4 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h4><p>通过命令检查容器是否健康运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line"><span class="built_in">test</span>: [<span class="string">"CMD"</span>,<span class="string">"curl"</span>,<span class="string">"-f"</span>,<span class="string">"http://localhost"</span>]</span><br><span class="line">interval: 1m30s</span><br><span class="line">timeout: 10s</span><br><span class="line">retries: 3</span><br></pre></td></tr></table></figure><h4 id="image"><a href="#image" class="headerlink" title="image"></a>image</h4><p>指定为镜像名称或者镜像ID,如果镜像在本地不存在，Compose将会尝试拉取这个镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image: ubuntu</span><br><span class="line">image: orchardup/postgresql</span><br><span class="line">image: a4bc65fd</span><br></pre></td></tr></table></figure><h4 id="labels"><a href="#labels" class="headerlink" title="labels"></a>labels</h4><p>为容器添加Docker元数据（metadata）信息，可以为容器添加辅助说明信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">labels:</span><br><span class="line">com.startupteam.description: <span class="string">"webapp for a startup team"</span></span><br><span class="line">com.startupteam.department: <span class="string">"depvops department"</span></span><br><span class="line">com.startupteam.release: <span class="string">"rc3 for v1.0"</span></span><br></pre></td></tr></table></figure><h4 id="links"><a href="#links" class="headerlink" title="links"></a>links</h4><p>不推荐使用该指令</p><h4 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h4><p>配置日志选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">loggin:</span><br><span class="line">driver: syslog</span><br><span class="line">options:</span><br><span class="line">syslog-address: <span class="string">"tcp://192.168.0.42:123"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目前支持三种日志驱动类型</span></span><br><span class="line">driver: <span class="string">"json-file"</span></span><br><span class="line">driver: <span class="string">"syslog"</span></span><br><span class="line">driver: <span class="string">"none"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># options配置日志驱动的相关参数</span></span><br><span class="line">options:</span><br><span class="line">max-size: <span class="string">"200k"</span></span><br><span class="line">max-file: <span class="string">"10"</span></span><br></pre></td></tr></table></figure><h4 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a>network_mode</h4><p>设置网络模式，使用和 docker run 的 network参数一样的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">network_mode: <span class="string">"bridge"</span></span><br><span class="line">network_mode: <span class="string">"host"</span></span><br><span class="line">network_mode: <span class="string">"none"</span></span><br><span class="line">network_mode: <span class="string">"service:[service name]"</span></span><br><span class="line">network_mode: <span class="string">"container:[container name/id]"</span></span><br></pre></td></tr></table></figure><h4 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h4><p>配置容器连接的网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">"3"</span></span><br><span class="line">services:</span><br><span class="line">some-service:</span><br><span class="line">networks:</span><br><span class="line">- some-network</span><br><span class="line">- other-network</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">some-network:</span><br><span class="line">other-network:</span><br></pre></td></tr></table></figure><h4 id="pid"><a href="#pid" class="headerlink" title="pid"></a>pid</h4><p>跟主机系统共享进程命名空间，打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程ID来互相访问和操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid: <span class="string">"host"</span></span><br></pre></td></tr></table></figure><h4 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h4><p>暴露端口信息</p><p>使用宿主端口：容器端口（HOST:CONTAINER）格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ports:</span><br><span class="line"> - <span class="string">"3000"</span></span><br><span class="line"> - <span class="string">"8000:8000"</span></span><br><span class="line"> - <span class="string">"49100:22"</span></span><br><span class="line"> - <span class="string">"127.0.0.1:8001:8001"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当使用 HOST:CONTAINER格式映射端口时，使用的容器端口小于60并且没有放到引号里，可能会得到错误结果，因为YAML会自动解析xx:yy，这种数字格式为60进制，为避免出现这个问题，建议数字串都采用引号包括起来的字符串格式</span></span><br></pre></td></tr></table></figure><h4 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a>secrets</h4><p>存储敏感数据，例如mysql服务密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">"3.1"</span></span><br><span class="line">services：</span><br><span class="line"></span><br><span class="line">mysql:</span><br><span class="line">image: mysql</span><br><span class="line">environment:</span><br><span class="line">MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password</span><br><span class="line">secrets:</span><br><span class="line">- db_root_password</span><br><span class="line">- my_other_secret</span><br><span class="line"></span><br><span class="line">secrets:</span><br><span class="line">my_secret:</span><br><span class="line">file: ./my_secret.txt</span><br><span class="line">my_other_secret:</span><br><span class="line">external: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="security-opt"><a href="#security-opt" class="headerlink" title="security_opt"></a>security_opt</h4><p>指定容器模板标签label机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">security_opt:</span><br><span class="line">- label:user:USER</span><br><span class="line">- label:role:ROLE</span><br></pre></td></tr></table></figure><h4 id="stop-signal"><a href="#stop-signal" class="headerlink" title="stop_signal"></a>stop_signal</h4><p>设置另一个信号来停止容器。在默认情况下使用的是SIGTERM停止容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop_signal: SIGUSR1</span><br></pre></td></tr></table></figure><h4 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a>sysctls</h4><p>配置容器内核参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sysctls:</span><br><span class="line">net.core.somaxconn: 1024</span><br><span class="line">net.ipv4.tcp_syncookies: 0</span><br><span class="line"></span><br><span class="line">sysctls:</span><br><span class="line">- net.core.somaxconn=1024</span><br><span class="line">- net.ipv4.tcp_syncookies=0</span><br></pre></td></tr></table></figure><h4 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h4><p>指定容器的ulimits限制值</p><p>例如，指定最大容器的进程数为65535.指定文件句柄数为20000（软限制，应用可以随时修改，不能超过硬限制）和40000（系统硬限制，只能root用户提高）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimits:</span><br><span class="line"> nproc: 65535</span><br><span class="line"> nofile:</span><br><span class="line"> soft: 20000</span><br><span class="line"> hard: 40000</span><br></pre></td></tr></table></figure><h4 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h4><p>数据卷所挂载路径设置，可以设置宿主主机路径（HOST:CONTAINER）或加上访问模式（HOST:CONTAINER:ro）</p><p>该指令中路径支持相对路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line"> - /var/lib/mysql</span><br><span class="line"> - cache/:tmp/cache</span><br><span class="line"> - ~/configs:/etc/configs/:ro</span><br></pre></td></tr></table></figure><h4 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h4><p>domainname,entrypoint,hostname,ipc,mac_address,privileged,read_only,shm_size,restart,stdin_open,tty,user,wor等指令，基本跟 docker run中对应参数的功能一致</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定服务容器启动后执行的入口文件</span></span><br><span class="line">entrypoint: /code/entrypoint.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定容器中运行应用的用户名</span></span><br><span class="line">user: nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定容器中工作目录</span></span><br><span class="line">working_dir: /code</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定容器中搜索域名、主机名、mac地址等</span></span><br><span class="line">domainname: your_website.com</span><br><span class="line">hostname: <span class="built_in">test</span></span><br><span class="line">mac_address: 08-00-27-00-0C-0A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许容器中运行一些特权命令</span></span><br><span class="line">privileged: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为always或者unless-stopped</span></span><br><span class="line">restart: always</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改</span></span><br><span class="line">read_only: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开标准输入，可以接受外部输入</span></span><br><span class="line">stdin_open: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟一个伪终端</span></span><br><span class="line">tty: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="读取变量"><a href="#读取变量" class="headerlink" title="读取变量"></a>读取变量</h4><p>Compose模板文件支持动态读取主机的系统环境变量和当前目录下的 .env文件中的变量</p><p>例如，下面的Compose文件将从运行它的环境中读取变量 <code>${MONGO_VERSION}</code>的值，并写入执行的指令中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">verison: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">db: </span><br><span class="line">image: <span class="string">"mongo:<span class="variable">$&#123;MONGO_VERSION&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>如果执行 <code>MONGO_VERSION=3.2 docker-compose up</code> 则会启动一个 <code>mongo:3.2</code> 镜像的容器；如果执行 <code>MONGO_VERSION=2.8 docker-compose up</code> 则会启动一个 <code>mongo:2.8</code> 镜像的容器。</p><p>若当前目录存在 <code>.env</code> 文件，执行 <code>docker-compose</code> 命令时将从该文件中读取变量。</p><p>在当前目录新建 <code>.env</code> 文件并写入以下内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 支持 # 号注释</span></span><br><span class="line">MONGO_VERSION=3.6</span><br></pre></td></tr></table></figure><p>执行 <code>docker-compose up</code> 则会启动一个 <code>mongo:3.6</code> 镜像的容器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cntofu.com/book/139/index.html&quot;&gt;docker学习，作者源于这里&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="docker" scheme="http://laibh.top/categories/docker/"/>
    
    
      <category term="docker" scheme="http://laibh.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs回顾</title>
    <link href="http://laibh.top/2020-06-19-NodeJS%E5%9B%9E%E9%A1%BE.html"/>
    <id>http://laibh.top/2020-06-19-NodeJS回顾.html</id>
    <published>2020-06-19T08:46:38.000Z</published>
    <updated>2022-03-04T10:00:38.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h1><h2 id="模块与文件"><a href="#模块与文件" class="headerlink" title="模块与文件"></a>模块与文件</h2><h3 id="require-的加载机制"><a href="#require-的加载机制" class="headerlink" title="require 的加载机制"></a>require 的加载机制</h3><h4 id="模块的分类"><a href="#模块的分类" class="headerlink" title="模块的分类"></a>模块的分类</h4><p>系统模块</p><ul><li>C/C++模块，也叫build-in内建模块，一般用于native模块嗲用，在require出去</li><li>native模块，在开发中使用的Node.js 的 http/buffer/fs等，底层也是调用的内建模块（C/C++）</li></ul><p>第三方模块：</p><p>非Node.js自带的模块被称为第三方模块，会分成路径形式的文件模块（以<code>.</code>、<code>..</code>、<code>/</code>开头的）和自定义的模块（比如express/koa/moment.js等）</p><p>在 Node.JS 中模块加载一般会经历3个步骤：路径分析、文件定位、编译执行</p><p>按照模块的分类，按照以下的顺序进行优先加载：</p><ul><li>系统缓存：模块被执行之后会进行缓存，首先是先进行缓存加载，判断换粗中是否有值。</li><li>系统模块：也就是原生模块，优先级次于系统缓存，部分核心模块已经被编译成二进制，省略了路径分析、文件定位，直接加载在内存中，系统模块定义在 Node.js 源码的lib目录下。</li><li>文件模块：优先加载 <code>.</code>、<code>..</code>、<code>/</code>开头的，如果文件没有加上拓展名，会依次按照<code>.js</code>、<code>.json</code>、<code>.node</code>尝试进行拓展名补足。（在尝试过程中也是以<strong>同步阻塞模式</strong>来判断文件是否存在的，从性能优化角度来看，<code>.json</code>、<code>node</code>最好还是加上文件的拓展名）</li><li>目录作为模块：文件模块加载过程中没有找到，但发现这是一个目录，这个适合就会把这个目录当做一个包来处理，Node采用了commonjs规范，会先在项目的根目录查找package.json文件，取出文件中定义的main属性描述的入口文件进行加载，也没有加载到，则会抛出默认错误：Error：Cannot find module ‘lib/hello.js’</li><li>node_modules目录加载：对于系统模块，路径文件模块都找不到，Nodejs会从当前模块的父目录进行查找，直到系统的根目录</li></ul><h3 id="module-exports-与-exports-的区别"><a href="#module-exports-与-exports-的区别" class="headerlink" title="module.exports 与 exports 的区别"></a>module.exports 与 exports 的区别</h3><p>exports相当于 module.exports 的快捷方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> exports = <span class="built_in">module</span>.exports</span><br></pre></td></tr></table></figure><p>但是不能改变 exports 的指向，我们可以通过 <code>exports.test = &#39;a&#39;</code>，这样来导出一个对象，但是不能通过下面的例子直接赋值，这样会改变 exports 的指向</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法，将会得到 undefined</span></span><br><span class="line">exports = &#123;</span><br><span class="line">   <span class="string">'a'</span>:<span class="number">1</span>,</span><br><span class="line">   <span class="string">'b'</span>:<span class="number">2</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line">modules.exports =&#123;</span><br><span class="line">   <span class="string">'a'</span>:<span class="number">1</span>,</span><br><span class="line">   <span class="string">'b'</span>:<span class="number">2</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模块循环引用问题"><a href="#模块循环引用问题" class="headerlink" title="模块循环引用问题"></a>模块循环引用问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a模块start'</span>);</span><br><span class="line">exports.test = <span class="number">1</span>;</span><br><span class="line">undeclaredVariable = <span class="string">'a模块为声明变量'</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a模块加载完毕：b.test值'</span>,b.test);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b模块start'</span>);</span><br><span class="line">exports.test = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'undeclaredVariable:'</span>,undeclaredVariable)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b模块加载完毕：a.test值：'</span>,a.test)</span><br></pre></td></tr></table></figure><p>执行 <code>node a.js</code>,结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a模块start</span><br><span class="line">b模块start</span><br><span class="line">undeclaredVariable:a模块未声明变量</span><br><span class="line">b模块加载完毕：a.test值：1</span><br><span class="line">a模块加载完毕：b.test值：2</span><br></pre></td></tr></table></figure><p>启动a.js会加载b.js，那么在b.js中又加载到了a.js，但是此时a.js模块hi阿咩有执行完，返回的是一个a.js模块的exports对象未完成的副本给到b.js模块（因此不会陷入死循环），然后b.js完成加载之后将exports 对象退供给a.js模块</p><h4 id="a-模块中的-undeclaredVariable-变量在-b-js-是否会打印？"><a href="#a-模块中的-undeclaredVariable-变量在-b-js-是否会打印？" class="headerlink" title="a 模块中的 undeclaredVariable 变量在 b.js 是否会打印？"></a>a 模块中的 undeclaredVariable 变量在 b.js 是否会打印？</h4><p>undeclaredVariable 是一个未声明的变量，也就是一个挂在全局的变量，那么在其他地方是可以拿得到的</p><h4 id="假设有-a-js、b-js-两个模块相互引用，会有什么问题，会不会陷入死循环？"><a href="#假设有-a-js、b-js-两个模块相互引用，会有什么问题，会不会陷入死循环？" class="headerlink" title="假设有 a.js、b.js 两个模块相互引用，会有什么问题，会不会陷入死循环？"></a>假设有 a.js、b.js 两个模块相互引用，会有什么问题，会不会陷入死循环？</h4><p>不会陷入死循环</p><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><h3 id="Buffer与Cache的区别"><a href="#Buffer与Cache的区别" class="headerlink" title="Buffer与Cache的区别"></a>Buffer与Cache的区别</h3><h4 id="缓冲（Buffer）"><a href="#缓冲（Buffer）" class="headerlink" title="缓冲（Buffer）"></a>缓冲（Buffer）</h4><p>缓冲是用于处理二进制流数据，将数据存储起来，它是临时性的，对于流式数据来说，会采用缓冲区将数据临时存储起来，等缓冲到一定大小的时候存入硬盘中。视频播放器就是一个经典例子。</p><h4 id="缓存（Cache）"><a href="#缓存（Cache）" class="headerlink" title="缓存（Cache）"></a>缓存（Cache）</h4><p>缓存可以看做一个中间层，可以是永久性的将热点数据进行缓存，使得访问速度更快。例如我们通过对 memory、Redis等将数据从硬盘或者第三方接口中请求过来进行缓存，目的就是将数据存于内存的缓存区中，这样对同一个资源进行访问，速度会更快，也就是性能优化的一个重要点。</p><h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><h4 id="什么是进程（Process）和线程（Thread），之间的区别"><a href="#什么是进程（Process）和线程（Thread），之间的区别" class="headerlink" title="什么是进程（Process）和线程（Thread），之间的区别"></a>什么是进程（Process）和线程（Thread），之间的区别</h4><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>进程是计算中程序关于数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器。启动一个服务，运行一个实例，就是开一个服务进程。多进程就是进程的复制（fork），fork出来的每个进程都有自己的独立空间地址、数据栈，一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了IPC通信，进程之间才可以数据共享。</p><h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><p>线程是操作系统能够进行运算调度的最小单位，线程是隶属进程的，被包含与进程之中的。一个线程只能隶属一个进程，但是一个进程是可以拥有多个线程的。</p><p>同一个代码，可以根据系统CPU核心数启动多个进程，每个进程都有属于自己的独立运行空间，进程之间是不互相影响的。同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述和信号处理等。但 同一进程中的多个线程有各自的调用栈，自己的寄存器环境，自己的线程本地存储。</p><h3 id="什么是孤儿进程"><a href="#什么是孤儿进程" class="headerlink" title="什么是孤儿进程"></a>什么是孤儿进程</h3><p>父进程创建子进程之后，父进程退出了，但是父进程对应的一个或者多个子进程还在运行，这些子进程会被系统的init进程收养，对应的程序ppid为1，这就是孤儿进程。</p><h3 id="创建多进程时，代码里有app-listen-port-在进行fork时，为什么没有报端口被占用"><a href="#创建多进程时，代码里有app-listen-port-在进行fork时，为什么没有报端口被占用" class="headerlink" title="创建多进程时，代码里有app.listen(port)在进行fork时，为什么没有报端口被占用"></a>创建多进程时，代码里有<code>app.listen(port)</code>在进行fork时，为什么没有报端口被占用</h3><p>端口被占用的情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.js</span></span><br><span class="line"><span class="keyword">const</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork;</span><br><span class="line"><span class="keyword">const</span> cups = <span class="built_in">require</span>(<span class="string">'os'</span>).cups();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;cups.length;i++)&#123;</span><br><span class="line">    <span class="keyword">const</span> worker = fork(<span class="string">'worker.js'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'worker process created, pid: %s ppid: %s'</span>, worker.pid, process.pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.send(<span class="string">'I am worker,pid:'</span>+process.pid+<span class="string">', ppid: '</span>+process.pid)</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台执行node master.js只有一个worker 可以监听 3000 端口，其余会抛出 Error:listen EADDRINUSE :::3000错误</span></span><br></pre></td></tr></table></figure><p>多进程模式可通过句柄传递不会有端口占用的问题。</p><p>当父子进程之间建立IPC通道之后，通过子进程对象的send方法发送消息，第二个参数sendHandle就是句柄，可以是TCP套接字，TCP服务器、UDP套接字等，为了解决上面多进程端口占用问题，将主进程的socket传递到子进程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.js</span></span><br><span class="line"><span class="keyword">const</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork;</span><br><span class="line"><span class="keyword">const</span> cups = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus();</span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">'net'</span>).createServer();</span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br><span class="line">process.title = <span class="string">'node-master'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;cpus.length;i++)&#123;</span><br><span class="line">    <span class="keyword">const</span> worker = fork(<span class="string">'worker.js'</span>)</span><br><span class="line">    worker.send(<span class="string">'server'</span>,server);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'worker process created, pid: %s ppid: %s'</span>, worker.pid, process.pid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(i+<span class="number">1</span> === cpus.length)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'serve close'</span>);</span><br><span class="line">        server.close(); <span class="comment">// 关闭服务器监听，交由子进程处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.end(<span class="string">'I am worker, pid: '</span> + process.pid + <span class="string">', ppid: '</span> + process.ppid);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> worker;</span><br><span class="line">process.title = <span class="string">'node-worker'</span>;</span><br><span class="line">process.on(<span class="string">'message'</span>,(message,sendHandle)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(message === <span class="string">'server'</span>)&#123;</span><br><span class="line">        worker = sendHandle;</span><br><span class="line">        worker.on(<span class="string">'connection'</span>,(socket)=&gt;&#123;</span><br><span class="line">            server.emit(<span class="string">'connection'</span>,socket)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="什么是IPC通信，如何建立，什么场景下会使用"><a href="#什么是IPC通信，如何建立，什么场景下会使用" class="headerlink" title="什么是IPC通信，如何建立，什么场景下会使用"></a>什么是IPC通信，如何建立，什么场景下会使用</h3><p>IPC(inter-process communication)，即进程间通信技术，由于每个进程创建之后都有自己的独立地址空间，实现IPC的目的就是进程之间的资源共享访问，实现IPC的方式有多种：管道、消息队列、信号量、Domain Socket，Nodejs通过pipe来实现。</p><p>未使用IPC的情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pipe.js</span></span><br><span class="line"><span class="keyword">const</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn;</span><br><span class="line"><span class="keyword">const</span> child = spawn(<span class="string">'node'</span>,[<span class="string">'worker.js'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(process.pid,child.pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'I am worker,PID:'</span>,process.pid)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 node pipe.js，输出主线程的id，子线程的id，但是子线程worker.js的信息没有在控制台打印，原因是新创建的子进程有自己的 stdio流</span></span><br></pre></td></tr></table></figure><p>创建一个父进程和子进程之间传递消息的IPC通道实现输出信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改pipe.js让子进程的stdio和当前进程的stdio之间建立管道链接，还可以通过spawn方法的stdio选项建立IPC机制</span></span><br><span class="line"><span class="comment">// pipe.js</span></span><br><span class="line"><span class="keyword">const</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn;</span><br><span class="line"><span class="keyword">const</span> child = spawn(<span class="string">'node'</span>,[<span class="string">'worker.js'</span>]);</span><br><span class="line">child.stdout.pipe(process.stdout);</span><br><span class="line"><span class="built_in">console</span>.log(process.pid,child.pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程与子进程的通信</span></span><br><span class="line"><span class="comment">// 父进程在创建子进程之前会先去创建IPC通道并一直监听该通道，之后开始创建子进程并通过环境变量（NODE_CHANNEL_FD）的方式将IPC频道的文件描述符传递给子进程，子进程启动时根据传递的文件描述符去链接IPC通道，从而建立父子进程之间的通信机制。</span></span><br></pre></td></tr></table></figure><h3 id="Node-js是单线程还是多线程，为什么会单线程"><a href="#Node-js是单线程还是多线程，为什么会单线程" class="headerlink" title="Node.js是单线程还是多线程，为什么会单线程"></a>Node.js是单线程还是多线程，为什么会单线程</h3><p>javascript是单线程，在服务端运行环境的nodejs不是单线程。</p><p>浏览器环境中对于DOM的操作是单线程的，避免DOM渲染冲突，在浏览器中UI渲染线程和JS执行引擎是互斥的，一方在执行式都会导致另一方被挂起，这是由JS引擎所决定的。</p><h3 id="关于守护进程，是什么，为什么，怎么编写？"><a href="#关于守护进程，是什么，为什么，怎么编写？" class="headerlink" title="关于守护进程，是什么，为什么，怎么编写？"></a>关于守护进程，是什么，为什么，怎么编写？</h3><p>守护进程运行在后台不受终端影响。</p><h4 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h4><ol><li>创建子进程</li><li>在子进程中创建新会话（调用系统函数setsid）</li><li>改变子进程工作目录（如：’/‘或者’/usr/‘等）</li><li>父进程终止</li></ol><h3 id="编写demo"><a href="#编写demo" class="headerlink" title="编写demo"></a>编写demo</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js文件的处理逻辑使用 spawn创建子进程完成第一步，设置options.detached为true可以使得子进程在父进程退出后继续运行（系统层会调用setsid方法），这是第二步。options.cwd指定当前子进程工作目录不做设置默认继承当前工作目录，这是第三步。运行daemon.unref()退出父进程，第四步。</span></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startDaemon</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> daemon = spawn(<span class="string">'node'</span>,[<span class="string">'daemon.js'</span>],&#123;</span><br><span class="line">        cwd:<span class="string">'/usr'</span>,</span><br><span class="line">        datached:<span class="literal">true</span>,</span><br><span class="line">        stdio:<span class="string">'ignore'</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'守护进程开启 父进程 pid: %s, 守护进程 pid: %s'</span>, process.pid, daemon.pid);</span><br><span class="line">    daemon.unref();</span><br><span class="line">&#125;</span><br><span class="line">startDaemon();</span><br><span class="line"></span><br><span class="line"><span class="comment">// daemon.js文件哩逻辑开启一个定时器每10秒运行一次，使得这个资源不会退出，同时写入日志到子进程当前的工作目录下</span></span><br><span class="line"><span class="comment">// /usr/daemon.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;Console&#125; = <span class="built_in">require</span>(<span class="string">'console'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Console(fs.createWriteStream(<span class="string">'./stdout.log'</span>),fs.createWriteStream(<span class="string">'./stderr.log'</span>));</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    logger.log(<span class="string">'daemon pid:'</span>,process.pid,<span class="string">'ppid: '</span>,process.ppid)</span><br><span class="line">&#125;,<span class="number">1000</span>*<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>实际工作中守护进程很多，例如PM2,Egg-Cluster等，实际工作上对于守护进程的健壮性要求还是很高的，例如：进程的异常监听，工作进程管理调度，进程挂掉之后重启等等。</p><h3 id="实现一个简单的命令行交互程序"><a href="#实现一个简单的命令行交互程序" class="headerlink" title="实现一个简单的命令行交互程序"></a>实现一个简单的命令行交互程序</h3><p>采用子进程 child_process的spawn方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn;</span><br><span class="line"><span class="keyword">const</span> child = spawn(<span class="string">'echo'</span>,[<span class="string">'简单的命令行交互'</span>]);</span><br><span class="line">child.stdout.pipe(process.stdout) <span class="comment">// 将子进程的输出作为当前进程的输入，打印在控制台</span></span><br></pre></td></tr></table></figure><h3 id="进程的当前工作目录是什么，有什么用"><a href="#进程的当前工作目录是什么，有什么用" class="headerlink" title="进程的当前工作目录是什么，有什么用"></a>进程的当前工作目录是什么，有什么用</h3><p>进程的当前工作目录可以通过process.cwd()命令获取，默认为当前启动的目录，如果是创建子进程则继承于父进程的目录，可以通过process.chdir()命令重置，例如通过spawn命令创建的子进程可以指定cwd选项设置子进程的工作目录。</p><p>有什么用，例如fs读取文件，如果设置为相对路径则是相当于当前进程启动的目录进行查找，所以，启动目的设置有误的情况下将无法得到正确的结果。还有一种情况程序里引用第三方模块也是根据当前进程启动的目录来进行查找的</p><h3 id="多进程或者多个Web服务之间的状态共享问题"><a href="#多进程或者多个Web服务之间的状态共享问题" class="headerlink" title="多进程或者多个Web服务之间的状态共享问题"></a>多进程或者多个Web服务之间的状态共享问题</h3><p>多进程模式下各个进程之间是相互独立的，例如用户登录之后seesion的保存，如果保存在服务进程里，那么如果我有4个工作进程，每个进程都要保存一份这是没有必要的。假设服务重启了数据也会丢失。多个Web服务也是一样的，还会出现在A机器创建了Session，当负载均衡分到B机器上之后还需要再创建一份，一般的做法是通过Redis或者数据库来做数据共享</p><h3 id="什么是僵尸进程"><a href="#什么是僵尸进程" class="headerlink" title="什么是僵尸进程"></a>什么是僵尸进程</h3><p>使用fork可以创建子进程，正常情况进程退出，内核要释放进程所占用的资源：打开的文件、占用的内存等，但是进程的PID、退出状态、运行时间等会进行保留，知道父进程调用wait/waitpid来获取子进程的状态信息时，这些资源才会释放。</p><p>如果子进程退出之后，父进程没有调用wait/waitpid来获取子进程的状态，那么保留的进程号将会一直被占用，且占用系统资源，称为僵死或僵尸进程。</p><p>元凶是其父进程，我们把元凶kill掉之后，僵尸进程会变为孤儿进程被系统的 init 进程pid=1的进程所收养，init进程会对这些孤儿进程进行管理（调用wait/waitpid）释放其占用资源。</p><h2 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h2><h3 id="console是异步还是同步的"><a href="#console是异步还是同步的" class="headerlink" title="console是异步还是同步的"></a>console是异步还是同步的</h3><p>console既不是总是同步的，也不总是异步的，是否为同步取决于链接是什么流以及操作系统是Window还是Posix</p><p>同步写将会阻塞实践循环直到写完成。</p><ul><li>文件（Files）：Windows和POSIX平台都是同步</li><li>终端（TTYS）：Windows平台下同步，在POSIX平台下异步</li><li>管道（Pipes）：Windows平台下同步，POSIX平台下异步</li></ul><h3 id="如何实现一个console-log"><a href="#如何实现一个console-log" class="headerlink" title="如何实现一个console.log"></a>如何实现一个console.log</h3><p>可利用 process.stdout将输入流数据输出到输出流（即输出到终端）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.stdout.write(<span class="string">'xxx'</span>+<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><h3 id="为什么console-log-执行完就退出"><a href="#为什么console-log-执行完就退出" class="headerlink" title="为什么console.log()执行完就退出"></a>为什么console.log()执行完就退出</h3><p>一旦产生事件循环，就会长产生一个While(true)的死循环，例如定时器，console.log则没有产生watch/handlers，在事件循环一次就退出了。</p><p>Nodejs进程退出会等待异步处理完成，常见的运维过程中会碰到需要进程优雅退出的场景，Nodejs自然退出是最好的，process.exit是比较粗暴的。</p><p>常见的异步请求：</p><ul><li>http请求，数据库请求等IO请求操作</li><li>net.Server.listen()或者http.Server.listen等端口监听</li><li>fs.write()类型的文件IO操作</li><li>console.log()输出日志</li><li>setTimeout()/setInterval等定时器操作</li><li>process.send()等异步请求发送</li></ul><h2 id="Net模块"><a href="#Net模块" class="headerlink" title="Net模块"></a>Net模块</h2><table><thead><tr><th>OSI七层模型</th><th>TCP/IP五层模型</th><th>描述</th></tr></thead><tbody><tr><td>应用层</td><td>应</td><td>构建于传输层之上常用的HTTP、FTP文件传输协议、SMTP邮件传输协议等</td></tr><tr><td>表示层</td><td>用</td><td>构建于传输层之上常用的HTTP、FTP文件传输协议、SMTP邮件传输协议等</td></tr><tr><td>会话层</td><td>层</td><td>构建于传输层之上常用的HTTP、FTP文件传输协议、SMTP邮件传输协议等</td></tr><tr><td>传输层</td><td>传输层</td><td>向用户提供可靠的端到端服务TCP、UDP</td></tr><tr><td>网络层</td><td>网络层</td><td>IPV4、IPV6</td></tr><tr><td>数据链路层</td><td>数据链路层</td><td>设备驱动和硬件</td></tr><tr><td>物理层</td><td>物理层</td><td>设备驱动和硬件</td></tr></tbody></table><h3 id="什么是TCP协议，什么时候会选择TCP协议"><a href="#什么是TCP协议，什么时候会选择TCP协议" class="headerlink" title="什么是TCP协议，什么时候会选择TCP协议"></a>什么是TCP协议，什么时候会选择TCP协议</h3><p>IP协议是无连接通信协议，IP协议不会占用两个设备之间通信的线路，IP实际上主要负责将每个数据包路由至目的地，但是IP协议没有能确保数据包是否到达，传过去的数据是否按照顺序排列，所以IP数据包是不可靠的。而解决数据不可靠的问题就是由TCP协议来完成。</p><p>TCP（Transmission Control Protocol）是可靠的传输控制协议，三个特点：</p><ul><li>面向链接：需要对方主机在线，并建立链接</li><li>面向字节流：发送多少字节自己说了算，每次选出一段字节发送的时候，都会带上一个序号，这个序号就是发送的这段字节中编号最小的字节的编号。</li><li>可靠：保证数据有序的到达对方主机，每发送一个数据就会期待收到对方的回复，在指定时间内收到了ACK回复，就确认数据到达，如果超过一定的时间没有收到对方的回复，就认为对方没有收到，再重新发送一次。</li></ul><p>TCP报文</p><table><thead><tr><th>源端口（16）</th><th>目的端口（16）</th></tr></thead><tbody><tr><td>TCP序号（32）</td><td>TCP序号（32）</td></tr><tr><td>捎带的确认（32）</td><td>捎带的确认（32）</td></tr><tr><td>首部长度（4）保留（6）Flag（6：URG、ACK、PSH、RST、SYN、FIN）</td><td>窗口尺寸（16）</td></tr><tr><td>TCP校验和（16）</td><td>紧急指针（16）</td></tr><tr><td>数据包内容</td><td>数据包内容</td></tr></tbody></table><p>6个标志位：</p><ul><li>URG,紧急指针标志，当为1时表示紧急指针有效，为0时则忽略紧急指针</li><li>ACK,确认序号标志，为1表示确认有效，为0表示报文不含有确认信息，确认号无误</li><li>PSH,push标志，当为1时就是让接收方收到该TCP报文的时候不进入缓冲区排队而是快速发送给应用程序</li><li>RST,重置连接标志，当连接出现错误的时可以重置，或者用于拒绝非法的报文段和连接请求</li><li>SYN,同步序号，用于建立连接过程</li><li>FIN,finish标志，用于释放连接</li></ul><p>3次握手协议：</p><ol><li>第一次握手，当客户端需要去建立连接时，客户端就会发送SYN包（seq=x）到服务器，然后客户端进入SYN_SEND的状态，代表已经发SYN包过去，并且在等待服务器确认。此时，ACK=0,SYN=1。</li><li>第二次握手，服务器收到SYN包，会进行确认，由上面的标志知道SYN是表示同步序号，这时候会使得 确认号=序号+1，即ack等于x+1,然后服务器也会像客户端发送一个SYN包（seq=y),也就是服务器会发送SYN+ACK包，来表示确认到了客户端的一次握手并且二次握手建立，此时服务器进入SYN_RECV状态。此时，ACK=1,SYN=1。</li><li>第三次握手，客户端收到服务器的SYN+ACK包，然后就会向服务器发送确认包ACK(ack=y+1)和SYN(seq=x+1),等到这个包发送完毕之后客户端和服务器就会进入ESTABLISHED状态，完成三次握手，就可以在服务器与客户端之间传输数据了。</li></ol><p>SYN是同步序号，当SYN=1而ACK=0时表明这是一个连接请求报文，对方若同意连接，那应在报文中使SYN=1和ACK=1，因此SYN置1表示这是一个连接请求或者连接接受报文。而ACK状态是用来确认是否同意连接。也就是传了SYN,证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要ACK信号来验证</p><p>当在传送完数据之后，客户端与服务器端之间有四次握手协议：</p><ol><li>第一次握手：客户端发送一个FIN和序号过去（seq=u）用来表示客户端和服务端之间有关闭的请求，同时关闭客户端的数据传送，客户端就进入FIN_WAIT_1的状态</li><li>第二次握手：服务端收到FIN=1的标志位，就会发送一个ACK标志位表示确认，然后确认序号就变成了收到的序号+1,即ack=u+1(FIN和SYN在这点相同，但是作用不一样)这时候服务端进入CLOSE_WAIT状态，这是一个半关闭状态。只能服务端给客户端发送数据而客户端不能给服务端发送数据</li><li>第三次握手：这次握手还是服务端发起的。这是服务端在传完最后的数据（没有就不传）就会发送一个FIN=1和ACK=1,且序号seq会改变（没有传数据则不变），而ack不变，这时候服务端就会进入LAST_ACK状态，表示最后再确认一次。</li><li>第四次握手：客户端在接收到FIN之后，就会进入TIME_WAIT状态，接着发送一个ACK和seq=u+1,ack=w+1给服务端，这时候服务端就会进入CLOSED状态。而客户端进入TIME_WAIT状态的时候必须要等待2MSL的时间才会关闭</li></ol><p>TIME_WAIT状态的作用？（MSL：网络中数据报文存在的最大时间）</p><ol><li>TIME_WAIT状态可以确保有足够的时间让对方接收到ACK包，如果ACK没有到达，在传输过程丢失了或者一些其他原因，这样就可以让客户端重发ACK包，如果客户端直接关闭了，那么就有可能导致服务端在一些情况下没有接受到ACK包而无法与客户端断开连接。这样客户端发送ACK包到服务端，服务端请求重发，一来一回就刚好是2MSL</li><li>保证迟来的TCP报文段有足够的时间被识别并丢弃，linux中一个TCPort不能打开两次或者两次以上。当client处于time_wait状态时无法使用此port建立新连接，假设不存在time_wait状态，新连接可能会受到旧连接的数据</li></ol><h3 id="TCP粘包是什么-该怎么办"><a href="#TCP粘包是什么-该怎么办" class="headerlink" title="TCP粘包是什么,该怎么办"></a>TCP粘包是什么,该怎么办</h3><p>客户端（发送一端）在发送之前会将短时间有多个发送的数据块缓冲到一起（发送缓冲区），形成了一个大的数据块一并发送，同样接收端也有一个接收缓冲区，收到的数据先存放在接收端缓冲区，然后程序从这里读取部分数据进行消费，这样做也是为了减少I/O消耗达到性能优化。</p><p>数据达到缓冲区什么时间开发发送这个取决于TCP拥塞控制，是任何时刻内确定能被发送出去的字节数的控制因素之一，是阻止发送方至接收方之间的链路变得拥塞的手段</p><p>TCP粘包解决方案：</p><ol><li><p>延迟发送：设置延迟发送，sleep休眠一段时间。简单但是传输效率大大降低，只适用于交互频率低的情况</p></li><li><p>关闭nagle算法。nagle算法是一种改善网络传输效率的算法，避免网络中充斥着大量小的数据块，它所期望的是尽可能发送大的数据块，因此在每次请求一个数据块给TCP发送时，TCP并不会立即执行发送，而是等待一小段时间进行发送。</p><p>当网络中充斥着大量小的数据块时，Nagle算法能将小的数据块集合起来一起发送减少了网络拥堵，但并不是所有场景都需要这样。例如，REPL终端交互，当用户输入单个字符以获取响应，所以在nodejs中可以设置 socket.setNoDelay方法来关闭Nagle算法。<code>const server = net.createServer(); server.on(&#39;connection&#39;,socket=&gt;{socket.setNoDelay(true)})</code></p></li><li><p>封包/拆包。使用长度编码的方式，通信双方约定好格式，将消息分为定长的消息头（Header）和不定长的消息体（Body），在解析时读取消息头获取到内容的占用的长度，之后读取到的消息体内容字节数等于字节头的字节数时，认为它是一个完整的包。</p></li></ol><table><thead><tr><th>消息头序号（Header）</th><th>消息体长度（Header）</th><th>消息体（Body）</th></tr></thead><tbody><tr><td>SerialNumber</td><td>bodyLength</td><td>body</td></tr><tr><td>2字节</td><td>2字节</td><td>N字节</td></tr></tbody></table><p>Buffer的几个api：</p><ul><li>Buffer.alloc(size[,fill[,encoding]]),初始化一个size大小的Buffer空间，默认填充0，也可以指定fill进行自动以填充</li><li>Buffer.writeInt16BE(value[,offset]),value为要写入的Buffer值，offset为偏移量从哪个位置开始写入</li><li>Buffer.writeInt32BE(value[,offset]),value为要写入的Buffer值，不同的是writeInt16BE表示高位优先写入一个16位整型，这个是32位</li><li>Buffer.readInt16BE([offset])，高位优先读取16位整型，offset为读取之前要跳过的字节数</li><li>Buffer.readInt32BE([offset])，高位优先读取32位整型，offset为读取之前要跳过的字节数</li></ul><h4 id="编码-解码的实现"><a href="#编码-解码的实现" class="headerlink" title="编码/解码的实现"></a>编码/解码的实现</h4><p>TCP顶层是基于二进制数据，应用层通常是易于表达的字符串、数字等，需要先将数据通过Buffer转换为二进制，取出的时候同样需要解码操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// transcoder.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transcoder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.packageHeaderLen = <span class="number">4</span>; <span class="comment">// 包头长度</span></span><br><span class="line">    <span class="keyword">this</span>.serialNumber = <span class="number">0</span>; <span class="comment">// 定义包序号</span></span><br><span class="line">    <span class="keyword">this</span>.packageSerialNumberLen = <span class="number">2</span>; <span class="comment">// 包序列号所占用的字节</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 编码</span></span><br><span class="line"><span class="comment">   * @param &#123;Object&#125; data Buffer 对象数据</span></span><br><span class="line"><span class="comment">   * @param &#123;Int&#125; serialNumber 包序号，客户端编码时自动生成，服务器解码之后在编码时需要传入解码的包序号</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  encode(data, serialNumber) &#123;</span><br><span class="line">    <span class="keyword">const</span> body = Buffer.from(data);</span><br><span class="line">    <span class="keyword">const</span> header = Buffer.alloc(<span class="keyword">this</span>.packageHeaderLen);</span><br><span class="line">    header.writeInt16BE(serialNumber || <span class="keyword">this</span>.serialNumber);</span><br><span class="line">    header.writeInt16BE(body.length, <span class="keyword">this</span>.packageSerialNumberLen); <span class="comment">// 跳过包序号的前两位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (serialNumber === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.serialNumber++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Buffer.concat([header, body])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 解码</span></span><br><span class="line"><span class="comment">   * @param &#123;Object&#125; buffer</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  decode(buffer) &#123;</span><br><span class="line">    <span class="keyword">const</span> header = buffer.slice(<span class="number">0</span>, <span class="keyword">this</span>.packageHeader); <span class="comment">// 获取包头</span></span><br><span class="line">    <span class="keyword">const</span> body = buffer.slice(<span class="keyword">this</span>.packageHeaderLen); <span class="comment">// 获取包尾部</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      serialNumber: header.readInt16BE(),</span><br><span class="line">      bodyLength: header.readInt16BE(<span class="keyword">this</span>.packageSerialNumberLen), <span class="comment">// 因为编码阶段跳过两位，所以解码也需要跳过</span></span><br><span class="line">      body: body.toString(),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取包长度两种情况</span></span><br><span class="line"><span class="comment">   * 1. 如果当前buffer长度数据小于包头，肯定不是一个完整的数据包，因此直接返回0不做处理（可能数据还没有接收完）</span></span><br><span class="line"><span class="comment">   * 2. 否则返回这个完整的数据包长度</span></span><br><span class="line"><span class="comment">   * @param &#123;*&#125; buffer</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  getPackageLength(buffer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer.length &lt; <span class="keyword">this</span>.packageHeaderLen) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.packageHeaderLen + buffer.readInt16BE(<span class="keyword">this</span>.packageSerialNumberLen)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Transcoder;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> Transcoder = <span class="built_in">require</span>(<span class="string">'./transcoder'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> transcoder = <span class="keyword">new</span> Transcoder();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = net.createConnection(&#123;</span><br><span class="line">  host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">  port: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> overageBuffer = <span class="literal">null</span>; <span class="comment">//上一次Buffer剩下的数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client.on(<span class="string">'data'</span>, buffer =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (overageBuffer) &#123;</span><br><span class="line">    buffer = Buffer.concat([overageBuffer, buffer])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> packageLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// eslint-disable-next-line no-cond-assign</span></span><br><span class="line">  <span class="keyword">while</span> (packageLength = transcoder.getPackageLength(buffer)) &#123;</span><br><span class="line">    <span class="keyword">const</span> packageData = buffer.slice(<span class="number">0</span>, packageLength); <span class="comment">// 取出整个数据包</span></span><br><span class="line">    buffer = buffer.slice(packageLength); <span class="comment">// 删除已经取出的数据包，这里采用的方法是把缓冲区（buffer）已取出的包给截掉</span></span><br><span class="line">    <span class="keyword">const</span> result = transcoder.decode(packageData); <span class="comment">// 解码</span></span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  overageBuffer = buffer; <span class="comment">// 记录剩余不完整的包</span></span><br><span class="line">&#125;).on(<span class="string">'error'</span>, err =&gt; &#123; <span class="comment">// 监听一个未开启的端口就会报 ECONNREFUSED错误</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`服务器异常: <span class="subst">$&#123;err&#125;</span>`</span>)</span><br><span class="line">&#125;).on(<span class="string">'close'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`客户链接断开！， <span class="subst">$&#123;err&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">client.write(transcoder.encode(<span class="string">'Nodejs 技术栈'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  <span class="string">'1 JavaScript '</span>,</span><br><span class="line">  <span class="string">'2 TypeScript '</span>,</span><br><span class="line">  <span class="string">'3 Python '</span>,</span><br><span class="line">  <span class="string">'4 Java '</span>,</span><br><span class="line">  <span class="string">'5 C '</span>,</span><br><span class="line">  <span class="string">'6 PHP '</span>,</span><br><span class="line">  <span class="string">'7 ASP.NET '</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">    client.write(transcoder.encode(arr[i]))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> Transcoder = <span class="built_in">require</span>(<span class="string">'./transcoder'</span>);</span><br><span class="line"><span class="keyword">const</span> transcoder = <span class="keyword">new</span> Transcoder();</span><br><span class="line"><span class="keyword">const</span> HOST = <span class="string">'127.0.0.1'</span>;</span><br><span class="line"><span class="keyword">const</span> PORT = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">let</span> overageBuffer = <span class="literal">null</span>; <span class="comment">// 上一次善剩余数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个TCP服务实例</span></span><br><span class="line"><span class="keyword">const</span> server = net.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">server.listen(PORT, HOST)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'listening'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`服务已经开启在<span class="subst">$&#123;HOST&#125;</span>:<span class="subst">$&#123;PORT&#125;</span>`</span>)</span><br><span class="line">&#125;).on(<span class="string">'connection'</span>, socket =&gt; &#123;</span><br><span class="line">  <span class="comment">// data事件就是读取数据</span></span><br><span class="line">  socket.on(<span class="string">'data'</span>, buffer =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (overageBuffer) &#123;</span><br><span class="line">      buffer = Buffer.concat([overageBuffer, buffer])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> packageLength = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line no-cond-assign</span></span><br><span class="line">    <span class="keyword">while</span> (packageLength = transcoder.getPackageLength(buffer)) &#123;</span><br><span class="line">      <span class="keyword">const</span> packageData = buffer.slice(<span class="number">0</span>, packageLength); <span class="comment">//取出整个数据包</span></span><br><span class="line">      buffer = buffer.slice(packageLength); <span class="comment">// 删除取出的数据包，这里采用的方法是把缓冲区buffer已取出的包截掉</span></span><br><span class="line">      <span class="keyword">const</span> result = transcoder.decode(packageData); <span class="comment">// 解码</span></span><br><span class="line">      <span class="built_in">console</span>.log(result);</span><br><span class="line">      socket.write(transcoder.encode(result.body, result.serialNumber))</span><br><span class="line">    &#125;</span><br><span class="line">    overageBuffer = buffer; <span class="comment">// 记录不完整的包  </span></span><br><span class="line">  &#125;).on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'socket end'</span>)</span><br><span class="line">  &#125;).on(<span class="string">'error'</span>, error =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'socket error'</span>, error)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).on(<span class="string">'close'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Server Close!'</span>)</span><br><span class="line">&#125;).on(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err.code === <span class="string">'EADDRINUSE'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'地址正被使用，重试中......'</span>)</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      server.close();</span><br><span class="line">      server.listen(PORT.HOST)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`服务器异常: <span class="subst">$&#123;err&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS模块是基于UDP协议来实现的，在Nodejs中可以通过<code>require(&#39;dns&#39;)</code>实现域名的解析查询，Nodejs DNS模块分成两大类：</p><ol><li>底层操作系统工具进行域名解析</li><li>链接到一个DNS网络服务器执行域名解析</li></ol><h3 id="底层操作工具域名解析"><a href="#底层操作工具域名解析" class="headerlink" title="底层操作工具域名解析"></a>底层操作工具域名解析</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Nodejs DNS模块的 dns.lookup()方法使用底层操作系统进行域名解析，是不需要经过网络通信的</span></span><br><span class="line"><span class="keyword">const</span> dns = <span class="built_in">require</span>(<span class="string">'dns'</span>);</span><br><span class="line"></span><br><span class="line">dns.lookup(<span class="string">'laibh.top'</span>,(err,address,family)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`地址: <span class="subst">$&#123;address&#125;</span>,地址族：<span class="subst">$&#123;family&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="链接到DNS服务器执行域名解析"><a href="#链接到DNS服务器执行域名解析" class="headerlink" title="链接到DNS服务器执行域名解析"></a>链接到DNS服务器执行域名解析</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dns 模块除了 dns.lookup之外的函数，都会连接到实际DNS服务器以执行名称解析并始终使用网络执行DNS查询</span></span><br><span class="line"><span class="keyword">const</span> dns = <span class="built_in">require</span>(<span class="string">'dns'</span>);</span><br><span class="line">dns.lookup(<span class="string">'laibh.top'</span>,(err,records)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(records)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>dns.lookup与dns.resolve</code>不同</p><p>虽然用异步的角度来使用dns.lookup，但是内部的libuv底层线程池中确实同步的调用 getaddrinfo(3)，所以可能有由于一些不确定的因素造成Node进程阻塞</p><p>与dns.lookup不同的是dns.resolve没有使用getaddrinfo(3)，而通过网络执行的DNS查询，始终保持异步不会对其他进程产生负面影响</p><h3 id="DNS域名解析过程"><a href="#DNS域名解析过程" class="headerlink" title="DNS域名解析过程"></a>DNS域名解析过程</h3><ol><li>浏览器DNS缓存。访问一个URL优先查找浏览器的DNS缓存，命中就返回。未命中就继续下一步，查找操作系统的缓存。当修改了本地hosts域名指向发现浏览器缓存没有变化是因为每个浏览器有一个固定值。</li><li>系统（OS）缓存。查看操作系统中是否有域名对应的IP,位于操作系统的hosts文件。</li><li>路由器缓存。当浏览器DNS与系统OS缓存均没有映射的时候，则请求会发送到路由器缓存中检查</li><li>ISP DNS缓存。ISP为互联网服务提供商。</li></ol><p>DNS本地解析指的是系统缓存这一阶段，在浏览器缓存没有命中的情况下， 会从本地系统的一个hosts文件中寻找对应的IP</p><h2 id="Cluster-（集群）"><a href="#Cluster-（集群）" class="headerlink" title="Cluster （集群）"></a>Cluster （集群）</h2><p>在PM2的配置文件中可以设置<code>exec_model:&#39;cluster</code>和<code>instance</code>两个属性来设置开启多个进程，PM2其实就是利用Nodejs Cluster这个模块来实现的，还有eggJs中的egg-cluster模块在启用Worker进程也是用到这个模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> numCPUs = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus().length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Master 进程 <span class="subst">$&#123;process.pid&#125;</span> 正在运行`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numCPUs; i++) &#123;</span><br><span class="line">    cluster.fork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cluster.on(<span class="string">'exit'</span>, (worker, code, signal) =&gt; &#123; <span class="built_in">console</span>.log(<span class="string">`Worker <span class="subst">$&#123;worker.process.pid&#125;</span> 已退出`</span>) &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">`你好，哈哈哈 <span class="subst">$&#123;process.pid&#125;</span>`</span>)</span><br><span class="line">  &#125;).listen(<span class="number">8000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Worker 进程 <span class="subst">$&#123;process.pid&#125;</span> 已启用`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="采用了哪种集群方式"><a href="#采用了哪种集群方式" class="headerlink" title="采用了哪种集群方式"></a>采用了哪种集群方式</h3><p>集群模式通常实现有两种：</p><ol><li>1个Node实例开启多个端口，通过反向代理服务器向各端口服务进行转发</li><li>1个Node实例开启多个进程监听同一个端口，通过负载均衡技术分配请求（Master-&gt;Worker）</li></ol><p>第一个方案存在的一个问题就是占用多个端口，造成资源浪费，由于多个实例是独立运行的，进程间通信不太好做。好处是稳定性高，各实例之间没有影响。</p><p>第二个方案多个Node进程去监听同一个端口，好处是进程间通信相对简单，减少了端口的资源浪费，但是这个时候需要保证服务进程的稳定性，特别是对Master进程稳定性要求会更高，编码也会复杂。</p><p>Nodejs中自带的Cluster模块正是采用了第二种方案。</p><h3 id="多个进程为什么可以监听同一个端口"><a href="#多个进程为什么可以监听同一个端口" class="headerlink" title="多个进程为什么可以监听同一个端口"></a>多个进程为什么可以监听同一个端口</h3><p>端口不是被所有的进程全部监听，仅仅受到Master进程的监听。Master进程创建一个Socket并绑定监听到目标端口，通过子进程之间建立IPC通道之后，通过调用子进程的send方法，将Socket（链接句柄）传递过去。（Master通过cluster.fork方法创建的，本质上还是使用了child_process.fork这个方法）</p><p>使用 child_process.fork()创建的子进程，进行Socket传递的示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.js</span></span><br><span class="line"><span class="keyword">const</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork;</span><br><span class="line"><span class="keyword">const</span> cpus = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus();</span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">'net'</span>).createServer().listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;cpus.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> worker = fork(<span class="string">'worker.js'</span>);</span><br><span class="line">      <span class="comment">// 将 Master 的 server 传递给子进程</span></span><br><span class="line">    worker.send(<span class="string">'server'</span>, server);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'worker process created, pid: %s ppid: %s'</span>, worker.pid, process.pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="string">'I am worker, pid: '</span> + process.pid + <span class="string">', ppid: '</span> + process.ppid);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> worker;</span><br><span class="line"><span class="comment">// 第二个参数 sendHandle 就是句柄，可以是 TCP套接字、TCP服务器、UDP套接字等</span></span><br><span class="line">process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">message, sendHandle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message === <span class="string">'server'</span>) &#123;</span><br><span class="line">        worker = sendHandle;</span><br><span class="line">        worker.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">            server.emit(<span class="string">'connection'</span>, socket);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>端口会被主进程绑定监听一次，但是主进程和子进程在建立IPC通信之后，发送Socket到子进程实现端口共享，在之后Master接受到新的客户端链接后，通过负载均衡技术再转发到各Worker进程。</p><h3 id="多个进程之间如何通信"><a href="#多个进程之间如何通信" class="headerlink" title="多个进程之间如何通信"></a>多个进程之间如何通信</h3><p>由于cluster.fork本质上还是使用child_process.fork()这个方法来创建子进程，进程间通信无非几种：pipe（管道）、消息队列、信号量、Domain Socket。Nodejs中是通过pipe(管道)实现的，pipe作用于之间有血缘关系的进程，通过fork传递，其本身也是一个进程，将一个进程的输出作为另外一个进程的输入。</p><h3 id="如何对多个Worker进行请求转发"><a href="#如何对多个Worker进行请求转发" class="headerlink" title="如何对多个Worker进行请求转发"></a>如何对多个Worker进行请求转发</h3><p>在Nodejs中使用了RoundRobin负载均衡策略，简称RP,它的实现原理是一种无状态的轮询策略，假定每台服务器的硬件资源、处理性能都是相同的，根据进程的数量，依次分配，直到所有进程处理完了，再开始重新计算分配。优点是实现起来简洁也易用，缺点是如果出现某个请求占用的时间较长，就会导致负载不会太均衡。</p><p>RP这种负载均衡技术适用于同一组服务器拥有相同的软硬件配置且平均的服务请求响应</p><p>RP是一种常见的复杂均衡技术，Nginx中也有使用，另外在RP的基础上还衍生了一个Weighted Round-Robin权重负载均衡轮询算法，简称WRR,同样也是使用轮询的技术，但是在基础上考虑了服务器的处理能力，实现时为服务器加上权重，这种负载均衡算法能够确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。</p><h3 id="Nodejs负载均衡策略设置"><a href="#Nodejs负载均衡策略设置" class="headerlink" title="Nodejs负载均衡策略设置"></a>Nodejs负载均衡策略设置</h3><ul><li>RoundRobin,RR。设置时要使用cluster.SCHED_RR,如果通过环境变量设置要使用rr,如果用cluster对象获取 schedulingPolicy数字表示为2</li><li>Shared Socket，SS,设置时要用cluster.SCHED_NONE，如果通过环境变量设置要用node,如果用cluster对象获取schedulingPolicy数字表示为1</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cluster对象的schedulingPolicy属性设置</span></span><br><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略一：一种轮询的策略，默认值</span></span><br><span class="line">cluster.schedulingPolicy = cluster.SHCED_RR;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略二:由操作系统调度的策略</span></span><br><span class="line">cluster.schedulingPolicy = cluster.SCHED_NONE;</span><br><span class="line"></span><br><span class="line">cluster.fork();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者通过环境变量 NODE_CLUSTER_SCHED_POLICY设置：</span></span><br><span class="line">env NODE_CLUSTER_SCHED_POLICY = <span class="string">'none'</span> node app.js</span><br></pre></td></tr></table></figure><h2 id="基于Stream实现多文件合并"><a href="#基于Stream实现多文件合并" class="headerlink" title="基于Stream实现多文件合并"></a>基于Stream实现多文件合并</h2><h3 id="一个简单的Stream操作"><a href="#一个简单的Stream操作" class="headerlink" title="一个简单的Stream操作"></a>一个简单的Stream操作</h3><p>创建一个可读流readable一个可写流writeable，通过管道pipe将可写流绑到可读流，一个简单的Stream操作就可以完成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> readable = fs.createReadStream(<span class="string">'./log/read.txt'</span>);</span><br><span class="line"><span class="keyword">const</span> writeable = fs.createWriteStream(<span class="string">'./log/write.txt'</span>);</span><br><span class="line"></span><br><span class="line">readable.pipe(writeable)</span><br><span class="line"></span><br><span class="line"><span class="comment">// readable.pip(destionation[,option])</span></span><br><span class="line"><span class="comment">// destionation：是一个可写流对象，也就是一个数据写入的目标对象</span></span><br><span class="line"><span class="comment">// options:end,读取结束时终止写入流，默认值是true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认情况下不需要手动调用写入流的end方法关闭的，更改end为false写入的目标将会处于一直打开状态，此时就需要监听可读流的end时间，结束之后手动调用可写流的end事件。</span></span><br><span class="line"></span><br><span class="line">readable.pipe(writeable,&#123;</span><br><span class="line">    end:<span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">readable.on(<span class="string">'end'</span>,()=&gt;&#123;</span><br><span class="line">    writeable.end(<span class="string">'结束'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果可读流期间发什么什么错误，则写入的目标流将不会关闭，所以需要监听错误事件，手动关闭可写流，防止内存泄露。</p><h3 id="多个文件通过Stream合并成一个文件"><a href="#多个文件通过Stream合并成一个文件" class="headerlink" title="多个文件通过Stream合并成一个文件"></a>多个文件通过Stream合并成一个文件</h3><p>设置可读流的end为false可以保持写入流一直处于打开状态，通过这种方式，一开始可写流处于打开状态，知道所有的可读流结束，我们再将可写流关闭。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stream 合并</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; sourceFiles 源文件目录名</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; targetFile 目标文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">streamMerge</span>(<span class="params">sourceFiles, targetFile</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> scripts = fs.readdirSync(path.resolve(__dirname, sourceFiles)); <span class="comment">// 获取源文件目录下的所有文件</span></span><br><span class="line">  <span class="keyword">const</span> fileWriteStream = fs.createWriteStream(path.resolve(__dirname, targetFile)); <span class="comment">// 创建一个可写流</span></span><br><span class="line">  streamMergeRecursive(scripts, fileWriteStream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stream 合并的递归调用</span></span><br><span class="line"><span class="comment"> * @param &#123;Array&#125; scripts</span></span><br><span class="line"><span class="comment"> * @param &#123;Stream&#125; fileWriteStream</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">streamMergeRecursive</span>(<span class="params">scripts = [], fileWriteStream</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归到尾 的情况判断</span></span><br><span class="line">  <span class="keyword">if</span> (!scripts.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> fileWriteStream.end(<span class="string">"console.log('Stream 合并完成')"</span>) <span class="comment">// 最后关闭可写流，防止内存泄露</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> currentFile = path.resolve(__dirname, <span class="string">'scripts/'</span>, scripts.shift());</span><br><span class="line">  <span class="keyword">const</span> currentReadStream = fs.createReadStream(currentFile); <span class="comment">// 获取当前的可读流</span></span><br><span class="line"></span><br><span class="line">  currentReadStream.pipe(fileWriteStream, &#123; <span class="attr">end</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  currentReadStream.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    streamMergeRecursive(scripts, fileWriteStream)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  currentReadStream.on(<span class="string">'error'</span>, (error) =&gt; &#123; <span class="comment">// 监听错误事件，关闭可读流，防止内存泄露</span></span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">    fileWriteStream.close()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">streamMerge(<span class="string">'./scripts'</span>, <span class="string">'./script.js'</span>)</span><br></pre></td></tr></table></figure><h2 id="Stream-pipe的使用与实现原理"><a href="#Stream-pipe的使用与实现原理" class="headerlink" title="Stream pipe的使用与实现原理"></a>Stream pipe的使用与实现原理</h2><p>通过流我们可以将一大块数据拆分称为一小部分一点一点的流动起来，不需要一次性全部读入，在Linux下可以通过<code>|</code>符号实现，类似的在Nodejs的Stream模块中同样也为我们提供了 pipe方法来实现</p><h3 id="未使用Stream-pipe的情况"><a href="#未使用Stream-pipe的情况" class="headerlink" title="未使用Stream pipe的情况"></a>未使用Stream pipe的情况</h3><p>在Nodejs中I/O操作都是异步的，先用util模块的promiseify方法将fs.readFile的callback形式转换为Promise形式</p><p>，它将数据一次性读入内存然后再进行返回，当数据文件很大的时候也是对内存的一种消耗，不推荐</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// koa 的例子</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> &#123;promisify&#125; = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;resolve&#125; = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx=&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ctx.body = <span class="keyword">await</span> readFile(resolve(__dirname,<span class="string">'test.json'</span>)))</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        ctx.body = err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><h3 id="使用Steam-pipe"><a href="#使用Steam-pipe" class="headerlink" title="使用Steam pipe"></a>使用Steam pipe</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx=&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> readable = fs.createReadStream(resolve(__dirname,<span class="string">'test.json'</span>));</span><br><span class="line">        ctx.body = readable;       </span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        ctx.body = err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 在Koa中直接创建一个可读流赋值给ctx.body，框架内封装好了pipe方法，下面为源码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">respond</span>(<span class="params">ctx</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> body = ctx.body;</span><br><span class="line">    <span class="keyword">if</span>(body <span class="keyword">instanceof</span> Stream) <span class="keyword">return</span> body.pipe(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用与不使用Stream"><a href="#使用与不使用Stream" class="headerlink" title="使用与不使用Stream"></a>使用与不使用Stream</h3><p>使用了可读流，通过pipe接口监听data与end事件，把data的可读流拆分称为一小块一小块的数据（chunks），像流水一样源源不断吐给客户端，而不再需要等待整个文件都加载到内存后才发送数据。pipe可以视为流的管道/通道方法，任何类型的流都会有这个方法来处理流的输入与输出。</p><p>总体来说，使用流可以大大提升响应时间，又能有效减轻服务器内存的压力</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>在应用层调用 fs.createReadStream 方法，找到这个方法创建的可读流对象pipe的方法实现</p><h4 id="lib-fs-js"><a href="#lib-fs-js" class="headerlink" title="/lib/fs.js"></a>/lib/fs.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出一个createReadStream方法，在这个方法里面创建一个ReadSream可读流对象，且ReadStream来自internal/fs/streams</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒加载，主要在用到的时候用来实例化 ReadStream/WriteStream等对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyLoadStreams</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!ReadStream)&#123;</span><br><span class="line">        (&#123;ReadStream,WriteStream&#125;) = <span class="built_in">require</span>(<span class="string">'internal/fs/streams'</span>);</span><br><span class="line">        [FileReadStream,FileWriteStream] = [ReadStream,WriteStream];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReadStream</span>(<span class="params">path,options</span>)</span>&#123;</span><br><span class="line">   lazyLoadStreams();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReadStream(path,options); <span class="comment">// 创建一个可读流</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = fs = &#123;</span><br><span class="line">    createReadStream, <span class="comment">// 导出 createReadStream 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lib-internal-fs-streams-js"><a href="#lib-internal-fs-streams-js" class="headerlink" title="/lib/internal/fs/streams.js"></a>/lib/internal/fs/streams.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法定义了构造函数 ReadStream，且在原型上定义了 open、_read、_destroy等方法，没有pipe方法，通过ObjectSetPrototypeOf方法实现了继承，ReadStream继承了Readable在原型中定义的函数，继续查找Readable的实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;Readable,Writeable&#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReadStream</span>(<span class="params">path,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> ReadStream)) <span class="keyword">return</span> <span class="keyword">new</span> ReadStream(path,options)</span><br><span class="line">    </span><br><span class="line">    Readable.call(<span class="keyword">this</span>,options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ObjectSetPrototypeOf(ReadStream.prototype,Readable.prototype);</span><br><span class="line">ObjectStreamProtptypeOf(ReadStream,Readable);</span><br><span class="line"></span><br><span class="line">ReadStream.prototype.open = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">ReadStream.prototype._read = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;&#125;</span><br><span class="line">ReadStream.prototype._destroy = <span class="function"><span class="keyword">function</span>(<span class="params">err,cb</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">module</span>.<span class="title">exports</span> = </span>&#123;</span><br><span class="line">    ReadStream,</span><br><span class="line">    WriteStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lib-stream-js"><a href="#lib-stream-js" class="headerlink" title="/lib/stream.js"></a>/lib/stream.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// to avoid cross-reference(require) issue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Stream = <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'internal/streams/legacy'</span>);</span><br><span class="line"></span><br><span class="line">Stream.Readable = <span class="built_in">require</span>(<span class="string">'_stream_readable'</span>);</span><br><span class="line">Stream.Writable = <span class="built_in">require</span>(<span class="string">'_stream_writable'</span>)</span><br><span class="line">Stream.Duplex = <span class="built_in">require</span>(<span class="string">'_stream_duplex'</span>);</span><br><span class="line">Stream.Transform = requier(<span class="string">'_stream_transform'</span>);</span><br><span class="line">Stream.PassThrough = <span class="built_in">require</span>(<span class="string">'_stream_passthrough'</span>);</span><br></pre></td></tr></table></figure><h4 id="lib-internal-streams-legacy-js"><a href="#lib-internal-streams-legacy-js" class="headerlink" title="/lib/internal/streams/legacy.js"></a>/lib/internal/streams/legacy.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承了Events 模块，然后在原型上定义了pipe方法，而_stream_readable继承了Stream之后又自己实现了pipe方法</span></span><br><span class="line"><span class="keyword">const</span> &#123;ObjectSetPrototypeOf&#125; = primordials;</span><br><span class="line"><span class="keyword">const</span> EE = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stream</span>(<span class="params">opts</span>)</span>&#123;</span><br><span class="line">   EE.call(<span class="keyword">this</span>,opts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ObjectSetPrototypeOf(Stream.prototype,EE.prototype);</span><br><span class="line">ObjectSetPrototypeOf(Stream,EE);</span><br><span class="line"></span><br><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = Stream;</span><br></pre></td></tr></table></figure><h4 id="lib-stream-readable-js"><a href="#lib-stream-readable-js" class="headerlink" title="/lib/_stream_readable.js"></a>/lib/_stream_readable.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了Readable构造函数，且继承于lib/stream.js的Stream，然后重写pipe方法</span></span><br><span class="line"><span class="built_in">module</span>.exports = Readable;</span><br><span class="line">Readable.ReadableState = ReadableState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> EE = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> Stream = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br><span class="line"></span><br><span class="line">ObjectSetPrototypeOf(Readable.prototype,Stream.prototype)</span><br><span class="line">ObjectSetPrototypeOf(Readable,Stream);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Readable</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Readable)) <span class="keyword">return</span> <span class="keyword">new</span> Readable(options)</span><br><span class="line">    </span><br><span class="line">    Stream.call(<span class="keyword">this</span>,options); <span class="comment">// 继承自 Stream构造函数的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="stream-readable-js实现分析"><a href="#stream-readable-js实现分析" class="headerlink" title="_stream_readable.js实现分析"></a>_stream_readable.js实现分析</h5><p>1.声明构造函数Readable，继承Stream的构造函数和原型。</p><p>文件继承了events事件，拥有了events在原型中定义的属性，例如on、emit</p><p>2.声明pipe方法，订阅data事件</p><p>在Stream原型上声明pipe方法，订阅data事件，src为可读对象，dest为可写流对象。在使用pipe方法的时候也是监听的data事件，一边读取一边写入数据。</p><p>ondata方法的几个核心的实现：</p><ul><li>dest.write(chunk):接受chunk写入数据，如果内部的缓冲小于创建流时配置的highWaterMark，则返回true（缓存未满）,否则返回false时应该停止向流写入数据，直到‘drain’（清空缓存）事件被触发</li><li>src.pause()：可读流会停止data事件，意味着此时暂停数据写入了</li></ul><p>调用src.pause是为了防止读入数据过快来不及写入，如果缓存未满即dest.write(chunk)，这个缓存是根据创建流时创建的highWaterMark属性，默认为16384（16k），对象模式的流默认为16</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> src = <span class="keyword">this</span>;</span><br><span class="line">    src.on(<span class="string">'data'</span>,ondata);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ondata</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> ret = dest.write(chunk);</span><br><span class="line">        <span class="keyword">if</span>(ret === <span class="literal">false</span>)&#123;</span><br><span class="line">            ...</span><br><span class="line">            src.pause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.订阅drain事件，继续流动数据。继续写入事件到流时会触发drain事件，也就是dest.write(chunk)等于false(缓存满了)时，如果ondrain不存在则注册drain事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> src = <span class="keyword">this</span>;</span><br><span class="line">    src.on(<span class="string">'data'</span>,ondata);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ondata</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> ret = dest.write(chunk);</span><br><span class="line">        <span class="keyword">if</span>(ret === <span class="literal">false</span>)&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span>(!ondrain)&#123;</span><br><span class="line">        <span class="comment">// When the dest drains, it reduces the awaitDrain counter</span></span><br><span class="line">        <span class="comment">// on the source.  This would be more elegant with a .once()</span></span><br><span class="line">        <span class="comment">// handler in flow(), but adding and removing repeatedly is</span></span><br><span class="line">        <span class="comment">// too slow.    </span></span><br><span class="line">                ondrain = pipeOnDrain(src);</span><br><span class="line">                dest.on(<span class="string">'drain'</span>,ondrain);</span><br><span class="line">            &#125;</span><br><span class="line">            src.pause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当写入流dest耗尽时，它将会在可读流对象 source上减少 awaitDrain计数器，为了确保所有需要缓存的写入都完成，即state.awaitDrain === 0和src可读流上的data事件存在，切换流到流动模式</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pipeOnDrain</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">pipeDrainFunctionResult</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> state = src._readableState;</span><br><span class="line">            debug(<span class="string">'pipeOnDrain'</span>,state.awaitDrain);</span><br><span class="line">            <span class="keyword">if</span>(state.awaitDrain)&#123;</span><br><span class="line">                state.awaitDrain--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(state.awaitDrain ===<span class="number">0</span> &amp;&amp; EE.listenerCount(src,<span class="string">'data'</span>))&#123;</span><br><span class="line">                state.flowing = <span class="literal">true</span>;</span><br><span class="line">                flow(src)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Stream.read() 从内部缓存拉取并返回数据，如果没有可读的数据，则返回null，在可读流上src还有一个readable属性，如果可以安全地调用readable,read(),则为true</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">slow</span>(<span class="params">stream</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> state = stream._readableState;</span><br><span class="line">        debug(<span class="string">'flow'</span>,state.flowing);</span><br><span class="line">        <span class="keyword">while</span>(state.flowing &amp;&amp; stream.read() !== <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.触发data事件。调用readable的resume方法，触发可读流的data事件，进入流动模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> src = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// start the flow if it hasnot been started already.</span></span><br><span class="line">    <span class="keyword">if</span>(!state.flowing)&#123;</span><br><span class="line">        debug(<span class="string">'pipe resume'</span>)</span><br><span class="line">        src.resume();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resume方法内部又调用resume_()，最终执行了stream.read(0)读取了一次空数据（size设置为0），将会触发实例上的_read()方法，再触发data事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resume</span>(<span class="params">stream,state</span>)</span>&#123;</span><br><span class="line">    process.nextTick(resume_,stream,state)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resume_</span>(<span class="params">stream,state</span>)</span>&#123;</span><br><span class="line">    debug(<span class="string">'resume'</span>,state.reading);</span><br><span class="line">    <span class="keyword">if</span>(!state.reading)&#123;</span><br><span class="line">        stream.read(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.订阅end事件</p><p>end事件：当可读流中没有数据可供消费时触发，调用onend函数，执行dest.end()方法，表明已没有数据要被写入可写流，进行关闭（关闭可写流的id）,之后再调用stream.write会导致错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> doEnd = (!pipeOpts || pipeOpts.end !== <span class="literal">false</span>) &amp;&amp; dest !== process.stdout &amp;&amp;</span><br><span class="line">          dest !== process.stderr;</span><br><span class="line">    <span class="keyword">const</span> endFn = doEnd?onend:unpipe;</span><br><span class="line">    <span class="keyword">if</span>(state.endEmitted)&#123;</span><br><span class="line">        process.nestTick(endFn)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        src.once(<span class="string">'end'</span>,endFn)</span><br><span class="line">    &#125;</span><br><span class="line">    dest.on(<span class="string">'unpipe'</span>,onunpipe)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onend</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        debug(<span class="string">'onend'</span>);</span><br><span class="line">        dest.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.触发pipe事件，传入可读流对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> source = <span class="keyword">this</span>;</span><br><span class="line">    dest.emit(<span class="string">'pipe'</span>,src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在应用层使用但的时候可以在可写流上订阅pipe事件，做一些判断。</p><p>7.支持链式调用，最后返回dest</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.protptype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lib-internal-streams-legacy-js模块实现分析"><a href="#lib-internal-streams-legacy-js模块实现分析" class="headerlink" title="/lib/internal/streams/legacy.js模块实现分析"></a>/lib/internal/streams/legacy.js模块实现分析</h2><h3 id="声明构造函数Stream"><a href="#声明构造函数Stream" class="headerlink" title="声明构造函数Stream"></a>声明构造函数Stream</h3><p>声明构造函数Stream继承于事件events,此时就拥有了events在原型定义的属性，例如on/emit等方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;ObjectSetPrototypeOf&#125; = primordials;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> EE = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stream</span>(<span class="params">opts</span>)</span>&#123;</span><br><span class="line">    EE.call(<span class="keyword">this</span>,opts)</span><br><span class="line">&#125;</span><br><span class="line">ObjectSetPrototypeOf(Stream.prototype,EE.prototype);</span><br><span class="line">ObjectSetPrototypeOf(Stream,EE)</span><br></pre></td></tr></table></figure><h3 id="声明pipe方法，订阅data事件"><a href="#声明pipe方法，订阅data事件" class="headerlink" title="声明pipe方法，订阅data事件"></a>声明pipe方法，订阅data事件</h3><p>在Stream原型上声明pipe方法，订阅data事件，source为可读流对象，dest为可写流对象</p><p>在使用pipe方法的时候也是监听的data事件，一边读取数据一边写入数据</p><p>ondata方法的几个API：</p><ul><li>dest.writable：如果调用writable.write()是安全的，则为true</li><li>dest.write(chunk)：接收chunk写入数据，如果内部的缓冲小于内部创建流时配置的highWaterMark，则返回true,否则返回false时应该停止向流写入数据，知道drain事件被触发。</li><li>source.pause()：可读流会停止data事件，意味着此时暂停数据写入了</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> source = <span class="keyword">this</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ondata</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dest.writable &amp;&amp; dest.write(chunk) === <span class="literal">false</span> &amp;&amp; source.pause)&#123;</span><br><span class="line">            source.pause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    source.on(<span class="string">'data'</span>,ondata)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="订阅drain事件"><a href="#订阅drain事件" class="headerlink" title="订阅drain事件"></a>订阅drain事件</h3><p>如果调用dest.write(chunk)返回false,就会调用source.pause()停止数据流动，继续写入事件到流时会触发drain事件，ondrain方法的几个API：</p><ul><li>source.readable：如果可以安全地调用readable.read()，则为true,例如数据未读到末尾，则会返回true，表示可读的。</li><li>source.resume()：将被暂停的可读流恢复触发data事件，并将流切换流动模式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ondrain</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(source.readable &amp;&amp; source.resume)&#123;</span><br><span class="line">            source.resume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dest.on(<span class="string">'drain'</span>,ondrain)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选项指定end属性，订阅end-close事件"><a href="#选项指定end属性，订阅end-close事件" class="headerlink" title="选项指定end属性，订阅end,close事件"></a>选项指定end属性，订阅end,close事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果end选项没有被提供，可读流订阅end或者close事件，后续将会触发该事件，指定dest.end方法，仅被调用一次，didOnEnd变量做了控制，主要是为了关闭可写流的id</span></span><br><span class="line"><span class="comment">// close:当流或者底层资源（比如文件描述符）被关闭时触发close事件</span></span><br><span class="line"><span class="comment">// end: 当可读流中没有数据可供消费的时候触发</span></span><br><span class="line"><span class="comment">// 可读流的end,destroy方法</span></span><br><span class="line"><span class="comment">// dest.end() 表明已经没有数据要被写入可写流，进行关闭，之后再调用stream.write会导致错误</span></span><br><span class="line"><span class="comment">// dest.destory() 销毁流</span></span><br><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!dest._isStdio &amp;&amp; (!options || options.end !== <span class="literal">false</span>))&#123;</span><br><span class="line">        source.on(<span class="string">'end'</span>,onend);</span><br><span class="line">        source.on(<span class="string">'close'</span>,onclose);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> didOnEnd = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onend</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(didOnEnd) <span class="keyword">return</span>;</span><br><span class="line">        didOnEnd = <span class="literal">true</span>;</span><br><span class="line">        dest.end();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onclose</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(didOnEnd) <span class="keyword">return</span>;</span><br><span class="line">        didOnEnd = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> dest.destory === <span class="string">'function'</span>)&#123;</span><br><span class="line">            dest.destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="订阅可读流与可写流的error事件"><a href="#订阅可读流与可写流的error事件" class="headerlink" title="订阅可读流与可写流的error事件"></a>订阅可读流与可写流的error事件</h3><p>可读流、可写流发生错误时触发error事件，调用onerror方法，首先移除可读流，可写流订阅的所有事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onerror</span>(<span class="params">er</span>)</span>&#123;</span><br><span class="line">        cleanup();</span><br><span class="line">        <span class="keyword">if</span>(EE.listenerCount(<span class="keyword">this</span>,<span class="string">'error'</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> er;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    source.on(<span class="string">'error'</span>,onerror);</span><br><span class="line">    dest.on(<span class="string">'error'</span>,onerror);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cleanup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        source.removeListener(<span class="string">'data'</span>,ondata);</span><br><span class="line">        dest.removeListener(<span class="string">'drain'</span>,ondrain);</span><br><span class="line">        </span><br><span class="line">        source.removeListener(<span class="string">'end'</span>,onend);</span><br><span class="line">        source.removelistener(<span class="string">'close'</span>,onclose);</span><br><span class="line">        </span><br><span class="line">        source.removeListener(<span class="string">'error'</span>,onerror);</span><br><span class="line">        dest.removelistener(<span class="string">'error'</span>,onerror);</span><br><span class="line">        </span><br><span class="line">        source.removeListener(<span class="string">'end'</span>,cleanup);</span><br><span class="line">        source.removelistener(<span class="string">'close'</span>,cleanup);     </span><br><span class="line">        </span><br><span class="line">        dest.removelistener(<span class="string">'close'</span>,cleanup);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="触发pipe事件"><a href="#触发pipe事件" class="headerlink" title="触发pipe事件"></a>触发pipe事件</h3><p>在pipe方法里面最后还会触发一个pipe事件，传入可读流对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> source = <span class="keyword">this</span>;</span><br><span class="line">    dest.emit(<span class="string">'pipe'</span>,source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="支持链式调用"><a href="#支持链式调用" class="headerlink" title="支持链式调用"></a>支持链式调用</h3><p>最后返回dest,支持<code>A.pipe(B).pipe(c)</code>的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="util-promisify如何将Callback转换为Promise"><a href="#util-promisify如何将Callback转换为Promise" class="headerlink" title="util.promisify如何将Callback转换为Promise"></a>util.promisify如何将Callback转换为Promise</h2><p>util模块提供了很多工具函数，其中promisify方法可以将callback转换为Promise对象，解决回调地狱的问题。</p><h3 id="简单实现版本"><a href="#简单实现版本" class="headerlink" title="简单实现版本"></a>简单实现版本</h3><h4 id="util-promisify基本使用"><a href="#util-promisify基本使用" class="headerlink" title="util promisify基本使用"></a>util promisify基本使用</h4><p>将callback转为promise对象，首先确保这个callback为一个错误优先的回调函数，即<code>(err,value)=&gt;err</code>指定一个错误参数，value为返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个text.txt文件，写入一些自定义内容，使用fs.readFile来读取这个文件进行测试</span></span><br><span class="line"><span class="comment">// 传统的Callback写法</span></span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line">fs.readFile(<span class="string">'text.txt'</span>,<span class="string">'utf8'</span>,(err,result)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Error'</span>,err);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Result: '</span>,result)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise写法</span></span><br><span class="line"><span class="keyword">const</span> &#123;promisify&#125; = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> readFilePromisify = util.promisify(fs.readFile); <span class="comment">// 转换为Promise</span></span><br><span class="line"></span><br><span class="line">readFilePromisify(<span class="string">'text.txt'</span>,<span class="string">'utf8'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span>=&gt;</span><span class="built_in">console</span>.log(result))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><p>自定义mayJunPromisify函数实现</p><p>自定义mayJunPromisify函数实现callback转换为promise，核心实现如下：</p><ul><li>校验传入的参数original是否为Function,不是则抛错</li><li>promisify(fs.readFile)执行之后会返回一个函数fn,定义待返回的函数后返回</li><li>fn返回的是一个Promise对象，在返回的Promise对象中执行callback函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mayJunPromisify</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> original !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The "original" argument must be of type Function,Received type undefined'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                original.call(<span class="keyword">this</span>,...args,(err,result)=&gt;&#123;</span><br><span class="line">                    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                        reject(err)</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        resolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">                resolve(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="util-promisify-custom基本使用"><a href="#util-promisify-custom基本使用" class="headerlink" title="util.promisify.custom基本使用"></a>util.promisify.custom基本使用</h4><p>另一个功能是可以使用util.promise.custom符号重写util.promisify返回值。</p><p>在fs.readFile上定义util.promisify.custom符号，其功能为禁止读取文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意顺序要在 util.promisify之前</span></span><br><span class="line">fs.readFile[util.promisify.custom] = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'该文件暂时禁止读取'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFilePromisify = util.promisify(fs.readFile);</span><br><span class="line">readFilePromisify(<span class="string">'text.txt'</span>,<span class="string">'utf8'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span>=&gt;</span><span class="built_in">console</span>.log(result))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(err)) <span class="comment">// 该文件暂时禁止读取</span></span><br></pre></td></tr></table></figure><p>自定义mayJunPromisify.custom实现</p><ul><li>定义一个Symbol变量kCustomPromisifiedSymbol赋予mayJunPromisify.custom</li><li>校验是否有自定义的promise函数</li><li>自定义的mayJunPromisified.custom也要保证是一个函数，否则抛错</li><li>直接返回自定义的mayJunPromisify.custom函数，后续的fn函数就不会执行了，所以在这里重写util.promisify返回值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所以说util.promisify.custom是一个符号</span></span><br><span class="line"><span class="keyword">const</span> kCustomPromisifiedSymbol = <span class="built_in">Symbol</span>(<span class="string">'util,promisify.custom'</span>);</span><br><span class="line">mayJunPromisify.custom = kCustomPromisifiedSymbol;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mayJunPromisify</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> original !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The "original" argument must be of type Function,Received type undefined'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(original[kCustomPromisifiedSymbol])&#123;</span><br><span class="line">        <span class="keyword">const</span> fn = original[kCustomPromisifiedSymbol];</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The "mayJunPromise.custom" property must be of the type Function,Received type number'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.defineProperty(fn,kCustomPromisifiedSymbol,&#123;</span><br><span class="line">            value:fn,</span><br><span class="line">            enumerable:<span class="literal">false</span>,</span><br><span class="line">            writable:<span class="literal">false</span>,</span><br><span class="line">            configurable:<span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">...args</span>)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="util-promisify回调函数多参转换"><a href="#util-promisify回调函数多参转换" class="headerlink" title="util.promisify回调函数多参转换"></a>util.promisify回调函数多参转换</h4><p>有些函数的回调形式是多个参数的，例如dns.lookup，它的回调形式是<code>(err,address,family)=&gt;...</code>拥有 三个参数，对这种情况也做兼容</p><p>基本使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dns = <span class="built_in">require</span>(<span class="string">'dns'</span>);</span><br><span class="line"><span class="keyword">const</span> lookupPromisify = util.promisify(dns.lookup);</span><br><span class="line"></span><br><span class="line">lookupPromisify(<span class="string">'laibh.top'</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">&#123;address,family&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'地址：'</span>,address,<span class="string">'地址族：'</span>,family)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><p>实现解析：</p><p>为了支持util.promisify也都会在函数上定义一个customPromisifyArgs参数，value为回调的多个参数的名称，类型为数组，例如dns.lookup绑定的customPromisifyArgs的value为<code>[&#39;address&#39;,&#39;family&#39;]</code>，其主要目的也是为了适配util.promisify</p><p>dns.lookup支持util.promisify核心实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;customPromisifyArgs&#125; = <span class="built_in">require</span>(<span class="string">'internal/util'</span>);</span><br><span class="line"></span><br><span class="line">ObjectDefineProperty(lookup,customPromisifyArgs,&#123;</span><br><span class="line">    value:[<span class="string">'address'</span>,<span class="string">'family'</span>],</span><br><span class="line">    enumerable:<span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>customPromisifyArgs这个参数是从internal/util模块导出的，仅内部调用，在外部util.promisify是没有这个参数的。也就意味着只有Node模块中例如dns.lookup、fs.read等方法在多参数的时候可以使用util.promisify转换为Promise，如果自定义的callback存在多参数的情况，使用util.promisify则不行，不过可以基于util.promisify自己封装一个：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// Symbol used to customize promisify conversion</span></span><br><span class="line">    customPromisifyArgs:kCustomPromisifyArgsSymbol</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义Symbol变量kCustomPromisifyArgsSymbol</li><li>获取参数名称列表</li><li><code>(err,result)</code>改为<code>(err,...values)</code>,原先的result仅接受一个参数，改为<code>...values</code>接收多个参数</li><li>argumentNames存在且value&gt;1,则回调会存在多个参数名称，经常遍历，返回一个obj</li><li>否则values最多仅有一个参数名称，即数组values有且仅有一个元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> kCustomPromisifyArgsSymbol = <span class="built_in">Symbol</span>(<span class="string">'customPromisifyArgs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 获取多个回调函数的函数参数列表</span></span><br><span class="line">    <span class="keyword">const</span> argumentName = original[kCustomPromisifyArgsSymbol];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">..args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                original.call(<span class="keyword">this</span>,...args,(err,...values)=&gt;&#123;</span><br><span class="line">                    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                        reject(err)</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// argumentNames存在且values&gt;1,则回调会存在多个参数名称，进行遍历，返回一个obj</span></span><br><span class="line">                        <span class="keyword">if</span>(argumentNames !== <span class="literal">undefined</span> &amp;&amp; values.length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                            <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">                            <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;argumentNames.length;i+=<span class="number">1</span>)&#123;</span><br><span class="line">                                obj[argumentNames[i]] = values[i];</span><br><span class="line">                                resolve(obj)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="comment">// 否则values最多只有一个参数名称，即数组values有且只有一个元素</span></span><br><span class="line">                            resolve(values[<span class="number">0</span>])</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于kCustomPromiseArgsSymbol使用Symbol声明（每次重新定义都会不一样），且没有对外提供。要实现这个功能，需要每次在cb重新定义kCustomPromisifyArgsSymbol属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> kCustomPromisifiedSymbol = <span class="built_in">Symbol</span>(<span class="string">'util.promisify.custom'</span>);</span><br><span class="line"><span class="keyword">const</span> kCustomPromisifyArgsSymbol = <span class="built_in">Symbol</span>(<span class="string">'customPromisifyArgs'</span>);</span><br><span class="line">mayJunPromisify.custom = kCustomPromisifiedSymbol;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mayJunPromisify</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> original !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The "original" argument must be of type Function,Received type undefined'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(original[kCustomPromisifiesSymbol])&#123;</span><br><span class="line">        <span class="keyword">const</span> fn = original[kCustomPromisifiesSymbol];</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The "util.promisify.custom" property must be of type Function.Received type number'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.defineProperty(fn,kCustomPromisifiedSymbol,&#123;</span><br><span class="line">            value:fn,</span><br><span class="line">            enumerable:<span class="literal">false</span>,</span><br><span class="line">            writable:<span class="literal">false</span>,</span><br><span class="line">            configurable:<span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 获取多个回调函数的参数列表</span></span><br><span class="line">        <span class="keyword">const</span> argumentNames = original[kCustomPromisifyArgsSymbol];</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    original.call(<span class="keyword">this</span>,...args,(err,...values)=&gt;&#123;</span><br><span class="line">                        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                            reject)(err);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="comment">// argumentName 存在且 values&gt;1,则回调会存在多个参数名称，进行遍历，返回一个obj</span></span><br><span class="line">                            <span class="keyword">if</span>(argumentNames !== <span class="literal">undefined</span> &amp;&amp; values.length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                                <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">                                <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;argumentNames.length;i+=<span class="number">1</span>)&#123;</span><br><span class="line">                                    obj[argumentNames[i]] = values[i]</span><br><span class="line">                                    resolve(obj)</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                <span class="comment">// 否则values最多仅有一个参数名称，即数组values有且仅有一个元素</span></span><br><span class="line">                                resolve(values[<span class="number">0</span>])</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mayJunPromisify,</span><br><span class="line">    kCustomPromisifyArgsSymbol</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;kCustomPromisifyArgsSymbol,mayJunPromisify&#125; = <span class="built_in">require</span>(<span class="string">'./may-jun-promisify'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mayJunPromisify.custom自定义Promise函数测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisifyCustomTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    fs.readFile[mayJunPromisify.custom]=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'该文件暂时禁止读取'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> readFilePromisify = mayJunPromisify(fs.readFile);</span><br><span class="line">    readFilePromisify(<span class="string">'text.txt'</span>,<span class="string">'utf8'</span>)</span><br><span class="line">        .then(<span class="function"><span class="params">result</span>=&gt;</span><span class="built_in">console</span>.log(result))</span><br><span class="line">        .catch(<span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(err)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义cb多参数转换promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cbConverPromiseTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getUserById</span>(<span class="params">id,cb</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> name = <span class="string">'laibh'</span>,</span><br><span class="line">              age = <span class="number">25</span>;</span><br><span class="line">        cb(<span class="literal">null</span>,name,age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(getUserById,kCustomPromisifyArgsSymbol,&#123;</span><br><span class="line">        value:[<span class="string">'name'</span>,<span class="string">'age'</span>],</span><br><span class="line">        enumerable:<span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> getUserByIdPromisify = mayJunPromisify(getUserById);</span><br><span class="line">    getUserByIdPromisify(<span class="number">1</span>)</span><br><span class="line">        .then(&#123;name,age&#125;=&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name,age);</span><br><span class="line">    &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(err))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">promisifyCustomTest();</span><br><span class="line">cbConverPromiseTest();</span><br></pre></td></tr></table></figure><h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><p>I/O即Input/Output，输入输出端口，是信息处理系统与外部世界之间的通信，输入手是系统接收的信号或数据，输出的则是从其发送的信号或数据</p><p>一次I/O操作分为等待资源，使用资源两个阶段，常见的词网络I/O,磁盘I/O</p><h3 id="阻塞与非阻塞I-O"><a href="#阻塞与非阻塞I-O" class="headerlink" title="阻塞与非阻塞I/O"></a>阻塞与非阻塞I/O</h3><p>是对于操作系统内核而言的，发生在等待资源阶段，根据发起的I/O请求是否阻塞来判断</p><p>阻塞I/O：这种模式下一个用户进程在发起一个I/O操作之后，只有接收到响应或者超时时才可进行处理其他事情，否则I/O将会一直阻塞。以读取磁盘上的一段文件为例子，系统内核在完成磁盘寻道、读取数据、复制数据到内存之中之后，这个调用才算完成。阻塞的这段时间对CPU资源是浪费的。</p><p>非阻塞I/O：这种模式下一个用户进程发起一个I/O操作之后，如果数据没有就绪，会立刻返回（标志数据资源不可用），此时CPU时间片可以用来做一些其他事情。</p><h3 id="同步与异步I-O"><a href="#同步与异步I-O" class="headerlink" title="同步与异步I/O"></a>同步与异步I/O</h3><p>同步与异步I/O发生在使用资源阶段。</p><p>同步I/O：应用发送或接受数据后，如果不返回，继续等待（此处发生阻塞），直到数据成功或失败返回。</p><p>异步I/O：应用发送或接受数据后立刻返回，数据写入OS缓存，由OS完成数据发送或接收，并返回成功或者失败的信息给应用，NodeJs就是典型异步编程的例子。</p><h3 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h3><p>操作系统为了多个应用同时运行，需要保证不同进程相对独立、内核的安全。所以操作系统把内存空间划分为用户空、内核空间两部分。用户空间存放用户程序代码和数据，而内核空间则存放内核代码和数据。</p><p>OSI七层模型与网际网协议族图：传输层之上（会话层、表示层、应用层）为用户空间（Web客户端、浏览器、FTP），下四层（传输层，网络层，数据链路层，物理层）为内核空间，例如传输层的TCP/UDP就对应内核空间。</p><h3 id="操作系统I-O模型"><a href="#操作系统I-O模型" class="headerlink" title="操作系统I/O模型"></a>操作系统I/O模型</h3><h4 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h4><p>当进程调用 recvfrom() 函数的时候阻塞，<strong>应用程序</strong>开始系统调用，在<strong>系统内核</strong>数据就绪，将数据从内核中拷贝出来后结束。这个过程应用程序都处于等待状态，不能做其他事情，直到将数据拷贝到用户空间或出错才返回，我们称之为阻塞I/O模式。</p><h3 id="同步非阻塞I-O"><a href="#同步非阻塞I-O" class="headerlink" title="同步非阻塞I/O"></a>同步非阻塞I/O</h3><p>想对于同步非阻塞I/O模式，同步非阻塞I/O在 每次调用之后，如果数据没有就绪就会立即返回，之后重复调用检查I/O操作是否就绪，这对CPU资源非常浪费，直到数据就绪将数据从内核拷贝到用户空间，返回成功指示到应用程序。</p><h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p>链接（Socket）并发大的时候，上面的两种就不适合了，前面一个处理不完，后面的就只能干等。多路复用技术先进行select数据就绪后，调用recvfrom进行真正的I/O读写操作。高级之处在于能够一个线程同时处理多个Socket</p><p>多路复用中的I/O通常指的是网络I/O,多路指的是多个Socker链接，复用指操作系统进行运算调度最小单位线程，整体的意思就是多个网络I/O复用一个或少量线程来处理Socket</p><p>I/O多路复用的四种实现：select/poll/epoll/kqueue</p><ul><li>select，通过轮询检查在文件描述符上设置的标志位来进行判断，select的轮询相当于在数据库中查找一条记录没有建立索引，对所有的socket进行全部遍历，这对CPU是浪费的。另外select还有一个限制，对于单个线程所能打开的文件描述符最大只有1024，那么基于select的轮询技术最多也只能很好的处理1000并发的吞吐量</li><li>poll,poll和select在实现上没有什么本质上的区别，poll基于链表来实现，没有了最大链接1024的限制。当文件描述符多了之后，每次调用都会对链接进行线性遍历，性能也是十分低下的。</li><li>epoll。是linux下效率最高的I/O事件通知机制，没有最大链接限制，通过callback回调通知机制，不再是每次调用对链接进行线性遍历，这样就不会随着文件描述符的增加导致效率下降。1GB内存的机器上大概能监听10w个端口，远超过select1024的限制</li><li>kqueue，与epoll类似，仅存于FreeBSD(一种类UNIX操作系统)</li></ul><h3 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h3><p>仅在Unix上支持，与I/O多路复用相比避免了select的阻塞轮询，应用程序进行系统调用后立即返回，处理其他事情，在数据就绪之后系统会发送一个SIGIO信号到应用程序，应用程序开始读取数据</p><h3 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h3><p>目前最理想形式的一种，应用程序发起系统调用后无需等待直接返回当前调用状态，进行后续的其他任务，结果由内核完成I/O操作之后通过回调通知到应用程序，中间没有阻塞过程。Linux2.6增加了AIO，但是很少系统能够实现</p><h3 id="轮询技术Select-与-Epoll的区别"><a href="#轮询技术Select-与-Epoll的区别" class="headerlink" title="轮询技术Select 与 Epoll的区别"></a>轮询技术Select 与 Epoll的区别</h3><p><strong>操作方式上</strong></p><ul><li>select采用了线性遍历来查找，链接多了之后在一个庞大的数组中每次遍历来锁定一个链接，非常消耗性能</li><li>epoll则不需要遍历，采用的是回调机制，可以看作是一个HashTable，来锁定一个对象非常快。</li></ul><p><strong>文件描述符限制</strong></p><ul><li>对于文件描述符最大链接数select限制为1024</li><li>epoll则没有这个限制，通常在1GB内存的机器上所能支持的连接数为10W左右。</li></ul><p><strong>操作系统的支持</strong></p><p>目前高性能的Web服务器Nginx是基于epoll来实现高并发的</p><h3 id="Nodejs中的内存管理和V8垃圾回收机制"><a href="#Nodejs中的内存管理和V8垃圾回收机制" class="headerlink" title="Nodejs中的内存管理和V8垃圾回收机制"></a>Nodejs中的内存管理和V8垃圾回收机制</h3><p>在Nodejs中，关于垃圾回收、内存释放不需要像C语言创建一个对象之后需手动创建一个delete/free的一个操作之后进行GC,Nodejs与java一样，由虚拟机进行内存自动管理。</p><h3 id="NodeJs中的GC"><a href="#NodeJs中的GC" class="headerlink" title="NodeJs中的GC"></a>NodeJs中的GC</h3><p>node.js是基于Chrome v8引擎的javascript运行环境，V8就是虚拟机。</p><h3 id="垃圾回收内存管理实践"><a href="#垃圾回收内存管理实践" class="headerlink" title="垃圾回收内存管理实践"></a>垃圾回收内存管理实践</h3><h4 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h4><p>node提供process.memoryUsage方法来查看当前进程内存使用情况，单位为节</p><ul><li>ress(resident set size)：RAM中保存的进程占用的内存部分，包括代码本身、栈、堆</li><li>heapTotal：堆中总共申请到的内存量</li><li>heapUsed：堆中目前用到的内存量，判断内存泄露主要以这个字节为准</li><li>external：V8引擎内存C++对象占用的内存</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*单位字节格式为MB输出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> format = <span class="function"><span class="keyword">function</span>(<span class="params">bytes</span>)</span></span><br><span class="line"><span class="function">    <span class="title">return</span> (<span class="params">bytes<span class="regexp">/1024/</span><span class="number">1024</span></span>).<span class="title">toFixed</span>(<span class="params"><span class="number">2</span></span>)+' <span class="title">MB</span>'</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">/*</span></span><br><span class="line"><span class="function">*封装<span class="title">print</span>方法输出内存占用信息</span></span><br><span class="line"><span class="function">*/</span></span><br><span class="line"><span class="function"><span class="title">const</span> <span class="title">print</span> = <span class="title">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> memoryUsage = process.memoryUsage();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">            res:format(memoryUsage.rss),</span><br><span class="line">            heapTotal:format(memoryUsage.heapTotal),</span><br><span class="line">            heapUsed:format(memoryUsage.heapUsed),</span><br><span class="line">            external:format(memoryUsage.external),</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存泄露的例子"><a href="#内存泄露的例子" class="headerlink" title="内存泄露的例子"></a>内存泄露的例子</h4><p>堆用来存放对象引用类型，例如字符串、对象、在代码中创建一个Fruit存放在堆中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Quantity</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>(num * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fruit</span>(<span class="params">name,quantity</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.quantity = <span class="keyword">new</span> Quantity(quantity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> apple = <span class="keyword">new</span> Fruit(<span class="string">'apple'</span>);</span><br><span class="line">print();</span><br><span class="line"><span class="keyword">let</span> banane = <span class="keyword">new</span> Fruit(<span class="string">'banane'</span>,<span class="number">20</span>);</span><br><span class="line">print();</span><br><span class="line"><span class="comment">// 执行代码，aplle对象heapUsed使用仅有4.21M，而banana由于quantity属性创建了一个很大数组空间导致heapUsed飙升到164.21M。</span></span><br><span class="line"><span class="comment">// &#123;"rss":"19.94 MB","heapTotal":"6.83 MB","heapUsed":"4.21 MB","external":"0.01 MB"&#125;</span></span><br><span class="line"><span class="comment">// &#123;"rss":"180.04 MB","heapTotal":"166.84 MB","heapUsed":"164.24 MB","external":"0.01 MB"&#125;</span></span><br></pre></td></tr></table></figure><h4 id="手动执行垃圾回收内存释放"><a href="#手动执行垃圾回收内存释放" class="headerlink" title="手动执行垃圾回收内存释放"></a>手动执行垃圾回收内存释放</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">banana = <span class="literal">null</span>;</span><br><span class="line">global.gc();</span><br><span class="line">print(); </span><br><span class="line"><span class="comment">// 执行 node --expose-gc xxx.js --expose-gc参数表示运行手动执行垃圾回收机制，将banana对象赋值null进行GC</span></span><br><span class="line"><span class="comment">// &#123;"rss":"52.48 MB","heapTotal":"9.33 MB","heapUsed":"3.97 MB","external":"0.01 MB"&#125;</span></span><br><span class="line"><span class="comment">// heapUsed的使用已经降了下来</span></span><br></pre></td></tr></table></figure><h3 id="V8垃圾回收机制"><a href="#V8垃圾回收机制" class="headerlink" title="V8垃圾回收机制"></a>V8垃圾回收机制</h3><p>垃圾回收指的是回收那些在应用程序中不再引用的对象，当一个对象无法从根节点访问这个对象就会作为垃圾回收的候选对象。这里的根对象可以为全局对象、局部变量，无法从根节点访问指的也就是不会再被其他活动对象所引用。</p><h4 id="V8堆内存限制"><a href="#V8堆内存限制" class="headerlink" title="V8堆内存限制"></a>V8堆内存限制</h4><p>在V8中限制64位机制大约为1.4G，32位的大概是0.7G，对于一些大内存的操作需要谨慎否则超出V8内存限制会造成进程退出</p><p>内存溢出边界的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// overflow.js</span></span><br><span class="line"><span class="keyword">const</span> format = <span class="function"><span class="keyword">function</span>(<span class="params">bytes</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (bytes / <span class="number">1024</span> / <span class="number">1024</span>).toFixed(<span class="number">2</span>)+<span class="string">' MB'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> memoryUsage = process.memoryUsage();</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`heapTotal:<span class="subst">$&#123;format(memoryUsage.heapTotal)&#125;</span>,</span></span><br><span class="line"><span class="string"> heapUsed: <span class="subst">$&#123;format(memoryUsage.heapUsed)&#125;</span>`</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> total = [];</span><br><span class="line">setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    total.push(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>*<span class="number">1024</span>*<span class="number">1024</span>)) <span class="comment">// 大内存占用</span></span><br><span class="line">    print();</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>total为全局变量每次增长大概在160M左右且不会被回收，在接近V8边界时无法分配内存导致进程内存溢出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node overflow.js</span></span><br><span class="line">heapTotal: 166.84 MB, heapUsed: 164.23 MB</span><br><span class="line">heapTotal: 326.85 MB, heapUsed: 324.26 MB</span><br><span class="line">heapTotal: 487.36 MB, heapUsed: 484.27 MB</span><br><span class="line">heapTotal: 649.38 MB, heapUsed: 643.98 MB</span><br><span class="line">heapTotal: 809.39 MB, heapUsed: 803.98 MB</span><br><span class="line">heapTotal: 969.40 MB, heapUsed: 963.98 MB</span><br><span class="line">heapTotal: 1129.41 MB, heapUsed: 1123.96 MB</span><br><span class="line">heapTotal: 1289.42 MB, heapUsed: 1283.96 MB</span><br><span class="line"></span><br><span class="line">&lt;--- Last few GCs ---&gt;</span><br><span class="line"></span><br><span class="line">[87581:0x103800000]    11257 ms: Mark-sweep 1283.9 (1290.9) -&gt; 1283.9 (1290.9) MB, 512.1 / 0.0 ms  allocation failure GC in old space requested</span><br><span class="line">[87581:0x103800000]    11768 ms: Mark-sweep 1283.9 (1290.9) -&gt; 1283.9 (1287.9) MB, 510.7 / 0.0 ms  last resort GC in old space requested</span><br><span class="line">[87581:0x103800000]    12263 ms: Mark-sweep 1283.9 (1287.9) -&gt; 1283.9 (1287.9) MB, 495.3 / 0.0 ms  last resort GC in old space requested</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;--- JS stacktrace ---&gt;</span><br></pre></td></tr></table></figure><p>v8提供了两个参数仅在启用阶段调整内存限制大小，分别为调整老生代、新生代：</p><ul><li>–max-old-space-size=2048</li><li>–max-new-space-size=2048</li></ul><p>内存不是越大越好，一方面是服务器资源昂贵，另外是V8以1.5G的堆内存进行一次小的垃圾回收大约需要50毫秒以上时间，会导致JavaScript进程暂停，这也是最主要的一方面。</p><h4 id="新生代与老生代"><a href="#新生代与老生代" class="headerlink" title="新生代与老生代"></a>新生代与老生代</h4><p><strong>新生代空间</strong></p><p>由于新空间的垃圾回收机制很频繁，所以处理方式必须非常快，采用Scavenge算法，这是一种复制算法，新生代空间会被一分为二划分为两个相等大小的from-space和to-space工作方式是将from space中存活的对象复制出来，然后移动它们到to space 中或者被提升到老生代空间中，对于from space中没有存活的对象将会被释放，完成这些复制后再将from space和to space进行互换。</p><p>Scavenge算法适用少量内存的垃圾回收，但是有很大的空间开销，对于新生代少量内存是可以接受的</p><p><strong>老生代空间</strong></p><p>新生代空间在垃圾回收满足于一定的条件（是否经过Scavenge空间、to space内存占比）会被晋升到老生代空间中，在老生代空间中的对象都已经至少经历了一次或者多次的回收所以它们的存活概率会更大。在使用Scavenge算法会有两个缺点，一是将会重复的复制存活对象使得效率低下，二是对空间资源的浪费，所以在老生代空间中采用了 Mark-Sweep（标记清除）和Mark-Compact（标记整理）算法</p><p>Mark-Sweep处理时分为标记、清除两个步骤，与Scavenge算法只复制活对象相反的是在老生代空间中由于活对象占多数Mark-Sweep在标记阶段遍历堆中的所有对象仅标记活对象把未标记的死对象清除，这时一次标记清除就已经完成了。有一个问题是被清除的对象遍布于各内存地址，产生很多内存碎片</p><p>Mark-Compact(标记整理算法)为了解决内存碎片问题，在其工作过程中将活着的对象往一端移动，这时内存空间是紧凑的，移动完成之后，直接整理边界之外的内存。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>V8使用了不同的垃圾回收算法Scavenge/Mark-Sweep/Mark-Compact.这三种垃圾回收算法都避免不了在进行垃圾回收时需要将应用程序暂停，待垃圾回收完成之后在恢复应用逻辑，对于新生代空间来说由于很快所以影响不大，但是对于老生代空间由于存活对象较多，停顿还是会造成影响的，因此V8又新增了增量标记的方式减少停顿时间。</p><h3 id="内存泄露-1"><a href="#内存泄露-1" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>内存泄露（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统奔溃等严重后果。</p><p><strong>全局变量</strong>，未声明的变量或挂在全局global下的变量不会自动回收，将会常驻内存直到直到进程退出才会释放，除非通过delete或者重新赋值为undefined/null解决之间的引用关系，才会被回收。</p><p><strong>闭包</strong>，也是一个常见的内存泄露问题，闭包会引用父级函数中的变量，如果闭包得不到释放，闭包引用的父级变量也不会释放从而导致内存泄露</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> originalThing = theThing;</span><br><span class="line">    <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(originalThing)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        theThing = &#123;</span><br><span class="line">            longStr:<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'*'</span>),</span><br><span class="line">            someMethod:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(someMessage)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setInterval(replaceThing,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>代码运行时，每次执行replaceThing方法都会生成一个新的对象，但是之前的对象没有释放导致的内存泄露。</p><p><strong>慎将内存作为缓存</strong></p><p>通过内存来做缓存是最快的实现方式，缓存中的存储的键越多，长期存活的对象就越多，垃圾回收时将这些对象做无用功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面一个获取用户Token的例子，memoryStore对象会随着用户数的增加而增长，当启动多个线程或者部署在多台机器会造成每个进程都保存一份，显然是资源的浪费，最好是通过Redis做共享</span></span><br><span class="line"><span class="keyword">const</span> memoryStore = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">exports.getUserToken = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> token = memoryStore.get(key);</span><br><span class="line">    <span class="keyword">if</span>(token &amp;&amp; <span class="built_in">Date</span>.now() - token.now &gt; <span class="number">2</span> * <span class="number">60</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> dbToken = db.get(key);</span><br><span class="line">    memoryStore.set(key,&#123;</span><br><span class="line">        now:<span class="built_in">Date</span>.now(),</span><br><span class="line">        val:dbToken</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模块私有变量内存常驻</strong></p><p>加载一个模块代码之前，Nodejs会使用一个如下的函数封装器将其封装，保证了顶层的变量（var,const,let）在模块范围内，而不是全局对象。这个时候就会形成一个闭包，在require时会被加载一次，将exports对象保存在内存中，直到进程退出才会回收，这个将会导致的是内存常驻，所以避免一些没必要的模块加载，否则也会造成内存增加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">exports,require,module,__filename,__dirname</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 模块的代码实际上在这里</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 所以建议对模块的引用仅在头部初次加载之后用const缓存起来，而不是在使用时每次都去加载一起。</span></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'a.js'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'a.js'</span>).run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>事件反复监听</strong></p><p>NodeJs中对一个事件反复监听则会报下面的错误，实际上使用的EventEmitter类，包含一个listeners数组，默认为10个监听器超出这个数则会报警，用于发现内存泄露，也可以通过emitter.setMaxListeners()方法为指定的EventEmitter实例修改限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaxListenersExceededWarning：Possible EventEmitter memory leak detected, 11 connect added.Use emitter.setMaxListeners() to increase limit</span><br></pre></td></tr></table></figure><p><strong>其他注意事项</strong></p><p>使用定时器setInterval时记得使用对应的clearInterval进行清除。因为setInterval执行完之后会返回一个值且不会自动释放，另外还有map/filter等对数组进行操作，每次操作之后都会创建一个新的数组，将会占用内存，如果单纯的遍历map可以用forEach。</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul><li><code>[Cache]</code> <a href="https://github.com/webpack/memory-fs">memory-fs 将文件写入内存</a></li><li><code>[Cache]</code> <a href="https://github.com/ptarjan/node-cache#readme">Memory Cache</a></li><li><code>[Cache]</code> <a href="https://github.com/mpneuried/nodecache">Node Cache</a></li></ul><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><ul><li><code>[Schedule]</code> <a href="https://github.com/node-schedule/node-schedule">node-schedule</a></li><li><code>[Schedule]</code> <a href="https://github.com/agenda/agenda">Agenda 将Node中的定时任务存储在数据库中（官方推荐MongoDB）</a></li><li><code>[Schedule]</code> <a href="https://www.nodejs.red/#/docs/microservice/rabbitmq-base?id=rabbitmq延迟队列实现定时任务">Node.js结合RabbitMQ延迟队列实现定时任务</a></li></ul><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><ul><li><code>[Template]</code> <a href="https://ejs.co/">Ejs</a></li><li><code>[Template]</code> <a href="https://handlebarsjs.com/">Handlebarsjs</a></li><li><code>[Template]</code> <a href="http://jade-lang.com/">Jade</a></li></ul><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><ul><li><code>[Framework]</code> <a href="http://www.expressjs.com.cn/">Express 中文版</a>、<a href="http://www.expressjs.com.cn/">Express of English Version</a></li><li><code>[Framework]</code> <a href="https://koajs.com/">Koa 中文版</a>、<a href="https://koajs.com/">Koa of English Version</a></li><li><code>[Framework]</code> <a href="https://eggjs.org/zh-cn/intro/quickstart.html">Egg 中文版</a>、<a href="https://eggjs.org/en/intro/quickstart.html">Egg of English Version</a></li><li><code>[Framework]</code> <a href="https://docs.nestjs.cn/">Nest.js 中文版</a>、<a href="https://docs.nestjs.com/">Nest.js</a></li></ul><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><ul><li><code>[typeorm]</code> <a href="https://typeorm.io/">typeorm</a> 【右上角切换中文】</li><li><code>[sequelize]</code> <a href="http://docs.sequelizejs.com/">sequelize</a></li><li><code>[prisma]</code> <a href="https://www.prisma.io/docs">prisma</a></li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h3><p><strong>QPS</strong></p><p>QPS（Query Per Second）指每秒查询量，规定时间内所能处理的流量大小，通常QPS值越大服务器的吞吐量也就越大，相对服务器负荷也会越高</p><p>QPS=并发量/平均响应时间并发量 = QPS * 平均响应时间</p><p><strong>TPS</strong></p><p>TPS（TransactionPerSecond）指每秒事物处理量，每秒钟系统所能处理的交易或事务的数量，用来形容系统的性能。</p><p><strong>两者区别</strong></p><p>一次下单请求，访问一次创建接口产生一次TPS,对于服务器的请求可能会产生多次，比如查询用户地址信息、商品数据信息、商品报价信息，这些请求计入QPS,也就是产生了3次QPS</p><h3 id="系统扩容评价"><a href="#系统扩容评价" class="headerlink" title="系统扩容评价"></a>系统扩容评价</h3><p>根据二八法则来评估系统扩容需要多少台机器，二八法则即20%的时间承载80%的流量，把20%的时间称为峰值时间，换算公式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(总PV数 * 80%) / (每天描述 * 20%) = 峰值时间每秒请求数</span><br><span class="line">峰值时间内每秒请求数（QPS）/单台机器QPS = 需要的机器</span><br></pre></td></tr></table></figure><p>假设有1000wPV,总共需要的QPS为多少？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1000000 * 0.8) / (24 * 60 * 60 * 0.2) = 463(QPS)</span><br></pre></td></tr></table></figure><p>假设每台机器支撑100QPS，则共需要的机器为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">463</span>(总有QPS)/<span class="number">100</span>(单机QPS) = <span class="number">5</span>(约需要<span class="number">5</span>台机器)</span><br></pre></td></tr></table></figure><h2 id="Nodejs-CPU使用率"><a href="#Nodejs-CPU使用率" class="headerlink" title="Nodejs CPU使用率"></a>Nodejs CPU使用率</h2><h3 id="os-cups-数据指标"><a href="#os-cups-数据指标" class="headerlink" title="os.cups()数据指标"></a>os.cups()数据指标</h3><p>返回的对象数组中有一个times字段，包含了user/nice/sys/idle/irq几个指标数据，分别代表CPU在用户模式、良好模式、系统模式、空闲模式、中断模式下话费的毫秒数。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    model: <span class="string">'Intel(R) Core(TM) i5-4590 CPU @ 3.30GHz'</span>,</span><br><span class="line">    speed: <span class="number">3292</span>,</span><br><span class="line">    times: &#123;</span><br><span class="line">      user: <span class="number">151474100</span>,</span><br><span class="line">      nice: <span class="number">0</span>,</span><br><span class="line">      sys: <span class="number">95311197</span>,</span><br><span class="line">      idle: <span class="number">2258535287</span>,</span><br><span class="line">      irq: <span class="number">2136605</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    model: <span class="string">'Intel(R) Core(TM) i5-4590 CPU @ 3.30GHz'</span>,</span><br><span class="line">    speed: <span class="number">3292</span>,</span><br><span class="line">    times: &#123;</span><br><span class="line">      user: <span class="number">84900939</span>,</span><br><span class="line">      nice: <span class="number">0</span>,</span><br><span class="line">      sys: <span class="number">65104926</span>,</span><br><span class="line">      idle: <span class="number">2355314423</span>,</span><br><span class="line">      irq: <span class="number">874869</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    model: <span class="string">'Intel(R) Core(TM) i5-4590 CPU @ 3.30GHz'</span>,</span><br><span class="line">    speed: <span class="number">3292</span>,</span><br><span class="line">    times: &#123;</span><br><span class="line">      user: <span class="number">144337320</span>,</span><br><span class="line">      nice: <span class="number">0</span>,</span><br><span class="line">      sys: <span class="number">112618416</span>,</span><br><span class="line">      idle: <span class="number">2248364428</span>,</span><br><span class="line">      irq: <span class="number">699602</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    model: <span class="string">'Intel(R) Core(TM) i5-4590 CPU @ 3.30GHz'</span>,</span><br><span class="line">    speed: <span class="number">3292</span>,</span><br><span class="line">    times: &#123;</span><br><span class="line">      user: <span class="number">110066333</span>,</span><br><span class="line">      nice: <span class="number">0</span>,</span><br><span class="line">      sys: <span class="number">84988268</span>,</span><br><span class="line">      idle: <span class="number">2310265437</span>,</span><br><span class="line">      irq: <span class="number">897333</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>定义方法getCPUInfo用来获取系统CPU信息，提供了CPU利用率的实时监控，这个实时不是绝对的实时，会有时差，下面实现中默认设置的1秒钟，可以通过Options.ms进行调整</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>);</span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OSUtils</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.cpuUsageMSDefault = <span class="number">1000</span>; <span class="comment">// CPU 利用率默认时间段</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取CPU信息</span></span><br><span class="line"><span class="comment">   * @return &#123;Object&#125; CPU信息</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> _getCPUInfo() &#123;</span><br><span class="line">  <span class="keyword">const</span> cpus = os.cpus();</span><br><span class="line">  <span class="keyword">let</span> user = <span class="number">0</span>,</span><br><span class="line">    nice = <span class="number">0</span>,</span><br><span class="line">    sys = <span class="number">0</span>,</span><br><span class="line">    idle = <span class="number">0</span>,</span><br><span class="line">    irq = <span class="number">0</span>,</span><br><span class="line">    total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> cpu <span class="keyword">in</span> cpus) &#123;</span><br><span class="line">    <span class="keyword">const</span> times = cpus[cpu].times;</span><br><span class="line">    user += times.user;</span><br><span class="line">    nice += times.nice;</span><br><span class="line">    sys += times.sys;</span><br><span class="line">    idle += times.idle;</span><br><span class="line">    irq += times.irq;</span><br><span class="line">  &#125;</span><br><span class="line">  total += user + nice + sys + idle + irq;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    user,</span><br><span class="line">    sys,</span><br><span class="line">    idle,</span><br><span class="line">    total</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取某时间段CPU利用率</span></span><br><span class="line"><span class="comment">   * @param &#123;Number&#125; Options.ms [时间段，默认是1000ms，即1秒钟]</span></span><br><span class="line"><span class="comment">   * @param &#123;Boolean&#125; Options.percentage [true（以百分比结果返回）| false]</span></span><br><span class="line"><span class="comment">   * @return &#123;Promise&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">async</span> getCPUUsage(options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> &#123; cpuUsageMS, percentage &#125; = options;</span><br><span class="line">    cpuUsageMS = cpuUsageMS || that.cpuUsageMSDefault;</span><br><span class="line">    <span class="keyword">const</span> t1 = that._getCPUInfo(); <span class="comment">// t1时间点的 CPU信息</span></span><br><span class="line">    <span class="keyword">await</span> sleep(cpuUsageMS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> t2 = that._getCPUInfo(); <span class="comment">// t2时间点的 CPU信息</span></span><br><span class="line">    <span class="keyword">const</span> idle = t2.idle - t1.idle;</span><br><span class="line">    <span class="keyword">const</span> total = t2.total - t1.total;</span><br><span class="line">    <span class="keyword">let</span> usage = <span class="number">1</span> - idle / total;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (percentage) usage = (usage * <span class="number">100.0</span>).toFixed(<span class="number">2</span>) + <span class="string">'%'</span>;</span><br><span class="line">    <span class="keyword">return</span> usage;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> osUtils = <span class="keyword">new</span> OSUtils()</span><br><span class="line">osUtils.getCPUUsage(&#123; <span class="attr">percentage</span>: <span class="literal">true</span> &#125;).then(<span class="function"><span class="params">cpuUsage</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'CPU 利用率'</span>, cpuUsage)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="NodeJs与Event-Loop"><a href="#NodeJs与Event-Loop" class="headerlink" title="NodeJs与Event Loop"></a>NodeJs与Event Loop</h2><p>node之前的世界，多线程服务器中，Web应用程序是用一个client/server(客户端/服务端)模式所编写的，其中client将向server请求资源并且将会根据这个资源以响应，server仅在client请求时做出响应，并在每次响应后关闭连接。这种模式是有效的，因为对服务器的每一个请求都需要时间和资源（内存、CPU等等），服务器必须完成上一个请求，才能接受下一个请求。需要同时处理N个请求，服务器就需要N个线程，如果有N+1个请求，就必须等N个线程中的任何一个可用。</p><p>服务器中的线程不是唯一的问题，一个线程为什么不能同时处理2个或者更多请求，是因为阻塞了Input/Output操作。</p><table><thead><tr><th>操作</th><th>CPU时钟周期数(ticks)</th></tr></thead><tbody><tr><td>CPU寄存器</td><td>3</td></tr><tr><td>L1 Cache(一级缓存)</td><td>8</td></tr><tr><td>L2 Cache(二级缓存)</td><td>12</td></tr><tr><td>RAM(随机存取存储器)</td><td>150</td></tr><tr><td>Disk（磁盘）</td><td>30 000 000</td></tr><tr><td>NetWork（网络）</td><td>250 000 000</td></tr></tbody></table><p>时钟周期也称为tick/clock cycle/clock period等，指一个硬件在被使用过程中，被划分为多个时间周期，当我们需要比较不同硬件性能时，就在不同硬件上测试同一个软件，观察它们的时钟周期时间和周期指数，如果时钟周期越长、周期越多，就意味着这个硬件需要的性能较低。</p><h3 id="Event-Loop事件循环"><a href="#Event-Loop事件循环" class="headerlink" title="Event Loop事件循环"></a>Event Loop事件循环</h3><p>事件循环实际上是一个无限循环，并且线程里唯一可用的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> StartNodeInstance(<span class="keyword">void</span>* arg)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#123;</span><br><span class="line">        SealHandleScope seal(isolate);</span><br><span class="line">        bool more;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            v8::platform::PumpMessageLoop(default_platform,isolate);</span><br><span class="line">            more = uv_run(env-&gt;event_loop(),UV_RUN_ONCE);</span><br><span class="line">            <span class="keyword">if</span>(mode == <span class="literal">false</span>)&#123;</span><br><span class="line">                v8::platform::PumpMessageLoop(default_platform,isolate);</span><br><span class="line">                EmitBeforeExit(env);</span><br><span class="line">                </span><br><span class="line">                more = uv_loop_alive(env-&gt;event_loop());</span><br><span class="line">                <span class="keyword">if</span>(uv_run(env-&gt;event_loop),UV_RUN_NOWAIT)!=<span class="number">0</span>)&#123;</span><br><span class="line">                    more = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(more == <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件循环经历6个阶段，所有阶段的执行被称为tick</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">timers-&gt;</span><span class="bash">pending callbacks -&gt;idle,prepare-&gt;poll-&gt;check-&gt;close callbacks</span></span><br></pre></td></tr></table></figure><ul><li>timers：这个阶段执行定时器setTimeout和setInterval的回调函数</li><li>pending callbacks：几乎所有的回调都在这里执行，除了close回调，定时器timers阶段的回调和setImmediate</li><li>idle,prepare：仅在内部使用</li><li>poll：检索新的I/O事件，适当时Node在此处阻塞</li><li>check：setImmediate回调函数将在这里执行</li><li>close callbacks：一些准备关闭的回调函数，如 socket.on(‘close’,…)</li></ul><p>当Event loop需要执行I/O操作时，它将从一个池（通过Libuv库）中使用系统线程，当这个作业完成时，回调将排队等待在pending callbacks阶段被执行</p><h3 id="CPU密集型任务问题"><a href="#CPU密集型任务问题" class="headerlink" title="CPU密集型任务问题"></a>CPU密集型任务问题</h3><p>设定一个函数，给定一个数，计算在一个数组中返回N个质数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primes.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>, s = <span class="built_in">Math</span>.sqrt(n); i &lt;= s; i++)</span><br><span class="line">    <span class="keyword">if</span> (n % i === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> n &gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nthPrime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = n;</span><br><span class="line">  <span class="keyword">let</span> iterator = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (counter &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    isPrime(iterator) &amp;&amp; result.push(iterator) &amp;&amp; counter--;</span><br><span class="line">    iterator++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; isPrime, nthPrime &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> primes = <span class="built_in">require</span>(<span class="string">'./primes'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; pathname, query &#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (pathname === <span class="string">'/primes'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = primes.nthPrime(query.n || <span class="number">0</span>);</span><br><span class="line">    res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>);</span><br><span class="line">    res.write(<span class="built_in">JSON</span>.stringify(result));</span><br><span class="line">    res.end()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.statusCode = <span class="number">404</span>;</span><br><span class="line">    res.write(<span class="string">'Not Found'</span>);</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(<span class="number">9898</span>);</span><br><span class="line"><span class="comment">// index.js 创建一个服务并在每次请求 /primes这个库，通过query传递参数，假设有3个客户端访问这个非阻塞API,第一个页面请求5个质数，第二个1000个，第三个100000000个，会发现，第三个请求时，客户端就会被阻塞，因为质数会占用大量的CPU,主线程忙于执行密集型的代码，将无法做其他事情，还有Node引入了工作线程</span></span><br></pre></td></tr></table></figure><h3 id="工作线程"><a href="#工作线程" class="headerlink" title="工作线程"></a>工作线程</h3><p>工作线程对于执行CPU密集型的javascript操作非常有用，在I/O密集型的工作中用途不大，NodeJs内置的异步I/O操作比工作线程效率更高</p><p>修改代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; workerData, parentPort &#125; = <span class="built_in">require</span>(<span class="string">'worker_threads'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>, s = <span class="built_in">Math</span>.sqrt(n); i &lt;= s; i++)</span><br><span class="line">    <span class="keyword">if</span> (n % i === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> n &gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nthPrime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = n;</span><br><span class="line">  <span class="keyword">let</span> iterator = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (counter &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    isPrime(iterator) &amp;&amp; result.push(iterator) &amp;&amp; counter--;</span><br><span class="line">    iterator++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parentPort.postMessage(nthPrime(workerData.n))</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; Worker &#125; = <span class="built_in">require</span>(<span class="string">'worker_threads'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; pathname, query &#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (pathname === <span class="string">'/primes'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(<span class="string">'./primes.js'</span>, &#123;</span><br><span class="line">      workerData: &#123;</span><br><span class="line">        n: query.n || <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    worker.on(<span class="string">'error'</span>, () =&gt; &#123;</span><br><span class="line">      res.statusCode = <span class="number">500</span>;</span><br><span class="line">      res.write(<span class="string">'Oops there was an error'</span>);</span><br><span class="line">      res.end();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line"></span><br><span class="line">    worker.on(<span class="string">'message'</span>, (message) =&gt; &#123;</span><br><span class="line">      result = message;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    worker.on(<span class="string">'exit'</span>, () =&gt; &#123;</span><br><span class="line">      res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>);</span><br><span class="line">      res.write(<span class="built_in">JSON</span>.stringify(result));</span><br><span class="line">      res.end()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.statusCode = <span class="number">404</span>;</span><br><span class="line">    res.write(<span class="string">'Not Found'</span>);</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(<span class="number">9898</span>);</span><br><span class="line"><span class="comment">// index.js在每个请求中创建一个Worker实例，在一个工作线程中加载并执行primes文件，当这个质数列表计算完成买这个message将会被触发，接受信息并赋值result，由于这个job已完成，将会再次触发exit事件，允许主线程发送数据到客户端</span></span><br><span class="line"><span class="comment">// primes导入 workerData(从主线程传递参数)，parentPort是向主线程发送消息的方式</span></span><br><span class="line"><span class="comment">// 主线程将不会再阻塞，但是生成工作线程并不是最佳实践，创建新线程并不便宜，一定要先创建一个线程池</span></span><br></pre></td></tr></table></figure><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis是一个免费开源、基于内存的高性能Key-Value数据库，具有速度快，数据持久化，多语言和多功能等特性。</p><p><strong>速度快</strong>：10w OPS能力，单线程模型，数据存于内存中，注意一次只能运行一次命令，使用过程拒绝使用慢命令，例如keys/flushall/flushdb/slow lua script/mutil/exec等</p><p><strong>持久化</strong>：基于内存模型，断电后或者服务重启会造成数据丢失，针对这个问题，提出两种数据持久化策略，分别为RDB和AOF,会将Redis在内存中的数据异步更新到磁盘中，实现数据的持久化功能。</p><p><strong>丰富的数据类型</strong>：除了常见的String/HashTable/List/Set/Zset之外还有BitMaps(位图)、HyperLogLog（超小内存唯一计数）</p><p><strong>多语言</strong>：基于TCP的通信方式，支持Node.Js/Python/Java/Ruby/Lua等。</p><p><strong>多功能</strong>：提供了发布订阅、简单的事务功能、pipeline提高客户端并发效率。另外在Redis中所有单个命令操作都是原子性的，如果想对多个命令一起操作，可以借助Lua脚本（实现自定义命令，保证原子性）</p><h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><ul><li><code>keys *</code> ：遍历所有key，生产环境不建议使用，时间复杂度O(n)</li><li><code>dbsize key</code>：计算key的总数，Redis内置了这个计数器，会实时更新key的总数，时间复杂度O(1)</li><li><code>exists key</code>：检查key是否存在，时间复杂度为O(1)</li><li><code>expire key seconds</code>：key在指定second后过期，时间复杂度O(1)</li><li><code>ttl key</code>：key剩余的过期时间，时间复杂度O(1)</li><li><code>persist key</code>: 去掉key的过期时间，时间复杂度O(1)</li><li><code>type key</code>：查看key的类型，时间复杂度O(1)</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>最大限制512MB,适用于缓存、计算器、分布式锁等，字符串类型的值可以为简单的字符串、JSON、XML、数组甚至是二进制（视频）</p><h5 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h5><table><thead><tr><th>命令</th><th>含义</th><th>时间复杂度</th></tr></thead><tbody><tr><td>set get del</td><td>对key进行设置、读取、删除</td><td>O(1)</td></tr><tr><td>incr decr</td><td>计数</td><td>O(1)</td></tr><tr><td>incrby decrby</td><td>对计数设置增量</td><td>O(1)</td></tr><tr><td>setnx</td><td>key存在不做任何操作</td><td>O(1)</td></tr><tr><td>setex</td><td>key存在做操作与setnx相反</td><td>O(1)</td></tr><tr><td>getset</td><td>设置新值返回旧值 getset key newValue</td><td>O(1)</td></tr><tr><td>mset mget</td><td>多个key进行设置、读取</td><td>O(1)</td></tr></tbody></table><p><strong>set</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set key value [ex seconds] [px milliseconds] [nx|xx]</span><br><span class="line"><span class="comment">// seconds：单位(秒)</span></span><br><span class="line"><span class="comment">// milliseconds:单位（毫秒）</span></span><br><span class="line"><span class="comment">// nx:key 存在不做任何操作，等价于setnx</span></span><br><span class="line"><span class="comment">// xx:key 存在做操作与nx相反，相当于setex</span></span><br></pre></td></tr></table></figure><p><strong>mget mset</strong></p><p>mget/mset可以批量获取或设置值，如果使用get多次读取数据等价于n次网络时间+n次命令时间，这种方法可以用mget优化，等价于1次网络时间+n次命令时间，这是一个O(n)操作，避免命令过多客户端阻塞</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset key1 val1 key2 val2 key3 val3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget key1 key2 key3</span><br><span class="line">1) "val1"</span><br><span class="line">2) "val2"</span><br><span class="line">3) "val3"</span><br></pre></td></tr></table></figure><p><strong>incr decr incrby decrby </strong></p><ul><li>incr：自增</li><li>decr：自减</li><li>incrby：指定数字自增</li><li>decrby：指定数字自减</li><li>incrbyfloat：指定浮点数自增</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">incr key</span><br><span class="line">decr key</span><br><span class="line">incrby key increment</span><br><span class="line">decrby key decrement</span><br><span class="line">incrbyfloat key increment</span><br></pre></td></tr></table></figure><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>缓存，对城市列表数据进行缓存</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cityList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> redisKey = <span class="string">'city'</span>;</span><br><span class="line">    <span class="keyword">let</span> cities = redis.get(redisKey)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!cities)&#123;</span><br><span class="line">        cities = mongo.getCityList();</span><br><span class="line">        redis.set(redisKey,<span class="built_in">JSON</span>.stringify(cities));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cities;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分布式锁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value [EX seconds] [PX milliseconds] [NX|XX]</span><br></pre></td></tr></table></figure><p>计数器，网站的PV/UV统计，文章点赞、阅读量，视频网络的播放量，Redis提供的incr命令可实现计数器功能，性能好复杂度为O(1)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> incrPageViewsCounter = <span class="function"><span class="params">pageId</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="string">`page:views:<span class="subst">$&#123;pageId&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> redis.incr(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Session存储，Redis不会因为服务器重启导致Session数据丢失，具有数据持久化功能。</p><p>限流，短信发送为了避免接口被频繁调用，通常要在指定时间内避免重复发送</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SMSLimit = <span class="keyword">async</span> phone =&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="string">`sms:limit:<span class="subst">$&#123;phone&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> redis.set(key,<span class="number">1</span>,<span class="string">'EX'</span>,<span class="number">60</span>,<span class="string">'NX'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(result === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'60s 内无法再次发送验证码'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'可以发送'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SMSLimit(<span class="number">18800000000</span>)</span><br></pre></td></tr></table></figure><h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>哈希结构有一个特点，所有命令都是H开头，hash类型其值本身就由一个或多个filed-value构成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hashKey = &#123;</span><br><span class="line">    filed1:value1,</span><br><span class="line">    filed2:value2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优：节省空间，可以部分更新</span></span><br><span class="line"><span class="comment">// 缺：不支持TTL设置，Redis中过期时间只针对顶级Key,无法对Hash Key的field设置过期时间，只能对整个Key 通过expire设置</span></span><br><span class="line"><span class="comment">// 注意：在使用hgetall的时候注意，集合很大将会浪费性能</span></span><br></pre></td></tr></table></figure><h5 id="常见命令-1"><a href="#常见命令-1" class="headerlink" title="常见命令"></a>常见命令</h5><table><thead><tr><th>命令</th><th>含义</th><th>时间复杂度</th></tr></thead><tbody><tr><td>hset</td><td>对key的field进行设置</td><td>O(1)</td></tr><tr><td>hget</td><td>获取key指定的field</td><td>O(1)</td></tr><tr><td>hdel</td><td>删除key指定的field</td><td>O(1)</td></tr><tr><td>hincrby hincrbyfloat</td><td>类似于incrby incryfloat 这个操作的是field</td><td>O(1)</td></tr><tr><td>hmset hmget</td><td>对多个filed value 设置 读取</td><td>O(n)</td></tr><tr><td>hgetall</td><td>获取key的所有field value</td><td>O(n)</td></tr><tr><td>hvals</td><td>获取key的所有value</td><td>O(n)</td></tr><tr><td>hkeys</td><td>获取key的所有fields</td><td>O(n)</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset student name Jack</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hget student name</span><br><span class="line">"Jack"</span><br><span class="line">127.0.0.1:6379&gt; hmset student age 18 sex man</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget student sex age</span><br><span class="line">1) "man"</span><br><span class="line">2) "18"</span><br><span class="line">127.0.0.1:6379&gt; hgetall student</span><br><span class="line">1) "name"</span><br><span class="line">2) "Jack"</span><br><span class="line">3) "age"</span><br><span class="line">4) "18"</span><br><span class="line">5) "sex"</span><br><span class="line">6) "man"</span><br></pre></td></tr></table></figure><h5 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h5><p>hash适合将一些数据存储在一起，例如缓存用户信息，与字符串不同的是，hash可以对用户信息结构中的每个字段单独存储，当需要获取信息时可以仅获取需要的部分字段。如果用字符串存储，两种方式，一种是将信息拆分为多个键（每个属性一个键）来存储，占用过的key同时占用空间；另外一种方式是序列化字符串存储，这种方式如果去数据只能全部取出并且还要进行反序列化，序列化/反序列化也有一定的内存开销</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存用户信息例子：</span></span><br><span class="line"><span class="comment">// 模拟查询Mongo数据</span></span><br><span class="line"><span class="keyword">const</span> mongo = &#123;</span><br><span class="line">    getUserInfoByUserId:<span class="function"><span class="params">userId</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            name:<span class="string">'Jack'</span>,</span><br><span class="line">            age:<span class="number">19</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户信息</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params">userId</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="string">`user:<span class="subst">$&#123;userId&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 从缓存获取数据</span></span><br><span class="line">        <span class="keyword">const</span> userInfoCache = <span class="keyword">await</span> redis.hgetall(key);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 userInfoCache为空，返回值为&#123;&#125;</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Object</span>.keys(userInfoCache).length ===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> userInfo = mongo.getUserInfoByUserId(userId);</span><br><span class="line">            <span class="keyword">await</span> redis.hmset(key,userInfo);</span><br><span class="line">            <span class="keyword">await</span> redis.expire(key,<span class="number">120</span>);</span><br><span class="line">            <span class="keyword">return</span> userinfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userInfoCache;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserInfo(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>Redis的列表用来存储字符串元素的集合，基于Linked Lists实现，意味着插入、删除操作非常快，时间复杂度为O(1),索引很慢，时间复杂度为O(n)</p><p>Redis列表命令都是L开头，在实际运用中可以作为队列或者栈</p><ul><li>Stack（栈）：后进先出，实现命令<code>lpush+lpop</code></li><li>Queue（队列）：先进先出，实现命令<code>lpush+rpop</code></li><li>Capped Collection(有限集合)：<code>lpush+ltrim</code></li><li>Message Queue(消息队列)：<code>lpush+brpop</code></li></ul><h5 id="常见命令-2"><a href="#常见命令-2" class="headerlink" title="常见命令"></a>常见命令</h5><table><thead><tr><th>命令</th><th>含义</th><th>时间复杂度</th></tr></thead><tbody><tr><td>lpush rpush</td><td>列表左端/右端插入一个值</td><td>O(1~n)</td></tr><tr><td>linsert</td><td>列表指定的值前/后插入新值</td><td>O(n)</td></tr><tr><td>lpop rpop</td><td>列表左侧或者右侧弹出一个值</td><td>O(1)</td></tr><tr><td>blpop brpop</td><td>lpop rpop 的阻塞版本，需设置timeout</td><td>O(1)</td></tr><tr><td>ltrim</td><td>按照索引范围修剪列表</td><td>O(n)</td></tr><tr><td>lrange</td><td>获取指定范围内的元素列表</td><td>O(n)</td></tr><tr><td>llen</td><td>获取列表长度</td><td>O(1)</td></tr><tr><td>lset</td><td>设置列表指定索引值为新值</td><td>O(n)</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列表左侧加入三个元素</span></span><br><span class="line">127.0.0.1:6379&gt; lpush languages JavaScript Python Go</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取列表长度</span></span><br><span class="line">127.0.0.1:6379&gt; llen languages</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取指定范围内元素列表 从左到右 start/end-&gt;0/N-1 从右到左 start/end-&gt;-1/-N</span></span><br><span class="line">127.0.0.1:6379&gt; lrange languages 0 2</span><br><span class="line">1) "Go"</span><br><span class="line">2) "Python"</span><br><span class="line">3) "JavaScript"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列表右侧插入元素</span></span><br><span class="line">127.0.0.1:6379&gt; rpush languages TypeScript</span><br><span class="line">(integer) 4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看列表的元素</span></span><br><span class="line">127.0.0.1:6379&gt; lrange languages 0 3</span><br><span class="line">1) "Go"</span><br><span class="line">2) "Python"</span><br><span class="line">3) "JavaScript"</span><br><span class="line">4) "TypeScript"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列表左端移除一个元素</span></span><br><span class="line">127.0.0.1:6379&gt; lpop languages</span><br><span class="line">"Go"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列表右端移除一个元素</span></span><br><span class="line">127.0.0.1:6379&gt; rpop languages</span><br><span class="line">"TypeScript"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 谁的那个列表指定索引值为新值</span></span><br><span class="line">127.0.0.1:6379&gt; lset languages 1 JS</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列表指定的值前/后插入新值</span></span><br><span class="line">127.0.0.1:6379&gt; linsert languages after JS Nodejs</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按照索引范围修剪列表（元素截取）</span></span><br><span class="line">127.0.0.1:6379&gt; ltrim languages 1 2</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h5 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h5><p>消息队列，Redis List结构的lpush与brpop命令可实现消息队列，lpush命令是从左端插入数据，brpop命令是从右端阻塞式的读取数据，阻塞读过程中如果队列中没有数据，会立即进入休眠直到数据到来或超过设置的timeout时间，会立即醒过来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="string">'languages'</span>;</span><br><span class="line">    <span class="comment">// 阻塞读，timeout为5秒钟</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> redis.brpop(key,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>Redis集合类型可用来存储多个字符串元素，和列表不同，集合元素不允许重复，集合中的元素是无须的，也不能通过索引下标获取元素。Redis集合的命令都是S开头</p><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><table><thead><tr><th>命令</th><th>含义</th><th>时间复杂度</th></tr></thead><tbody><tr><td>sadd</td><td>集合中添加元素，如果元素重复则添加失败</td><td>O(1)</td></tr><tr><td>srem</td><td>删除集合中的元素</td><td>O(1)</td></tr><tr><td>scard</td><td>计算集合中的元素个数</td><td>O(1)</td></tr><tr><td>sismember</td><td>判断集合中是否存在指定元素</td><td>O(count)</td></tr><tr><td>srandmember</td><td>随机从集合中返回指定元素</td><td>O(n)</td></tr><tr><td>sinter</td><td>求集合交集</td><td></td></tr><tr><td>sunion</td><td>求集合并集</td><td></td></tr><tr><td>sdiff</td><td>求集合差集</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 集合中添加元素</span></span><br><span class="line">127.0.0.1:6379&gt; sadd languages2 Nodejs JavaScript</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算集合中元素个数</span></span><br><span class="line">127.0.0.1:6379&gt; scard languages2</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断集合中是否存在指定元素 1 存在 0不存在</span></span><br><span class="line">127.0.0.1:6379&gt; sismember languages2 Nodejs</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sismember languages2 Nodejs1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 随机从集合中返回n个元素</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember languages2 2</span><br><span class="line">1) "JavaScript"</span><br><span class="line">2) "Nodejs"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; srandmember languages2 3</span><br><span class="line">1) "JavaScript"</span><br><span class="line">2) "Nodejs"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置用户1 使用的语言</span></span><br><span class="line">127.0.0.1:6379&gt; sadd user:1 Nodejs JavaScript</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置用户2 使用的语言</span></span><br><span class="line">127.0.0.1:6379&gt; sadd user:2 Nodejs Python</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 求 user:1与 user:2 交集</span></span><br><span class="line">127.0.0.1:6379&gt; sinter user:1 user:2</span><br><span class="line">1) "Nodejs"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 求user:1 与 user:2 并集</span></span><br><span class="line">127.0.0.1:6379&gt; sunion user:1 user:2</span><br><span class="line">1) "JavaScript"</span><br><span class="line">2) "Nodejs"</span><br><span class="line">3) "Python"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 求user:1 与 user:2 差集</span></span><br><span class="line">127.0.0.1:6379&gt; sdiff user:1 user:2</span><br><span class="line">1) "JavaScript"</span><br></pre></td></tr></table></figure><h5 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h5><p>抽奖，Redis的结合有去重功能，一些抽奖类项目中可以存储中奖的用户Id,能够保证同一个用户Id不会中奖两次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">userId</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="string">'luck:users'</span>;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> redis.sadd(key,userId);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果元素存在，返回0表示未添加成功</span></span><br><span class="line">    <span class="keyword">if</span>(result === <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'您已中间一次，无法再次参与'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'恭喜您中奖'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>计算用户共同感兴趣的商品，sadd与sinter可以用来统计用户共同感兴趣的商品，sadd保存每个用户喜欢的商品标签，使用sinter对每个用户感兴趣的商品标签求交集</p><h4 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h4><p>Redis有序集合zset保留了集合set元素不能重复的特征之外，在有序集合的元素中是可以排序的，与列表使用索引下标不同的是有序集合是有序集合给每个元素设置一个分值（score）作为排序的依据</p><p>Redis有序集合是Z开头的</p><h5 id="常见命令-3"><a href="#常见命令-3" class="headerlink" title="常见命令"></a>常见命令</h5><table><thead><tr><th>命令</th><th>含义</th><th>时间复杂度</th></tr></thead><tbody><tr><td>zadd</td><td>集合中添加元素</td><td>O(logN)</td></tr><tr><td>zrem</td><td>集合中删除元素</td><td>O(1)</td></tr><tr><td>zscore</td><td>返回集合的分数</td><td>O(1)</td></tr><tr><td>zincrby</td><td>增加或者减少集合的分数</td><td>O(1)</td></tr><tr><td>zcard</td><td>返回元素的个数</td><td>O(1)</td></tr></tbody></table><p><strong>zadd</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zadd key [NX|XX] [CH] [INCR] score member [sroce member ...]</span><br><span class="line"><span class="meta">#</span><span class="bash"> [NX|XX]：NX member必须不存在才添加成功，用户Create;XX,member 必须存在才能更新成功，用于UPDATE</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [CH]：返回此次操作后有序集合元素和分数发生的变化</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [INCR]：对score做增加，相当于 zincrby</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> score：代表分数（排序）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> member：成员</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 有序集合 grages 中添加3个元素</span></span><br><span class="line">127.0.0.1:6379&gt; zadd grades NX 80 xiaoming 75 xiaozhang 85 xiaoli</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看成员 xiaozhang 分数</span></span><br><span class="line">127.0.0.1:6379&gt; zscore grades xiaozhang</span><br><span class="line">"75"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新成员 xiaozhang 分数</span></span><br><span class="line">127.0.0.1:6379&gt; zadd grades XX 90 xiaozhang</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次查看成员xiaozhang分数</span></span><br><span class="line">127.0.0.1:6379&gt; zscore grades xiaozhang</span><br><span class="line">"90"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看成员排名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分数从低到高</span></span><br><span class="line">127.0.0.1:6379&gt; zrank grades xiaozhang</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分数从高到低</span></span><br><span class="line">127.0.0.1:6379&gt; zrevrank grades xiaozhang</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加成员分数</span></span><br><span class="line">127.0.0.1:6379&gt; zincrby grades 5 xiaozhang</span><br><span class="line">"95"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回指定范围成员排名，WITHSCORES可选参数，去掉则不返回分数</span></span><br><span class="line">127.0.0.1:6379&gt; zrange grades 0 2 WITHSCORES</span><br><span class="line">1) "xiaoming"</span><br><span class="line">2) "80"</span><br><span class="line">3) "xiaoli"</span><br><span class="line">4) "85"</span><br><span class="line">5) "xiaozhang"</span><br><span class="line">6) "95"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回指定分数范围内的成员列表</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore grades 85 100</span><br><span class="line">1) "xiaoli"</span><br><span class="line">2) "xiaozhang"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定成员</span></span><br><span class="line">127.0.0.1:6379&gt; zrem grades xiaoli</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><h4 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h4><p>Redis整个生命周期：发送命令-&gt;排队-&gt;执行命令-&gt;返回结果，慢查询通常发生在执行命令阶段，可以通过日志查询系统slowlog进行问题定位跟踪</p><p>在配置文件中<code>redis.conf</code>设置：</p><ul><li>slowlog-max-len：表示慢查询最大的条数，默认128，保存在内存中，当超过预先设置的值后会将最早的slowlog删除，是个先进先出队列</li><li>slow-log-slower-than：慢查询阀值，默认10000微妙，只有命令执行时间大于该阀值才会被slowlog记录，如果记录所有命令将阀值设置为0</li></ul><p>Redis是每秒万级别，设置阀值时候，默认为10000微秒（10毫秒），不要设置太大，建议1毫秒之下，才有意义。定期将慢查询持久化到其他数据库，便于排查。</p><p>慢查询命令：</p><ul><li>slowlog get [n]：获取慢查询队列</li><li>slowlog len：获取慢查询队列长度</li><li>slowlog reset：清空慢查询队列</li></ul><h4 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h4><p>核心1次网络请求处理n条命令，redis本身命令处理时间是微秒级别，pipeline主要减少网络传输要求</p><h4 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h4><p>角色：发布者（publisher）/订阅者（subscriber）/频道（channel）:</p><ul><li>发布消息<code>publish channel message</code></li><li>订阅消息 <code>subscribe [channel]</code>，可以订阅多个频道</li><li>取消订阅 <code>unsubscribe [channel]</code></li></ul><h4 id="BitMaps（位图）"><a href="#BitMaps（位图）" class="headerlink" title="BitMaps（位图）"></a>BitMaps（位图）</h4><h4 id="CEO"><a href="#CEO" class="headerlink" title="CEO"></a>CEO</h4><p>用于地理位置定位，基于zset实现的：</p><ul><li><code>geoadd key longitude latitude member</code>增加地理位置信息，例如：<code>geoadd cities: 163.31 39.99 beijing</code></li><li><code>geopos key member [member...]</code>,获取地理位置消息，例如<code>geopos cities: beijing</code></li><li><code>geodist key member1 member2 [unit]</code>：获取两地址位置距离，unit为单位（m/km/mi/ft）,例如：<code>geodist cities: beijing shanghai km</code></li></ul><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>单机带来的问题机器故障、容量限制、QPS瓶颈，主从复制是一种一主多从的模式提供了数据副本，解决了单机带来的机器故障问题，另外主从分离模式还提供了Redis读的性能，也是高可用，分布式的基础。</p><p>所谓的主从复制就是一个Redis主节点拥有多个从节点，由主节点的数据单向复制到从节点，在一些读多写少的业务场景非常受用</p><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>Redis数据存储都是内存里，对数据的更新异步的存储在磁盘里，在Redis中的数据持久化有两种策略，RDB快照，AOF日历</p><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>把当前内存中的数据集快照写入磁盘，恢复时将快照文件直接读到内存里。</p><h5 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h5><p>save和bgsave生成快照</p><p>save：使用save会造成客户端阻塞，它使用一种同步的方式生成RDB快照文件，因为Redis是单线程，如果save过程很长也会阻塞其他客户端的命令，在生产中是不建议使用的</p><p>bgsave：使用bgsave Redis会fork一个子进程来负责生成RDB文件，由于bgsave是异步进行的并不会阻塞其他客户端的命令，bgsave模式下阻塞阶段发生在fork过程中</p><h5 id="持久化配置"><a href="#持久化配置" class="headerlink" title="持久化配置"></a>持久化配置</h5><p>其中stop-writes-on-bgsave-error这个配置很重要，如果子进程(也就是备用经常)在后台生成快照失败，主经常会停止新的写入操作，也是为了保持数据一致性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 持久化默认时间策略</span></span><br><span class="line">save 900 1 # 如果仅有1-9次更改操作，那么要900s才写入硬盘一次</span><br><span class="line">save 300 10 # 如果仅有10-9999次更改操作，那么要300s才写入硬盘一次</span><br><span class="line">save 60 10000 # 如果超过10000次更改操作，那么60s才会写入硬盘一次</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> RBD 文件名称，建议 dump-6379.rdb</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 工作目录（上面 dump-6379.rdb 文件保存目录）</span></span><br><span class="line">dir /data/soft/redis-5.0.5/data/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 备份进程出错，主进程停止写入</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否压缩</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 导入时是否检查</span></span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; save</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; bgsave</span><br><span class="line">Background saving started</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 服务端</span></span><br><span class="line">[35856] 02 Jul 10:01:02.999 * 1 changes in 3600 seconds. Saving...</span><br><span class="line">[35856] 02 Jul 10:01:03.063 * Background saving started by pid 58172</span><br><span class="line">[35856] 02 Jul 10:01:03.263 # fork operation complete</span><br><span class="line">[35856] 02 Jul 10:01:03.263 * Background saving terminated with success</span><br><span class="line">[35856] 02 Jul 10:30:56.240 * DB saved on disk</span><br><span class="line">[35856] 02 Jul 10:31:03.565 * Background saving started by pid 53904</span><br><span class="line">[35856] 02 Jul 10:31:03.705 # fork operation complete</span><br><span class="line">[35856] 02 Jul 10:31:03.705 * Background saving terminated with success</span><br></pre></td></tr></table></figure><h5 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h5><p>性能、时间耗时，存在不稳定性</p><p>RDB生成的过程就是将Redis内存中的dump到硬盘生成一个RDB文件，其实就是生成一个内存快照，save会造成阻塞，不建议生产环境去使用。besave的fork也是一个重量级操作，遵循copy-on-write（写入时复制）策略，新fork出的子进程会继续共享父进程的物理空间，使用COW技术可以避免不必要的资源分配，父进程的代码段和只读数据段都不允许修改，所以无需复制，当父进程处理些请求时会把要修改的页创建副本，而子进程在fork过冲中会共享父进程的内存快照</p><blockquote><p>Copy on Write技术实现原理：fork之后，kernel把父进程中所有的内存页的权限都设为read-only,然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写入内存时，CPU硬件检测到内存页是read-only,于是触发页异常中间（page-fault），陷入kernel的一个终端例程。中断例程中，kernal就会把触发的异常的页复制一份，于是分子进程各自持有独立的一份</p><p>COW技术可以减少分配和复制大量资源时带来的瞬间延迟，减少不必要的资源分配。</p><p>如果在fork之后，父子进程还需要进行读写操作，那么会产生大量的分页错误（页异常中断page-fault），这样就得不偿失了</p></blockquote><p>Redis会根据自定义时间策略或者定时任务手动执行besave进行快照备份，如果某个出现宕机会丢失部分数据</p><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>以写日志的方式执行redis命令后，将数据写入AOF日志文件</p><h5 id="可靠性fsync"><a href="#可靠性fsync" class="headerlink" title="可靠性fsync"></a>可靠性fsync</h5><p>redis命令写入过程，是先写入硬盘的缓冲区，缓冲区根据选择的策略写入到系统中，linux的glibc提供了fsync（init fd）函数可以将指定文件的内容强制从内核写入至磁盘，只要redis进程实时调用了fsync函数就可以保证AOF日志不丢失，由于fsync是一个磁盘I/O操作，所以不能每条redis指令都执行一次fsync，这样redis高性能就没有保证，有三种策略，默认推荐everysec策略：</p><ul><li>always：每条命令都会写入AOF中，保证数据不会丢失，但是I/O开销会很大</li><li>everysec：以每秒钟为单位将缓冲区中的数据写入到硬盘，如果出现故障可能会丢失1秒钟的数据，这个也是Redis的默认值</li><li>no：这个策略根据操作系统定义的进行写入，不需要操作，但同时也是不可控的。</li></ul><h5 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h5><p>将那些过期、重复的命令进行压缩减少，从而达到减少硬盘占用量，提高数据恢复速度</p><p>实现方式：</p><ul><li>bgrewriteaof:类似于RDB中的bgsave</li><li>auto-aof-rewrite-min-size：配置AOF重写需要的最小尺寸</li><li>auto-aof-rewrite-percentage：配置AOF文件增长率</li></ul><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 是否开启 aof</span></span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件名称</span></span><br><span class="line">appendfilename "appendonly-6379.aof"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步方式</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> aof 重写期间是否同步</span></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重写触发配置</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加载 aof 时如果有错如何处理</span></span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件重写策略</span></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure><h5 id="数据损坏修复"><a href="#数据损坏修复" class="headerlink" title="数据损坏修复"></a>数据损坏修复</h5><p>“在过去曾经发现一些很罕见的 BUG 导致使用 AOF 重建的数据跟原数据不一致的问题。” 这句话来自 Redis 实践官方，为了应对这种罕见的 BUG 可以使用 redis-check-aof 命令修复原始的 AOF 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-check-aof --fix appendonly-6379.aof # appendonly-6379.aof 对应你的 aof 日志文件</span><br></pre></td></tr></table></figure><h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><ul><li>重放优先级：系统重启时优先重放AOF备份数据，随后是RDB,因为从数据备份的完整性考虑，AOF相比RDB可靠性更高些</li><li>恢复速度快：RDB采用二进制方式存储占用体积小，AOF是以日志形式存储，体积相比RDB要大，相比较来说，RDB的数据恢复速度要高于AOF</li><li>数据安全性：RDB采用快照形式，在一定时间内会丢失数据，AOF相对更安全些，主要有三种策略。</li></ul><p>一般来说，应该同时使用两种持久化功能，如果可以承受数分钟以内的数据丢失，可以只使用RDB持久化。很多用户都只使用AOF持久化，而定时生成RDB非常便于进行数据库备份，并且RDB恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免之前说过的AOFbug。</p><h3 id="哨兵高可用"><a href="#哨兵高可用" class="headerlink" title="哨兵高可用"></a>哨兵高可用</h3><p>主从复制如果主节点发生故障，Redis Sentinel功能可以自动提升而不是人工干预</p><p>Sentinel是一个分布式系统，类似于Cousul集群，一般由3~5个节点组成，使用Raft算法实现领导者选举因为故障转移只需要一个Sentinel节点来完成</p><h3 id="为什么Redis只适用于缓存而不能当做数据库来使用？"><a href="#为什么Redis只适用于缓存而不能当做数据库来使用？" class="headerlink" title="为什么Redis只适用于缓存而不能当做数据库来使用？"></a>为什么Redis只适用于缓存而不能当做数据库来使用？</h3><ul><li>性能：Redis是一个基于内存的数据库，通常用来计数器、Session存储、缓存设计等等</li><li>成本：假设百万条数据，仅1%是热点数据其余都是冷数据，这种情况全部都存在Redis里面，是资源的浪费，从缓存设计角度来说，所保存的也仅是热点数据</li><li>灵活性：Redis的数据结构是丰富的，支持String,HashTable,List,Set,Zset还有最新的BitMaps.GEO等，如果有很复杂的查询语句，关联查询等，还是SQL等数据库更加合适</li><li>数据可靠性：第一种方式是Redis+RDB，如果发生断电，自上次持久化到最次一次故障之间的数据丢失。第二种是Redis+AOF，AOF有三种策略将数据持久化到磁盘，其中everysec是相对折中的一种方案，everysec折中方案也会存在1秒钟数据丢失的问题。</li></ul><h3 id="实践1——计数器实现并发场景下的优惠券领取功能"><a href="#实践1——计数器实现并发场景下的优惠券领取功能" class="headerlink" title="实践1——计数器实现并发场景下的优惠券领取功能"></a>实践1——计数器实现并发场景下的优惠券领取功能</h3><p>计数器在实际中有很多需求：PV/UV、接口并发限制、抽奖、优惠券领取等</p><h4 id="业务背景"><a href="#业务背景" class="headerlink" title="业务背景"></a>业务背景</h4><p>业务需求方做优惠券发放活动，共优惠券10张，参与用户100人，先到先得，假设每次并发20用户同时访问，如何保证不超领取</p><h4 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h4><ul><li>exists：判断指定key是否存在</li><li>setnx：设置值，若值存在不做任何处理</li><li>incr：计数</li></ul><p>每发送一次领取请求，采用incr命令进行自增，由于redis单线程的原因，可以保证原子性，不会出现超领</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luck.js</span></span><br><span class="line"><span class="keyword">const</span> Redis = <span class="built_in">require</span>(<span class="string">'redis'</span>);</span><br><span class="line"><span class="keyword">const</span> redis = <span class="keyword">new</span> Redis(<span class="number">6379</span>,<span class="string">'127.0.0.1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将日志写入指定文件</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;Console&#125; = <span class="built_in">require</span>(<span class="string">'console'</span>);</span><br><span class="line"><span class="keyword">const</span> output = fs.createWriteStream(<span class="string">'./stdout.js'</span>)</span><br><span class="line"><span class="keyword">const</span> errorOutput  fs.createWriteStream(<span class="string">'./stderr.js'</span>)</span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Console(output,errorOutput);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">luck</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="string">'counter:luck'</span>;</span><br><span class="line">    <span class="keyword">const</span> keyExists = <span class="keyword">await</span> redis.exists(key);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!keyExists)&#123;</span><br><span class="line">        <span class="comment">// 如果key不存在初始化设置</span></span><br><span class="line">        <span class="keyword">await</span> redis.setnx(key,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加领取数量</span></span><br><span class="line">    <span class="keyword">const</span> result =  <span class="keyword">await</span> redis.incr(key);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(result &gt; count)&#123;</span><br><span class="line">        <span class="comment">// 优惠券领取超限</span></span><br><span class="line">        logger.error(<span class="string">'luck failure'</span>,result);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    logger.info(<span class="string">'luck success'</span>,result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.export = luck;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> luck = <span class="built_in">require</span>(<span class="string">'./luck'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.url === <span class="string">'luck'</span>)&#123;</span><br><span class="line">        luck();</span><br><span class="line">        </span><br><span class="line">        res.end(<span class="string">'ok'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><h3 id="实践2——Redis-Lua脚本"><a href="#实践2——Redis-Lua脚本" class="headerlink" title="实践2——Redis Lua脚本"></a>实践2——Redis Lua脚本</h3><p>Lua是一种轻量小巧的脚本语言，用标准c语言编写并以源代码形式开放，设计目的是为嵌入应用程序中，从而为应用程序提供灵活的扩张和定制功能。由于Lua语言具有原子性，其在执行过程中不会被其他程序打断，对于并发下的数据一致性有一定的帮助</p><h4 id="两种Lua脚本"><a href="#两种Lua脚本" class="headerlink" title="两种Lua脚本"></a>两种Lua脚本</h4><p>Redis支持两种运行Lua脚本，一种是直接Redis中输入Lua代码，适用于一些简单的脚本，另一种方式是编写Lua脚本文件，Redis使用SHA1算法支持对脚本签名和Script Load 预先缓存，需要运行的时候通过签名返回的标识符即可。</p><h4 id="EVAL"><a href="#EVAL" class="headerlink" title="EVAL"></a>EVAL</h4><p>通过内置的Lua解释器，可以使用EVAL命令对Lua脚本进行求值</p><ul><li>script：指定脚本</li><li>numkeys：指定键名餐参数个数</li><li>key：键名，可以多个key,通过KEYS[1]KEYS[2]的形式访问</li><li>atg：键值，可以多个val，通ARGS[1]ARGS[2]的形式访问</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EVAL script numkeys key[key...] arg[arg...]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过KEYS[] 数组的形式访问ARGV[],下标是从1开始，KEYS[1]对应的键名为name1,ARGV[2]对应的值为val2</span></span><br><span class="line">127.0.0.1:6379&gt; EVAL "return redis.call('SET',KEYS[1],ARGV[2])" 2 name1 name2 va</span><br><span class="line">l1 val2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name1</span><br><span class="line">"val2"</span><br></pre></td></tr></table></figure><p>redis.call何redis.pcall是两个不同的Lua函数来调用redis命令，区别是如果redis命令中出现错误异常，redis.call会直接返回一个错误信息给调用者，而redis.pcall会以Lua的形式对错误进行捕获并返回</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里执行了两条 Redis 命令，第一条故意写了一个 SET_ 这是一个错误的命令，可以看到出错后，错误信息被抛出给了调用者，同时你执行 get name2 会得到 (nil)，第二条命令也没有被执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis.call</span></span><br><span class="line">127.0.0.1:6379&gt; EVAL "redis.call('SET_', KEYS[1], ARGV[2]); redis.call('SET', KEYS[2], ARGV[3])" 2 name1 name2 val1 val2 val3</span><br><span class="line">(error) ERR Error running script (call to f_bf814e38e3d98242ae0c62791fa299f04e757a7d): @user_script:1: @user_script: 1: Unknown Redis command called from Lua script </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis.pcall</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一样的操作，可以看到输出结果为nil，它的错误被Lua捕获了，在执行get name2 会得到一个设置好的结果val3，这里第二条命令是被执行了的</span></span><br><span class="line">EVAL "redis.pcall('SET_', KEYS[1], ARGV[2]); redis.pcall('SET', KEYS[2], ARGV[3])" 2 name1 name2 val1 val2 val3</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h5 id="Nodejs实现"><a href="#Nodejs实现" class="headerlink" title="Nodejs实现"></a>Nodejs实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ioredis 支持所有脚本命令，比如EVAL/EVALSHA/SCRIPT,在现实场景中使用它是很繁琐的，要注意脚本缓存，并检测何时使用EVAL、EVALSHA.ioredis公开了一个defineCommand方法，使得脚本更容易使用</span></span><br><span class="line"><span class="keyword">const</span> Redis = require(<span class="string">'ioredis'</span>);</span><br><span class="line"><span class="keyword">const</span> redis = <span class="keyword">new</span> Redis(<span class="number">6379</span>,<span class="string">'127.0.0.1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> evalScript = <span class="string">"return redis.call('SET',KEYS[1],ARGV[2])"</span>;</span><br><span class="line">redis.defineCommand(<span class="string">'evalTest'</span>,&#123;</span><br><span class="line">    numberOfKeys:<span class="number">2</span>,</span><br><span class="line">    lua:evalScript</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function">async function <span class="title">eval</span><span class="params">()</span></span>&#123;</span><br><span class="line">    await redis.evalTest(<span class="string">'name1'</span>,<span class="string">'name2'</span>,<span class="string">'val1'</span>,<span class="string">'val2'</span>);</span><br><span class="line">    <span class="keyword">const</span> result = await redis.get(<span class="string">'name1'</span>);</span><br><span class="line">    console.log(result) <span class="comment">// val2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eval();</span><br></pre></td></tr></table></figure><h4 id="EVALSHA"><a href="#EVALSHA" class="headerlink" title="EVALSHA"></a>EVALSHA</h4><p>EVAL命令要求每次执行脚本的时候都发送一次脚本主体script body。Redis有一个内部缓存机制，因此它不会每次都重新编译脚本，通过EVALSHA来实现，根据给定的SHA1校验码，对缓存在服务器中的脚本进行求值</p><ul><li>SCRIPT FLUSH：清除所有脚本缓存</li><li>SCRIPT EXISTS：检查指定的脚本是否存在于脚本缓存</li><li>SCRIPT LOAD：讲一个脚本转入脚本缓存，但不立即运行它</li><li>SCRIPT KILL：杀死当前正在运行的脚本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EVALSHA sha1 numkeys key [key...] arg[arg...]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 载入脚本缓存</span></span><br><span class="line">127.0.0.1:6379&gt; SCRIPT LOAD "redis.pcall('SET',KEYS[1],ARGV[2])"</span><br><span class="line">"3b2c59b4e98a20a3a9e631fb586218e7b70f1020"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成的SHA-1签名的标识字符串用于执行之后的脚本</span></span><br><span class="line">127.0.0.1:6379&gt; EVALSHA 3b2c59b4e98a20a3a9e631fb586218e7b70f1020 2 name11 name12</span><br><span class="line"> val11 val12</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get name11</span><br><span class="line">"val12"</span><br></pre></td></tr></table></figure><h5 id="nodejs实现"><a href="#nodejs实现" class="headerlink" title="nodejs实现"></a>nodejs实现</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Redis = <span class="built_in">require</span>(<span class="string">'ioredis'</span>);</span><br><span class="line"><span class="keyword">const</span> redis = <span class="keyword">new</span> Redis(<span class="number">6379</span>,<span class="string">'127.0.0.1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> evalScript = <span class="string">"return redis.call('SET'，KEY1[1],ARGV[2])"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">evalSHA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.缓存脚本获取sha1值</span></span><br><span class="line">    <span class="keyword">const</span> sha1 = <span class="keyword">await</span> redis.script(<span class="string">'load'</span>,evalScript);</span><br><span class="line">    <span class="comment">// 2.通过evalsha执行脚本</span></span><br><span class="line">    <span class="keyword">await</span> redis.evalsha(sha1,<span class="number">2</span>,<span class="string">'name1'</span>,<span class="string">'name2'</span>,<span class="string">'val1'</span>,<span class="string">'val2'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.获取数据</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> redis.get(<span class="string">'name1'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// val2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">evalSHA();</span><br></pre></td></tr></table></figure><h4 id="Lua脚本文件"><a href="#Lua脚本文件" class="headerlink" title="Lua脚本文件"></a>Lua脚本文件</h4><p>有逻辑运算的脚本，可以编写Lua脚本文件</p><p>下面是一个测试代码，通过读取两个值比较返回不同的值，通过lua脚本实现后可以多条redis命令原子性</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---test.lua</span></span><br><span class="line"><span class="comment">-- 先SET</span></span><br><span class="line">redis.call(<span class="string">'SET'</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>])</span><br><span class="line">redis.call(<span class="string">'SET'</span>,KEYS[<span class="number">2</span>],ARGV[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- GET 取值</span></span><br><span class="line"><span class="keyword">local</span> key1 = <span class="built_in">tonumber</span>(redis.call(<span class="string">'GET'</span>,KEYS[<span class="number">1</span>]));</span><br><span class="line"><span class="keyword">local</span> key2 = <span class="built_in">tonumber</span>(redis.call(<span class="string">'GET'</span>,KEYS[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果key1 小于 key2返回0 nil相当于false</span></span><br><span class="line"><span class="keyword">if</span>(key1 == <span class="literal">nil</span> <span class="keyword">or</span> key == <span class="literal">nil</span> <span class="keyword">or</span> key1 &lt; key2)</span><br><span class="line">    <span class="keyword">then</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h5 id="nodejs加载lua脚本文件"><a href="#nodejs加载lua脚本文件" class="headerlink" title="nodejs加载lua脚本文件"></a>nodejs加载lua脚本文件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Redis = <span class="built_in">require</span>(<span class="string">'ioredis'</span>);</span><br><span class="line"><span class="keyword">const</span> redis = <span class="keyword">new</span> Redis(<span class="number">6379</span>,<span class="string">'127.0.0.1'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> redisLuaScript = fs.readFileSync(<span class="string">'./test.lua'</span>);</span><br><span class="line">    <span class="keyword">const</span> result1 = <span class="keyword">await</span> redis.eval(redisLuaScript,<span class="number">2</span>,<span class="string">'name1'</span>,<span class="string">'nam2'</span>,<span class="number">20</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">const</span> result2 = <span class="keyword">await</span> redis.eval(redisLuaScript,<span class="number">2</span>,<span class="string">'name1'</span>,<span class="string">'nam2'</span>,<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(result1,result2); <span class="comment">// 1 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><h3 id="实践3——Redis分布式锁"><a href="#实践3——Redis分布式锁" class="headerlink" title="实践3——Redis分布式锁"></a>实践3——Redis分布式锁</h3><p>线程锁：单线程编程模式下请求是顺序的，一个好处不需要考虑线程安全、资源竞争问题</p><p>进程锁：一个服务部署于一台服务器，同时开启多个进程，nodejs中为了利用操作系统资源，根据CPU的核心数可以开启多程模式，这个时候如果对于一个共享资源操作还是会遇到资源竞争的问题，另外每一个进程都是相互独立，拥有自己独立的内存空间，关于进程锁通过java的synchronized也很难解决，它仅局限在同一个JVM中有效</p><p>分布式锁：一个服务无论是单线程还是多进程模式，当多机部署、处于分布式环境下对统一共享资源进行操作还是会面临同样的问题。由于先读数据在通过业务逻辑修改之后进行SET操作，这并不是一个原子操作，当多个客户端对同一个资源进行先读后写操作就会引发并发问题，这个时候就需要分布式锁去解决。</p><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>实现分布式锁的方式：数据库、redis、zookeeper，通过redis来实现一个分布式锁，保持三个特性：安全性、死锁、容错</p><p>安全性：上锁，在任意时刻保持仅有一个客户端持有该锁</p><p>死锁：造成死锁可能是由于某种原因，本该释放的锁没有被释放，因此在上锁的时候可以同步设置过期时间，由于客户端自己的原因没有被释放，也要保证锁能够自动释放</p><p>容错：容错是在多节点的模式下需要考虑的，只要保证N/2+1节点可用，客户端就可以成功获取、释放锁</p><h4 id="Redis但实力分布式锁实现"><a href="#Redis但实力分布式锁实现" class="headerlink" title="Redis但实力分布式锁实现"></a>Redis但实力分布式锁实现</h4><p>在Redis的单节点实例下实现一个简单的分布式锁，会借助简单lua脚本来实现原子性</p><h5 id="上锁"><a href="#上锁" class="headerlink" title="上锁"></a>上锁</h5><p>通过setnx命令占坑，为了防止死锁，通常在占坑之后还会设置一个过期时间expire:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setnx key value</span><br><span class="line">expire key seconds</span><br></pre></td></tr></table></figure><p>上面的操作不是一个原子性操作，原子性操作是指命令在执行过程中并不会被其他线程或者请求打断，如果setnx执行成功之后，出现网络闪断expire命令便不会得到执行，会导致死锁出现。</p><p>通过：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value [EX seconds] [PX milliseconds] [NX|XX]</span><br></pre></td></tr></table></figure><h5 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h5><p>释放锁的过程是将原来占有的坑删除，加锁的过程把value设置为一个随机值，在del key之前先判断这个key存在且value等于自己制定的值才执行删除操作，判断和删除不是一个原子性操作，借助Lua脚本实现</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="Node实践"><a href="#Node实践" class="headerlink" title="Node实践"></a>Node实践</h4><h5 id="初始化自定义redisLock"><a href="#初始化自定义redisLock" class="headerlink" title="初始化自定义redisLock"></a>初始化自定义redisLock</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisLock</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化 RedisLock</span></span><br><span class="line"><span class="comment">   * @param &#123;*&#125; client</span></span><br><span class="line"><span class="comment">   * @param &#123;*&#125; option</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(client, options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!client) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'client 不存在'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (client.status !== <span class="string">'connecting'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'client 未正常链接'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.lockLeaseTime = options.lockLeaseTime || <span class="number">2</span>; <span class="comment">// 默认所过期时间 2 秒</span></span><br><span class="line">    <span class="keyword">this</span>.lockTimeout = options.lockTimeout || <span class="number">5</span>; <span class="comment">// 默认所过期时间 5 秒</span></span><br><span class="line">    <span class="keyword">this</span>.expireMode = options.expireMode || <span class="string">'EX'</span>;</span><br><span class="line">    <span class="keyword">this</span>.setMode = options.setMode || <span class="string">'NX'</span>;</span><br><span class="line">    <span class="keyword">this</span>.client = client;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 上锁，通过set 命令传入setnx/expire拓展参数，</span></span><br><span class="line"><span class="comment">   * 上锁成功返回，上锁失败进行重试，</span></span><br><span class="line"><span class="comment">   * 在lockTimeout 指定时间内仍未获取到锁，则获取锁失败</span></span><br><span class="line"><span class="comment">   * @param &#123;*&#125; key</span></span><br><span class="line"><span class="comment">   * @param &#123;*&#125; val</span></span><br><span class="line"><span class="comment">   * @param &#123;*&#125; expire</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">async</span> lock(key, val, expire) &#123;</span><br><span class="line">    <span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">intraneLock</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> self.client.set(key, val, self.expireMode, expire || self.lockLeaseTime, self.setMode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (result === <span class="string">'OK'</span>) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> <span class="subst">$&#123;val&#125;</span> 上锁成功`</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 锁超时</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.floor((<span class="built_in">Date</span>.now() - start) / <span class="number">1000</span>) &gt; self.lockLeaseTime) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> <span class="subst">$&#123;val&#125;</span> 上锁重试超时结束`</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环等待重试</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> <span class="subst">$&#123;val&#125;</span> 等待重试`</span>)</span><br><span class="line">        <span class="keyword">await</span> sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> <span class="subst">$&#123;val&#125;</span> 开始重试`</span>)</span><br><span class="line">        <span class="keyword">return</span> intraneLock();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 释放锁,通过redis.eval(script)执行自定义redis lua脚本</span></span><br><span class="line"><span class="comment">   * @param &#123;*&#125; key</span></span><br><span class="line"><span class="comment">   * @param &#123;*&#125; val</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">async</span> unLock(key, val) &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> script = <span class="string">`</span></span><br><span class="line"><span class="string">   if redis.call('get',KEYS[1] == ARGV[1]) then </span></span><br><span class="line"><span class="string">    return redis.call('del',KEYS[1])</span></span><br><span class="line"><span class="string">   else </span></span><br><span class="line"><span class="string">    return 0</span></span><br><span class="line"><span class="string">   end</span></span><br><span class="line"><span class="string">   `</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> self.client.eval(script, <span class="number">1</span>, key, val);</span><br><span class="line">      <span class="keyword">if</span> (result === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Redis = <span class="built_in">require</span>(<span class="string">'ioredis'</span>);</span><br><span class="line"><span class="keyword">const</span> redis = <span class="keyword">new</span> Redis(<span class="number">6379</span>, <span class="string">'127.0.0.1'</span>);</span><br><span class="line"><span class="keyword">const</span> uuidv1 = <span class="built_in">require</span>(<span class="string">'uuid/v1'</span>);</span><br><span class="line"><span class="keyword">const</span> RedisLock = <span class="built_in">require</span>(<span class="string">'./redisLock'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> redisLock = <span class="keyword">new</span> RedisLock(redis);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, time || <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = uuidv1();</span><br><span class="line">    <span class="keyword">await</span> redisLock.lock(key, id, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">await</span> sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> unLock = <span class="keyword">await</span> redisLock.unLock(key, id);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'unLock: '</span>, key, id, unlock);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'上锁失败'</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'name1'</span>);</span><br><span class="line">test(<span class="string">'name1'</span>)</span><br></pre></td></tr></table></figure><p>同时调用了两次test方法进行上锁，只有第一次是成功的，第二次name1 上锁的时候发现key=name1已被占坑，开始重试，由于以上的测试中设置了3秒之后自动释放，name1 在经过两次重试之后上锁成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name1 26e00260-0532-11ea-b978-2160dffafa30 上锁成功</span><br><span class="line">name1 26e02970-0532-11ea-b978-2160dffafa30 等待重试</span><br><span class="line">name1 26e02970-0532-11ea-b978-2160dffafa30 开始重试</span><br><span class="line">name1 26e02970-0532-11ea-b978-2160dffafa30 等待重试</span><br><span class="line">unLock:  name1 26e00260-0532-11ea-b978-2160dffafa30 true</span><br><span class="line">name1 26e02970-0532-11ea-b978-2160dffafa30 开始重试</span><br><span class="line">name1 26e02970-0532-11ea-b978-2160dffafa30 上锁成功</span><br><span class="line">unLock:  name1 26e02970-0532-11ea-b978-2160dffafa30 true</span><br></pre></td></tr></table></figure><h5 id="Redlock算法"><a href="#Redlock算法" class="headerlink" title="Redlock算法"></a>Redlock算法</h5><p>在Sentinel/Redis Cluster下，如果客户端A在主节点获取到锁之后，主节点还未来得及同步信息到从节点就挂掉了，这时候Sentinel 会选举另外一个从节点作为主节点，那么客户端B此时也申请相同的锁，就会出现同一个锁被多个客户端持有，对数据的最终一致性有很高的要求还不行。</p><p>鉴于这些问题，官方提供了一个使用Redis实现分布式锁的规范算法Redlock，在单实例或者多实例提供强有力的保障，本身具备容错能力，会从N个实例使用相同的key、随机值尝试<code>set ket value [EX seconds] [PX milliseconds] [NX|XX]</code>命令去获取所，在有效时间内至少 <code>N/2+1</code>个Redis实例取到所，否则取锁失败，失败情况下客户端应该在所有Redis实例上进行解锁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Redis = <span class="built_in">require</span>(<span class="string">'ioredis'</span>);</span><br><span class="line"><span class="keyword">const</span> client1 = <span class="keyword">new</span> Redis(<span class="number">6379</span>, <span class="string">'127.0.0.1'</span>);</span><br><span class="line"><span class="keyword">const</span> RedLock = <span class="built_in">require</span>(<span class="string">'redlock'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> redlock = <span class="keyword">new</span> RedLock([client1], &#123;</span><br><span class="line">  retryDelay: <span class="number">200</span>, <span class="comment">// time in ms</span></span><br><span class="line">  retryCount: <span class="number">5</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个Redis 实例</span></span><br><span class="line"><span class="comment">// const redlock = new RedLock(</span></span><br><span class="line"><span class="comment">//   [new Redis(6379, '127.0.0.1')],</span></span><br><span class="line"><span class="comment">//   [new Redis(6379, '127.0.0.2')],</span></span><br><span class="line"><span class="comment">//   [new Redis(6379, '127.0.0.3')]</span></span><br><span class="line"><span class="comment">// )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">key, ttl, client</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> loclk = <span class="keyword">await</span> redlock.lock(key, ttl);</span><br><span class="line">    <span class="built_in">console</span>.log(client, lock, value)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(client, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'name1'</span>, <span class="number">10000</span>, <span class="string">'client1'</span>);</span><br><span class="line">test(<span class="string">'name1'</span>, <span class="number">10000</span>, <span class="string">'client2'</span>);</span><br></pre></td></tr></table></figure><p>对同一个key name1 两次上锁，由于client1 先取到了锁，client2 无法获取锁，重试5次之后报错：<code>LockError:Exceeded 5 attempts to lock the resource &#39;name1&#39;</code></p><h2 id="如何让秒杀、活动倒计时更加精确"><a href="#如何让秒杀、活动倒计时更加精确" class="headerlink" title="如何让秒杀、活动倒计时更加精确"></a>如何让秒杀、活动倒计时更加精确</h2><p>分析一下从获取服务器时间到前端显示倒计时的过程：</p><ol><li>客户端http请求服务器时间</li><li>服务器响应完成</li><li>服务器通过网络传输时间到客户端</li><li>客户端根据活动开始时间和服务器时间差做倒计时显示</li></ol><p>服务器响应完成的时间就是服务器时间，但是经过网络传输就会有误差，由网络环境决定误差大小，一般是几十ms或者几百ms。</p><p>可得出：<code>当前服务器时间=服务器系统返回时间+网络传输时间+前端渲染时间+常量（可选）</code></p><p>前端渲染时间，避免不同浏览器渲染快慢差异差异造成明显的时间不同步，可以在服务器返回当前时间和本地签单的时间的差值得出</p><p>获得服务器时间后，前端进入倒计时计算和计时器显示，要考虑js代码和线程阻塞造成计时器延时问题，思路是通过引入计数器，判断计时器延迟执行的时间来调整，尽量让误差缩小，不同浏览器不同时间段打开页面倒计时误差可控制在1s以内</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程占用</span></span><br><span class="line">setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j++ <span class="xml"><span class="tag">&lt; <span class="attr">100000000</span>);</span></span></span><br><span class="line"><span class="xml">&#125;,0)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 倒计时</span></span><br><span class="line"><span class="xml">let interval = 1000,</span></span><br><span class="line"><span class="xml">    ms = 50000, //从服务器和活动开始时间计算出的时间差，测试用50000ms</span></span><br><span class="line"><span class="xml">    count=0,</span></span><br><span class="line"><span class="xml">    startTime = new Date().getTime(),</span></span><br><span class="line"><span class="xml">    timeCounter = null;</span></span><br><span class="line"><span class="xml">if(ms &gt;=0)&#123;</span></span><br><span class="line"><span class="xml">    timeCounter = setTimeout(countDownStart,interval)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">function countDownStart()&#123;</span></span><br><span class="line"><span class="xml">    count++;</span></span><br><span class="line"><span class="xml">    const offset = new Date().getTime() - (startTime+count*interval);</span></span><br><span class="line"><span class="xml">    let nextTime = interval -offset;</span></span><br><span class="line"><span class="xml">    const daytohour = 0;</span></span><br><span class="line"><span class="xml">    if(nextTime <span class="tag">&lt; <span class="attr">0</span>)&#123;</span></span></span><br><span class="line"><span class="xml">        nextTime = 0;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    ms-=interval;</span></span><br><span class="line"><span class="xml">    console.log(`误差：$&#123;offset&#125;ms,下一次执行：$&#123;nextTime&#125;ms后，离活动结束还有：$&#123;ms&#125;ms`)</span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    if(ms <span class="tag">&lt; <span class="attr">0</span>)&#123;</span></span></span><br><span class="line"><span class="xml">        clearTimer(timeCount)</span></span><br><span class="line"><span class="xml">    &#125;else&#123;</span></span><br><span class="line"><span class="xml">        timeCounter = setTimeout(countDownStart,nextTime),</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NodeJS&quot;&gt;&lt;a href=&quot;#NodeJS&quot; class=&quot;headerlink&quot; title=&quot;NodeJS&quot;&gt;&lt;/a&gt;NodeJS&lt;/h1&gt;&lt;h2 id=&quot;模块与文件&quot;&gt;&lt;a href=&quot;#模块与文件&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="NodeJs" scheme="http://laibh.top/categories/NodeJs/"/>
    
    
      <category term="NodeJs" scheme="http://laibh.top/tags/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title>珠峰架构-函数</title>
    <link href="http://laibh.top/2019-12-07-%E7%8F%A0%E5%B3%B0%E6%9E%B6%E6%9E%84-Day1.html"/>
    <id>http://laibh.top/2019-12-07-珠峰架构-Day1.html</id>
    <published>2019-12-07T04:00:00.000Z</published>
    <updated>2022-03-04T10:00:38.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="珠峰架构-函数"><a href="#珠峰架构-函数" class="headerlink" title="珠峰架构-函数"></a>珠峰架构-函数</h1><p>知识点：</p><p><code>高阶函数，解决异步问题</code>、<code>发布订阅模式和观察者模式</code>、<code>promise核心应用，promise解决异步问题</code>、<code>实现一个完成的promise库</code>、<code>promise中常见的面试题</code>、<code>扩展promise中常见的方法</code>、<code>掌握 generator的使用以及co库的应用</code>、<code>异步方案 async+await</code></p><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="AOP-面向切片编程"><a href="#AOP-面向切片编程" class="headerlink" title="AOP 面向切片编程"></a>AOP 面向切片编程</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高阶函数 函数参数如果是函数，或者这个函数返回一个新的函数，我们就叫它高阶函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AOP 面向切片编程</span></span><br><span class="line"><span class="comment">// before函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(who + <span class="string">' hello'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforeFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    beforeFn();</span><br><span class="line">    <span class="keyword">this</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">afterFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>(...args);</span><br><span class="line">    afterFn();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> beforeSay = say.before(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'开始说话'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> afterSay = beforeSay.after(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'结束说话'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">afterSay(<span class="string">'laibh.top'</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">开始说话</span></span><br><span class="line"><span class="comment">laibh.top hello</span></span><br><span class="line"><span class="comment">结束说话</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="React事务简单模拟"><a href="#React事务简单模拟" class="headerlink" title="React事务简单模拟"></a>React事务简单模拟</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">  perform(anyMethod, wrappers) &#123;</span><br><span class="line">    wrappers.forEach(<span class="function"><span class="params">wrapper</span> =&gt;</span> wrapper.initialize())</span><br><span class="line">    anyMethod();</span><br><span class="line">    wrappers.forEach(<span class="function"><span class="params">wrapper</span> =&gt;</span> wrapper.close())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> transaction = <span class="keyword">new</span> Transaction()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oldFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'原有的逻辑'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">transaction.perform(oldFunc, [</span><br><span class="line">  &#123; <span class="comment">// wrapper1</span></span><br><span class="line">    initialize() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'初始化1'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    close() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'关闭1'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="comment">// wrapper2</span></span><br><span class="line">    initialize() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'初始化2'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    close() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'关闭2'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">初始化1</span></span><br><span class="line"><span class="comment">初始化2</span></span><br><span class="line"><span class="comment">原有的逻辑</span></span><br><span class="line"><span class="comment">关闭1</span></span><br><span class="line"><span class="comment">关闭2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="判断类型"><a href="#判断类型" class="headerlink" title="判断类型"></a>判断类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typeof instaceof constructor Object.prototype.toString.call</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isType</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">args</span>) =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(args) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> types = [<span class="string">'String'</span>, <span class="string">'Boolean'</span>, <span class="string">'Number'</span>, <span class="string">'Null'</span>, <span class="string">'Undefined'</span>, <span class="string">'Symbol'</span>, <span class="string">'Object'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> utils = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> type = types[i]</span><br><span class="line">  utils[<span class="string">`is<span class="subst">$&#123;type&#125;</span>`</span>] = isType(type)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(utils.isSymbol(<span class="built_in">Symbol</span>()))</span><br></pre></td></tr></table></figure><h3 id="异步并发-lodash-after"><a href="#异步并发-lodash-after" class="headerlink" title="异步并发 lodash after"></a>异步并发 lodash after</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lodash after 在执行多少次之后</span></span><br><span class="line"><span class="comment">// 做异步的并发处理</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">after</span>(<span class="params">times, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (--times == <span class="number">0</span>) &#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = after(<span class="number">3</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'执行三次后才执行'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fn()</span><br><span class="line">fn()</span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="comment">// node 方法异步的 I/O</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> after = <span class="function">(<span class="params">times, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> website = &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">key, value</span>) =&gt;</span> &#123;</span><br><span class="line">    website[key] = value</span><br><span class="line">    <span class="keyword">if</span> (--times === <span class="number">0</span>) &#123;</span><br><span class="line">      callback(website)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> out = after(<span class="number">2</span>, (website) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(website)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./name.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  out(<span class="string">'name'</span>, data)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./age.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  out(<span class="string">'age'</span>, data)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="发布订阅模式和观察者模式"><a href="#发布订阅模式和观察者模式" class="headerlink" title="发布订阅模式和观察者模式"></a>发布订阅模式和观察者模式</h2><h3 id="发布订阅解决异步"><a href="#发布订阅解决异步" class="headerlink" title="发布订阅解决异步"></a>发布订阅解决异步</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node 方法异步的 I/O</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希望两次都完成后，分别打印最终结果，再打印一次已经处理完毕的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布emit 订阅 on 一种一对多的关系 [fn,fn,fn]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Events</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = []</span><br><span class="line">  &#125;</span><br><span class="line">  on(callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack.push(callback)</span><br><span class="line">  &#125;</span><br><span class="line">  emit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> events = <span class="keyword">new</span> Events();</span><br><span class="line"><span class="keyword">let</span> website = &#123;&#125;;</span><br><span class="line">events.on(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(website).length === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(website)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'当前获取完毕'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./name.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  website.name = data</span><br><span class="line">  events.emit();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./age.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  website.age = data</span><br><span class="line">  events.emit();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="观察者模式简单模拟"><a href="#观察者模式简单模拟" class="headerlink" title="观察者模式简单模拟"></a>观察者模式简单模拟</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察者模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123; <span class="comment">// 被观察者</span></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = [];</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'happy'</span></span><br><span class="line">  &#125;</span><br><span class="line">  attach(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack.push(observer)</span><br><span class="line">  &#125;</span><br><span class="line">  setState(newState) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = newState</span><br><span class="line">    <span class="keyword">this</span>.stack.forEach(<span class="function"><span class="params">p</span> =&gt;</span> p.update(newState))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123; <span class="comment">// 观察者</span></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  update(newState) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>,小宝宝<span class="subst">$&#123;newState&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Observer(<span class="string">'爸爸'</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Observer(<span class="string">'妈妈'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Subject(<span class="string">'小宝宝'</span>)</span><br><span class="line">c.attach(p1)</span><br><span class="line">c.attach(p2)</span><br><span class="line">c.setState(<span class="string">'unhappy'</span>)</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;珠峰架构-函数&quot;&gt;&lt;a href=&quot;#珠峰架构-函数&quot; class=&quot;headerlink&quot; title=&quot;珠峰架构-函数&quot;&gt;&lt;/a&gt;珠峰架构-函数&lt;/h1&gt;&lt;p&gt;知识点：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高阶函数，解决异步问题&lt;/code&gt;、&lt;code&gt;发布订阅模式和
      
    
    </summary>
    
      <category term="珠峰架构" scheme="http://laibh.top/categories/%E7%8F%A0%E5%B3%B0%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="珠峰架构" scheme="http://laibh.top/tags/%E7%8F%A0%E5%B3%B0%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>react hook实践</title>
    <link href="http://laibh.top/2019-10-26-react%20hook%E5%AE%9E%E8%B7%B5.html"/>
    <id>http://laibh.top/2019-10-26-react hook实践.html</id>
    <published>2019-10-26T04:00:00.000Z</published>
    <updated>2022-03-04T10:00:38.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react-hook实践"><a href="#react-hook实践" class="headerlink" title="react hook实践"></a>react hook实践</h1><p>又到了跟着文档码字学习的阶段，<code>hook</code>从提案到现在已经很久了。在这之前但是还没有真正地去了解这个 react 新玩具。跟随<a href="https://react.docschina.org/docs/hooks-intro.html#gradual-adoption-strategy">文档</a>学习，并尝试重构一些项目</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>官方自带的视频已经很好地介绍了 <code>hook</code></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Hook 是 React.16.8 新增特征，可以让你在不编写 class的情况下使用 state 以及其他 React 特性</p><h3 id="State-Hook"><a href="#State-Hook" class="headerlink" title="State Hook"></a><code>State Hook</code></h3><p>简单的示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count,setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;setCount(count+1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">                Click me</span></span><br><span class="line"><span class="regexp">            &lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>通过在函数组件里调用它来给组件添加一些内部的 <code>state</code>，React 会在渲染的时候保留这个 <code>state</code>。<code>useState</code>会返回一堆值：当前值和一个让你更新它的函数，可以在时间处理函数中或者其他一些地方调用这个函数。类似 <code>class</code>组件的 <code>this.setState</code>，但是它不会把新的 <code>state</code>和旧的 <code>state</code>进行合并。</p><p><code>useState</code> 唯一的参数就是初始的<code>state</code>。上面的例子中，计数器从零开始的，所有初始 <code>state</code>就是0。注意不同于 <code>this.state</code>，这里的 <code>state</code>不一定要是一个对象。</p><h4 id="声明多个变量"><a href="#声明多个变量" class="headerlink" title="声明多个变量"></a>声明多个变量</h4><p>在一个组件中声明多个变量</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExampleWithManyStates</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [age,setAge] = useState(<span class="number">42</span>)</span><br><span class="line">    <span class="keyword">const</span> [fruit,setFruit] = useState(<span class="string">'banana'</span>)</span><br><span class="line">    <span class="keyword">const</span> [todos,setTodos] = useState(&#123;<span class="attr">text</span>:<span class="string">'Learn Hooks'</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Hook"><a href="#Hook" class="headerlink" title="Hook?"></a>Hook?</h4><p>Hook 是一些可以让你在函数组件里 钩入 <code>React state</code>以及生命周期函数等特性的函数。Hook 不能在 class 组件中使用。使得不用 class 也可以使用 React.</p><h3 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a><code>Effect Hook</code></h3><p>React 组件中数据获取、订阅或者手动修改 DOM,都统称为副作用，或者称为作用</p><p><code>useEffect</code>就是 Effect Hook，给函数组件增加了操作副作用的能力，跟 class 组件的 <code>componentDid</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code>具有相同的用途，只不过被合并成了一个AOU</p><p>例子，在 React 更新 DOM 后设置一个页面的标题</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 相当于 componentDidMount 和 componentDidUpdate</span></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`laibh.top you check <span class="subst">$&#123;count&#125;</span> times`</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You click &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;setCount(count+1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">                Click me</span></span><br><span class="line"><span class="regexp">            &lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>当调用 <code>useEffect</code>，就是在告诉 React 在完成对 DOM 的更改后运行副作用函数，由于副作用函数是在组件内声明的，所有可以访问到组件的 <code>props</code>或者 <code>state</code>。默认情况下，React 会在每次渲染后调用副作用函数——包括第一次渲染的时候</p><p>副作用函数还可以通过返回一个函数来指定清除副作用。例如，在下面的组件中使用副作用函数来订阅好友的在线状态，并通过取消订阅来进行清除操作：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState,useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [isOnline,setIsOnline] = useState(<span class="literal">null</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">        setIsOnline(status.isOnline)</span><br><span class="line">    &#125;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        ChatAPI.subscribeToFrinedStatus(props.friend.id,handleStatusChange)</span><br><span class="line">        <span class="keyword">return</span><span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            ChatAPI.unsubscribeFromFriendStatus(props.friend.id,handleStatusChange)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span>(isOnline === <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Loading ...'</span>   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实例中，React会在组件销毁或者后续渲染时重新执行副作用函数，取消对 <code>ChatAPI</code>的订阅。</p><p>跟 <code>useState</code>一样，可以在组件中多次使用 <code>useEffect</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatusWithCounter</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count,setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> [isOnline,setIsOnline] = useState(<span class="literal">null</span>)</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        ChatAPI.subscribeToFriendStatus(props.friend.id,handleStatusChange)</span><br><span class="line">        <span class="keyword">return</span><span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            ChatAPI.subscribeFromFriendStatus(props.friend.id,handleStatusChange)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">        setIsOnline(status.isOnline)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用 Hook,可以把组件内相关的副作用组织在一起（例如创建订阅以及及时取消），而不要把它们拆分到不同的生命周期函数</p><h3 id="Hook使用规则"><a href="#Hook使用规则" class="headerlink" title="Hook使用规则"></a><code>Hook</code>使用规则</h3><p>Hook 就是 javascript 函数，但是使用它们会有两个额外的规则：</p><p>只能在函数最外层调用Hook。不要在循环、条件判断或者子函数中调用</p><p>只能在React 的函数组件中调用Hook。</p><h3 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 <code>Hook</code></h3><p>在之前，组件之间复用一些状态逻辑，有两种主流方案：高阶组件、<code>render props</code>。自定义 <code>Hook</code>可以在不增加组件的情况下达到相同的目的</p><p><code>FriendStatus</code>组件，通过调用 <code>useState</code>和 <code>useEffect</code>的 Hook 来订阅一个好友的在线状态，假设我们想在另一个组件里复用这个订阅逻辑</p><p>首先，把逻辑提取到一个叫做 <code>useFriendStatus</code>的自定义 <code>Hook</code>里：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState,useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriendStatus</span>(<span class="params">friendID</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [isOnline,setIsOnline] = useState(<span class="literal">null</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">        setIsOnline(status.isOnline)</span><br><span class="line">    &#125;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        ChatAPI.subscribeToFriendStatus(friendID,handleStatusChange)</span><br><span class="line">        <span class="keyword">return</span><span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            ChatAPI.unsubscribeFromFriendStatus(friendID,handleStatusChange)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> isOnline</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它将 <code>friendID</code>作为参数，并返回该好友是否在线，我们可以在两个组件中用到它：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isOnline = useFriendStatus(props.friend.id)</span><br><span class="line">    <span class="keyword">if</span>(isOnline === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Loading'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendListItem</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isOnlie = useFriendStatus(props.friend.id)</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;li style=&#123;&#123;<span class="attr">color</span>:isOnline?<span class="string">'green'</span>:<span class="string">'black'</span>&#125;&#125;&gt;</span><br><span class="line">            &#123;props.friend.name&#125;</span><br><span class="line">        &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>两个组件中的 state 是完全独立的。Hook 是一种复用状态逻辑的方式，不复用 state 本身，事实上，Hook 每次调用都有一个完全独立的 state,因此可以在单个组件中多次调用同一个自定义 Hook</p><h3 id="其他Hook"><a href="#其他Hook" class="headerlink" title="其他Hook"></a>其他<code>Hook</code></h3><p>还有一些使用频率较低的但很有用的 <code>Hook</code>，比如使用 <code>useContext</code>可以不使用组件嵌套订阅 React 的 Context</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> locale = useContext(localeContext)</span><br><span class="line">    <span class="keyword">const</span> theme = useContext(ThemeContext)</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// useReducer 通过 reducer 来管理组件本地复杂的 state</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Todos</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [todos,dispatch] = useReducer(todosReducer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-State-Hook"><a href="#使用-State-Hook" class="headerlink" title="使用 State Hook"></a>使用 <code>State Hook</code></h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class 示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="comment">// 1. 构造函数中设置来初始化 count</span></span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            count:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;p&gt;You click &#123;<span class="keyword">this</span>.state.count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;()=&gt;this.setState(&#123;count:this.state.count+1&#125;)&#125;&gt;</span></span><br><span class="line"><span class="regexp">                    Click me</span></span><br><span class="line"><span class="regexp">                &lt;/</span>button&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ hook示例</span></span><br><span class="line"><span class="regexp">import React,&#123;useState&#125; from 'react'</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Example()&#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 1. 函数组件中没有this,不能分配或者读取this.state,直接调用 useState</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 2. useState定义了一个 state变量。需要为一个参数初始state，参数可以是数字字符串或者对象。返回值为当前state以及更新state的函数。</span></span><br><span class="line"><span class="regexp">    const [count,setCount] = useState(0)</span></span><br><span class="line"><span class="regexp">    return(</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;p&gt;You click &#123;count&#125; times&lt;/</span>p&gt;</span><br><span class="line">            &lt;button onClick=&#123;()=&gt;setCount(count+<span class="number">1</span>)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Hook和函数组件"><a href="#Hook和函数组件" class="headerlink" title="Hook和函数组件"></a><code>Hook</code>和函数组件</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Example = <span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 在这里可以使用 Hook</span></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span>    </span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">function Example(props)&#123;</span></span><br><span class="line"><span class="xml">    // 这里可以使用 Hook</span></span><br><span class="line"><span class="xml">    return <span class="tag">&lt;<span class="name">div</span> /&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>Hook 在 class 内部是不起作用的，可以使用来替代 class</p><h2 id="使用-Effect-Hook"><a href="#使用-Effect-Hook" class="headerlink" title="使用 Effect Hook"></a>使用 <code>Effect Hook</code></h2><p><code>Effect Hook</code>可以让你在函数组件中执行副作用操作</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState,useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count,setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类似于 componentDidMount 和 componentDidUpdate、componentWillUnmount</span></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 用浏览器的api更新文档标题</span></span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;setCount(count+1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">                Click me</span></span><br><span class="line"><span class="regexp">            &lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>数据获取，设置订阅以及手动更改 React 组件中的 DOM 都属于副作用。在 React 组件中有两种常见副作用操作：需要清除的和不需要清除的。</p><h3 id="无需清除的-effect"><a href="#无需清除的-effect" class="headerlink" title="无需清除的 effect"></a>无需清除的 effect</h3><p>有时候，我们只想在 React 更新DOM 之后运行一些额外的代码，比如网络请求、手动变更 DOM,记录日志，这些都是常见的无需清除的操作。因为我们在执行完这些操作之后，就可以忽略他们了。</p><h4 id="使用class"><a href="#使用class" class="headerlink" title="使用class"></a>使用class</h4><p>在 React 的 class 组件中，<code>render</code>函数是不应该有任何副作用的，一般来说，在这里执行操作太早了，我们都希望在 React 更新 DOM 之后才执行我们的操作</p><p>这也是为什么把副作用放在 <code>componentDidMount</code>和<code>componentDidUpdate</code>函数中。</p><p>下面的示例，React 计数器的 class 组件，在 React 对 DOM 进行操作后，立即更新了 document 的 title 属性</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            count:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span> times`</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    componentDidUpdate()&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span> times`</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;p&gt;You clicked &#123;<span class="keyword">this</span>.state.count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;()=&gt;this.setState(&#123;count:this.state.count+1&#125;)&#125;&gt;</span></span><br><span class="line"><span class="regexp">                    Click me </span></span><br><span class="line"><span class="regexp">                &lt;/</span>button&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 在 class 中，我们需要在两个声明周期函数中编写重复代码，很多情况下，我们希望在组件加载和更新时执行同样的操作。从概念上，我们希望每次渲染后执行-但是React的class组件没有提供这样的方法，即使我们提取出来，还是要在两个地方调用它</span></span><br></pre></td></tr></table></figure><h4 id="使用hook"><a href="#使用hook" class="headerlink" title="使用hook"></a>使用hook</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState,useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count,setCount] = useState(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You click <span class="subst">$&#123;count&#125;</span> times`</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You click &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;setCount(count+1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">                Click me</span></span><br><span class="line"><span class="regexp">            &lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 1. useEffect 告诉React 组件需要在渲染后执行某些操作。会保存传递的函数，并且在执行 DOM更新之后调用它。在这个 effect 中，我们设置了 document 的 title 属性，不过我们也可以执行数据获取或者调用其他命令的 API</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 2. 将 useEffect 放在组件内部让我们可以在 effect 中直接访问 count state 变量或者其他 props.我们不需要特殊的API来读取它，它已经保存在函数作用域中。Hook 使用了 js的闭包机制，而不用在js已经提供了解决方案的情况下，还引入特定的React API</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 3. useEffect会在每次渲染后都执行，默认情况下，它在第一次渲染之后和每次更新之后都会执行，不用去考虑挂载还是更新，React保证了每次运行 effect的同时，DOM都已经更新完毕了</span></span><br></pre></td></tr></table></figure><p>与 componentDidMount 和 componentDidUpdate不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，让应用看起来响应很快。大多数情况下，effect不需要同步地执行，在个别情况下（例如测试布局），有单独的 useLayoutEffect Hook 使用</p><h3 id="需要清除的-effect"><a href="#需要清除的-effect" class="headerlink" title="需要清除的 effect"></a>需要清除的 effect</h3><p>订阅外部数据源等一些副作用是需要清除的，可以防止内存泄露。</p><h4 id="使用class-1"><a href="#使用class-1" class="headerlink" title="使用class"></a>使用class</h4><p>通常会在 <code>componentDidMount</code>中设置订阅，在 <code>componentWillMount</code>中清除它。假设我们有一个 <code>ChatApI</code>模块，运行我们订阅好友的在线状态</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FriendStatus</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            isOnline:<span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.handleStatusChange = <span class="keyword">this</span>.handleStatusChange.bind(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        ChatAPI.subsribeToFriendStatus(</span><br><span class="line">            <span class="keyword">this</span>.props.friend.id,</span><br><span class="line">            <span class="keyword">this</span>.handleStatusChange</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        ChatAPI.unsubsribeToFriendStatue(</span><br><span class="line">            <span class="keyword">this</span>.props.friend.id,</span><br><span class="line">            <span class="keyword">this</span>.handleStatusChange</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    handleStatusChange(status)&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            isOnline:status.isOnline</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state.isOnline === <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Loading...'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.state.isOnline ? <span class="string">'ONline'</span> : <span class="string">'Offline'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用hook-1"><a href="#使用hook-1" class="headerlink" title="使用hook"></a>使用hook</h4><p>useEffect 设计在同一个地方执行添加和删除订阅，effect返回一个函数，React就会在指定清除的时候调用它</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState,useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [isOnline,setIsOnline] = useState(<span class="literal">null</span>)</span><br><span class="line">    </span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">            setIsOnline(status.isOnline)</span><br><span class="line">        &#125;</span><br><span class="line">        ChatAPI.subscribeToFriendStatus(props.friend.id,handleStatusChange)</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">cleanup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            ChatAPI.unsubscribeFromFriendStatus(props.friend.id,handleStatuChange)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(isOnline === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Loading...'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. effect返回一个函数，这是 effect 可选的清除机制，每个 effect 都可以返回一个清除函数。所以可以将添加和订阅的逻辑放在一起，都属于 effect的一部分</span></span><br><span class="line"><span class="comment">// 2. React 会在组件卸载的时候执行清除操作，effect在每次渲染的时候都会执行。这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除</span></span><br><span class="line"><span class="comment">// 3.并不是必须为 effect 返回的函数命名，上面命令是为了表明此函数的目的，可以返回一个箭头函数或者另一个名字</span></span><br></pre></td></tr></table></figure><h3 id="使用多个Effect-实现关注点分离"><a href="#使用多个Effect-实现关注点分离" class="headerlink" title="使用多个Effect 实现关注点分离"></a>使用多个Effect 实现关注点分离</h3><p>使用hook其中一个目的就是要解决class 中声明周期函数经常包含不相关的逻辑，但又把相关逻辑分离到了几个不同方法中的问题。上面代码是示例中计数器和好友状态指示器逻辑组合在一起的组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FriendStatusWithCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            count:<span class="number">0</span>,</span><br><span class="line">            isOnline:<span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.handleStatusChange = <span class="keyword">this</span>.handleStatusChange.bind(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You click <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span> times`</span></span><br><span class="line">        ChatAPI.subscribeToFriendStatus(</span><br><span class="line">            <span class="keyword">this</span>.props.friend.id,</span><br><span class="line">            <span class="keyword">this</span>.handleStatusChange</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidUpdate()&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You click <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span> times`</span></span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">        ChatAPI.unsubscibeFromFriendStatus(</span><br><span class="line">            <span class="keyword">this</span>.props.friend.id,</span><br><span class="line">            <span class="keyword">this</span>.handleStatusChange            </span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    handleStatusChange(status)&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            isOnline:status.inOnline</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以发现设置 documnet.title 的逻辑是如何被分割到 componentDidMount 和 componentDidUpdate中。订阅逻辑是被分割到 componentDidMount 和 componentWillUnmount 中。而且 componentDidMount 中包含了两个不同功能的代码</span></span><br></pre></td></tr></table></figure><p>而使用 hook,跟使用多个 state 的 hook一样，可以使用多个 effect将不相关逻辑分离到不同的 effect中</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatusWithCounter</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count,setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> [isOnline,setIsOnline] = useState(<span class="literal">null</span>)</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">            setIsOnline(status.isOnline)</span><br><span class="line">        &#125;</span><br><span class="line">        ChatAPI.subscribeToFriendStatus(props.friend.id,handleStatusChange)</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            ChatAPI.unsubcribeFromFriendStatus(props.friend.id,handleStatusChange)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hook 允许我们按照代码的用途分离他们，而不是像生命周期函数那样，React 将按照 effect 声明的顺序依次调用组件中的每一个 effect</span></span><br></pre></td></tr></table></figure><h3 id="为什么每次更新的时候都要运行effect"><a href="#为什么每次更新的时候都要运行effect" class="headerlink" title="为什么每次更新的时候都要运行effect"></a>为什么每次更新的时候都要运行effect</h3><p>为什么 effect 在每次重渲染都会执行，而不是在卸载组件的时候执行一次。</p><p>上述用于显示好友是否在线的 FriendStatus 组件，从 class 中 props 读取 friend.id，然后在组件挂载后订阅好友状态，并在卸载组件的时候取消订阅</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(</span><br><span class="line">      <span class="keyword">this</span>.props.friend.id,</span><br><span class="line">      <span class="keyword">this</span>.handleStatusChange</span><br><span class="line">    );        </span><br><span class="line">&#125;</span><br><span class="line">componentWillUnmount()&#123;</span><br><span class="line">    ChatAPI.unsubscribeFromFriendStatus(</span><br><span class="line">      <span class="keyword">this</span>.props.friend.id,</span><br><span class="line">      <span class="keyword">this</span>.handleStatusChange</span><br><span class="line">    );    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里会有一个问题，当组件已经显示在屏幕上时，friend props发生变化，我们的组件将继续展示原来的好友状态，这是一个 bug,而且我们还会因为取消订阅时错误使用错误的好友 ID,导致内存泄露或者奔溃的问题</span></span><br><span class="line"><span class="comment">// 所以通过添加 componentDidUpdate 来解决这个问题</span></span><br><span class="line">componentDidUpdate(prevProps)&#123;</span><br><span class="line">    <span class="comment">// 取消之前的订阅的 friend.id</span></span><br><span class="line">    ChatAPI.unsubscibeFromFriendStatus(</span><br><span class="line">        prevProps.friend.id,</span><br><span class="line">        <span class="keyword">this</span>.handleStatusChange</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 订阅新的 friend.id</span></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(</span><br><span class="line">        <span class="keyword">this</span>.props.friend.id,</span><br><span class="line">        <span class="keyword">this</span>.handleStatusChange</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hook版本</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        ChatAPI.subscribeToFriendStatus(props.friend.id,handleStatusChange)</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            ChatAPI.unsubscibeFromFriendStatus(props.friend.id,handleStatusChange)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要特定的代码来处理更新逻辑，useEffect默认就会处理。它会在调用一个新的 effect 之前对前一个 effect 进行清理。下面按时间列出一个可能会产生的订阅和取消订阅调用序列</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mount with &#123;friend:&#123;id:100&#125;&#125; props</span></span><br><span class="line">ChatAPI.subscibeToFriendStatus(<span class="number">100</span>,handleStatusChange) <span class="comment">// 运行第一个 effect</span></span><br><span class="line"><span class="comment">// Mount with &#123;friend:&#123;id:200&#125;&#125; props</span></span><br><span class="line">ChatAPI.unsubscribeFromFriendStatus(<span class="number">100</span>,handleStatusChange) <span class="comment">// 清除上一个 effect</span></span><br><span class="line">ChatAPI.subscibeToFriendStatus(<span class="number">200</span>,handleStatusChange) <span class="comment">// 运行下一个 effect</span></span><br><span class="line"><span class="comment">// Mount with &#123;friend:&#123;id:300&#125;&#125; props</span></span><br><span class="line">ChatAPI.unsubscribeFromFriendStatus(<span class="number">200</span>,handleStatusChange) <span class="comment">// 清除上一个 effect</span></span><br><span class="line">ChatAPI.subscibeToFriendStatus(<span class="number">300</span>,handleStatusChange) <span class="comment">// 运行下一个 effect</span></span><br><span class="line"><span class="comment">// unMount</span></span><br><span class="line">ChatAPI.unsubscribeFromFriendStatus(<span class="number">300</span>,handleStatusChange) <span class="comment">// 清除上一个 effect</span></span><br></pre></td></tr></table></figure><p>默认行为保证了一致性，避免了在 class 组件因为没有处理更新逻辑而导致常见 bug</p><h3 id="通过跳过-effect-进行性能优化"><a href="#通过跳过-effect-进行性能优化" class="headerlink" title="通过跳过 effect 进行性能优化"></a>通过跳过 effect 进行性能优化</h3><p>在某些情况下，每次渲染后都会执行清理或者执行 effect 可能会导致性能问题。在 class 组件中，可以通过 componentDidUpate 中添加 prevProps 或者 prevState 的比较逻辑解决：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps,prevState)&#123;</span><br><span class="line">    <span class="keyword">if</span>(prevState.count !== <span class="keyword">this</span>.state.count)&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span> times`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是很常见的需求，被内置到了 useEffect 的 hook api中，如果某些特定值在两次重渲染中没有发生变化，可以通过 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个参数即可：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span></span><br><span class="line">&#125;,[count]) <span class="comment">// 仅在 count 更改的时候更新</span></span><br><span class="line"><span class="comment">// 对于有清除操作的 effect同样适用</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">        setIsOnline(status.isOnline)</span><br><span class="line">    &#125;</span><br><span class="line">    ChatAPI.subscibeToFriendStatus(props.friend.id,handleStatusChange)</span><br><span class="line">    <span class="keyword">return</span><span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        ChatAPI.unsubscibeFromFriendStatus(props.friend.id,handleStatusChange)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,[props.friend.id]) <span class="comment">// 仅在 props.friend.id 发生变化时，重新订阅</span></span><br></pre></td></tr></table></figure><p>注意：</p><p>如果要使用这种优化方法，确保数组中包含了所有外部作用域中会随着时间变化并且在 effect 中使用的变量，否则代码会引用到先前渲染中的旧变量。</p><p>如果想只执行一次 effect 仅在组件挂载或者卸载时执行，可以传递一个空数组（[]），作为第二个参数，告诉 React 的 effect 不依赖于props 或者 state 中的任何值，所以它永远都不需要被重复执行，这不属于特殊情况，依然遵循数组的工作方式。</p><p>如果传入了一个空数组，effect 内部的 props 和 state 就会一直拥有其初始值。尽管传入的空数组作为第二个参数更加接近熟悉的 componentDidMount 和 componentWillUnMount 思维方式。React 会等待浏览器完成画面渲染后才会延迟调用 useEffect，因此会使得额外操作很方便。</p><p> 启用 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a> 中的 <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> 规则。此规则会在添加错误依赖时发出警告并给出修复建议。 </p><h2 id="Hook-规则"><a href="#Hook-规则" class="headerlink" title="Hook 规则"></a><code>Hook</code> 规则</h2><p>Hook 本质就是 JS 函数，使用它需要遵循两条规则。 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">linter 插件</a>来强制执行这些规则：</p><h3 id="只在顶层使用-Hook"><a href="#只在顶层使用-Hook" class="headerlink" title="只在顶层使用 Hook"></a>只在顶层使用 <code>Hook</code></h3><p>不要在循环，条件或者嵌套函数中调用 Hook，确保总是在 React 函数的最顶层调用它们。遵循这条规则，就能确保 hook 在每一次渲染中都按照同样的顺序被执行.</p><h3 id="只在-React-函数中使用-Hook"><a href="#只在-React-函数中使用-Hook" class="headerlink" title="只在 React 函数中使用 Hook"></a>只在 React 函数中使用 <code>Hook</code></h3><p>不要在普通的 JS 函数中调用 Hook，可以在React 函数组件中调用 Hook，在自定义 Hook 中调用其他 Hook</p><p>遵循以上规则，确保组件的状态逻辑在代码中清晰可见</p><h3 id="ESLINT-插件"><a href="#ESLINT-插件" class="headerlink" title="ESLINT 插件"></a>ESLINT 插件</h3><p>  <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks"><code>eslint-plugin-react-hooks</code></a> 的 ESLint 插件来强制执行这两条规则。如果你想尝试一下，可以将此插件添加到你的项目中： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint-plugins-react-hooks --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ESLint 的配置</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"plugins"</span>:[</span><br><span class="line">        //...</span><br><span class="line">        <span class="string">"react-hooks"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"rules"</span>:&#123;</span><br><span class="line">        //...</span><br><span class="line">        "react-hooks/rules-of-hooks":"error",// 检查 Hook 规则</span><br><span class="line">        "react-hooks/exhaustive-deps":"warn" // 检查 effect 的依赖</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>单个组件中使用多个 State Hook或者 Effect Hook</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Form</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [name,setName] = useState(<span class="string">'Mary'</span>)</span><br><span class="line">    useEffect(<span class="function"><span class="keyword">function</span> <span class="title">persisForm</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        localStorage.setItem(<span class="string">'formData'</span>,name)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> [surname,setSurname] = useState(<span class="string">'Poppins'</span>)</span><br><span class="line">    useEffect(<span class="function"><span class="keyword">function</span> <span class="title">updateTitle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = name + <span class="string">' '</span> +surname</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 怎么知道哪个state 对应哪个 useState，答案是React靠Hook调用的顺序。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首次渲染</span></span><br><span class="line">useState(<span class="string">'Mary'</span>) <span class="comment">// 1.使用 Mary 初始化变量名为 name 的 state</span></span><br><span class="line">useEffect(persistForm) <span class="comment">// 2.添加 effect 以保存 form 操作</span></span><br><span class="line">useState(<span class="string">'Poppings'</span>) <span class="comment">// 3.使用 Poppings 初始化变量名为 surname 的 state</span></span><br><span class="line">useEffect(updateTitle) <span class="comment">//4. 添加 effect 以更新标题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二次渲染</span></span><br><span class="line">useState(<span class="string">'Mary'</span>) <span class="comment">// 5.读取变量名为 name 的 state (参数被忽略)</span></span><br><span class="line">useEffect(persistForm) <span class="comment">// 6.替换保存 form 的 effect</span></span><br><span class="line">useState(<span class="string">'Poppings'</span>) <span class="comment">// 7.读取变量名为 surname 的 state(参数被忽略)</span></span><br><span class="line">useEffect(updateTitle) <span class="comment">//8. 替换更新标题的effect</span></span><br></pre></td></tr></table></figure><p>只要 Hook 的调用顺序在多次渲染中保持一致，React 就能正确将内部 state 和对应的 hook 进行关联。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 倘若将一个 hook 调用放入到一个条件语句中会发生什么</span></span><br><span class="line"><span class="keyword">if</span>(name !== <span class="string">''</span>)&#123;</span><br><span class="line">    useEffect(<span class="function"><span class="keyword">function</span> <span class="title">persistForm</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        localStorage.setItem(<span class="string">'formData'</span>,name)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在第一次渲染中 name!== ''条件为true,所以会执行这个 hook，但是下一次渲染我们可能清空了表单，表达式为 false,此时渲染会跳过该hook，hook的调用顺讯发生了变化</span></span><br><span class="line">useState(<span class="string">'Mary'</span>) <span class="comment">//1.读取变量名为 name 的 state(参数被忽略)</span></span><br><span class="line"><span class="comment">// useEffect(persistForm) // 此 hook 被忽略</span></span><br><span class="line">useState(<span class="string">'Poppins'</span>) <span class="comment">// 2.(之前为3)。读取变量名为 surname的state 失败</span></span><br><span class="line">useEffect(updateTitle) <span class="comment">// 3.(之前为4)，替换更新标题的 effect失败</span></span><br></pre></td></tr></table></figure><p>React 不知道第二个useState 的 Hook 应该返回什么，React 以为在该组件中第二个 Hook 的调用像上次渲染一样。对应的是 persistForm的 effect,但并非如此。从这里开始，后面的 Hook调用都被提前执行，导致了bug的产生。</p><p>这就是为什么 Hook 需要在我们组件的最顶层调用，如果要有条件地执行一个 effect，可以将判断放在 Hook 的内部</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="keyword">function</span> <span class="title">persistForm</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 将条件放置在 effect 中</span></span><br><span class="line">    <span class="keyword">if</span>(name === <span class="string">''</span>)&#123;</span><br><span class="line">        localStorage.setItem(<span class="string">'formData'</span>,name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="自定义-Hook-1"><a href="#自定义-Hook-1" class="headerlink" title="自定义 Hook"></a>自定义 <code>Hook</code></h2><p>通过自定义 Hook，可以将组件逻辑提取到可重用的函数中</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState,useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendState</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [isOnline,setIsOnline] = useState(<span class="literal">null</span>)</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">            setIsOnline(status.isOnline)</span><br><span class="line">        &#125;</span><br><span class="line">        ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">        &#125;;        </span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span>(isOnline === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Loading...'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设聊天应用中有一个联系人列表，当用户在线时需要把名字设置为 绿色，我们可以把上面类似的逻辑复制并粘贴到 FriendListItem 组件中，但这并不是理想的解决方案</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState,useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendListItem</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [isOnline,setIsOnline] = useState(<span class="literal">null</span>)</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">            setIsOnline(status.isOnline)</span><br><span class="line">        &#125;</span><br><span class="line">        ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">        &#125;;          </span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;li style=&#123;&#123;<span class="attr">color</span>:isOnline?<span class="string">'green'</span>:<span class="string">'black'</span>&#125;&#125;&gt;</span><br><span class="line">            &#123;props.friend.name&#125;</span><br><span class="line">        &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>我们希望在FriendStatus以及FriendListItem 之间共享逻辑。</p><h3 id="提取自定义-Hook"><a href="#提取自定义-Hook" class="headerlink" title="提取自定义 Hook"></a>提取自定义 <code>Hook</code></h3><p>当我们想在两个函数之间共享逻辑时，会把它提取到第三个函数中，而组件和Hook都是函数，所以也使用这种方式</p><p>自定义Hook 是一个函数，名称以 use 开头，函数内部可以调用其他 hook，下面 useFriendStatus 就是定义的 Hook</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState,useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriendStatus</span>(<span class="params">friendID</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [isOnline,setIsOnline] = useState(<span class="literal">null</span>)</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">            setIsOnline(status.isOnline)</span><br><span class="line">        &#125;</span><br><span class="line">        ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);</span><br><span class="line">        &#125;;          </span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> isOnline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 此处 <code>useFriendStatus</code> 的 Hook 目的是订阅某个好友的在线状态。这就是我们需要将 <code>friendID</code> 作为参数，并返回这位好友的在线状态的原因。 </p><h3 id="使用自定义-Hook"><a href="#使用自定义-Hook" class="headerlink" title="使用自定义 Hook"></a>使用自定义 <code>Hook</code></h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isOnline = useFriendStatus(props.friend.id)</span><br><span class="line">    <span class="keyword">if</span>(isOnline === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Loading...'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendListItem</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isOnline = useFriendStatus(props.friend.id)</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;li style=&#123;&#123;<span class="attr">color</span>:isOnline?<span class="string">'green'</span>:<span class="string">'black'</span>&#125;&#125;&gt;</span><br><span class="line">            &#123;props.friend.name&#125;</span><br><span class="line">        &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>  <strong>代码等价于原来的示例代码</strong> ,<strong>自定义 Hook 是一种自然遵循 Hook 设计的约定，而并不是 React 的特性。</strong> </p><p> <strong>自定义 Hook 必须以 “<code>use</code>” 开头</strong> </p><p> <strong>在两个组件中使用相同的 Hook 不会共享 state</strong> </p><p> <strong>自定义 Hook  每次<em>调用</em>  都会获取独立的 state</strong></p><h3 id="多个-Hook之间传递信息"><a href="#多个-Hook之间传递信息" class="headerlink" title="多个 Hook之间传递信息"></a>多个 <code>Hook</code>之间传递信息</h3><p>由于 Hook 本身就是函数，因此我们可以在它们之间传递信息。</p><p>将使用聊天程序中的另一个组件来说明这一点，这是一个聊天消息接收者的选择器。会显示当前的好友是否在线</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> friendList = [</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">'Phoebe'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">'Rachel'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:<span class="string">'Ross'</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChatRecipientPicker</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [recipientID,setRecipientID] = useState(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> isRecipientOnline = useFriendStatus(recipientID)</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;&gt;</span><br><span class="line">        &lt;Circle color=&#123;isRecipientOnline ? <span class="string">'green'</span> : <span class="string">'red'</span>&#125;/&gt;</span><br><span class="line">        &lt;Select </span><br><span class="line">                value=&#123;recipientID&#125;</span><br><span class="line">                onChange=&#123;e=&gt;setRecipientID(<span class="built_in">Number</span>(e.target.value))&#125;</span><br><span class="line">             &gt;</span><br><span class="line">            &#123;friendList.map(<span class="function"><span class="params">friend</span>=&gt;</span>(</span><br><span class="line">                &lt;option key=&#123;friend.id&#125; value=&#123;friend.id&#125;&gt;</span><br><span class="line">                    &#123;friend.name&#125;</span><br><span class="line">                &lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">            ))&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Select&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>将当前选择的好友ID保存在 recepientID 状态变量中，并在用户从 Select 中选择其他好友时更新这个state</p><p>由于 useState 提供了 recipientID 状态变量的最新值，我们可以将它作为参数传递给自定义的 useFriendStatus Hook</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [recipientID,setRecipientID] = useState(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> isRecipientOnline = useFriendStatus(recipientID)</span><br></pre></td></tr></table></figure><p>当我们选择不同的好友并更新 recipientID 状态变量时，useFriendStatusHook 将会取消订阅之前选中的好友，并订阅新选中的好友状态</p><h2 id="Hook-API索引"><a href="#Hook-API索引" class="headerlink" title="Hook API索引"></a><code>Hook API</code>索引</h2><h3 id="基本Hook"><a href="#基本Hook" class="headerlink" title="基本Hook"></a>基本<code>Hook</code></h3><h4 id="useState"><a href="#useState" class="headerlink" title="useState"></a><strong>useState</strong></h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state,setState] = useState(initialState)</span><br></pre></td></tr></table></figure><p>返回一个state,以及更新 state 的函数。在初始渲染期间，返回的状态（state）与传入的第一个参数(initialState)值相同。</p><p><code>setState</code>函数用于更新state,它接收一个新的state值并将组件的一次重新渲染加入队列</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setState(newState);</span><br></pre></td></tr></table></figure><p>后续渲染中，useState 返回的第一个值始终是更新后最新的 state。React会确保 setState 函数的标识是稳定的，并且不会在组件重新渲染时发生变化，这就是为什么可以安全地从 useEffect 或 useCallback 的依赖列表中省略 setState</p><p><strong>函数式更新</strong></p><p>如果新的state需要通过使用先前的 state计算得出，那么可以将函数传递给 setState,该函数将接收先前的 state,并返回一个更新后的值，下面的例子展示了 setState 的两种用法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123;initialCount&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count,setCount] = useState(initialCount);</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;&gt;</span><br><span class="line">        Count:&#123;count&#125;</span><br><span class="line">&lt;button onClick=&#123;()=&gt;setCount(initialCount)&#125;&gt;Reset&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;setCount(prevCount=&gt;prevCount+1)&#125;&gt;=&lt;/</span>button&gt;</span><br><span class="line">            &lt;button onClick=&#123;()=&gt;setCount(<span class="function"><span class="params">prevCount</span>=&gt;</span>prevCount<span class="number">-1</span>)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><code>+</code>和<code>-</code>采用函数式形式，因为被更新的的 state 需要基于之前的 state,但是重置按钮则采用普通形式，因为它总是把 count 设置回初始值</p><p>与 class 组件的 setState 方法不一致，useState 不会自动合并更新对象，使用函数式的 setState 结合展开运算符达到合并更新对象的效果</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setState(<span class="function"><span class="params">prevState</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// Object.assign</span></span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        ...prevState,...updateValues</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// useReducer 是另一种可选方案，更适合用于管理包含多个子值的 state 对象</span></span><br></pre></td></tr></table></figure><p><strong>惰性初始 state</strong></p><p>initialState 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数计算并返回初始 state,次函数只在初始渲染被调用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state,setState] = useState(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> initialState = someExpensiveComputation(props)</span><br><span class="line">    <span class="keyword">return</span> initialState</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>跳过state 更新</strong></p><p>调用 State Hook 的更新函数并传入当前的 state ，React 将跳过子组件的渲染以及 effect 的执行，React 使用Object.is 比较算法来比较state</p><p>需要注意的是，React可能仍需要在跳过渲染前渲染该组件，不过由于React不会对组件数的深层节点进行不必要的渲染，所以不用担心。如果在渲染期间执行了高开销的计算，则可以使用 useMemo 优化。</p><h4 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useEffect(didUpdate)</span><br></pre></td></tr></table></figure><p>该hook 接收一个包含命令式、并且可能有副作用代码的函数。</p><p>在函数组件主体内改变 DOM,添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性</p><p>使用 <code>useEffect</code>完成副作用操作，赋值给 <code>useEffect</code>的函数会在组件渲染到屏幕之后执行。默认情况下，effect 将在每轮渲染结束后执行，可以渲染让它在只有某些值的时候才执行。</p><p><strong>清除effect</strong></p><p>通常，组件卸载时需要清除 effect 创建的诸如订阅或者定时器ID 等资源，要实现这一点，需要返回一个清除函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> subsciption = props.source.subscibe()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 清除订阅</span></span><br><span class="line">        subscription.unsubscribe()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>为了防止内存泄露，清除函数会在组件卸载前执行，另外，如果组件多次渲染，则在执行下一个 effect 之前，上一个 effect 就已经被清除。上面的例子意味着组件的每一次更新都会创建新的订阅，若想避免每次更新都触发 effect 的。</p><p><strong>effect的执行时机</strong></p><p>与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会被延迟调用。这使得它适用于很多常见的副作用场景，如设置订阅和事件处理等情况，因为不应该在函数中执行阻塞浏览器更新屏幕的操作。</p><p>然后不是所有的 effect 都可以被延迟执行的，例如在浏览器执行 下一次绘制前，用户可见的 DOM变更就必须同步执行，这样永不才不会感觉到视觉上的不一致。React 提供了 useLayoutEffect Hook 来处理这类 effect，和 useEffect 结构相同，但是调用时机不同。</p><p>虽然 useEffect 会在浏览器绘制后延迟执行，但会保证在任何渲染前执行，React 将在组件更新前刷新上一轮的渲染的 effect </p><p><strong>effect的条件执行</strong></p><p>默认情况下，effect 会在每轮组件渲染完成后执行，一旦 effect 的依赖发生变化，它就会被重新创建。但我们不需要再每次更新时都创建新的订阅，而仅在 props 改变的时候重新创建，可以给 useEffect 传递第二个参数，它是 effect 依赖的值数组</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> subscription = props.source.subscribe()</span><br><span class="line">    <span class="keyword">return</span><span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        subscription.unsubscribe();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,[props.source])</span><br><span class="line"><span class="comment">// 此时只有props.source 改变后才会重新创建订阅</span></span><br></pre></td></tr></table></figure><h4 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = useContext(myContext);</span><br></pre></td></tr></table></figure><p>接收一个 context 对象（React.createContext的返回值）并返回该 context 的当前值。当前 context 值由上层组件中距离当前组件最新的 <code>&lt;MyContext.Provider&gt;</code>的 value prop 决定。</p><p>当上层最近的 <code>&lt;MyContext.Provider&gt;</code>更新时，该Hook 会触发重新渲染，并使用最新传递给 MyContext provider 的 context  value 值</p><p>别忘记 <code>useContext</code> 的参数必须是 <em>context 对象本身</em>：</p><ul><li><strong>正确：</strong> <code>useContext(MyContext)</code></li><li><strong>错误：</strong> <code>useContext(MyContext.Consumer)</code></li><li><strong>错误：</strong> <code>useContext(MyContext.Provider)</code></li></ul><p>调用了 useContext的组件总会在 context 值变化时重新渲染，如果重新渲染组件开销比较大的话，可以通过 memoization 优化</p><p><code>useContext(MyContext)</code>只是能够读取 context 的值以及订阅 context 的变化，仍然需要在上层组件树中使用 <code>&lt;MyContext.Provider&gt;</code>来为下层组件提供 context</p><h3 id="额外的-Hook"><a href="#额外的-Hook" class="headerlink" title="额外的 Hook"></a>额外的 Hook</h3><h4 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state,dispatch] = useReducer(reducer,initialArg,init)</span><br></pre></td></tr></table></figure><p>它接受一个 <code>(state,action)=&gt; newState</code>的 reducer，并返回一个当前的 state以及与其配套的 <code>dispatch</code>方法。</p><p>在某些场景下，useReducer 比 useState更适用。例如 state 逻辑复杂且包含多个子值，或者下一个 state 依赖之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为可以向子组件传递 dispatch 而不是回调函数。</p><p>reducer 重写 useState 的计数器</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state,action</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">count</span>:state.count+<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">count</span>:state.count<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [state,dispatch] = useReducer(reducer,initialState)</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;&gt;</span><br><span class="line">        Count:&#123;state.count&#125;</span><br><span class="line">        &lt;button onClick=&#123;()=&gt;dispatch(&#123;<span class="attr">type</span>:<span class="string">'increment'</span>&#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;()=&gt;dispatch(&#123;<span class="attr">type</span>:<span class="string">'decrement'</span>&#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>指定初始state</strong></p><p>有两种初始化 useReducer state 的方式，可以根据使用场景选择其中的一种。将初始 state 作为第二个参数传入 useReducer 是最简单的方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state,dispatch] = useReducer(</span><br><span class="line">    reducer,</span><br><span class="line">    &#123;<span class="attr">count</span>:initialCount&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>惰性初始化</strong></p><p>选择惰性地创建初始化 state,为此需要将 init 函数作为 useReducer 的第三个参数传入，这样初始 state 将被设置为 init(initialArg)</p><p>这样做，可以将用于计算 state 的逻辑提取到 reducer 外部，这也为将来对重置 state 的 action 做处理提供了便利：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">initialCount</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">count</span>:initialCount&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state,action</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">count</span>:state.count+<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">count</span>:state.count<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'reset'</span>:</span><br><span class="line">            <span class="keyword">return</span> init(action.payload);            </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123;initialCount&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [state,dispatch] = useReducer(reducer,initialCount,init)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>(</span><br><span class="line">    &lt;&gt;</span><br><span class="line">    Count:&#123;state.count&#125;</span><br><span class="line">    &lt;button onClick=&#123;()=&gt;dispatch(&#123;<span class="attr">type</span>:<span class="string">'reset'</span>,<span class="attr">payload</span>:initialCount&#125;)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;button onClick=&#123;()=&gt;dispatch(&#123;<span class="attr">type</span>:<span class="string">'increment'</span>&#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;button onClick=&#123;()=&gt;dispatch(&#123;<span class="attr">type</span>:<span class="string">'decrement'</span>&#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p><strong>跳过 dispatch</strong></p><p>如果 Reducer Hook  的返回值与当前 state 相同，React 将跳过子组件的渲染以及副作用的执行。需要注意的是，React 可能仍需要跳过渲染前再次渲染该组件。不过由于React 不会对组件树的深层节点进行不必要的渲染，所以不用担心。如果在渲染期间执行了高开销的计算，则可以使用 <code>useMemo</code>来进行优化</p><h4 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoziedCallback = useCallBack(</span><br><span class="line">    ()=&gt;&#123;</span><br><span class="line">        dosomething(a,b);</span><br><span class="line">    &#125;,</span><br><span class="line">    [a,b]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>返回一个 memoized 回调函数</p><p>把内联回调函数以及依赖数组作为参数传入 useCallback ，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会跟新。当你把回调函数给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件，它将非常有用</p><p><code>useCallback(fn,deps)</code>相当于 <code>useMemo(()=&gt;fn,deps)</code></p><h4 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = useMemo(<span class="function"><span class="params">()</span>=&gt;</span>computeExpensiveValue(a,b),[a,b])</span><br></pre></td></tr></table></figure><p>返回一个 memoized值。</p><p>把创建函数和依赖项作为参数传入 useMemo,它仅会在某个依赖项改变时才重新计算 memoized值，这种优化有助于避免在每次渲染时都进行高开销计算。</p><p>传入 useMemo 的函数会在渲染期间执行，不要在这个函数内部执行于渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo</p><p>如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值</p><h4 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> refContainer = useRef(initialValue)</span><br></pre></td></tr></table></figure><p>useRef 返回一个可变的 ref 对象，其 <code>.current</code>属性被初始化为传入的参数 initialValue 。返回的 ref 对象在组件的整个生命周期内保持不变。</p><p>命令式访问子组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextInputWithFocusButton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> onButtonClick = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// current 指向已经挂载到 DOM 上的文本输入元素</span></span><br><span class="line">        inputEl.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;&gt;</span><br><span class="line">        &lt;input ref=&#123;inputEl&#125; type=<span class="string">"text"</span>/&gt;</span><br><span class="line">        &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useImperativeHandle(ref,createHandle,[deps])</span><br></pre></td></tr></table></figure><p><code>useImperativeHandle</code>可以让你在使用 <code>ref</code>时自定义暴露给父组件的实例值。<code>useImperativeHandle</code>应当与 <code>forwardRef</code>一起使用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyInput</span>(<span class="params">props,ref</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">    useImperativeHandle(red,()=&gt;&#123;</span><br><span class="line">        focus:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            inputRef.current.focus()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">...</span>/&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">FancyInput = forwardRef(FancyInput)</span></span><br><span class="line">// 渲染 &lt;FancyInput ref=&#123;fancyInputRef&#125; /&gt; 的父组件可以调用 fancyInputRef.current.focus();</span><br></pre></td></tr></table></figure><h4 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h4><p>其函数签名与 useEffect 相同，但它会在所有的DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划会被同步刷新。尽可能使用 标准的 useEffect 以避免阻塞视觉更新</p><p>注意：</p><p>useLayoutEffect 与 componentDidMount、componentDIdUpdate的调用阶段是一样的。</p><p>如果使用服务端渲染，无论是 useLayoutEffect 或者 useEffect 都无法在 JS 代码加载完成之前执行。这就是为什么在服务端渲染组件中引入 useLayoutEffect 代码会触发React 警告。解决这个问题，需要将代码逻辑移到 useEffect 中（如果首次渲染不需要这段逻辑的情况下），或是将该组件延迟到客户端渲染完成后再显示（直到 useLayoutEffect执行之前HTML 都显示错误的情况下）</p><p>若要从服务端渲染的 HTML 中排除依赖布局 effect 的组件，可以通过使用 <code>showChild &amp;&amp; &lt;Child&gt;</code>进行条件渲染，并使用 <code>useEffect(()=&gt;{setShowChild(true)},[])</code>延迟展示组件。这样在客户单渲染完成之前，UI就不会像之前那样显示错乱了。</p><h4 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useDebugValue(value)</span><br></pre></td></tr></table></figure><p><code>useDebugValue</code>可用于 React 开发工具中显示自定义 hook 标签</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriendStatus</span>(<span class="params">friendID</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [isOnline,setIsOnline] = useState(<span class="literal">null</span>)</span><br><span class="line">    useDebugValue(isOnline?<span class="string">'Online'</span>:<span class="string">'Offline'</span>)</span><br><span class="line">    <span class="keyword">return</span> isOnline</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>延迟格式化 debug值</strong></p><p>某些情况下，格式化值的显示可能是一项开销很大的操作，除非检查 Hook，否则没有必要这么做。因此，useDebugValue 接受一个格式化函数作为可选的第二个参数。该函数只有在 hook 检查才会被调用。它接受 debug 值作为参数，并且会返回一个格式化的显示值。</p><p>例如，一个返回 Date 值的自定义 Hook 可以通过格式化函数来避免不必要的 toDateString 函数调用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useDebugValue(date,date=&gt;date.toDateString())</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;react-hook实践&quot;&gt;&lt;a href=&quot;#react-hook实践&quot; class=&quot;headerlink&quot; title=&quot;react hook实践&quot;&gt;&lt;/a&gt;react hook实践&lt;/h1&gt;&lt;p&gt;又到了跟着文档码字学习的阶段，&lt;code&gt;hook&lt;/cod
      
    
    </summary>
    
      <category term="react" scheme="http://laibh.top/categories/react/"/>
    
    
      <category term="react" scheme="http://laibh.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>基于ts重构axios</title>
    <link href="http://laibh.top/2019-09-03-%E5%9F%BA%E4%BA%8Ets%E9%87%8D%E6%9E%84axios.html"/>
    <id>http://laibh.top/2019-09-03-基于ts重构axios.html</id>
    <published>2019-09-03T06:19:54.000Z</published>
    <updated>2022-03-04T10:00:38.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于ts重构axios"><a href="#基于ts重构axios" class="headerlink" title="基于ts重构axios"></a>基于ts重构axios</h1><p><strong>ustbhuangyi</strong> 老师的 <a href="https://coding.imooc.com/class/330.html">基于TypeScript从零重构axios</a>学习记录。</p><p><strong>知识点</strong></p><p>TypeScript 常用语法：</p><p><code>基础类型</code> 、 <code>函数</code> 、 <code>变量声明</code> 、 <code>接口</code> 、 <code>类</code> 、 <code>泛型</code> 、 <code>类型推新</code> 、 <code>高级类型</code> </p><p>axios js库：</p><p><code>项目脚手架</code> 、 <code>基础功能实现</code> 、 <code>异常情况处理</code> 、 <code>接口扩展</code> 、 <code>拦截器实现</code> 、 <code>配置化实现</code> 、 <code>取消功能实现</code> 、 <code>其他功能实现等等</code> </p><p>主要工具：<br><code>Jest</code> 、 <code>TSLint</code> 、 <code>Commitizen</code> 、 <code>Prettier</code> 、 <code>RollupJS</code> 、 <code>Semantic release</code> </p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><a href="http://laibh.top/2018-11-28-TypeScript.html">点我</a></p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ul><li>在浏览器使用 XMLHttpRequest 对象通讯</li><li>支持 Promise API</li><li>支持请求和响应的拦截器</li><li>支持请求数据和响应数据的转换</li><li>支持请求的取消</li><li>JSON数据的自动转换</li><li>客户端防止 XSRF</li></ul><h2 id="基于-XMLHttpRequest-编写基本请求代码"><a href="#基于-XMLHttpRequest-编写基本请求代码" class="headerlink" title="基于 XMLHttpRequest 编写基本请求代码"></a>基于 XMLHttpRequest 编写基本请求代码</h2><h3 id="处理请求数据：url-body-headers"><a href="#处理请求数据：url-body-headers" class="headerlink" title="处理请求数据：url/body/headers"></a>处理请求数据：url/body/headers</h3><p><strong>src/types/index.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export type Method = &apos;get&apos; | &apos;GET&apos; | &apos;delete&apos; | &apos;Delete&apos; | &apos;head&apos; | &apos;HEAD&apos; | &apos;options&apos; | &apos;OPTIONS&apos; | &apos;post&apos; | &apos;POST&apos; | &apos;put&apos; | &apos;PUT&apos; | &apos;patch&apos; | &apos;PATCH&apos;</span><br><span class="line">export interface AxiosRequestConfig &#123;</span><br><span class="line">  url: string</span><br><span class="line">  method?: Method</span><br><span class="line">  data?: any</span><br><span class="line">  params?: any</span><br><span class="line">  headers?: any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>src/xhr.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; AxiosRequestConfig &#125; from &apos;./types&apos;</span><br><span class="line"></span><br><span class="line">export default function xhr(config: AxiosRequestConfig): void &#123;</span><br><span class="line">  const &#123; data = null, url, method = &apos;get&apos;, headers &#125; = config</span><br><span class="line">  const request = new XMLHttpRequest()</span><br><span class="line">  // method,url,async</span><br><span class="line">  request.open(method.toUpperCase(), url, true)</span><br><span class="line">  Object.keys(headers).forEach(name =&gt; &#123;</span><br><span class="line">    if (data === null &amp;&amp; name.toLowerCase() === &apos;content-type&apos;) &#123;</span><br><span class="line">      delete headers[name]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      request.setRequestHeader(name, headers[name])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  request.send(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>src/index.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import &#123; AxiosRequestConfig &#125; from &apos;./types&apos;</span><br><span class="line">import &#123; buildURL &#125; from &apos;./helpers/url&apos;;</span><br><span class="line">import &#123; transformRequest &#125; from &apos;./helpers/data&apos;;</span><br><span class="line">import xhr from &apos;./xhr&apos;</span><br><span class="line">import &#123; processHeaders &#125; from &apos;./helpers/header&apos;;</span><br><span class="line"></span><br><span class="line">function axios(config: AxiosRequestConfig): void &#123;</span><br><span class="line">  processConfig(config)</span><br><span class="line">  xhr(config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function processConfig(config: AxiosRequestConfig): void &#123;</span><br><span class="line">  config.url = transformURL(config)</span><br><span class="line">  config.data = transformRequestData(config)</span><br><span class="line">  config.headers = transformHeaders(config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transformHeaders(config: AxiosRequestConfig): void &#123;</span><br><span class="line">  const &#123; headers = &#123;&#125;, data &#125; = config</span><br><span class="line">  return processHeaders(headers, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transformRequestData(config: AxiosRequestConfig): void &#123;</span><br><span class="line">  return transformRequest(config.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transformURL(config: AxiosRequestConfig): string &#123;</span><br><span class="line">  const &#123; url, params &#125; = config;</span><br><span class="line">  return buildURL(url, params)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default axios</span><br></pre></td></tr></table></figure><h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4><p><strong>data.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; isPlainObject &#125; from &quot;./util&quot;;</span><br><span class="line"></span><br><span class="line">export function transformRequest(data: any): any &#123;</span><br><span class="line">  if (isPlainObject(data)) &#123;</span><br><span class="line">    return JSON.stringify(data)</span><br><span class="line">  &#125;</span><br><span class="line">  return data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>headers.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import &#123; isPlainObject &#125; from &quot;./util&quot;</span><br><span class="line"></span><br><span class="line">function normalizeHeaderName(headers: any, normalizedName: string): void &#123;</span><br><span class="line">  if (!headers) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  Object.keys(headers).forEach(name =&gt; &#123;</span><br><span class="line">    if (name !== normalizedName &amp;&amp; name.toUpperCase() === normalizedName.toUpperCase()) &#123;</span><br><span class="line">      headers[normalizedName] = headers[name]</span><br><span class="line">      delete headers[name]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function processHeaders(headers: any, data: any): any &#123;</span><br><span class="line">  normalizeHeaderName(headers, &apos;Content-Type&apos;)</span><br><span class="line">  if (isPlainObject(data)) &#123;</span><br><span class="line">    if (headers &amp;&amp; !headers[&apos;Content-Type&apos;]) &#123;</span><br><span class="line">      headers[&apos;Content-Type&apos;] = &apos;application/json;charset=utf-8&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return headers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>url.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123; isDate, isPlainObject &#125; from &apos;./util&apos;</span><br><span class="line"></span><br><span class="line">function encode(val: string): string &#123;</span><br><span class="line">  return encodeURIComponent(val)</span><br><span class="line">    .replace(/%40/g, &apos;@&apos;)</span><br><span class="line">    .replace(/%3A/ig, &apos;:&apos;)</span><br><span class="line">    .replace(/%24/g, &apos;**util.ts**</span><br><span class="line"></span><br><span class="line">​```tsx</span><br><span class="line">const toString = Object.prototype.toString</span><br><span class="line"></span><br><span class="line">export function isDate(val: any): val is Date &#123;</span><br><span class="line">  return toString.call(val) === &apos;[object Date]&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function isPlainObject(val: any): val is Object &#123;</span><br><span class="line">  return toString.call(val) === &apos;[object Object]&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理响应数据"><a href="#处理响应数据" class="headerlink" title="处理响应数据"></a>处理响应数据</h3><p>定义响应接口</p><p><strong>types/index</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AxiosResponse &#123;</span><br><span class="line">  data: <span class="built_in">any</span></span><br><span class="line">  status: <span class="built_in">number</span></span><br><span class="line">  statusText: <span class="built_in">string</span></span><br><span class="line">  headers: <span class="built_in">any</span></span><br><span class="line">  config: AxiosRequestConfig</span><br><span class="line">  request: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AxiosPromise <span class="keyword">extends</span> Promise&lt;AxiosResponse&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理 headers 的数据</p><p><strong>helpers/header.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">export function processHeaders(headers: any, data: any): any &#123;</span><br><span class="line">  normalizeHeaderName(headers, &apos;Content-Type&apos;)</span><br><span class="line">  if (isPlainObject(data)) &#123;</span><br><span class="line">    if (headers &amp;&amp; !headers[&apos;Content-Type&apos;]) &#123;</span><br><span class="line">      headers[&apos;Content-Type&apos;] = &apos;application/json;charset=utf-8&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return headers</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function parseHeaders(headers: string): any &#123;</span><br><span class="line">  let parsed = Object.create(null)</span><br><span class="line">  if (!headers) &#123;</span><br><span class="line">    return headers</span><br><span class="line">  &#125;</span><br><span class="line">  headers.split(&apos;\r\n&apos;).forEach(line =&gt; &#123;</span><br><span class="line">    let [key, val] = line.split(&apos;:&apos;)</span><br><span class="line">    key = key.trim().toLowerCase()</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    if (val) &#123;</span><br><span class="line">      val = val.trim();</span><br><span class="line">    &#125;</span><br><span class="line">    parsed[key] = val</span><br><span class="line">  &#125;)</span><br><span class="line">  return parsed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理 响应data</p><p><strong>helpers/data.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export function transformResponse(data: any): any &#123;</span><br><span class="line">  if (typeof data === &apos;string&apos;) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      data = JSON.parse(data)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      // do nothing</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 xhr, 返回一个 Promise</p><p><strong>xhr.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import &#123; AxiosRequestConfig, AxiosPromise, AxiosResponse &#125; from &apos;./types&apos;</span><br><span class="line">import &#123; parseHeaders &#125; from &apos;./helpers/headers&apos;</span><br><span class="line"></span><br><span class="line">export default function xhr(config: AxiosRequestConfig): AxiosPromise &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    const &#123; data = null, url, method = &apos;get&apos;, headers, responseType &#125; = config</span><br><span class="line">    const request = new XMLHttpRequest()</span><br><span class="line">    if (responseType) &#123;</span><br><span class="line">      request.responseType = responseType</span><br><span class="line">    &#125;</span><br><span class="line">    // method,url,async</span><br><span class="line">    request.open(method.toUpperCase(), url, true)</span><br><span class="line"></span><br><span class="line">    request.onreadystatechange = function handleLoad() &#123;</span><br><span class="line">      if (request.readyState !== 4) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const responseHeaders = parseHeaders(request.getAllResponseHeaders())</span><br><span class="line">      const responseData = responseType &amp;&amp; responseType !== &apos;text&apos; ? request.response : request.responseText</span><br><span class="line">      const response: AxiosResponse = &#123;</span><br><span class="line">        data: responseData,</span><br><span class="line">        status: request.status,</span><br><span class="line">        statusText: request.statusText,</span><br><span class="line">        headers: responseHeaders,</span><br><span class="line">        config,</span><br><span class="line">        request</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(response)</span><br><span class="line">    &#125;</span><br><span class="line">    Object.keys(headers).forEach(name =&gt; &#123;</span><br><span class="line">      if (data === null &amp;&amp; name.toLowerCase() === &apos;content-type&apos;) &#123;</span><br><span class="line">        delete headers[name]</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        request.setRequestHeader(name, headers[name])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    request.send(data)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/LbhFront-end/ts-axios">具体代码地址</a></p><p>)</p><pre><code>.replace(/%2C/ig, &apos;,&apos;).replace(/%20/g, &apos;+&apos;).replace(/%5B/ig, &apos;[&apos;).replace(/%5D/ig, &apos;]&apos;)</code></pre><p>}</p><p>export function buildURL(url: string, params?: any): string {<br>  if (!params) {</p><pre><code>return url</code></pre><p>  }<br>  const parts: string[] = []<br>  Object.keys(params).forEach(key =&gt; {</p><pre><code>const val = params[key]if (val === null || typeof val === &apos;undefined&apos;) {  return}let values = []if (Array.isArray(val)) {  values = val  key += &apos;[]&apos;} else {  values = [val]}values.forEach(val =&gt; {  if (isDate(val)) {    val = val.toISOString()  } else if (isPlainObject(val)) {    val = JSON.stringify(val)  }  parts.push( `${encode(key)}=${encode(val)}` )})</code></pre><p>  })<br>  let serializedParams = parts.join(‘&amp;’)<br>  if (serializedParams) {</p><pre><code>const markIndex = url.indexOf(&apos;#&apos;)if (markIndex !== -1) {  url = url.slice(0, markIndex)}url += (url.indexOf(&apos;?&apos;) === -1 ? &apos;?&apos; : &apos;&amp;&apos;) + serializedParams</code></pre><p>  }<br>  return url<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**util.ts**</span><br><span class="line"></span><br><span class="line">​```tsx</span><br><span class="line">const toString = Object.prototype.toString</span><br><span class="line"></span><br><span class="line">export function isDate(val: any): val is Date &#123;</span><br><span class="line">  return toString.call(val) === &apos;[object Date]&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function isPlainObject(val: any): val is Object &#123;</span><br><span class="line">  return toString.call(val) === &apos;[object Object]&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理响应数据-1"><a href="#处理响应数据-1" class="headerlink" title="处理响应数据"></a>处理响应数据</h3><p>定义响应接口</p><p><strong>types/index</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AxiosResponse &#123;</span><br><span class="line">  data: <span class="built_in">any</span></span><br><span class="line">  status: <span class="built_in">number</span></span><br><span class="line">  statusText: <span class="built_in">string</span></span><br><span class="line">  headers: <span class="built_in">any</span></span><br><span class="line">  config: AxiosRequestConfig</span><br><span class="line">  request: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AxiosPromise <span class="keyword">extends</span> Promise&lt;AxiosResponse&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理 headers 的数据</p><p><strong>helpers/header.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">export function processHeaders(headers: any, data: any): any &#123;</span><br><span class="line">  normalizeHeaderName(headers, &apos;Content-Type&apos;)</span><br><span class="line">  if (isPlainObject(data)) &#123;</span><br><span class="line">    if (headers &amp;&amp; !headers[&apos;Content-Type&apos;]) &#123;</span><br><span class="line">      headers[&apos;Content-Type&apos;] = &apos;application/json;charset=utf-8&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return headers</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function parseHeaders(headers: string): any &#123;</span><br><span class="line">  let parsed = Object.create(null)</span><br><span class="line">  if (!headers) &#123;</span><br><span class="line">    return headers</span><br><span class="line">  &#125;</span><br><span class="line">  headers.split(&apos;\r\n&apos;).forEach(line =&gt; &#123;</span><br><span class="line">    let [key, val] = line.split(&apos;:&apos;)</span><br><span class="line">    key = key.trim().toLowerCase()</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    if (val) &#123;</span><br><span class="line">      val = val.trim();</span><br><span class="line">    &#125;</span><br><span class="line">    parsed[key] = val</span><br><span class="line">  &#125;)</span><br><span class="line">  return parsed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理 响应data</p><p><strong>helpers/data.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export function transformResponse(data: any): any &#123;</span><br><span class="line">  if (typeof data === &apos;string&apos;) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      data = JSON.parse(data)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      // do nothing</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 xhr, 返回一个 Promise</p><p><strong>xhr.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import &#123; AxiosRequestConfig, AxiosPromise, AxiosResponse &#125; from &apos;./types&apos;</span><br><span class="line">import &#123; parseHeaders &#125; from &apos;./helpers/headers&apos;</span><br><span class="line"></span><br><span class="line">export default function xhr(config: AxiosRequestConfig): AxiosPromise &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    const &#123; data = null, url, method = &apos;get&apos;, headers, responseType &#125; = config</span><br><span class="line">    const request = new XMLHttpRequest()</span><br><span class="line">    if (responseType) &#123;</span><br><span class="line">      request.responseType = responseType</span><br><span class="line">    &#125;</span><br><span class="line">    // method,url,async</span><br><span class="line">    request.open(method.toUpperCase(), url, true)</span><br><span class="line"></span><br><span class="line">    request.onreadystatechange = function handleLoad() &#123;</span><br><span class="line">      if (request.readyState !== 4) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const responseHeaders = parseHeaders(request.getAllResponseHeaders())</span><br><span class="line">      const responseData = responseType &amp;&amp; responseType !== &apos;text&apos; ? request.response : request.responseText</span><br><span class="line">      const response: AxiosResponse = &#123;</span><br><span class="line">        data: responseData,</span><br><span class="line">        status: request.status,</span><br><span class="line">        statusText: request.statusText,</span><br><span class="line">        headers: responseHeaders,</span><br><span class="line">        config,</span><br><span class="line">        request</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(response)</span><br><span class="line">    &#125;</span><br><span class="line">    Object.keys(headers).forEach(name =&gt; &#123;</span><br><span class="line">      if (data === null &amp;&amp; name.toLowerCase() === &apos;content-type&apos;) &#123;</span><br><span class="line">        delete headers[name]</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        request.setRequestHeader(name, headers[name])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    request.send(data)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/LbhFront-end/ts-axios">具体代码地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于ts重构axios&quot;&gt;&lt;a href=&quot;#基于ts重构axios&quot; class=&quot;headerlink&quot; title=&quot;基于ts重构axios&quot;&gt;&lt;/a&gt;基于ts重构axios&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;ustbhuangyi&lt;/strong&gt; 老师的 &lt;
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://laibh.top/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="http://laibh.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>前端必备的测试</title>
    <link href="http://laibh.top/2019-08-19-%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E7%9A%84%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://laibh.top/2019-08-19-前端必备的测试学习.html</id>
    <published>2019-08-19T00:33:54.000Z</published>
    <updated>2022-03-04T10:00:38.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端必备的测试"><a href="#前端必备的测试" class="headerlink" title="前端必备的测试"></a>前端必备的测试</h1><p>DellLee 老师的 <a href="https://coding.imooc.com/class/372.html">前端要学的测试课 从Jest入门到TDD/BDD双实战</a>学习记录。</p><p><strong>知识点</strong></p><p>Jest 基础</p><p><code>基础API</code>、<code>异步测试</code>、<code>Mock技巧</code>、<code>快照</code>、<code>timer测试</code>、<code>Dom测试</code></p><p>实现项目</p><p><code>Vue</code>、<code>Vue-test-utils</code>、<code>React</code>、<code>Enzyme</code>、<code>TDD+单元测试</code>、<code>BDD+集成测试</code></p><h2 id="初识测试"><a href="#初识测试" class="headerlink" title="初识测试"></a>初识测试</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minus</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  add,</span><br><span class="line">  minus</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// math.test.js</span></span><br><span class="line"><span class="comment">// 简陋测试</span></span><br><span class="line"><span class="keyword">import</span> &#123; add, minus &#125; <span class="keyword">from</span> <span class="string">'./math'</span></span><br><span class="line"><span class="keyword">let</span> result</span><br><span class="line"><span class="keyword">let</span> expected</span><br><span class="line">result = add(<span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line">expected = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result !== <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`3 + 7 应该等于 <span class="subst">$&#123;expected&#125;</span>,但结果却是 <span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = minus(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">expected = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result !== <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`3 - 3 应该等于 <span class="subst">$&#123;expected&#125;</span>,但结果却是 <span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 封装版</span></span><br><span class="line"><span class="keyword">import</span> &#123; add, minus &#125; <span class="keyword">from</span> <span class="string">'./math'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">expect</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    toBe: <span class="function"><span class="keyword">function</span> (<span class="params">actual</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (result !== actual) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`预期值与实际值不相等 预期<span class="subst">$&#123;actual&#125;</span> 结果却是 <span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">desc, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;desc&#125;</span>通过测试`</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;desc&#125;</span>没有通过测试 <span class="subst">$&#123;e&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">'测试加法3 + 7'</span>, () =&gt; &#123;</span><br><span class="line">  expect(add(<span class="number">3</span>, <span class="number">7</span>)).toBe(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br><span class="line">test(<span class="string">'测试减法6 - 3'</span>, () =&gt; &#123;</span><br><span class="line">  expect(minus(<span class="number">6</span>, <span class="number">3</span>)).toBe(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="自动化框架：Jest"><a href="#自动化框架：Jest" class="headerlink" title="自动化框架：Jest"></a>自动化框架：Jest</h2><p>优点：性能、功能、易用性、速度快、Api简单、易配置、隔离性好、监控模式、IDE整合、Snapshot、多项目并行、覆盖率、Mock丰富</p><h3 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 项目内部调用 jest</span></span><br><span class="line">npx jest --init </span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择 </span></span><br><span class="line">browser-like</span><br><span class="line"><span class="meta">#</span><span class="bash"> 随后选择自动生成报告，自动清除实例在每个<span class="built_in">test</span>之前，就会生成一下配置文件</span></span><br><span class="line">jest.config.js</span><br></pre></td></tr></table></figure><p><code>jest.config.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For a detailed explanation regarding each configuration property, visit:</span></span><br><span class="line"><span class="comment">// https://jestjs.io/docs/en/configuration.html</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// All imported modules in your tests should be mocked automatically</span></span><br><span class="line">  <span class="comment">// 自动模拟在测试用例中的所有导入模块，在 __mocks__ 文件夹中寻找</span></span><br><span class="line">  <span class="comment">// automock: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stop running tests after `n` failures</span></span><br><span class="line">  <span class="comment">// 默认情况下，Jest运行所有测试并在完成后将所有错误生成到控制台，bil 让 jest 在 n 失败后停止运行测试</span></span><br><span class="line">  <span class="comment">// bail: 0,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Respect "browser" field in package.json when resolving modules</span></span><br><span class="line">  <span class="comment">// false =&gt; browser | true =&gt; node</span></span><br><span class="line">  <span class="comment">// browser: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The directory where Jest should store its cached dependency information</span></span><br><span class="line">  <span class="comment">// 存放 jest 依赖信息缓存的目录</span></span><br><span class="line">  <span class="comment">// cacheDirectory: "C:\\Users\\Administrator\\AppData\\Local\\Temp\\jest",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Automatically clear mock calls and instances between every test</span></span><br><span class="line">  <span class="comment">// 自动清除模拟调用和实例在每次测试之间</span></span><br><span class="line">  clearMocks: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Indicates whether the coverage information should be collected while executing the test</span></span><br><span class="line">  <span class="comment">// 是否收集测试时的覆盖率信息，因为要带上覆盖率搜集语句访问所有执行过的文件，这可能会让测试执行速度明显减慢</span></span><br><span class="line">  <span class="comment">// collectCoverage: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of glob patterns indicating a set of files for which coverage information should be collected</span></span><br><span class="line">  <span class="comment">// 指示应收集覆盖率信息的全局模式一组文件，即使文件不存在测试，也将为其收集覆盖率信息，并且测试套件中不需要它</span></span><br><span class="line">  <span class="comment">// collectCoverageFrom: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The directory where Jest should output its coverage files</span></span><br><span class="line">  <span class="comment">// jest 输出测速覆盖率文件的目录</span></span><br><span class="line">  <span class="comment">// 运行 npx jest --coverage</span></span><br><span class="line">  coverageDirectory: <span class="string">"coverage"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of regexp pattern strings used to skip coverage collection</span></span><br><span class="line">  <span class="comment">// 忽略测试的文件路径的正则匹配</span></span><br><span class="line">  <span class="comment">// coveragePathIgnorePatterns: [</span></span><br><span class="line">  <span class="comment">//   "\\\\node_modules\\\\"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A list of reporter names that Jest uses when writing coverage reports</span></span><br><span class="line">  <span class="comment">// coverageReporters: [</span></span><br><span class="line">  <span class="comment">//   "json",</span></span><br><span class="line">  <span class="comment">//   "text",</span></span><br><span class="line">  <span class="comment">//   "lcov",</span></span><br><span class="line">  <span class="comment">//   "clover"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An object that configures minimum threshold enforcement for coverage results</span></span><br><span class="line">  <span class="comment">// coverageThreshold: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A path to a custom dependency extractor</span></span><br><span class="line">  <span class="comment">// dependencyExtractor: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make calling deprecated APIs throw helpful error messages</span></span><br><span class="line">  <span class="comment">// errorOnDeprecated: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Force coverage collection from ignored files using an array of glob patterns</span></span><br><span class="line">  <span class="comment">// forceCoverageMatch: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A path to a module which exports an async function that is triggered once before all test suites</span></span><br><span class="line">  <span class="comment">// globalSetup: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A path to a module which exports an async function that is triggered once after all test suites</span></span><br><span class="line">  <span class="comment">// globalTeardown: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A set of global variables that need to be available in all test environments</span></span><br><span class="line">  <span class="comment">// globals: &#123;&#125;,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The maximum amount of workers used to run your tests. Can be specified as % or a number. E.g. maxWorkers: 10% will use 10% of your CPU amount + 1 as the maximum worker number. maxWorkers: 2 will use a maximum of 2 workers.</span></span><br><span class="line">  <span class="comment">// maxWorkers: "50%",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of directory names to be searched recursively up from the requiring module's location</span></span><br><span class="line">  <span class="comment">// moduleDirectories: [</span></span><br><span class="line">  <span class="comment">//   "node_modules"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of file extensions your modules use</span></span><br><span class="line">  <span class="comment">// 模块使用文件扩展名数组，当你导入的文件没有扩展名的时候，它会在这个数组里面去自动匹配</span></span><br><span class="line">  <span class="comment">// moduleFileExtensions: [</span></span><br><span class="line">  <span class="comment">//   "js",</span></span><br><span class="line">  <span class="comment">//   "json",</span></span><br><span class="line">  <span class="comment">//   "jsx",</span></span><br><span class="line">  <span class="comment">//   "ts",</span></span><br><span class="line">  <span class="comment">//   "tsx",</span></span><br><span class="line">  <span class="comment">//   "node"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A map from regular expressions to module names that allow to stub out resources with a single module</span></span><br><span class="line">  <span class="comment">// 模块名映射，类 webpack alias 以及 jsconfig.js 的 compilerOptions.paths</span></span><br><span class="line">  <span class="comment">// moduleNameMapper: &#123;&#125;,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of regexp pattern strings, matched against all module paths before considered 'visible' to the module loader</span></span><br><span class="line">  <span class="comment">// modulePathIgnorePatterns: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Activates notifications for test results</span></span><br><span class="line">  <span class="comment">// notify: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An enum that specifies notification mode. Requires &#123; notify: true &#125;</span></span><br><span class="line">  <span class="comment">// notifyMode: "failure-change",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A preset that is used as a base for Jest's configuration</span></span><br><span class="line">  <span class="comment">// preset: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run tests from one or more projects</span></span><br><span class="line">  <span class="comment">// projects: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use this configuration option to add custom reporters to Jest</span></span><br><span class="line">  <span class="comment">// reporters: undefined,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Automatically reset mock state between every test</span></span><br><span class="line">  <span class="comment">// resetMocks: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reset the module registry before running each individual test</span></span><br><span class="line">  <span class="comment">// resetModules: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A path to a custom resolver</span></span><br><span class="line">  <span class="comment">// resolver: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Automatically restore mock state between every test</span></span><br><span class="line">  <span class="comment">// restoreMocks: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The root directory that Jest should scan for tests and modules within</span></span><br><span class="line">  <span class="comment">// rootDir: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A list of paths to directories that Jest should use to search for files in</span></span><br><span class="line">  <span class="comment">// roots: [</span></span><br><span class="line">  <span class="comment">//   "&lt;rootDir&gt;"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allows you to use a custom runner instead of Jest's default test runner</span></span><br><span class="line">  <span class="comment">// runner: "jest-runner",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The paths to modules that run some code to configure or set up the testing environment before each test</span></span><br><span class="line">  <span class="comment">// setupFiles: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A list of paths to modules that run some code to configure or set up the testing framework before each test</span></span><br><span class="line">  <span class="comment">// 运行做测试的时候使用某些垫片为运行环境做兼容</span></span><br><span class="line">  <span class="comment">// setupFilesAfterEnv: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A list of paths to snapshot serializer modules Jest should use for snapshot testing</span></span><br><span class="line">  <span class="comment">// 快照格式化</span></span><br><span class="line">  <span class="comment">// snapshotSerializers: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The test environment that will be used for testing</span></span><br><span class="line">  <span class="comment">// testEnvironment: "jest-environment-jsdom",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Options that will be passed to the testEnvironment</span></span><br><span class="line">  <span class="comment">// testEnvironmentOptions: &#123;&#125;,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Adds a location field to test results</span></span><br><span class="line">  <span class="comment">// testLocationInResults: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The glob patterns Jest uses to detect test files</span></span><br><span class="line">  <span class="comment">// 匹配测试文件</span></span><br><span class="line">  <span class="comment">// testMatch: [</span></span><br><span class="line">  <span class="comment">//   "**/__tests__/**/*.[jt]s?(x)",</span></span><br><span class="line">  <span class="comment">//   "**/?(*.)+(spec|test).[tj]s?(x)"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of regexp pattern strings that are matched against all test paths, matched tests are skipped</span></span><br><span class="line">  <span class="comment">// testPathIgnorePatterns: [</span></span><br><span class="line">  <span class="comment">//   "\\\\node_modules\\\\"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The regexp pattern or array of patterns that Jest uses to detect test files</span></span><br><span class="line">  <span class="comment">// testRegex: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// This option allows the use of a custom results processor</span></span><br><span class="line">  <span class="comment">// testResultsProcessor: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// This option allows use of a custom test runner</span></span><br><span class="line">  <span class="comment">// testRunner: "jasmine2",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// This option sets the URL for the jsdom environment. It is reflected in properties such as location.href</span></span><br><span class="line">  <span class="comment">// 模拟浏览器的地址</span></span><br><span class="line">  <span class="comment">// testURL: "http://localhost",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Setting this value to "fake" allows the use of fake timers for functions such as "setTimeout"</span></span><br><span class="line">  <span class="comment">// timers: "real",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A map from regular expressions to paths to transformers</span></span><br><span class="line">  <span class="comment">// 不同文件类型对应不同的转换器</span></span><br><span class="line">  <span class="comment">// transform: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation</span></span><br><span class="line">  <span class="comment">// transformIgnorePatterns: [</span></span><br><span class="line">  <span class="comment">//   "\\\\node_modules\\\\"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them</span></span><br><span class="line">  <span class="comment">// unmockedModulePathPatterns: undefined,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Indicates whether each individual test should be reported during the run</span></span><br><span class="line">  <span class="comment">// verbose: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode</span></span><br><span class="line">  <span class="comment">// watchPathIgnorePatterns: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Whether to use watchman for file crawling</span></span><br><span class="line">  <span class="comment">// watchman: true,</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="babelrc"><a href="#babelrc" class="headerlink" title="babelrc"></a>babelrc</h3><p>jest 未配置转换时，默认只支持 commonjs 语法。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"targets"</span>: &#123;</span><br><span class="line">          <span class="attr">"node"</span>: <span class="string">"current"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jest转换（commonjs -&gt; es module）大概工作原理：</p><ol><li>npm run jest</li><li>jest（babel-jest）jest 内部的</li><li>检测是有 babel-core</li><li>拿到 .babelrc 配置</li><li>再运行测试之前，结合 babel  把代码做一次转化</li><li>运行转化过的测试用例</li></ol><h2 id="常用匹配器（Matchers）"><a href="#常用匹配器（Matchers）" class="headerlink" title="常用匹配器（Matchers）"></a>常用匹配器（Matchers）</h2><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><h4 id="toBe"><a href="#toBe" class="headerlink" title=".toBe()"></a>.toBe()</h4><h4 id="toEqual-value"><a href="#toEqual-value" class="headerlink" title=".toEqual(value)"></a>.toEqual(value)</h4><h4 id="toBeGreaterThan-number"><a href="#toBeGreaterThan-number" class="headerlink" title=".toBeGreaterThan(number)"></a>.toBeGreaterThan(number)</h4><h4 id="toBeGreaterThanOrEqual-number"><a href="#toBeGreaterThanOrEqual-number" class="headerlink" title=".toBeGreaterThanOrEqual(number)"></a>.toBeGreaterThanOrEqual(number)</h4><h4 id="toBeLessThan-number"><a href="#toBeLessThan-number" class="headerlink" title=".toBeLessThan(number)"></a>.toBeLessThan(number)</h4><h4 id="toBeLessThanOrEqual-number"><a href="#toBeLessThanOrEqual-number" class="headerlink" title=".toBeLessThanOrEqual(number)"></a>.toBeLessThanOrEqual(number)</h4><h4 id="toBeCloseTo-number-numDigits"><a href="#toBeCloseTo-number-numDigits" class="headerlink" title=".toBeCloseTo(number,numDigits?)"></a>.toBeCloseTo(number,numDigits?)</h4><p>第二个参数为精度，代表几位小数点，默认为2位</p><h4 id="toBeNaN"><a href="#toBeNaN" class="headerlink" title=".toBeNaN()"></a>.toBeNaN()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字相关</span></span><br><span class="line">test(<span class="string">'匹配器：toBe-数字相等'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBe 匹配器 matchers Object.is() ===</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">10</span></span><br><span class="line">  expect(a).toBe(<span class="number">10</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toEqual-内容相等'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toEqual 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = &#123; <span class="attr">one</span>: <span class="number">1</span> &#125;</span><br><span class="line">  expect(a).toEqual(&#123; <span class="attr">one</span>: <span class="number">1</span> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeGreaterThan-大于比较数'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeGreaterThan 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">4</span></span><br><span class="line">  expect(a).toBeGreaterThan(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeGreaterThanOrEqual-大于等于比较数'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeGreaterThanOrEqual 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">4</span></span><br><span class="line">  expect(a).toBeGreaterThanOrEqual(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeLessThan-小于比较数'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeLessThan 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">4</span></span><br><span class="line">  expect(a).toBeLessThan(<span class="number">5</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeLessThanOrEqual-小于等于比较数'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeLessThanOrEqual 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">4</span></span><br><span class="line">  expect(a).toBeLessThanOrEqual(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数</span></span><br><span class="line">test(<span class="string">'匹配器：toBeCloseTo-两个浮点数字相加'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeCloseTo 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> value = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line">  <span class="comment">// expect(value).toBe(0.3);   这句会报错，因为浮点数有舍入误差</span></span><br><span class="line">  expect(value).toBeCloseTo(<span class="number">0.3</span>); <span class="comment">// 这句可以运行</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// NaN</span></span><br><span class="line">test(<span class="string">'匹配器：toBeNaN-等于NaN'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="literal">NaN</span>).toBeNaN();</span><br><span class="line">  expect(<span class="number">1</span>).not.toBeNaN();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="真假"><a href="#真假" class="headerlink" title="真假"></a>真假</h3><ul><li><code>toBeNull</code>只匹配 <code>null</code></li><li><code>toBeUndefined</code>只匹配 <code>undefined</code></li><li><code>toBeDefined</code> 与 <code>toBeUndefined</code>相反</li><li><code>toBeTruthy</code> 匹配任何 <code>if</code> 语句为真</li><li><code>toBeFalsy</code>匹配任何 <code>if</code> 语句为假</li></ul><h4 id="toBeNull"><a href="#toBeNull" class="headerlink" title=".toBeNull()"></a>.toBeNull()</h4><h4 id="toBeUndefined"><a href="#toBeUndefined" class="headerlink" title=".toBeUndefined()"></a>.toBeUndefined()</h4><h4 id="toBeDefined"><a href="#toBeDefined" class="headerlink" title=".toBeDefined()"></a>.toBeDefined()</h4><h4 id="toBeTruthy"><a href="#toBeTruthy" class="headerlink" title=".toBeTruthy()"></a>.toBeTruthy()</h4><h4 id="toBeFalsy"><a href="#toBeFalsy" class="headerlink" title=".toBeFalsy()"></a>.toBeFalsy()</h4><p>在JavaScript中，有六个falsy值：<code>false</code>，<code>0</code>，<code>&#39;&#39;</code>，<code>null</code>，<code>undefined</code>，和<code>NaN</code>。其他一切都是真实的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真假相关</span></span><br><span class="line">test(<span class="string">'匹配器：toBeNull-与null相等'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeNull 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="literal">null</span></span><br><span class="line">  expect(a).toBeNull()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeUndefined-与undefined相等'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeUndefined 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="literal">undefined</span></span><br><span class="line">  expect(a).toBeUndefined()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeDefined-被定义过的,非 undefined 的，可为 null'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeDefined 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="literal">null</span></span><br><span class="line">  expect(a).toBeDefined()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeTruthy-真值或者隐藏为true的'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeTruthy 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">  expect(a).toBeTruthy()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeFalsy-真值或者隐藏为false的'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeFalsy 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="literal">null</span></span><br><span class="line">  expect(a).toBeFalsy()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="否定"><a href="#否定" class="headerlink" title="否定"></a>否定</h3><h4 id="not"><a href="#not" class="headerlink" title=".not"></a>.not</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'匹配器：not-不是xx'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// not 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">  expect(a).not.toBeFalsy()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="expect-not-arrayContaining-array"><a href="#expect-not-arrayContaining-array" class="headerlink" title="expect.not.arrayContaining(array)"></a>expect.not.arrayContaining(array)</h4><p>匹配不是接收值的子集</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'not.arrayContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = [<span class="number">1</span>];</span><br><span class="line">  it(<span class="string">'如果接收的数组不包含1就通过测试'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).toEqual(</span><br><span class="line">      expect.not.arrayContaining(expected)</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="expect-not-objectContaining-object"><a href="#expect-not-objectContaining-object" class="headerlink" title="expect.not.objectContaining(object)"></a>expect.not.objectContaining(object)</h4><p>匹配不包含某个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'not.objectContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = &#123; <span class="attr">haha</span>: <span class="string">'laibh.top'</span> &#125;;</span><br><span class="line">  it(<span class="string">'如果接收的对象不包含&#123; haha: laibh.top &#125;就通过测试'</span>, () =&gt; &#123;</span><br><span class="line">    expect(&#123; <span class="attr">haha</span>: <span class="string">'laibh.top1'</span> &#125;).toEqual(</span><br><span class="line">      expect.not.objectContaining(expected)</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="expect-not-stringContaining-string"><a href="#expect-not-stringContaining-string" class="headerlink" title="expect.not.stringContaining(string)"></a>expect.not.stringContaining(string)</h4><p>匹配不包含某个字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'not.stringContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = <span class="string">'赖同学'</span>;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'如果接收的字符串不完全等于赖同学就通过测试'</span>, () =&gt; &#123;</span><br><span class="line">    expect(<span class="string">'赖'</span>).toEqual(expect.not.stringContaining(expected));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="expect-not-stringMatching-string-regexp"><a href="#expect-not-stringMatching-string-regexp" class="headerlink" title="expect.not.stringMatching(string|regexp)"></a>expect.not.stringMatching(string|regexp)</h4><p>同上，不过参数可以是正则表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'not.stringMatching'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = <span class="regexp">/赖同学/</span>;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'如果接收的字符串赖同学就通过测试'</span>, () =&gt; &#123;</span><br><span class="line">    expect(<span class="string">'赖'</span>).toEqual(expect.not.stringMatching(expected));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="toMatch-regexpOrString"><a href="#toMatch-regexpOrString" class="headerlink" title=".toMatch(regexpOrString)"></a>.toMatch(<code>regexpOrString</code>)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">test(<span class="string">'匹配器：toMatch-正则字符串匹配'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toMatch 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> str = <span class="string">'http://laibh.top'</span></span><br><span class="line">  expect(str).toMatch(<span class="string">'laibh'</span>)</span><br><span class="line">  <span class="comment">// 使用正则</span></span><br><span class="line">  expect(str).toMatch(<span class="regexp">/laibh/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="expect-stringContaining-string"><a href="#expect-stringContaining-string" class="headerlink" title="expect.stringContaining(string)"></a>expect.stringContaining(string)</h4><p>匹配包含某个字符串</p><h4 id="expect-stringMatching-string-regexp"><a href="#expect-stringMatching-string-regexp" class="headerlink" title="expect.stringMatching(string|regexp)"></a>expect.stringMatching(string|regexp)</h4><p>匹配字符串，可用正则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'stringMatching in arrayContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = [</span><br><span class="line">    expect.stringMatching(<span class="regexp">/^Alic/</span>),</span><br><span class="line">    expect.stringMatching(<span class="regexp">/^[BR]ob/</span>),</span><br><span class="line">  ];</span><br><span class="line">  it(<span class="string">'matches even if received contains additional elements'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="string">'Alicia'</span>, <span class="string">'Roberto'</span>, <span class="string">'Evelina'</span>]).toEqual(</span><br><span class="line">      expect.arrayContaining(expected),</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'does not match if received does not contain expected elements'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="string">'Roberto'</span>, <span class="string">'Evelina'</span>]).not.toEqual(</span><br><span class="line">      expect.arrayContaining(expected),</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="expect-toContain"><a href="#expect-toContain" class="headerlink" title="expect.toContain()"></a>expect.toContain()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line">test(<span class="string">'匹配器：toContain-数组包含某项'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toContain 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> arr = [<span class="string">'lai'</span>, <span class="string">'bin'</span>, <span class="string">'hong'</span>]</span><br><span class="line">  <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(arr)</span><br><span class="line">  expect(set).toContain(<span class="string">'lai'</span>)</span><br><span class="line">  expect(arr).toContain(<span class="string">'lai'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="expect-arrayContaining-array"><a href="#expect-arrayContaining-array" class="headerlink" title="expect.arrayContaining(array)"></a>expect.arrayContaining(array)</h4><p>匹配子集</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'arrayContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = [<span class="string">'1'</span>, <span class="string">'2'</span>];</span><br><span class="line">  it(<span class="string">'即使接收值包含其他参数也匹配'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]).toEqual(expect.arrayContaining(expected));</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'只要接收值不包含期望的值就不匹配'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="string">'2'</span>, <span class="string">'4'</span>]).not.toEqual(expect.arrayContaining(expected));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="objectContaining-object"><a href="#objectContaining-object" class="headerlink" title="objectContaining(object)"></a>objectContaining(object)</h4><p>匹配任何递归预期属性的接收对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'测试onPress函数回调参数匹配对象'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> onPress = jest.fn();</span><br><span class="line">  simulatePresses(onPress)</span><br><span class="line">  expect(onPress).toBeCalledWith(</span><br><span class="line">    expect.objectContaining(&#123;</span><br><span class="line">      x: expect.any(<span class="built_in">Number</span>),</span><br><span class="line">      y: expect.any(<span class="built_in">Number</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="toHaveProperty-keyPath-value"><a href="#toHaveProperty-keyPath-value" class="headerlink" title=".toHaveProperty(keyPath,value?)"></a>.toHaveProperty(keyPath,value?)</h4><p>检查对象中各种属性存在和值，第二个参数是可选的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object containing house features to be tested</span></span><br><span class="line"><span class="keyword">const</span> houseForSale = &#123;</span><br><span class="line">  bath: <span class="literal">true</span>,</span><br><span class="line">  bedrooms: <span class="number">4</span>,</span><br><span class="line">  kitchen: &#123;</span><br><span class="line">    amenities: [<span class="string">'oven'</span>, <span class="string">'stove'</span>, <span class="string">'washer'</span>],</span><br><span class="line">    area: <span class="number">20</span>,</span><br><span class="line">    wallColor: <span class="string">'white'</span>,</span><br><span class="line">    <span class="string">'nice.oven'</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'ceiling.height'</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'this house has my desired features'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// Simple Referencing</span></span><br><span class="line">  expect(houseForSale).toHaveProperty(<span class="string">'bath'</span>);</span><br><span class="line">  expect(houseForSale).toHaveProperty(<span class="string">'bedrooms'</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  expect(houseForSale).not.toHaveProperty(<span class="string">'pool'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 嵌套深层用 .</span></span><br><span class="line">  expect(houseForSale).toHaveProperty(<span class="string">'kitchen.area'</span>, <span class="number">20</span>);</span><br><span class="line">  expect(houseForSale).toHaveProperty(<span class="string">'kitchen.amenities'</span>, [</span><br><span class="line">    <span class="string">'oven'</span>,</span><br><span class="line">    <span class="string">'stove'</span>,</span><br><span class="line">    <span class="string">'washer'</span>,</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  expect(houseForSale).not.toHaveProperty(<span class="string">'kitchen.open'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 嵌套深层用 []</span></span><br><span class="line">  expect(houseForSale).toHaveProperty([<span class="string">'kitchen'</span>, <span class="string">'area'</span>], <span class="number">20</span>);</span><br><span class="line">  expect(houseForSale).toHaveProperty(</span><br><span class="line">    [<span class="string">'kitchen'</span>, <span class="string">'amenities'</span>],</span><br><span class="line">    [<span class="string">'oven'</span>, <span class="string">'stove'</span>, <span class="string">'washer'</span>],</span><br><span class="line">  );</span><br><span class="line">  expect(houseForSale).toHaveProperty([<span class="string">'kitchen'</span>, <span class="string">'amenities'</span>, <span class="number">0</span>], <span class="string">'oven'</span>);</span><br><span class="line">  expect(houseForSale).toHaveProperty([<span class="string">'kitchen'</span>, <span class="string">'nice.oven'</span>]);</span><br><span class="line">  expect(houseForSale).not.toHaveProperty([<span class="string">'kitchen'</span>, <span class="string">'open'</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Referencing keys with dot in the key itself</span></span><br><span class="line">  expect(houseForSale).toHaveProperty([<span class="string">'ceiling.height'</span>], <span class="string">'tall'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="toMatchObject-object"><a href="#toMatchObject-object" class="headerlink" title=".toMatchObject(object)"></a>.toMatchObject(object)</h4><p>检查对象的属性的子集相匹配</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> houseForSale = &#123;</span><br><span class="line">  bath: <span class="literal">true</span>,</span><br><span class="line">  bedrooms: <span class="number">4</span>,</span><br><span class="line">  kitchen: &#123;</span><br><span class="line">    amenities: [<span class="string">'oven'</span>, <span class="string">'stove'</span>, <span class="string">'washer'</span>],</span><br><span class="line">    area: <span class="number">20</span>,</span><br><span class="line">    wallColor: <span class="string">'white'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> desiredHouse = &#123;</span><br><span class="line">  bath: <span class="literal">true</span>,</span><br><span class="line">  kitchen: &#123;</span><br><span class="line">    amenities: [<span class="string">'oven'</span>, <span class="string">'stove'</span>, <span class="string">'washer'</span>],</span><br><span class="line">    wallColor: expect.stringMatching(<span class="regexp">/white|yellow/</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'the house has my desired features'</span>, () =&gt; &#123;</span><br><span class="line">  expect(houseForSale).toMatchObject(desiredHouse);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="toBeInstanceOf-Class"><a href="#toBeInstanceOf-Class" class="headerlink" title=".toBeInstanceOf(Class)"></a>.toBeInstanceOf(Class)</h4><p>检查对象是一个类的实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">expect(<span class="keyword">new</span> A()).toBeInstanceOf(A);</span><br><span class="line">expect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;).toBeInstanceOf(<span class="built_in">Function</span>);</span><br><span class="line">expect(<span class="keyword">new</span> A()).toBeInstanceOf(<span class="built_in">Function</span>); <span class="comment">// throws</span></span><br></pre></td></tr></table></figure><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="toThrow-error"><a href="#toThrow-error" class="headerlink" title=".toThrow(error?)"></a>.toThrow(error?)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> throwNewErrorFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'this is a new error'</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常</span></span><br><span class="line">test(<span class="string">'匹配器：toThrow-测试抛出异常'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toThrow 匹配器 matchers</span></span><br><span class="line">  expect(throwNewErrorFunc).toThrow()</span><br><span class="line">  <span class="comment">// 测试抛出的内容</span></span><br><span class="line">  expect(throwNewErrorFunc).toThrow(<span class="string">'this is a new error'</span>)</span><br><span class="line">  <span class="comment">// 表达式也行</span></span><br><span class="line">  expect(throwNewErrorFunc).toThrow(<span class="regexp">/this is a new error/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="任意"><a href="#任意" class="headerlink" title="任意"></a>任意</h3><h4 id="expect-anything"><a href="#expect-anything" class="headerlink" title="expect.anything()"></a>expect.anything()</h4><p>匹配除了 <code>null</code>、<code>undefined</code>的任意值，可以它使用在 <code>toEqual</code>或者 <code>toBeCalledWith</code>里面替代文字值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'map 遍历一个非空的参数'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> mock = jest.fn();</span><br><span class="line">    [<span class="number">1</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> mock(x))</span><br><span class="line">    expect(mock).toBeCalledWith(expect.anything())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="expect-any-constructor"><a href="#expect-any-constructor" class="headerlink" title="expect.any(constructor)"></a>expect.any(constructor)</h4><p>匹配任意构造器生成的实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randocall</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">6</span> + <span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">'测试 randocall的回调函数调用了一个数字'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> mock = jest.fn();</span><br><span class="line">    randocall(mock)</span><br><span class="line">    expect(mock).toBeCalledWith(expect.any(<span class="built_in">Number</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="toHaveLength-number"><a href="#toHaveLength-number" class="headerlink" title=".toHaveLength(number)"></a>.toHaveLength(number)</h4><p>检查对象有个 length 属性并将设为某一数值。这对于检查数组或字符串大小特别有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).toHaveLength(<span class="number">3</span>);</span><br><span class="line">expect(<span class="string">'abc'</span>).toHaveLength(<span class="number">3</span>);</span><br><span class="line">expect(<span class="string">''</span>).not.toHaveLength(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h4 id="toContain-item"><a href="#toContain-item" class="headerlink" title=".toContain(item)"></a>.toContain(item)</h4><p>检查项目在数组或者字符串是否是另一个字符串的子串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'the flavor list contains lime'</span>, () =&gt; &#123;</span><br><span class="line">  expect(getAllFlavors()).toContain(<span class="string">'lime'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="toContainEqual-item"><a href="#toContainEqual-item" class="headerlink" title=".toContainEqual(item)"></a>.toContainEqual(item)</h4><p>检查具有特定结构和值的元素是否包含在数据中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'test contain'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> testValue = &#123; <span class="attr">bol</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  expect([&#123; <span class="attr">bol</span>: <span class="literal">true</span> &#125;, &#123; <span class="attr">sour</span>: <span class="literal">false</span> &#125;]).toContainEqual(testValue)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="异步相关"><a href="#异步相关" class="headerlink" title="异步相关"></a>异步相关</h3><h4 id="expect-assertions"><a href="#expect-assertions" class="headerlink" title="expect.assertions()"></a>expect.assertions()</h4><p>匹配在测试用例里面使用断言的次数。确保在异步函数为了确保在回调函数里面断言被调用特别有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'异步调用所有回调'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="comment">// 确保有两个断言被调用</span></span><br><span class="line">    expect.assertions(<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback1</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        expect(data).toBeTruthy()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback2</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        expect(data).toBeTruthy();</span><br><span class="line">    &#125;</span><br><span class="line">    doAsync(callback1,callback2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="expect-hasAssertions"><a href="#expect-hasAssertions" class="headerlink" title="expect.hasAssertions()"></a>expect.hasAssertions()</h4><p>匹配在测试用例里面至少使用一次断言</p><h4 id="resolves"><a href="#resolves" class="headerlink" title=".resolves"></a>.resolves</h4><p>使用 <code>resolves</code>解开 fulfilled promise，如果 reject promise，则断言失败</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'resolves to lemon'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// make sure to add a return statement</span></span><br><span class="line">  <span class="keyword">return</span> expect(<span class="built_in">Promise</span>.resolve(<span class="string">'lemon'</span>)).resolves.toBe(<span class="string">'lemon'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>测试是异步的，需要告诉 jest 等待返回解开的断言</p><p>也可以用 <code>async/await</code>结合 <code>.resolves</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'resolves to lemon'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(<span class="built_in">Promise</span>.resolve(<span class="string">'lemon'</span>)).resolves.toBe(<span class="string">'lemon'</span>);</span><br><span class="line">  <span class="keyword">await</span> expect(<span class="built_in">Promise</span>.resolve(<span class="string">'lemon'</span>)).resolves.not.toBe(<span class="string">'octopus'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="rejects"><a href="#rejects" class="headerlink" title=".rejects"></a>.rejects</h4><p>使用 <code>rejects</code>解开 rejected  promise,如果 fulfilled promise,则断言失败</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'rejects to octopus'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// make sure to add a return statement</span></span><br><span class="line">  <span class="keyword">return</span> expect(<span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'octopus'</span>))).rejects.toThrow(<span class="string">'octopus'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>测试是异步的，需要告诉 jest 等待返回解开的断言</p><p>同样使用  <code>async/await</code>结合 <code>.rejects</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'rejects to octopus'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(<span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'octopus'</span>))).rejects.toThrow(<span class="string">'octopus'</span>);</span><br><span class="line">  <span class="keyword">await</span> expect(<span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'octopus'</span>))).rejects.not.toThrow(<span class="string">'lemon'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><h4 id="toHaveBeenCalled-toBeCalled"><a href="#toHaveBeenCalled-toBeCalled" class="headerlink" title=".toHaveBeenCalled()|.toBeCalled()"></a>.toHaveBeenCalled()|.toBeCalled()</h4><p>确保模拟功能得到调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drinkAll</span>(<span class="params">cb, flavour</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (flavour !== <span class="string">'octopus'</span>) &#123;</span><br><span class="line">    cb(flavour)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'test drinkAll function'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'drink somthing lemon-flavour'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">    drinkAll(drink, <span class="string">'lemon'</span>)</span><br><span class="line">    expect(drink).toBeCalled();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'test drinkAll function'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'does not drink somthing octopus-flavour'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">    drinkAll(drink, <span class="string">'octopus'</span>)</span><br><span class="line">    expect(drink).not.toBeCalled();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'test drinkAll function'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'drink somthing lemon-flavour'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">    drinkAll(drink, <span class="string">'lemon'</span>)</span><br><span class="line">    expect(drink).toHaveBeenCalled();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'test drinkAll function'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'does not drink somthing octopus-flavour'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">    drinkAll(drink, <span class="string">'octopus'</span>)</span><br><span class="line">    expect(drink).not.toHaveBeenCalled();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="toHaveBeenCallTimes-number-toBeCalledTimes-number"><a href="#toHaveBeenCallTimes-number-toBeCalledTimes-number" class="headerlink" title=".toHaveBeenCallTimes(number)|.toBeCalledTimes(number)"></a>.toHaveBeenCallTimes(number)|.toBeCalledTimes(number)</h4><p>确保模拟功能得到调用次数与指定数字一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drinkEach drinks each drink'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">  drinkEach(drink, [<span class="string">'lemon'</span>, <span class="string">'octopus'</span>]);</span><br><span class="line">  expect(drink).toHaveBeenCalledTimes(<span class="number">2</span>);</span><br><span class="line">  expect(drink).toBeCalledTimes(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="toHaveBeenCalledWith-arg1-arg2-…-toBeCalledWith-arg1-arg2-…"><a href="#toHaveBeenCalledWith-arg1-arg2-…-toBeCalledWith-arg1-arg2-…" class="headerlink" title=".toHaveBeenCalledWith(arg1,arg2,…)|.toBeCalledWith(arg1,arg2,…)"></a>.toHaveBeenCalledWith(arg1,arg2,…)|.toBeCalledWith(arg1,arg2,…)</h4><p>确保模拟功能被调用的具体参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calledWithArg</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  cb(<span class="string">'Arg'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'test calledWithArg'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn();</span><br><span class="line">  calledWithArg(fn);</span><br><span class="line">  expect(fn).toBeCalledWith(<span class="string">'Arg'</span>);</span><br><span class="line">  expect(fn).toHaveBeenCalledWith(<span class="string">'Arg'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="toHaveBeenLastCalledWith-arg1-arg2-…-lastCalledWith-arg1-arg2-…"><a href="#toHaveBeenLastCalledWith-arg1-arg2-…-lastCalledWith-arg1-arg2-…" class="headerlink" title=".toHaveBeenLastCalledWith(arg1,arg2,…)|.lastCalledWith(arg1, arg2, …)"></a>.toHaveBeenLastCalledWith(arg1,arg2,…)|.lastCalledWith(arg1, arg2, …)</h4><p>确保模拟功能被最后一次调用的具体参数</p><h4 id="toHaveBeenNthCalledWith-nthCall-arg1-arg2-…-nthCalledWith-nthCall-arg1-arg2-…"><a href="#toHaveBeenNthCalledWith-nthCall-arg1-arg2-…-nthCalledWith-nthCall-arg1-arg2-…" class="headerlink" title=".toHaveBeenNthCalledWith(nthCall, arg1, arg2, ….)|.nthCalledWith(nthCall, arg1, arg2, ….)"></a>.toHaveBeenNthCalledWith(nthCall, arg1, arg2, ….)|.nthCalledWith(nthCall, arg1, arg2, ….)</h4><p>确保模拟功能多次调用的顺序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drinkEach drinks each drink'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">  drinkEach(drink, [<span class="string">'lemon'</span>, <span class="string">'octopus'</span>]);</span><br><span class="line">  expect(drink).toHaveBeenNthCalledWith(<span class="number">1</span>, <span class="string">'lemon'</span>);</span><br><span class="line">  expect(drink).toHaveBeenNthCalledWith(<span class="number">2</span>, <span class="string">'octopus'</span>);</span><br><span class="line">  expect(drink).nthCalledWith(<span class="number">1</span>, <span class="string">'lemon'</span>);</span><br><span class="line">  expect(drink).nthCalledWith(<span class="number">2</span>, <span class="string">'octopus'</span>);    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>n 必须是从 1开始的正整数</p><h4 id="toHaveReturned-toReturn"><a href="#toHaveReturned-toReturn" class="headerlink" title=".toHaveReturned()|.toReturn()"></a>.toHaveReturned()|.toReturn()</h4><p>测试模拟函数成功返回(即没有抛出错误)至少一次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'test calledWithArg'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn();</span><br><span class="line">  calledWithArg(fn);</span><br><span class="line">  expect(fn).toHaveReturned();</span><br><span class="line">  expect(fn).toReturn();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="toHaveReturnedTimes-number-toReturnTimes-number"><a href="#toHaveReturnedTimes-number-toReturnTimes-number" class="headerlink" title=".toHaveReturnedTimes(number)|.toReturnTimes(number)"></a>.toHaveReturnedTimes(number)|.toReturnTimes(number)</h4><p>确保模拟函数返回成功的次数,抛出错误的模拟函数的任何调用都不计入函数返回的次数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drink returns twice'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  drink();</span><br><span class="line">  drink();</span><br><span class="line"></span><br><span class="line">  expect(drink).toHaveReturnedTimes(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="toHaveReturnedWith-value-toReturnWith-value"><a href="#toHaveReturnedWith-value-toReturnWith-value" class="headerlink" title=".toHaveReturnedWith(value)|.toReturnWith(value)"></a>.toHaveReturnedWith(value)|.toReturnWith(value)</h4><p>确保模拟函数返回特定的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'test Return 123'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">123</span>);</span><br><span class="line">  calledWithArg(fn);</span><br><span class="line">  expect(fn).toHaveReturnedWith(<span class="number">123</span>)</span><br><span class="line">  expect(fn).toReturnWith(<span class="number">123</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="toHaveLastReturnedWith-value-lastReturnedWith-value"><a href="#toHaveLastReturnedWith-value-lastReturnedWith-value" class="headerlink" title=".toHaveLastReturnedWith(value)|.lastReturnedWith(value)"></a>.toHaveLastReturnedWith(value)|.lastReturnedWith(value)</h4><p>确保模拟函数最后一次返回特定的值</p><h4 id="toHaveNthReturnedWith-nthCall-value-nthReturnedWith-nthCall-value"><a href="#toHaveNthReturnedWith-nthCall-value-nthReturnedWith-nthCall-value" class="headerlink" title=".toHaveNthReturnedWith(nthCall, value)|.nthReturnedWith(nthCall, value)"></a>.toHaveNthReturnedWith(nthCall, value)|.nthReturnedWith(nthCall, value)</h4><p>确保模拟函数第n次调用返回特定的值</p><p>第n个参数必须是从1开始的正整数。</p><h3 id="自定义扩展"><a href="#自定义扩展" class="headerlink" title="自定义扩展"></a>自定义扩展</h3><h4 id="expect-extend"><a href="#expect-extend" class="headerlink" title="expect.extend()"></a>expect.extend()</h4><p><code>pass</code>表示是否有匹配，<code>message</code>提供一个没有参数的函数，在出现错误的情况下返回消息。当<code>pass:false</code>，<code>message</code>返回 <code>expect(x).matcher()</code>失败的错误信息，<code>pass:true</code>，<code>message</code>返回当<code>expect(x).not.matcher()</code>失败时的错误消息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expect.extend(matchers)</span></span><br><span class="line">expect.extend(&#123;</span><br><span class="line">  toBeWithinRange(reveived, floor, ceiling) &#123;</span><br><span class="line">    <span class="keyword">const</span> pass = reveived &gt;= floor &amp;&amp; reveived &lt;= ceiling;</span><br><span class="line">    <span class="keyword">if</span> (pass) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        message: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`期待 <span class="subst">$&#123;reveived&#125;</span> 不在范围<span class="subst">$&#123;floor&#125;</span>-<span class="subst">$&#123;ceiling&#125;</span>内`</span>,</span><br><span class="line">        pass,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        message: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`期待 <span class="subst">$&#123;reveived&#125;</span> 在范围<span class="subst">$&#123;floor&#125;</span>-<span class="subst">$&#123;ceiling&#125;</span>内`</span>,</span><br><span class="line">        pass,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'测试范围'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">100</span>).toBeWithinRange(<span class="number">90</span>, <span class="number">100</span>)</span><br><span class="line">  expect(<span class="number">101</span>).not.toBeWithinRange(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">  expect(&#123; <span class="attr">apples</span>: <span class="number">6</span>, <span class="attr">bananas</span>: <span class="number">3</span> &#125;).toEqual(&#123;</span><br><span class="line">    apples: expect.toBeWithinRange(<span class="number">1</span>, <span class="number">10</span>),</span><br><span class="line">    bananas: expect.not.toBeWithinRange(<span class="number">11</span>, <span class="number">20</span>),</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>异步扩展,需要结合 <code>async</code>和 <code>await</code>函数来使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">expect.extend(&#123;</span><br><span class="line">    <span class="keyword">async</span> toBeDivisibleByExternalValue(reveived)&#123;</span><br><span class="line">        <span class="comment">// 异步获取的除数</span></span><br><span class="line">        <span class="keyword">const</span> externalValue = <span class="keyword">await</span> getExternalValueFromRemoteSource();</span><br><span class="line">        <span class="keyword">const</span> pass = received % externalValue == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(pass)&#123;</span><br><span class="line">            <span class="keyword">return</span>&#123;</span><br><span class="line">                message:<span class="function"><span class="params">()</span>=&gt;</span><span class="string">`期待<span class="subst">$&#123;received&#125;</span>不被<span class="subst">$&#123;externalValue&#125;</span>整除`</span>,</span><br><span class="line">                pass</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>&#123;</span><br><span class="line">                message:<span class="function"><span class="params">()</span>=&gt;</span><span class="string">`期待<span class="subst">$&#123;received&#125;</span>被<span class="subst">$&#123;externalValue&#125;</span>整除`</span>,</span><br><span class="line">                pass</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://jestjs.io/docs/zh-Hans/expect">更多</a></p><h3 id="测试异步代码"><a href="#测试异步代码" class="headerlink" title="测试异步代码"></a>测试异步代码</h3><p>回调形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetchData.js</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'@/utils/request'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchData = <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">  request(<span class="string">'http://www.dell-lee.com/react/api/demo.json'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.data) cb(res.data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> fetchData</span><br><span class="line"><span class="comment">// fetchData.test.js</span></span><br><span class="line"><span class="keyword">import</span> fetchData <span class="keyword">from</span> <span class="string">'./fetchData'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">test(<span class="string">'fetch 返回结果为 &#123;success: true&#125;'</span>, () =&gt; &#123;</span><br><span class="line">  fetchData(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    expect(data).toEqual(&#123;</span><br><span class="line">      success: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调类型异步函数</span></span><br><span class="line">test(<span class="string">'fetch 返回结果为 &#123;success: true&#125;'</span>, (done) =&gt; &#123;</span><br><span class="line">  fetchData(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    expect(data).toEqual(&#123;</span><br><span class="line">      success: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    done();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetchData.js</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'@/utils/request'</span>;</span><br><span class="line"><span class="keyword">const</span> fetchData = <span class="function"><span class="params">()</span> =&gt;</span> request(<span class="string">'http://www.dell-lee.com/react/api/demo.json'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> fetchData</span><br><span class="line"></span><br><span class="line"><span class="comment">//fetchData.test.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fetchData <span class="keyword">from</span> <span class="string">'./fetchData'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line">test(<span class="string">'fetch 返回结果为 &#123;success: true&#125;'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> fetchData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    expect(res.data).toEqual(&#123; <span class="attr">success</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 测试404</span></span><br><span class="line">test(<span class="string">'fetchData 返回结果为404'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 要求至少跑一次 expect</span></span><br><span class="line">  expect.assertions(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> fetchData().catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    expect(e.toString().indexOf(<span class="string">'404'</span>) &gt; <span class="number">-1</span>).toBe(<span class="literal">true</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// .resolves / .rejects</span></span><br><span class="line">test(<span class="string">'fetch 返回结果为 &#123;success: true&#125;'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> expect(fetchData()).resolves.toMatchObject(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      success: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'fetchData 返回结果为404'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> expect(fetchData()).rejects.toThrow()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Async/Await</span></span><br><span class="line">test(<span class="string">'fetch 返回结果为 &#123;success: true&#125;'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(fetchData()).resolves.toMatchObject(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      success: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'fetchData 返回结果为404'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(fetchData()).rejects.toThrow()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 另一种 Async/Await</span></span><br><span class="line">test(<span class="string">'fetch 返回结果为 &#123;success: true&#125;'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetchData()</span><br><span class="line">  expect(res.data).toEqual(&#123;</span><br><span class="line">    success: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'fetchData 返回结果为404'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  expect.assertions(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> fetchData()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">await</span> expect(e.toString()).toEqual(<span class="string">'Error: Request failed with status code 404'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Couter.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.number = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addOne() &#123;</span><br><span class="line">    <span class="keyword">this</span>.number += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addTwo() &#123;</span><br><span class="line">    <span class="keyword">this</span>.number += <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  minusOne() &#123;</span><br><span class="line">    <span class="keyword">this</span>.number -= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  minusTwo() &#123;</span><br><span class="line">    <span class="keyword">this</span>.number -= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter;</span><br><span class="line"><span class="comment">// Couter.test.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">'./Couter'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'测试 Counter'</span>,()=&gt;&#123;</span><br><span class="line">  <span class="keyword">let</span> couter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有测试开始之前</span></span><br><span class="line">  beforeAll(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    couter = <span class="keyword">new</span> Counter();</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 每个测试用例开始之前</span></span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 每次测试都会生成一个新的 couter</span></span><br><span class="line">    couter = <span class="keyword">new</span> Counter();</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 每个测试用例结束之后</span></span><br><span class="line">  afterEach(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;)</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 所有测试结束之后</span></span><br><span class="line">  afterAll(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  describe(<span class="string">'测试增加相关代码'</span>,()=&gt;&#123;</span><br><span class="line">    test(<span class="string">'测试 Conter 中的 addOne 方法'</span>, () =&gt; &#123;</span><br><span class="line">      couter.addOne();</span><br><span class="line">      expect(couter.number).toBe(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    test(<span class="string">'测试 Conter 中的 addTwo 方法'</span>, () =&gt; &#123;</span><br><span class="line">      couter.addTwo();</span><br><span class="line">      expect(couter.number).toBe(<span class="number">2</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  describe(<span class="string">'测试减少相关代码'</span>,()=&gt;&#123;</span><br><span class="line">    test(<span class="string">'测试 Conter 中的 minusOne 方法'</span>, () =&gt; &#123;</span><br><span class="line">      couter.minusOne();</span><br><span class="line">      expect(couter.number).toBe(<span class="number">-1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  </span><br><span class="line">    test(<span class="string">'测试 Conter 中的 minusTwo 方法'</span>, () =&gt; &#123;</span><br><span class="line">      couter.minusTwo();</span><br><span class="line">      expect(couter.number).toBe(<span class="number">-2</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>describe 里面就是一个作用域，嵌套作用域可以有多个钩子函数，钩子函数执行顺序由外到内</p><p><code>test.only</code>，只执行某个测试用例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'测试减少相关代码'</span>,()=&gt;&#123;</span><br><span class="line">  test.only(<span class="string">'测试 Conter 中的 minusOne 方法'</span>, () =&gt; &#123;</span><br><span class="line">    couter.minusOne();</span><br><span class="line">    expect(couter.number).toBe(<span class="number">-1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'测试 Conter 中的 minusTwo 方法'</span>, () =&gt; &#123;</span><br><span class="line">    couter.minusTwo();</span><br><span class="line">    expect(couter.number).toBe(<span class="number">-2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h3><ol><li>捕获函数的调用，this 指向，调用顺序</li><li>自由设置返回结果</li><li>改变内部函数的实现</li></ol><h4 id="基本模拟-导入函数"><a href="#基本模拟-导入函数" class="headerlink" title="基本模拟-导入函数"></a>基本模拟-导入函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo</span></span><br><span class="line"><span class="keyword">const</span> runCallback = <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> runCallback</span><br><span class="line"></span><br><span class="line"><span class="comment">//demo.test.js</span></span><br><span class="line"><span class="keyword">import</span> runCallback <span class="keyword">from</span> <span class="string">'./demo'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'测试 runCallback 方法'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'runCallback被调用,并只调用了一次'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="comment">// mock 函数，捕获函数的调用</span></span><br><span class="line">    <span class="keyword">const</span> func = jest.fn();</span><br><span class="line">    <span class="comment">// 方法返回一次 值 Haha，mockReturnValue则是都返回，也可以在 jest.fn(()=&gt;&#123;return 'Haha'&#125;)定义</span></span><br><span class="line">    func.mockReturnValueOnce(<span class="string">'Haha'</span>)</span><br><span class="line">    runCallback(func)</span><br><span class="line">    expect(func).toBeCalled()</span><br><span class="line">    expect(func.mock.calls.length).toBe(<span class="number">1</span>)</span><br><span class="line">    expect(func.mock.results[<span class="number">0</span>].value).toBe(<span class="string">'Haha'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(func.mock)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  ● Console</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    console.log src/lesson2/demo.test.js:14</span></span><br><span class="line"><span class="comment">      &#123; calls: [ [] ],</span></span><br><span class="line"><span class="comment">        instances: [ undefined ],</span></span><br><span class="line"><span class="comment">        invocationCallOrder: [ 1 ],</span></span><br><span class="line"><span class="comment">        results: [ &#123; type: 'return', value: 'Haha' &#125; ] &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="修改原来函数的返回"><a href="#修改原来函数的返回" class="headerlink" title="修改原来函数的返回"></a>修改原来函数的返回</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xx.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchData = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    axios.get(<span class="string">'/'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>res.data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (function()&#123;return '123' &#125;)()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> fetchData;</span><br><span class="line"><span class="comment">// xx.test.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fetchData <span class="keyword">from</span> <span class="string">'./xx.js'</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">ject.mock(<span class="string">'axios'</span>)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'fetchData 测试'</span>,()=&gt;&#123;</span><br><span class="line">    axios.get.mockResolvedValue(&#123;</span><br><span class="line">        data:<span class="string">"(function()&#123;return '123' &#125;)()"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> fetchData().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">        expect(<span class="built_in">eval</span>(data)).toEqual(<span class="string">'123'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="mocks-文件夹"><a href="#mocks-文件夹" class="headerlink" title="__mocks__文件夹"></a><code>__mocks__</code>文件夹</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __mock__/xx.js</span></span><br><span class="line"><span class="keyword">const</span> fetchData = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">"(function()&#123;return '123' &#125;)()"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着改测试，模拟函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xx.test.js</span></span><br><span class="line">jest.mock(<span class="string">'./xx'</span>)</span><br><span class="line"><span class="keyword">import</span> fetchData <span class="keyword">from</span> <span class="string">'./xx.js'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'fetchData 测试'</span>,()=&gt;&#123;</span><br><span class="line">    axios.get.mockResolvedValue(&#123;</span><br><span class="line">        data:<span class="string">"(function()&#123;return '123' &#125;)()"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> fetchData().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">        expect(<span class="built_in">eval</span>(data)).toEqual(<span class="string">'123'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述函数顶部那步模拟也可以通过在 jest.config.js 中修改配置 <code>automock：true</code> 改为自动模拟，那么引入对应的函数的时候就会自动去 <code>__mocks__</code>文件夹里面去寻找对应的模拟函数。注意一旦开启这个配置，需要启动才会生效，另外也会导致很多测试需要重新修改。</p><h4 id="同时存在-mocks-以及导入函数"><a href="#同时存在-mocks-以及导入函数" class="headerlink" title="同时存在__mocks__以及导入函数"></a>同时存在<code>__mocks__</code>以及导入函数</h4><p>在原来 xx.js 基础上面新增 一个 <code>getNumber</code>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">xx.js</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchData = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    axios.get(<span class="string">'/'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>res.data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (function()&#123;return '123' &#125;)()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getNumber = <span class="function"><span class="params">()</span>=&gt;</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">fetchData,</span><br><span class="line">    getNumber</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着修改测试用例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xx.test.js</span></span><br><span class="line">jest.mock(<span class="string">'./xx'</span>)</span><br><span class="line"><span class="keyword">import</span> fetchData <span class="keyword">from</span> <span class="string">'./xx.js'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'fetchData 测试'</span>,()=&gt;&#123;</span><br><span class="line">    axios.get.mockResolvedValue(&#123;</span><br><span class="line">        data:<span class="string">"(function()&#123;return '123' &#125;)()"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> fetchData().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">        expect(<span class="built_in">eval</span>(data)).toEqual(<span class="string">'123'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">test(<span class="string">'getNumber 测试'</span>,()=&gt;&#123;</span><br><span class="line">expect(getNumber()).toBe(<span class="number">123</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述代码会报错，<code>getNumebr</code> 找不到对应的函数，因为测试用例还是会去<code>__mocks__</code> 文件夹去寻找 <code>getNumber</code>。但是我们只希望模拟异步的函数，对于同步函数希望通过导入的方式来测试，那么就从原来的js文件中导入 <code>getNumber</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xx.test.js</span></span><br><span class="line">jest.mock(<span class="string">'./xx'</span>)</span><br><span class="line"><span class="keyword">import</span> fetchData <span class="keyword">from</span> <span class="string">'./xx.js'</span></span><br><span class="line"><span class="keyword">const</span> &#123; getNumber &#125; = jest.requireActual(<span class="string">'./xx'</span>)</span><br><span class="line">test(<span class="string">'fetchData 测试'</span>,()=&gt;&#123;</span><br><span class="line">    axios.get.mockResolvedValue(&#123;</span><br><span class="line">        data:<span class="string">"(function()&#123;return '123' &#125;)()"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> fetchData().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">        expect(<span class="built_in">eval</span>(data)).toEqual(<span class="string">'123'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">test(<span class="string">'getNumber 测试'</span>,()=&gt;&#123;</span><br><span class="line">expect(getNumber()).toBe(<span class="number">123</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Mock-Timer"><a href="#Mock-Timer" class="headerlink" title="Mock Timer"></a>Mock Timer</h3><p>写一个 setTimeout 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timer.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (cb)=&gt;&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    cb()</span><br><span class="line">  &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timer.test.js</span></span><br><span class="line"><span class="keyword">import</span> timer <span class="keyword">from</span> <span class="string">'./timer'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'timer 测试'</span>,(done)=&gt;&#123;</span><br><span class="line">  timer(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    expect(<span class="number">2</span>).toBe(<span class="number">1</span>)</span><br><span class="line">    done();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的测试用例会直接通过， <code>timer</code>是一个异步函数，并不会执行函数体内的内容，需要像之前的异步函数一样，加个 done 参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timer <span class="keyword">from</span> <span class="string">'./timer'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'timer 测试'</span>,(done)=&gt;&#123;</span><br><span class="line">  timer(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    expect(<span class="number">2</span>).toBe(<span class="number">1</span>)</span><br><span class="line">    done();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接着测试用例便会运行，并报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">FAIL  src/lesson3/timer.test.js (7.997s)</span><br><span class="line"> ● Console</span><br><span class="line"></span><br><span class="line">   console.error node_modules/_jsdom@11.12.0@jsdom/lib/jsdom/virtual-console.js:29</span><br><span class="line">     Error: Uncaught [Error: expect(received).toBe(expected) // Object.is equality</span><br><span class="line">     </span><br><span class="line">     Expected: 1</span><br><span class="line">     Received: 2]</span><br><span class="line">         at reportException (F:\赖彬鸿\git-project\usual\Egret-Project\FontendTest\node_modules\_jsdom@11.12.0@jsdom\lib\jsdom\living\helpers\runtime-script-errors.js:66:24)</span><br><span class="line">         at Timeout.callback [as _onTimeout] (F:\赖彬鸿\git-project\usual\Egret-Project\FontendTest\node_modules\_jsdom@11.12.0@jsdom\lib\jsdom\browser\Window.js:680:7)</span><br><span class="line">         at ontimeout (timers.js:436:11)</span><br><span class="line">         at tryOnTimeout (timers.js:300:5)</span><br><span class="line">         at listOnTimeout (timers.js:263:5)</span><br><span class="line">         at Timer.processTimers (timers.js:223:10) &#123; Error: expect(received).toBe(expected) // Object.is equality</span><br><span class="line">     </span><br><span class="line">     Expected: 1</span><br><span class="line">     Received: 2</span><br><span class="line">         at toBe (F:\赖彬鸿\git-project\usual\Egret-Project\FontendTest\src\lesson3\timer.test.js:5:15)</span><br><span class="line">         at cb (F:\赖彬鸿\git-project\usual\Egret-Project\FontendTest\src\lesson3\timer.js:3:5)</span><br><span class="line">         at Timeout.callback [as _onTimeout] (F:\赖彬鸿\git-project\usual\Egret-Project\FontendTest\node_modules\_jsdom@11.12.0@jsdom\lib\jsdom\browser\Window.js:678:19)</span><br><span class="line">         at ontimeout (timers.js:436:11)</span><br><span class="line">         at tryOnTimeout (timers.js:300:5)</span><br><span class="line">         at listOnTimeout (timers.js:263:5)</span><br><span class="line">         at Timer.processTimers (timers.js:223:10)</span><br><span class="line">       matcherResult:</span><br><span class="line">        &#123; actual: 2,</span><br><span class="line">          expected: 1,</span><br><span class="line">          message: [Function],</span><br><span class="line">          name: 'toBe',</span><br><span class="line">          pass: false &#125; &#125;</span><br></pre></td></tr></table></figure><p>也可以通过模拟 timer 这类异步函数，来达到目的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timer.test.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> timer <span class="keyword">from</span> <span class="string">'./timer'</span></span><br><span class="line"><span class="comment">// mock timer</span></span><br><span class="line">jest.useFakeTimers()</span><br><span class="line">test(<span class="string">'timer 测试'</span>,()=&gt;&#123;    </span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn();</span><br><span class="line">  timer(fn)</span><br><span class="line">  <span class="comment">// 快速运行所有Timer</span></span><br><span class="line">  jest.runAllTimers();</span><br><span class="line">  expect(fn).toHaveBeenCalledTimes(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于嵌套 timer 异步函数，<code>jest.runOnlyPendingTimers</code>可以让只最外层的第一个 timer 运行。</p><p>另外还有快进时间的api,<code>jest.advanceTimersByTime(n)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timer.test.js</span></span><br><span class="line"><span class="keyword">import</span> timer <span class="keyword">from</span> <span class="string">'./timer'</span></span><br><span class="line"></span><br><span class="line">jest.useFakeTimers()</span><br><span class="line">test(<span class="string">'timer 测试'</span>,()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn();</span><br><span class="line">  timer(fn)</span><br><span class="line">  jest.advanceTimersByTime(<span class="number">3000</span>)</span><br><span class="line">  expect(fn).toHaveBeenCalledTimes(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>嵌套 timer 的测试用例结合 钩子<code>beforeEach</code>以及两个上面讲的api的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timer.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (cb)=&gt;&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    cb()</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      cb()</span><br><span class="line">    &#125;,<span class="number">3000</span>)    </span><br><span class="line">  &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// timer.test.js</span></span><br><span class="line"><span class="keyword">import</span> timer <span class="keyword">from</span> <span class="string">'./timer'</span></span><br><span class="line"></span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  jest.useFakeTimers()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test(<span class="string">'timer 测试-runAllTimers'</span>,()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn();</span><br><span class="line">  timer(fn)</span><br><span class="line">  jest.runAllTimers();</span><br><span class="line">  expect(fn).toHaveBeenCalledTimes(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line">test(<span class="string">'timer 测试-advanceTimersByTime'</span>,()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn();</span><br><span class="line">  timer(fn)</span><br><span class="line">  jest.advanceTimersByTime(<span class="number">3000</span>)</span><br><span class="line">  expect(fn).toHaveBeenCalledTimes(<span class="number">1</span>)</span><br><span class="line">  jest.advanceTimersByTime(<span class="number">3000</span>)</span><br><span class="line">  expect(fn).toHaveBeenCalledTimes(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Mock-Funtions"><a href="#Mock-Funtions" class="headerlink" title="Mock Funtions"></a>Mock Funtions</h3><p>Mock 函数可以轻松测试代码之间的连接——实现方式包括：擦除函数实际实现、捕获对函数的调用（以及在这些调用中传递的参数）、在使用 <code>new</code> 实例化时捕获构造函数的实例，允许测试时配置返回值</p><h4 id="模拟函数"><a href="#模拟函数" class="headerlink" title="模拟函数"></a>模拟函数</h4><p>测试函数 <code>forEach</code>的内部实现，这个函数为传入的数组中的每个元素调用一次回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">items,callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> index=<span class="number">0</span>;index&lt;items.length;index+=<span class="number">1</span>)&#123;</span><br><span class="line">        callback(item[index])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了测试此函数，可以使用一个 mock 函数，然后检查 mock 函数的状态来确保回调函数如期调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mockCallback = jest.fn(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">42</span> + x);</span><br><span class="line">forEach([<span class="number">0</span>, <span class="number">1</span>], mockCallback)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此mock函数被调用了两次</span></span><br><span class="line">expect(mockCallback.mock.calls.length).toBe(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(mockCallback)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      &#123; </span></span><br><span class="line"><span class="comment">      [Function: mockConstructor]</span></span><br><span class="line"><span class="comment">        _isMockFunction: true,</span></span><br><span class="line"><span class="comment">        getMockImplementation: [Function],</span></span><br><span class="line"><span class="comment">        mock: [Getter/Setter],</span></span><br><span class="line"><span class="comment">        mockClear: [Function],</span></span><br><span class="line"><span class="comment">        mockReset: [Function],</span></span><br><span class="line"><span class="comment">        mockRestore: [Function],</span></span><br><span class="line"><span class="comment">        mockReturnValueOnce: [Function],</span></span><br><span class="line"><span class="comment">        mockResolvedValueOnce: [Function],</span></span><br><span class="line"><span class="comment">        mockRejectedValueOnce: [Function],</span></span><br><span class="line"><span class="comment">        mockReturnValue: [Function],</span></span><br><span class="line"><span class="comment">        mockResolvedValue: [Function],</span></span><br><span class="line"><span class="comment">        mockRejectedValue: [Function],</span></span><br><span class="line"><span class="comment">        mockImplementationOnce: [Function],</span></span><br><span class="line"><span class="comment">        mockImplementation: [Function],</span></span><br><span class="line"><span class="comment">        mockReturnThis: [Function],</span></span><br><span class="line"><span class="comment">        mockName: [Function],</span></span><br><span class="line"><span class="comment">        getMockName: [Function] </span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次调用函数时的第一个参数是 0</span></span><br><span class="line">expect(mockCallback.mock.calls[<span class="number">0</span>][<span class="number">0</span>]).toBe(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(mockCallback.mock)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      &#123; </span></span><br><span class="line"><span class="comment">      calls: [ [ 0 ], [ 1 ] ],</span></span><br><span class="line"><span class="comment">        instances: [ undefined, undefined ],</span></span><br><span class="line"><span class="comment">        invocationCallOrder: [ 1, 2 ],</span></span><br><span class="line"><span class="comment">        results:</span></span><br><span class="line"><span class="comment">         [ &#123; type: 'return', value: 42 &#125;, &#123; type: 'return', value: 43 &#125; ] </span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 第二次调用函数时的第一个参数是1</span></span><br><span class="line">expect(mockCallback.mock.calls[<span class="number">1</span>][<span class="number">0</span>]).toBe(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次函数调用的返回值是 42</span></span><br><span class="line">expect(mockCallback.mock.results[<span class="number">0</span>].value).toBe(<span class="number">42</span>)</span><br></pre></td></tr></table></figure><h4 id="mock属性"><a href="#mock属性" class="headerlink" title=".mock属性"></a><code>.mock</code>属性</h4><p>所有 mock 函数都有这个特殊的 <code>.mock</code>属性，它保存了关于此函数如何调用、调用时的返回值的信息。<code>.mock</code>属性还追踪每次调用时 <code>this</code>的值，所以我们同样也可以检视（inspect）<code>this</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMock = jest.fn();</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> myMock();</span><br><span class="line"><span class="keyword">const</span> b = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> bound = myMock.bind(b)</span><br><span class="line">bound();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myMock.mock.instances)</span><br><span class="line"><span class="comment">// [ mockConstructor &#123;&#125;, &#123;&#125; ]</span></span><br></pre></td></tr></table></figure><h4 id="模拟返回值"><a href="#模拟返回值" class="headerlink" title="模拟返回值"></a>模拟返回值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMock = jest.fn();</span><br><span class="line"><span class="built_in">console</span>.log(myMock())</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">myMock</span><br><span class="line">    .mockReturnValueOnce(<span class="number">10</span>)</span><br><span class="line">.mockReturnValueOnce(<span class="string">'x'</span>)</span><br><span class="line">.mockReturnValue(<span class="literal">true</span>)</span><br><span class="line"><span class="built_in">console</span>.log(myMock(), myMock(), myMock(), myMock());</span><br><span class="line"><span class="comment">// 10, 'x', true, true</span></span><br></pre></td></tr></table></figure><p>结合一些函数灵活模拟</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filterTestFn = jest.fn();</span><br><span class="line"></span><br><span class="line">filterTestFn.mockReturnValueOnce(<span class="literal">true</span>).mockReturnValueOnce(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = [<span class="number">11</span>,<span class="number">12</span>].filter(filterTestFn)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="comment">// [11]</span></span><br><span class="line"><span class="built_in">console</span>.log(filterTestFn.mock.calls)</span><br><span class="line"><span class="comment">// [[11],[12]]</span></span><br></pre></td></tr></table></figure><h4 id="模拟模块"><a href="#模拟模块" class="headerlink" title="模拟模块"></a>模拟模块</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// users.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Users</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> call()&#123;</span><br><span class="line">        <span class="keyword">return</span> axios.get(<span class="string">'/user.json'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>res.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Users</span><br></pre></td></tr></table></figure><p>模拟 axios.get 返回一个假的 response</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// users.test.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">import</span> Users <span class="keyword">from</span> <span class="string">'./users'</span>;</span><br><span class="line"></span><br><span class="line">jest.mock(axios);</span><br><span class="line">test(<span class="string">'should fetch users'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> users = [&#123;<span class="attr">name</span>:<span class="string">'Bob'</span>&#125;]</span><br><span class="line">    <span class="keyword">const</span> res = &#123;<span class="attr">data</span>:users&#125;</span><br><span class="line">    axios.get.mockResolvedValue(res)</span><br><span class="line">    <span class="keyword">return</span> Users.all().then(<span class="function"><span class="params">data</span>=&gt;</span>expect(data).toEqual(users))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h4><p>通过模拟函数 <code>jest.fn</code>或者<code>mockImplementationOnce</code>方法来完成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMockFn = jest.fn(<span class="function"><span class="params">cb</span>=&gt;</span> cb(<span class="literal">null</span>,<span class="literal">true</span>))</span><br><span class="line"></span><br><span class="line">myMockFn(<span class="function">(<span class="params">err,val</span>)=&gt;</span><span class="built_in">console</span>.log(val))</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>mockImplementation</code>当您需要定义从另一个模块创建的模拟函数的默认实现时，该方法很有用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// some implementation</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test.js</span></span><br><span class="line"></span><br><span class="line">jest.mock(<span class="string">'../foo'</span>) <span class="comment">//  这个会自动模拟</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">'../foo'</span>)</span><br><span class="line"></span><br><span class="line">foo.mockImplementation(<span class="function"><span class="params">()</span>=&gt;</span><span class="number">42</span>)</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>当需要重新创建模拟函数的复杂行为，以便多个函数调用产生不同的结果时，可以使用 <code>mockImplementationOnce</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMockFn = jest</span><br><span class="line">.fn()</span><br><span class="line">.mockImplementationOnce(<span class="function"><span class="params">cb</span> =&gt;</span> cb(<span class="literal">null</span>,<span class="literal">true</span>))</span><br><span class="line">.mockImplementationOnce(<span class="function"><span class="params">cb</span> =&gt;</span> cb(<span class="literal">null</span>,fase))</span><br><span class="line">myMockFn(<span class="function">(<span class="params">err, val</span>) =&gt;</span> <span class="built_in">console</span>.log(val));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">myMockFn(<span class="function">(<span class="params">err, val</span>) =&gt;</span> <span class="built_in">console</span>.log(val));</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>.mockReturnThis()</code>返回 this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123;</span><br><span class="line">    myMethod: jest.fn().mockReturnThis(),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 与下面实现相同</span></span><br><span class="line"><span class="keyword">const</span> otherObj = &#123;</span><br><span class="line">    myMethod: jest.fn(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模拟函数名称"><a href="#模拟函数名称" class="headerlink" title="模拟函数名称"></a>模拟函数名称</h4><p>选择为模拟函数提供一个名称，改名称将在测试错误输出中显示，而不是 <code>jest.fn()</code>，使用这个可以快速识别在测试输出中报告错误的模拟函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMockFn = jest</span><br><span class="line">.fn()</span><br><span class="line">.mockReturnValue(<span class="string">'default'</span>)</span><br><span class="line">.mockImplementation(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">42</span>)</span><br><span class="line">.mockName(<span class="string">'add42'</span>)</span><br></pre></td></tr></table></figure><h3 id="Snapshot快照"><a href="#Snapshot快照" class="headerlink" title="Snapshot快照"></a>Snapshot快照</h3><p>适合测试配置文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xx.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> generateConfig = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    server:<span class="string">'http://localhost'</span>,</span><br><span class="line">    port:<span class="number">8080</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//xx.test.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; generateConfig &#125; <span class="keyword">from</span> <span class="string">'./snopshot'</span>;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'测试 generateConfig 函数'</span>,()=&gt;&#123;</span><br><span class="line">  expect(generateConfig()).toMatchSnapshot();</span><br><span class="line">  expect(generateConfig()).toEqual(&#123;</span><br><span class="line">    server:<span class="string">'http://localhost'</span>,</span><br><span class="line">    port:<span class="number">8080</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>jest --watchAll</code>里面出现了 <code>u</code>、<code>i</code>模式分别对应 更新所有的快照跟更新单个快照</p><p>安装 <code>prettier</code>,运行 <code>toMatchInlineSnapshot</code>，会将 快照自动存到代码下面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'测试 generateConfig 函数'</span>, () =&gt; &#123;</span><br><span class="line">  expect(generateConfig()).toMatchInlineSnapshot(</span><br><span class="line">    &#123;</span><br><span class="line">      time: expect.any(<span class="built_in">Date</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 下面是自动生成的</span></span><br><span class="line">    <span class="string">`</span></span><br><span class="line"><span class="string">    Object &#123;</span></span><br><span class="line"><span class="string">      "port": 8080,</span></span><br><span class="line"><span class="string">      "server": "http://localhost",</span></span><br><span class="line"><span class="string">      "time": Any&lt;Date&gt;,</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="ES6-类"><a href="#ES6-类" class="headerlink" title="ES6 类"></a>ES6 类</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util.js</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">  init()&#123;&#125;</span><br><span class="line">  a()&#123;</span><br><span class="line">    <span class="comment">// 异常复杂</span></span><br><span class="line">  &#125;</span><br><span class="line">  b()&#123;</span><br><span class="line">    <span class="comment">// 异常复杂</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Util;</span><br></pre></td></tr></table></figure><p>在别的函数里面使用这个类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useUtil.js</span></span><br><span class="line"><span class="keyword">import</span> Util <span class="keyword">from</span> <span class="string">'./util'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useUtil = <span class="function">(<span class="params">a,b</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> util = <span class="keyword">new</span> Util()</span><br><span class="line">  util.a(a)</span><br><span class="line">  util.b(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useUtil;</span><br></pre></td></tr></table></figure><p>写这个使用类的函数的测试用例的时候，我们会发现这个函数因为使用到了类里面的函数，而函数又很复杂，直接调用会损耗性能。所以这里我们用几种方法来模拟</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useUtil.test.js</span></span><br><span class="line">jest.mock(<span class="string">'./util'</span>)</span><br><span class="line"><span class="comment">// jest.mock 发现 util 是一个类，会自动把类的构造函数方法变成 jest.fn()</span></span><br><span class="line"><span class="comment">// const Util = jest.fn();</span></span><br><span class="line"><span class="comment">// Util.a = jest.fn()</span></span><br><span class="line"><span class="comment">// Util.b = jest.fn()</span></span><br><span class="line"><span class="keyword">import</span> Util <span class="keyword">from</span> <span class="string">'./util'</span></span><br><span class="line"><span class="keyword">import</span> useUtil <span class="keyword">from</span> <span class="string">'./useUtil'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'测试 useUtil'</span>,()=&gt;&#123;</span><br><span class="line">  useUtil();</span><br><span class="line">  expect(Util).toHaveBeenCalled();</span><br><span class="line">  <span class="built_in">console</span>.log(Util.mock)</span><br><span class="line">  expect(Util.mock.instances[<span class="number">0</span>].a).toHaveBeenCalled()</span><br><span class="line">  expect(Util.mock.instances[<span class="number">0</span>].b).toHaveBeenCalled()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  ● Console</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    console.log src/lesson3/useUtil.test.js:12</span></span><br><span class="line"><span class="comment">      &#123; calls: [ [] ],</span></span><br><span class="line"><span class="comment">        instances: [ Util &#123; init: [Function], a: [Function], b: [Function] &#125; ],</span></span><br><span class="line"><span class="comment">        invocationCallOrder: [ 1 ],</span></span><br><span class="line"><span class="comment">        results: [ &#123; type: 'return', value: undefined &#125; ] &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>另一种方法就是通过在 <code>__mocks__</code>文件夹中模拟</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __mocks__/util.js</span></span><br><span class="line"><span class="keyword">const</span> Util = jest.fn();</span><br><span class="line">Util.prototype = jest.fn();</span><br><span class="line">Util.prototype = jest.fn();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Util</span><br></pre></td></tr></table></figure><p>还有一种写法，是在原来的测试用例修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useUtil.test.js</span></span><br><span class="line">jest.mock(<span class="string">'./util'</span>,()=&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> Util = jest.fn();</span><br><span class="line">    Util.prototype = jest.fn();</span><br><span class="line">    Util.prototype = jest.fn();</span><br><span class="line">    <span class="keyword">return</span> Util;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dom.js</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addDivToBody = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">    $(<span class="string">'body'</span>).append(<span class="string">'&lt;div/&gt;'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> addDivToBody</span><br><span class="line"></span><br><span class="line"><span class="comment">// dom.test.js</span></span><br><span class="line"><span class="comment">// node 本身不具备 dom</span></span><br><span class="line"><span class="comment">// jest 在 node 环境下模拟了一套 dom 的 api,jsDom</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span></span><br><span class="line"><span class="keyword">import</span> addDivToBody <span class="keyword">from</span> addDivToBody;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'测试 addDivToBody'</span>,()=&gt;&#123;</span><br><span class="line">    addDivToBody();</span><br><span class="line">    expect($(<span class="string">'body'</span>).find(<span class="string">'div'</span>).length).toBe(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="TDD（测试驱动开发）"><a href="#TDD（测试驱动开发）" class="headerlink" title="TDD（测试驱动开发）"></a>TDD（测试驱动开发）</h2><p>全称：Test Driven Development</p><h3 id="开发流程（Red-Green-Development）"><a href="#开发流程（Red-Green-Development）" class="headerlink" title="开发流程（Red-Green Development）"></a>开发流程（Red-Green Development）</h3><ol><li>编写测试用例</li><li>运行测试，测试用例无法通过测试</li><li>编写代码，使测试用例通过测试</li><li>优化代码，完成开发</li><li>重复上述步骤</li></ol><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol><li>长期减少回归 bug</li><li>代码质量更好（组织、可维护性）</li><li>测试覆盖率高</li><li>错误测试代码不容易出现</li></ol><h3 id="Vue-TDD"><a href="#Vue-TDD" class="headerlink" title="Vue TDD"></a>Vue TDD</h3><p>开始</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装脚手架</span></span><br><span class="line">npm i @vue/cli@3.8.4 -g</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装vue,可以选择默认配置，也可以自定义配置</span></span><br><span class="line">vue create vue-jest</span><br></pre></td></tr></table></figure><h4 id="vue-test-utils"><a href="#vue-test-utils" class="headerlink" title="@vue/test-utils"></a>@vue/test-utils</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorld.test.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; shallowMount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'@/components/HelloWorld.vue'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'HelloWorld.vue'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">/** 如果不使用 @vue/test-utils</span></span><br><span class="line"><span class="comment">   * import Vue from 'vue'</span></span><br><span class="line"><span class="comment">   *   it('renders props.msg when passed', () =&gt; &#123;</span></span><br><span class="line"><span class="comment">  const root = document.createElement('div')</span></span><br><span class="line"><span class="comment">  root.className = 'root'</span></span><br><span class="line"><span class="comment">  document.body.appendChild(root)</span></span><br><span class="line"><span class="comment">  new Vue(&#123;</span></span><br><span class="line"><span class="comment">    render: h =&gt; h(HelloWorld, &#123;</span></span><br><span class="line"><span class="comment">      props: &#123;</span></span><br><span class="line"><span class="comment">        msg: 'laibh'</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;)</span></span><br><span class="line"><span class="comment">  &#125;).$mount('.root')</span></span><br><span class="line"><span class="comment">  expect(document.getElementsByClassName('hello').length).toBe(1)</span></span><br><span class="line"><span class="comment">  &#125;)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">const</span> msg = <span class="string">'new message'</span></span><br><span class="line">  <span class="keyword">const</span> wrapper = shallowMount(HelloWorld, &#123;</span><br><span class="line">    propsData: &#123; msg &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  expect(wrapper.text()).toMatch(msg)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>shallowMount</code>浅层渲染，只渲染第一层，不渲染子组件，适合单元测试</p><p><code>mount</code>则会渲染子组件，适合集成测试</p><h4 id="开发-Header-组件"><a href="#开发-Header-组件" class="headerlink" title="开发 Header 组件"></a>开发 Header 组件</h4><p>测试用例先行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Header.test.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; shallowMount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'@/components/Header/Header.vue'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'测试 Header 组件'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'Header 包含 Input 框'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(Header)</span><br><span class="line">    <span class="keyword">const</span> input = wrapper.find(<span class="string">'[data-test="input"]'</span>)</span><br><span class="line">    expect(input.exists()).toBe(<span class="literal">true</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">'Header 中 Input 初始内容为空'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(Header)</span><br><span class="line">    <span class="keyword">const</span> inputValue = wrapper.vm.$data.inputValue</span><br><span class="line">    expect(inputValue).toBe(<span class="string">''</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'Header 中 Input 框值发生变化，值应该也跟着改变'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(Header)</span><br><span class="line">    <span class="keyword">const</span> input = wrapper.find(<span class="string">'[data-test="input"]'</span>)</span><br><span class="line">    input.setValue(<span class="string">'laibh'</span>)</span><br><span class="line">    <span class="keyword">const</span> inputValue = wrapper.vm.$data.inputValue</span><br><span class="line">    expect(inputValue).toBe(<span class="string">'laibh'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'Header 中 Input 框输入回车，无内容时无反应'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(Header)</span><br><span class="line">    <span class="keyword">const</span> input = wrapper.find(<span class="string">'[data-test="input"]'</span>)</span><br><span class="line">    input.setValue(<span class="string">''</span>)</span><br><span class="line">    input.trigger(<span class="string">'keyup.enter'</span>)</span><br><span class="line">    expect(wrapper.emitted().add).toBeFalsy()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'Header 中 Input 框输入回车，有内容时向外触发事件,同时清空 inputValue'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(Header)</span><br><span class="line">    <span class="keyword">const</span> input = wrapper.find(<span class="string">'[data-test="input"]'</span>)</span><br><span class="line">    input.setValue(<span class="string">'laibh'</span>)</span><br><span class="line">    input.trigger(<span class="string">'keyup.enter'</span>)</span><br><span class="line">    expect(wrapper.emitted().add).toBeTruthy()</span><br><span class="line">    expect(wrapper.vm.$data.inputValue).toBe(<span class="string">''</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>根据测试用例写代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// Header.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input data-test=&quot;input&quot; v-model=&quot;inputValue&quot; @keyup.enter=&quot;addTodoItem&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Header&quot;,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      inputValue: &quot;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addTodoItem() &#123;</span><br><span class="line">      if (this.inputValue) &#123;</span><br><span class="line">        this.$emit(&quot;add&quot;, this.inputValue);</span><br><span class="line">        this.inputValue = &quot;&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang=&quot;less&quot;&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jest.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    collectCoverageFrom: [<span class="string">'**/*.&#123;js,vue&#125;'</span>, <span class="string">'!**/node_modules/**'</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package.json</span></span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test:cov"</span>: <span class="string">"vue-cli-service test:unit --coverage"</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="React-TDD"><a href="#React-TDD" class="headerlink" title="React TDD"></a>React TDD</h3><h4 id="Enzyme"><a href="#Enzyme" class="headerlink" title="Enzyme"></a>Enzyme</h4><p><a href="https://github.com/airbnb/enzyme">github</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 </span></span><br><span class="line">npm i --save-dev enzyme enzyme-adapter-react-16</span><br></pre></td></tr></table></figure><p>同样，<code>shallow</code>适合单元测试，<code>mount</code>则是集成测试</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.je</span></span><br><span class="line"><span class="keyword">import</span> React from <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">App</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">     <span class="comment">// 使用的data-test=xxx 等属性可以做到解耦，不会因为改变样式名而发生改变，另外也不会被hash掉</span></span><br><span class="line">    &lt;div className=<span class="string">"app-container"</span> title=<span class="string">"laibh"</span> data-test=<span class="string">"container"</span>&gt;</span><br><span class="line">      hello world</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> App;</span><br><span class="line"><span class="comment">// App.test.js</span></span><br><span class="line"><span class="keyword">import</span> React from <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> App from <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> Enzyme, &#123; shallow &#125; from <span class="string">'enzyme'</span>;</span><br><span class="line"><span class="keyword">import</span> Adapter from <span class="string">'enzyme-adapter-react-16'</span>;</span><br><span class="line">Enzyme.configure(&#123; adapter: <span class="keyword">new</span> Adapter() &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">it(<span class="string">'renders without crashing'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = shallow(&lt;App /&gt;)</span><br><span class="line">  <span class="comment">// 输出整个内容字符串</span></span><br><span class="line">  console.log(wrapper.debug())</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    &lt;div className="app-container" title="laibh" data-test="container"&gt;</span></span><br><span class="line"><span class="comment">      hello world</span></span><br><span class="line"><span class="comment">    &lt;/div&gt;  </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  expect(wrapper.find(<span class="string">'[data-test="container"]'</span>).length).toBe(<span class="number">1</span>)</span><br><span class="line">  expect(wrapper.find(<span class="string">'[data-test="container"]'</span>).prop(<span class="string">'title'</span>)).toBe(<span class="string">'laibh'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>另外它海域一些扩展 API，例如 <a href="https://github.com/FormidableLabs/enzyme-matchers/tree/master/packages/jest-enzyme">jest-enzyme</a>，让语法易懂简洁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.test.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> Enzyme, &#123; shallow &#125; <span class="keyword">from</span> <span class="string">'enzyme'</span>;</span><br><span class="line"><span class="keyword">import</span> Adapter <span class="keyword">from</span> <span class="string">'enzyme-adapter-react-16'</span>;</span><br><span class="line">Enzyme.configure(&#123; <span class="attr">adapter</span>: <span class="keyword">new</span> Adapter() &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">it(<span class="string">'renders without crashing'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>)</span></span><br><span class="line"><span class="xml">  console.log(wrapper.debug())</span></span><br><span class="line"><span class="xml">  const container = wrapper.find('[data-test="container"]')</span></span><br><span class="line"><span class="xml">  expect(container.length).toBe(1)</span></span><br><span class="line"><span class="xml">  expect(container.prop('title')).toBe('laibh')</span></span><br><span class="line"><span class="xml">  // 等同上面两句</span></span><br><span class="line"><span class="xml">  expect(container).toExist()</span></span><br><span class="line"><span class="xml">  expect(container).toHaveProp('title', 'laibh')</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure><p>别忘记在 <code>jest.config.js</code>里面进行配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    setupFilesAfterEnv: [<span class="string">'./node_modules/jest-enzyme/lib/index.js'</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开发-Header-组件-1"><a href="#开发-Header-组件-1" class="headerlink" title="开发 Header 组件"></a>开发 Header 组件</h4><p>同样测试先行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'../../index'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; shallow &#125; <span class="keyword">from</span> <span class="string">'enzyme'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapper;</span><br><span class="line"><span class="keyword">let</span> inputElem;</span><br><span class="line">describe(<span class="string">'测试 Header 组件'</span>, () =&gt; &#123;</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span>)</span></span><br><span class="line"><span class="xml">    inputElem = wrapper.find('[data-test="input"]')</span></span><br><span class="line"><span class="xml">  &#125;)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('正常渲染', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    expect(wrapper).toMatchSnapshot()</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('包含一个 input', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    expect(inputElem).toExist()</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('input初始化内容应该为空', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    expect(inputElem.prop('value')).toBe('')</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('当用户输入时，input内容会跟着变化', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    const value = '哈哈哈'</span></span><br><span class="line"><span class="xml">    inputElem.simulate('change', &#123;</span></span><br><span class="line"><span class="xml">      target: &#123;</span></span><br><span class="line"><span class="xml">        value</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;)</span></span><br><span class="line"><span class="xml">    expect(wrapper.state('value')).toBe(value)</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('当用户输入后，键入回车，如果 input 没有内容，则不操作', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    const fn = jest.fn();</span></span><br><span class="line">    const wrapper = shallow(&lt;Header addUndoItem=&#123;fn&#125; /&gt;)</span><br><span class="line">    wrapper.setState(&#123; value: '' &#125;)</span><br><span class="line">    const inputElem = wrapper.find('[data-test="input"]')</span><br><span class="line">    inputElem.simulate('keyUp', &#123;</span><br><span class="line">      keyCode: 13</span><br><span class="line">    &#125;)</span><br><span class="line">    expect(fn).not.toBeCalled()</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it('当用户输入后，键入回车，如果 input 有内容，addUndoItem应该被调用,然后input被清空', () =&gt; &#123;</span><br><span class="line">    const fn = jest.fn();</span><br><span class="line">    const wrapper = shallow(&lt;Header addUndoItem=&#123;fn&#125; /&gt;)</span><br><span class="line">    const value = 'haha';</span><br><span class="line">    wrapper.setState(&#123; value &#125;)</span><br><span class="line">    const inputElem = wrapper.find('[data-test="input"]')</span><br><span class="line">    inputElem.simulate('keyUp', &#123;</span><br><span class="line">      keyCode: 13</span><br><span class="line">    &#125;)</span><br><span class="line">    expect(fn).toBeCalled()</span><br><span class="line">    expect(fn).toBeCalledWith(value)</span><br><span class="line">    const newInputElem = wrapper.find('[data-test="input"]')</span><br><span class="line">    expect(newInputElem.prop('value')).toBe('')</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>根据测试写代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./index.less'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInputKeyUp = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">const</span> &#123; addUndoItem &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">if</span> (e.keyCode === <span class="number">13</span> &amp;&amp; value) &#123;</span><br><span class="line">      addUndoItem(value)</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">value</span>: <span class="string">''</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInputChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">value</span>: e.target.value &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=&#123;styles.header&#125;&gt;</span><br><span class="line">        &lt;div className=&#123;styles.headerContent&#125;&gt;</span><br><span class="line">          TodoList</span><br><span class="line">        &lt;input</span><br><span class="line">            className=&#123;styles.headerInput&#125;</span><br><span class="line">            data-test=<span class="string">'input'</span></span><br><span class="line">            value=&#123;value&#125;</span><br><span class="line">            onChange=&#123;<span class="keyword">this</span>.handleInputChange&#125;</span><br><span class="line">            onKeyUp=&#123;<span class="keyword">this</span>.handleInputKeyUp&#125;</span><br><span class="line">            placeholder=<span class="string">'Add Todo'</span></span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Header;</span><br></pre></td></tr></table></figure><h3 id="TDD-小结"><a href="#TDD-小结" class="headerlink" title="TDD 小结"></a>TDD 小结</h3><p>优势：代码质量提高</p><p><code>单元测试</code></p><p>测试覆盖率高，业务耦合度高，代码量大，过于独立</p><h2 id="BDD（行为驱动开发）"><a href="#BDD（行为驱动开发）" class="headerlink" title="BDD（行为驱动开发）"></a>BDD（行为驱动开发）</h2><p>全称：Behavior Driven Development</p><h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue integration/todoList </span></span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">'../../TodoList'</span></span><br><span class="line"></span><br><span class="line">  it(<span class="string">`</span></span><br><span class="line"><span class="string">    1.用户会在 header输入框输入内容</span></span><br><span class="line"><span class="string">    2.用户会点击回车按钮</span></span><br><span class="line"><span class="string">    3.列表项应该增加用户输入内容的列表项</span></span><br><span class="line"><span class="string">  `</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">TodoList</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">      const inputElem = wrapper.findAll('[data-test="header-input"]').at(0)</span></span><br><span class="line"><span class="xml">      const content = 'haha'</span></span><br><span class="line"><span class="xml">      inputElem.setValue(content)</span></span><br><span class="line"><span class="xml">      inputElem.trigger('change')</span></span><br><span class="line"><span class="xml">      inputElem.trigger('keyup.enter')</span></span><br><span class="line"><span class="xml">      const listItems = wrapper.findAll('[data-test="list-item"]').at(0)</span></span><br><span class="line"><span class="xml">      expect(listItems.length).toBe(1)</span></span><br><span class="line"><span class="xml">      expect(listItems.at(0).text()).toContain(content)</span></span><br><span class="line"><span class="xml">    &#125;)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// react integration/todoList </span></span><br><span class="line"><span class="xml">import React from 'react';</span></span><br><span class="line"><span class="xml">import &#123; mount &#125; from 'enzyme';</span></span><br><span class="line"><span class="xml">import TodoList from './../../index';</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">describe('集成测试：TodoList', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">  let wrapper;</span></span><br><span class="line"><span class="xml">  beforeEach(() =&gt; &#123;</span></span><br><span class="line"><span class="xml">    wrapper = mount(<span class="tag">&lt;<span class="name">TodoList</span> /&gt;</span>)</span></span><br><span class="line"><span class="xml">  &#125;)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it(`</span></span><br><span class="line"><span class="xml">  1.用户会在 header输入框输入内容</span></span><br><span class="line"><span class="xml">  2.用户会点击回车按钮</span></span><br><span class="line"><span class="xml">  3.列表项应该增加用户输入内容的列表项</span></span><br><span class="line"><span class="xml">  `, () =&gt; &#123;</span></span><br><span class="line"><span class="xml">      const value = 'haha'</span></span><br><span class="line"><span class="xml">      const headerInput = wrapper.find('[data-test="header-input"]')</span></span><br><span class="line"><span class="xml">      headerInput.simulate('change', &#123;</span></span><br><span class="line"><span class="xml">        target: &#123;</span></span><br><span class="line"><span class="xml">          value</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">      &#125;)</span></span><br><span class="line"><span class="xml">      // 按下回车键，keyCode为13</span></span><br><span class="line"><span class="xml">      headerInput.simulate('keyUp', &#123;</span></span><br><span class="line"><span class="xml">        keyCode: 13</span></span><br><span class="line"><span class="xml">      &#125;)</span></span><br><span class="line"><span class="xml">      // undoListItem</span></span><br><span class="line"><span class="xml">      const listItems = wrapper.find('[data-test="list-item"]')</span></span><br><span class="line"><span class="xml">      expect(listItems.length).toBe(1)</span></span><br><span class="line"><span class="xml">      expect(listItems.at(0).text()).toContain(value)</span></span><br><span class="line"><span class="xml">    &#125;)</span></span><br><span class="line"><span class="xml">&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="TDD-与-BDD-比较"><a href="#TDD-与-BDD-比较" class="headerlink" title="TDD 与 BDD 比较"></a>TDD 与 BDD 比较</h3><p><strong>TDD</strong></p><ol><li>先写测试再写代码</li><li>一般结合单元测试使用，是白盒测试</li><li>测试重点在代码</li><li>安全感低</li><li>速度快</li></ol><p><strong>BDD</strong></p><ol><li>先写代码再写测试</li><li>一般结合集成测试使用，是黑盒测试</li><li>测试重点在 UI (DOM)</li><li>安全感高</li><li>速度慢</li></ol><h3 id="Redux相关测试"><a href="#Redux相关测试" class="headerlink" title="Redux相关测试"></a>Redux相关测试</h3><p>增加 redux 在项目</p><p><code>createStore</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/store/createStore</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; reducer <span class="keyword">as</span> todoReducer &#125; <span class="keyword">from</span> <span class="string">'../containers/TodoList/store'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  todo: todoReducer</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__());</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><p><code>store/actions.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CHANGE_INPUT_VALUE &#125; <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> changeInputValue = <span class="function"><span class="params">value</span> =&gt;</span> (&#123;</span><br><span class="line">  type: CHANGE_INPUT_VALUE,</span><br><span class="line">  value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>store/constants.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CHANGE_INPUT_VALUE = <span class="string">'CHANGE_INPUT_VALUE'</span></span><br></pre></td></tr></table></figure><p><code>store/reducer.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CHANGE_INPUT_VALUE &#125; <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  inputValue: <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = initialState, action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> CHANGE_INPUT_VALUE:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        inputValue: action.value</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>store/index.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducer'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./actions'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; reducer, actions &#125;</span><br></pre></td></tr></table></figure><p><code>TodoList/index.js</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'./../../components/Header/index'</span>;</span><br><span class="line"><span class="keyword">import</span> UndoList <span class="keyword">from</span> <span class="string">'./../../components/UndoList/index'</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./index.less'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      undoList: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handledeleteItem = <span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; undoList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">const</span> newList = undoList.filter(<span class="function">(<span class="params">item, itemIndex</span>) =&gt;</span> itemIndex !== index)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">undoList</span>: newList &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleStatusChange = <span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; undoList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="comment">// undoList.forEach((item, itemIndex) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   if (itemIndex === index) &#123;</span></span><br><span class="line">    <span class="comment">//     Object.assign(item, &#123; status: 'input' &#125;)</span></span><br><span class="line">    <span class="comment">//     return;</span></span><br><span class="line">    <span class="comment">//   &#125; Object.assign(item, &#123; status: 'div' &#125;)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="keyword">const</span> newList = undoList.map(<span class="function">(<span class="params">item, itemIndex</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (itemIndex === index) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          ...item,</span><br><span class="line">          status: <span class="string">'input'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">return</span> &#123;</span><br><span class="line">        ...item,</span><br><span class="line">        status: <span class="string">'div'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">undoList</span>: newList &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleBlur = <span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; undoList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">const</span> newList = undoList.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...item,</span><br><span class="line">        status: <span class="string">'div'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">undoList</span>: newList &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInputValue = <span class="function">(<span class="params">index, value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; undoList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">const</span> newList = undoList.map(<span class="function">(<span class="params">item, itemIndex</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (itemIndex === index) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          ...item,</span><br><span class="line">          value</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">return</span> &#123;</span><br><span class="line">        ...item,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">undoList</span>: newList &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  addUndoItem = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; undoList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      undoList: [...undoList, &#123;</span><br><span class="line">        status: <span class="string">'div'</span>,</span><br><span class="line">        value</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; undoList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=&#123;styles.todoList&#125;&gt;</span><br><span class="line">        &lt;Header addUndoItem=&#123;<span class="keyword">this</span>.addUndoItem&#125; /&gt;</span><br><span class="line">        &lt;UndoList</span><br><span class="line">          list=&#123;undoList&#125;</span><br><span class="line">          deleteItem=&#123;<span class="keyword">this</span>.handledeleteItem&#125;</span><br><span class="line">          changeStatus=&#123;<span class="keyword">this</span>.handleStatusChange&#125;</span><br><span class="line">          changeBlur=&#123;<span class="keyword">this</span>.handleBlur&#125;</span><br><span class="line">          valueChange=&#123;<span class="keyword">this</span>.handleInputValue&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default TodoList;</span></span><br></pre></td></tr></table></figure><p><code>src/index.js</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store/createStore'</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render((</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">), document.getElementById('root'));</span></span><br></pre></td></tr></table></figure><p>然后修改集成测试的测试用例</p><p><code>src/containers/TodoList/__test__/integration/TodoList.test.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'enzyme'</span>;</span><br><span class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">'./../../index'</span>;</span><br><span class="line"><span class="comment">// 增加的内容</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./../../../../store/createStore'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'集成测试：TodoList'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> wrapper;</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    wrapper = mount(</span><br><span class="line">      &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;TodoList /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  it(`</span></span><br><span class="line"><span class="regexp">  1.用户会在 header输入框输入内容</span></span><br><span class="line"><span class="regexp">  2.用户会点击回车按钮</span></span><br><span class="line"><span class="regexp">  3.列表项应该增加用户输入内容的列表项</span></span><br><span class="line"><span class="regexp">  `, () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      const value = 'haha'</span></span><br><span class="line"><span class="regexp">      const headerInput = wrapper.find('[data-test="header-input"]')</span></span><br><span class="line"><span class="regexp">      headerInput.simulate('change', &#123;</span></span><br><span class="line"><span class="regexp">        target: &#123;</span></span><br><span class="line"><span class="regexp">          value</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">      &#125;)</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 按下回车键，keyCode为13</span></span><br><span class="line"><span class="regexp">      headerInput.simulate('keyUp', &#123;</span></span><br><span class="line"><span class="regexp">        keyCode: 13</span></span><br><span class="line"><span class="regexp">      &#125;)</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ undoListItem</span></span><br><span class="line"><span class="regexp">      const listItems = wrapper.find('[data-test="list-item"]')</span></span><br><span class="line"><span class="regexp">      expect(listItems.length).toBe(1)</span></span><br><span class="line"><span class="regexp">      expect(listItems.at(0).text()).toContain(value)</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="异步代码"><a href="#异步代码" class="headerlink" title="异步代码"></a>异步代码</h3><h4 id="compontDidMount"><a href="#compontDidMount" class="headerlink" title="compontDidMount"></a>compontDidMount</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        data:[</span></span><br><span class="line"><span class="comment">            &#123;status:'div',value:'haha'&#125;,</span></span><br><span class="line"><span class="comment">        ],</span></span><br><span class="line"><span class="comment">        success:true</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    axios.get(<span class="string">'/undoList.json'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            undoList:res.data</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 模拟函数</p><p><code>src/__mock__/axios.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mockUndoList = &#123;</span><br><span class="line">    data:[&#123;</span><br><span class="line">        status:<span class="string">'div'</span>,<span class="attr">value</span>:<span class="string">'haha'</span></span><br><span class="line">    &#125;],</span><br><span class="line">    success:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    get(url)&#123;</span><br><span class="line">        <span class="keyword">if</span>(url === <span class="string">'/undoList.json'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">                resolve(mockUndoList)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">`</span></span><br><span class="line"><span class="string">1.用户打开页面</span></span><br><span class="line"><span class="string">2.应该展示接口返回的数据</span></span><br><span class="line"><span class="string">`</span>,(done)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(</span><br><span class="line">        &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">            &lt;TodoList /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 解决数据异步问题</span></span><br><span class="line"><span class="regexp">      setTimeout(()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">          wrapper.update();</span></span><br><span class="line"><span class="regexp">          const listItems = wrapper.find('[data-test="list-item"]')</span></span><br><span class="line"><span class="regexp">          expect(listItems.length).toBe(1)   </span></span><br><span class="line"><span class="regexp">          done()</span></span><br><span class="line"><span class="regexp">      &#125;,0)  </span></span><br><span class="line"><span class="regexp">        </span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ node的语法</span></span><br><span class="line"><span class="regexp">      process.nextTick(()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">          wrapper.update();</span></span><br><span class="line"><span class="regexp">          const listItems = wrapper.find('[data-test="list-item"]')</span></span><br><span class="line"><span class="regexp">          expect(listItems.length).toBe(1)   </span></span><br><span class="line"><span class="regexp">          done()        </span></span><br><span class="line"><span class="regexp">      &#125;)</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        data:[</span></span><br><span class="line"><span class="comment">            &#123;status:'div',value:'haha'&#125;,</span></span><br><span class="line"><span class="comment">        ],</span></span><br><span class="line"><span class="comment">        success:true</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        axios.get(<span class="string">'/undoList.json'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                undoList:res.data</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(e)</span><br><span class="line">        &#125;)        </span><br><span class="line">    &#125;,<span class="number">5000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">jest.useFakeTimers();</span><br><span class="line"></span><br><span class="line">it(<span class="string">`</span></span><br><span class="line"><span class="string">1.用户打开页面</span></span><br><span class="line"><span class="string">2.应该展示接口返回的数据</span></span><br><span class="line"><span class="string">`</span>,(done)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(</span><br><span class="line">        &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">            &lt;TodoList /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">        </span></span><br><span class="line"><span class="regexp">      expect(setTimeout).toHaveBeenCalledTimes(1);</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 跑完所有 setTimeout 的时间</span></span><br><span class="line"><span class="regexp">      jest.runAllTimers();</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 解决数据异步问题</span></span><br><span class="line"><span class="regexp">      setTimeout(()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">          wrapper.update();</span></span><br><span class="line"><span class="regexp">          const listItems = wrapper.find('[data-test="list-item"]')</span></span><br><span class="line"><span class="regexp">          expect(listItems.length).toBe(1)   </span></span><br><span class="line"><span class="regexp">          done()</span></span><br><span class="line"><span class="regexp">      &#125;,0)  </span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><h2 id="前端自动化测试的优势"><a href="#前端自动化测试的优势" class="headerlink" title="前端自动化测试的优势"></a>前端自动化测试的优势</h2><ol><li>更好的代码组织，项目的可维护性增强</li><li>更小的bug 出现概率，尤其是回归测试中的 Bug</li><li>修改工程质量差的项目，更加安全</li><li>项目具备潜在的文档特性</li><li>扩广前端的知识面</li></ol><h2 id="Enzyme-1"><a href="#Enzyme-1" class="headerlink" title="Enzyme"></a>Enzyme</h2><p>Enzyme 是 React 的 JavaScript 测试应用程序，可以轻松测试 React Components 的输出。还可以在给定输出的情况下，遍历以某种方式模拟运行。</p><p>主要通过模仿 Jq 用于 DOM 操作和遍历</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="at-index"><a href="#at-index" class="headerlink" title="at(index)"></a>at(index)</h4><p><code>.at(index) =&gt; shallowWrapper</code></p><p>返回当前 wrapper 中指定索引的节点</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>)</span></span><br><span class="line"><span class="xml">expect(wrapper.find(foo).at(0).props().foo).toEqual('bar')</span></span><br></pre></td></tr></table></figure><h4 id="first"><a href="#first" class="headerlink" title="first()"></a>first()</h4><p><code>.first() =&gt; ShallowWrapper</code></p><p>将匹配节点集合减少到集合中的第一个，就像<code>.at(0)</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(wrapper.find(Foo).first().props().foo).to.equal(<span class="string">'bar'</span>);</span><br></pre></td></tr></table></figure><h4 id="last"><a href="#last" class="headerlink" title="last()"></a>last()</h4><p><code>.last() =&gt; ShallowWrapper</code></p><p>将匹配节点集减少到集合中的最后一个，就像<code>.at(length - 1)</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find(Foo).last().props().foo).to.equal('bar');</span></span><br></pre></td></tr></table></figure><h4 id="childAt-index"><a href="#childAt-index" class="headerlink" title="childAt(index)"></a>childAt(index)</h4><p><code>.childAt(index) =&gt; ShallowWrapper</code></p><p>返回指定索引的子节点</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">TodoList</span> <span class="attr">items</span>=<span class="string">&#123;items&#125;/</span>&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('ul').childAt(0).type).toEqual('li')</span></span><br></pre></td></tr></table></figure><h4 id="children-selector"><a href="#children-selector" class="headerlink" title="children([selector])"></a>children([selector])</h4><p><code>.children([selector]) =&gt; ShallowWrapper</code></p><p>返回父节点某个元素的所有子节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">TodoList</span> <span class="attr">items</span>=<span class="string">&#123;items&#125;/</span>&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('ul').children.length).toEqual(items.length)</span></span><br></pre></td></tr></table></figure><h4 id="closest-selector"><a href="#closest-selector" class="headerlink" title="closest(selector)"></a>closest(selector)</h4><p><code>.closest(selector) =&gt; shallowWrapper</code></p><p>通过遍历节点祖先，返回第一个相匹配的节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find(Foo).closest('.bar')).to.have.lengthOf(1);</span></span><br></pre></td></tr></table></figure><h4 id="contains-nodeOrNodes"><a href="#contains-nodeOrNodes" class="headerlink" title="contains(nodeOrNodes)"></a>contains(nodeOrNodes)</h4><p><code>.contains(nodeOrNodes) =&gt; Boolean</code></p><p>返回所有给定的react元素是否与渲染树中的元素匹配。它将通过检查期望元素是否与包装器元素具有相同的 props 并共享相同的值来确定包装器中的元素是否与预期元素匹配。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wrapper;</span><br><span class="line">wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div data-foo=<span class="string">"foo"</span> data-bar=<span class="string">"bar"</span>&gt;Hello&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">expect(wrapper.contains(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"bar"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">expect(wrapper.contains(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">false</span>);</span><br><span class="line">expect(wrapper.contains(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"bar"</span> <span class="attr">data-baz</span>=<span class="string">"baz"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">false</span>);</span><br><span class="line">expect(wrapper.contains(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"Hello"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">false</span>);</span><br><span class="line">expect(wrapper.contains(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"bar"</span> /&gt;</span>)).to.equal(false);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">wrapper = shallow((</span></span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span&gt;Hello&lt;/span&gt;</span><br><span class="line">    &lt;div&gt;Goodbye&lt;/div&gt;</span><br><span class="line">    &lt;span&gt;Again&lt;/span&gt;</span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">));</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">expect(wrapper.contains([</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>Goodbye<span class="tag">&lt;/<span class="name">div</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">])).to.equal(true);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">expect(wrapper.contains([</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>World<span class="tag">&lt;/<span class="name">div</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">])).to.equal(false);</span></span><br></pre></td></tr></table></figure><h4 id="containsAllMatchingElements-patternNodes"><a href="#containsAllMatchingElements-patternNodes" class="headerlink" title="containsAllMatchingElements(patternNodes)"></a>containsAllMatchingElements(patternNodes)</h4><p><code>.containsAllMatchingElements(patternNodes) =&gt; Boolean</code></p><p>返回所有给定的react元素是否<code>patternNodes</code>与包装器的渲染树中的元素匹配。每个元素<code>patternNodes</code>必须匹配一次或多次。匹配遵循规则<code>containsMatchingElement</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> style = &#123; <span class="attr">fontSize</span>: <span class="number">13</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span className=<span class="string">"foo"</span>&gt;Hello&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div style=&#123;style&#125;&gt;Goodbye&lt;/</span>div&gt;</span><br><span class="line">    &lt;span&gt;Again&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">expect(wrapper.containsAllMatchingElements([</span><br><span class="line">  &lt;span&gt;Hello&lt;<span class="regexp">/span&gt;,</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;Goodbye&lt;/</span>div&gt;,</span><br><span class="line">])).to.equal(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="containsAnyMatchingElements-patternNodes"><a href="#containsAnyMatchingElements-patternNodes" class="headerlink" title="containsAnyMatchingElements(patternNodes)"></a>containsAnyMatchingElements(patternNodes)</h4><p><code>.containsAnyMatchingElements(patternNodes) =&gt; Boolean</code></p><p>返回至少一个给定的react元素是否<code>patternNodes</code>与包装器的渲染树中的元素匹配。一个或多个元素<code>patternNodes</code>必须匹配一次或多次。匹配遵循规则<code>containsMatchingElement</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> style = &#123; <span class="attr">fontSize</span>: <span class="number">13</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span className=<span class="string">"foo"</span>&gt;Hello&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div style=&#123;style&#125;&gt;Goodbye&lt;/</span>div&gt;</span><br><span class="line">    &lt;span&gt;Again&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">expect(wrapper.containsAnyMatchingElements([</span><br><span class="line">  &lt;span&gt;Bonjour&lt;<span class="regexp">/span&gt;,</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;Goodbye&lt;/</span>div&gt;,</span><br><span class="line">])).to.equal(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="containsMatchingElement-patternNode"><a href="#containsMatchingElement-patternNode" class="headerlink" title="containsMatchingElement(patternNode)"></a>containsMatchingElement(patternNode)</h4><p><code>.containsMatchingElement(patternNode) =&gt; Boolean</code></p><p>返回<code>patternNode</code>react元素是否与渲染树中的任何元素匹配。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div data-foo=<span class="string">"foo"</span> data-bar=<span class="string">"bar"</span>&gt;Hello&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">expect(wrapper.containsMatchingElement(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"bar"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">true</span>);</span><br><span class="line">expect(wrapper.containsMatchingElement(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">expect(wrapper.containsMatchingElement(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"bar"</span> <span class="attr">data-baz</span>=<span class="string">"baz"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">false</span>);</span><br><span class="line">expect(wrapper.containsMatchingElement(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"Hello"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">false</span>);</span><br><span class="line">expect(wrapper.containsMatchingElement(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"bar"</span> /&gt;</span>)).to.equal(false);</span></span><br></pre></td></tr></table></figure><h4 id="context-key"><a href="#context-key" class="headerlink" title="context([key])"></a>context([key])</h4><p>返回包装器根节点的上下文哈希。可选地传入一个props，它将只返回该值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(</span><br><span class="line">  &lt;MyComponent /&gt;,</span><br><span class="line">  &#123; <span class="attr">context</span>: &#123; <span class="attr">foo</span>: <span class="number">10</span> &#125; &#125;,</span><br><span class="line">);</span><br><span class="line">expect(wrapper.context().foo).to.equal(<span class="number">10</span>);</span><br><span class="line">expect(wrapper.context(<span class="string">'foo'</span>)).to.equal(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="debug-options"><a href="#debug-options" class="headerlink" title="debug([options])"></a>debug([options])</h4><p><code>.debug([options]) =&gt; String</code></p><p>返回包装器的类似HTML的字符串，以便进行调试。当测试没有通过时，打印到控制台很有用。</p><p><code>options</code>（<code>Object</code>[可选]）：</p><ul><li><code>options.ignoreProps</code>：（<code>Boolean</code>[可选]）：是否应在结果字符串中省略props。默认情况下包含道具。</li><li><code>options.verbose</code>：（<code>Boolean</code>[可选]）：是否应该详细打印作为道具传递的数组和对象。</li></ul><h4 id="dive-options"><a href="#dive-options" class="headerlink" title="dive([options])"></a>dive([options])</h4><p><code>.dive([options]) =&gt; ShallowWrapper</code></p><p>浅呈现当前包装器的一个非DOM子项，并返回结果周围的包装器。它必须是单节点包装器，并且该节点必须是React组件。</p><p>注意：只能在单个非DOM组件元素节点的包装上调用，否则会引发错误。如果必须使用多个子节点对包装器进行浅包装，请使用<code>.shallow（）</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div className=<span class="string">"in-bar"</span> /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function Foo() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Bar /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const wrapper = shallow(&lt;Foo /</span>&gt;);</span><br><span class="line">expect(wrapper.find(<span class="string">'.in-bar'</span>)).to.have.lengthOf(<span class="number">0</span>);</span><br><span class="line">expect(wrapper.find(Bar)).to.have.lengthOf(<span class="number">1</span>);</span><br><span class="line">expect(wrapper.find(Bar).dive().find(<span class="string">'.in-bar'</span>)).to.have.lengthOf(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="equals-node"><a href="#equals-node" class="headerlink" title="equals(node)"></a>equals(node)</h4><p><code>.equals(node) =&gt; Boolean</code></p><p>返回当前包装器根节点呈现树是否与传入的树相似</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line">expect(wrapper.equals(&lt;div className="foo bar" /&gt;)).to.equal(true);</span><br></pre></td></tr></table></figure><h4 id="every-selector"><a href="#every-selector" class="headerlink" title="every(selector)"></a>every(selector)</h4><p><code>.every(selector) =&gt; Boolean</code></p><p>返回包装器中的所有节点是否与提供的选择器匹配。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo qoo"</span> /&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo boo"</span> /&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo hoo"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br><span class="line"><span class="regexp">expect(wrapper.find('.foo').every('.foo')).to.equal(true);</span></span><br><span class="line"><span class="regexp">expect(wrapper.find('.foo').every('.qoo')).to.equal(false);</span></span><br><span class="line"><span class="regexp">expect(wrapper.find('.foo').every('.bar')).to.equal(false);</span></span><br></pre></td></tr></table></figure><h4 id="everyWhere-fn"><a href="#everyWhere-fn" class="headerlink" title="everyWhere(fn)"></a>everyWhere(fn)</h4><p><code>.everyWhere(fn) =&gt; Boolean</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo qoo"</span> /&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo boo"</span> /&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo hoo"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br><span class="line"><span class="regexp">expect(wrapper.find('.foo').everyWhere(n =&gt; n.hasClass('foo'))).to.equal(true);</span></span><br><span class="line"><span class="regexp">expect(wrapper.find('.foo').everyWhere(n =&gt; n.hasClass('qoo'))).to.equal(false);</span></span><br><span class="line"><span class="regexp">expect(wrapper.find('.foo').everyWhere(n =&gt; n.hasClass('bar'))).to.equal(false);</span></span><br></pre></td></tr></table></figure><h4 id="exists-selector"><a href="#exists-selector" class="headerlink" title="exists([selector])"></a>exists([selector])</h4><p><code>.exists([selector]) =&gt; Boolean</code></p><p>返回包装器中是否存在任何节点。或者，如果传入选择器，则该选择器是否在包装器中具有任何匹配项。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"some-class"</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.exists('.some-class')).to.equal(true);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('.other-class').exists()).to.equal(false);</span></span><br></pre></td></tr></table></figure><h4 id="filter-selector"><a href="#filter-selector" class="headerlink" title="filter(selector)"></a>filter(selector)</h4><p><code>.filter(selector) =&gt; ShallowWrapper</code></p><p>返回一个新的包装器，其中只包含与提供的选择器匹配的当前包装器的节点。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('.foo').filter('.bar')).to.have.lengthOf(1);</span></span><br></pre></td></tr></table></figure><h4 id="filterWhere-fn"><a href="#filterWhere-fn" class="headerlink" title="filterWhere(fn)"></a>filterWhere(fn)</h4><p><code>.filterWhere(fn) =&gt; ShallowWrapper</code></p><p>返回一个新的包装器，它只包含当前包装器的节点，当传递给提供的谓词函数时，返回true</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">const complexFoo = wrapper.find('.foo').filterWhere(n =&gt; typeof n.type() !== 'string');</span></span><br><span class="line"><span class="xml">expect(complexFoo).to.have.lengthOf(4);</span></span><br></pre></td></tr></table></figure><h4 id="find-selector"><a href="#find-selector" class="headerlink" title="find(selector)"></a>find(selector)</h4><p><code>.find(selector) =&gt; ShallowWrapper</code></p><p>查找当前包装器的呈现树中与提供的选择器匹配的每个节点。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'../components/Foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('.foo')).to.have.lengthOf(1);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('.bar')).to.have.lengthOf(3);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// compound selector</span></span><br><span class="line"><span class="xml">expect(wrapper.find('div.some-class')).to.have.lengthOf(3);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// CSS id selector</span></span><br><span class="line"><span class="xml">expect(wrapper.find('#foo')).to.have.lengthOf(1);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 组件</span></span><br><span class="line"><span class="xml">expect(wrapper.find(Foo)).to.have.lengthOf(1);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 组件显示名称</span></span><br><span class="line"><span class="xml">expect(wrapper.find('Foo')).to.have.lengthOf(1);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 对象属性选择器</span></span><br><span class="line"><span class="xml">expect(wrapper.find(&#123; prop: 'value' &#125;)).to.have.lengthOf(1);</span></span><br></pre></td></tr></table></figure><h4 id="findWhere-fn"><a href="#findWhere-fn" class="headerlink" title="findWhere(fn)"></a>findWhere(fn)</h4><p><code>.findWhere(fn) =&gt; ShallowWrapper</code></p><p>查找渲染树中为提供的谓词函数返回true的每个节点。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">const complexComponents = wrapper.findWhere(n =&gt; n.type() !== 'string');</span></span><br><span class="line"><span class="xml">expect(complexComponents).to.have.lengthOf(8);</span></span><br></pre></td></tr></table></figure><h4 id="forEach-fn"><a href="#forEach-fn" class="headerlink" title="forEach(fn)"></a>forEach(fn)</h4><p><code>.forEach(fn) =&gt; Self</code></p><p>迭代当前包装器的每个节点，并使用围绕作为第一个参数传入的相应节点的包装器执行提供的函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo bax"</span> /&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo bar"</span> /&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo baz"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">wrapper.find('.foo').forEach((node) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  expect(node.hasClass('foo')).to.equal(true);</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure><h4 id="get-index"><a href="#get-index" class="headerlink" title="get(index)"></a>get(index)</h4><p><code>.get(index) =&gt; ReactElement</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find(Foo).get(0).props.foo).to.equal('bar');</span></span><br></pre></td></tr></table></figure><h4 id="getWrappingComponent"><a href="#getWrappingComponent" class="headerlink" title="getWrappingComponent()"></a>getWrappingComponent()</h4><p><code>.getWrappingComponent() =&gt; ShallowWrapper</code></p><p>如果<code>wrappingComponent</code>传入了a <code>options</code>，则此方法返回<code>ShallowWrapper</code>渲染的周围<code>wrappingComponent</code>。这<code>ShallowWrapper</code>可以用来更新<code>wrappingComponent</code> props，state等。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Router &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./my/app/store'</span>;</span><br><span class="line"><span class="keyword">import</span> mockStore <span class="keyword">from</span> <span class="string">'./my/app/mockStore'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyProvider</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; children, customStore &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;customStore || store&#125;&gt;</span><br><span class="line">      &lt;Router&gt;</span><br><span class="line">        &#123;children&#125;</span><br><span class="line">      &lt;<span class="regexp">/Router&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">MyProvider.propTypes = &#123;</span><br><span class="line">  children: PropTypes.node,</span><br><span class="line">  customStore: PropTypes.shape(&#123;&#125;),</span><br><span class="line">&#125;;</span><br><span class="line">MyProvider.defaultProps = &#123;</span><br><span class="line">  children: <span class="literal">null</span>,</span><br><span class="line">  customStore: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>, &#123;</span></span><br><span class="line"><span class="xml">  wrappingComponent: MyProvider,</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br><span class="line"><span class="xml">const provider = wrapper.getWrappingComponent();</span></span><br><span class="line"><span class="xml">provider.setProps(&#123; customStore: mockStore &#125;);</span></span><br></pre></td></tr></table></figure><h4 id="getElement"><a href="#getElement" class="headerlink" title="getElement()"></a>getElement()</h4><p><code>.getElement() =&gt; ReactElement</code></p><p>返回包装的ReactElement。如果当前包装器正在包装根组件，则返回根组件的最新呈现输出。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span /&gt;</span><br><span class="line">    &lt;span /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function MyComponent() &#123;</span></span><br><span class="line"><span class="regexp">  return element;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const wrapper = shallow(&lt;MyComponent /</span>&gt;);</span><br><span class="line">expect(wrapper.getElement()).to.equal(element);</span><br></pre></td></tr></table></figure><h4 id="getElements"><a href="#getElements" class="headerlink" title="getElements()"></a>getElements()</h4><p><code>.getElements() =&gt; Array&lt;ReactElement&gt;</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one = <span class="xml"><span class="tag">&lt;<span class="name">span</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">const two = <span class="tag">&lt;<span class="name">span</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function Test() &#123;</span></span><br><span class="line"><span class="xml">  return (</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;one&#125;</span><br><span class="line">      &#123;two&#125;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  );</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const wrapper = shallow(<span class="tag">&lt;<span class="name">Test</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('span').getElements()).to.deep.equal([one, two]);</span></span><br></pre></td></tr></table></figure><h4 id="hasClass-className"><a href="#hasClass-className" class="headerlink" title="hasClass(className)"></a>hasClass(className)</h4><p><code>.hasClass(className) =&gt; Boolean</code></p><p>返回包装节点是否具有<code>className</code>包含传入的类名称的prop。它必须是单节点包装器。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('.my-button').hasClass('disabled')).to.equal(true);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 正则</span></span><br><span class="line"><span class="xml">expect(wrapper.find('.my-button').hasClass(/(ComponentName)-(other)-(\d+)/)).to.equal(true);</span></span><br></pre></td></tr></table></figure><h4 id="hostNodes"><a href="#hostNodes" class="headerlink" title="hostNodes()"></a>hostNodes()</h4><p><code>.hostNodes() =&gt; ShallowWrapper</code></p><p>返回仅包含主机节点的新包装器。当使用<code>react-dom</code>，主机节点是HTML元素，而不是定制反应的组分</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;MyComponent className=<span class="string">"foo"</span> /&gt;</span><br><span class="line">    &lt;span className=<span class="string">"foo"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br><span class="line"><span class="regexp">const twoNodes = wrapper.find('.foo');</span></span><br><span class="line"><span class="regexp">expect(twoNodes.hostNodes()).to.have.lengthOf(1);</span></span><br></pre></td></tr></table></figure><h4 id="html"><a href="#html" class="headerlink" title="html()"></a>html()</h4><p><code>.html() =&gt; String</code></p><p>返回整个当前渲染树（不仅仅是浅渲染部分）的渲染HTML标记的字符串。只能在单个节点的包装器上调用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"in-foo"</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function Bar() &#123;</span></span><br><span class="line"><span class="xml">  return (</span></span><br><span class="line">    &lt;div className="in-bar"&gt;</span><br><span class="line">      &lt;Foo /&gt;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  );</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const wrapper = shallow(<span class="tag">&lt;<span class="name">Bar</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.html()).to.equal('<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"in-bar"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"in-foo"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>');</span></span><br><span class="line"><span class="xml">expect(wrapper.find(Foo).html()).to.equal('<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"in-foo"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>');</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const wrapper = shallow(<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>important<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.html()).to.equal('<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>important<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>');</span></span><br></pre></td></tr></table></figure><h4 id="instance"><a href="#instance" class="headerlink" title="instance()"></a>instance()</h4><p><code>.instance() =&gt; ReactComponent</code></p><p>返回单节点包装器节点的底层类实例; <code>this</code>在它的方法。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stateless</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Stateless<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stateful</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Stateful<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'shallow wrapper instance should be null'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">Stateless</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">  const instance = wrapper.instance();</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  expect(instance).to.equal(null);</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">test('shallow wrapper instance should not be null', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">  const wrapper = shallow(<span class="tag">&lt;<span class="name">Stateful</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">  const instance = wrapper.instance();</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  expect(instance).to.be.instanceOf(Stateful);</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure><h4 id="is-selector"><a href="#is-selector" class="headerlink" title="is(selector)"></a>is(selector)</h4><p><code>.is(selector) =&gt; Boolean</code></p><p>返回单个包装节点是否与提供的选择器匹配。它必须是单节点包装器。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"some-class other-class"</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.is('.some-class')).to.equal(true);</span></span><br></pre></td></tr></table></figure><h4 id="isEmptyRender"><a href="#isEmptyRender" class="headerlink" title="isEmptyRender()"></a>isEmptyRender()</h4><p><code>.isEmptyRender() =&gt; Boolean</code></p><p>返回包装器是否最终只呈现允许的假值：<code>false</code>或<code>null</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">Foo</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.isEmptyRender()).to.equal(true);</span></span><br></pre></td></tr></table></figure><h4 id="key"><a href="#key" class="headerlink" title="key()"></a>key()</h4><p><code>.key() =&gt; String</code></p><p>返回当前包装器节点的键值。它必须是单节点包装器。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &#123;[<span class="string">'foo'</span>, <span class="string">'bar'</span>].map(<span class="function"><span class="params">s</span> =&gt;</span> &lt;li key=&#123;s&#125;&gt;&#123;s&#125;&lt;<span class="regexp">/li&gt;)&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/u</span>l&gt;</span><br><span class="line">)).find(<span class="string">'li'</span>);</span><br><span class="line">expect(wrapper.at(<span class="number">0</span>).key()).to.equal(<span class="string">'foo'</span>);</span><br><span class="line">expect(wrapper.at(<span class="number">1</span>).key()).to.equal(<span class="string">'bar'</span>);</span><br></pre></td></tr></table></figure><h4 id="map-fn"><a href="#map-fn" class="headerlink" title="map(fn)"></a>map(fn)</h4><p><code>.map(fn) =&gt; Array&lt;Any&gt;</code></p><p>将当前节点数组映射到另一个数组。每个节点作为a传递<code>ShallowWrapper</code> 给map函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo"</span>&gt;bax&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div className="foo"&gt;bar&lt;/</span>div&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo"</span>&gt;baz&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> texts = wrapper.find(<span class="string">'.foo'</span>).map(<span class="function"><span class="params">node</span> =&gt;</span> node.text());</span><br><span class="line">expect(texts).to.eql([<span class="string">'bax'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>]);</span><br></pre></td></tr></table></figure><h4 id="matchesElement-patternNode"><a href="#matchesElement-patternNode" class="headerlink" title="matchesElement(patternNode)"></a>matchesElement(patternNode)</h4><p><code>.matchesElement(patternNode) =&gt; Boolean</code></p><p>回给定的react元素是否<code>patternNode</code>与包装器的渲染树匹配。它必须是单节点包装器，并且仅检查根节点。</p><p>这些<code>patternNode</code>行为就像一张通配符。为了匹配包装器中的节点：</p><ul><li>标签名称必须匹配</li><li>内容必须匹配：在文本节点中，前导和尾随空格被忽略，但中间空间不被忽略。子元素必须根据这些规则以递归方式匹配。</li><li><code>patternNode</code>props（attributes）必须出现在包装器的节点中，而不是相反。如果它们出现，它们的值必须匹配。</li><li><code>patternNode</code>样式CSS属性必须出现在包装器节点的样式中，而不是相反。如果它们出现，它们的值必须匹配。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button type=<span class="string">"button"</span> onClick=&#123;<span class="keyword">this</span>.handleClick&#125; className=<span class="string">"foo bar"</span>&gt;Hello&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const wrapper = shallow(&lt;MyComponent /</span>&gt;);</span><br><span class="line">expect(wrapper.matchesElement(<span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>)).to.equal(<span class="literal">true</span>);</span><br><span class="line">expect(wrapper.matchesElement(<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">"foo bar"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>)).to.equal(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="name"><a href="#name" class="headerlink" title="name()"></a>name()</h4><p><code>.name() =&gt; String|null</code></p><p>返回此包装器的当前节点的名称。如果它是复合组件，则这将是最顶层渲染组件的名称。如果它是本机DOM节点，则它将是标记名称的字符串。如果是的话<code>null</code>，那就是<code>null</code>。</p><p>返回名称的优先顺序是：<code>type.displayName</code>- &gt; <code>type.name</code>- &gt; <code>type</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.name()).to.equal('div');</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function SomeWrappingComponent() &#123;</span></span><br><span class="line"><span class="xml">  return <span class="tag">&lt;<span class="name">Foo</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">const wrapper = shallow(<span class="tag">&lt;<span class="name">SomeWrappingComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.name()).to.equal('Foo');</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">Foo.displayName = 'A cool custom name';</span></span><br><span class="line"><span class="xml">function SomeWrappingComponent() &#123;</span></span><br><span class="line"><span class="xml">  return <span class="tag">&lt;<span class="name">Foo</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">const wrapper = shallow(<span class="tag">&lt;<span class="name">SomeWrappingComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.name()).to.equal('A cool custom name');</span></span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li><a href="https://coding.imooc.com/class/372.html">前端要学的测试课 从Jest入门到TDD/BDD双实战</a></li><li><a href="https://jestjs.io/en/">jest 官方文档</a></li><li><a href="https://airbnb.io/enzyme/">enzyme官方文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端必备的测试&quot;&gt;&lt;a href=&quot;#前端必备的测试&quot; class=&quot;headerlink&quot; title=&quot;前端必备的测试&quot;&gt;&lt;/a&gt;前端必备的测试&lt;/h1&gt;&lt;p&gt;DellLee 老师的 &lt;a href=&quot;https://coding.imooc.com/clas
      
    
    </summary>
    
      <category term="测试" scheme="http://laibh.top/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试" scheme="http://laibh.top/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>工欲善其事，必先利其器(eslint+prettier)</title>
    <link href="http://laibh.top/2019-08-08-%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%EF%BC%8C%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8(eslint+prettier).html"/>
    <id>http://laibh.top/2019-08-08-工欲善其事，必先利其器(eslint+prettier).html</id>
    <published>2019-08-08T01:30:54.000Z</published>
    <updated>2022-03-04T10:00:38.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工欲善其事，必先利其器-eslint-prettier"><a href="#工欲善其事，必先利其器-eslint-prettier" class="headerlink" title="工欲善其事，必先利其器(eslint+prettier)"></a>工欲善其事，必先利其器(eslint+prettier)</h2><h3 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h3><p><a href="https://prettier.io/docs/en/index.html">官网</a></p><h4 id="什么叫Prettier？"><a href="#什么叫Prettier？" class="headerlink" title="什么叫Prettier？"></a>什么叫Prettier？</h4><p>Prettier是一个固定的代码格式化程序，支持：</p><ul><li>JavaScript，包括<a href="https://github.com/tc39/proposals/blob/master/finished-proposals.md">ES2017</a></li><li><a href="https://facebook.github.io/jsx/">JSX</a></li><li><a href="https://angular.io/">Angular</a></li><li><a href="https://vuejs.org/">Vue</a></li><li><a href="https://flow.org/">Flow</a></li><li><a href="https://www.typescriptlang.org/">TS</a></li><li>CSS，<a href="http://lesscss.org/">Less</a>和<a href="http://sass-lang.com/">SCSS</a></li><li><a href="https://en.wikipedia.org/wiki/HTML">HTML</a></li><li><a href="http://json.org/">JSON</a></li><li><a href="http://graphql.org/">GraphQL</a></li><li><a href="http://commonmark.org/">Markdown</a>，包括<a href="https://github.github.com/gfm/">GFM</a>和<a href="https://mdxjs.com/">MDX</a></li><li><a href="http://yaml.org/">YAML</a></li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yarn</span></span><br><span class="line">yarn add prettier --dev --exact</span><br><span class="line"><span class="meta">#</span><span class="bash"> 全局</span></span><br><span class="line">yarn global add prettier</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> npm</span></span><br><span class="line">npm install --save-dev --save-exact prettier</span><br><span class="line"><span class="meta">#</span><span class="bash"> 全局</span></span><br><span class="line">npm install --global prettier</span><br></pre></td></tr></table></figure><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 排版宽度,即每行最大宽度，默认值是80</span><br><span class="line">  "printWidth":100,</span><br><span class="line">  // 制表符宽度，每个层级缩进几个空格，默认值为2</span><br><span class="line">  "tabWidth": 2,</span><br><span class="line">  // 是否使用 tab 替代 space 为单位缩进，默认值为false</span><br><span class="line">  "useTabs": false,</span><br><span class="line">  // 分号，句尾是否自动补全分号，默认为true</span><br><span class="line">  "semi": true,</span><br><span class="line">  // 启用双引号，不启用单引号,默认为true</span><br><span class="line">  "singleQuote": true,</span><br><span class="line">  // 在 JSX 文件中使用单引号替代双引号，默认为 false</span><br><span class="line">  "jsxSingleQuote": true,</span><br><span class="line">  // 为多行数组的非末尾添加逗号（单行数组不需要逗号），数值：none(不添加逗号)、es5(在ES5中生效的逗号，对象数组等)，all(任何可以添加逗号的地方)</span><br><span class="line">  "trailingComma": "es5",</span><br><span class="line">  // 括号空格，在对象字面量和括号之间添加空格，默认为 true</span><br><span class="line">  "bracketSpacing": true,</span><br><span class="line">  // 将多行 JSX 元素的 &gt; 放置于最后一行的末尾，而非换行。默认为 false</span><br><span class="line">  "jsxBracketSameLine": false,</span><br><span class="line">  // 箭头函数圆括号，默认为 avoid(在可以消除的情况下，消除括号)，always(一直保留括号)</span><br><span class="line">  "arrowParens": "avoid",</span><br><span class="line">  "overrides": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"files"</span>: <span class="string">".prettierrc"</span>,</span><br><span class="line">      <span class="attr">"options"</span>: &#123; <span class="attr">"parser"</span>: <span class="string">"json"</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Eslint"><a href="#Eslint" class="headerlink" title="Eslint"></a>Eslint</h3><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><p>命名必须传递足够的信息。<code>fetchUserInfoAsync</code>比<code>getData</code>更加具体</p><p><strong>命名基础</strong></p><h3 id="半自动构建"><a href="#半自动构建" class="headerlink" title="半自动构建"></a>半自动构建</h3><h4 id="husky"><a href="#husky" class="headerlink" title="husky"></a>husky</h4><p>Husky 可以阻止无效的 <code>git commit</code>、<code>git push</code>以及其他woff行为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install husky --save-dev</span><br></pre></td></tr></table></figure><h4 id="lint-staged"><a href="#lint-staged" class="headerlink" title="lint-staged"></a>lint-staged</h4><p>针对暂存的git文件运行linters并且不要让💩滑入你的代码库！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install lint-staged --save-dev</span><br></pre></td></tr></table></figure><h4 id="commitlint"><a href="#commitlint" class="headerlink" title="commitlint"></a>commitlint</h4><p>规范 <code>commit message</code>,便于自动生成 <code>CHANGELOG</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install commitlint @commitlint/cli @commitlint/config-conventional --save-dev</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// commitlint.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  extends: [<span class="string">"@commitlint/config-conventional"</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">"type-enum"</span>: [</span><br><span class="line">      <span class="number">2</span>,</span><br><span class="line">      <span class="string">"always"</span>,</span><br><span class="line">      [<span class="string">"feat"</span>, <span class="string">"fix"</span>, <span class="string">"docs"</span>, <span class="string">"style"</span>, <span class="string">"refactor"</span>, <span class="string">"test"</span>, <span class="string">"chore"</span>, <span class="string">"revert"</span>]</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"subject-full-stop"</span>: [<span class="number">0</span>, <span class="string">"never"</span>],</span><br><span class="line">    <span class="string">"subject-case"</span>: [<span class="number">0</span>, <span class="string">"never"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * feat：新功能（feature）</span></span><br><span class="line"><span class="comment"> * fix：修补bug</span></span><br><span class="line"><span class="comment"> * docs：文档（documentation）</span></span><br><span class="line"><span class="comment"> * style： 格式（不影响代码运行的变动）</span></span><br><span class="line"><span class="comment"> * refactor：重构（即不是新增功能，也不是修改bug的代码变动）</span></span><br><span class="line"><span class="comment"> * test：增加测试</span></span><br><span class="line"><span class="comment"> * chore：构建过程或辅助工具的变动</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="conventional-changelog"><a href="#conventional-changelog" class="headerlink" title="conventional-changelog"></a>conventional-changelog</h4><p>自动生成 <code>CHANGELOG</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install conventional-changelog conventional-changelog-cli --save-dev</span><br></pre></td></tr></table></figure><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"concurrently \"node scripts/start.js\" \"npm run mock\""</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"node scripts/build.js"</span>,</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"node scripts/test.js"</span>,</span><br><span class="line">    <span class="attr">"eslint"</span>: <span class="string">"eslint --fix **/*.js"</span>,</span><br><span class="line">    <span class="attr">"prettier"</span>: <span class="string">"prettier --write ./src/**/**/**/*"</span>,</span><br><span class="line">    <span class="attr">"mock"</span>: <span class="string">"json-server --watch db.json --port 3004"</span>,</span><br><span class="line">    <span class="attr">"changelog"</span>: <span class="string">"conventional-changelog -p angular -i CHANGELOG.md -s -r 0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"husky"</span>: &#123;</span><br><span class="line">    <span class="attr">"hooks"</span>: &#123;</span><br><span class="line">      <span class="attr">"pre-commit"</span>: <span class="string">"lint-staged"</span>,</span><br><span class="line">      <span class="attr">"commit-msg"</span>: <span class="string">"commitlint -E HUSKY_GIT_PARAMS"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"lint-staged"</span>: &#123;</span><br><span class="line">    <span class="attr">"src/**/*.&#123;jsx,txs,ts,js,json,css,md&#125;"</span>: [</span><br><span class="line">      <span class="string">"prettier --write ./src/**/**/**/*"</span>,</span><br><span class="line">      <span class="string">"eslint --fix **/*.js"</span>,</span><br><span class="line">      <span class="string">"git add"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"config"</span>: &#123;</span><br><span class="line">    <span class="attr">"commitizen"</span>: &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"cz-customizable"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="commit-amp-push"><a href="#commit-amp-push" class="headerlink" title="commit&amp;push"></a>commit&amp;push</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当有新的改变</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交，输入不规范的提交信息，先校验代码， 提示不规范，并且不通过</span></span><br><span class="line">git commit -m "test"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入规范信息，规范自行百度，也可以从 commitlint.config.js中看出。运行钩子自动prettier，接着运行 eslint,没有报错则 git add，并开始校验提交信息是否规范，无误后顺利提交</span></span><br><span class="line">git commit -m "feat: add semi-automatic construction"</span><br><span class="line">husky &gt; pre-commit (node v10.15.3)</span><br><span class="line">Stashing changes... [started]</span><br><span class="line">Stashing changes... [skipped]</span><br><span class="line">→ No partially staged files found...</span><br><span class="line">Running tasks... [started]</span><br><span class="line">Running tasks for src/**/*.&#123;jsx,txs,ts,js,json,css,md&#125; [started]</span><br><span class="line">prettier --write ./src/**/**/**/* [started]</span><br><span class="line">prettier --write ./src/**/**/**/* [completed]</span><br><span class="line">eslint --fix **/*.js [started]</span><br><span class="line">eslint --fix **/*.js [completed]</span><br><span class="line">git add [started]</span><br><span class="line">git add [completed]</span><br><span class="line">Running tasks for src/**/*.&#123;jsx,txs,ts,js,json,css,md&#125; [completed]</span><br><span class="line">Running tasks... [completed]</span><br><span class="line">husky &gt; commit-msg (node v10.15.3)</span><br><span class="line">[master 9afdd76] test: lint-staged</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送到 orgin</span></span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成 changelog</span></span><br><span class="line">npm run changelog</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> conventional-changelog -p angular -i CHANGELOG.md -s -r 0</span></span><br></pre></td></tr></table></figure><h3 id="CSS样式顺序"><a href="#CSS样式顺序" class="headerlink" title="CSS样式顺序"></a>CSS样式顺序</h3><p>相关属性应该为一组，可以以下面的样式为编写顺序</p><ul><li>Positioning</li><li>Box model</li><li>Typographic</li><li>Visual</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.declaration-order&#123;</span><br><span class="line">    <span class="comment">/* Positioning */</span></span><br><span class="line">    position: absolute;</span><br><span class="line">    top: <span class="number">0</span>;</span><br><span class="line">    right: <span class="number">0</span>;</span><br><span class="line">    bottom: <span class="number">0</span>;</span><br><span class="line">    left: <span class="number">0</span>;</span><br><span class="line">    z-index: <span class="number">100</span>;    </span><br><span class="line">    <span class="comment">/* Box model */</span></span><br><span class="line">    display:block;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">    width: <span class="number">100</span>px;</span><br><span class="line">    height: <span class="number">100</span>px;</span><br><span class="line">    padding: <span class="number">10</span>px;</span><br><span class="line">    border: 1px solid #666;</span><br><span class="line">    border-radius: <span class="number">5</span>px;</span><br><span class="line">    margin: <span class="number">10</span>px;</span><br><span class="line">    float: right;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    <span class="comment">/* Typographic */</span></span><br><span class="line">    font: normal <span class="number">12</span>px <span class="string">'Helvetica Neue'</span>,sans-serif;</span><br><span class="line">    line-height: <span class="number">1.5</span>;</span><br><span class="line">    text-align: center;</span><br><span class="line">    <span class="comment">/* Visual */</span></span><br><span class="line">    background-color: #333;</span><br><span class="line">    color: #fff;</span><br><span class="line">    opacity: <span class="number">0.8</span>;</span><br><span class="line">    <span class="comment">/* Other */</span></span><br><span class="line">    cursor: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><ol><li><a href="http://taobaofed.org/blog/2017/01/05/writing-readable-code/">编写「可读」代码的实践</a></li><li><a href="https://imweb.io/topic/5a5cc753a192c3b460fce3fc">前端开发规范之命名规范、html规范、css规范、js规范</a></li><li><a href="https://prettier.io/docs/en/install.html">Prettier</a></li><li><a href="http://eslint.cn/docs/rules/">eslint</a></li><li><a href="https://github.com/airbnb/javascript">airbnb规范</a></li><li><a href="https://github.com/yannickcr/eslint-plugin-react/tree/1aab93d0e3e91f73accdfc3a59afbdaf97c0d08e/docs/rules">eslint-plugin-react</a></li><li><a href="https://github.com/AlloyTeam/eslint-config-alloy">eslint-config-alloy</a></li><li><a href="https://github.com/evcohen/eslint-plugin-jsx-a11y/tree/master/docs/rules">eslint-plugin-jsx-a11y</a></li><li><a href="https://www.npmjs.com/package/husky">husky</a></li><li><a href="https://www.npmjs.com/package/lint-staged">lint-staged</a></li><li><a href="https://commitlint.js.org/#/concepts-commit-conventions">commitlint</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;工欲善其事，必先利其器-eslint-prettier&quot;&gt;&lt;a href=&quot;#工欲善其事，必先利其器-eslint-prettier&quot; class=&quot;headerlink&quot; title=&quot;工欲善其事，必先利其器(eslint+prettier)&quot;&gt;&lt;/a&gt;工欲善其
      
    
    </summary>
    
      <category term="规范" scheme="http://laibh.top/categories/%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="规范" scheme="http://laibh.top/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>从leetCode学习JavaScript数据结构与基础算法</title>
    <link href="http://laibh.top/2019-07-03-%E4%BB%8EleetCode%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.html"/>
    <id>http://laibh.top/2019-07-03-从leetCode学习JavaScript数据结构与基础算法.html</id>
    <published>2019-07-03T01:30:54.000Z</published>
    <updated>2022-03-04T10:00:38.464Z</updated>
    
    <content type="html"><![CDATA[<p>循序渐进，保持空杯</p><h2 id="从leetCode学习JavaScript数据结构与基础算法"><a href="#从leetCode学习JavaScript数据结构与基础算法" class="headerlink" title="从leetCode学习JavaScript数据结构与基础算法"></a>从leetCode学习JavaScript数据结构与基础算法</h2><p>简单算法：</p><p><code>字符串</code>、<code>数组</code>、<code>正则</code>、<code>排序</code>、<code>递归</code></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><strong>反转字符串中的单词③</strong></p><p>给定一个字符串，需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序</p><p>实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入："Let's take LeetCode contest"</span><br><span class="line">输出："s'teL ekat edoCteeL tsetnoc"</span><br></pre></td></tr></table></figure><p>注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment">* @return &#123;string&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.字符串按空格进行分隔，数组的元素的先后顺序就是单词的顺序</span></span><br><span class="line">    <span class="comment">// 2.遍历数组的元素，也就是每个单词String，通过 split分隔转Array 同时用Array 自带的 reverse方法将每个单词数组分隔后产生的数组反转</span></span><br><span class="line">    <span class="comment">// 3.接着用join('')将单词数组中的每个数组拼凑成字符串</span></span><br><span class="line">    <span class="comment">// 4.最后将字符串单词数组拼凑为最终的字符串</span></span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">' '</span>).map(<span class="function"><span class="params">i</span>=&gt;</span>i.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)).join(<span class="string">' '</span>)</span><br><span class="line">    <span class="comment">// 或者用正则，匹配空格</span></span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="regexp">/\s/g</span>).map(<span class="function"><span class="params">i</span>=&gt;</span>i.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)).join(<span class="string">' '</span>)</span><br><span class="line">    <span class="comment">// 匹配单词(match)</span></span><br><span class="line">    <span class="keyword">return</span> s.match(<span class="regexp">/[\w']+/g</span>).map(<span class="function"><span class="params">i</span>=&gt;</span>i.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)).join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reverseByWord <span class="keyword">from</span> <span class="string">'../../code/string/lession1'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'reverseByWord:Let\'s take LeetCode contest'</span>, () =&gt; &#123;</span><br><span class="line">  expect(reverseByWord(<span class="string">"Let's take LeetCode contest"</span>)).toBe(<span class="string">"s'teL ekat edoCteeL tsetnoc"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>知识点：</p><p><code>String.prototype.split</code>、<code>String.prototype.match</code>、<code>Array.prototype.map</code>、<code>Array.prototype.reverse</code>、<code>Array.prototype.join</code></p><p>扩展：上面讲的是单个空格隔开，那如果不是当个空格呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样可以使用正则的贪婪匹配来解决</span></span><br><span class="line"><span class="keyword">const</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 或者用正则，匹配空格</span></span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="regexp">/\s+/g</span>).map(<span class="function"><span class="params">i</span>=&gt;</span>i.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)).join(<span class="string">' '</span>)</span><br><span class="line">    <span class="comment">// 匹配单词(match)</span></span><br><span class="line">    <span class="keyword">return</span> s.match(<span class="regexp">/[\w']+/g</span>).map(<span class="function"><span class="params">i</span>=&gt;</span>i.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)).join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>计数二进制子串</strong></p><p>给定一个字符串 <code>s</code>，计算具有相同数量 0 和 1的非空（连续）子符串的数量，并且这些子字符串中的所有 0 和 1 都是组合在一起的。</p><p>重复出现的子串要计算它们出现的次数。</p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入："00110011"</span><br><span class="line">输出：6</span><br><span class="line">解释：有6个子串具有相同数量的连续1和0："0011","01","1100","10","0011"和"01"</span><br><span class="line">请注意，一些重复出现的子串要计算它们出现的次数</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; str</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (str) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 创建数据结构堆栈保存数据</span></span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">const</span> match = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> j = str.match(<span class="regexp">/^(0+|1+)/</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// j=(n个)0-&gt;o=(n个)1;j=(n个)1-&gt;o=(n个)0;</span></span><br><span class="line">    <span class="keyword">let</span> o = (j[<span class="number">0</span>] ^ <span class="number">1</span>).toString().repeat(j.length)</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`^(<span class="subst">$&#123;j&#125;</span><span class="subst">$&#123;o&#125;</span>)`</span>)</span><br><span class="line">    <span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">RegExp</span>.$<span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = str.length - <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 简单递归</span></span><br><span class="line">    <span class="keyword">let</span> sub = match(str.slice(i))</span><br><span class="line">    <span class="keyword">if</span> (sub) &#123;</span><br><span class="line">      result.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'countBinarySubstring(00110011)'</span>, () =&gt; &#123;</span><br><span class="line">  expect(countBinarySubstring(<span class="string">'00110011'</span>)).toEqual([<span class="string">'0011'</span>, <span class="string">'01'</span>, <span class="string">'1100'</span>, <span class="string">'10'</span>, <span class="string">'0011'</span>, <span class="string">'01'</span>])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'countBinarySubstring(10101)'</span>, () =&gt; &#123;</span><br><span class="line">  expect(countBinarySubstring(<span class="string">'10101'</span>)).toEqual([<span class="string">'10'</span>, <span class="string">'01'</span>, <span class="string">'10'</span>, <span class="string">'01'</span>])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>知识点：</p><p><code>发现规律</code>，<code>RegExp</code></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>电话号码的组合</strong></p><p>给定一个仅包含 <code>2-9</code>的字符串，返回它能表示的字母组合。给出数字到字母的映射如下（与电话按钮相同）。注意1不对应任何字母</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1[] 2[abc] 3[def]</span><br><span class="line">4[ghi] 5[jkl] 6[mno]</span><br><span class="line">7[pqrs] 8[tuv] 9[wxyz]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： "23"</span><br><span class="line">输出： ["ad","ae","af","bd","be","bf","cd","ce","cf"]</span><br></pre></td></tr></table></figure><p>说明：上面的答案是按字典排序的，可以任意选择答案输出的顺序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; digits</span></span><br><span class="line"><span class="comment"> * @return &#123;string[]&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (digits) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (digits.length &lt; <span class="number">1</span>) <span class="keyword">return</span> []</span><br><span class="line">  <span class="comment">// 建立电话号码键盘映射</span></span><br><span class="line">  <span class="keyword">const</span> map = [<span class="string">''</span>, <span class="number">1</span>, <span class="string">'abc'</span>, <span class="string">'def'</span>, <span class="string">'ghi'</span>, <span class="string">'jkl'</span>, <span class="string">'mno'</span>, <span class="string">'pqrs'</span>, <span class="string">'tuv'</span>, <span class="string">'wxyz'</span>]</span><br><span class="line">  <span class="keyword">if</span> (digits.length &lt; <span class="number">2</span>) <span class="keyword">return</span> map[digits].split(<span class="string">''</span>)</span><br><span class="line">  <span class="comment">// 将输入的digits 分隔成数组，234=&gt;[2,3,4]</span></span><br><span class="line">  <span class="keyword">const</span> num = digits.split(<span class="string">''</span>)</span><br><span class="line">  <span class="comment">// 保存键盘映射后的字母内容，如 23=&gt;['abc','def']</span></span><br><span class="line">  <span class="keyword">const</span> code = []</span><br><span class="line">  num.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    code.push(map[item])</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> comb = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 临时变量用来保存两个组合的结果</span></span><br><span class="line">    <span class="keyword">const</span> temp = []</span><br><span class="line">    <span class="comment">// 循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, ilen = arr[<span class="number">0</span>].length; i &lt; ilen; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, jlen = arr[<span class="number">1</span>].length; j &lt; jlen; j++) &#123;</span><br><span class="line">        temp.push(<span class="string">`<span class="subst">$&#123;arr[<span class="number">0</span>][i]&#125;</span><span class="subst">$&#123;arr[<span class="number">1</span>][j]&#125;</span>`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去掉一开始遍历的前两个，替换为这两个循环后的结果</span></span><br><span class="line">    arr.splice(<span class="number">0</span>, <span class="number">2</span>, temp)</span><br><span class="line">    <span class="comment">// 当数组的长度大于1时递归</span></span><br><span class="line">    <span class="keyword">if</span> (arr.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      comb(arr)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回真正的结果</span></span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 开始递归运算</span></span><br><span class="line">  <span class="keyword">return</span> comb(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'letterCombinations(23)'</span>, () =&gt; &#123;</span><br><span class="line">  expect(letterCombinations(<span class="string">'23'</span>)).toEqual([<span class="string">'ad'</span>, <span class="string">'ae'</span>, <span class="string">'af'</span>, <span class="string">'bd'</span>, <span class="string">'be'</span>, <span class="string">'bf'</span>, <span class="string">'cd'</span>, <span class="string">'ce'</span>, <span class="string">'cf'</span>])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'letterCombinations(234)'</span>, () =&gt; &#123;</span><br><span class="line">  expect(letterCombinations(<span class="string">'234'</span>)).toEqual([</span><br><span class="line">    <span class="string">'adg'</span>, <span class="string">'adh'</span>, <span class="string">'adi'</span>,</span><br><span class="line">    <span class="string">'aeg'</span>, <span class="string">'aeh'</span>, <span class="string">'aei'</span>,</span><br><span class="line">    <span class="string">'afg'</span>, <span class="string">'afh'</span>, <span class="string">'afi'</span>,</span><br><span class="line">    <span class="string">'bdg'</span>, <span class="string">'bdh'</span>, <span class="string">'bdi'</span>,</span><br><span class="line">    <span class="string">'beg'</span>, <span class="string">'beh'</span>, <span class="string">'bei'</span>,</span><br><span class="line">    <span class="string">'bfg'</span>, <span class="string">'bfh'</span>, <span class="string">'bfi'</span>,</span><br><span class="line">    <span class="string">'cdg'</span>, <span class="string">'cdh'</span>, <span class="string">'cdi'</span>,</span><br><span class="line">    <span class="string">'ceg'</span>, <span class="string">'ceh'</span>, <span class="string">'cei'</span>,</span><br><span class="line">    <span class="string">'cfg'</span>, <span class="string">'cfh'</span>, <span class="string">'cfi'</span></span><br><span class="line">  ])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>知识点：</p><p><code>公式运算</code></p><p><strong>卡牌分组</strong></p><p>给定一副牌，每张牌上都写着一个整数。</p><p>此时，需要选定一个数字 <code>x</code>，使得可以将整部牌按下述规则分成 1 组或者更多：</p><ul><li>每组都有 <code>x</code> 张牌</li><li>组内所有的牌上都写着相同的整数</li></ul><p>仅当可选的 <code>x&gt;=2</code>时返回 <code>true</code></p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,4,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1],[2,2],[3,3],[4,4]</span><br></pre></td></tr></table></figure><p>提示：</p><ol><li><code>1 &lt;= deck.length &lt;= 10000</code></li><li><code>0 &lt;= deck[i] &lt; 10000</code></li></ol><p>知识点：</p><p><code>归并运算</code></p><p><strong>种花问题</strong></p><p>知识点：</p><p><code>筛选运算</code></p><p><strong>格雷编码</strong></p><p>知识点：</p><p><code>二进制运算</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;循序渐进，保持空杯&lt;/p&gt;
&lt;h2 id=&quot;从leetCode学习JavaScript数据结构与基础算法&quot;&gt;&lt;a href=&quot;#从leetCode学习JavaScript数据结构与基础算法&quot; class=&quot;headerlink&quot; title=&quot;从leetCode学习Java
      
    
    </summary>
    
      <category term="javaScript相关" scheme="http://laibh.top/categories/javaScript%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="javaScript数据结构与算法" scheme="http://laibh.top/tags/javaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>React源码浅析</title>
    <link href="http://laibh.top/2019-06-29-React%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90.html"/>
    <id>http://laibh.top/2019-06-29-React源码浅析.html</id>
    <published>2019-06-29T01:30:54.000Z</published>
    <updated>2022-03-04T10:00:38.464Z</updated>
    
    <content type="html"><![CDATA[<p>知其然知其所以然，框架工的自我尝试进阶</p><h2 id="React源码浅析"><a href="#React源码浅析" class="headerlink" title="React源码浅析"></a>React源码浅析</h2><p>知识点：</p><p><strong>React Api</strong></p><p><code>createElement</code>、<code>createContext</code>、<code>JSX=&gt;JS</code>、<code>ConcurrentMode</code>、<code>Ref</code>、<code>Component</code>、<code>Suspense</code>、<code>Hooks</code></p><p><strong>React 中的更新创建</strong></p><p><code>ReactDOM.render</code>、<code>Fiber</code>、<code>UpdateQueue</code>、<code>FiberRoot</code>、<code>Update</code>、<code>expirationTime</code></p><p><strong>Fiber Scheduler</strong></p><p><code>scheduleWork</code>、<code>batchedUpdates</code>、<code>performWork</code>、<code>performUnitOfWork</code>、<code>requestWork</code>、<code>react scheduler</code>、<code>renderRoot</code></p><p><strong>开始更新</strong></p><p><code>beginWork以及优化</code>、<code>各类组件的更新过程</code>、<code>调节子节点的过程</code></p><p><strong>完成各个节点的更新</strong></p><p><code>completeUnitOfWork</code>、<code>虚拟DOM对比</code>、<code>completeWork</code>、<code>错误捕获处理</code>、<code>unwindwork</code>、<code>完成整棵树更新</code></p><p><strong>提交更新</strong></p><p><code>commitRoot整体流程</code>、<code>开发时的帮助方法</code>、<code>提交快照</code>、<code>提交DOM插入</code>、<code>提交DOM更新</code>、<code>提交DOM删除</code>、<code>提交所有生命周期</code></p><p><strong>各功能的实现功能</strong></p><p><code>context的实现过程</code>、<code>ref的实现过程</code>、<code>hydrate的实现过程</code>、<code>React的事件体系</code></p><p><strong>Suspense</strong></p><p><code>更新优先级的概念</code>、<code>更新挂起的概念</code>、<code>Suspense组件更新</code>、<code>timeout处理</code>、<code>retry重新尝试渲染</code>、<code>lazy组件更新</code></p><p><strong>Hooks</strong></p><p><code>核心原理</code>、<code>useState</code>、<code>useEffect</code>、<code>useContent</code>、<code>其他Hooks API</code></p><h3 id="React-Api-相关"><a href="#React-Api-相关" class="headerlink" title="React Api 相关"></a>React Api 相关</h3><h4 id="React-js"><a href="#React-js" class="headerlink" title="React.js"></a>React.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">const React = &#123;</span><br><span class="line">    Children:&#123;</span><br><span class="line">        map,</span><br><span class="line">        forEach,</span><br><span class="line">        count,</span><br><span class="line">        toArray,</span><br><span class="line">        only</span><br><span class="line">    &#125;,</span><br><span class="line">    createRef,</span><br><span class="line">    Component,</span><br><span class="line">    PureComponent,</span><br><span class="line">    createContext,</span><br><span class="line">    forWardRef,</span><br><span class="line">    lazy,</span><br><span class="line">    memo,</span><br><span class="line">    Fragment:REACT_FRAGMENT_TYPE,</span><br><span class="line">    StrictMode:REACT_STRICT_MODE_TYPE,</span><br><span class="line">    SuspenseLREACT_SUSPENSE_TYPE,</span><br><span class="line">    createElement:__DEV__?createElementWithValidation:createElement,</span><br><span class="line">    cloneElement:__DEV__?cloneElementWithValidation:cloneElement,</span><br><span class="line">    isValidElement:isValidElement,</span><br><span class="line">    version:ReactVersion,</span><br><span class="line">    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:ReactSharedInternals,</span><br><span class="line">&#125;</span><br><span class="line">if (enableStableConcurrentModeAPIs) &#123;</span><br><span class="line">  React.ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;</span><br><span class="line">  React.Profiler = REACT_PROFILER_TYPE;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  React.unstable_ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;</span><br><span class="line">  React.unstable_Profiler = REACT_PROFILER_TYPE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default React;</span><br></pre></td></tr></table></figure><h4 id="ReactElement-js"><a href="#ReactElement-js" class="headerlink" title="ReactElement.js"></a>ReactElement.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br></pre></td><td class="code"><pre><span class="line">// hasOwnProperty 方法返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是知否有指定的键）</span><br><span class="line">const hasOwnProperty = Object.prototype.hasOwnProperty;</span><br><span class="line">// 内建的props</span><br><span class="line">const RESERVED_PROPS = &#123;</span><br><span class="line">  key: true,</span><br><span class="line">  ref: true,</span><br><span class="line">  __self: true,</span><br><span class="line">  __source: true,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let specialPropKeyWarningShown, specialPropRefWarningShown;</span><br><span class="line">// 判断是否是合法的 ref</span><br><span class="line">function hasValidRef(config) &#123;</span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    if (hasOwnProperty.call(config, &apos;ref&apos;)) &#123;</span><br><span class="line">      /**</span><br><span class="line">      * getOwnPropertyDescriptor 返回指定对象上自有属性描述符（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</span><br><span class="line">      * get 方法。获取该属性的访问器函数（getter）。如果没有访问器，该值为 undefined</span><br><span class="line">      */</span><br><span class="line">      const getter = Object.getOwnPropertyDescriptor(config, &apos;ref&apos;).get;</span><br><span class="line">      if (getter &amp;&amp; getter.isReactWarning) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return config.ref !== undefined;</span><br><span class="line">&#125;</span><br><span class="line">// 判断是否是合法的 key</span><br><span class="line">function hasValidKey(config) &#123;</span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    if (hasOwnProperty.call(config, &apos;key&apos;)) &#123;</span><br><span class="line">      const getter = Object.getOwnPropertyDescriptor(config, &apos;key&apos;).get;</span><br><span class="line">      if (getter &amp;&amp; getter.isReactWarning) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return config.key !== undefined;</span><br><span class="line">&#125;</span><br><span class="line">// 定义了 key 不合法抛出的警告</span><br><span class="line">function defineKeyPropWarningGetter(props, displayName) &#123;</span><br><span class="line">  const warnAboutAccessingKey = function() &#123;</span><br><span class="line">    if (!specialPropKeyWarningShown) &#123;</span><br><span class="line">      specialPropKeyWarningShown = true;</span><br><span class="line">      warningWithoutStack(</span><br><span class="line">        false,</span><br><span class="line">        &apos;%s: `key` is not a prop. Trying to access it will result &apos; +</span><br><span class="line">          &apos;in `undefined` being returned. If you need to access the same &apos; +</span><br><span class="line">          &apos;value within the child component, you should pass it as a different &apos; +</span><br><span class="line">          &apos;prop. (https://fb.me/react-special-props)&apos;,</span><br><span class="line">        displayName,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  warnAboutAccessingKey.isReactWarning = true;</span><br><span class="line">  Object.defineProperty(props, &apos;key&apos;, &#123;</span><br><span class="line">    get: warnAboutAccessingKey,</span><br><span class="line">    configurable: true,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">// 定义了 ref 不合法抛出的警告</span><br><span class="line">function defineRefPropWarningGetter(props, displayName) &#123;</span><br><span class="line">  const warnAboutAccessingRef = function() &#123;</span><br><span class="line">    if (!specialPropRefWarningShown) &#123;</span><br><span class="line">      specialPropRefWarningShown = true;</span><br><span class="line">      warningWithoutStack(</span><br><span class="line">        false,</span><br><span class="line">        &apos;%s: `ref` is not a prop. Trying to access it will result &apos; +</span><br><span class="line">          &apos;in `undefined` being returned. If you need to access the same &apos; +</span><br><span class="line">          &apos;value within the child component, you should pass it as a different &apos; +</span><br><span class="line">          &apos;prop. (https://fb.me/react-special-props)&apos;,</span><br><span class="line">        displayName,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  warnAboutAccessingRef.isReactWarning = true;</span><br><span class="line">  Object.defineProperty(props, &apos;ref&apos;, &#123;</span><br><span class="line">    get: warnAboutAccessingRef,</span><br><span class="line">    configurable: true,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Factory method to create a new React element. This no longer adheres to</span><br><span class="line"> * the class pattern, so do not use new to call it. Also, no instanceof check</span><br><span class="line"> * will work. Instead test $$typeof field against Symbol.for(&apos;react.element&apos;) to check</span><br><span class="line"> * if something is a React Element.</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;*&#125; type</span><br><span class="line"> * @param &#123;*&#125; key</span><br><span class="line"> * @param &#123;string|object&#125; ref</span><br><span class="line"> * @param &#123;*&#125; self A *temporary* helper to detect places where `this` is</span><br><span class="line"> * different from the `owner` when React.createElement is called, so that we</span><br><span class="line"> * can warn. We want to get rid of owner and replace string `ref`s with arrow</span><br><span class="line"> * functions, and as long as `this` and owner are the same, there will be no</span><br><span class="line"> * change in behavior.</span><br><span class="line"> * @param &#123;*&#125; source An annotation object (added by a transpiler or otherwise)</span><br><span class="line"> * indicating filename, line number, and/or other information.</span><br><span class="line"> * @param &#123;*&#125; owner</span><br><span class="line"> * @param &#123;*&#125; props</span><br><span class="line"> * @internal</span><br><span class="line"> */</span><br><span class="line">const ReactElement = function(type, key, ref, self, source, owner, props) &#123;</span><br><span class="line">  const element = &#123;</span><br><span class="line">    // This tag allows us to uniquely identify this as a React Element</span><br><span class="line">    $$typeof: REACT_ELEMENT_TYPE,</span><br><span class="line"></span><br><span class="line">    // Built-in properties that belong on the element</span><br><span class="line">    type: type,</span><br><span class="line">    key: key,</span><br><span class="line">    ref: ref,</span><br><span class="line">    props: props,</span><br><span class="line"></span><br><span class="line">    // Record the component responsible for creating this element.</span><br><span class="line">    _owner: owner,</span><br><span class="line">  &#125;;</span><br><span class="line"> // 开发环境的一些内容</span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    // The validation flag is currently mutative. We put it on</span><br><span class="line">    // an external backing store so that we can freeze the whole object.</span><br><span class="line">    // This can be replaced with a WeakMap once they are implemented in</span><br><span class="line">    // commonly used development environments.</span><br><span class="line">    element._store = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // To make comparing ReactElements easier for testing purposes, we make</span><br><span class="line">    // the validation flag non-enumerable (where possible, which should</span><br><span class="line">    // include every environment we run tests in), so the test framework</span><br><span class="line">    // ignores it.</span><br><span class="line">    Object.defineProperty(element._store, &apos;validated&apos;, &#123;</span><br><span class="line">      configurable: false,</span><br><span class="line">      enumerable: false,</span><br><span class="line">      writable: true,</span><br><span class="line">      value: false,</span><br><span class="line">    &#125;);</span><br><span class="line">    // self and source are DEV only properties.</span><br><span class="line">    Object.defineProperty(element, &apos;_self&apos;, &#123;</span><br><span class="line">      configurable: false,</span><br><span class="line">      enumerable: false,</span><br><span class="line">      writable: false,</span><br><span class="line">      value: self,</span><br><span class="line">    &#125;);</span><br><span class="line">    // Two elements created in two different places should be considered</span><br><span class="line">    // equal for testing purposes and therefore we hide it from enumeration.</span><br><span class="line">    Object.defineProperty(element, &apos;_source&apos;, &#123;</span><br><span class="line">      configurable: false,</span><br><span class="line">      enumerable: false,</span><br><span class="line">      writable: false,</span><br><span class="line">      value: source,</span><br><span class="line">    &#125;);</span><br><span class="line">    if (Object.freeze) &#123;</span><br><span class="line">      Object.freeze(element.props);</span><br><span class="line">      Object.freeze(element);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return element;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 创建并返回给定类型的新ReactElement。</span><br><span class="line"> * See https://reactjs.org/docs/react-api.html#createelement</span><br><span class="line"> */</span><br><span class="line">export function createElement(type, config, children) &#123;</span><br><span class="line">  let propName;</span><br><span class="line"></span><br><span class="line">  // Reserved names are extracted</span><br><span class="line">  const props = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  let key = null;</span><br><span class="line">  let ref = null;</span><br><span class="line">  let self = null;</span><br><span class="line">  let source = null;</span><br><span class="line"></span><br><span class="line">  if (config != null) &#123;</span><br><span class="line">    if (hasValidRef(config)) &#123;</span><br><span class="line">      ref = config.ref;</span><br><span class="line">    &#125;</span><br><span class="line">    if (hasValidKey(config)) &#123;</span><br><span class="line">      key = &apos;&apos; + config.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self = config.__self === undefined ? null : config.__self;</span><br><span class="line">    source = config.__source === undefined ? null : config.__source;</span><br><span class="line">    // 如果不是内建的props以及本身拥有的属性，将剩余的属性传入到新的props对象中</span><br><span class="line">    for (propName in config) &#123;        </span><br><span class="line">      if (</span><br><span class="line">        hasOwnProperty.call(config, propName) &amp;&amp;</span><br><span class="line">        !RESERVED_PROPS.hasOwnProperty(propName)</span><br><span class="line">      ) &#123;</span><br><span class="line">        props[propName] = config[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 子对象可以是多个参数，并且这些参数会传输到新分配的props对象上。</span><br><span class="line">  const childrenLength = arguments.length - 2;</span><br><span class="line">  if (childrenLength === 1) &#123;</span><br><span class="line">    props.children = children;</span><br><span class="line">  &#125; else if (childrenLength &gt; 1) &#123;</span><br><span class="line">    const childArray = Array(childrenLength);</span><br><span class="line">    for (let i = 0; i &lt; childrenLength; i++) &#123;</span><br><span class="line">      childArray[i] = arguments[i + 2];</span><br><span class="line">    &#125;</span><br><span class="line">    if (__DEV__) &#123;</span><br><span class="line">      if (Object.freeze) &#123;</span><br><span class="line">        Object.freeze(childArray);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    props.children = childArray;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 解析默认属性</span><br><span class="line">  if (type &amp;&amp; type.defaultProps) &#123;</span><br><span class="line">    const defaultProps = type.defaultProps;</span><br><span class="line">    for (propName in defaultProps) &#123;</span><br><span class="line">      if (props[propName] === undefined) &#123;</span><br><span class="line">        props[propName] = defaultProps[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    if (key || ref) &#123;</span><br><span class="line">      const displayName =</span><br><span class="line">        typeof type === &apos;function&apos;</span><br><span class="line">          ? type.displayName || type.name || &apos;Unknown&apos;</span><br><span class="line">          : type;</span><br><span class="line">      if (key) &#123;</span><br><span class="line">        defineKeyPropWarningGetter(props, displayName);</span><br><span class="line">      &#125;</span><br><span class="line">      if (ref) &#123;</span><br><span class="line">        defineRefPropWarningGetter(props, displayName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return ReactElement(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    self,</span><br><span class="line">    source,</span><br><span class="line">    ReactCurrentOwner.current,</span><br><span class="line">    props,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回一个生成给定类型的ReactElements的函数。（已废弃）</span><br><span class="line"> * See https://reactjs.org/docs/react-api.html#createfactory</span><br><span class="line"> */</span><br><span class="line">export function createFactory(type) &#123;</span><br><span class="line">  const factory = createElement.bind(null, type);</span><br><span class="line">  // Expose the type on the factory and the prototype so that it can be</span><br><span class="line">  // easily accessed on elements. E.g. `&lt;Foo /&gt;.type === Foo`.</span><br><span class="line">  // This should not be named `constructor` since this may not be the function</span><br><span class="line">  // that created the element, and it may not even be a constructor.</span><br><span class="line">  // Legacy hook: remove it</span><br><span class="line">  factory.type = type;</span><br><span class="line">  return factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function cloneAndReplaceKey(oldElement, newKey) &#123;</span><br><span class="line">  const newElement = ReactElement(</span><br><span class="line">    oldElement.type,</span><br><span class="line">    newKey,</span><br><span class="line">    oldElement.ref,</span><br><span class="line">    oldElement._self,</span><br><span class="line">    oldElement._source,</span><br><span class="line">    oldElement._owner,</span><br><span class="line">    oldElement.props,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  return newElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 以 element 元素为样板克隆并返回新的 React 元素</span><br><span class="line"> * See https://reactjs.org/docs/react-api.html#cloneelement</span><br><span class="line"> */</span><br><span class="line">export function cloneElement(element, config, children) &#123;</span><br><span class="line">  invariant(</span><br><span class="line">    !(element === null || element === undefined),</span><br><span class="line">    &apos;React.cloneElement(...): The argument must be a React element, but you passed %s.&apos;,</span><br><span class="line">    element,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  let propName;</span><br><span class="line"></span><br><span class="line">  // 复制原来的props</span><br><span class="line">  const props = Object.assign(&#123;&#125;, element.props);</span><br><span class="line"></span><br><span class="line">  // 提取内建props相关的值</span><br><span class="line">  let key = element.key;</span><br><span class="line">  let ref = element.ref;</span><br><span class="line">  // Self is preserved since the owner is preserved.</span><br><span class="line">  const self = element._self;</span><br><span class="line">  // Source is preserved since cloneElement is unlikely to be targeted by a transpiler, and the original source is probably a better indicator of the true owner.</span><br><span class="line">  const source = element._source;</span><br><span class="line"></span><br><span class="line">  // Owner will be preserved, unless ref is overridden</span><br><span class="line">  let owner = element._owner;</span><br><span class="line"></span><br><span class="line">  if (config != null) &#123;</span><br><span class="line">    if (hasValidRef(config)) &#123;</span><br><span class="line">      // Silently steal the ref from the parent.</span><br><span class="line">      ref = config.ref;</span><br><span class="line">      owner = ReactCurrentOwner.current;</span><br><span class="line">    &#125;</span><br><span class="line">    if (hasValidKey(config)) &#123;</span><br><span class="line">      key = &apos;&apos; + config.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Remaining properties override existing props</span><br><span class="line">    let defaultProps;</span><br><span class="line">    if (element.type &amp;&amp; element.type.defaultProps) &#123;</span><br><span class="line">      defaultProps = element.type.defaultProps;</span><br><span class="line">    &#125;</span><br><span class="line">    for (propName in config) &#123;</span><br><span class="line">      if (</span><br><span class="line">        hasOwnProperty.call(config, propName) &amp;&amp;</span><br><span class="line">        !RESERVED_PROPS.hasOwnProperty(propName)</span><br><span class="line">      ) &#123;</span><br><span class="line">        if (config[propName] === undefined &amp;&amp; defaultProps !== undefined) &#123;</span><br><span class="line">          // Resolve default props</span><br><span class="line">          props[propName] = defaultProps[propName];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          props[propName] = config[propName];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Children can be more than one argument, and those are transferred onto</span><br><span class="line">  // the newly allocated props object.</span><br><span class="line">  const childrenLength = arguments.length - 2;</span><br><span class="line">  if (childrenLength === 1) &#123;</span><br><span class="line">    props.children = children;</span><br><span class="line">  &#125; else if (childrenLength &gt; 1) &#123;</span><br><span class="line">    const childArray = Array(childrenLength);</span><br><span class="line">    for (let i = 0; i &lt; childrenLength; i++) &#123;</span><br><span class="line">      childArray[i] = arguments[i + 2];</span><br><span class="line">    &#125;</span><br><span class="line">    props.children = childArray;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return ReactElement(element.type, key, ref, self, source, owner, props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 验证对象是否为ReactElement。</span><br><span class="line"> * See https://reactjs.org/docs/react-api.html#isvalidelement</span><br><span class="line"> * @param &#123;?object&#125; object</span><br><span class="line"> * @return &#123;boolean&#125; True if `object` is a ReactElement.</span><br><span class="line"> * @final</span><br><span class="line"> */</span><br><span class="line">export function isValidElement(object) &#123;</span><br><span class="line">  return (</span><br><span class="line">    typeof object === &apos;object&apos; &amp;&amp;</span><br><span class="line">    object !== null &amp;&amp;</span><br><span class="line">    object.$$typeof === REACT_ELEMENT_TYPE</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReactElement</code> 通过 <code>createElement</code> 创建的，传入三个参数：</p><ul><li><p>type（指代 <code>ReactElement</code>的类型）</p><ul><li>字符串。<code>&#39;div&#39;</code>等，被称为 <code>HostComponent</code></li><li>Class。继承自 <code>Component</code>或者 <code>PureComponent</code>的组件，称为 <code>ClassComponent</code></li><li>方法。<code>functinal Component</code></li><li>原生。<code>Fragment</code>、<code>AsyncModel</code>、<code>Symbol</code></li></ul></li><li><p>config</p></li><li>children</li></ul><p><code>ReactElement</code>只是一个用来承载信息的容器，里面有几个信息：</p><ul><li><code>type</code>，用来判断如何创建节点</li><li><code>key</code>和 <code>ref</code>这些特殊信息</li><li><code>props</code>新的属性内容</li><li><code>$$type</code>用于确定是否属于 <code>ReactElement</code></li></ul><h4 id="ReactBaseClasses-js"><a href="#ReactBaseClasses-js" class="headerlink" title="ReactBaseClasses.js"></a>ReactBaseClasses.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import ReactNoopUpdateQueue from &apos;./ReactNoopUpdateQueue&apos;;</span><br><span class="line">/**</span><br><span class="line"> * Base class helpers for the updating state of a component.</span><br><span class="line"> */</span><br><span class="line">const emptyObject = &#123;&#125;;</span><br><span class="line">function Component(props, context, updater) &#123;</span><br><span class="line">  this.props = props;</span><br><span class="line">  this.context = context;</span><br><span class="line">  // If a component has string refs, we will assign a different object later.</span><br><span class="line">  this.refs = emptyObject;</span><br><span class="line">  // We initialize the default updater but the real one gets injected by the renderer.</span><br><span class="line">  this.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Component.prototype.isReactComponent = &#123;&#125;;</span><br><span class="line">// 核心方法</span><br><span class="line">Component.prototype.setState = function(partialState, callback) &#123;</span><br><span class="line">  invariant(</span><br><span class="line">    typeof partialState === &apos;object&apos; ||</span><br><span class="line">      typeof partialState === &apos;function&apos; ||</span><br><span class="line">      partialState == null,</span><br><span class="line">    &apos;setState(...): takes an object of state variables to update or a &apos; +</span><br><span class="line">      &apos;function which returns an object of state variables.&apos;,</span><br><span class="line">  );</span><br><span class="line">  // DOM 实现的</span><br><span class="line">  this.updater.enqueueSetState(this, partialState, callback, &apos;setState&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">// 强制更新</span><br><span class="line">Component.prototype.forceUpdate = function(callback) &#123;</span><br><span class="line">  this.updater.enqueueForceUpdate(this, callback, &apos;forceUpdate&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function ComponentDummy() &#123;&#125;</span><br><span class="line">ComponentDummy.prototype = Component.prototype;</span><br><span class="line"></span><br><span class="line">function PureComponent(props, context, updater) &#123;</span><br><span class="line">  this.props = props;</span><br><span class="line">  this.context = context;</span><br><span class="line">  // If a component has string refs, we will assign a different object later.</span><br><span class="line">  this.refs = emptyObject;</span><br><span class="line">  this.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line">const pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());</span><br><span class="line">pureComponentPrototype.constructor = PureComponent;</span><br><span class="line">// Avoid an extra prototype jump for these methods.</span><br><span class="line">Object.assign(pureComponentPrototype, Component.prototype);</span><br><span class="line">// isPureComponent 属性便于 REACT-DOM 后面辨认是否是纯组件</span><br><span class="line">pureComponentPrototype.isPureReactComponent = true;</span><br><span class="line"></span><br><span class="line">export &#123;Component, PureComponent&#125;;</span><br></pre></td></tr></table></figure><h4 id="ReactCreateRef-js"><a href="#ReactCreateRef-js" class="headerlink" title="ReactCreateRef.js"></a>ReactCreateRef.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export function createRef()&#123;</span><br><span class="line">    const refObject = &#123;</span><br><span class="line">        current:null,</span><br><span class="line">    &#125;</span><br><span class="line">    return refObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Refs 提供了一种方式，允许我们访问 DOM 节点或者在 render 方法中创建的 React 元素。</p><p>使用 Refs 的情况：</p><ul><li>管理焦点，文本选择或者媒体播放</li><li>触发强制动画</li><li>集成第三方 DOM 库</li></ul><p>使用 Refs 的方法：</p><ul><li>string ref</li><li>function</li><li>createRef</li></ul><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">export default class RefDemo extends React.Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.objRef = React.createRef();</span><br><span class="line">    // &#123;current:null&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      this.refs.stringRef.textContent = &apos;string ref got&apos;</span><br><span class="line">      this.methodRef.textContent = &apos;method ref got&apos;</span><br><span class="line">      this.objRef.current.textContent = &apos;obj ref got&apos;</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;p ref=&quot;stringRef&quot;&gt;span1&lt;/p&gt;</span><br><span class="line">        &lt;p ref=&#123;ele =&gt; (this.methodRef = ele)&#125;&gt;span3&lt;/p&gt;</span><br><span class="line">        &lt;p ref=&#123;this.objRef&#125;&gt;span3&lt;/p&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="forwardRef-js"><a href="#forwardRef-js" class="headerlink" title="forwardRef.js"></a>forwardRef.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export default function forwardRef(render:(props,ref))&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">        $$typeof:REACT_FORWARD_REF_TYPE,</span><br><span class="line">        render,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React.forwardRef 会创建一个 React 组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。</p><p>主要使用的是：</p><ul><li>转发 refs 到 DOM 组件</li><li>在高阶组件中转发 refs</li></ul><p>React.forwardRef 接受渲染函数作为参数。React 将使用 props 和 refs 作为参数来调用此函数。此函数应该返回 React 节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// PureComponent</span><br><span class="line">const TargetComponent = React.forwardRef((props,ref)=&gt;&#123;</span><br><span class="line">    &lt;input type=&quot;text&quot; ref=&#123;ref&#125; /&gt;</span><br><span class="line">&#125;)</span><br><span class="line">        </span><br><span class="line">export default class Comp extends React.Component&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super();</span><br><span class="line">        this.ref = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        this.ref.current.value = &apos;ref get input&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;TargetComponent ref=&#123;this.ref&#125;/&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReactContext.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export function createContext(defaultValue,calculateChangedBits)&#123;</span><br><span class="line">    if(calculateChangedBits === undefined)&#123;</span><br><span class="line">        calculateChangedBits = null;</span><br><span class="line">    &#125;     </span><br><span class="line">    const context = &#123;</span><br><span class="line">        $$typeof:REACT_CONTEXT_TYPE,</span><br><span class="line">        _calculateChangedBits:calculateChangedBits,</span><br><span class="line">        _currentValue:defaultValue,</span><br><span class="line">        _currentValue2:defaultValue,</span><br><span class="line">        Provider:null,</span><br><span class="line">        Consumer:null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    context.Provider = &#123;</span><br><span class="line">        $$typeof:REACT_PROVIDER_TYPE,</span><br><span class="line">        _context:context</span><br><span class="line">    &#125;</span><br><span class="line">    if(__DEV__)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        context.Consumer = context;</span><br><span class="line">    &#125;    </span><br><span class="line">    return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReactLazy-js"><a href="#ReactLazy-js" class="headerlink" title="ReactLazy.js"></a>ReactLazy.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">lazy</span>(<span class="params">ctor:(</span>)=&gt;<span class="title">Thenable</span>&lt;<span class="title">T</span>,<span class="title">R</span>&gt;)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        $$<span class="keyword">typeof</span>:REACT_LAZY_TYPE,</span><br><span class="line">        <span class="comment">// 类 promise</span></span><br><span class="line">        _ctor:ctor,</span><br><span class="line">        _status:<span class="number">-1</span>,</span><br><span class="line">        <span class="comment">// 加载完返回的结果</span></span><br><span class="line">        _result:<span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h4><p>简单用法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState,useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> [name,setName] = useState(<span class="string">'lbh'</span>);</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'component update'</span>)</span><br><span class="line">        <span class="comment">// 解除绑定</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'unbind'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    &lt;&gt;</span><br><span class="line">        &lt;p&gt;My name is:&#123;name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="text" value=&#123;name&#125; onChange=&#123;e=&gt;setName(e.target.value)&#125;&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReactChildren-js"><a href="#ReactChildren-js" class="headerlink" title="ReactChildren.js"></a>ReactChildren.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line">const SEPARATOP = &apos;.&apos;;</span><br><span class="line">const SUBSEPARATOR = &apos;:&apos;;</span><br><span class="line">function escape(key)&#123;</span><br><span class="line">    const escapeRegex = /[=:]/g;</span><br><span class="line">    const escaperLookup = &#123;</span><br><span class="line">        &apos;=&apos;:&apos;=0&apos;,</span><br><span class="line">        &apos;:&apos;:&apos;=2&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    const escapedString = (&apos;&apos;+key).replace(escapeRegex,function(match)&#123;</span><br><span class="line">        return escapeLookup[match];</span><br><span class="line">    &#125;)</span><br><span class="line">    return &apos;$&apos; + escapedString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let didWarnAboutMaps = false;</span><br><span class="line">const userProviderKeyEscapeRegex = /\/+/g;</span><br><span class="line">function escapeUserProvidedKey(text)&#123;</span><br><span class="line">    return (&apos;&apos;+text).replace(userProviderKeyEscapeRegex,&apos;$&amp;/&apos;);</span><br><span class="line">&#125;</span><br><span class="line">// 对象池</span><br><span class="line">const POOL_SIZE = 10;</span><br><span class="line">const traverseContextPool = [];</span><br><span class="line">function getPooledTraverseContext(mapResult,keyPrefix,mapFunction,mapContext)&#123;</span><br><span class="line">    if(traverseContextPool.length)&#123;</span><br><span class="line">        const traverseContext = traverseContextPool.pop();</span><br><span class="line">        traverseContext.result = mapResult;</span><br><span class="line">        traverseContext.keyPrefix = keyPrefix;</span><br><span class="line">        traverseContext.func = mapFunction;</span><br><span class="line">        traverseContext.context = mapContext;</span><br><span class="line">        traverseContext.count = 0;</span><br><span class="line">        return traverseContext;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            result:mapResult,</span><br><span class="line">            keyPrefix:keyPrefix,</span><br><span class="line">            func:mapFunction,</span><br><span class="line">            context:mapContext,</span><br><span class="line">            count:0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 释放对象属性，少于指定长度时，将对象push 对象池</span><br><span class="line">function releaseTravserContext(traverseContext)&#123;</span><br><span class="line">    traverseContext.result = null;</span><br><span class="line">    traverseContext.keyPrefix = null;</span><br><span class="line">    traverseContext.func = null;</span><br><span class="line">    traverseContext.context = null;</span><br><span class="line">    traverseContext.count = 0;</span><br><span class="line">    if(traverseContextPool.length &lt; POOL_SIZE)&#123;</span><br><span class="line">        traverseContextPool.push(traverseContext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 核心</span><br><span class="line">function traverseAllChildrenImpl(</span><br><span class="line">  children,</span><br><span class="line">  nameSoFar,</span><br><span class="line">  callback,</span><br><span class="line">  traverseContext,</span><br><span class="line">) &#123;</span><br><span class="line">  const type = typeof children;</span><br><span class="line"></span><br><span class="line">  if (type === &apos;undefined&apos; || type === &apos;boolean&apos;) &#123;</span><br><span class="line">    children = null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let invokeCallback = false;</span><br><span class="line"></span><br><span class="line">  if (children === null) &#123;</span><br><span class="line">    invokeCallback = true;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">      case &apos;string&apos;:</span><br><span class="line">      case &apos;number&apos;:</span><br><span class="line">        invokeCallback = true;</span><br><span class="line">        break;</span><br><span class="line">      case &apos;object&apos;:</span><br><span class="line">        switch (children.$$typeof) &#123;</span><br><span class="line">          case REACT_ELEMENT_TYPE:</span><br><span class="line">          case REACT_PORTAL_TYPE:</span><br><span class="line">            invokeCallback = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (invokeCallback) &#123;</span><br><span class="line">    callback(</span><br><span class="line">      traverseContext,</span><br><span class="line">      children,</span><br><span class="line">      nameSoFar === &apos;&apos; ? SEPARATOR + getComponentKey(children, 0) : nameSoFar,</span><br><span class="line">    );</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let child;</span><br><span class="line">  let nextName;</span><br><span class="line">  let subtreeCount = 0; </span><br><span class="line">  const nextNamePrefix =</span><br><span class="line">    nameSoFar === &apos;&apos; ? SEPARATOR : nameSoFar + SUBSEPARATOR;</span><br><span class="line"></span><br><span class="line">  if (Array.isArray(children)) &#123;</span><br><span class="line">    for (let i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">      child = children[i];</span><br><span class="line">      nextName = nextNamePrefix + getComponentKey(child, i);</span><br><span class="line">      subtreeCount += traverseAllChildrenImpl(</span><br><span class="line">        child,</span><br><span class="line">        nextName,</span><br><span class="line">        callback,</span><br><span class="line">        traverseContext,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    const iteratorFn = getIteratorFn(children);</span><br><span class="line">    if (typeof iteratorFn === &apos;function&apos;) &#123;</span><br><span class="line">      const iterator = iteratorFn.call(children);</span><br><span class="line">      let step;</span><br><span class="line">      let ii = 0;</span><br><span class="line">      while (!(step = iterator.next()).done) &#123;</span><br><span class="line">        child = step.value;</span><br><span class="line">        nextName = nextNamePrefix + getComponentKey(child, ii++);</span><br><span class="line">        subtreeCount += traverseAllChildrenImpl(</span><br><span class="line">          child,</span><br><span class="line">          nextName,</span><br><span class="line">          callback,</span><br><span class="line">          traverseContext,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (type === &apos;object&apos;) &#123;</span><br><span class="line">      let addendum = &apos;&apos;;</span><br><span class="line">      const childrenString = &apos;&apos; + children;</span><br><span class="line">      invariant(</span><br><span class="line">        false,</span><br><span class="line">        &apos;Objects are not valid as a React child (found: %s).%s&apos;,</span><br><span class="line">        childrenString === &apos;[object Object]&apos;</span><br><span class="line">          ? &apos;object with keys &#123;&apos; + Object.keys(children).join(&apos;, &apos;) + &apos;&#125;&apos;</span><br><span class="line">          : childrenString,</span><br><span class="line">        addendum,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return subtreeCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function traverseAllChildren(children,callback,traverseContext)&#123;</span><br><span class="line">    if(children === null)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return traverseAllChildrenImpl(children,&apos;&apos;,callback,traverseContext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getComponentKey(component,index)&#123;</span><br><span class="line">    if(</span><br><span class="line">        typeof component === &apos;object&apos; &amp;&amp; </span><br><span class="line">        component !== null &amp;&amp;</span><br><span class="line">        component.key != null</span><br><span class="line">    )&#123;</span><br><span class="line">        return escape(component.key);</span><br><span class="line">    &#125;</span><br><span class="line">    return index.toString(36);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function forEachSingleChild(bookKeeping,child,name)&#123;</span><br><span class="line">    const &#123; func, context &#125; = bookKeeping;</span><br><span class="line">    func.call(context,child,bookKeeping.count++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function forEachChildren(children, forEachFunc, forEachContext) &#123;</span><br><span class="line">  if (children == null) &#123;</span><br><span class="line">    return children;</span><br><span class="line">  &#125;</span><br><span class="line">  const traverseContext = getPooledTraverseContext(</span><br><span class="line">    null,</span><br><span class="line">    null,</span><br><span class="line">    forEachFunc,</span><br><span class="line">    forEachContext,</span><br><span class="line">  );</span><br><span class="line">  traverseAllChildren(children, forEachSingleChild, traverseContext);</span><br><span class="line">  releaseTraverseContext(traverseContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mapSingleChildIntoContext(bookKeeping, child, childKey) &#123;</span><br><span class="line">  const &#123;result, keyPrefix, func, context&#125; = bookKeeping;</span><br><span class="line"></span><br><span class="line">  let mappedChild = func.call(context, child, bookKeeping.count++);</span><br><span class="line">  if (Array.isArray(mappedChild)) &#123;</span><br><span class="line">    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c =&gt; c);</span><br><span class="line">  &#125; else if (mappedChild != null) &#123;</span><br><span class="line">    if (isValidElement(mappedChild)) &#123;</span><br><span class="line">      mappedChild = cloneAndReplaceKey(</span><br><span class="line">        mappedChild,</span><br><span class="line">        keyPrefix +</span><br><span class="line">          (mappedChild.key &amp;&amp; (!child || child.key !== mappedChild.key)</span><br><span class="line">            ? escapeUserProvidedKey(mappedChild.key) + &apos;/&apos;</span><br><span class="line">            : &apos;&apos;) +</span><br><span class="line">          childKey,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(mappedChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mapIntoWithKeyPrefixInternal(children,array,prefix,func,context)&#123;</span><br><span class="line">    let escapedPrefix = &apos;&apos;;</span><br><span class="line">    if(prefix != null)&#123;</span><br><span class="line">        escapedPrefix = escapeUserProvidedKey(prefix)+&apos;/&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    const traverseContext = getPooledTraverseContext(</span><br><span class="line">        array,</span><br><span class="line">        escapedPrefix,</span><br><span class="line">        func,</span><br><span class="line">        context</span><br><span class="line">    )</span><br><span class="line">    traverseAllChildren(children,mapSingleChildIntoContext,traverseContext);</span><br><span class="line">    releaseTraverseContext(traverseContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mapChildren(children,func,context)&#123;</span><br><span class="line">    if(children == null)&#123;</span><br><span class="line">        return children;</span><br><span class="line">    &#125;</span><br><span class="line">    const result = [];</span><br><span class="line">    mapIntoWithKeyPrefixInternal(children,result,null,func,context);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function countChildren(children)&#123;</span><br><span class="line">    return traverseAllChildren(children,()=&gt;null,null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function toArray(children)&#123;</span><br><span class="line">    const result = [];</span><br><span class="line">    mapIntoWithKeyPrefixInternal(children,result,null,child =&gt; child)</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function onlyChild(children) &#123;</span><br><span class="line">  invariant(</span><br><span class="line">    isValidElement(children),</span><br><span class="line">    &apos;React.Children.only expected to receive a single React element child.&apos;,</span><br><span class="line">  );</span><br><span class="line">  return children;</span><br><span class="line">&#125;</span><br><span class="line">export &#123;</span><br><span class="line">forEachChild as forEach,</span><br><span class="line">    mapChildren as map,</span><br><span class="line">    countChildren as count,</span><br><span class="line">    onlyChild as only,</span><br><span class="line">    toArray,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要方法流程图：</p><pre class="mermaid">graph TDA(开始)contextPool(contextPool)mapIntoWithKeyPrefixInternal(mapIntoWithKeyPrefixInternal)traverseAllChildren(traverseAllChildren)traverseAllChildrenImpl(traverseAllChildrenImpl)mapSingleChildrenContext(mapSingleChildrenContext)是否多个节点{是否多个节点}isArray{isArray}循环每个节点((循环每个节点))对每个节点调用mapFunc返回map之后的节点(对每个节点调用mapFunc返回map之后的节点)往result中推入clone节点并替换key(往result中推入clone节点并替换key)A --> mapIntoWithKeyPrefixInternalmapIntoWithKeyPrefixInternal -. 开始的时候获取 .-> contextPoolmapIntoWithKeyPrefixInternal -. 结束之后归还 .-> contextPoolmapIntoWithKeyPrefixInternal --> traverseAllChildrentraverseAllChildren --> traverseAllChildrenImpltraverseAllChildrenImpl --> 是否多个节点是否多个节点 --Y--> 循环每个节点是否多个节点 --N--> mapSingleChildrenContext循环每个节点 --> traverseAllChildrenImplmapSingleChildrenContext --> 对每个节点调用mapFunc返回map之后的节点对每个节点调用mapFunc返回map之后的节点 --> isArrayisArray --Y--> mapIntoWithKeyPrefixInternalisArray --N--> 往result中推入clone节点并替换key</pre><h4 id="ReactContext-js"><a href="#ReactContext-js" class="headerlink" title="ReactContext.js"></a>ReactContext.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export function createCOntext(defaultValue,calculateChangedBits)&#123;</span><br><span class="line">    if(calculateChangedBits === undefined)&#123;</span><br><span class="line">        calculateChangedBits = null;</span><br><span class="line">    &#125;</span><br><span class="line">    const context = &#123;</span><br><span class="line">        $$typeof:REACT_CONTEXT_TYPE,</span><br><span class="line">        _calculateChangeBits:calculateChangeBits,</span><br><span class="line">        _currentValue:defaultValue,</span><br><span class="line">        _currentValue2:defaultValue,</span><br><span class="line">        Provider:null,</span><br><span class="line">        Consumer:null</span><br><span class="line">    &#125;</span><br><span class="line">    context.Provider = &#123;</span><br><span class="line">        $$typeof:REACT_PROVIDER_TYPE,</span><br><span class="line">        _context:context,</span><br><span class="line">    &#125;</span><br><span class="line">    context.Consumer = context;</span><br><span class="line">    return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="memo-js"><a href="#memo-js" class="headerlink" title="memo.js"></a>memo.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">memo</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"> type: React$ElementType,</span></span></span><br><span class="line"><span class="function"><span class="params"> compare?: (oldProps: Props, newProps: Props</span>) =&gt; <span class="title">boolean</span>,</span></span><br><span class="line"><span class="function">    )</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        $$<span class="keyword">typeof</span>:REACT_MEMO_TYPE,</span><br><span class="line">        type,</span><br><span class="line">        compare:compare === <span class="literal">undefined</span> ? <span class="literal">null</span> : compare,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建更新的方式"><a href="#创建更新的方式" class="headerlink" title="创建更新的方式"></a>创建更新的方式</h3><p>主要是下面的知识点：</p><p><code>ReactDOM.render</code>、<code>ReactDOM.render</code>、<code>setState</code>、<code>forceUpdate</code></p><p>步骤：</p><ul><li>创建 ReactRoot</li><li>创建 FiberRoot 和 RootFiber</li><li>创建更新</li></ul><h4 id="ReactDOM-js"><a href="#ReactDOM-js" class="headerlink" title="ReactDOM.js"></a>ReactDOM.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// ReactDOM</span><br><span class="line">const ReactDOM = &#123;</span><br><span class="line">    createPortal,</span><br><span class="line">    findDOMNode(</span><br><span class="line">    componentOrElement,</span><br><span class="line">    )&#123;</span><br><span class="line">        if (componentOrElement == null) &#123;</span><br><span class="line">          return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (componentOrElement.nodeType === ELEMENT_NODE) &#123;</span><br><span class="line">          return componentOrElement;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // REACTElememt,DOM包裹节点，回调方法</span><br><span class="line">    hydrate(element,container,callback)&#123;</span><br><span class="line">        return legacyRenderSubtreeIntoContainer(</span><br><span class="line">        null,</span><br><span class="line">            element,</span><br><span class="line">            container,</span><br><span class="line">            // 协调更新的选项</span><br><span class="line">            true,</span><br><span class="line">            callback</span><br><span class="line">        )</span><br><span class="line">    &#125;,</span><br><span class="line">    render(element,container,callback)&#123;</span><br><span class="line">        return legacyRenderSubtreeIntoContainer(</span><br><span class="line">            null,</span><br><span class="line">            element,</span><br><span class="line">            container,</span><br><span class="line">            false,</span><br><span class="line">            callback</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>render 与 hydrate 方法都可以传入三个参数，包括 ReactElement、DOM包裹节点和渲染结束后执行的回调方法，返回 <code>legacyRenderSubtreeIntoContainer</code> 方法执行的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">function legacyRenderSubtreeIntoContainer(</span><br><span class="line"> parentComponent,</span><br><span class="line"> children,</span><br><span class="line"> container,</span><br><span class="line"> forceHydrate,</span><br><span class="line"> callback</span><br><span class="line">)&#123;</span><br><span class="line">     let root;</span><br><span class="line">     if(!root)&#123;</span><br><span class="line">         root = container._reactRootContainer = legacyCreateRootFromDOMContainer(</span><br><span class="line">             container,</span><br><span class="line">             forceHydrate,</span><br><span class="line">         )</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">function legacyCreateRootFromDOMContainer(</span><br><span class="line"> container,</span><br><span class="line"> forceHydrate,</span><br><span class="line">)&#123;</span><br><span class="line">     const shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);</span><br><span class="line">     // 没有ssr的情况</span><br><span class="line">     if(!shouldHydrate)&#123;</span><br><span class="line">         let rootSibling;</span><br><span class="line">         while((rootSibling = container.lastChild))&#123;</span><br><span class="line">             // 删除 container 下面的所有子节点</span><br><span class="line">             container.removeChild(rootSibling)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;     </span><br><span class="line">     const isConcurrent = false;</span><br><span class="line">     return new ReactRoot(container,isConcurrent,shouldHydrate)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function shouldHydrateDueToLegacyHeuristic()&#123;</span><br><span class="line">    const rootElement = getReactRootElementInContainer(container);</span><br><span class="line">    return !!(</span><br><span class="line">        rootElement &amp;&amp; </span><br><span class="line">        // 普通element节点</span><br><span class="line">        rootElement.nodeType === ELEMENT_NODE &amp;&amp; </span><br><span class="line">        // data-reactroot 老版本ssr的节点</span><br><span class="line">        rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getReactRootElementInContainer(container)&#123;</span><br><span class="line">    if(!container)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断节点</span><br><span class="line">    if(container.nodeType === DOCUMENT_NODE)&#123;</span><br><span class="line">        return container.documentElement;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return container.firstChild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断 root 是否不存在，不存在调用<code>legacyCreateRootFromDOMContainer</code>，传入 <code>container</code>,<code>forceHydrate</code>两个参数。<code>legacyCreateRootFromDOMContainer</code>函数创建了一个 <code>ReactRoot</code>，而 <code>forceHydrate</code>布尔类型参数在 <code>hydrate</code> 传入 <code>true</code>,在 <code>render</code> 里面传入 <code>false</code>。前者是服务器渲染，后者是客户端渲染。服务器渲染当服务器呈现标记的节点，React 会保留它并附加事件处理程序，从而具有高性能的首屏加载，客户端渲染当初始DOM与当前 DOM 存在差异，则可能会更改节点。可以看到 如果是 <code>false</code>会 <code>container.removeChild(rootSibling)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">function ReactRoot(</span><br><span class="line"> container,</span><br><span class="line"> isConcurrent,</span><br><span class="line"> hydrate</span><br><span class="line">)&#123;</span><br><span class="line">     const root = DOMRender.createContainer(container,isConcurrent,hydrate);</span><br><span class="line">     this._internalRoot = root;</span><br><span class="line"> &#125;</span><br><span class="line">// react-reconciler/inline.dom</span><br><span class="line">function createContainer(</span><br><span class="line"> containerInfo,</span><br><span class="line">  isConcurrent,</span><br><span class="line">  hydrate</span><br><span class="line">)&#123;</span><br><span class="line">     // 创建 FiberRoot</span><br><span class="line">     return createFiberRoot(container,isConcurrent,hydrate)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">// ReactFiberRoot</span><br><span class="line">export function createFiberRoot(</span><br><span class="line">  containerInfo,</span><br><span class="line">  isConcurrent,</span><br><span class="line">  hydrate,</span><br><span class="line">): FiberRoot &#123;</span><br><span class="line">    // </span><br><span class="line">  const uninitializedFiber = createHostRootFiber(isConcurrent);</span><br><span class="line"></span><br><span class="line">  let root;</span><br><span class="line">  if (enableSchedulerTracing) &#123;</span><br><span class="line">    root = &#123;</span><br><span class="line">      current: uninitializedFiber,</span><br><span class="line">      containerInfo: containerInfo,</span><br><span class="line">      pendingChildren: null,</span><br><span class="line"></span><br><span class="line">      earliestPendingTime: NoWork,</span><br><span class="line">      latestPendingTime: NoWork,</span><br><span class="line">      earliestSuspendedTime: NoWork,</span><br><span class="line">      latestSuspendedTime: NoWork,</span><br><span class="line">      latestPingedTime: NoWork,</span><br><span class="line"></span><br><span class="line">      didError: false,</span><br><span class="line"></span><br><span class="line">      pendingCommitExpirationTime: NoWork,</span><br><span class="line">      finishedWork: null,</span><br><span class="line">      timeoutHandle: noTimeout,</span><br><span class="line">      context: null,</span><br><span class="line">      pendingContext: null,</span><br><span class="line">      hydrate,</span><br><span class="line">      nextExpirationTimeToWorkOn: NoWork,</span><br><span class="line">      expirationTime: NoWork,</span><br><span class="line">      firstBatch: null,</span><br><span class="line">      nextScheduledRoot: null,</span><br><span class="line"></span><br><span class="line">      interactionThreadID: unstable_getThreadID(),</span><br><span class="line">      memoizedInteractions: new Set(),</span><br><span class="line">      pendingInteractionMap: new Map(),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    root = &#123;</span><br><span class="line">      current: uninitializedFiber,</span><br><span class="line">      containerInfo: containerInfo,</span><br><span class="line">      pendingChildren: null,</span><br><span class="line"></span><br><span class="line">      earliestPendingTime: NoWork,</span><br><span class="line">      latestPendingTime: NoWork,</span><br><span class="line">      earliestSuspendedTime: NoWork,</span><br><span class="line">      latestSuspendedTime: NoWork,</span><br><span class="line">      latestPingedTime: NoWork,</span><br><span class="line"></span><br><span class="line">      didError: false,</span><br><span class="line"></span><br><span class="line">      pendingCommitExpirationTime: NoWork,</span><br><span class="line">      finishedWork: null,</span><br><span class="line">      timeoutHandle: noTimeout,</span><br><span class="line">      context: null,</span><br><span class="line">      pendingContext: null,</span><br><span class="line">      hydrate,</span><br><span class="line">      nextExpirationTimeToWorkOn: NoWork,</span><br><span class="line">      expirationTime: NoWork,</span><br><span class="line">      firstBatch: null,</span><br><span class="line">      nextScheduledRoot: null,</span><br><span class="line">    &#125;;</span><br><span class="line">    uninitializedFiber.stateNode = root;</span><br><span class="line">    return root;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;知其然知其所以然，框架工的自我尝试进阶&lt;/p&gt;
&lt;h2 id=&quot;React源码浅析&quot;&gt;&lt;a href=&quot;#React源码浅析&quot; class=&quot;headerlink&quot; title=&quot;React源码浅析&quot;&gt;&lt;/a&gt;React源码浅析&lt;/h2&gt;&lt;p&gt;知识点：&lt;/p&gt;
&lt;p&gt;&lt;st
      
    
    </summary>
    
      <category term="React" scheme="http://laibh.top/categories/React/"/>
    
    
      <category term="源码" scheme="http://laibh.top/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://laibh.top/2019-06-25-regExp.html"/>
    <id>http://laibh.top/2019-06-25-regExp.html</id>
    <published>2019-06-25T01:30:54.000Z</published>
    <updated>2022-03-04T10:00:38.464Z</updated>
    
    <content type="html"><![CDATA[<p>最近这段时间因为赶项目，一直没有更新博客。精通正则这本书一年前翻阅过过一些。用到的地方不多，便很快就忘记了。今忙里抽空复习一下正则，在项目中也会有所用到。主要是跟随<a href="http://deerchao.net/tutorials/regex/regex-1.htm">正则表达式30分钟入门教程</a>，再结合 JS 中的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式</a>进行复习。</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>编写处理字符串的程序或者网页时候，经常会有查找符合复杂规则的字符串的需要。正则表达式就是用于描述这些规。即记录文本规则的代码。</p><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>在一篇英文小说中查找 <code>hi</code>，可以使用正则 <code>hi</code>。它可以精确匹配这样的字符串：由两个字符组成，前一个字符是 <code>h</code>，后一个字符串是 <code>i</code>。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，可以匹配 <code>hi</code>、<code>HI</code>、<code>Hi</code>、<code>hI</code>这四种情况中的任意的一种。</p><p><code>hi</code>这个正则表达式也会匹配 <code>him</code>、<code>history</code>、<code>high</code>等，如果要精确查找到 <code>hi</code>这个单词的话，应该使用正则表达式 <code>\bhi\b</code>。</p><p><code>\b</code>是正则表达式规定一个特殊代码（元字符），代表着单词的开头或者结尾，也就是单词的分界处。英文的单词一般是由空格，标点符号或者换行符来分隔的，但是 <code>\b</code>并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。</p><p>如果要找到是 <code>hi</code>后面不远处跟着一个 <code>Lucy</code>，就要使用正则表达式 <code>\bhi\b.*\bLucy\b</code>。这里的 <code>.</code>是一个元字符，匹配除了换行符外的任意字符。<code>*</code>同样是元字符，不过它代表的不是字符，也不是位置。而是数量，它指定 <code>*</code>前边的内容可以连续重复使用任意次以使整个正则表达式得到匹配。因此 <code>.*</code>连在一起就意味着任意数量的不包括换行的字符。现在 <code>\bhi\b.*\bLucy\b</code>的意思就是：先是一个单词<code>hi</code>，然后是任意个任意字符（但不能是换行），最后是 <code>Lucy</code>整个单词。</p><p>如果使用其他元字符，可以构造更强大的正则表达式，比如下面的例子</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>\d\d-\d\d\d\d\d\d\d\d</span><br><span class="line"><span class="comment"># 以 0 开头，然后是两个数字，然后是一个连字符'-'，最后是8个数字（也就是中国的电话号码，只能匹配区号是3位的情况）</span></span><br><span class="line"><span class="comment"># \d 是一个新的元字符。匹配一个数字。'-'不是元字符，只匹配它本身——连字符（或者减号，或者中横线等）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简化</span></span><br><span class="line"><span class="number">0</span>\d<span class="string">&#123;2&#125;</span>-d<span class="string">&#123;8&#125;</span></span><br><span class="line"><span class="comment"># \d 后面&#123;2&#125; 和 &#123;8&#125;的意思必须连续重复匹配2（8）次</span></span><br></pre></td></tr></table></figure><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>常用的元字符</p><table><thead><tr><th>代码</th><th>说明</th><th>相当于</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配换行符以外的任意字符</td><td></td></tr><tr><td><code>\w</code></td><td>匹配字母或数字或下划线或汉字</td><td></td></tr><tr><td><code>\s</code></td><td>匹配任意的空白符（包括空格、制表符（Tab）、换行符，中文全角空格）</td><td></td></tr><tr><td><code>\d</code></td><td>匹配数字</td><td></td></tr><tr><td><code>\b</code></td><td>匹配单词的开始或者结束</td><td></td></tr><tr><td><code>^</code></td><td>匹配字符串的开始</td><td></td></tr><tr><td><code>$</code></td><td>匹配字符串的结束</td></tr></tbody></table><p>元字符 <code>^</code>和 <code>$</code>都匹配一个位置，这和 <code>\b</code>有点类似。<code>^</code>匹配想要用来查找的字符串的开头，<code>$</code>匹配结尾。</p><p><code>\d+</code>匹配1个或者更多连续的数字。<code>+</code>是和 <code>*</code>类似的元字符，不同的是 <code>*</code>匹配重复任意次（可能是0次），而 <code>+</code>则匹配重复1次或者更多次。</p><p><code>\b\w{6}\b</code>匹配刚好 6个字符的单词</p><p><code>\d{5,12}</code> 表示匹配字符串里面包含 5 到 12 连续位数字，而不是整个字符串是 5 到 12 位数字</p><p><code>^\d{5,12}$</code>则是精确匹配整个字符串就是 5 到 12 位数字</p><h3 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h3><p>如果想要查找元字符本身的话，比如查找<code>.</code>或者 <code>*</code>就需要转义，<code>\</code>可以来取消这些字符的特殊意义</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找 .</span></span><br><span class="line">\.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找 *</span></span><br><span class="line">\*</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 查找 \</span></span><br><span class="line">\\</span><br></pre></td></tr></table></figure><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p>下面是正则表达式中所有限定符（指定数量的代码）</p><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>重复0次或者更多次</td></tr><tr><td>+</td><td>重复1次或者更多次</td></tr><tr><td>？</td><td>重复0次或者1次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>{n,m}</td><td>重复n次到m次</td></tr></tbody></table><p><code>Windows\d+</code> 匹配 <code>Windows</code>后面跟1个或者跟多数字</p><p><code>^\w+</code>匹配一行的第一个单词（或者整个字符串的第一个单词）</p><h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><p>要想查找数字、字母或者数字，空白是很简单的，因为已经有对应的这些字符集合的元字符，但是想匹配没有预定字符的字符集合（比如元音字母 <code>a</code>/<code>e</code>/<code>i</code>/<code>o</code>/<code>u</code>）。</p><p>只需要在方括号中列出它们就可以了,<code>[aeiou]</code>就匹配任何一个英文元音字母，<code>[.?!]</code>匹配标点符号（<code>.</code>或<code>?</code>或<code>!</code>）</p><p>也可以轻松指定一个字符范围，<code>[0-9]</code>的含义和  <code>\d</code>是完全一致的：一个数字。</p><p><code>[a-z0-9A-Z]</code>也完全等同于 <code>\w</code>（如果值考虑英文的话）</p><p>思考：</p><p><code>\(?0\d{2}[) -]?\d{8}</code></p><p>上面的表达式，可以匹配几种格式的电话号码，像（010）88888888，或者010-88888888。它首先是一个转义字符，它能出现0次或者1次（？）,然后是一个0，后面跟着两个数字（d{2}），然后是<code>）</code>或者<code>-</code>或者空格中的一个，它出现1次或者不出现，最后是8个数字。</p><h3 id="分枝条件"><a href="#分枝条件" class="headerlink" title="分枝条件"></a>分枝条件</h3><p>上面思考题，其实也可以匹配 010)8888888或者 （010-88888888 这样不正确的格式。要解决这个问题，需要用到分枝条件。正则表达式里面的分枝条件是有几种规则的。如果满足其中任意一个规则应该都当成匹配，具体的方法是用 <code>|</code>把不同的规则都分隔开。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>\d<span class="string">&#123;2&#125;</span>-\d<span class="string">&#123;8&#125;</span>|<span class="number">0</span>\d<span class="string">&#123;3&#125;</span>-d<span class="string">&#123;7&#125;</span></span><br><span class="line"><span class="comment"># 这个表达式可以匹配两种连字符分隔的电话号码：一种是三位区号的，8位本地号。另一种是4位区号的，7个本地号的</span></span><br><span class="line">\(<span class="number">0</span>\d<span class="string">&#123;2&#125;</span>\)[- ]?\d<span class="string">&#123;8&#125;</span>|<span class="number">0</span>\d<span class="string">&#123;2&#125;</span>[- ]?\d<span class="string">&#123;8&#125;</span></span><br><span class="line"><span class="comment"># 这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。可以试试用分支条件把这个表达式扩展成支持4位区号的</span></span><br><span class="line">\d<span class="string">&#123;5&#125;</span>-\d<span class="string">&#123;4&#125;</span>|\d<span class="string">&#123;5&#125;</span></span><br><span class="line"><span class="comment"># 这个表达式用于匹配美国的邮政编码。它的规则是5位数字，或者用连字号间隔的9位数字。</span></span><br><span class="line"><span class="comment"># 这要需要注意，不能改成 \d&#123;5&#125;|\d&#123;5&#125;-d&#123;4&#125;，这样就只会匹配5位邮编（以及9位邮编的前5位）。原因是匹配分支条件时，会从左到右测试每个条件，如果满足了某个分支的话，就不会去管其他条件了。</span></span><br></pre></td></tr></table></figure><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>重复单个字符，直接在字符后面加上限定符就好了。如果想要重复多个字符的话，可以用小括号来指定子表达式（分组），然后就可以指定这个子表达式的重复次数了，或者是其他的操作。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（\d&#123;<span class="number">1</span>,<span class="number">3</span>&#125;\.)<span class="string">&#123;3&#125;</span>\d&#123;<span class="number">1</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment"># 上面是一个简答的 ip地址匹配。\d&#123;1,3&#125;匹配1到3位数字</span></span><br><span class="line"><span class="comment"># (\d&#123;1,3&#125;\.)&#123;3&#125;匹配三位数字加上一个英文句号，这个整体也是这个分组重复了3次，最后再加上一个1到3位的数字 \d&#123;1,3&#125;</span></span><br><span class="line"><span class="comment"># 缺漏的地方在于它也会匹配 256.300.899.999 这种不存在的ip 地址。</span></span><br><span class="line"><span class="comment"># 正确的地址(ip地址中每个数字都不能大于255，可以有前导0)</span></span><br><span class="line">((<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>]\d|<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]|[<span class="number">01</span>]?\d\d?)\.)<span class="string">&#123;3&#125;</span>(<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>]\d|<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]|[<span class="number">01</span>]?\d\d?)</span><br></pre></td></tr></table></figure><h3 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h3><p>有时候需要查找的不是某个能简单定义的字符类的字符。比如想查找除了数字以外的，其他任意字符都行的情况，这时候就需要反义。</p><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td><code>\W</code></td><td>匹配任意不是字母、数字、下划线或者汉字的字符</td></tr><tr><td><code>\S</code></td><td>匹配任意不是空白符的字符</td></tr><tr><td><code>\D</code></td><td>匹配任意不是数字的字符</td></tr><tr><td><code>\B</code></td><td>匹配不是单词开头或者结束的位置</td></tr><tr><td><code>[^X]</code></td><td>匹配除了 X 以外的任意的字符</td></tr><tr><td><code>[^aeiou]</code></td><td>匹配除了 aeiou 这个字母与以外的任意字符</td></tr></tbody></table><p>例子：</p><p><code>\S+</code>匹配不包括空白符的字符串</p><p><code>&lt;a[^&gt;]+&gt;</code>匹配用尖括号括起来的以 <code>a</code>开头的字符串</p><h3 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h3><p>使用小括号指定一个子表达式后，匹配这个子表达式的文本（也就是此分组捕获的内容）可以在表达式或者其他程序中作进一步的处理。默认情况下，每个分组都会自动拥有一个组号，规则就是：从左到右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，依次类推。</p><p>分组0代表整个正则表达式，实际上组号分配过程是要从左向右扫描两遍的，第一遍只给未命名组分配，第二遍只给命名组分配，因为所有命名组的组号都大于未命名的组号。</p><p>可以使用 <code>(?:exp)这样的语法来剥夺一个分组对组号分配的参与权</code></p><p>后向引用，用于重复搜索前面的某个分组匹配的文本。例如，<code>\1</code>代表分组1匹配的文本。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\b(\w+)\b\<span class="keyword">s</span>+\<span class="number">1</span>\b</span><br><span class="line"><span class="comment"># 匹配重复的单词，这个表达式首先是一个单词，也就是单词开始处和单词结束处之间多于一个的字母或者数字（\b(\w+)\b），这个单词会被捕获到编码为1的分组中，然后是1个或者几个空白符(\s+)，最后分组1中捕获的内容（也就是前面匹配的那个单词）（\1）</span></span><br></pre></td></tr></table></figure><p>也可以自己指定子表达式的组名，要指定一个子表达式的组名，使用这样的语法:</p><p><code>(?&lt;Word&gt;\w+)</code>或者<code>(?&#39;Word&#39;\w+)</code>这样就把 <code>\w</code>的组名指定为 Word。要反向引用这个分组捕获的内容，可以使用<code>\k&lt;Word&gt;</code>，上面的例子也可以写成这样：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\b(?&lt;Word&gt;\w+)\b\<span class="keyword">s</span>+\k&lt;Word&gt;\b</span><br></pre></td></tr></table></figure><p>下表是常用分组语法：</p><table><thead><tr><th>分类</th><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>捕获</td><td>(exp)</td><td>匹配 exp,并捕获文本到自动命名的组里</td></tr><tr><td></td><td>(?\<name>exp)</td><td>匹配 exp，并捕获文本到名称为 name 的组里，也可以写成 <code>(?&#39;name&#39;exp)</code></td></tr><tr><td></td><td>(?:exp)</td><td>匹配 exp，不捕获匹配的文本，也不给此分组的分配组号</td></tr><tr><td>零宽断言</td><td>(?= exp)</td><td>匹配 exp 前面的位置</td></tr><tr><td></td><td>(?&lt;= exp)</td><td>匹配 exp 后面的位置</td></tr><tr><td></td><td>(?!exp)</td><td>匹配后面跟的不是 exp 的位置</td></tr><tr><td></td><td>(?&lt;!exp)</td><td>匹配前面不是 exp 的位置</td></tr><tr><td>注释</td><td>(?#comment)</td><td>这种类型的分组不对正则表达式的处理产生任何影响，用于注释让人阅读</td></tr></tbody></table><h3 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h3><p>断言用来声明一个应该为真的事实，正则表达式中只有当断言为真的时候才会继续进行匹配。</p><p>用于查找在某些内容前或者之后的东西，像 <code>\b</code>、<code>^</code>、<code>$</code>那样用于指定一个位置，这个位置应该满足一定的条件（断言），因此它们被称为零宽断言。</p><p><code>(?=exp)</code>也叫零宽度正预测先行断言（Zero-width positive lookahead），它断言自身出现的位置的后面能匹配表达式 exp。比如，<code>\b\w+(?=ing\b)</code>，匹配以 <code>ing</code>为结尾的单词的前面部分（除了 ing 以外的部分），如查找 <code>I&#39;m singing while you&#39;re dancing.</code>时，它会匹配 <code>sing</code>和 <code>danc</code></p><p><code>(?&lt;=exp)</code>也叫零宽度正回顾后发断言(Zero-width positive lookbehind)，它断言自身出现的为位置的前面能匹配表示达 exp，比如 <code>(?&lt;=\bre)\w+\b</code>会匹配以 <code>re</code>开头的单词的后半部分（除了re 以外的部分）。例如在查找 <code>reading a book</code>时，它匹配 <code>ading</code>。</p><p>假如想要给一个很长的数字中每三位加一个逗号，从右边加。可以这样查找前面和里面添加逗号的部分：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">((?&lt;=\d)\d<span class="string">&#123;3&#125;</span>)+\b</span><br><span class="line"><span class="comment"># 查找 1234567890 =&gt; 234567890</span></span><br><span class="line"></span><br><span class="line">（?&lt;=\<span class="keyword">s</span>）\d+(?=\<span class="keyword">s</span>)</span><br><span class="line"><span class="comment"># 匹配以空白符间隔的数字，不包括这些空白符</span></span><br><span class="line"><span class="comment"># 查找 1234 56 7890 =&gt; 56</span></span><br></pre></td></tr></table></figure><h3 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h3><p>前面提到怎么查找不是某个字符或者不在某个字符类里面的字符的方法（反义）。但是如果我们只是想确保某个字符没有出现，但不想去匹配它时，例如查找这样的单词——它里面的出现了字母q,但是q后面跟着的不是字母 u，我们可以尝试：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\b\w*<span class="string">q[^u]</span>\w*\b</span><br><span class="line"><span class="comment"># 匹配包含后面不是字母u 的字母q的单词。但是你可以发现 [^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]总要匹配一个字符，或者是句号或者是其他的什么。后面的 \w*\b 将会匹配下一个单词，于是 上面的表达式就可以匹配整个  Iraq fighting。</span></span><br><span class="line"><span class="comment"># 负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。</span></span><br><span class="line">\b\w*<span class="string">q(?!u)</span>\w*\b</span><br></pre></td></tr></table></figure><p>零宽度负预测先行断言(?!exp)(Zero-width negative lookahead)，断言此位置后面不能匹配表达式exp。</p><p>例如：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\d<span class="string">&#123;3&#125;</span>(?!\d)</span><br><span class="line"><span class="comment"># 匹配三位数字，而且这三位数字的后面不能是数字</span></span><br><span class="line">\b((?!abc)\w)+\b</span><br><span class="line"><span class="comment"># 匹配不包括连续字符串 abc 的单词</span></span><br></pre></td></tr></table></figure><p>同理可以用零宽度负回顾后发断言(?&lt;!exp)(Zero-width negative lookbehind)，来断言此位置的前面不能匹配表达式 <code>(?&lt;![a-z])\d{7}</code>,即前面不是小写字母的七位数字</p><p>一个更加复杂的例子：</p><p><code>(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)</code></p><p>匹配不包含属性的简单 html 标签内的内容。<code>(?&lt;=&lt;(\w+)&gt;)</code>指定了这样的前缀：被尖括号括起来的单词，然后是 <code>.*</code>(任意的字符串)，最后一个是后缀<code>(?=&lt;\/\1&gt;)</code>。<code>\/</code>转义了，<code>\1</code>反向引用，整个内容就是闭合标签之间的内容，不包括两个标签本身。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>小括号的另一种用途是通过语法<code>(?#comment)</code>来包含注释。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)</span><br></pre></td></tr></table></figure><p>要包含注释的话，最好是启用“忽略模式里面的空白符”选项。这样在编写表达式时能任意的添加空格/TAB/换行，而实际使用时这些都被忽略。启用这个选项后，在 <code>#</code>后面到这一行结束的所有文本都被当做注释忽略掉。例如，我们可以前面的一个表达式写成这样：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(?&lt;=<span class="comment"># 断言要匹配的文本的前缀</span></span><br><span class="line">&lt;(\w+)&gt; <span class="comment"># 查找尖括号括起来的字母或者数字（即HTML/XML标签）</span></span><br><span class="line">)       <span class="comment"># 前缀结束</span></span><br><span class="line">.*      <span class="comment"># 匹配任意文本</span></span><br><span class="line">(?=     <span class="comment"># 断言要匹配的文本的后缀</span></span><br><span class="line">&lt;\/\<span class="number">1</span>&gt;  <span class="comment"># 查找尖括号括起来的内容：前面是一个 '/'，后面是先前捕获的标签</span></span><br><span class="line">)       <span class="comment"># 后缀结束</span></span><br></pre></td></tr></table></figure><h3 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h3><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例子：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索 <code>aabab</code>的话，它就会匹配整个 <code>aabab</code>，这被称为贪婪匹配。</p><p>有时候，我们需要懒惰匹配，也就是尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号 <code>?</code>。这样，<code>.?</code>这意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。</p><p><code>a.*?b</code>匹配最短的，以a开始，以b结束的字符串。如果把它应用于 <code>aabab</code>的话，它会匹配 <code>aab</code>和 <code>ab</code></p><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td><code>*?</code></td><td>重复任意次，但尽可能少重复</td></tr><tr><td><code>+?</code></td><td>重复 1次或者更多次，但尽可能少重复</td></tr><tr><td><code>??</code></td><td>重复 0 次或者 1 次，但尽可能少重复</td></tr><tr><td><code>{n,m}？</code></td><td>重复 n 到 m 次，但尽可能少重复</td></tr><tr><td><code>{n,}?</code></td><td>重复  n 次以上，但尽可能少重复</td></tr></tbody></table><h2 id="JS-中的正则表达式"><a href="#JS-中的正则表达式" class="headerlink" title="JS 中的正则表达式"></a>JS 中的正则表达式</h2><p>正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象，这些模式被用于 <code>RegExp</code>的<code>test</code>和 <code>exec</code>，以及 <code>String</code>的 <code>match</code>、<code>replace</code>、<code>search</code>和 <code>split</code>方法。</p><h3 id="创建一个正则表达式"><a href="#创建一个正则表达式" class="headerlink" title="创建一个正则表达式"></a>创建一个正则表达式</h3><p>1.使用一个正则表达式字面量，其由包含斜杠之间的模式组成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/ab+c/</span>;</span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^[a-zA-Z]+[0-9]*\W?_$/gi</span></span><br></pre></td></tr></table></figure><p>2.调用<code>RegExp</code>对象的构造函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'ab+c'</span>);</span><br><span class="line"><span class="keyword">let</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/^[a-zA-Z]+[0-9]*\W?_$/</span>,<span class="string">'gi'</span>)</span><br><span class="line"><span class="keyword">let</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"^[a-zA-Z]+[0-9]*\\W?_$"</span>,<span class="string">"gi"</span>)</span><br></pre></td></tr></table></figure><h3 id="编写一个正则表达式的模式"><a href="#编写一个正则表达式的模式" class="headerlink" title="编写一个正则表达式的模式"></a>编写一个正则表达式的模式</h3><p>一个正则表达式的模式由简单的字符所构成，比如 <code>/abc/</code>，或是简单和特殊字符的组合，比如 <code>/ab*c/</code>或者 <code>/Chapter(\d+)\.\d*/</code>。后者用到了括号，它在正则表达中可以被当作是一个记忆设备。这一部分正则所匹配的字符会被记住，在后面可以利用。</p><p><strong>使用简单的模式</strong></p><p>简单的模式由找到的直接匹配所构成的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/abc/</span><br><span class="line"><span class="comment">// 匹配 Hi, do you know your abc's? </span></span><br><span class="line"><span class="comment">// 匹配 The latest airplane designs evolved from slabcraft.? </span></span><br><span class="line"><span class="comment">// 不匹配 Grab crab</span></span><br></pre></td></tr></table></figure><p><strong>使用特殊字符</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ab*c/</span><br><span class="line"><span class="comment">// 匹配 cbbabbbbcdebc =&gt; abbbbc</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td><code>\</code></td><td>在非特殊字符之前的反斜杆表示下一个字符是特殊的。<br>反斜杆也可以将其后的特殊字符，转义为字面量。<br>使用 <code>new RegExp(&#39;pattern&#39;)</code>的时候要将 <code>\</code>转义，因为 <code>\</code>在字符串里面也是一个转义字符</td></tr><tr><td><code>^</code></td><td>匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。</td></tr><tr><td><code>$</code></td><td>匹配输入的结束。如果多行标识符被设置为 true，那么也会匹配换行符之前的位置。0</td></tr><tr><td><code>*</code></td><td>匹配前一个表示0 次或者多次。等价于<code>{0,}</code></td></tr><tr><td><code>+</code></td><td>匹配前面一个表达式1次或者更多次，等价于 <code>{1,}</code></td></tr><tr><td><code>?</code></td><td>匹配前面一个表达式0次或者1次。等价于<code>{0,1}</code><br>如果紧跟在任何量词 <code>*</code>、<code>+</code>、<code>?</code>、<code>{}</code>后面，将会使得量词变成非贪婪（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反</td></tr><tr><td><code>.</code></td><td>（小数点）匹配除换行符之外面的任何单个字符</td></tr><tr><td><code>(x)</code></td><td>匹配 ‘x’并记住匹配项。括号被称为捕获括号。<br>模式<code>/(foo)(bar)\1\2/</code><br>在正式表达式的替换环节，使用 <code>$1</code>的语法，例如 <code>&#39;bar.foo&#39;.replace(/(..)(..)/,&#39;$2$1&#39;)</code></td></tr><tr><td><code>(?:x)</code></td><td>匹配‘x’但不记住匹配项。这种叫做非捕获括号，使得你能够定义与正则表达式运算符一起使用的子表达式。<br></td></tr><tr><td><code>x(?=y)</code></td><td>匹配‘x’仅仅当’x’后面跟着‘y’。这种叫先行断言。<br><code>/Jack(?=Spart)/</code>会匹配到 ‘Jack’仅当它后面跟着’Spart’。但是‘Spart’都不是匹配结果中的一部分</td></tr><tr><td><code>(?&lt;=y)x</code></td><td>匹配‘x’仅仅当’x’前面是‘y’,这种叫做后行断言。<br><code>/(?&lt;=Jack)Spart/</code>会匹配到 ‘Spart’仅仅当它前面是‘Jack’。<br>`/(?&lt;=Jack</td><td>Tom)Spart/`会匹配到 ’Spart‘仅仅当它前面是 ’Jack‘或者是 ‘Tom’。但是’Tom‘和’Jack‘都不是匹配结果的一部分</td></tr><tr><td><code>x(?！y)</code></td><td>匹配’x‘仅仅当’x‘后面不跟着’y‘,这个叫做正向否定查找。<br><code>/\d+(?!\.)/</code>匹配一个数字仅仅当这个数字后面没有跟小数点的时候。</td></tr><tr><td>`x</td><td>y`</td><td>匹配’x‘或者’y‘。</td></tr><tr><td><code>{n}</code></td><td>n是一个正整数，匹配了前面一个字符刚好发生了 n 次</td></tr><tr><td><code>{n,m}</code></td><td>n 和 m 都是整数。匹配前面的字符至少 n 次，最多 m 次。如果 n 或者 m 的值是0，这个值会被忽略。</td></tr><tr><td><code>[xyz]</code></td><td>一个字符的集合。匹配方括号中的任意字符，包括转义序列。可以用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊意义。</td></tr><tr><td><code>[^xyz]</code></td><td>一个反向字符集。匹配任何没有包含在方括号中的字符。同样可以使用破折号来指定一个字符范围。</td></tr><tr><td><code>[\b]</code></td><td>匹配一个退格(U+0008)</td></tr><tr><td><code>\b</code></td><td>匹配一个词的边界。一个词的边界就是一个词不被另外一个字字符跟随的位置或者没有其他“字”字符在其前面的位置。</td></tr><tr><td><code>\B</code></td><td>匹配一个非单词边界。匹配一个前后字符都是相同类型的位置。都是’字‘字符或者都不是’字‘字符。一个字符串的开始和结尾都被认为不是‘字’字符，或者是字符串。</td></tr><tr><td><code>\cX</code></td><td>当 X 是处于A 到 Z 之间的字符的时候，匹配字符串中的一个控制符</td></tr><tr><td><code>\d</code></td><td>匹配一个数字</td></tr><tr><td><code>\D</code></td><td>匹配一个非数字字符</td></tr><tr><td><code>\f</code></td><td>匹配一个换页符（U+000C）</td></tr><tr><td><code>\n</code></td><td>匹配一个换行符（U+000A）</td></tr><tr><td><code>\r</code></td><td>匹配一个回车符（U+000D）</td></tr><tr><td><code>\s</code></td><td>匹配一个空白符号，包括空格、制表符、换页符和换行符。<br>等价于<code>[\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]</code></td></tr><tr><td><code>\S</code></td><td>匹配一个非空白字符。<br>等价于<code>[^</code>\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff<code>]</code>。</td></tr><tr><td><code>\t</code></td><td>匹配一个水平制表符（U+0009）</td></tr><tr><td><code>\v</code></td><td>匹配一个垂直制表符（U+000B）</td></tr><tr><td><code>\w</code></td><td>匹配一个单字字符（字母、数字或者下划线）<br>等价于  <code>[A-Za-z0-9_]</code></td></tr><tr><td><code>\W</code></td><td>匹配一个单字字符<br>等价于 <code>[^A-Za-z0-9_]</code></td></tr><tr><td><code>\n</code></td><td>在正则表达式中，它返回最后的第 n 个子捕获匹配的子字符串（捕获的数目以左括号计数）</td></tr><tr><td><code>\0</code></td><td>匹配 NULL(U+0000)字符，不要在这后面跟着其他小数，因为 <code>\0&lt;digits&gt;</code>是一个八进制转义序列</td></tr><tr><td><code>\xhh</code></td><td>与代码 hh 匹配字符（两个十六进制数字）</td></tr><tr><td><code>\uhhhh</code></td><td>与代码 <code>hhhh</code>匹配字符（四个十六进制数字）</td></tr></tbody></table><h3 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h3><p>正则表达式被用于 RegExp 的 exec 和 test 方法，还有 String  的 match、replace、search和 split 方法。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>exec</code></td><td>一个在字符串中执行查找匹配的 RegExp 方法，它返回一个数组(未匹配返回 null)</td></tr><tr><td><code>test</code></td><td>一个在字符串中测试是否匹配的 RegExp 方法，它返回 true 或者 false</td></tr><tr><td><code>match</code></td><td>一个在字符串中执行查找匹配的 String 方法，它返回一个数组或者在未匹配时返回 null</td></tr><tr><td><code>search</code></td><td>一个在字符串中测试匹配的 String  方法，它返回匹配到的位置索引，或者在失败时返回 -1</td></tr><tr><td><code>replace</code></td><td>一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉后面的子字符串</td></tr><tr><td><code>split</code></td><td>一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的字符串存储到数组中的 String 方法</td></tr></tbody></table><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 脚本使用 exec 方法在一个字符串中查找一个匹配</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/d(b+)d/g</span>;</span><br><span class="line"><span class="comment">/**reg参数</span></span><br><span class="line"><span class="comment">* 5 lastIndex 下一个匹配的索引值</span></span><br><span class="line"><span class="comment">* "d(b+)d" source 模式文本。在正则表达式创建时更新，不执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> myArray = reg.exec(<span class="string">"cdbbdbsbz"</span>)</span><br><span class="line">myArray; <span class="comment">// ["dbbd", "bb", index: 1, input: "cdbbdbsbz", groups: undefined]</span></span><br><span class="line"><span class="comment">/** myArray参数</span></span><br><span class="line"><span class="comment">* ["dbbd,bb"] 匹配到的字符和所有被记住的子字符串</span></span><br><span class="line"><span class="comment">* 1 1input 初始字符串</span></span><br><span class="line"><span class="comment">* input:cdbbdbsbz  初始字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 不需要访问正则表达式的属性，通过另一个方法来创建</span></span><br><span class="line">myArray = <span class="regexp">/d(b+)d/g</span>.exec(<span class="string">"cdbbdbsbz"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过一个字符串构建正则表达式，还有另一种方式</span></span><br><span class="line">reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"d(b+)d"</span>,<span class="string">"g"</span>);</span><br><span class="line">myArray = reg.exec(<span class="string">"cdbbdbsbz"</span>)</span><br></pre></td></tr></table></figure><h4 id="使用括号的子字符串匹配"><a href="#使用括号的子字符串匹配" class="headerlink" title="使用括号的子字符串匹配"></a>使用括号的子字符串匹配</h4><p>一个正则表达式模式使用括号，将导致相应的子匹配被记住。使用括号匹配的子字符串的数量是无限的。返回的数组中保存所有被发现的子匹配。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(\w+)\s(\w+)/</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'John Smith'</span>;</span><br><span class="line"><span class="keyword">let</span> newStr = str.replace(reg,<span class="string">"$2,$1"</span>)</span><br><span class="line">newStr; <span class="comment">// "Smith,John"</span></span><br></pre></td></tr></table></figure><h4 id="通过标志进行高级搜索"><a href="#通过标志进行高级搜索" class="headerlink" title="通过标志进行高级搜索"></a>通过标志进行高级搜索</h4><p>正则表达式有四个可选参数进行全局和不区分大小写搜索，这些参数可以单独使用也可以一起使用在任何顺序和包含正则表达式的部分中。</p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td><code>g</code></td><td>全局搜索</td></tr><tr><td><code>i</code></td><td>不区分大小写搜索</td></tr><tr><td><code>m</code></td><td>多行搜索(使用该标志，<code>^</code>和 <code>$</code>匹配的开始或者结束输入字符串的)</td></tr><tr><td><code>y</code></td><td>执行“粘性”搜索，匹配从目标字符串的当前位置开始，可以使用 <code>y</code>标志</td></tr></tbody></table><p>格式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/pattern/</span>flags;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\w+\s/g</span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"pattern"</span>,<span class="string">"flags"</span>)</span><br><span class="line">reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\w+\\s"</span>,<span class="string">"g"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近这段时间因为赶项目，一直没有更新博客。精通正则这本书一年前翻阅过过一些。用到的地方不多，便很快就忘记了。今忙里抽空复习一下正则，在项目中也会有所用到。主要是跟随&lt;a href=&quot;http://deerchao.net/tutorials/regex/regex-1.ht
      
    
    </summary>
    
      <category term="正则表达式" scheme="http://laibh.top/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
      <category term="正则表达式" scheme="http://laibh.top/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面试官问我HTML5是什么（下）</title>
    <link href="http://laibh.top/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91HTML5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E4%B8%8B%EF%BC%89.html"/>
    <id>http://laibh.top/面试官问我HTML5是什么（下）.html</id>
    <published>2019-05-30T01:30:54.000Z</published>
    <updated>2022-03-04T10:00:38.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><p>发展历史</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CSS1 -&gt; CSS2 -&gt; CSS2.1 -&gt;CSS3</span><br></pre></td></tr></table></figure><p><strong>模块与模块化结构</strong></p><p>CSS3采用了分工协作的模块化结构</p><p>其中最重要的 CSS3 模块包括：</p><ul><li>选择器</li><li>框模型</li><li>背景和边框</li><li>文本效果</li><li>2D/3D 转换</li><li>动画</li><li>多列布局</li><li>用户界面</li></ul><h3 id="CSS3-新增的选择器"><a href="#CSS3-新增的选择器" class="headerlink" title="CSS3 新增的选择器"></a>CSS3 新增的选择器</h3><p><strong>属性选择器</strong></p><table><thead><tr><th>选择器</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td><em>E[att^=”val”]</em></td><td>属性 <code>att</code>的值以 <code>val</code>开头的元素</td><td><code>div[id^=&#39;haha&#39;]</code></td></tr><tr><td><em>E[att$=”val”]</em></td><td>属性 <code>att</code>的值以 <code>val</code>结尾的元素</td><td><code>div[id^=&#39;haha&#39;]</code></td></tr><tr><td><em>E[att</em>=”val”]</td><td>属性 <code>att</code>的值包含 <code>val</code>字符串的元素</td><td><code>div[id^=&#39;haha&#39;]</code></td></tr></tbody></table><p><strong>结构性伪类选择器</strong></p><table><thead><tr><th>选择器</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td><em>E:root</em></td><td>匹配文档的根元素，对于 HTML 文档就是 HTML元素</td><td></td></tr><tr><td><em>E:not(s)</em></td><td>匹配不符合当前选择器的任何元素</td><td><code>div:not([class=&quot;demo&quot;])</code>:除了<code>class</code>为<code>demo</code>的div以外</td></tr><tr><td><em>E:empty</em></td><td>匹配一个不包含任何子元素的元素（文本节点也被看成子元素，空格也是一个元素）</td><td></td></tr><tr><td><em>E:target</em></td><td>匹配被 <code>location.hash</code>选中的元素（即锚点元素），选择器可以用来选取当前活动的目标元素</td><td></td></tr><tr><td><em>E:first-child</em></td><td>匹配<code>E</code>父元素的第一个子元素,如果当前位置元素不是前面所修饰的元素，那么无效</td><td><code>li:first-child</code>:匹配页面中所有第一个<code>li</code></td></tr><tr><td><em>E:last-child</em></td><td>匹配<code>E</code>父元素的最后一个子元素，等同于 <code>E:nth-last-child(1)</code>,如果当前位置元素不是前面所修饰的元素，那么无效</td><td></td></tr><tr><td><em>E:nth-child(n)</em></td><td>匹配<code>E</code>父元素的第<code>n</code>个元素，第一个编号为1,如果当前位置元素不是前面所修饰的元素，那么无效</td><td></td></tr><tr><td><em>E:nth–last-child(n)</em></td><td>匹配<code>E</code>父元素的倒数第n个子元素，第一个编号为1,如果当前位置元素不是前面所修饰的元素，那么无效</td><td></td></tr><tr><td><em>E:nth-of-type(n)</em></td><td>与<code>E:nth-child()</code>类似，但是仅匹配使用同种标签的元素</td><td><code>p:nth-of-type(2)</code>:匹配父元素的第2个子元素p</td></tr><tr><td><em>E:first-of-type(n)</em></td><td>匹配父元素使用同种标签的第一个子元素，等同于 <code>E:nth-of-type(1)</code></td><td></td></tr><tr><td><em>E:last-of-type(n)</em></td><td>匹配父元素使用同种标签的最后一个子元素，等同于 <code>E:nth-last-of-type(1)</code></td><td></td></tr><tr><td><em>E:nth-last-of-type(n)</em></td><td>与 <code>E:nth-last-child(n)</code>类似，但是仅匹配使用相同标签的元素</td><td></td></tr><tr><td><em>E:only-child</em></td><td>匹配父元素下仅有的一个子元素，等同于 <code>E:first-child:last-child</code>或者 <code>E:nth-child(1):nth-last-child(1)</code></td><td></td></tr><tr><td><em>E：only-of-type</em></td><td>匹配父元素下使用同种标签的唯一一个子元素，等同于 <code>E:first-of-type:last-of-type</code>或者 <code>E:nth-of-type(1):nth-last-of-type(1)</code></td><td></td></tr><tr><td>备注：</td><td><code>n</code>里面可以是 odd(奇数)、even(偶数)</td><td>循环使用样式：<code>li:nth-child(2n+1)</code></td></tr></tbody></table><p><strong>UI状态伪类选择器</strong></p><table><thead><tr><th>选择器</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td><em>E:enabled</em></td><td>匹配表单中激活的元素</td><td></td></tr><tr><td><em>E:disabled</em></td><td>匹配表单中禁用的元素</td><td></td></tr><tr><td><em>E:checked</em></td><td>匹配表单中被选中的单选框或者复选框</td><td></td></tr><tr><td><em>E::selection</em></td><td>匹配用户用鼠标当前选中的元素</td><td><code>user-select: none;</code>取消鼠标选中的默认样式</td></tr><tr><td><em>E:read-only</em></td><td>匹配选中只读的元素</td><td><code>&lt;input type=&quot;text&quot; readonly=&quot;readonly&quot; value=&quot;hahha&quot;/&gt;</code></td></tr><tr><td><em>E:read-write</em></td><td>匹配选中非只读的元素</td><td><code>&lt;input type=&quot;text&quot; value=&quot;hahha&quot;/&gt;</code></td></tr></tbody></table><p><strong>级元素通用选择器</strong></p><table><thead><tr><th>选择器</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td><code>E~F</code></td><td>匹配任何在 <code>E</code>元素之后的同级元素 <code>F</code></td><td>p~ul{background:#ff9;}</td></tr></tbody></table><ol><li>E：hover</li><li>E：active</li><li>E：focus</li><li>E：enabled</li><li>E：disabled</li><li>E：read-only</li><li>E：read-write</li><li>E：checked</li><li>E：default</li><li>E：indeterminate</li><li>E：selection</li></ol><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><ol><li>简单属性选择</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*把包含某个attribute的所有边元素变成红色*/</span></span><br><span class="line">*<span class="selector-attr">[attribute]</span>&#123;<span class="attribute">color</span>:red&#125;</span><br><span class="line"><span class="comment">/*只对有attribute属性的div元素应用样式*/</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[attribute]</span>&#123;<span class="attribute">color</span>:red&#125;</span><br><span class="line"><span class="comment">/*根据多个属性，同时拥有attribute1和attribute2的元div应用样式*/</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[attribute1]</span><span class="selector-attr">[attribute2]</span>&#123;<span class="attribute">color</span>:red&#125;</span><br><span class="line"><span class="comment">/*对有alt属性的图像*/</span></span><br><span class="line"><span class="selector-tag">img</span><span class="selector-attr">[alt]</span>&#123;<span class="attribute">border</span>:<span class="number">5px</span> solid red&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>根据具体属性选择</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*某个具体的a标签*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href="http://laibh.top"]</span>&#123;<span class="attribute">color</span>:red&#125;;</span><br><span class="line"><span class="comment">/*加多一个限制*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href="http://laibh.top"]</span><span class="selector-attr">[title="赖同学"]</span>&#123;<span class="attribute">color</span>:red&#125;;</span><br><span class="line"><span class="comment">/*不要忽略空格*/</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[class="red small"]</span>&#123;<span class="attribute">color</span>:red&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>根据部分属性值选择</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*选择 class属性中包含 important元素的 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[class~="important"]</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">[abc^=”def”]</td><td style="text-align:left">选择 abc 属性值以 “def” 开头的所有元素</td></tr><tr><td style="text-align:left">[abc$=”def”]</td><td style="text-align:left">选择 abc 属性值以 “def” 结尾的所有元素</td></tr><tr><td style="text-align:left">[abc*=”def”]</td><td style="text-align:left">选择 abc 属性值中包含子串 “def” 的所有元素</td></tr></tbody></table><ol start="4"><li>特定属性选择类型</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这个规则会选择 lang 属性等于 en 或以 en- 开头的所有元素*/</span></span><br><span class="line">*<span class="selector-attr">[lang|="en"]</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure><p><strong>css属性选择器表</strong></p><table><thead><tr><th style="text-align:left">选择器</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">[<em>attribute</em>]</td><td style="text-align:left">用于选取带有指定属性的元素。</td></tr><tr><td style="text-align:left">[<em>attribute</em>=<em>value</em>]</td><td style="text-align:left">用于选取带有指定属性和值的元素。</td></tr><tr><td style="text-align:left">[<em>attribute</em>~=<em>value</em>]</td><td style="text-align:left">用于选取属性值中包含指定词汇的元素。</td></tr><tr><td style="text-align:left">[<em>attribute</em>\</td><td style="text-align:left">=<em>value</em>]</td><td>用于选取带有以指定值开头的属性值的元素，该值必须是<strong>整个单词</strong>。</td></tr><tr><td style="text-align:left">[<em>attribute</em>^=<em>value</em>]</td><td style="text-align:left">匹配属性值以指定值开头的每个元素。（CSS3新增）</td></tr><tr><td style="text-align:left">[<em>attribute</em>$=<em>value</em>]</td><td style="text-align:left">匹配属性值以指定值结尾的每个元素。（CSS3新增）</td></tr><tr><td style="text-align:left">[<em>attribute**=</em>value*]</td><td style="text-align:left">匹配属性值中包含指定值的每个元素。（CSS3新增）</td></tr></tbody></table><h3 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a>伪类与伪元素</h3><h4 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h4><p>CSS2定义：用于向某些选择器添加特殊的效果。</p><p>CSS3定义：</p><ol><li>伪类的存在是为了通过选择器找到那些不存于DOM树中的信息以及不能被常规 CSS选择器获取到的信息（:target）</li><li>伪类由<strong>一个</strong>冒号<code>:</code>开头，冒号后面是伪类的名称和包含在圆括号中的可选参数</li><li>任何常规选择器都可以在任何位置使用伪类。伪类语法不区分大小写。一些伪类的作用会互斥，另外一些伪类可以同时被同一个元素使用。并且，为了满足用户在操作  DOM时产生的 DOM 结构变化，伪类也可以是动态的</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">selector</span> : <span class="selector-tag">pseudo-class</span>&#123; <span class="attribute">property</span>:value &#125;</span><br><span class="line"><span class="selector-tag">selector</span><span class="selector-class">.class</span> : <span class="selector-tag">pseudo-class</span>&#123; <span class="attribute">property</span>:value &#125;</span><br></pre></td></tr></table></figure><p><strong>锚伪类</strong>（不存在于 DOM树的信息）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>&#123;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>&#123;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;&#125;</span><br><span class="line"><span class="selector-tag">a</span>;<span class="selector-tag">active</span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.tab_content</span> &#123;</span></span><br><span class="line"><span class="undefined">  height: 800px;</span></span><br><span class="line"><span class="undefined">  background: red;</span></span><br><span class="line"><span class="undefined">  margin-bottom: 100px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#tab1</span><span class="selector-pseudo">:target</span>, <span class="selector-id">#tab2</span><span class="selector-pseudo">:target</span>, <span class="selector-id">#tab3</span><span class="selector-pseudo">:target</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line"><span class="undefined">&#125;    </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tab1"</span> <span class="attr">class</span>=<span class="string">"tab_content"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--tabed content--&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tab2"</span> <span class="attr">class</span>=<span class="string">"tab_content"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--tabed content--&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tab3"</span> <span class="attr">class</span>=<span class="string">"tab_content"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--tabed content--&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--:target通过CSS实现了常规CSS无法实现的逻辑--&gt;</span></span><br></pre></td></tr></table></figure><p><strong>伪类表</strong></p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th><th style="text-align:left">CSS</th></tr></thead><tbody><tr><td style="text-align:left">:active</td><td style="text-align:left">向被激活的元素添加样式。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:focus</td><td style="text-align:left">向拥有键盘输入焦点的元素添加样式。</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">:hover</td><td style="text-align:left">当鼠标悬浮在元素上方时，向元素添加样式。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:link</td><td style="text-align:left">向未被访问的链接添加样式。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:visited</td><td style="text-align:left">向已被访问的链接添加样式。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:first-child</td><td style="text-align:left">向元素的第一个子元素添加样式。</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">:lang</td><td style="text-align:left">向带有指定 lang 属性的元素添加样式。</td><td style="text-align:left">2</td></tr></tbody></table><h4 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h4><p>CSS2定义：用于向某些选择器设置特殊效果</p><p>CSS3定义：</p><ol><li>伪元素在DOM树中创建了一些抽象元素，这些抽象元素是不存在文档语言里面的（html源码）。如：document接口不提供访问元素内容的第一个字或者第一行的机制，而伪元素可以使得开发者提取到这些信息。并且，一些伪元素可以使开发者获取到不存在与源文档中的内容（<code>:before</code>/<code>:after</code>）</li><li>伪元素由<strong>两个</strong>冒号<code>:：</code>开头，然后是伪元素的名称</li><li>使用<code>::</code>是为了区分伪类和伪元素（CSS2中没有区别）。考虑兼容性的话，CSS2中的已存伪元素可以使用 <code>:</code>，但是 CSS3的就要使用 <code>::</code></li><li>一个选择器只能使用一个伪元素，并且伪元素必须处于选择器语句的最后</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">selector</span><span class="selector-pseudo">:pseudo-element</span>&#123;<span class="attribute">property</span>:value&#125;</span><br><span class="line"><span class="selector-tag">selector</span><span class="selector-class">.class</span><span class="selector-pseudo">:pseudo-element</span>&#123;<span class="attribute">property</span>:value&#125;</span><br></pre></td></tr></table></figure><p><code>:first-line</code></p><p>用于向文本的首行设置特殊样式(只能用于块级元素)</p><p>下面属性可以应用这个伪元素</p><ul><li>font</li><li>color</li><li>background</li><li>word-spacing</li><li>letter-spacing</li><li>text-decoration</li><li>vertical-align</li><li>text-transform</li><li>line-height</li><li>clear</li></ul><p><code>:first-letter</code></p><p>用于向文本的首字母设置特殊样式</p><p>下面的属性可以应用这个伪元素</p><ul><li>font</li><li>color</li><li>background</li><li>margin</li><li>padding</li><li>border</li><li>text-decoration</li><li>vertical-align(当 float为none)</li><li>text-transform</li><li>line-height</li><li>float</li><li>clear</li></ul><p><code>:before</code></p><p>在元素内容前面插入新内容</p><p><code>:after</code></p><p>在元素内容之后插入新内容</p><p><strong>伪元素表</strong></p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th><th style="text-align:left">CSS</th></tr></thead><tbody><tr><td style="text-align:left">:first-letter</td><td style="text-align:left">向文本的第一个字母添加特殊样式。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:first-line</td><td style="text-align:left">向文本的首行添加特殊样式。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:before</td><td style="text-align:left">在元素之前添加内容。</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">:after</td><td style="text-align:left">在元素之后添加内容。</td><td style="text-align:left">2</td></tr></tbody></table><h4 id="伪类与伪元素特性与区别"><a href="#伪类与伪元素特性与区别" class="headerlink" title="伪类与伪元素特性与区别"></a>伪类与伪元素特性与区别</h4><ol><li>伪类本质上是为了弥补常规 CSS 选择器的不足，以便获取更多的信息（不存在 DOM树的信息，不能被常规CSS选择器获取的信息）</li><li>伪元素本质上是创建了一个有内容的虚拟容器,这个容器不包含任何DOM元素，但是可以包含内容</li><li>CSS3 中的伪类和伪元素的语法不同（<code>:</code>与<code>::</code>）</li><li>可以同时使用多个伪类，而只能同时使用一个伪元素</li></ol><h3 id="完整表格"><a href="#完整表格" class="headerlink" title="完整表格"></a>完整表格</h3><table><thead><tr><th style="text-align:left">选择器</th><th style="text-align:left">示例</th><th style="text-align:left">示例说明</th><th style="text-align:left">CSS</th></tr></thead><tbody><tr><td style="text-align:left">.<em>class</em></td><td style="text-align:left">.intro</td><td style="text-align:left">选择所有class=”intro”的元素</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">#<em>id</em></td><td style="text-align:left">#firstname</td><td style="text-align:left">选择所有id=”firstname”的元素</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">*</td><td style="text-align:left">选择所有元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><em>element</em></td><td style="text-align:left">p</td><td style="text-align:left">选择所有<p>元素</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left"><em>element,element</em></td><td style="text-align:left">div,p</td><td style="text-align:left">选择所有<div>元素和<p>元素</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left"><em>element</em> <em>element</em></td><td style="text-align:left">div p</td><td style="text-align:left">选择<div>元素内的所有<p>元素</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left"><em>element</em>&gt;<em>element</em></td><td style="text-align:left">div&gt;p</td><td style="text-align:left">选择所有父级是 <div> 元素的 <p> 元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><em>element</em>+<em>element</em></td><td style="text-align:left">div+p</td><td style="text-align:left">选择所有紧接着<div>元素之后的<p>元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><em>attribute</em></td><td style="text-align:left">[target]</td><td style="text-align:left">选择所有带有target属性元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><em>attribute</em>=<em>value</em></td><td style="text-align:left">[target=-blank]</td><td style="text-align:left">选择所有使用target=”-blank”的元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><em>attribute</em>~=<em>value</em></td><td style="text-align:left">[title~=flower]</td><td style="text-align:left">选择标题属性包含单词”flower”的所有元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><em>attribute</em></td><td style="text-align:left">=<em>language</em>[lang\</td><td style="text-align:left">=en]</td><td style="text-align:left">选择 lang 属性以 en 为开头的所有元素</td><td>2</td></tr><tr><td style="text-align:left">:link</td><td style="text-align:left">a:link</td><td style="text-align:left">选择所有未访问链接</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:visited</td><td style="text-align:left">a:visited</td><td style="text-align:left">选择所有访问过的链接</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:active</td><td style="text-align:left">a:active</td><td style="text-align:left">选择活动链接</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:hover</td><td style="text-align:left">a:hover</td><td style="text-align:left">选择鼠标在链接上面时</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:focus</td><td style="text-align:left">input:focus</td><td style="text-align:left">选择具有焦点的输入元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">:first-letter</td><td style="text-align:left">p:first-letter</td><td style="text-align:left">选择每一个<P>元素的第一个字母</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:first-line</td><td style="text-align:left">p:first-line</td><td style="text-align:left">选择每一个<P>元素的第一行</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:first-child</td><td style="text-align:left">p:first-child</td><td style="text-align:left">指定只有当<p>元素是其父级的第一个子级的样式。</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">:before</td><td style="text-align:left">p:before</td><td style="text-align:left">在每个<p>元素之前插入内容</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">:after</td><td style="text-align:left">p:after</td><td style="text-align:left">在每个<p>元素之后插入内容</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">:lang(<em>language</em>)</td><td style="text-align:left">p:lang(it)</td><td style="text-align:left">选择一个lang属性的起始值=”it”的所有<p>元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><em>element1</em>~<em>element2</em></td><td style="text-align:left">p~ul</td><td style="text-align:left">选择p元素之后的每一个ul元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left"><em>attribute</em>^=<em>value</em></td><td style="text-align:left">a[src^=”https”]</td><td style="text-align:left">选择每一个src属性的值以”https”开头的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left"><em>attribute</em>$=<em>value</em></td><td style="text-align:left">a[src$=”.pdf”]</td><td style="text-align:left">选择每一个src属性的值以”.pdf”结尾的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left"><em>attribute</em>=<em>value</em></td><td style="text-align:left">a[src*=”runoob”]</td><td style="text-align:left">选择每一个src属性的值包含子字符串”runoob”的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:first-of-type</td><td style="text-align:left">p:first-of-type</td><td style="text-align:left">选择每个p元素是其父级的第一个p元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:last-of-type</td><td style="text-align:left">p:last-of-type</td><td style="text-align:left">选择每个p元素是其父级的最后一个p元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:only-of-type</td><td style="text-align:left">p:only-of-type</td><td style="text-align:left">选择每个p元素是其父级的唯一p元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:only-child</td><td style="text-align:left">p:only-child</td><td style="text-align:left">选择每个p元素是其父级的唯一子元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:nth-child(<em>n</em>)</td><td style="text-align:left">p:nth-child(2)</td><td style="text-align:left">选择每个p元素是其父级的第二个子元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:nth-last-child(<em>n</em>)</td><td style="text-align:left">p:nth-last-child(2)</td><td style="text-align:left">选择每个p元素的是其父级的第二个子元素，从最后一个子项计数</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:nth-of-type(<em>n</em>)</td><td style="text-align:left">p:nth-of-type(2)</td><td style="text-align:left">选择每个p元素是其父级的第二个p元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:nth-last-of-type(<em>n</em>)</td><td style="text-align:left">p:nth-last-of-type(2)</td><td style="text-align:left">选择每个p元素的是其父级的第二个p元素，从最后一个子项计数</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:last-child</td><td style="text-align:left">p:last-child</td><td style="text-align:left">选择每个p元素是其父级的最后一个子级。</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:root</td><td style="text-align:left">:root</td><td style="text-align:left">选择文档的根元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:empty</td><td style="text-align:left">p:empty</td><td style="text-align:left">选择每个没有任何子级的p元素（包括文本节点）</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:target</td><td style="text-align:left">#news:target</td><td style="text-align:left">选择当前活动的#news元素（包含该锚名称的点击的URL）</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:enabled</td><td style="text-align:left">input:enabled</td><td style="text-align:left">选择每一个已启用的输入元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:disabled</td><td style="text-align:left">input:disabled</td><td style="text-align:left">选择每一个禁用的输入元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:checked</td><td style="text-align:left">input:checked</td><td style="text-align:left">选择每个选中的输入元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:not(<em>selector</em>)</td><td style="text-align:left">:not(p)</td><td style="text-align:left">选择每个并非p元素的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">::selection</td><td style="text-align:left">::selection</td><td style="text-align:left">匹配元素中被用户选中或处于高亮状态的部分</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:out-of-range</td><td style="text-align:left">:out-of-range</td><td style="text-align:left">匹配值在指定区间之外的input元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:in-range</td><td style="text-align:left">:in-range</td><td style="text-align:left">匹配值在指定区间之内的input元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:read-write</td><td style="text-align:left">:read-write</td><td style="text-align:left">用于匹配可读及可写的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:read-only</td><td style="text-align:left">:read-only</td><td style="text-align:left">用于匹配设置 “readonly”（只读） 属性的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:optional</td><td style="text-align:left">:optional</td><td style="text-align:left">用于匹配可选的输入元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:required</td><td style="text-align:left">:required</td><td style="text-align:left">用于匹配设置了 “required” 属性的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:valid</td><td style="text-align:left">:valid</td><td style="text-align:left">用于匹配输入值为合法的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:invalid</td><td style="text-align:left">:invalid</td><td style="text-align:left">用于匹配输入值为非法的元素</td><td style="text-align:left">3</td></tr></tbody></table><h3 id="在页面插入内容"><a href="#在页面插入内容" class="headerlink" title="在页面插入内容"></a>在页面插入内容</h3><p><code>:before</code>或者 <code>:after</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入文字 */</span></span><br><span class="line"><span class="comment">/* 在h2前 */</span></span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">'哈哈哈'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在h2后 */</span></span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">'内容'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 指定个别元素不进行插入 */</span></span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-class">.sample</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入图像 */</span></span><br><span class="line"><span class="comment">/* 在h2前 */</span></span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:bofore</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="built_in">url</span>(mark.png);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在h2后 */</span></span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="built_in">url</span>(mark.png);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将元素属性作为content的值来显示 */</span></span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">context</span>:<span class="built_in">attr</span>(alt);</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">    <span class="attribute">margin-top</span>:<span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>content</code>插入项目编号</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>大标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>实例文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>大标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>实例文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*多个标题加上连续编号*/</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:<span class="built_in">counter</span>(mycounter)</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line"><span class="attribute">counter-increment</span>:mycounter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*追加文字*/</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:<span class="string">'第'</span><span class="built_in">counter</span>(mycounter)<span class="string">'章'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line"><span class="attribute">counter-increment</span>:mycounter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 指定样式 */</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:<span class="string">'第'</span><span class="built_in">counter</span>(mycounter)<span class="string">'章'</span>;</span><br><span class="line"><span class="attribute">color</span>:blue;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">42px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line"><span class="attribute">counter-increment</span>:mycounter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 指定编号种类 list-style-type的值*/</span></span><br><span class="line"><span class="comment">/* content(计数器名，编号种类)*/</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:<span class="string">'第'</span><span class="built_in">counter</span>(mycounter,lower-roman)<span class="string">'章'</span>;</span><br><span class="line"><span class="attribute">color</span>:blue;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">42px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 编号嵌套 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:bofore</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="built_in">counter</span>(mycounter2,lower-roman);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>:mycounter2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>list-style-type 的值</p><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">none</td><td style="text-align:left">无标记。</td></tr><tr><td style="text-align:left">disc</td><td style="text-align:left">默认。标记是实心圆。</td></tr><tr><td style="text-align:left">circle</td><td style="text-align:left">标记是空心圆。</td></tr><tr><td style="text-align:left">square</td><td style="text-align:left">标记是实心方块。</td></tr><tr><td style="text-align:left">decimal</td><td style="text-align:left">标记是数字。</td></tr><tr><td style="text-align:left">decimal-leading-zero</td><td style="text-align:left">0开头的数字标记。(01, 02, 03, 等。)</td></tr><tr><td style="text-align:left">lower-roman</td><td style="text-align:left">小写罗马数字(i, ii, iii, iv, v, 等。)</td></tr><tr><td style="text-align:left">upper-roman</td><td style="text-align:left">大写罗马数字(I, II, III, IV, V, 等。)</td></tr><tr><td style="text-align:left">lower-alpha</td><td style="text-align:left">小写英文字母The marker is lower-alpha (a, b, c, d, e, 等。)</td></tr><tr><td style="text-align:left">upper-alpha</td><td style="text-align:left">大写英文字母The marker is upper-alpha (A, B, C, D, E, 等。)</td></tr><tr><td style="text-align:left">lower-greek</td><td style="text-align:left">小写希腊字母(alpha, beta, gamma, 等。)</td></tr><tr><td style="text-align:left">lower-latin</td><td style="text-align:left">小写拉丁字母(a, b, c, d, e, 等。)</td></tr><tr><td style="text-align:left">upper-latin</td><td style="text-align:left">大写拉丁字母(A, B, C, D, E, 等。)</td></tr><tr><td style="text-align:left">hebrew</td><td style="text-align:left">传统的希伯来编号方式</td></tr><tr><td style="text-align:left">armenian</td><td style="text-align:left">传统的亚美尼亚编号方式</td></tr><tr><td style="text-align:left">georgian</td><td style="text-align:left">传统的乔治亚编号方式(an, ban, gan, 等。)</td></tr><tr><td style="text-align:left">cjk-ideographic</td><td style="text-align:left">简单的表意数字</td></tr><tr><td style="text-align:left">hiragana</td><td style="text-align:left">标记是：a, i, u, e, o, ka, ki, 等。（日文片假名）</td></tr><tr><td style="text-align:left">katakana</td><td style="text-align:left">标记是：A, I, U, E, O, KA, KI, 等。（日文片假名）</td></tr><tr><td style="text-align:left">hiragana-iroha</td><td style="text-align:left">标记是：i, ro, ha, ni, ho, he, to, 等。（日文片假名）</td></tr><tr><td style="text-align:left">katakana-iroha</td><td style="text-align:left">标记是：I, RO, HA, NI, HO, HE, TO, 等。（日文片假名）</td></tr></tbody></table><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.cnblogs.com/ihardcoder/p/5294927.html">CSS3伪类和伪元素的特性和区别</a></li><li><a href="https://read.douban.com/ebook/15160963/">HTML 5与CSS 3权威指南</a></li><li><a href="https://www.w3cschool.cn/html/">W3cScholl</a></li><li><a href="https://www.cnblogs.com/dreamingbaobei/p/5062998.html">CSS3新增的选择器和属性</a></li><li><a href="https://www.cnblogs.com/wangzhenling/p/8824093.html">神奇的css3（1）新增属性、选择器</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS3&quot;&gt;&lt;a href=&quot;#CSS3&quot; class=&quot;headerlink&quot; title=&quot;CSS3&quot;&gt;&lt;/a&gt;CSS3&lt;/h2&gt;&lt;p&gt;发展历史&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="前端面试" scheme="http://laibh.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="HTML5" scheme="http://laibh.top/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>面试官问我HTML5是什么（中）</title>
    <link href="http://laibh.top/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91HTML5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E4%B8%AD%EF%BC%89.html"/>
    <id>http://laibh.top/面试官问我HTML5是什么（中）.html</id>
    <published>2019-05-25T01:30:54.000Z</published>
    <updated>2022-03-04T10:00:38.468Z</updated>
    
    <content type="html"><![CDATA[<p>学习链接：<br><a href="https://read.douban.com/ebook/15160963/">HTML 5与CSS 3权威指南</a></p><p><a href="https://www.w3cschool.cn/html/">W3cScholl</a></p><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><p>HTML5 中的一个新增元素，可以在页面绘制出各种漂亮的图形与图像。</p><h3 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h3><p>canvas 元素就是 HTML5 中新增的一个用来绘制图形。在页面上放置一个 <code>canvas</code>元素，相当于在页面上放置一块画布，可以在其中进行图形绘制。</p><h3 id="在页面中放置-canvas元素"><a href="#在页面中放置-canvas元素" class="headerlink" title="在页面中放置 canvas元素"></a>在页面中放置 canvas元素</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Canvas<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"draw('canvas')"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"300"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"canvas.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--script--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">id</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span></span><br><span class="line"><span class="javascript">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span></span><br><span class="line"><span class="undefined">  context.fillRect(0, 0, 400, 300);</span></span><br><span class="line"><span class="javascript">  context.fillStyle = <span class="string">'red'</span>;</span></span><br><span class="line"><span class="javascript">  context.strokeStyle = <span class="string">'blue'</span>;</span></span><br><span class="line"><span class="undefined">  context.lineWidth = 1;</span></span><br><span class="line"><span class="undefined">  context.fillRect(50,50,100,100);</span></span><br><span class="line"><span class="undefined">  context.strokeRect(50,50,100,100);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先，要指定 ID,width,height 这三个属性。</p><h4 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h4><ol><li>取得 canvas 元素，用 DOM 方法取得要绘制的目标元素</li><li>取得上下文（context）。进行绘制的时候需要用到图形上下文（graphics context），图形上下文是一个封装了很多绘图功能的对象。使用 canvas 对象的 <code>getContext</code>方法来获得图形上下文。</li><li>填充与绘制边框。绘制图形的时候有两种方式：填充（fill）与绘制边框（stroke）。填充是指填充图形内部，绘制边框是指不填充图形内部，值绘制图形的外框。</li><li>设定绘图样式（style）。在进行图形绘制的时候，要设定好绘图的样式，然后调用相关的方法进行图形绘制。相关的属性有 fillStyle(填充图形的样式)，strokeStyle(图形边框的样式)</li><li>指定线宽。使用图形上下文对象的 lineWidth 属性设置图形边框的宽度。</li><li>指定颜色值。颜色名，或者十六进制的颜色值</li><li>分别使用 fillRect 与 strokeRect 方法来填充矩形和绘制矩形边框。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context.fillRect(x,y,width,height);</span><br><span class="line">context.strokeRect(x,y,width,height);</span><br></pre></td></tr></table></figure><p>还有一个 clearRect 方法，擦除指定矩形区域中的图形，使得矩形中的颜色全部变成透明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.clearRect(x,y,width,height);</span><br></pre></td></tr></table></figure><h3 id="使用路径"><a href="#使用路径" class="headerlink" title="使用路径"></a>使用路径</h3><h4 id="绘制圆形"><a href="#绘制圆形" class="headerlink" title="绘制圆形"></a>绘制圆形</h4><p>使用路径绘制图形的过程：</p><ol><li>开始创建路径</li><li>创建图形的路径</li><li>路径创建完成后，关闭路径</li><li>设定绘制样式，调用绘制方法，绘制路径</li></ol><p>大概的意思就是，先用路径勾勒图形轮廓，然后设置颜色，进行绘制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawCircle</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.arc(i * <span class="number">25</span>, i * <span class="number">25</span>, i * <span class="number">10</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">true</span>)</span><br><span class="line">    context.closePath();</span><br><span class="line">    context.fillStyle = <span class="string">'rgba(255,0,0,0.25)'</span>;</span><br><span class="line">    context.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>context.arc(x,y,radius,startAngle,endAngle,anticlockwise)</code></p><p>这个方法使用了六个参数，<code>x</code>为绘制圆形的横坐标，<code>y</code>为纵坐标，<code>radius</code>为圆形半径，<code>startAngle</code>为开始的角度，<code>endAngle</code>为结束角度，<code>anticlockwise</code>为是否按顺时针方向进行绘制。</p><p>关于角度与弧度的计算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> radius = degress * <span class="built_in">Math</span>.PI / <span class="number">180</span>;</span><br></pre></td></tr></table></figure><p><code>arc</code>方法不仅可以用阿里绘制圆形，也可以用来绘制圆弧。因此，使用时必须要指定开始角度与结束角度。因为这两个角度决定了弧度。<code>anticlockwise</code>为一个布尔值的参数，参数为 true 时，按顺时针绘制，参数为 false时，按逆时针绘制。</p><p>绘制完图形后，使用 <code>context.closePath()</code>将路径关闭，接着就可以使用 <code>fill</code>方法（<code>stroke</code>）填充图形与绘制图形边框了。</p><h4 id="不关闭路径"><a href="#不关闭路径" class="headerlink" title="不关闭路径"></a>不关闭路径</h4><p>如果不关闭路径，已经创建的路径会被永远保留，使用 fill 或者 stroke 绘制的时候会重复绘制已存在的路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawCircle</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    context.arc(i * <span class="number">25</span>, i * <span class="number">25</span>, i * <span class="number">10</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">true</span>)</span><br><span class="line">    context.fillStyle = <span class="string">'rgba(255,0,0,0.25)'</span>;</span><br><span class="line">    context.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="绘制线"><a href="#绘制线" class="headerlink" title="绘制线"></a>绘制线</h4><p><strong>moveTo 与 lineTo</strong></p><p>moveTo 方法的作用是将光标移动到指定坐标，绘制直线的时候以这个坐标点为起点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moveTo(x,y)</span><br></pre></td></tr></table></figure><p>lineTo方法，也是用两个参数，x ，y表示直线终点的横纵坐标。使用该方法绘制直线后，光标会自动移动到 lineTo 方法参数所指定的直线终点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawLine</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  <span class="keyword">let</span> dx = <span class="number">150</span>;</span><br><span class="line">  <span class="keyword">let</span> dy = <span class="number">150</span>;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="number">100</span>;</span><br><span class="line">  context.beginPath();</span><br><span class="line">  context.fillStyle = <span class="string">'rgb(100,255,100)'</span>;</span><br><span class="line">  context.strokeStyle = <span class="string">'rgb(0,0,100)'</span>;</span><br><span class="line">  <span class="keyword">let</span> dig = <span class="built_in">Math</span>.PI / <span class="number">15</span> * <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">Math</span>.sin(i * dig);</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">Math</span>.cos(i * dig);</span><br><span class="line">    context.lineTo(dx + x * s, dy + y * s);</span><br><span class="line">  &#125;</span><br><span class="line">  context.closePath()</span><br><span class="line">  context.fill();</span><br><span class="line">  context.stroke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-bezierCurveTo-绘制贝塞尔曲线"><a href="#使用-bezierCurveTo-绘制贝塞尔曲线" class="headerlink" title="使用 bezierCurveTo 绘制贝塞尔曲线"></a>使用 bezierCurveTo 绘制贝塞尔曲线</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.bezierCurveTo(cp1x,cp1y,cp2x,cpy2y,x,y);</span><br></pre></td></tr></table></figure><p>绘制曲线，需要两个控制点以及一点终点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawBezierLine</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  <span class="keyword">let</span> dx = <span class="number">150</span>;</span><br><span class="line">  <span class="keyword">let</span> dy = <span class="number">150</span>;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="number">100</span>;</span><br><span class="line">  context.beginPath();</span><br><span class="line">  context.fillStyle = <span class="string">'rgb(100,255,100)'</span>;</span><br><span class="line">  context.strokeStyle = <span class="string">'rgb(0,0,100)'</span>;</span><br><span class="line">  <span class="keyword">let</span> dig = <span class="built_in">Math</span>.PI / <span class="number">15</span> * <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">Math</span>.sin(i * dig);</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">Math</span>.cos(i * dig);</span><br><span class="line">    context.bezierCurveTo(dx + x * s, dy + y * s - <span class="number">100</span>, dx + x * s + <span class="number">100</span>, dy + y * s, dx + x * s, dy + y * s);</span><br><span class="line">  &#125;</span><br><span class="line">  context.closePath()</span><br><span class="line">  context.fill();</span><br><span class="line">  context.stroke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>quadraticCurveTo</code>方法绘制二次贝塞尔曲线</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.quadraticCurveTo(cpx,cpy,x,y)</span><br></pre></td></tr></table></figure><h3 id="绘制渐变图形"><a href="#绘制渐变图形" class="headerlink" title="绘制渐变图形"></a>绘制渐变图形</h3><h4 id="绘制线性渐变"><a href="#绘制线性渐变" class="headerlink" title="绘制线性渐变"></a>绘制线性渐变</h4><p>绘制线性渐变需要用到 <code>lineargradient</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.createLinearGradient(xStart,yStart,xEnd,yEnd);</span><br></pre></td></tr></table></figure><p>接着使用 addColorStop 方法设定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.addColorStop(offset,color);</span><br></pre></td></tr></table></figure><p>offset 为所设定的颜色离开渐变起始点的偏移量。参数的值是0到1之间的浮点值，渐变起始点的偏移量是0，渐变结束点的偏移量是1.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawLineGradient</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  <span class="keyword">const</span> gl = context.createLinearGradient(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>);</span><br><span class="line">  gl.addColorStop(<span class="number">0</span>, <span class="string">'rgb(255,255,0)'</span>);</span><br><span class="line">  gl.addColorStop(<span class="number">1</span>, <span class="string">'rgb(0,255,255)'</span>);</span><br><span class="line">  context.fillStyle = gl;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  <span class="keyword">const</span> g2 = context.createLinearGradient(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">0</span>);</span><br><span class="line">  g2.addColorStop(<span class="number">0</span>, <span class="string">'rgba(0,0,255,0.5)'</span>);</span><br><span class="line">  g2.addColorStop(<span class="number">0</span>, <span class="string">'rgba(255,0,0,0.5)'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.fillStyle = g2;</span><br><span class="line">    context.arc(i * <span class="number">25</span>, i * <span class="number">25</span>, i * <span class="number">10</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">    context.closePath();</span><br><span class="line">    context.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="绘制径向渐变"><a href="#绘制径向渐变" class="headerlink" title="绘制径向渐变"></a>绘制径向渐变</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.createRadialGradient(xStart,yStart,radiusStart,xEnd,yEnd,radiusEnd);</span><br></pre></td></tr></table></figure><p>分别指定两个圆的大小和位置。从第一个圆的圆心处向外进行扩散渐变，一直扩散到第二个圆的外轮廓处。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawRadialGradient</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  <span class="keyword">const</span> g1 = context.createRadialGradient(<span class="number">400</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">0</span>, <span class="number">400</span>);</span><br><span class="line">  g1.addColorStop(<span class="number">0.1</span>, <span class="string">'rgb(255,255,0)'</span>);</span><br><span class="line">  g1.addColorStop(<span class="number">0.3</span>, <span class="string">'rgb(255,0,255)'</span>);</span><br><span class="line">  g1.addColorStop(<span class="number">1</span>, <span class="string">'rgb(0,255,255)'</span>);</span><br><span class="line">  context.fillStyle = g1;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  <span class="keyword">const</span> g2 = context.createRadialGradient(<span class="number">250</span>, <span class="number">250</span>, <span class="number">0</span>, <span class="number">250</span>, <span class="number">250</span>, <span class="number">300</span>);</span><br><span class="line">  g2.addColorStop(<span class="number">0.1</span>, <span class="string">'rgb(255,0,0,0.5)'</span>);</span><br><span class="line">  g2.addColorStop(<span class="number">0.7</span>, <span class="string">'rgb(255,255,0,0.5)'</span>);</span><br><span class="line">  g2.addColorStop(<span class="number">1</span>, <span class="string">'rgb(0,0,255,0.5)'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.fillStyle = g2;</span><br><span class="line">    context.arc(i * <span class="number">25</span>, i * <span class="number">25</span>, i * <span class="number">10</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">    context.closePath();</span><br><span class="line">    context.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制变形图形"><a href="#绘制变形图形" class="headerlink" title="绘制变形图形"></a>绘制变形图形</h3><h4 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h4><p>主要有三种形式：</p><ul><li>平移，使用图形上下文的 <code>translate</code>方法来移动图形坐标轴原点。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.translate(x,y);</span><br></pre></td></tr></table></figure><ul><li>扩大，使用对象的 <code>scale</code>方法将图形放大</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.scale(x,y)</span><br></pre></td></tr></table></figure><ul><li>旋转，使用 <code>rotate</code>方法将图形进行旋转</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.rotate(angle);</span><br></pre></td></tr></table></figure><p>旋转中西是坐标轴的原点，顺时针方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawDeformationGraphics</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">   <span class="comment">// 改变圆心位置</span></span><br><span class="line">  context.translate(<span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'rgba(255,0,0,0.25)'</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">    context.translate(<span class="number">25</span>, <span class="number">25</span>);</span><br><span class="line">    context.scale(<span class="number">0.95</span>, <span class="number">0.95</span>);</span><br><span class="line">    context.rotate(<span class="built_in">Math</span>.PI / <span class="number">10</span>);</span><br><span class="line">    context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码使用坐标变换的方法。首先绘制了一个长方形，然后在一个循环中反复使用平移坐标轴，图形缩小，图形旋转三种技巧绘制出来变形图形。</p><h4 id="与路径结合使用"><a href="#与路径结合使用" class="headerlink" title="与路径结合使用"></a>与路径结合使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawDeformationGraphicsWithFivePointedStar</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  context.translate(<span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'rgba(255,0,0,0.25)'</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">    context.translate(<span class="number">25</span>, <span class="number">25</span>);</span><br><span class="line">    context.scale(<span class="number">0.95</span>, <span class="number">0.95</span>);</span><br><span class="line">    context.rotate(<span class="built_in">Math</span>.PI / <span class="number">10</span>);</span><br><span class="line">    createFivePointedStar(context);</span><br><span class="line">    context.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFivePointedStar</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context.beginPath();</span><br><span class="line">  context.fillStyle = <span class="string">'rgba(255,0,0,0.5)'</span>;</span><br><span class="line">  <span class="keyword">const</span> dx = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">const</span> dy = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> s = <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">let</span> dig = <span class="built_in">Math</span>.PI / <span class="number">5</span> * <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">Math</span>.sin(i * dig);</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">Math</span>.cos(i * dig);</span><br><span class="line">    context.lineTo(dx + x * s, dy + y * s);</span><br><span class="line">  &#125;</span><br><span class="line">  context.closePath();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h4><p>当图形上下文被创建完毕时，事实上也创建了一个默认的变换矩阵，如果不对这个变换矩阵进行修改，绘制的图形将以画布的最左上角为坐标原点绘制图形，绘制出来的图形也不经过缩放、变形的处理。我们可以对这个变换矩形进行修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.transform(a , b , c , d , e , f )</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><em>a</em></td><td style="text-align:left">水平缩放绘图</td></tr><tr><td style="text-align:left"><em>b</em></td><td style="text-align:left">水平倾斜绘图</td></tr><tr><td style="text-align:left"><em>c</em></td><td style="text-align:left">垂直倾斜绘图</td></tr><tr><td style="text-align:left"><em>d</em></td><td style="text-align:left">垂直缩放绘图</td></tr><tr><td style="text-align:left"><em>e</em></td><td style="text-align:left">水平移动绘图</td></tr><tr><td style="text-align:left"><em>f</em></td><td style="text-align:left">垂直移动绘图</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawTransform</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  <span class="keyword">const</span> colors = [<span class="string">'red'</span>, <span class="string">'orange'</span>, <span class="string">'yellow'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, <span class="string">'navy'</span>, <span class="string">'purple'</span>];</span><br><span class="line">  context.lineWidth = <span class="number">10</span>;</span><br><span class="line">  context.transform(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; colors.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 定义每次向下移动 10个像素的变换矩阵</span></span><br><span class="line">    context.transform(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    context.strokeStyle = colors[i];</span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.arc(<span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI, <span class="literal">true</span>);</span><br><span class="line">    context.stroke();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setTransform 会将变换矩阵重置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTransform(m11,m12,m21,m22,dx,dy)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawSetTransform</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.strokeStyle = <span class="string">'red'</span>;</span><br><span class="line">  context.strokeRect(<span class="number">30</span>, <span class="number">10</span>, <span class="number">60</span>, <span class="number">20</span>);</span><br><span class="line">  <span class="keyword">let</span> rad = <span class="number">45</span> * <span class="built_in">Math</span>.PI / <span class="number">180</span>;</span><br><span class="line"></span><br><span class="line">  context.setTransform(<span class="built_in">Math</span>.cos(rad), <span class="built_in">Math</span>.sin(rad), -<span class="built_in">Math</span>.sin(rad), <span class="built_in">Math</span>.cos(rad), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  context.strokeStyle = <span class="string">'blue'</span>;</span><br><span class="line">  context.strokeRect(<span class="number">30</span>, <span class="number">10</span>, <span class="number">60</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">  context.setTransform(<span class="number">2.5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2.5</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  context.strokeStyle = <span class="string">'green'</span>;</span><br><span class="line">  context.strokeRect(<span class="number">30</span>, <span class="number">10</span>, <span class="number">60</span>, <span class="number">20</span>);</span><br><span class="line">  </span><br><span class="line">  context.setTransform(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">40</span>, <span class="number">80</span>);</span><br><span class="line">  context.strokeStyle = <span class="string">'gray'</span>;</span><br><span class="line">  context.strokeRect(<span class="number">30</span>, <span class="number">10</span>, <span class="number">60</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图形组合"><a href="#图形组合" class="headerlink" title="图形组合"></a>图形组合</h3><p>设定图形上下文对象的 <code>globalCompositeOperation</code>属性能自己决定图形的组合方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.globalCompositeOperation = type</span><br></pre></td></tr></table></figure><p>type 的值必须是下面几种字符串之一：</p><ul><li><p>source-over(默认值)</p><p>表示新图形覆盖杂原有图形上</p></li><li><p>destination-over</p><p>表示在原有图形之下绘制新图形</p></li><li><p>source-in</p><p>新图形与原有图形作 in 运算，只显示新图形中与原有图像相互重叠的部分，新图形与原有图形的其他部分均变成透明</p></li><li><p>destination-in</p><p>原有图形与新图形作 in 运算，只显示原有图形中与新图形相重叠的部分，新图形与原有图形的其他部分均变成透明</p></li><li><p>source-out</p><p>新图形与原有图形 out 运算。只显示新图形中与原有图形不重叠的部分，新图形与原有图形的其他部分变成透明</p></li><li><p>destination-out</p><p>新图形与原有图形 out 运算。只显示原有图形中与新图形不重叠的部分，原有图形与新图形的其他部分变成透明</p></li><li><p>source-atop</p><p>只绘制新图形中与原有图形重叠的部分与未被重叠覆盖的原有图形，新图形的其他部分变成透明</p></li><li><p>destination-atop</p><p>只绘制原有图形中被新图形重叠覆盖的部分与新图形的其他部分，原有图形中的其他部分变成透明，不绘制新图形中与原有图形相重叠的部分</p></li><li><p>lighter</p><p>原有图形与新图形均绘制，重叠部分做加色处理</p></li><li><p>xor</p><p>只绘制新图形中与原有图形不重叠的部分，重叠部分变成透明</p></li><li><p>copy</p><p>只绘制新图形，原有图形中未与新图形重叠的部分变成透明</p></li></ul><h3 id="给图形绘制阴影"><a href="#给图形绘制阴影" class="headerlink" title="给图形绘制阴影"></a>给图形绘制阴影</h3><ul><li>shadowOffsetX——阴影的横线位移量</li><li>shadowOffsetY——阴影的纵向位移量</li><li>shadowColor——阴影的颜色</li><li>shadowBlur——阴影的模糊范围</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawShadowFifthStar</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  context.shadowOffsetX = <span class="number">10</span>;</span><br><span class="line">  context.shadowOffsetY = <span class="number">10</span>;</span><br><span class="line">  context.shadowColor = <span class="string">'rgba(100,100,100,0.5)'</span>;</span><br><span class="line">  context.shadowBlur = <span class="number">7.5</span>;</span><br><span class="line">  context.translate(<span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    context.translate(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    createFivePointedStar(context);</span><br><span class="line">    context.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用图像"><a href="#使用图像" class="headerlink" title="使用图像"></a>使用图像</h3><h4 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宽高 为原图像宽高</span></span><br><span class="line">context.drawImage(image,x,y);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加宽高的自定义</span></span><br><span class="line">context.drawImage(image,x,y,w,h)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将画布中绘制好的图像的全部或者部分复制到画布的另一个位置上</span></span><br><span class="line">context.drawImage(image,sx,sy,sw,sh,dx,dy,dw,dh)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawCanvasImage</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>)</span><br><span class="line">  image = <span class="keyword">new</span> Image();</span><br><span class="line">  image.src = <span class="string">'../Desktop/微信图片_20190311090059.jpg'</span></span><br><span class="line">  image.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    drawBigImage(context, image)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawImage</span>(<span class="params">context, image</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    context.drawImage(image, <span class="number">0</span> + i * <span class="number">50</span>, <span class="number">0</span> + i * <span class="number">25</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawBigImage</span>(<span class="params">context, image</span>) </span>&#123;</span><br><span class="line">  context.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">  context.drawImage(image, <span class="number">23</span>, <span class="number">5</span>, <span class="number">57</span>, <span class="number">80</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图像平铺"><a href="#图像平铺" class="headerlink" title="图像平铺"></a>图像平铺</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawTileImage</span>(<span class="params">canvas, context, image</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(canvas);</span><br><span class="line">  <span class="keyword">const</span> scale = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">let</span> n1 = image.width / scale;</span><br><span class="line">  <span class="keyword">let</span> n2 = image.height / scale;</span><br><span class="line">  <span class="keyword">let</span> n3 = canvas.width / n1;</span><br><span class="line">  <span class="keyword">let</span> n4 = canvas.height / n2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n3; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n4; j++) &#123;</span><br><span class="line">      context.drawImage(image, i * n1, j * n2, n1, n2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面使用变量和循环来实现图像平铺。还可以用更简便的图形上下文的 <code>createPattern</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.createPattern(image,type)</span><br></pre></td></tr></table></figure><p>image 参数为要平铺的图像，type 参数：</p><ul><li>no-repeat：不平铺</li><li>repeat-x：横方向平铺</li><li>repeat-y：纵方向平铺</li><li>repeat：全方向平铺</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawCanvasImage</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>)</span><br><span class="line">  image = <span class="keyword">new</span> Image();</span><br><span class="line">  image.src = <span class="string">'../Desktop/微信图片_20190311090059.jpg'</span>;</span><br><span class="line">  image.width = <span class="number">10</span>;</span><br><span class="line">  image.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> canvasTemp = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">    <span class="keyword">const</span> contextTemp = canvasTemp.getContext(<span class="string">'2d'</span>);</span><br><span class="line">    canvasTemp.width = <span class="number">100</span>;</span><br><span class="line">    canvasTemp.height = <span class="number">100</span>;</span><br><span class="line">    contextTemp.drawImage(<span class="keyword">this</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">let</span> ptrn = context.createPattern(canvasTemp,<span class="string">'repeat'</span>);</span><br><span class="line">    <span class="comment">// context.drawImage(image, 23, 5, 57, 80);</span></span><br><span class="line">    context.fillStyle = ptrn;</span><br><span class="line">    context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当图像太大的时候，可以通过把图像绘制在一个临时的 canvas 里面，然后再用主canvas 重复这个临时 canvas </p><h4 id="图像裁剪"><a href="#图像裁剪" class="headerlink" title="图像裁剪"></a>图像裁剪</h4><p>使用 clip 方法设置裁剪区域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cutImage</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  <span class="keyword">const</span> gr = context.createLinearGradient(<span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>, <span class="number">0</span>);</span><br><span class="line">  gr.addColorStop(<span class="number">0</span>, <span class="string">'rgb(255,255,0)'</span>);</span><br><span class="line">  gr.addColorStop(<span class="number">1</span>, <span class="string">'rgb(0,255,255)'</span>);</span><br><span class="line">  context.fillStyle = gr;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  image = <span class="keyword">new</span> Image();</span><br><span class="line">  image.src = <span class="string">'../Desktop/微信图片_20190311090059.jpg'</span>;</span><br><span class="line">  image.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    createFivePointedStar(context);</span><br><span class="line">    context.drawImage(image, <span class="number">-50</span>, <span class="number">-150</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFivePointedStar</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context.beginPath();</span><br><span class="line">  context.translate(<span class="number">100</span>,<span class="number">150</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'rgba(255,0,0,0.5)'</span>;  </span><br><span class="line">  <span class="keyword">const</span> dx = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">const</span> dy = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> s = <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">let</span> dig = <span class="built_in">Math</span>.PI / <span class="number">5</span> * <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">Math</span>.sin(i * dig);</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">Math</span>.cos(i * dig);</span><br><span class="line">    context.lineTo(dx + x * s, dy + y * s);</span><br><span class="line">  &#125;</span><br><span class="line">  context.closePath();</span><br><span class="line">  context.clip();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="像素处理"><a href="#像素处理" class="headerlink" title="像素处理"></a>像素处理</h4><p>使用 getImageData 方法可以获取图像中的像素,获得像素组依次 rgba 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageData = context.getImageData(x,y,width,height);</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><em>x</em></td><td style="text-align:left">开始复制的左上角位置的 x 坐标。</td></tr><tr><td style="text-align:left"><em>y</em></td><td style="text-align:left">开始复制的左上角位置的 y 坐标。</td></tr><tr><td style="text-align:left"><em>width</em></td><td style="text-align:left">将要复制的矩形区域的宽度。</td></tr><tr><td style="text-align:left"><em>height</em></td><td style="text-align:left">将要复制的矩形区域的高度。</td></tr></tbody></table><p>对于 ImageData 对象中的每个像素，都存在着四方面的信息，即 RGBA 值：</p><ul><li>R - 红色 (0-255)</li><li>G - 绿色 (0-255)</li><li>B - 蓝色 (0-255)</li><li>A - alpha 通道 (0-255; 0 是透明的，255 是完全可见的)</li></ul><p>利用 putImageData 将图像数据放回画布,期间做一些颜色处理，可以模拟滤镜。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">image.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// createFivePointedStar(context);</span></span><br><span class="line">  context.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  <span class="keyword">let</span> imagedata = context.getImageData(<span class="number">0</span>, <span class="number">0</span>, image.width, image.height)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = imagedata.data.length; i &lt; n; i += <span class="number">4</span>) &#123;</span><br><span class="line">    imagedata.data[i + <span class="number">0</span>] = <span class="number">255</span> - imagedata.data[i + <span class="number">0</span>];</span><br><span class="line">    imagedata.data[i + <span class="number">1</span>] = <span class="number">255</span> - imagedata.data[i + <span class="number">2</span>];</span><br><span class="line">    imagedata.data[i + <span class="number">2</span>] = <span class="number">255</span> - imagedata.data[i + <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  context.putImageData(imagedata, <span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.putImageData(imgData,x,y,dirtyX,dirtyY,dirtyWidth,dirtyHeight);</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><em>imgData</em></td><td style="text-align:left">规定要放回画布的 ImageData 对象。</td></tr><tr><td style="text-align:left"><em>x</em></td><td style="text-align:left">ImageData 对象左上角的 x 坐标，以像素计。</td></tr><tr><td style="text-align:left"><em>y</em></td><td style="text-align:left">ImageData 对象左上角的 y 坐标，以像素计。</td></tr><tr><td style="text-align:left"><em>dirtyX</em></td><td style="text-align:left">可选。水平值（x），以像素计，在画布上放置图像的位置。</td></tr><tr><td style="text-align:left"><em>dirtyY</em></td><td style="text-align:left">可选。水平值（y），以像素计，在画布上放置图像的位置。</td></tr><tr><td style="text-align:left"><em>dirtyWidth</em></td><td style="text-align:left">可选。在画布上绘制图像所使用的宽度。</td></tr><tr><td style="text-align:left"><em>dirtyHeight</em></td><td style="text-align:left">可选。在画布上绘制图像所使用的高度。</td></tr></tbody></table><h3 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h3><p>fillText 填充方式绘制字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.fillText(text,x,y,maxWidth);</span><br></pre></td></tr></table></figure><p>maxWidth，允许最大的宽度，像素单位</p><p>strokeText 用轮廓方式绘制字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.strokeText(text,x,y,maxWidth);</span><br></pre></td></tr></table></figure><p>一些关于文字绘制的属性：</p><ul><li>font：字体</li><li>textAlign：水平对齐方式，start(默认)、end、left、right、center</li><li>textBaseline：垂直对齐方式，top、hanging、middle、alphabetic(默认)、ideographic、bottom</li></ul><p>获得文字的宽度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.measureText(text)</span><br></pre></td></tr></table></figure><p>接受一个参数 text，该参数为需要绘制的文字，返回一个 TextMetrics 对象，TextMetrics对象的 width 属性表示使用当前指定的文字后  text 参数中指定的文字的总文字宽度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawText</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.font = <span class="string">'italic 20px sans-serif'</span>;</span><br><span class="line">  <span class="keyword">let</span> txt = <span class="string">'字符串的宽度为：'</span>;</span><br><span class="line">  <span class="keyword">let</span> tml = context.measureText(txt);</span><br><span class="line">  context.fillText(txt, <span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">  context.fillText(tml.width, tml.width + <span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">  context.font = <span class="string">'bold 30px sans-serif'</span>;</span><br><span class="line">  <span class="keyword">let</span> tm2 = context.measureText(txt);</span><br><span class="line">  context.fillText(txt, <span class="number">10</span>, <span class="number">70</span>);</span><br><span class="line">  context.fillText(tm2.width, tm2.width + <span class="number">10</span>, <span class="number">70</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="保存与恢复状态"><a href="#保存与恢复状态" class="headerlink" title="保存与恢复状态"></a>保存与恢复状态</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将当前状态保存到 栈中</span></span><br><span class="line">context.save();</span><br><span class="line"><span class="comment">// 从栈中取出之前保存的图形上下文的状态进行恢复 </span></span><br><span class="line">context.restore();</span><br></pre></td></tr></table></figure><p>绘画状态包括坐标的原点、变形时的变换矩阵，图形上下文对象的当前属性值。</p><p>可以应用在下面但不仅仅下面的场景：</p><ul><li>图像或图形变形</li><li>图像裁剪</li><li>改变图形上下文的以下属性的时候：fillStyle、font、globalAlpha、globalComposite、Operation、lineCap、lineJoin、lineWidth、miterLimit、shadowBlur、shadowColor、shadowOffsetX、shadowOffsetY、strokeStyle、textAlign、textBaseline</li></ul><h4 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h4><p> 原理实际上是把当前的绘画状态输出到一个 data URL 地址所指向的数据中的过程。data URL指的是目前大部分浏览器能够识别的一种 base64编码的 URL，主要用于小型的、可以在网页中直接嵌入的，而不需要从外部文件嵌入的数据，例如 img 元素中的图像文件等。</p><p>toDataURL 方法把绘画状态输出到一个 data URL中，然后重新装载，客户可以直接把装载后的文件进行保存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">canvas.toDataURL(type);</span><br><span class="line"><span class="comment">// type 表示输出输出类型的 MIME 类型</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawDataURL</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'rgb(0,0,255)'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">  context.fillStyle = <span class="string">'rgb(255,255,0)'</span>;</span><br><span class="line">  context.fillRect(<span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(canvas.toDataURL(<span class="string">"image/jepg"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单动画的制作"><a href="#简单动画的制作" class="headerlink" title="简单动画的制作"></a>简单动画的制作</h4><p>canvas 画布中制作的动画实际上就是一个不断擦除（clearRect）、重绘的过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animationOnCanvas</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  width = canvas.width;</span><br><span class="line">  height = canvas.height;</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  setInterval(rotate, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rotate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  context.clearRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">  context.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">  context.fillRect(i, <span class="number">0</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">  i += <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多媒体播放"><a href="#多媒体播放" class="headerlink" title="多媒体播放"></a>多媒体播放</h2><h3 id="关于-video-与-audio元素"><a href="#关于-video-与-audio元素" class="headerlink" title="关于 video 与 audio元素"></a>关于 video 与 audio元素</h3><p>HTML4页面中播放视频或者音频数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">classid</span>=<span class="string">"clsid:F08DF954-8592-11D1-B16A-00C0F0283628"</span> <span class="attr">id</span>=<span class="string">"Slider1"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"50"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"BorderStyle"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"MousePointer"</span> <span class="attr">value</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Enabled"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Min"</span> <span class="attr">value</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Max"</span> <span class="attr">value</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"allowFullScreen"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"allowscriptaccess"</span> <span class="attr">value</span>=<span class="string">"always"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">embed</span> <span class="attr">type</span>=<span class="string">"application/x-shockwave-flash"</span> <span class="attr">width</span>=<span class="string">"425"</span> <span class="attr">height</span>=<span class="string">"344"</span> <span class="attr">src</span>=<span class="string">"p.swf"</span> <span class="attr">allowscriptaccess</span>=<span class="string">"always"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">allowfullscreen</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">embed</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出上面代码的一些缺点：冗长，需要使用 Flash 插件，用户没有安装的话，则视频看不了。需要结合多个元素，并且需要添加很多属性。</p><p>HTML5 中的则是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">'xxx.mp3'</span>&gt;</span></span><br><span class="line">    您的浏览器器不支持 audio 元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">"640"</span> <span class="attr">height</span>=<span class="string">"360"</span> <span class="attr">src</span>=<span class="string">'xxx.mp4'</span>&gt;</span></span><br><span class="line">    您的浏览器器不支持 video 元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--结合 source元素为同一个媒体数据指定多个播放格式与编码方式，浏览器会从中找到一种自己支持的播放格式来播放 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"sample.ogv"</span> <span class="attr">type</span>=<span class="string">"video/ogg"</span>;<span class="attr">codecs</span>=<span class="string">"theora,vorbis"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"sample.mov"</span> <span class="attr">type</span>=<span class="string">"video/quicktime"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--type指播放媒体的MIME类型，codes表示媒体的编码格式--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p>src</p><p>指定媒体数据的 URL 地址</p></li><li><p>autoplay</p><p>指定媒体是否在页面加载后自动播放</p></li><li><p>preload</p><p>指定数据是否预加载。预加载浏览器会预先将视频或者音频数据缓冲，加快播放速度，因为播放时数据已经缓冲完毕。该属性有 none（不进行预加载）、metadata（只预加载媒体的元数据：媒体字节数、第一帧、播放列表、持续时间等）、auto(默认，表示预加载全部视频或者音频)。</p></li><li><p>poster(video独有)</p><p>当视频不可用的时候，可以使用该元素向用户展示一副替代用的图片。用户体验良好</p></li><li><p>loop</p><p>循环播放</p></li><li><p>controls</p><p>添加浏览器自带的播放用的控制条，具有播放、暂停等按钮。</p></li><li><p>width 与 height（video独有）</p><p>该属性中指定视频的宽度和高度（像素）</p></li><li><p>error</p><p>读取使用媒体数据的过程中出错的话，返回一个 MediaError对象，该对象的code返回对应的错误状态，有4个值</p><p>MEDIA_ERR_ABORTED(数字值为1)：媒体数据的下载过程由于用户操作的原因而被中止</p><p>MEDIA_ERR_NETWORK(数字值为2)：确认媒体资源可用，但是在下载时出现网络错误，媒体数据的下载过程被中止</p><p>MEDIA_ERR_DECODE(数字值为3)：确认媒体资源可用，但是解码时发生错误。</p><p>MEDIA_ERR_SRC_NOT_SUPPORTED(数字值为4)：媒体资源不可用媒体格式不被支持，error属性为只读属性</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> video = <span class="built_in">document</span>.getElementById(<span class="string">'video element'</span>);</span><br><span class="line">video.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; error &#125; = video;</span><br><span class="line">  <span class="keyword">switch</span> (error.code) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'视频的下载过程被中止'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'网络发生故障，视频的下载过程被中止'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'解码失败'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'不支持的播放格式'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'无'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><ul><li>networkState,4个可能值<ul><li>NETWORK_EMPTY(数字值为0)：音频/视频尚未初始化</li><li>NETWORK_IDLE(1)：音频/视频是活动的且已选取资源，但并未使用网络</li><li>NETWORK_LOADING(2)：浏览器正在下载数据</li><li>NETWORK_NO_SOURCE(3)：未找到音频/视频来源</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">video.addEventListener(<span class="string">'progress'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; networkState &#125; = video;</span><br><span class="line">  <span class="keyword">if</span> (networkState === <span class="number">2</span>) &#123;</span><br><span class="line">    x.innerHTML = <span class="string">`加载中...[<span class="subst">$&#123;e.loaded&#125;</span>/<span class="subst">$&#123;e.total&#125;</span> byte]`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (networkState === <span class="number">3</span>) &#123;</span><br><span class="line">    x.innerHTML = <span class="string">'记载失败'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><ul><li><p>currentSrc</p><p>读取播放中的媒体数据的 URL地址，为只读属性</p></li><li><p>buffered（只读）</p><p>buffered 属性返回 TimeRanges 对象。该对象表示用户的音视频缓冲范围，缓冲范围指的是已缓冲音视频的时间范围。如果用户在音频中跳跃播放，会得到多个缓冲范围。</p></li></ul><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">audio|video.buffered</span><br></pre></td></tr></table></figure><p>返回值</p><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">TimeRanges 对象</td><td style="text-align:left">表示音视频的已缓冲部分。TimeRanges 对象属性：length - 获得音视频中已缓冲范围的数量<br>start(index) - 获得某个已缓冲范围的开始位置<br/>end(index) - 获得某个已缓冲范围的结束位置<br/><strong>注释：</strong>首个缓冲范围的下表是 0。</td></tr></tbody></table><ul><li><p>readyState（只读）</p><p>返回媒体当前的播放位置的就绪状态值：</p><p>HAVE_NOTHING(0)：没有获取到媒体的任何信息，当前的播放位置没有可播放数据</p><p>HAVE_METADATA(1)：已经获取到足够的媒体数据，但是当前播放位置没有有效的媒体数据（获取到的媒体数据无效）</p><p>HAVE_CURRENT_DATA(2)：当前播放位置已经有数据可以播放，但没有获取到可以让播放器前进的数据。当媒体为视频，即当前帧的数据已经获得，也获得了下一帧大数据，或者当前帧已经是最后一帧</p><p>HAVE_FUTURE_DATA(3)：当前播放位置已经有数据可以播放，而且也获得到了可以让播放器前进的数据。当媒体为视频时，即当前帧的数据已经获得，而且也获得了下一帧的数据，当前帧是播放的最后一帧时，readyState 属性不可能为 HAVE_FUTURE_DATA</p><p>HAVE_ENOUGH_DATA(4)：当前播放位置已经有数据可以播放，同时也获得了可以让播放器前进的数据，而且浏览器确认媒体数据以某一种速度可以加载，可以保证有足够的后续数据进行播放。</p></li><li><p>seeking属性与seekable（只读）</p><p>seeking属性返回一个布尔值，表示浏览器是否正在请求某一特定播放为孩子的数据，true表示浏览器正在请求数据，false表示浏览器正在停止请求。</p><p>seekable返回一个 TimeRanges对象，该对象表示请求到的数据的时间范围。当媒体为视频时，开始时间为请求到视频数据第一帧的时间结束为请求到视频数据最后一帧的时间。</p></li><li><p>currentTime（可读写）/startTime（只读）/duration（只读）</p><p>currentTime获取当前播放位置，也可以通过修改currentTime来修改当前播放位置。如果修改的位置上没有可用的媒体数据时，将抛出 INVALID_STATE_ERR 异常。如果修改的位置超出了浏览器在一次请求中可以请求的数据范围，将抛出 INDEX_SIZE_ERR  异常。</p><p>startTime 来读取媒体播放的开始时间，通常为0</p><p>duration 读取媒体文件总的播放时间</p><p>三者单位均为秒</p></li><li><p>played/paused/ended（均为只读）</p><p>played 返回一个 TimeRanges 对象，从该对象中可以去读媒体文件的以播放部分的时间段。开始时间为已播放部分的开始时间，结束时间为已播放部分的结束时间。</p><p>paused 返回一个布尔值，表示是否处于暂停播放中，true 表示媒体暂停播放，false 表示媒体正在播放</p><p>end 返回一个布尔值，表示是否播放完毕，true表示播放完毕，false表示还没有播放完毕</p></li><li><p>defaultPlaybackRate/playbackRate</p><p>前者读取或者修改默认的播放速率，后者可以读取修改当前的播放速率</p></li><li><p>volume与 muted</p><p>Volume 读取或者修改媒体的播放音量，范围为0到1。0为静音，1为最大音量</p><p>muted读取或者修改媒体的静音状态，布尔值。true表示静音状态，false表示非静音状态</p></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>video与 audio都有以下四种方法：</p><ul><li>play。播放媒体，将 paused变为 false</li><li>pause。暂停媒体，将 paused 变为 true</li><li>load。重新载入媒体进行播放，将 playbackRate变为 defaultPlaybackRate，error变为 null</li><li>canPlayType。来测试浏览器是否支持指定的媒体类型。<code>support = videoElement.canPlayType(type)</code>。该方法使用一个参数type，该参数的指定方法与 source元素的type参数的指定方法相同，都用播放文件的 MIME 类型来指定，可以在指定的字符串中加上表示媒体编码格式的 codes参数。该方法返回3个可能值：<ul><li>空字符串：表示浏览器不支持此种媒体类型</li><li>maybe：表示浏览器可能支持此种媒体类型</li><li>probably：表示浏览器确定支持此种媒体类型</li></ul></li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件处理方式分为两种：</p><ul><li>addEventListener</li><li>获取事件句柄的方式</li></ul><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>loadstart</td><td>浏览器开始在网上寻找媒体数据</td></tr><tr><td>progress</td><td>浏览器正在获取媒体数据</td></tr><tr><td>suspend</td><td>浏览器暂停获取媒体数据，但是下载过程并没有正常结束</td></tr><tr><td>abort</td><td>浏览器在下载完全部媒体数据之前中止获取媒体数据，但是并不是由错误引起的</td></tr><tr><td>error</td><td>获取媒体数据过程中出错</td></tr><tr><td>emptied</td><td>video元素或者 audio元素所在网络突然变为未初始状态。可能引起的原因有两个：载入媒体过程中突然发生一个致命错误和在浏览器正在选择支持的播放格式时，又调用了 load 方法重新载入媒体</td></tr><tr><td>stalled</td><td>浏览器尝试获取媒体数据失败</td></tr><tr><td>play</td><td>即使开始播放，当执行了 play 方法时触发，或者数据下载完之后元素被谁 autoplay</td></tr><tr><td>pause</td><td>播放暂停，当执行了 pause 方法时触发</td></tr><tr><td>loadedmetadata</td><td>浏览器获取完毕媒体的时长好字节数</td></tr><tr><td>loadeddata</td><td>浏览器已经加载完毕当前播放位置的媒体数据，准备播放</td></tr><tr><td>waiting</td><td>播放过程由于得不到下一帧而暂停播放（例如下一帧尚未加载完毕），但很快就能够播放下一帧</td></tr><tr><td>playing</td><td>正在播放</td></tr><tr><td>canplay</td><td>浏览器能够播放媒体，但估计以前播放速率不能直接将媒体播放完毕，播放需要缓冲</td></tr><tr><td>canplaythrough</td><td>浏览器能够播放媒体，而且以当前播放速率能够将媒体播放完毕，不再需要进行缓冲</td></tr><tr><td>seeking</td><td>seeking属性变为 true，浏览器正在请求数据</td></tr><tr><td>seeked</td><td>seeking属性变成false，浏览器停止请求数据</td></tr><tr><td>timeupdate</td><td>当前播放位置被改变，可能是播放过程中的自然改变，也可能是人为地改变，或由于播放不能连续而发生的跳变</td></tr><tr><td>ended</td><td>播放结束后停止播放</td></tr><tr><td>ratechange</td><td>defaultplaybackRate属性（默认播放速率）或 playbackRate属性（当前播放速率）被改变</td></tr><tr><td>durationchange</td><td>播放时长被改变</td></tr><tr><td>volumechange</td><td>volume（音量）被改变或者 muted（静音状态） 被改变</td></tr></tbody></table><h3 id="事件捕捉示例"><a href="#事件捕捉示例" class="headerlink" title="事件捕捉示例"></a>事件捕捉示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">video.addEventListener(<span class="string">'timeupdate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> timer = <span class="built_in">document</span>.getElementById(<span class="string">'time'</span>);</span><br><span class="line">  timer.innerHTML = <span class="built_in">Math</span>.floor(video.currentTime) + <span class="string">'/'</span> + <span class="built_in">Math</span>.floor(video.duration) + <span class="string">'(秒)'</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><h3 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h3><p>我们可以使用 cookies 在客户端保存注入用户等简单的用户信息，但它有一些限制：</p><ul><li>大小：cookies大小被限制在 4KB</li><li>带宽：cookies 随 HTTP 事务一起被发送，会浪费一部分发送 cookies使用的带宽</li><li>复杂度</li></ul><p>在 HTML5中重新提供了一种在客户端本地保存数据的功能，就是 Web Storage 功能。它分为两种</p><ul><li><p>sessionStorage</p><p>将数据保存在 seesion对象中。所谓的 session，是指用户在浏览某个网站的时候，从进入网站到浏览器关闭所经过这段时间，也就是用户浏览器这个网站所花费的时间，session 对象可以用来保存这时间所要求保存的任何数据、</p></li><li><p>localStorage</p><p>将数据保存在客户端本地的硬件设备（通常值硬盘，但也可以是其他硬件设备）中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站仍然可以使用。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sessionStorage</span></span><br><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">sessionStorage.setItem(key,value);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line">变量 = seesionStorage.getItem(key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// localStorage</span></span><br><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">localStorage.setItem(key,value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">变量 = localStorage.getItem(key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存时不允许重复键名。保存后可以修改键值，但是不允许修改键名（只能重新取键名，然后保存键值）</span></span><br></pre></td></tr></table></figure><h3 id="示例：简单-web-留言本"><a href="#示例：简单-web-留言本" class="headerlink" title="示例：简单 web 留言本"></a>示例：简单 web 留言本</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>简单 Web 留言本<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"memo"</span> <span class="attr">id</span>=<span class="string">"memo"</span> <span class="attr">cols</span>=<span class="string">"60"</span> <span class="attr">rows</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"追加"</span> <span class="attr">onclick</span>=<span class="string">"saveStorage('memo')"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"初始化"</span> <span class="attr">onclick</span>=<span class="string">"clearStorage('msg')"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">saveStorage</span>(<span class="params">id</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> data = <span class="built_in">document</span>.getElementById(id).value;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span></span><br><span class="line"><span class="undefined">    localStorage.setItem(time, data);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'数据已经保存了'</span>);</span></span><br><span class="line"><span class="javascript">    loadStorage(<span class="string">'msg'</span>);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">loadStorage</span>(<span class="params">id</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> result = <span class="string">`&lt;table border="1"&gt;`</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; localStorage.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> key = localStorage.key(i);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> value = localStorage.getItem(key);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="undefined">      date.setTime(key);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> datestr = date.toGMTString();</span></span><br><span class="line"><span class="xml">      result += `<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;value&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;datestr&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span>`</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    result += <span class="string">`&lt;/table&gt;`</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> target = <span class="built_in">document</span>.getElementById(id);</span></span><br><span class="line"><span class="undefined">    target.innerHTML = result;</span></span><br><span class="line"><span class="undefined">  &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">clearStorage</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    localStorage.clear();</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'全部数据被清除'</span>);</span></span><br><span class="line"><span class="javascript">    loadStorage(<span class="string">'msg'</span>);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="示例：简易数据库"><a href="#示例：简易数据库" class="headerlink" title="示例：简易数据库"></a>示例：简易数据库</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>简易数据库<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>EMAIL:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"email"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>电话号码:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"tel"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>备注:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"memo"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"saveStorage()"</span> <span class="attr">value</span>=<span class="string">"保存"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>检索：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"find"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"检索"</span> <span class="attr">onclick</span>=<span class="string">"findStorage('msg')"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">saveStorage</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Object</span>;</span></span><br><span class="line"><span class="javascript">    data.name = <span class="built_in">document</span>.getElementById(<span class="string">'name'</span>).value;</span></span><br><span class="line"><span class="javascript">    data.email = <span class="built_in">document</span>.getElementById(<span class="string">'email'</span>).value;</span></span><br><span class="line"><span class="javascript">    data.tel = <span class="built_in">document</span>.getElementById(<span class="string">'name'</span>).value;</span></span><br><span class="line"><span class="javascript">    data.memo = <span class="built_in">document</span>.getElementById(<span class="string">'memo'</span>).value;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(data);</span></span><br><span class="line"><span class="undefined">    localStorage.setItem(data.name, str);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'数据已经保存了'</span>);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">findStorage</span>(<span class="params">id</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> find = <span class="built_in">document</span>.getElementById(<span class="string">'find'</span>).value;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> str = localStorage.getItem(find);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(str);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> result = <span class="string">`姓名： <span class="subst">$&#123;data.name&#125;</span>&lt;br&gt;`</span>;</span></span><br><span class="line"><span class="javascript">    result += <span class="string">`EMAIL： <span class="subst">$&#123;data.email&#125;</span>&lt;br&gt;`</span>;</span></span><br><span class="line"><span class="javascript">    result += <span class="string">`电话号码： <span class="subst">$&#123;data.tel&#125;</span>&lt;br&gt;`</span>;</span></span><br><span class="line"><span class="javascript">    result += <span class="string">`备注： <span class="subst">$&#123;data.memo&#125;</span>&lt;br&gt;`</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> target = <span class="built_in">document</span>.getElementById(id);</span></span><br><span class="line"><span class="undefined">    target.innerHTML = result;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="本地数据库-新的推荐IndexedDB实现"><a href="#本地数据库-新的推荐IndexedDB实现" class="headerlink" title="本地数据库(新的推荐IndexedDB实现)"></a>本地数据库(新的推荐IndexedDB实现)</h2><p>HTML5中内置了一个可以通过 SQL 语言来访问的数据库</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> db = openDatabase(<span class="string">'mydb'</span>,<span class="string">'1.0'</span>,<span class="string">'Test DB'</span>,<span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br></pre></td></tr></table></figure><p>openDatabase接收五个参数：</p><ol><li>数据库名字</li><li>数据库版本号</li><li>显示名字</li><li>数据库保存数据的大小（以字节为单位 )</li><li>回调函数（非必须)</li></ol><p>transaction 方法来执行事务处理，防止在对数据库进行访问以及有关操作的时候收到外界的干扰。当一条语法执行失败的时候，整个事务会回滚</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.transaction(<span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    context.executeSql(<span class="string">'CREATE TABLE IF NOT EXISTS tesTable (id unique,name)'</span>);</span><br><span class="line">    context.executeSql(<span class="string">'INSERT INTO testTable(id,name) VALUES (0,"haha")'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>executeSql 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transaction.executeSql(sqlquery,[],dataHandler,errorHandler);</span><br></pre></td></tr></table></figure><p>executeSql 接收四个参数：</p><ol><li>查询字符串</li><li>用以替换查询字符串中问号的参数</li><li>执行成功回调函数（可选）</li><li>执行失败回调函数（可选）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transaction.executeSql(<span class="string">"UPDATE people set age=?where name=?;"</span>,[age,name],(transaction,result)=&gt;&#123;&#125;,(transaction,errmsg)=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure><h3 id="实例：留言本"><a href="#实例：留言本" class="headerlink" title="实例：留言本"></a>实例：留言本</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"init()"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>使用数据库实现的 Web 留言本<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>留言：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"memo"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"保存"</span> <span class="attr">onclick</span>=<span class="string">"saveData()"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">"datatable"</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> datatable = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> db = openDatabase(<span class="string">'MyData'</span>, <span class="string">''</span>, <span class="string">'My Database'</span>, <span class="number">102400</span>);</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(datatable.childNodes);</span></span><br><span class="line"><span class="javascript">    datatable = <span class="built_in">document</span>.getElementById(<span class="string">'datatable'</span>);</span></span><br><span class="line"><span class="undefined">    showAllData();</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">removeAllData</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = datatable.childNodes.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span></span><br><span class="line"><span class="undefined">      datatable.removeChild(datatable.childNodes[i]);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> tr = <span class="built_in">document</span>.createElement(<span class="string">'tr'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> th1 = <span class="built_in">document</span>.createElement(<span class="string">'th'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> th2 = <span class="built_in">document</span>.createElement(<span class="string">'th'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> th3 = <span class="built_in">document</span>.createElement(<span class="string">'th'</span>);</span></span><br><span class="line"><span class="javascript">    th1.innerHTML = <span class="string">'姓名'</span>;</span></span><br><span class="line"><span class="javascript">    th2.innerHTML = <span class="string">'留言'</span>;</span></span><br><span class="line"><span class="javascript">    th3.innerHTML = <span class="string">'时间'</span>;</span></span><br><span class="line"><span class="undefined">    tr.appendChild(th1);</span></span><br><span class="line"><span class="undefined">    tr.appendChild(th2);</span></span><br><span class="line"><span class="undefined">    tr.appendChild(th3);</span></span><br><span class="line"><span class="undefined">    datatable.appendChild(tr);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">showData</span>(<span class="params">row</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> tr = <span class="built_in">document</span>.createElement(<span class="string">'tr'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> td1 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</span></span><br><span class="line"><span class="undefined">    td1.innerHTML = row.name;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> td2 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</span></span><br><span class="line"><span class="undefined">    td2.innerHTML = row.message;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> td3 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> t = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="undefined">    t.setTime(row.time);</span></span><br><span class="line"><span class="javascript">    td3.innerHTML = t.toLocaleDateString() + <span class="string">" "</span> + t.toLocaleTimeString();</span></span><br><span class="line"><span class="undefined">    tr.appendChild(td1);</span></span><br><span class="line"><span class="undefined">    tr.appendChild(td2);</span></span><br><span class="line"><span class="undefined">    tr.appendChild(td3);</span></span><br><span class="line"><span class="undefined">    datatable.appendChild(tr);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">showAllData</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    db.transaction(<span class="function"><span class="keyword">function</span> (<span class="params">tx</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      tx.executeSql(<span class="string">'CREATE TABLE IF NOT EXISTS MsgData(name TEXT,message TEXT,time INTEGER)'</span>, []);</span></span><br><span class="line"><span class="javascript">      tx.executeSql(<span class="string">'SELECT * FROM MsgData'</span>, [], <span class="function"><span class="keyword">function</span> (<span class="params">tx, rs</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">        removeAllData();</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rs.rows.length; i++) &#123;</span></span><br><span class="line"><span class="undefined">          showData(rs.rows.item(i));</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">addData</span>(<span class="params">name, message, time</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    db.transaction(<span class="function"><span class="keyword">function</span> (<span class="params">tx</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      tx.executeSql(<span class="string">'INSERT INTO MsgData VALUES(?,?,?)'</span>, [name, message, time], <span class="function"><span class="keyword">function</span> (<span class="params">tx, rs</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'成功保存数据'</span>);</span></span><br><span class="line"><span class="javascript">      &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">tx, error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;error.source&#125;</span>:<span class="subst">$&#123;error.message&#125;</span>`</span>);</span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">saveData</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> name = <span class="built_in">document</span>.getElementById(<span class="string">'name'</span>).value;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> memo = <span class="built_in">document</span>.getElementById(<span class="string">'memo'</span>).value;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span></span><br><span class="line"><span class="undefined">    addData(name, memo, time);</span></span><br><span class="line"><span class="undefined">    showAllData();</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不过，Web SQL Database规范已经被废弃。因为每个浏览器都有自己的实现，浏览器的兼容性就不重要了。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API">关于 IndexedDB</a></p><h2 id="离线应用程序（已废弃）"><a href="#离线应用程序（已废弃）" class="headerlink" title="离线应用程序（已废弃）"></a>离线应用程序（<strong>已废弃</strong>）</h2><p>HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。</p><p>应用程序缓存为应用带来三个优势：</p><ul><li>离线浏览 - 用户可在应用离线时使用它们</li><li>速度 - 已缓存资源加载得更快</li><li>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</li></ul><p><strong>本地缓存与浏览器网页缓存的区别</strong></p><p>本地缓存为整个 Web 程序服务的，浏览器的网页缓存只服务于单个网页。任何网页都有网页缓存，而本地缓存值缓存指定的网页。本地缓存可以控制缓存更新，利用缓存对象的各种属性、状态和事件来开发出离线应用程序</p><h3 id="manifest文件"><a href="#manifest文件" class="headerlink" title="manifest文件"></a>manifest文件</h3><p>首先在 index.html 中引入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">！DOCTYPE</span> <span class="attr">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">mainfest</span> =<span class="string">'index.appcache'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每个指定了 manifest 的页面在用户对其访问时都会被缓存。如果未指定 manifest 属性，则页面不会被缓存（除非在 manifest 文件中直接指定了该页面）。</p><p>manifest 文件的建议的文件扩展名是：”.appcache”。</p><p>请注意，manifest 文件需要配置<em>正确的 MIME-type</em>，即 “text/cache-manifest”。必须在 web 服务器上进行配置。</p><p>Web 应用程序的本地缓存是通过每个页面的 <code>manifest</code>文件来管理的。是一个简单的文件文本，清单列举了需要被缓存或者不需要被缓存的资源文件的文件名以及访问路径。</p><p>manifest 文件可分为三个部分：</p><ul><li><em>CACHE MANIFEST</em> - 在此标题下列出的文件将在首次下载后进行缓存</li><li><em>NETWORK</em> - 在此标题下列出的文件需要与服务器的连接，且不会被缓存</li><li><em>FALLBACK</em> - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"># 文件开头必须要书写 CACHE MANIFEST</span><br><span class="line"># 以下是需要缓存的文件</span><br><span class="line"></span><br><span class="line">other.html</span><br><span class="line">images/1.jpg</span><br><span class="line">js/jquery.js</span><br><span class="line">css/bootstrap.css</span><br><span class="line"></span><br><span class="line">NETWORK：</span><br><span class="line">login.asp</span><br><span class="line"></span><br><span class="line">FALLBACK:</span><br><span class="line">online.js locale.js</span><br><span class="line"># 如果无法建立因特网连接，用 404页面替换/html/目录所有的文件，第一个是 URI资源，第二个是替补</span><br><span class="line">/html5/ /404.html</span><br></pre></td></tr></table></figure><p><strong>更新缓存</strong></p><p>一旦应用被缓存，它就会保持缓存知道下列的情况发生：</p><ul><li>用户清空浏览器缓存</li><li>manifest 文件被修改</li><li>由程序来更新应用缓存</li></ul><h3 id="浏览器与服务器的交互过程"><a href="#浏览器与服务器的交互过程" class="headerlink" title="浏览器与服务器的交互过程"></a>浏览器与服务器的交互过程</h3><p>场景：访问 网站A,以 index.html 为主页，使用 manifest 缓存了 index.html、1.js、1.css、1.jpg几个资源文件。</p><p>第一次访问：</p><ol><li>浏览器请求访问网站 A</li><li>服务器访问 index.html</li><li>浏览器解析 index.html，请求页面上的所有资源，包括 HTML/图像文件/CSS/JS/manifest文件等</li><li>服务器返回所有资源</li><li>浏览器处理 manifest文件，请求 manifest指定的本地缓存的文件，即使3中已经请求过了。如果要求缓存所有文件也是一个比较大的重复过程。</li><li>服务器返回所有要求缓存的文件</li><li>浏览器对本地缓存文件进行缓存，触发一个事件，通知本地缓存被更新</li></ol><p>manifest文件没有被修改，第二次访问：</p><ol><li>浏览器再次请求网站A</li><li>浏览器发现这个页面被本地缓存，于是使用本地缓存中的 index.html页面</li><li>浏览器解析 index.html，使用所有本地缓存中的资源文件</li><li>浏览器向服务器请求 manifest 文件</li><li>服务器返回一个 304，通知浏览器 manifest没有发生变化</li></ol><p>manifest文件被修改了，第三次访问：</p><ol><li>浏览器再次请求网站A</li><li>浏览器发送这个页面被本地缓存了，于是使用本地缓存中的 index.html页面</li><li>浏览器解析 index.html 文件，使用所有本地缓存中的资源文件</li><li>浏览器向服务器请求 manifest文件</li><li>服务器返回更新过的 manifest文件</li><li>浏览器处理 manifest文件，发送文件已经更新了，于是请求所有要求进行本地缓存的资源文件，包括 index.html 本身</li><li>浏览器返回要求进行本地缓存的资源文件</li><li>浏览器对本地缓存进行更新，存入所有新的资源文件，并且触发一个事件，通知本地缓存被更新了</li></ol><p>浏览器缓存过程中会触发一系列事件，该事件处理程序注册在ApplicationCache对象上，此对象是window的applicationCache属性的值。</p><p>下面详细描述了加载文档与更新应用缓存的流程：</p><ol><li>当浏览器访问一个包含 <code>manifest</code> 特性的文档时，如果应用缓存不存在，浏览器会加载文档，然后获取所有在清单文件中列出的文件，生成应用缓存的第一个版本。</li><li>对该文档的后续访问会使浏览器直接从应用缓存(而不是服务器)中加载文档与其他在清单文件中列出的资源。此外，浏览器还会向 <code>window.applicationCache 对象发送一个</code> <code>checking</code> 事件，在遵循合适的 HTTP 缓存规则前提下，获取清单文件。</li><li>如果当前缓存的清单副本是最新的，浏览器将向 <code>applicationCache 对象发送一个</code> <code>noupdate</code> 事件，到此，更新过程结束。注意，如果你在服务器修改了任何缓存资源，同时也应该修改清单文件，这样浏览器才能知道它需要重新获取资源。</li><li>如果清单文件<em>已经</em>改变，文件中列出的所有文件—也包括通过调用 <code>applicationCache.add() 方法添加到缓存中的那些文件</code>—会被获取并放到一个临时缓存中，遵循适当的 HTTP 缓存规则。对于每个加入到临时缓存中的文件，浏览器会向 <code>applicationCache 对象发送一个</code> <code>progress</code> 事件。如果出现任何错误，浏览器会发送一个 <code>error</code> 事件，并暂停更新。</li><li>一旦所有文件都获取成功，它们会自动移送到真正的离线缓存中，并向  <code>applicationCache</code>对象发送一个 <code>cached</code> 事件。鉴于文档早已经被从缓存加载到浏览器中，所以更新后的文档不会重新渲染，直到页面重新加载(可以手动或通过程序).</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//载入的时候，检查该清单文件。</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onchecking = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"san"</span>).innerHTML = <span class="string">"checking for a new version"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果清单文件没有动，同时应用程序也已经缓存了，该事件执行。</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onnoupdate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"san"</span>).innerHTML = <span class="string">"This version is up-to-date"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果还未缓存应用程序，或者清单有改动</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.ondownloading = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"san"</span>).innerHTML = <span class="string">"Downloading new version"</span>;</span><br><span class="line">    <span class="built_in">window</span>.progresscount = <span class="number">0</span>; <span class="comment">//在下面的事件中用到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下载过程不断调用progress事件，通常在每个文件下载完的时候。</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> progress = <span class="string">""</span>; </span><br><span class="line">    <span class="keyword">if</span>(e &amp;&amp; e.lengthComputable)&#123;</span><br><span class="line">        progress = <span class="string">""</span> + <span class="built_in">Math</span>.round(<span class="number">100</span>*e.loaded / e.total) + <span class="string">"%"</span>; <span class="comment">//计算下载完成比例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        progress = <span class="string">"("</span> + ++progresscount + <span class="string">")"</span>;  <span class="comment">//输出调用次数。</span></span><br><span class="line">    &#125;</span><br><span class="line">    $(<span class="string">"san"</span>).innerHTML = <span class="string">"Downloading new version"</span> + progress;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当下载完成并且首次将应用程序下载到缓存中时</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.oncached = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"san"</span>).innerHTML = <span class="string">"This application is now cached locally"</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下载完成并且首次将应用程序下载到缓存中。</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.oncached = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">"This application is now cached locally"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//下载完成并缓存的程序更新后触发，注意触发此事件时，用户任然看到老版本，只有当用户再次载入时才会访问最新版。</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onupdateready = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">"A new version has been downloaded.  Reload to run it"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//处于离线时，检查清单失败触发。</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">window</span>.applicationCache.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">"Couldn't load manifest or cache application"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//程序引用一个不存在的清单文件触发，同时将应用从缓存中删除。</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onobsolete = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">"This application is no longer cached. "</span> + </span><br><span class="line">           <span class="string">"Reload to get the latest version from the network."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="通信-API"><a href="#通信-API" class="headerlink" title="通信 API"></a>通信 API</h2><h3 id="跨文档消息传输"><a href="#跨文档消息传输" class="headerlink" title="跨文档消息传输"></a>跨文档消息传输</h3><p>可以在不同网页文档、不同端口、不同域之间进行消息传递。</p><p>HTML5 提供了在网页文档之间互相接受与发送消息的功能，只要获取到网页所在窗口对象的实例，不仅同源（域+端口号）的 Web 之间可以互相通信，甚至可以实现跨域通信。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.postMessage();</span><br><span class="line"><span class="comment">// 这个方法可以安全实现跨域通信。提供了一个受控禁止来规避同源策略的限制。这个方法被调用时，会在所有页面脚本执行完毕之后向目标窗口派发一个 MessageEvent 消息。这个消息有四个属性：message属性表示 message类型，data属性为 window.postMessage的第一个参数；origin属性表示调用 window.postMessage方法调用页面的当前状态；source属性记录调用 window.postMessage方法的窗口消息</span></span><br><span class="line"></span><br><span class="line">otherWindow.postMessage(message,targetOrigin,[transfer]);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* otherWindow 其他窗口的一个引用，比如 iframe的contentWindow属性，执行 window.open返回的窗口对象，或者是命名过或数值索引的 window.frames</span></span><br><span class="line"><span class="comment">* message 将要发送到其他 window的数据，会被结构化克隆算法序列化。意味着不受什么限制将数据对象安全传送给目标窗口不用自己序列化</span></span><br><span class="line"><span class="comment">* targetOrigin 通过窗口的 origin 属性来指定哪些窗口能接受到消息时间。可以是“*”或者一个URI.如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；</span></span><br><span class="line"><span class="comment">* transfer 可选 是一串和 message同时传递的 Transferable 对象，这些对象的所有权将被转移给消息的接收方，而发送一方不再保有所有权。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>派发事件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,receiveMessage,<span class="literal">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; origin,data,source&#125; = event;</span><br><span class="line">    <span class="keyword">if</span>(origin !== <span class="string">'http://example.com:8080'</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(source+<span class="string">':'</span>+data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* message的属性;</span></span><br><span class="line"><span class="comment">* data 从其他 window 传递来的对象</span></span><br><span class="line"><span class="comment">* origin 调用 postMessage 时消息发送方窗口的 origin，不能保证是该窗口当前的 或者 未来的origin，因为 postMessage被调用后可能被导航到不同的位置</span></span><br><span class="line"><span class="comment">* source 对发送消息窗口的引用，可以使用这个在具有不同 origin 的两个窗口建立双向通信</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A窗口域名是 http://example.com:8080 下面是 A 窗口 script 里面代码</span></span><br><span class="line"><span class="keyword">let</span> popup = <span class="built_in">window</span>.open(...popup details...);</span><br><span class="line"><span class="comment">// 如果弹出框没有被阻止且加载完成</span></span><br><span class="line"><span class="comment">// 这行语句没有发送信息出去，即使假设当前页面没有改变location（因为targetOrigin设置不对）</span></span><br><span class="line">popup.postMessage(<span class="string">"The user is 'bob' and the password is 'secret'"</span>,<span class="string">"https://secure.example.net"</span>);</span><br><span class="line"><span class="comment">// 假设当前页面没有改变location，这条语句会成功添加message到发送队列中去（targetOrigin设置对了）</span></span><br><span class="line">popup.postMessage(<span class="string">"hello there!"</span>,<span class="string">"http://example.com"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event.origin !== <span class="string">'http://example.org'</span>) <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,receiveMessage,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 弹出页 popup域名是 http://example.org 下面是 script 里面代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当A页面postMessage被调用后，这个function被addEventListenner调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event.origin !== <span class="string">'http://example.com:8080'</span>) <span class="keyword">return</span></span><br><span class="line">     <span class="comment">// event.data 是 "hello there!"</span></span><br><span class="line">    <span class="comment">// event.source 就当前弹出页的来源页面</span></span><br><span class="line">    event.source.postMessage(<span class="string">"hi there yourself!  the secret response "</span> +<span class="string">"is: rheeeeet!"</span>,event.origin);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, receiveMessage, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="Web-Sockets-通信"><a href="#Web-Sockets-通信" class="headerlink" title="Web Sockets 通信"></a>Web Sockets 通信</h3><p>使用 Web Sockets API 可以在服务器与客户端之间建立一个非 HTTP 的双向连接。这个连接是实时的，也是要永久的，除非某一方显示关闭。</p><p><strong>常量</strong></p><table><thead><tr><th><strong>Constant</strong></th><th><strong>Value</strong></th></tr></thead><tbody><tr><td><code>WebSocket.CONNECTING</code></td><td><code>0</code></td></tr><tr><td><code>WebSocket.OPEN</code></td><td><code>1</code></td></tr><tr><td><code>WebSocket.CLOSING</code></td><td><code>2</code></td></tr><tr><td><code>WebSocket.CLOSED</code></td><td><code>3</code></td></tr></tbody></table><p>以上是WebSocket 构造函数的原型中存在的一些常量，可通过 <code>WebSocket.readyState</code> 对照上述常量判断 WebSocket 连接 当前所处的状态</p><p><strong>用法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URL字符串以 ws 或者 wss（加密通信时）文字开头</span></span><br><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br><span class="line"></span><br><span class="line">socket.addEventListener(<span class="string">'open'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// send方法对服务器发送数据，只能发送文本数据，可以使用 JSON对象把任何 js对象转换为文本数据后发送</span></span><br><span class="line">    socket.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.addEventListerner(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Message from server'</span>,event.data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件句柄</span></span><br><span class="line"><span class="comment">// 接受服务器传过来的数据</span></span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; data &#125; = event</span><br><span class="line">&#125;</span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 开始通信</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听 socket 关闭事件</span></span><br><span class="line">socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 通信结束时的处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭 socket，切断通信连接0000</span></span><br><span class="line">socket.close()</span><br></pre></td></tr></table></figure><h2 id="使用-Web-Workers-处理线程"><a href="#使用-Web-Workers-处理线程" class="headerlink" title="使用 Web Workers 处理线程"></a>使用 Web Workers 处理线程</h2><p>web worker 是运行在后台的 javaScript，不会影响页面的性能。</p><p>创建后台线程的步骤很简单。将需要在后台线程中指定的脚本文件的 URL 地址作为参数，然后创建 Worker对象就可以了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">'worker.js'</span>);</span><br><span class="line"><span class="comment">// 后台线程是不能访问到页面或者窗口对象的，所以如果使用到 window对象或者 document对象会以前你错误的发生</span></span><br></pre></td></tr></table></figure><p>可以通过发送和接收消息来与后台线程互相传递数据。通过 Worker 对象的 onmessage 事件句柄活期户后台线程之间的消息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 处理收到的消息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// message 文本数据</span></span><br><span class="line">worker.postMessage(message);</span><br></pre></td></tr></table></figure><h3 id="示例：求和计算"><a href="#示例：求和计算" class="headerlink" title="示例：求和计算"></a>示例：求和计算</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>从1到给定数值求和<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  输入数值：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"num"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"calculate()"</span>&gt;</span>计算<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">'SumCalculate.js'</span>);</span></span><br><span class="line"><span class="javascript">    worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(event.data);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">calculate</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> num = <span class="built_in">parseInt</span>(<span class="built_in">document</span>.getElementById(<span class="string">'num'</span>).value,<span class="number">10</span>);</span></span><br><span class="line"><span class="undefined">      worker.postMessage(num);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SumCalculate.js</span></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num = event.data;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= num; i++) &#123;</span><br><span class="line">    result += i;</span><br><span class="line">  &#125;</span><br><span class="line">  postMessage(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例：与线程进行数据的交互"><a href="#示例：与线程进行数据的交互" class="headerlink" title="示例：与线程进行数据的交互"></a>示例：与线程进行数据的交互</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>从随机生成的数字中抽取3的倍数并显示<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">"table"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 随机数组</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> intArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> intStr = <span class="string">''</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 生成100个随机数</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">      intArray[i] = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">100</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">        intStr += <span class="string">';'</span>;       </span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">      intStr += intArray[i]</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">'script.js'</span>);</span></span><br><span class="line"><span class="undefined">    worker.postMessage(intStr);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (event.data != <span class="string">''</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> j;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> k;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> tr;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> td;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> intArray = event.data.split(<span class="string">';'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> table = <span class="built_in">document</span>.getElementById(<span class="string">'table'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; intArray.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">          j = <span class="built_in">parseInt</span>(i / <span class="number">10</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="undefined">          k = i % 10;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 该行不存在</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 添加行</span></span></span><br><span class="line"><span class="javascript">            tr = <span class="built_in">document</span>.createElement(<span class="string">'tr'</span>);</span></span><br><span class="line"><span class="javascript">            tr.id = <span class="string">'tr'</span> + j;</span></span><br><span class="line"><span class="undefined">            table.appendChild(tr);</span></span><br><span class="line"><span class="javascript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            tr = <span class="built_in">document</span>.getElementById(<span class="string">'tr'</span> + j);</span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="javascript">          td = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</span></span><br><span class="line"><span class="undefined">          tr.appendChild(td);</span></span><br><span class="line"><span class="undefined">          td.innerHTML = intArray[j * 10 + k];</span></span><br><span class="line"><span class="javascript">          td.style.backgroundColor = <span class="string">'blue'</span>;</span></span><br><span class="line"><span class="javascript">          td.style.color = <span class="string">'white'</span>;</span></span><br><span class="line"><span class="undefined">          td.width = 30;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script.js</span></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; data &#125; = event;</span><br><span class="line">  <span class="keyword">let</span> returnStr=<span class="string">""</span>;</span><br><span class="line">  <span class="keyword">let</span> intArray = data.split(<span class="string">';'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; intArray.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">parseInt</span>(intArray[i]) % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (returnStr != <span class="string">''</span>) &#123;</span><br><span class="line">        returnStr += <span class="string">';'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      returnStr += intArray[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  postMessage(returnStr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程嵌套"><a href="#线程嵌套" class="headerlink" title="线程嵌套"></a>线程嵌套</h3><p><strong>单层嵌套</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html script</span></span><br><span class="line"><span class="keyword">let</span> worket = <span class="keyword">new</span> Worker(<span class="string">'script.js'</span>)</span><br><span class="line">worket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// script.js</span></span><br><span class="line"></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; data &#125; = event;</span><br><span class="line">    <span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">'script2.js'</span>)</span><br><span class="line">    <span class="comment">// 把数据提交给子线程处理</span></span><br><span class="line">    worker.postMessage(<span class="built_in">JSON</span>.stringfy(data))</span><br><span class="line">    worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 把结果返回主页面</span></span><br><span class="line">        postMessage(event.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// script2.js</span></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; data &#125; = event;</span><br><span class="line">    result = someMethod(data);</span><br><span class="line">    <span class="comment">// 将处理好的处理返回</span></span><br><span class="line">    postMessage(result)</span><br><span class="line">    <span class="comment">// 如果不再使用则关闭子线程</span></span><br><span class="line">    close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多个线程中进行数据的交互</strong></p><p>实现子线程与子线程之间数据交互的，大致需要下面步骤：</p><ol><li>先创建发送数据的子线程</li><li>执行子线程中的任务，然后把要传递的数据发送给主线程</li><li>在主线程接受到子线程传回来的消息时，创建接受数据的子线程，然后把发送数据的子线程中返回的消息传递给接受数据的子线程</li><li>执行接受数据子线程中的代码</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> worker;</span><br><span class="line">    worker = <span class="keyword">new</span> Worker(<span class="string">'worker1.js'</span>);</span><br><span class="line">    worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 接受子线程中的数据</span></span><br><span class="line">        <span class="keyword">let</span> &#123; data &#125; = event;</span><br><span class="line">        worker = <span class="keyword">new</span> Worker(<span class="string">'worker2.js'</span>);</span><br><span class="line">        <span class="comment">// 把从发送数据的子线程中发回的消息传递给接受数据的子线程</span></span><br><span class="line">        worker.postMessage(data);</span><br><span class="line">        worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 获取接受数据的子线程中传回的数据</span></span><br><span class="line">            <span class="keyword">let</span> &#123;data&#125; = event;</span><br><span class="line">            <span class="comment">// 把结果发送到主页面</span></span><br><span class="line">            postMessage(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker1.js 发送数据的子线程</span></span><br><span class="line">onmessga = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;someData&#125; = event;</span><br><span class="line">    result = someMethod(someData);</span><br><span class="line">    postMassage(result);</span><br><span class="line">    <span class="comment">// 关闭子线程</span></span><br><span class="line">    close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程中可用的变量、函数与类"><a href="#线程中可用的变量、函数与类" class="headerlink" title="线程中可用的变量、函数与类"></a>线程中可用的变量、函数与类</h3><ul><li><p>self</p><p>表示本线程范围内的作用域</p></li><li><p>postMessage(message)</p><p>向创建线程的源窗口发送信息</p></li><li><p>onmessage</p><p>获取接受消息的事件句柄</p></li><li><p>importScripts(urls)</p><p>导入其他脚本文件，参数为文件的 URL地址，可以导入多个</p></li><li><p>navigator</p><p>与 window.navigator对象类似，具有 appName、platform、userAgent、appVersion这些属性</p></li><li><p>sessionStorage/localStorage</p><p>可以在线程中使用 Web Storage</p></li><li><p>XMLHttpRequest</p><p>在线程中处理 Ajax请求</p></li><li><p>setTimeout/setInterval</p><p>在线程中实现定时处理</p></li><li><p>close</p><p>结束本线程</p></li><li><p>eval/isNaN/escape</p><p>使用 javascipt 的核心函数</p></li><li><p>object</p><p>可以创建对象</p></li><li><p>WebSockets</p><p>使用 WebSockets API 来想服务器发送和接收信息</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习链接：&lt;br&gt;&lt;a href=&quot;https://read.douban.com/ebook/15160963/&quot;&gt;HTML 5与CSS 3权威指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.w3cschool.cn/html/&quot;&gt;W3cScholl
      
    
    </summary>
    
      <category term="前端面试" scheme="http://laibh.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="HTML5" scheme="http://laibh.top/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>面试官问我HTML5是什么（上）</title>
    <link href="http://laibh.top/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91HTML5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E4%B8%8A%EF%BC%89.html"/>
    <id>http://laibh.top/面试官问我HTML5是什么（上）.html</id>
    <published>2019-05-23T01:30:54.000Z</published>
    <updated>2022-03-04T10:00:38.468Z</updated>
    
    <content type="html"><![CDATA[<p>学习链接：<br><a href="https://read.douban.com/ebook/15160963/">HTML 5与CSS 3权威指南</a></p><p><a href="https://www.w3cschool.cn/html/">W3cScholl</a></p><h2 id="HTML5-与-HTML4-的区别"><a href="#HTML5-与-HTML4-的区别" class="headerlink" title="HTML5 与 HTML4 的区别"></a>HTML5 与 HTML4 的区别</h2><p>常见代码区别：</p><p>新增的一些属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"search"</span> <span class="attr">id</span>=<span class="string">"search"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'search'</span>).focus();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"search"</span> <span class="attr">autofocus</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结构上：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"nav"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"section"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"side-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="HTML-5-要解决的三个问题"><a href="#HTML-5-要解决的三个问题" class="headerlink" title="HTML 5 要解决的三个问题"></a>HTML 5 要解决的三个问题</h3><ul><li>Web 浏览器之间的兼容性很低</li><li>文档结构不明确</li><li>Web应用程序的功能受到了限制</li></ul><h3 id="语法的改变"><a href="#语法的改变" class="headerlink" title="语法的改变"></a>语法的改变</h3><p>HTML 语法是在 SGML(Standard Generalized Markup Language)语言的基础上建立起来的。对于 HTML 的执行在各个浏览器之间没有统一的一个标准。</p><p>HTML5 就是围绕这个Web标准，重新定义了一套在现有的 HTML 的基础上修改而来的语法，使它运行在各浏览器时它们都能符合这个通用标准。</p><h4 id="HTML5-的标记方法"><a href="#HTML5-的标记方法" class="headerlink" title="HTML5 的标记方法"></a>HTML5 的标记方法</h4><p>1.内容类型（ContentType）</p><p>扩展符仍为 ‘.html’或者 ‘.htm’。内容类型仍然为 ‘text/html’</p><p>2.DOCTYPE 声明</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C/DTD 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/Xhtml1-transitional.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br></pre></td></tr></table></figure><p>3.指定字符编码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equive</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="确保与之前的HTML-版本兼容"><a href="#确保与之前的HTML-版本兼容" class="headerlink" title="确保与之前的HTML 版本兼容"></a>确保与之前的HTML 版本兼容</h4><p>1.可以省略标记的元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不允许写结束标记的元素有：area/base/br/col/command/embed/hr/img/input/keygen/link/meta/param/source/track/wbr</span><br><span class="line">可以省略结束标记的元素：</span><br><span class="line">li/dt/dd/p/rt/rp/optgroup/option/colgroup/thead/tbody/tfoot/tr/td/th</span><br><span class="line">可以省略全部标记的元素(隐式存在，在文档结构仍然存在)：</span><br><span class="line">html/head/body/colgroup/tbody</span><br></pre></td></tr></table></figure><p>2.具有 boolean 值的属性</p><p>例如 disable/readonly/checked 等，只写属性不写属性值或者属性值为空字符表示属性值为 true。</p><p>3.省略引号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="新增的元素和废除的元素"><a href="#新增的元素和废除的元素" class="headerlink" title="新增的元素和废除的元素"></a>新增的元素和废除的元素</h3><h3 id="新增-html5-html4"><a href="#新增-html5-html4" class="headerlink" title="新增-html5(html4)"></a>新增-<code>html5(html4)</code></h3><h4 id="结构元素"><a href="#结构元素" class="headerlink" title="结构元素"></a>结构元素</h4><p><code>section(div)</code></p><p>表示页面中的一个内容区块，用于章节、页眉、页脚或者页面中的其他部分。与 h1-h6元素结合使用，表示文档结构</p><p><code>article(div)</code></p><p>表示页面中的一块与上下文不相关的独立内容，例如博客中的一篇文章或者报纸中的一篇文章</p><p><code>aside(div)</code></p><p>aside 元素表示 article 元素的内容之外的，与 article 元素内容相关的辅助信息</p><p><code>header(div)</code></p><p>表示页面一个内容区块或者整个页面的标题</p><p><code>hgroup(div)</code></p><p>用于整个页面或者页面中的一个内容块的标题进行组合</p><p><code>footer(div)</code></p><p>整个页面或者页面中的一个内容区块的脚注。一般来说，会包括作者的姓名、创作日期以及作者的联系信息。</p><p><code>nav(ul)</code></p><p>页面中导航链接部分</p><p><code>figure(dl)</code></p><p>一段独立的流内容，一般表示文档主体流内容中的一个独立单元，使用 <code>figcaption</code> 元素 为 <code>figure</code> 元素组添标题</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hahahahaha<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hahahahaha<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="多媒体元素"><a href="#多媒体元素" class="headerlink" title="多媒体元素"></a>多媒体元素</h4><p><code>video(object)</code></p><p>定义视频，比如电影片段或者其他视频流</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">'movie.ogg'</span> <span class="attr">controls</span>=<span class="string">'controls'</span>&gt;</span>video元素<span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">type</span>=<span class="string">'video/ogg'</span> <span class="attr">data</span>=<span class="string">'movie.ogv'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parma</span> <span class="attr">name</span>=<span class="string">'src'</span> <span class="attr">value</span>=<span class="string">"movie.ogv"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>audio(object)</code></p><p>定义音频，比如音乐或者其他音频流</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">'music.wav'</span>&gt;</span>audio元素<span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">type</span>=<span class="string">'application/ogg'</span> <span class="attr">data</span>=<span class="string">'someaudio.wav'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parma</span> <span class="attr">name</span>=<span class="string">'src'</span> <span class="attr">value</span>=<span class="string">"someaudio.wav"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>embed(object)</code></p><p>用来插入各种多媒体，格式可以是 Midi/Wav/AIFF/AU/MP3</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">'music.swf'</span>&gt;</span>embed元素<span class="tag">&lt;/<span class="name">embed</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">type</span>=<span class="string">'application/x-shockwave-flash'</span> <span class="attr">data</span>=<span class="string">'music.swf'</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>source</code></p><p>为媒介元素定义媒介资源</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"horse.ogg"</span> <span class="attr">type</span>=<span class="string">"audio/ogg"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"horse.mp3"</span> <span class="attr">type</span>=<span class="string">"audio/mpeg"</span>&gt;</span></span><br><span class="line"> Your browser does not support the audio element.</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">type</span>=<span class="string">'application/ogg'</span> <span class="attr">data</span>=<span class="string">'someaudio.wav'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parma</span> <span class="attr">name</span>=<span class="string">'src'</span> <span class="attr">value</span>=<span class="string">"someaudio.wav"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="语义元素"><a href="#语义元素" class="headerlink" title="语义元素"></a>语义元素</h4><p><code>mark(span)</code>元素</p><p>用来在视觉上向用户呈现那些需要突出显示或者高亮显示的文字。mark 元素的一个比较经典的应用就是在搜索结果中向用户高亮显示搜索关键词</p><p><code>progress(无)</code></p><p>表示进程运行中的进程，可以用 progress 来显示 javascript 中耗费时间的函数的进程</p><p><code>meter(无)</code></p><p>表示度量衡。仅用于已知最大值和最小值的度量。必须定义度量的范围，既可以在元素的文本中，也可以在 min/max 属性中定义。</p><p><code>time(span)</code></p><p>表示日期或者时间，也可以同时表示两者</p><p><code>ruby(无)</code></p><p>表示 ruby 注释（中文注音或者字符）</p><p>在东亚使用，显示的是东亚字符的发音。</p><p>与 <code>&lt;ruby&gt;</code> 以及 <code>&lt;rt&gt;</code> 标签一同使用：</p><p>ruby 元素由一个或多个字符（需要一个解释/发音）和一个提供该信息的 rt 元素组成，还包括可选的 rp 元素，定义当浏览器不支持 “ruby” 元素时显示的内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;ruby&gt;</span><br><span class="line"> 漢 <span class="tag">&lt;<span class="name">rt</span>&gt;</span> ㄏㄢˋ <span class="tag">&lt;/<span class="name">rt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>rt(无)</code></p><p>表示元素字符的解释或者发音</p><p><code>rp（无）</code></p><p>在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容</p><p><code>wbr</code></p><p>表示软换行，wbr 与 br 区别在于后者表示此处必须换行，前者是浏览器窗口或者父级元素的宽度足够宽的时候不进行换行，而当宽度不够时，主动在此处进行换行。wbr 元素好像对字符型的语言作用挺大，但是对中文没有多大用处。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>学习 AJAX ,您必须熟悉 <span class="tag">&lt;<span class="name">wbr</span>&gt;</span>Http<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>Request 对象。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>canvas</code></p><p>canvas 表示图形，比如图表和其他图像。元素本身没有行为，仅提供一块画布，但它把一个绘图 API 展示给 客户端的 javascript 以使得脚本能够把想绘制的东西绘制到这块画布上面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">'myCanvas'</span> <span class="attr">width</span>=<span class="string">'200'</span> <span class="attr">height</span>=<span class="string">'200'</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">type</span>=<span class="string">'image/svg+xml'</span> <span class="attr">data</span>=<span class="string">'inc/hdr.svg'</span> <span class="attr">width</span>=<span class="string">'200'</span> <span class="attr">height</span>=<span class="string">'200'</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>details</code></p><p>details 元素表示用户要求得到并且可以得到的细节信息，可以与 <code>summary</code>元素配合使用。<code>summary</code>提供标题或者图例。标题是可见的，用户点击标题时，会显示出细节信息。<code>summary</code>元素应该是 <code>details</code>元素的第一个子元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">summary</span>&gt;</span>H5<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">    hahahahha</span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>datalist</code></p><p>表示可选数据的列表，与 input 元素配合使用，可以制作出 输入值的下拉列表。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">list</span>=<span class="string">"cars"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"cars"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"BMW"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Ford"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Volvo"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>datagrid</code></p><p>表示可选数据的列表，以树形列表的形式来显示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">datagrid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span> (datagrid row 0) <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span> (datagrid row 1)</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">style</span>=<span class="string">"list-style-type:lower-alpha;"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span> (datagrid row 1,0) <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span> (datagrid row 1,1) <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span> (datagrid row 2) <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">datagrid</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>output(span)</code></p><p>表示不同类型的输出，比如脚本输出</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">form</span> <span class="attr">oninput</span>=<span class="string">"x.value=parseInt(a.value)+parseInt(b.value)"</span>&gt;</span></span><br><span class="line">0</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">id</span>=<span class="string">'a'</span> <span class="attr">value</span>=<span class="string">"50"</span>&gt;</span>100+</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">id</span>=<span class="string">"b"</span> <span class="attr">value</span>=<span class="string">"50"</span>&gt;</span>=</span><br><span class="line"><span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">"x"</span> <span class="attr">for</span>=<span class="string">"a b"</span>&gt;</span><span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>menu</code></p><p>表示菜单列表，当希望列出表单控件的时候使用该标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">type</span>=<span class="string">"toolbar"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">menu</span> <span class="attr">label</span>=<span class="string">"File"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"file_new()"</span>&gt;</span>新建<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"file_open()"</span>&gt;</span>打开<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"file_save()"</span>&gt;</span>保存<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">menu</span> <span class="attr">label</span>=<span class="string">"Edit"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"edit_cut()"</span>&gt;</span>剪切<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"edit_copy()"</span>&gt;</span>复制<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"edit_paste()"</span>&gt;</span>粘贴<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是目前主流所有浏览器都不支持这个标签</p><h4 id="input元素类型"><a href="#input元素类型" class="headerlink" title="input元素类型"></a>input元素类型</h4><p><code>email</code></p><p>表示必须输入 E-mail </p><p><code>url</code></p><p>输入 URL 地址</p><p><code>number</code></p><p>输入数值</p><p><code>range</code></p><p>输入一定范围内数字值</p><p><code>Date Pickers</code></p><p>拥有多个选择日期和时间的新型输入文本框</p><p>data-日、月、年</p><p>month-月、年</p><p>week-周、年</p><p>time-小时、分钟</p><p>datetime-日、月、年（UTC）</p><p>datetime-local-日、月、年（本地时间）</p><h3 id="废除（替代元素）"><a href="#废除（替代元素）" class="headerlink" title="废除（替代元素）"></a>废除（替代元素）</h3><p>1.能用css替代的元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">basefont/big/center/font/s/strike(del)/tt/u</span><br></pre></td></tr></table></figure><p>2.不再使用 frame 框架</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frameset/frame/noframes，现只支持 iframe框架。</span><br></pre></td></tr></table></figure><p>3.只有部分浏览器支持的元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applet(embed/obejct)/bgsound(audio)/blink/marquee</span><br></pre></td></tr></table></figure><p>4.其他被废除的元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rb(ruby)/acronym(abbr)/dir(ul)/isindex(form+input)/listing(pre)/xmp(code)/nextid(GUIDS)/plaintext('text/plain' MIME 类型)</span><br></pre></td></tr></table></figure><h3 id="新增的属性和废除的属性"><a href="#新增的属性和废除的属性" class="headerlink" title="新增的属性和废除的属性"></a>新增的属性和废除的属性</h3><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><h4 id="表单相关的属性"><a href="#表单相关的属性" class="headerlink" title="表单相关的属性"></a>表单相关的属性</h4><ul><li><code>input[type=text]</code>、<code>select</code>与 <code>button</code> 指定 <code>autofucus</code>属性，以指定的方式让元素在画面打开的时候自动获得焦点</li><li><code>input[type=text]</code>与 <code>textarea</code>指定 <code>placeholder</code>属性，会对用户的输入进行提示，提示用户输入的内容</li><li><code>input</code>、<code>output</code>、<code>select</code>、<code>textarea</code>、<code>button</code>与 <code>fieldset</code>指定 <code>form</code>属性，声明它们属性哪个表单，然后将其放置任何位置，而不是在表单之内</li><li><code>input[type=text]</code>与 <code>textarea</code>指定 <code>required</code>。表示用户提交的时候进行检查，检查该元素内一定要有输入内容</li><li><code>input</code>其他新增的属性：<code>autocomplete</code>、<code>min</code>、<code>max</code>、<code>multiple</code>、<code>pattern</code>、<code>step</code>。同时还有一个 新的 <code>list</code>元素可以与 <code>datalist</code>配合使用。<code>datalist</code>与 <code>autocomplete</code>属性配合使用。<code>multiple</code>属性允许在上传文件的时候一次上传多个文件。</li><li><code>input</code>、<code>button</code>增加了新的属性 <code>formaction</code>、<code>formenctype</code>、<code>formmethod</code>、<code>formnovalidate</code>与 <code>formtarget</code>，它们可以重载 <code>form</code>元素的 <code>action</code>、<code>enctype</code>、<code>method</code>、<code>novalidate</code>与 <code>target</code>属性。为  <code>fileset</code>增加了 <code>disabled</code>，可以把它的子元素设为 <code>disabled(无效)</code>状态</li><li><code>input</code>、<code>button</code>、<code>form</code>增加了 <code>novalidate</code>属性，该属性可以取消提交时进行的有关检查，表单可以被无条件提交。</li></ul><h4 id="链接相关属性"><a href="#链接相关属性" class="headerlink" title="链接相关属性"></a>链接相关属性</h4><ul><li><code>a</code>与 <code>area</code>增加 <code>media</code>属性，该属性规定目标 URL是什么类型的媒介/设备进行优化，只能在 <code>href</code>属性存在时使用</li><li>为 <code>area</code>元素增加了 <code>hreflang</code>属性与 <code>rel</code>属性，以保持与 <code>a</code>元素、<code>link</code>元素的一致。</li><li><code>link</code>元素增加了新的属性 <code>sizes</code>。该属性可以与 <code>icon</code>属性元素结合使用(通过 <code>rel</code>属性)，该属性指定关联图标（<code>icon</code>元素）的大小。</li><li>为 <code>base</code>元素增加了<code>target</code>属性，主要目的是保持与 <code>a</code>元素的一致性。</li></ul><h4 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h4><p>除了上面介绍的与表单和链接相关的属性外，HTML5 还增加了下面的属性：</p><ul><li><code>ol</code>元素增加 <code>reversed</code>,它指定了列表倒序显示</li><li><code>meta</code>增加 <code>charset</code>属性。因为这个属性被广泛支持了，而且为文档的字符编码的执行提供了一种良好的方式</li><li>为 <code>style</code>属性增加<code>scoped</code>属性，用来规定样式的作用范围，例如只对页面某个树起作用。</li><li><code>script</code>增加 <code>async</code>属性，定义脚本是否异步执行</li><li><code>html</code>增加 <code>mainfest</code>，开发离线Web 应用程序时它与 API 结合使用，定义一个 URL,在这个 URL 上描述文档的缓存信息。</li><li><code>iframe</code>元素增加了三个属性 <code>sandbox</code>、<code>seamless</code>与 <code>srcdoc</code>，用来提高页面安全性，防止不信任的 Web 页面执行某些操作。</li></ul><h3 id="废除"><a href="#废除" class="headerlink" title="废除"></a>废除</h3><table><thead><tr><th><strong>在HTML 4中使用的属性</strong></th><th><strong>使用该属性的元素</strong></th><th><strong>在HTML 5中的替代方案</strong></th></tr></thead><tbody><tr><td><strong>rev</strong></td><td>link、a</td><td>rel</td></tr><tr><td><strong>charset</strong></td><td>link、a</td><td>在被链接的资源的中使用HTTP Content-type头元素</td></tr><tr><td><strong>shape</strong>、coords</td><td>a</td><td>使用area元素代替a元素</td></tr><tr><td><strong>longdesc</strong></td><td>img、iframe</td><td>使用a元素链接到校长描述</td></tr><tr><td><strong>target</strong></td><td>link</td><td>多余属性，被省略</td></tr><tr><td><strong>nohref</strong></td><td>area</td><td>多余属性，被省略</td></tr><tr><td><strong>profile</strong></td><td>head</td><td>多余属性，被省略</td></tr><tr><td><strong>version</strong></td><td>html</td><td>多余属性，被省略</td></tr><tr><td><strong>name</strong></td><td>img</td><td>id</td></tr><tr><td><strong>scheme</strong></td><td>meta</td><td>只为某个表单域使用scheme</td></tr><tr><td><strong>archive**</strong>、chlassid、codebose、codetype、declare、standby**</td><td>object</td><td>使用data与typc属性类调用插件。需要使用这些属性来设置参数时，使用param属性</td></tr><tr><td><strong>valuetype</strong>、type</td><td>param</td><td>使用name与value属性，不声明之的MIME类型</td></tr><tr><td><strong>axis</strong>、abbr</td><td>td、th</td><td>使用以明确简洁的文字开头、后跟详述文字的形式。可以对更详细内容使用title属性，来使单元格的内容变得简短</td></tr><tr><td><strong>scope</strong></td><td>td</td><td>在被链接的资源的中使用HTTP Content-type头元素</td></tr><tr><td><strong>align</strong></td><td>caption、input、legend、div、h1、h2、h3、h4、h5、h6、p</td><td>使用CSS样式表替代</td></tr><tr><td><strong>alink</strong>、link、text、vlink、background、bgcolor</td><td>body</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、bgcolor、border、cellpadding、cellspacing、frame、rules、width</td><td>table</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、char、charoff、height、nowrap、valign</td><td>tbody、thead、tfoot</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、bgcolor、char、charoff、height、nowrap、valign、width</td><td>td、th</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、bgcolor、char、charoff、valign</td><td>tr</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、char、charoff、valign、width</td><td>col、colgroup</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、border、hspace、vspace</td><td>object</td><td>使用CSS样式表替代</td></tr><tr><td><strong>clear</strong></td><td>br</td><td>使用CSS样式表替代</td></tr><tr><td><strong>compace</strong>、type</td><td>ol、ul、li</td><td>使用CSS样式表替代</td></tr><tr><td><strong>compace</strong></td><td>dl</td><td>使用CSS样式表替代</td></tr><tr><td><strong>compace</strong></td><td>menu</td><td>使用CSS样式表替代</td></tr><tr><td><strong>width</strong></td><td>pre</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、hspace、vspace</td><td>img</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、noshade、size、width</td><td>hr</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、frameborder、scrolling、marginheight、marginwidth</td><td>iframe</td><td>使用CSS样式表替代</td></tr><tr><td><strong>autosubmit</strong></td><td>menu</td></tr></tbody></table><h3 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h3><h4 id="contentEditable"><a href="#contentEditable" class="headerlink" title="contentEditable"></a>contentEditable</h4><p>允许用户编辑元素中的内容，该元素必须是可以获得用户鼠标焦点的元素，在点击鼠标后要向用户提供一个插入符号，提示用户该元素中的内容允许被编辑。<code>contentEditable</code>属性是一个布尔值属性，可以被指定 <code>true</code>或者 <code>false</code></p><p>除此之外，还有一个隐藏的 <code>inherit</code>状态，属性为  <code>true</code>，元素被指定为允许编辑，属性为 <code>false</code>时，元素被指定为不允许编辑。未指定 <code>true</code>或者 <code>false</code>时，则由 <code>inherit</code>状态来决定，如果元素的父元素是可以编辑的，则该元素就是可编辑的。</p><p>元素还具有一个叫做 <code>isContentEditable</code>属性，当元素可编辑时，该属性为 true，当元素不可编辑时，该属性 为 false。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">contentEditable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>元素列表1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>元素列表2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>元素列表3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="designMode"><a href="#designMode" class="headerlink" title="designMode"></a>designMode</h4><p><code>designMode</code> 属性用来指定整个页面是否可编辑，当页面可编辑时，页面中任何支持上文所述的 <code>contentEditable</code> 属性的元素都变成了可编辑状态。<code>designMode</code>只能在 javascript 脚本里被编辑修改。该属性有两个值——“on” 和 “off”。属性被指定为 <code>on</code>时，页面可编辑，被指定为 <code>off</code>时，页面不可编辑。使用 javascript 来指定 designMode 属性的方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.designMode = <span class="string">'on'</span></span><br></pre></td></tr></table></figure><p>针对 <code>designMode</code> 属性，各个浏览器的支持情况也不一样：</p><ul><li>IE8：安全考虑，不允许使用 <code>designMode</code>属性让页面进行编辑状态</li><li>IE9：允许使用 <code>designMode</code>属性让页面进入编辑状态</li><li>Chrome3 和 Safari：使用内嵌 <code>frame</code>方式，该内嵌 <code>frame</code>是可编辑的</li><li>Firefox 和 Opera：允许使用 <code>designMode</code>属性让页面进入编辑状态</li></ul><h4 id="hidden"><a href="#hidden" class="headerlink" title="hidden"></a>hidden</h4><p>在 HTML5 中，所有的元素都允许有一个 <code>hidden</code>属性，该属性类似于 <code>input</code> 中的 <code>hidden</code>元素，功能是通知浏览器不渲染该元素，使该元素处于不可见状态。但是元素中的内容还是浏览器创建的，也就是说页面装载后允许使用 javascript 脚本将该属性取消，取消后该元素变为可见状态，同时元素中的内容页即时显示出来。<code>hidden</code>属性是一个布尔值的属性，为设为 <code>true</code>后，元素处于不可见状态，当设为 <code>false</code>后，元素属于可见状态。</p><h4 id="spellcheck"><a href="#spellcheck" class="headerlink" title="spellcheck"></a>spellcheck</h4><p><code>spellcheck</code> 是针对 <code>input</code>与 <code>textarea</code>这两个文本输入框提供的一个新属性，它的功能为对用户输入的文本内容进行拼写和语法检查。是一个布尔值属性，具有 true 和 false 两种值。必须明确书写属性值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">contentEditable</span> <span class="attr">spellcheck</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">spellcheck</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">contenteditable</span>=<span class="string">"true"</span> <span class="attr">spellcheck</span>=<span class="string">"true"</span>&gt;</span>这是可编辑的段落。请试着编辑文本。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是如果元素的 <code>readonly</code>或者  <code>disabled</code>设为 <code>true</code>，则不执行拼写检查。</p><h4 id="tabindex"><a href="#tabindex" class="headerlink" title="tabindex"></a>tabindex</h4><p>当不断敲击 Tab 键让窗口或者页面中的控件获得焦点，对窗口或者页面的所有控件进行遍历的时候，每一个控件的 <code>tabindex</code>表示该控件是第几个页面访问到的。</p><p>过去的这个属性在编辑网页的时候非常有用，但如今控件的遍历顺序是由元素在页面上所处的位置决定的，所以不再需要了。</p><p>但是 <code>tabindex</code>还有另外一个作用，在默认属性下，只有链接元素与表单可以通过按键获得焦点。如果对其他元素使用 <code>tabindex</code>属性后，也能让该元素获得焦点，那么当脚本中执行 <code>focus()</code>语句的时候，就可以让该元素获得焦点了。但这样做会有一个副作用：钙元素也可以通过按 Tab 键获得焦点，而这时有可能也不是开发者想要的结果。</p><p>把元素的 <code>tabindex</code>设为为负数（通常为-1）后就可以解决这个问题。<code>tabindex</code>的值为负数后，仍然可以通过编程的方式让元素获得焦点，但按下 Tab 键时该元素就不能获得焦点了。这在复杂的页面中或复杂的 Web 应用程序中是非常有用的。在 HTML4 中，-1 是一个无用的属性值，但到了 HTML5 中，通过巧妙运用让该属性得到了极大的应用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://laibh.top"</span> <span class="attr">tabindex</span>=<span class="string">"2"</span>&gt;</span>赖同学<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.google.com/"</span> <span class="attr">tabindex</span>=<span class="string">"1"</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.microsoft.com/"</span> <span class="attr">tabindex</span>=<span class="string">"3"</span>&gt;</span>Microsoft<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="data"><a href="#data" class="headerlink" title="data-*"></a>data-*</h4><p>使用 data-* 属性来嵌入自定义数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"target"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"e1"</span> <span class="attr">data-animal-type</span>=<span class="string">"鸟类"</span>&gt;</span>喜鹊<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"e2"</span> <span class="attr">data-animal-type</span>=<span class="string">"鱼类"</span>&gt;</span>金枪鱼<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"e3"</span> <span class="attr">data-animal-type</span>=<span class="string">"蜘蛛"</span>&gt;</span>蝇虎<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">showDetails</span>(<span class="params">animal</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> animalType = animal.getAttribute(<span class="string">"data-animal-type"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(animal.innerHTML + <span class="string">'是一种'</span> + animalType);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'target'</span>);</span></span><br><span class="line"><span class="javascript">    ul.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> ev = e || <span class="built_in">window</span>.event;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> target = ev.target || ev.srcElement;</span></span><br><span class="line"><span class="undefined">        showDetails(target);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="draggable"><a href="#draggable" class="headerlink" title="draggable"></a>draggable</h4><p>规定元素是否可以拖动，链接和图像默认是可以拖动的。</p><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element</span> <span class="attr">draggable</span>=<span class="string">"true|false|auto"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-id">#dropbox</span>&#123;</span></span><br><span class="line"><span class="undefined">width: 400px;</span></span><br><span class="line"><span class="undefined">height: 400px;</span></span><br><span class="line"><span class="css"><span class="selector-tag">border</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-id">#aaaaaa</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"dropbox"</span> <span class="attr">ondrop</span>=<span class="string">"drop(event)"</span> <span class="attr">ondragover</span>=<span class="string">"allowDrop(event)"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"drag"</span> <span class="attr">draggable</span>=<span class="string">"true"</span> <span class="attr">ondragstart</span>=<span class="string">"drag(event)"</span>&gt;</span>这是一段可移动的段落，请把该段落拖入上面的矩形<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">allowDrop</span>(<span class="params">ev</span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">        ev.preventDefault();</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">ev</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        ev.dataTransfer.setData(<span class="string">'Text'</span>,ev.target.id)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">drop</span>(<span class="params">ev</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> data = ev.dataTransfer.getData(<span class="string">'Text'</span>);</span></span><br><span class="line"><span class="javascript">        ev.target.appendChild(<span class="built_in">document</span>.getElementById(data));</span></span><br><span class="line"><span class="undefined">        ev.preventDefault()</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="新结构元素使用样式"><a href="#新结构元素使用样式" class="headerlink" title="新结构元素使用样式"></a>新结构元素使用样式</h3><p>兼容旧版本浏览器的 hack</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    article,aside,dialog,figure,footer,header,legend,nav,section&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">display</span><span class="selector-pseudo">:block</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    nav&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:20</span>%;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    article&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">float</span><span class="selector-pseudo">:right</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:79</span>%;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--IE8之前的浏览器不支持使用 CSS方法来使用这些尚未支持的结构元素，需要使用脚本定义--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.createElement(<span class="string">'header'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.createElement(<span class="string">'nav'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.createElement(<span class="string">'article'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.createElement(<span class="string">'footer'</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--或者引入一个 js来hack--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML5 HACK<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[if lt IE9]&gt;</span></span><br><span class="line"><span class="comment">&lt;script src="http://apps.bdimg.com/libs/html5shiv/3.7/html5shiv.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">    &lt;![end if]--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="表单与文件"><a href="#表单与文件" class="headerlink" title="表单与文件"></a>表单与文件</h2><p><strong>新的 form 属性</strong>：</p><ul><li>autocomplete</li><li>novalidate</li></ul><p><strong>新的 input 属性</strong>：</p><ul><li>autocomplete</li><li>autofocus</li><li>form</li><li>form overrides (formaction, formenctype, formmethod, formnovalidate, formtarget)</li><li>height 和 width</li><li>list</li><li>min, max 和 step</li><li>multiple</li><li>pattern (regexp)</li><li>placeholder</li><li>required</li></ul><p><strong>浏览器支持</strong></p><table><thead><tr><th style="text-align:left">Input type</th><th style="text-align:left">IE</th><th style="text-align:left">Firefox</th><th style="text-align:left">Opera</th><th style="text-align:left">Chrome</th><th style="text-align:left">Safari</th></tr></thead><tbody><tr><td style="text-align:left">autocomplete</td><td style="text-align:left">8.0</td><td style="text-align:left">3.5</td><td style="text-align:left">9.5</td><td style="text-align:left">3.0</td><td style="text-align:left">4.0</td></tr><tr><td style="text-align:left">autofocus</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">10.0</td><td style="text-align:left">3.0</td><td style="text-align:left">4.0</td></tr><tr><td style="text-align:left">form</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">9.5</td><td style="text-align:left">No</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">form overrides</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">10.5</td><td style="text-align:left">No</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">height and width</td><td style="text-align:left">8.0</td><td style="text-align:left">3.5</td><td style="text-align:left">9.5</td><td style="text-align:left">3.0</td><td style="text-align:left">4.0</td></tr><tr><td style="text-align:left">list</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">9.5</td><td style="text-align:left">No</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">min, max and step</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">9.5</td><td style="text-align:left">3.0</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">multiple</td><td style="text-align:left">No</td><td style="text-align:left">3.5</td><td style="text-align:left">No</td><td style="text-align:left">3.0</td><td style="text-align:left">4.0</td></tr><tr><td style="text-align:left">novalidate</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">pattern</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">9.5</td><td style="text-align:left">3.0</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">placeholder</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">3.0</td><td style="text-align:left">3.0</td></tr><tr><td style="text-align:left">required</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">9.5</td><td style="text-align:left">3.0</td><td style="text-align:left">No</td></tr></tbody></table><h3 id="新增属性"><a href="#新增属性" class="headerlink" title="新增属性"></a>新增属性</h3><p><code>form</code></p><p>在 HTML4 中表单内的从属元素必须写在表单内容，但是 HTML5 中，可以把它书写在页面的任何地方，然后给该元素指定一个 <code>form</code>属性。属性值为该表单的 id，这样就可以声明该元素从属于指定表单了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"testform"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">form</span>=<span class="string">"testform"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><p>目前只有 Opera 支持这个属性</p><p><code>formaction</code></p><p>HTML4中，一个表单内的所有元素都只能通过表单的 <code>action</code>属性统一提交到另一个页面，而在 HTML5 可以给所有的提交按钮，<code>&lt;input type=&quot;submit&quot;&gt;</code>、<code>&lt;input type=&quot;image&quot;&gt;</code>、<code>&lt;button type=&quot;submit&quot;&gt;</code>都增加 <code>formaction</code>属性，使得点击不同的按钮，可以将表单提交到不同的页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"testform"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"s1"</span> <span class="attr">value</span>=<span class="string">"v1"</span> <span class="attr">formaction</span>=<span class="string">"s1.jsp"</span>&gt;</span>提交到 s1</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"s2"</span> <span class="attr">value</span>=<span class="string">"v2"</span> <span class="attr">formaction</span>=<span class="string">"s2.jsp"</span>&gt;</span>提交到 s2</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"s3"</span> <span class="attr">value</span>=<span class="string">"v3"</span> <span class="attr">formaction</span>=<span class="string">"s3.jsp"</span>&gt;</span>提交到 s3</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>目前没有浏览器支持这一属性</p><p><code>formmethod</code></p><p>在 HTML4 中只有一个表单内有 <code>action</code>属性来对表单内所有元素统一指定提交页面，所以每个表单内只有一个 <code>method</code>属性来指统一指定提交方法。在 HTML5 中，可以使用 <code>formaction</code>属性来对每个表单元素分别指定不同的提交页面，也可以用 <code>formmethod</code>对每个表单元素分别指定不同的提交方式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"testform"</span> <span class="attr">action</span>=<span class="string">"serve.jsp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"s1"</span> <span class="attr">value</span>=<span class="string">"v1"</span> <span class="attr">formaction</span>=<span class="string">"s1.jsp"</span> <span class="attr">formmethod</span>=<span class="string">"get"</span>&gt;</span>提交到 s1</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"s2"</span> <span class="attr">value</span>=<span class="string">"v2"</span> <span class="attr">formaction</span>=<span class="string">"s2.jsp"</span> <span class="attr">formmethod</span>=<span class="string">"post"</span>&gt;</span>提交到 s2</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>目前没有浏览器支持这一属性</p><p><code>placeholder</code></p><p>是指文本框为输入状态时，文本框里面显示的输入提示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"input me"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>autofocus</code></p><p>给文本框、选择框或者按钮控件加上该属性，当画面打开的时候，该控件自动获得光标焦点。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">autofocus</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一个页面只能有一个控件具有该属性。不要滥用，建议只有当一个页面是以使用某个控件为主要目的的时候才使用。例如搜索页面中的搜索文本框。</p><p><code>list</code></p><p>为单行文本框添加一个 <code>list</code>属性，它的值为某个 <code>datalist</code>元素的 id。类似于 <code>select</code>，不同的是它除了可以选择之外，还可以自己输入。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">list</span>=<span class="string">"cars"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"cars"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"BMW"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Ford"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Volvo"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>autocomplete</code></p><p>辅助输入所用的自动完成功能，是一个节省输入时间，同时也非常方便的功能。可以指定 <code>on</code>、<code>off</code>、<code>&quot;&quot;</code>三个值。不指定时用浏览器的默认值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"greeting"</span> <span class="attr">autocomplete</span>=<span class="string">"on"</span> <span class="attr">list</span>=<span class="string">"greetings"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="表单元素种类"><a href="#表单元素种类" class="headerlink" title="表单元素种类"></a>表单元素种类</h3><p><code>url</code>、<code>email</code>、<code>date</code>、<code>time</code>、<code>datetime</code>、<code>datetime-local</code>、<code>month</code>、<code>week</code>、<code>number</code>、<code>range</code>、<code>search</code>、<code>tel</code>、<code>color</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"http://laibh.top"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">value</span>=<span class="string">"544289495@qq.com"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">value</span>=<span class="string">"2019-05-22"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"time"</span> <span class="attr">value</span>=<span class="string">"11:27"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"datetime"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"datetime-local"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"month"</span> <span class="attr">value</span>=<span class="string">"2019-05"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"week"</span> <span class="attr">value</span>=<span class="string">"2019-W21"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">value</span>=<span class="string">"25"</span> <span class="attr">min</span>=<span class="string">"10"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">step</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">value</span>=<span class="string">"25"</span> <span class="attr">min</span>=<span class="string">"10"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">step</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"tel"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"color"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>output</code></p><p>定义了不同类型的输出，比如计算结果或者脚本的输出。output 元素必须从属某个表单，必须将它书写在表单内部，或者对它添加 form 属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"testform1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">name</span>=<span class="string">"range1"</span> <span class="attr">step</span>=<span class="string">"5"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">output</span> <span class="attr">onforminput</span>=<span class="string">"value=range1.value"</span>&gt;</span>50<span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--或者浏览器兼容更好的下面这种方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"testform1"</span> <span class="attr">oninput</span>=<span class="string">"x.value=range1.value"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">name</span>=<span class="string">"range1"</span> <span class="attr">step</span>=<span class="string">"5"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">"x"</span> <span class="attr">for</span>=<span class="string">"range1"</span>&gt;</span>50<span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="http://www.w3school.com.cn/tags/att_output_for.asp">for</a></td><td style="text-align:left"><em>element_id</em></td><td style="text-align:left">定义输出域相关的一个或多个元素。</td></tr><tr><td style="text-align:left"><a href="http://www.w3school.com.cn/tags/att_output_form.asp">form</a></td><td style="text-align:left"><em>form_id</em></td><td style="text-align:left">定义输入字段所属的一个或多个表单。</td></tr><tr><td style="text-align:left"><a href="http://www.w3school.com.cn/tags/att_output_name.asp">name</a></td><td style="text-align:left"><em>name</em></td><td style="text-align:left">定义对象的唯一名称。（表单提交时使用）</td></tr></tbody></table><h3 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h3><p><strong>自动验证</strong></p><p><code>require</code></p><p>可以应用在大部分输入元素（除了隐藏元素，图片按钮上）。在提交时，如果元素中内容为空白，则不允许提交，同时在浏览器中显示信息提示文字。</p><p><code>pattern</code></p><p>要求输入内容格式的，对 <code>input</code>使用 <code>pattern</code>属性，设为某个正则表达式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">pattern</span>=<span class="string">"[0-9][A-Z]&#123;3&#125;"</span> <span class="attr">name</span>=<span class="string">"part"</span> <span class="attr">placeholder</span>=<span class="string">"输入内容；一个数字与三个大写字母"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>min</code> 与 <code>max</code></p><p>数值类型与日期类型元素专用属性。限制了 <code>input</code>元素输入的数值与日期范围。</p><p><code>step</code></p><p>控制 <code>input</code>元素中的值增加或者减少的步幅。</p><p><strong>显式验证</strong></p><p>HTML5 中，<code>form</code> 与 <code>input</code>(除了 <code>select</code> 与 <code>textarea</code>)都具有一个 <code>checkValidity</code>。使用这个方法，可以显示对表单内所有元素内容或者单个元素内容进行有效性验证。返回 boolen值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"textform4"</span> <span class="attr">onsubmit</span>=<span class="string">"return check()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"http://laibh.top"</span> <span class="attr">id</span>=<span class="string">"url"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> url = <span class="built_in">document</span>.getElementById(<span class="string">'url'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (!url.value) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'地址不能为空'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (!url.checkValidity()) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'请输入正确的url地址'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(url.value)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但其实一般提交按钮的时候，会自动检验格式</p><h3 id="取消校验"><a href="#取消校验" class="headerlink" title="取消校验"></a>取消校验</h3><p>有两种方法取消校验，第一种用 <code>form</code>的 <code>novalidate</code>属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"textform4"</span> <span class="attr">onsubmit</span>=<span class="string">"return check()"</span> <span class="attr">novalidate</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"http://laibh.top"</span> <span class="attr">id</span>=<span class="string">"url"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是上述的方法里面的 <code>checkValidity()</code>仍会生效</p><p>第二种是利用 <code>input</code>  或者 <code>submit</code>元素的 <code>formnovalidate</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"textform4"</span> <span class="attr">onsubmit</span>=<span class="string">"return check()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"http://laibh.top"</span> <span class="attr">id</span>=<span class="string">"url"</span> <span class="attr">formnovalidate</span>=<span class="string">"formnovalidate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--或者--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"textform4"</span> <span class="attr">onsubmit</span>=<span class="string">"return check()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"http://laibh.top"</span> <span class="attr">id</span>=<span class="string">"url"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">formnovalidate</span>=<span class="string">"formnovalidate"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前者是单单让一个 <code>input</code>取消验证，后者是取消验证整个 <code>form</code>表单</p><h3 id="自定义错误信息"><a href="#自定义错误信息" class="headerlink" title="自定义错误信息"></a>自定义错误信息</h3><p>HTML5 中可以利用 javascript 调用各个 input 元素的 <code>setCustomValidity</code>方法来自定义错误信息。需要注意的是一旦设置了 <code>setCustomValidity</code>，检验通过的条件变成了 <code>setCustomValidity(&#39;&#39;) &amp;&amp; !valueMissing &amp;&amp; !patternMismatch</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"code"</span> <span class="attr">required</span> <span class="attr">pattern</span>=<span class="string">"^\d&#123;4&#125;$"</span> <span class="attr">placeholder</span>=<span class="string">"请输入代码"</span> <span class="attr">oninput</span>=<span class="string">"check(this)"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">i</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> &#123; valueMissing,patternMismatch &#125; = i.validity;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(valueMissing,patternMismatch)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(valueMissing)&#123;</span></span><br><span class="line"><span class="javascript">            i.setCustomValidity(<span class="string">'该字段不能为空，请按要求填入代码'</span>)</span></span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(patternMismatch)&#123;</span></span><br><span class="line"><span class="javascript">                i.setCustomValidity(<span class="string">'请输入4位数字的代码'</span>)</span></span><br><span class="line"><span class="javascript">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                i.setCustomValidity(<span class="string">''</span>)</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;    </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="增强的页面元素"><a href="#增强的页面元素" class="headerlink" title="增强的页面元素"></a>增强的页面元素</h3><p><code>figure</code>和 <code>figcaption</code></p><p><code>figure</code>是一种元素的组合，带有可选标题。figure 元素用来表示网页上一块独立内容，将其从网页上移除后不会对网页上的其他内容产生任何影响。<code>figure</code>元素所表示的内容可以是图片、统计图或者代码示例。</p><p><code>figcaption</code>表示 <code>figure</code>元素的标题，从属于 <code>figure</code>。一个 <code>figure</code>最多只允许防止一个 <code>figcaption</code>元素，但是运行放置多个其他元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>黄浦江上的的卢浦大桥<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>拍摄者：W3School 项目组，拍摄时间：2010 年 10 月<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.w3school.com.cn/i/shanghai_lupu_bridge.jpg"</span> <span class="attr">width</span>=<span class="string">"350"</span> <span class="attr">height</span>=<span class="string">"234"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>figure</code>所表示的内容通常是图片、统计图或者代码示例，也可以是音频插件、视频插件或者统计表格。</p><p><code>details</code></p><p>提供了一种替代 javascript 的将画面上的局部区域进行展开或者收缩的方法，目前只有 Chrome 和 Safari 6 支持 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">summary</span>&gt;</span>Copyright 2011.<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>All pages and graphics on this web site are the property of W3School.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>mark</code></p><p>表示页面需要高亮或者突出显示的。只好是对网页全文检索某个关键词时显示的检索结果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Do not forget to buy <span class="tag">&lt;<span class="name">mark</span>&gt;</span>milk<span class="tag">&lt;/<span class="name">mark</span>&gt;</span> today.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了某种特殊目的把原文作者没有特别重点标示的内容给标示出来。</p><p>与 <code>em</code> 、<code>strong</code>元素的区别在于前者是作者自己标出来的重点要注意的，而<code>mark</code>跟作者本身没有太多关系，是在后来引用的时候添加上去的。</p><p><code>progress</code></p><p>表示一个任务的完成进度。</p><p>该元素有两个参数来表示当前任务完成情况。<code>value</code>表示完成了多少工作量，<code>max</code>表示总共多少工作量。</p><p>在属性设定的时候，这两个属性只能设定为有效的浮点数，<code>value</code>的值必须大于0，小于等于 <code>max</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>progress 使用示例<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>完成百分比：<span class="tag">&lt;<span class="name">progress</span> <span class="attr">id</span>=<span class="string">"progress"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">value</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span>%<span class="tag">&lt;/<span class="name">progress</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">'add()'</span> <span class="attr">value</span>=<span class="string">"请点击"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> progressBar = <span class="built_in">document</span>.getElementById(<span class="string">'progress'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        progressBar.getElementsByTagName(<span class="string">'span'</span>)[<span class="number">0</span>].textContent = <span class="string">'0'</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">            setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">                progressBar.value = i;</span></span><br><span class="line"><span class="javascript">                progressBar.getElementsByTagName(<span class="string">'span'</span>)[<span class="number">0</span>].textContent = i</span></span><br><span class="line"><span class="undefined">            &#125;, 1000 * i)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>meter</code></p><p>表示规定范围内的数量值。例如磁盘使用量，对于某个候选者的投票人数占总投票人数的比例等。</p><p>meter 元素有六个属性：</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">high</td><td style="text-align:left"><em>number</em></td><td style="text-align:left">定义度量的值位于哪个点，被界定为高的值。</td></tr><tr><td style="text-align:left">low</td><td style="text-align:left"><em>number</em></td><td style="text-align:left">定义度量的值位于哪个点，被界定为低的值。</td></tr><tr><td style="text-align:left">max</td><td style="text-align:left"><em>number</em></td><td style="text-align:left">定义最大值。默认值是 1。</td></tr><tr><td style="text-align:left">min</td><td style="text-align:left"><em>number</em></td><td style="text-align:left">定义最小值。默认值是 0。</td></tr><tr><td style="text-align:left">optimum</td><td style="text-align:left"><em>number</em></td><td style="text-align:left">定义什么样的度量值是最佳的值。如果该值高于 “high” 属性，则意味着值越高越好。如果该值低于 “low” 属性的值，则意味着值越低越好。</td></tr><tr><td style="text-align:left">value</td><td style="text-align:left"><em>number</em></td><td style="text-align:left">定义度量的值。</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meter</span> <span class="attr">value</span>=<span class="string">"5"</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"10"</span> <span class="attr">high</span>=<span class="string">"8"</span> <span class="attr">low</span>=<span class="string">"2"</span> <span class="attr">optimum</span>=<span class="string">"5"</span>&gt;</span>3/10<span class="tag">&lt;/<span class="name">meter</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meter</span> <span class="attr">value</span>=<span class="string">"0.6"</span>&gt;</span>60%<span class="tag">&lt;/<span class="name">meter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>注释：<span class="tag">&lt;/<span class="name">b</span>&gt;</span>Internet Explorer 不支持 meter 标签。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>menu</code>与 <code>command</code></p><p>用于菜单工具条与弹出菜单。两个元素的浏览器支持不是很好，不做介绍。</p><p><code>ol</code></p><p>增加了 <code>start</code>与 <code>reversed</code>属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">reversed</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>咖啡<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>牛奶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>茶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">start</span>=<span class="string">"50"</span> <span class="attr">reversed</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>咖啡<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>牛奶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>茶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>dl</code></p><p>重新定义后的 <code>dl</code>列表包含多个带名字的列表项。每一项包含一条或者多条带名字的 <code>dt</code>元素，用来表示术语，<code>dt</code>元素后面紧跟一个或者多个 <code>dd</code>元素，用来表示定义。在一个元素内，不允许带有相同的 <code>dt</code>元素，不允许有重复的术语。<code>dl</code>可以用来定义文章或者网页上的术语解释</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>Black hot drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>White cold drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>cite</code></p><p>标签定义作品（比如书籍、歌曲、电影、电视节目、绘画、雕塑等等）的标题。不能是人名</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/i/ct_fcsz.jpg"</span> <span class="attr">alt</span>=<span class="string">"富春山居图"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cite</span>&gt;</span>《富春山居图》<span class="tag">&lt;/<span class="name">cite</span>&gt;</span>由黄公望始画于至正七年(1347)，于至正十年完成。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>small</code></p><p>由原来的通用展示性元素变成更具体的、专门用来标识所谓的”小字印刷体”的元素。通常用于免责声明、注意事项、法律法规、与版权相关等的法律性声明文字中，同时不允许被应用在页面主内容中，只允许被当做辅助信息用 <code>inline</code>方式内嵌在页面上使用。同时 <code>small</code>元素也不意味着元素中内容字体会变小，如果需要将字体变小，需要配合  CSS 样式来用。</p><h3 id="文件-API"><a href="#文件-API" class="headerlink" title="文件 API"></a>文件 API</h3><p>HTML5 中提供了一个关于文件操作的文件 API.</p><h4 id="FileList-对象与-file-对象"><a href="#FileList-对象与-file-对象" class="headerlink" title="FileList 对象与 file 对象"></a>FileList 对象与 file 对象</h4><p><code>FileList</code> 对象表示用户选择的文件列表。在 HTML4 中，<code>file</code> 控件只允许放置一个文件，到了 HTML5 中。通过添加 <code>multiple</code>属性，<code>file</code>控件允许一次放置多个文件。控件内的每一个用户选择的文件都是一个 <code>file</code>对象，而 <code>FileList</code>对象则为这些 <code>file</code>对象的列表，代表用户选择的所有文件。 <code>file</code>对象有两个属性，<code>name</code>属性表示文件名，不包括路径，<code>lastModifiedDate</code>属性表示文件的最后修改日期。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span> <span class="attr">multiple</span> <span class="attr">size</span>=<span class="string">"80"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"showFileName()"</span> <span class="attr">value</span>=<span class="string">"文件上传"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">showFileName</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> file;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> files = <span class="built_in">document</span>.getElementById(<span class="string">'file'</span>).files;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> len = files.length;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="undefined">            file = files[i]</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(file.name);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Blob对象"><a href="#Blob对象" class="headerlink" title="Blob对象"></a>Blob对象</h4><p>Blob 表示二进制原始数据，它提供一个 <code>slice</code>方法，可以通过该方法访问到字节内部数据块。事实上，上面的 <code>file</code>对象也继承了这个 Blob 对象。</p><p>Blob 对象有两个属性，<code>size</code>属性表示一个 Blob 对象的字节长度，<code>type</code> 属性表示 Blob 的 MIME 类型，如果是未知类型的话，返回一个空字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showFileName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> file;</span><br><span class="line">    <span class="keyword">const</span> files = <span class="built_in">document</span>.getElementById(<span class="string">'file'</span>).files;</span><br><span class="line">    <span class="keyword">const</span> len = files.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        file = files[i]</span><br><span class="line">       <span class="built_in">console</span>.log(file.name + <span class="string">'==='</span> + file.size + <span class="string">'==='</span> + file.type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对 <code>file.size</code>或者 <code>file.type</code>判断可以进行文件大小与文件类型的限制。另外 HTML5 已经对 <code>file</code>控件添加了 <code>accept</code>属性，企图让 <code>file</code>控件只能接受某种类型的文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span> <span class="attr">multiple</span> <span class="attr">size</span>=<span class="string">"80"</span> <span class="attr">accept</span>=<span class="string">"image/gif"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样打开文件的时候就会显示 gif结尾的文件，当然如果你强行传其他类型的也是没有报错的。所以如果要做限制上传文件类型的话要结合 <code>file.type</code>来实现。</p><h4 id="FileReader接口"><a href="#FileReader接口" class="headerlink" title="FileReader接口"></a>FileReader接口</h4><p>主要用来把文件读入内存，并且读取文件中的数据。FileReader 接口有了一个异步 API,使用该 API可以在浏览器主线程中异步访问文件系统，读取文件中的数据。</p><p>检查是否可以使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="keyword">typeof</span> FileReader)&#123;</span><br><span class="line">    <span class="comment">// 浏览器为实现 FileReader 接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口方法</strong></p><p>这个接口拥有4个方法，其中三个用来读取文件，另一个用来读取过程中断</p><table><thead><tr><th>方法名</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>readAsBinaryString</td><td>file</td><td>将文件读取为二进制码</td></tr><tr><td>readAsText</td><td>file,[encoding]</td><td>将文件读取为文本</td></tr><tr><td>readAsDataURL</td><td>file</td><td>将文件读取为 DataURL</td></tr><tr><td>abort</td><td>（none）</td><td>中断读取操作</td></tr></tbody></table><ul><li>readAsBinaryString,这个方法将文件读取为二进制字符串，通常我们把它传送到后端，后端可以通过这段字符串存储文件。</li><li>readAsText,有两个参数，第二个参数是文本的编码方式，默认值为 <code>UTF-8</code>。将文件以文本方式读取，读取的结果是这个文本文件中的内容。</li><li>readAsDateURL,该方法将文件读取为一串 Data URL字符串，该方法事实上是将小文件以一种特殊格式的URL 地址形式直接读入页面。这里的小文件通常是图像与 html 格式的文件。</li></ul><p><strong>接口的事件</strong></p><p>除了上面打方法，FileReader 接口还包含了一套完整的事件模型，用于捕获读取文件时的状态。</p><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>onabort</td><td>数据读取中断时触发</td></tr><tr><td>onerror</td><td>数据读取出错时触发</td></tr><tr><td>onloadstart</td><td>数据取数开始时触发</td></tr><tr><td>onprogress</td><td>数据读取中</td></tr><tr><td>onload</td><td>数据读取成功完成时触发</td></tr><tr><td>onloadend</td><td>数据读取完成时触发，无论成功或者失败</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"file"</span>&gt;</span>请选择一个文件<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"readAsDataURL()"</span> <span class="attr">value</span>=<span class="string">"读取图像"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"readAsBinaryString()"</span> <span class="attr">value</span>=<span class="string">"读取二进制数据"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"readAsText()"</span> <span class="attr">value</span>=<span class="string">"读取文本数据"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">name</span>=<span class="string">"result"</span> <span class="attr">id</span>=<span class="string">"result"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> result = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> file = <span class="built_in">document</span>.getElementById(<span class="string">'file'</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (!<span class="keyword">typeof</span> FileReader) &#123;</span></span><br><span class="line"><span class="javascript">  alert(<span class="string">'浏览器不支持 FileReader 接口'</span>)</span></span><br><span class="line"><span class="javascript">  file.setAttribute(<span class="string">'disabled'</span>, <span class="string">'disabled'</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">readAsDataURL</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 检查文件是否为图像</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> &#123; files &#125; = file;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> len = files.length;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!<span class="regexp">/image\/\w+/</span>.test(files[i].type)) &#123;</span></span><br><span class="line"><span class="javascript">      alert(<span class="string">'请确保文件都为图像类型'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将文件以 Data URL 形式读入页面</span></span></span><br><span class="line"><span class="undefined">    reader.readAsDataURL(files[i])</span></span><br><span class="line"><span class="javascript">    reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span></span><br><span class="line"><span class="javascript">      img.src = <span class="keyword">this</span>.result</span></span><br><span class="line"><span class="undefined">      result.appendChild(img)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 将文件以二进制的形式读入页面</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">readAsBinaryString</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 检查文件是否为图像</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> &#123; files &#125; = file;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> len = files.length;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!<span class="regexp">/image\/\w+/</span>.test(files[i].type)) &#123;</span></span><br><span class="line"><span class="javascript">      alert(<span class="string">'请确保文件都为图像类型'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将文件以 二进制形式读入页面</span></span></span><br><span class="line"><span class="undefined">    reader.readAsBinaryString(files[i])</span></span><br><span class="line"><span class="javascript">    reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>)</span></span><br><span class="line"><span class="javascript">      p.innerHTML += <span class="keyword">this</span>.result</span></span><br><span class="line"><span class="undefined">      result.appendChild(p)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 将文件以文本形式读入页面</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">readAsText</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 检查文件是否为图像</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> &#123; files &#125; = file;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> len = files.length;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!<span class="regexp">/image\/\w+/</span>.test(files[i].type)) &#123;</span></span><br><span class="line"><span class="javascript">      alert(<span class="string">'请确保文件都为图像类型'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将文件以 二进制形式读入页面</span></span></span><br><span class="line"><span class="undefined">    reader.readAsText(files[i])</span></span><br><span class="line"><span class="javascript">    reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>)</span></span><br><span class="line"><span class="javascript">      p.innerHTML += <span class="keyword">this</span>.result</span></span><br><span class="line"><span class="undefined">      result.appendChild(p)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于读取状态的先后顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readAsDataURL</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 检查文件是否为图像</span></span><br><span class="line">  <span class="keyword">const</span> &#123; files &#125; = file;</span><br><span class="line">  <span class="keyword">const</span> len = files.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/image\/\w+/</span>.test(files[i].type)) &#123;</span><br><span class="line">      alert(<span class="string">'请确保文件都为图像类型'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    <span class="comment">// 将文件以 Data URL 形式读入页面</span></span><br><span class="line">    reader.readAsDataURL(files[i])</span><br><span class="line">    reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">      img.src = <span class="keyword">this</span>.result</span><br><span class="line">      result.appendChild(img)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'load'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    reader.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'progress'</span>);&#125;</span><br><span class="line">    reader.onabort = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'abort'</span>);&#125;</span><br><span class="line">    reader.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'error'</span>);&#125;</span><br><span class="line">    reader.onloadstart = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'loadstart'</span>);&#125;</span><br><span class="line">    reader.onloadend = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'loadend'</span>);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// loadstart</span></span><br><span class="line"><span class="comment">// progress</span></span><br><span class="line"><span class="comment">// load</span></span><br><span class="line"><span class="comment">// loadend</span></span><br></pre></td></tr></table></figure><p>在 <code>onprogress</code>里面可以用 <code>progress</code>来显示文件读取的百分比。</p><h4 id="拖放-API"><a href="#拖放-API" class="headerlink" title="拖放 API"></a>拖放 API</h4><p>虽然在 HTML5 之前已经可以使用 <code>mousedown</code>、<code>mousemove</code>、<code>mouseup</code>来实现拖放操作，但是这只是在浏览器内容的拖放。在 HTML5 中，支持在浏览器与其他应用程序之间的数据互相拖动，同时也大大简化了拖放方面的代码。</p><h5 id="实现拖放的步骤"><a href="#实现拖放的步骤" class="headerlink" title="实现拖放的步骤"></a>实现拖放的步骤</h5><ol><li>将想要拖放的对象元素的 <code>draggable</code>属性设为 <code>true</code>，这样才能将该元素进行拖放。另外，img元素与 a 元素默认运行拖放。</li><li>编写与拖放有关的代码。</li></ol><h5 id="拖放的相关事件"><a href="#拖放的相关事件" class="headerlink" title="拖放的相关事件"></a>拖放的相关事件</h5><table><thead><tr><th>事件</th><th>产生事件的元素</th><th>描述</th></tr></thead><tbody><tr><td>drastart</td><td>被拖放的元素</td><td>开始施放操作</td></tr><tr><td>drag</td><td>被拖放的元素</td><td>拖放过程中</td></tr><tr><td>dragenter</td><td>拖放过程中鼠标经过的元素</td><td>被拖放的元素开始进入本元素的范围</td></tr><tr><td>dragover</td><td>拖放过程中鼠标经过的元素</td><td>被拖放的元素正在本元素范围内移动</td></tr><tr><td>dragleave</td><td>拖放过程中鼠标经过的元素</td><td>被拖放的元素离开本元素的范围</td></tr><tr><td>drop</td><td>拖放的目标元素</td><td>有其他元素被拖放到了本元素中</td></tr><tr><td>dragend</td><td>拖放的对象元素</td><td>拖放操作结束</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"init()"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>简单拖放示例<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"dragme"</span> <span class="attr">draggable</span>=<span class="string">"true"</span> <span class="attr">style</span>=<span class="string">"width:200px;border:1px solid gray"</span>&gt;</span></span><br><span class="line">    请拖放</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"text"</span> <span class="attr">style</span>=<span class="string">"width:200px;height:200px;border:1px solid gray"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> source = <span class="built_in">document</span>.getElementById(<span class="string">'dragme'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> dest = <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>);</span></span><br><span class="line"><span class="javascript">      source.addEventListener(<span class="string">'dragstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> dt = ev.dataTransfer;</span></span><br><span class="line"><span class="javascript">        dt.effectAllowed = <span class="string">'all'</span>;</span></span><br><span class="line"><span class="javascript">        dt.setData(<span class="string">'text/plain'</span>, <span class="string">'你好'</span>)</span></span><br><span class="line"><span class="javascript">      &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      dest.addEventListener(<span class="string">'dragend'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 不执行默认处理（拒绝被拖放）</span></span></span><br><span class="line"><span class="undefined">        ev.preventDefault();</span></span><br><span class="line"><span class="undefined">      &#125;);</span></span><br><span class="line"><span class="javascript">      dest.addEventListener(<span class="string">'drop'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> dt = ev.dataTransfer;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> text = dt.getData(<span class="string">'text/plain'</span>);</span></span><br><span class="line"><span class="undefined">        dest.textContent += text;</span></span><br><span class="line"><span class="undefined">        ev.preventDefault();</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 禁止事件传播</span></span></span><br><span class="line"><span class="undefined">        ev.stopPropagation();</span></span><br><span class="line"><span class="javascript">      &#125;, <span class="literal">false</span>)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 页面设置属性，不执行默认处理(拒绝被拖放)</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.ondragover = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; e.preventDefault() &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.ondrop = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; e.preventDefault() &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>开始拖动（<code>dragstart</code>事件发生）时，将要拖动的数据存入 <code>DataTransfer</code>对象（<code>setData()方法</code>）。<code>DataTransfer</code>对象专门用来存放拖放时要携带的数据，它可以被设置为拖动事件对象的 <code>dataTransfer</code>属性。<code>setData</code>方法中的第一个参数为携带数据的数据种类的字符串，第二个参数为要修改的数据。第一个参数中表示数据种类的字符串里只能填入类似 <code>text/plain</code>或者<code>text/html</code>的表示 MIME 类型的文字，不能填入其他文字。</li><li>如果把<code>dt.setData(&quot;text/plain&quot;,&quot;你好&quot;)</code>改成 <code>dt.setData(&quot;text/plain&quot;,this.id)</code>。因为把被拖动元素的 id 当成了参数，所以携带的数据就是被拖动元素中的数据了，因为浏览器在使用 <code>getData()</code>方法读取数据时会自动读取该元素中的数据。</li><li>针对拖放的目标元素，必须在 <code>dragend</code>或者 <code>dragover</code>事件内调用事件对象的 <code>preventDefault()</code>方法。因为默认情况下，被拖放的目标元素不允许接受元素的，为了把元素拖放到其中，必须把默认处理给关闭掉。</li><li>目标元素接受到被拖放的元素后，执行 <code>getData</code>方法从 <code>DataTransfer</code>获得数据。<code>getData</code>方法的参数为 <code>setData</code>方法中指定的数据种类</li><li>要实现拖放过程，还必须在目标元素的 <code>drop</code>事件中关闭默认处理（拒绝被拖放），否则目标元素不能接受被拖放的元素</li><li>实现拖放过程，还必须设定整个页面为不执行默认处理（拒绝被拖放），否则拖放处理也不能被实现。因为页面是先于其他元素接受拖放的，如果页面上拒绝拖放，那么页面上其他元素就都不能接受拖放</li><li>要使元素可以被拖放，首先必须把该元素的 <code>draggable</code>属性设为 <code>true</code>，另外，为了让这个示例在所有支持拖放 API 的浏览器中都能正常运行，需要指定 <code>-webkit-user-drag:element</code>这种 Webkit 特有的 CSS 属性</li></ul><p>现在支持拖放处理的 MIME 类型主要有一下几种：</p><ul><li>text/plain:文本文字</li><li>text/html：HTML文字</li><li>text/xml：xml 文字</li><li>text/uri-list：URL 列表，每个 URL 为一行</li></ul><h5 id="DataTransfer-对象的属性与方法"><a href="#DataTransfer-对象的属性与方法" class="headerlink" title="DataTransfer 对象的属性与方法"></a>DataTransfer 对象的属性与方法</h5><table><thead><tr><th>属性/方法</th><th>描述</th></tr></thead><tbody><tr><td>dropEffect属性</td><td>表示拖放操作的视觉效果，运行对其进行值的设定。该效果必须用 <code>effectAllowed</code>属性置顶的允许的效果范围内。允许指定的值为 none、copy、move、link</td></tr><tr><td>effectAllowed属性</td><td>用来指定当元素被拖放时所运行的视觉效果，可以指定的值为none、copy、copyLink、copyMove、link、linkMove、move、all、unintialize</td></tr><tr><td>types属性</td><td>存入数据的种类，字符串的伪数组</td></tr><tr><td>void clearData(DOMString format)方法</td><td>清除 DataTransfer 对象中存放的数据，如果省略参数 format,则清除全部数据</td></tr><tr><td>void setData(DOMString format、DOMString data)</td><td>向 DataTransfer 对象内存入数据</td></tr><tr><td>DOMString getData(DOMString format)</td><td>从 DataTransfer 对象中读数据</td></tr><tr><td>void setDragImage(Element image,long x,long y)</td><td>用 img 元素来设置拖放图标（部分浏览器可以用 canvas 等其他元素来设置）</td></tr></tbody></table><h5 id="设定拖放时的视觉效果"><a href="#设定拖放时的视觉效果" class="headerlink" title="设定拖放时的视觉效果"></a>设定拖放时的视觉效果</h5><p><code>dropEffect</code>与 <code>effectAllowed</code>属性结合起来可以设定拖放时的视觉效果。<code>effectAllowed</code>属性表示当一个元素被拖动时所运行的视觉效果，一般在 <code>ondragstart</code>事件中设定，运行使用的值为 none、copy、copyLink、copyMove、link、move、all、unintialize。</p><p><code>dropEffect</code>属性表示实际拖放时的视觉效果，一般在 <code>ondragover</code>事件中指定，运行设定的值为 none、copy、link、move。<code>dropEffect</code>属性所表示的实际视觉效果必须在 <code>effectAllowed</code>属性所表示的允许的视觉效果范围内。规则如下：</p><ol><li>如果 <code>effectAllowed</code>属性被设为 <code>none</code>，则不允许拖放元素。</li><li>如果 <code>dropEffect</code>属性设定为 <code>none</code>，则不允许被拖放到目标元素中</li><li><code>effectAllowed</code>属性设定为 <code>all</code>或者不设定，则 <code>dropEffect</code>属性允许被设定为任何值，并按照指定的视觉效果进行显示</li><li>如果 <code>effectAllowed</code>属性设定为具体效果（不为 none或者 all），<code>dropEffect</code>属性也设定了具体视觉效果，则两个具体效果值必须完全相等，否则不允许被拖放元素拖放到目标元素中。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">source.addEventListener(<span class="string">'dragstart'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dt = ev.dataTransfer;</span><br><span class="line">    dt.effectAllowed = <span class="string">'copy'</span>;</span><br><span class="line">    dt.setData(<span class="string">"text/plain"</span>,<span class="string">"你好"</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">dest.addEventListener(<span class="string">'dragover'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dt = ev.dataTransfer;</span><br><span class="line">    dt.dropEffect = <span class="string">'copy'</span>;</span><br><span class="line">    ev.preventDefault();</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h5 id="自定义拖放图标"><a href="#自定义拖放图标" class="headerlink" title="自定义拖放图标"></a>自定义拖放图标</h5><p>除了上面所说的使用 <code>effectAllowed</code>属性与<code>dropEffect</code>属性外，HTML5 还允许自定义拖放图标——指的是在用鼠标拖动元素的过程中，位于鼠标指针下部的小图标。</p><p><code>setDragImage</code>方法有三个惨呼，第一个参数 image 设定为拖放图标的图标元素，第二个参数 x 为拖放图标离鼠标指针x轴方向的位移量，第三个参数 y 为拖放图标距离鼠标指针的 y 轴方向的位移量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dragIcon.src = <span class="string">'http://laibh.top/images/favicon-32x32-next.png?v=5.1.4'</span>;</span><br><span class="line">source.addEventListener(<span class="string">'dragstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> dt = ev.dataTransfer;</span><br><span class="line"><span class="built_in">console</span>.log(ev)</span><br><span class="line"><span class="built_in">console</span>.log(dt)</span><br><span class="line">dt.effectAllowed = <span class="string">'all'</span>;</span><br><span class="line">dt.setDragImage(dragIcon, <span class="number">-10</span>, <span class="number">-10</span>)</span><br><span class="line">dt.setData(<span class="string">'text/plain'</span>, <span class="string">'你好'</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习链接：&lt;br&gt;&lt;a href=&quot;https://read.douban.com/ebook/15160963/&quot;&gt;HTML 5与CSS 3权威指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.w3cschool.cn/html/&quot;&gt;W3cScholl
      
    
    </summary>
    
      <category term="前端面试" scheme="http://laibh.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="HTML5" scheme="http://laibh.top/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题目汇总摘录（React 基础篇）</title>
    <link href="http://laibh.top/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E6%91%98%E5%BD%95-React%20%E5%9F%BA%E7%A1%80%E7%AF%87.html"/>
    <id>http://laibh.top/前端面试题目汇总摘录-React 基础篇.html</id>
    <published>2019-05-13T02:30:54.000Z</published>
    <updated>2022-03-04T10:00:38.468Z</updated>
    
    <content type="html"><![CDATA[<p>温故而知新，保持空杯心态</p><h2 id="React-基础"><a href="#React-基础" class="headerlink" title="React  基础"></a>React  基础</h2><h3 id="什么是-React"><a href="#什么是-React" class="headerlink" title="什么是 React?"></a>什么是 React?</h3><p>是一个用于构建用户界面的 javaScript 库，主要用于构建 UI,很多人认为是 MVC 中的 View 层</p><p>特点：</p><ul><li>声明式设计 – 采用声明范式，可以轻松描述应用</li><li>高效 – 通过对 DOM 的模拟，最大限度地减少与 DOM 的交互</li><li>灵活 –  React 可以与很多库或者框架很好地配合</li><li>JSX – JSX 是 javascript 语法的扩展</li><li>组件 – 通过 React 构建的组件，使得代码更加容易得到，很好的应用在大项目的开发中</li><li>单向响应的数据流 – 减少了重复代码</li></ul><h3 id="React的渲染机制"><a href="#React的渲染机制" class="headerlink" title="React的渲染机制"></a>React的渲染机制</h3><h4 id="React-渲染过程"><a href="#React-渲染过程" class="headerlink" title="React 渲染过程"></a>React 渲染过程</h4><p>页面打开的时候，React 会调用 render 函数来构建一颗 DOM 树，在 <code>state/props</code>改变的时候， render 函数会再次调用渲染出来另外一颗树，接着， React 会对两棵树进行对比，找出需要更新的地方进行批量改动</p><h4 id="Diff-算法"><a href="#Diff-算法" class="headerlink" title="Diff 算法"></a>Diff 算法</h4><p><strong>作用</strong></p><p>计算出 Virtual DOM 中真正变化的部分，并只针对该部分进行原生 DOM 操作，而非重新渲染整个页面。</p><p><strong>传统 diff 算法的劣处</strong></p><p>通过循环递归节点进行依次对比，算法复杂度达到 <code>O(n^3)</code>，n 是树的节点数。假设展示1000个节点，得执行上亿次比较。CPU 无法进行在很短的时间内计算出差异</p><p><strong>React 的 diff 算法</strong></p><p>将 Virtual DOM 树转换成为 Actual DOM 树的最少操作过程被称为调和。React  的 diff 算法就是调和的具体实现。</p><p><strong>React 的diff 策略</strong></p><p>React 用三大策略将 <code>O(n^3)</code>复杂都转换为 <code>O(n)</code>复杂度</p><p>策略1（tree diff）:</p><p>Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计</p><p>策略2（component diff）:</p><p>拥有相同类的两个组件生成相似的树形结构</p><p>拥有不同类的两个组件生成不同的树形结构</p><p>策略三（element diff）:</p><p>对于同一层级的一组子节点，通过唯一的 id 区分</p><p><strong>diff 策略详解</strong></p><p><em>Tree diff</em></p><ol><li>React 通过 updateDepth 对 Virtual DOM 树进行层级控制</li><li>对树分层比较，两棵树只对同一层次节点进行比较，如果该节点不存在时，则该节点以及其节点会被完全删除，不会再进行进一步比较</li><li>只要遍历一次，就能完成整颗 DOM 的比较</li><li>如果 DOM 出现了跨层操作，diff 只会简单考虑同层级的节点位置变化，如果是跨层的话，只有创建和删除节点的操作。因此也不建议进行跨 DOM 操作，可以通过 CSS 隐藏、显示节点，而不是真正地移除，添加 DOM 节点</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">updateChildren:<span class="function"><span class="keyword">function</span>(<span class="params">nextNestedChildrenElements,transaction,context</span>)</span>&#123;</span><br><span class="line">    updateDepth++;</span><br><span class="line">    <span class="keyword">var</span> errorThrow = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._updateChildren(nextNestedChildrenElements,transaction,context)</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        updateDepth--;</span><br><span class="line">        <span class="keyword">if</span>(updateDepth)&#123;</span><br><span class="line">            <span class="keyword">if</span>(errorThrow)&#123;</span><br><span class="line">            clearQueue();   </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                processQueue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Component diff</em></p><ol><li>同一类型的两个组件，按原策略（层级比较）继续比较 Virtual DOM 树即可</li><li>同一类型的两个组件，组件 A 变化为 组件 B时，可能 Virtual DOM 没有任何改变，如果知道这一点，可节省大量计算时间。用户可以通过 <code>shouldComponentUpdate()</code> 来判断是否需要判断计算</li><li>不同类型的组件，将一个（将被改变的）组件判断为 <code>dirty component(脏组件)</code>，从而替换整个组件的所有节点。</li></ol><p>注意：如果组件 A 和 组件 B 的结构相似，但是 React 判断是不同类型的组件，则不会比较其结构，而是删除 组件 A 以及其子节点，创建组件 B 以其子节点。</p><p><em>Element diff</em></p><p>当节点处于同一层级时，diff 提供三个节点操作：删除、插入、移动</p><p>插入：组件 C 不在集合 （AB）中,需要插入</p><p>删除：组件 D 在集合 （ABD）中，但是集合变成（AB）,D就需要被删除</p><p>移动：组件 D 已经在集合（ABCD）中，且集合更新时，D 没有发生更新，只是位置的改变，如新的集合（ADBC）。D 在第二个，无须像传统的 diff,让旧集合的第二个 B 和新集合的比较，并且删除第二个位置的 B，再在第二个位置插入 D 。需要做的是（对同一层级的同组子节点）添加唯一的 key 进行区分，移动即可。</p><p><strong>移动逻辑详解</strong></p><p>情形一：新旧集合中存在相同节点但是位置不同时，如何移动节点</p><p><img src="/images/前端面试题目汇总摘录-React 基础篇-react-diff移动1.png" alt="react-diff移动1"></p><p><code>lastIndex</code>有点像浮标，或者一个 map 的索引，默认值是 0，会与 map 中的元素进行比较后改变自己的值（取 <code>index</code>和 <code>lastIndex</code>中的较大值）</p><ol><li>B，React 在新中取得 ,判断旧中是否存在相同的节点B,发现节点B后判断是否需要移动B。<ol><li>B 在旧中 <code>index = 1</code>,它 的 <code>lastIndex = 0</code></li><li>不满足 <code>lastIndex &gt; index</code>，无需移动操作。</li><li><code>lastindex = Math.max(lastindex,index) = 1</code> </li></ol></li><li>A，A在旧的 <code>index=0</code>,此时 <code>lastIndex=1</code>。满足 <code>lastIndex &gt; index</code>，对 A 进行移动到 <code>lastIndex=1</code>。接着操作 <code>lastIndex=Math.max(lastIndex,index)</code>还是等于1</li><li>D，同 1，不移动，由于旧的D <code>index=3</code>,<code>lastIndex=1</code>，改 <code>lastIndex=Math.max(lastIndex,index)=3</code></li><li>C,同 2，移动。C在旧的 <code>index=2</code>,满足<code>lastIndex(3)&gt;index</code>，移动</li><li>由于 C 已经是最后一个节点了，所以 diff 操作结束</li></ol><p>情形二：新集合中有新加入的节点，旧集合中有删除的节点</p><p><img src="/images/前端面试题目汇总摘录-React 基础篇-react-diff移动2.png" alt="react-diff移动2"></p><ol><li>B,同上理，不移动，更新 <code>lastIndex=1</code></li><li>E,旧集合中没有，在 <code>lastIndex=1</code>上创建E，更新 <code>lastIndex=1</code></li><li>C，C在旧集合中 <code>index=2</code>,不满足<code>lastIndex&gt;index</code>，不移动，更新 <code>lastIndex=Math.max(lastIndex,index)=2</code></li><li>A，旧集合中 <code>index=0</code>，符合 <code>lastIndex&gt;index</code>，移动，<code>lastIndex还是等于 2</code></li><li>新旧集合对比后，再对旧集合遍历。判断新集合中没有，但是旧集合有的元素D，删除 D，diff 操作结束</li></ol><p><strong>diff 的不足之处与待优化的地方</strong></p><p>情形三：将最后一个元素移动到最前面</p><p><img src="/images/前端面试题目汇总摘录-React 基础篇-react-diff移动3.png" alt="react-diff移动3"></p><p>D,此时D 不移动，但是因为它的 index 最大的，导致 <code>lastIndex=3</code>，从而使得其他元素的 <code>index &lt; lastIndex</code>，导致都要去移动。</p><p>理想的情况是值移动D,不移动 ABC.因此在开发中，应该尽量减少将最后一个节点移动到列表的首部，当节点数量过大或者操作更新过于频繁的时候，会影响到 React 的渲染性能。</p><h3 id="React-JSX"><a href="#React-JSX" class="headerlink" title="React JSX"></a>React JSX</h3><p>React 使用 JSX 来替代常规的 javascript,有几个优点：</p><ul><li>执行更快，在编译为 javascript 代码后进行了优化</li><li>类型安全，在编译过程中就能发现错误</li><li>使用 JSX 编写模板简单快速</li></ul><p>在 React 应用中，元素是构成 React 的最小单位，JSX 就是用来声明 React 当中的元素。</p><p>与浏览器的 DOM 元素不同，React 当中的元素是普通的对象，ReactDOM 可以确保浏览器的数据内容与 React 元素一致。通过 <code>ReactDOM.render</code>将元素渲染到 DOM 节点上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"foo "</span> /&gt;</span></span></span><br><span class="line">ReactDOM.render(&lt;App&gt;,document.getElementById('root'))</span><br></pre></td></tr></table></figure><p><strong>原理</strong></p><p>如何用 JavaScript 元素来表示一个 DOM 元素的结构:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">        Hello</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>Click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一个 DOM 元素包含的信息其实只有三个：标签、属性，子元素，所以上面的内容可以表示为</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    tag:'div',</span><br><span class="line">    attrs:&#123;className:'box',id:'content'&#125;,</span><br><span class="line">    children:[&#123;</span><br><span class="line">        tag:'div',</span><br><span class="line">        attrs&#123;className:'title'&#125;,</span><br><span class="line">        children:['Hello']</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        tag:'button',</span><br><span class="line">        attrs:null,</span><br><span class="line">        children:['Click']</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 javaScript 有个缺点就是内容太长，结构不够清晰，用 HTML 的方式会方便很多。而 React 把 javascript 扩展了一下，让 javascript 能够支持直接在 javascript 代码中编写类似 HTML 标签结构的语法。编译的过程中会把类似 HTML 的 JSX 结构转换成为 javascript 的对象结构。例如下面的代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'/index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1 className=<span class="string">'title'</span>&gt;React JSX&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;MyComponent /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElememtById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>经过编译后：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'/index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            React.createElement(</span><br><span class="line">                <span class="string">'div'</span>,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                React.createElement(</span><br><span class="line">                <span class="string">'h1'</span>,</span><br><span class="line">                &#123;<span class="attr">className</span>:<span class="string">'title'</span>&#125;,</span><br><span class="line">                <span class="string">"React JSX"</span></span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    React.createElement(MyComponent,<span class="literal">null</span>)</span><br><span class="line">    <span class="built_in">document</span>.getElememtById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>React.createElement</code> 会构建一个 JavaScript 对象来描述 HTML 结构的信息，包括标签名，属性，还有子元素等等。</p><p><strong>所谓的JSX 其实就是 JavaScript 对象</strong></p><p><code>React.render</code>功能就是把组件渲染并且构造 DOM 树，然后插入到页面上特定的元素上。</p><p>总结过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Babel 编译 +   </span><br><span class="line">React.js 构造           ReactDOM.render</span><br><span class="line">JSX -----&gt; JavaScript 对象结构 -----&gt; DOM 元素 -----&gt; 插入页面</span><br></pre></td></tr></table></figure><h3 id="React-生命周期函数"><a href="#React-生命周期函数" class="headerlink" title="React 生命周期函数"></a>React 生命周期函数</h3><h4 id="React-v16-0-前的生命周期"><a href="#React-v16-0-前的生命周期" class="headerlink" title="React v16.0 前的生命周期"></a>React v16.0 前的生命周期</h4><p>分成四个阶段 Initialization、Mounting、Updation、Unmounting</p><h4 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a><strong>Initialization</strong></h4><p>setup props and states</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test 类继承 react 的基本类，拥有了 render ，生命周期等等方法可以使用。</p><p><code>super(props)</code>，用来调用基类的构造方法（constructor()），将父组件中的props 注入给子组件，供其读取。</p><p>使用ES6 classes构建组件的时候<strong>static defaultProps={}</strong>其实就是调用内部的<strong>getDefaultProps</strong>方法。</p><p><code>constructor</code>可以做一些组件初始化的功能，例如初始化 <code>state</code>,就是调用内部的 <code>getIntialState</code>方法</p><h4 id="Mounting"><a href="#Mounting" class="headerlink" title="Mounting"></a><strong>Mounting</strong></h4><p>getDefaultProps =&gt; getInitialState =&gt; componentWillMount =&gt; render =&gt; componentDidMount</p><ul><li>componentWillMount</li></ul><p>在组件挂载到 DOM 之前调用且只会被调用一次，这里调用 <code>setState</code>不会引起组件重新渲染，也可以把这边的内容写在 <code>constructor</code>中。另外 在 React SSR 中，这个生命周期函数很重要。React-Helmet等等插件都是根据这个函数来实现在 Server 插入内容</p><ul><li>render</li></ul><p>根据组件的 <code>props</code>和 <code>state</code>，返回一个 React 元素，不负责组件的实际渲染工作，之后 React 根据元素去渲染 页面的 DOM 工作。render 是纯函数，不能在里面执行 <code>this.setState</code>，会有改变组件状态的副作用</p><ul><li>componentDidMount</li></ul><p>组件挂载到 DOM 后调用，且只会被调用一次</p><h4 id="Updation"><a href="#Updation" class="headerlink" title="Updation"></a><strong>Updation</strong></h4><p>props:</p><p>componentWillReciveProps =&gt; shouldComponentUpdate =&gt; ComponentWillUpdate =&gt; render =&gt; componentDidUpdate</p><p>states:</p><p>shouldComponentUpdate =&gt; componentWillUpdate =&gt; render =&gt; componentDidUpdate</p><p><strong>造成组件更新的情况有两类（三种）情况</strong></p><p>1.父组件重新 render</p><p>父组件重新 render 引起子组件重新 render 的情况有两种</p><p>a) 直接使用，每当父组件重新 render 导致 重传 <code>props</code>,子组件将跟着重新渲染，无论 <code>props</code> 知否有变化，可通过 <code>shouldComponentUpdate</code>方法优化</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    shouldComponentUpdate(nextProps)&#123; <span class="comment">// 使用这个方法，可以避免无论 props 是否有更新都会导致组件跟着渲染</span></span><br><span class="line">        <span class="keyword">if</span>(nextProps.somethings === <span class="keyword">this</span>.props.somethings)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        render()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.sometings&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b) 在 <code>componentWillReceiveProps</code>方法中，将 <code>props</code> 换成自己的 <code>state</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            sometings:props.somethings</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillReceiveProps(nextProps)&#123;</span><br><span class="line">        <span class="comment">// 父组件重传 props 时会调用这个方法</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">something</span>:nextProps.somethings&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.sometings&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官网的描述，在 <code>componentWillReceiveProps</code>中调用 <code>this.setState()</code>不会引起第二次渲染</p><p>是因为 <code>componentWillReceiveProps</code>中判断 <code>props</code>是否变化了，如果变化了， <code>this.setState</code>将引起 <code>state</code>的变化，从而引起 <code>render</code>，此时就没有必要再做第二次重传 <code>props</code>引起的 <code>render</code>,避免重复做一样的渲染。</p><p>2.组件本身调用 <code>setState</code>，无论 <code>state</code> 是否有变化，可通过 <code>shouldComponentUpdate</code>方法优化</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            something:<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    shouldComponentUpdate(nextState)&#123;</span><br><span class="line">        <span class="comment">// 使用这个方法，可以避免相同 state引起 render</span></span><br><span class="line">        <span class="keyword">if</span>(nextState.something === <span class="keyword">this</span>.state.something)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> preSomething = <span class="keyword">this</span>.state.something</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">something</span>:preSomething&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleChild&#125;</span>&gt;</span>&#123;this.state.something&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>componentWillReceviceProps(nextProps)</li></ul><p>这个方法只会调用于<code>props</code> 引起的组件更新过程中，参数 <code>nextProps</code>是父组件传给当前组件的新 <code>props</code>。但是父组件 <code>render</code>方法的调用不能保证重传给当前组件的 <code>props</code> 是否有变化，所以在此方法根据 <code>nextProps</code>和 <code>this.props</code>来查明重传的 <code>props</code>是否有变化，以及如果改变了要执行什么，例如根据新的 <code>props</code>调用 <code>this.setState()</code>触发当前组件重新 <code>render</code></p><ul><li>shouldComponentUpdate(nextProps,nextState)</li></ul><p>通过比较 <code>nextProps</code>，<code>nextState</code>以及 <code>this.state</code>,<code>this.props</code>返回 true 时当前组件将继续执行更新过程，返回 false 当前组件停止更新，从而来减少组件的不必要的渲染，优化组件性能。</p><ul><li>componentWillUpdate(nextProps,nextState)</li></ul><p>在 调用 render 之前调用，在这里可以执行一些组件更新前的工作，一般比较少用</p><ul><li>componentDidUpdate(prevProps,prevState)</li></ul><p>这个方法组件更新后调用，可以操作组件更新的 DOM,<code>prevProps</code>，<code>prevState</code>这两个参数是指组件更新前的 <code>props</code> 和 <code>state</code></p><h4 id="Unmounting"><a href="#Unmounting" class="headerlink" title="Unmounting"></a><strong>Unmounting</strong></h4><p>componentWillUnMount</p><ul><li>componentWillUnMount</li></ul><p>这个方法在组件被卸载前调用，可以在这里执行一些清理工作。例如组件中使用的定时器，componentDidMount 中手动创建的 DOM 元素等等，可以避免内存泄露</p><p>具体实现可以看看这篇文章，<a href="https://segmentfault.com/a/1190000018499749">一次性搞懂 React 生命周期</a></p><h4 id="React-v-16-4-的生命周期"><a href="#React-v-16-4-的生命周期" class="headerlink" title="React v.16.4 的生命周期"></a>React v.16.4 的生命周期</h4><p><a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">图</a></p><p><img src="/images/前端面试题目汇总摘录-React 基础篇-react-v16.4-生命周期函数图.png" alt="v.16.4"></p><h4 id="变更缘故"><a href="#变更缘故" class="headerlink" title="变更缘故"></a>变更缘故</h4><p>生命周期在React v16 推出 Fiber 后就不合适了，如果开启 <code>async rendering</code>，在 <code>render</code>函数之前的所有函数，都有可能被执行多次。</p><p>v.16 前的生命周期中,<code>componentWillMount</code>,<code>componentReceiveProps</code>,  <code>shouldComponentUpdate</code>,<code>componentWillUpdate</code>是在 <code>render</code>之前执行的。</p><p>开发者如果开启了 <code>async rendering</code>，而且在上述的生命周期方法做 ajax 请求的话，那就将会被无谓多次调用。明显不是我们期望的结果。在 <code>componentWillMount</code>请求 ajax ,不管多快的结果都跟不上首次 <code>render</code>，而且 <code>componentWillMount</code>在服务器渲染也会被调用到，这样的 IO 操作放在 <code>componentDidMount</code>里面更加适合。</p><p>禁止不能用比劝导开发者不要这样用更好，所以除了 <code>shouldComponentUpdate</code>，其他在 <code>render</code>函数之前的所有函数 <code>componentWillMount</code>、<code>componentWillReceiveProps</code>，<code>componentWillUpdate</code>都被 <code>getDerivedStateFromProps</code>替代。</p><p>就是用一个静态函数 <code>getDerivedStateFromProps</code>来取代被 <code>deprecate</code>的几个生命周期函数，强制开发者在 <code>render</code>之前只做无副作用的操作，而且能做的操作局限在根据 <code>props</code>和 <code>state</code>决定新的 <code>state</code></p><p><a href="https://react.docschina.org/docs/react-component.html?no-cache=1#static-getderivedstatefromprops">官网API-getDerivedStateFromProps()</a></p><p><a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html">关于更多</a></p><p>v16.0 刚推出的时候，增加了一个 <code>componentDidCatch</code> 生命周期函数，新引入的两个生命周期函数:<code>getDerivedStateFromProps</code>和 <code>getSnapshotBeforeUpdate</code></p><ul><li>getDerivedStateFromProps</li></ul><p><code>getDerivedStateFromProps</code>在v.16.3 中只是创建和更新（由父组件引发的）。如果不由父组件引发，这个方法是不会调用的，如自身的 <code>setState</code> 和 <code>forceUpate</code>引发的。</p><p>在 v.16.4  中改正了这一点，让 <code>getDerivedStateFromProps</code> 无论是 <code>Mounting</code> 还是 <code>Updating</code>,也无论是因为什么引起的 <code>Updating</code>全部都会被调用。</p><p><em>static getDerivedStateFromProps(props,state)</em>在组件创建时和更新时的 <code>render</code>方法之前调用，它应该返回一个对象来更新状态，或者返回 null 来不更新任何内容</p><ul><li>getSnapshotBeforeUpadate</li></ul><p><code>getSnapshotBeforeUpdate</code>被调用于 <code>render</code> 之后，可以读取但是无法使用 DOM 的时候。它使得组件可以在可能更改之前从 DOM 中捕获一些信息（例如滚动位置）。这个生命周期返回的任何值都将作为参数传递给 <code>componentDidUpdate</code></p><p>官网的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.listRef = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line">    getSnapshotBeforeUpdate(nextProps,prevState)&#123;</span><br><span class="line">        <span class="comment">// 我们是否要添加新的 items 到列表中，捕获滚动位置以便我们可以稍后整理滚动</span></span><br><span class="line">        <span class="keyword">if</span>(prevProps.list.length &lt; <span class="keyword">this</span>.props.list.length)&#123;</span><br><span class="line">            <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">            <span class="keyword">return</span> list.scrollHeight - list.scrollTop</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidUpdate(prevProps,prevState,snapshot)&#123;</span><br><span class="line">        <span class="comment">// 如果我们有 snapshot 值，我们已经添加新的 items，调整滚动以至于这些新的 items，不会将就的 items 推出视图。</span></span><br><span class="line">        <span class="keyword">if</span>(snapshot)&#123;</span><br><span class="line">            <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">            list.scrollTop = list.scrollHeight - snapshot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div ref=&#123;<span class="keyword">this</span>.listRef&#125;&gt;&#123;<span class="comment">/* ...contents */</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>另外可以看看这篇文章，<a href="https://www.imooc.com/article/39395">你可能不需要派生状态</a></p><h3 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h3><p>官方的解释:</p><p><strong>React Fiber 是对核心算法的一次重新实现</strong></p><h4 id="同步更新过程的局限"><a href="#同步更新过程的局限" class="headerlink" title="同步更新过程的局限"></a><strong>同步更新过程的局限</strong></h4><p>v16 之前，更新过程是同步的，这可能会导致性能问题。</p><p>React 决定要加载或者更新组件树的时候，会做很多事情，比如调用各个组件的生命周期函数，计算和对比 Virtual DOM ,最后更新 DOM 树，这整个过程是同步进行的，也就是说只要一个加载或者更新过程开始，那么 React 就会一直更新下去，中途不会停歇。</p><p>表面看，这样的设计也是合理的，更新过程中不会有 I/O 操作，完全是 CPU 计算，所以不需异步操作。但是当组件书比较庞大的时候，问题就来了。</p><p>例如更新一个组件需要1毫秒，如果有200个组件需要更新，那就有200毫秒。用户在 input 按钮输入一个子，要等待200毫秒才会有反应，造成界面卡顿，带来不好的用户体验。</p><p>另外一个生动的比较就是潜水员的比喻，潜水员进行潜水任务，在潜到底的过程中，如果岸上有更加优先的任务他是不知道的，只有当他重新浮出水面才能去执行优先级更高的任务。</p><p>因为 javascript 单线程的特点，每个同步任务的耗时不能太长，不然就会让程序不会对其他输入做出反应，React 的更新就是犯了这个禁止，而 React Fiber 是要改变现状。</p><h4 id="React-Fiber-1"><a href="#React-Fiber-1" class="headerlink" title="React Fiber"></a>React Fiber</h4><p>分片是破解 Javascript 同步操作时间过长的方法。</p><p>把一个耗时长的任务分成很多小片，每一个小片的运行时间都很短，虽然总时间依然很长，但是在每个小片执行之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的时间。</p><p>React Fiber 把更新过程碎片化，每执行一段更新过程，就把控制权交还给 React 负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。</p><p>维护每一个分片的数据结构，就是 Fiber</p><h4 id="为什么叫-Fiber"><a href="#为什么叫-Fiber" class="headerlink" title="为什么叫 Fiber"></a>为什么叫 Fiber</h4><p>在计算机科学中，Fiber 的含义是 “纤维”，意指比 Thread(线程) 更细的线，也就是比线程控制更精密的并发处理机制。</p><h4 id="React-Fiber-对现有代码的影响"><a href="#React-Fiber-对现有代码的影响" class="headerlink" title="React Fiber 对现有代码的影响"></a>React Fiber 对现有代码的影响</h4><p>在 React Fiber 中，一次更新过程会分成多个分片完成，所以完全可能一个更新任务还没有完成，会被另一个更高优先级的更新过程打断，这时候，<strong>优先级的更新任务会优先处理完，而低优先级更新任务所做的工作则会完全作废，然后等待机会重头再来。</strong></p><p>因为一个更新过程可能会被打断，所以 React Fiber 更新过程会被分成两个阶段（Phase）：第一个阶段 Reconciliation 和 第二个阶段 Commit Phase.</p><p>在第一个阶段中，React Fiber 会找出需要更新哪些 DOM,这个阶段可以被打断，但是到了第二个阶段，那就是一鼓作气把 DOM 更新完成，不会被打断。</p><p>这两个阶段大部分工作是结合 React Fiber 和 生命周期函数。</p><p>以 <code>render</code> 为界，第一个阶段可能会调用下面这些生命周期函数：</p><ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li></ul><p>下面这些生命周期函数则会在第二个阶段调用</p><ul><li>componentDidMount</li><li>componentDidUpdate</li><li>componentWillUnmount</li></ul><p>因为第一个阶段会被打断，重新再来，会造成意想不到的情况。</p><p>比如说，一个低优先级的任务 A 正在执行，已经调用了某个组件的 <code>componentWillUpdate</code>函数，接下来发现自己的时间分片已经用完了，于是冒出水面，看看有没有紧急任务，发现有个紧急任务B，接下来 React Fiber 就去执行这个紧急任务B。任务A 虽然执行了一半，但是没有办法，只能完全放弃，等到任务B 完成后，任务 A 重头来一遍，也就是说 <code>componentWillUpdate</code>函数会被再重新调用一次。</p><p>在现有的 React 中，每个生命周期函数在一个加载或者更新过程中决定只会被调用一次，在 React Fiber 中，不再是这样了，第一阶段的声生命周期函数在一次加载和更新过程中可能会被多次调用。</p><p>使用 React Fiber 之后，一定要检查一下第一阶段相关的这些生命周期函数，看看有没有逻辑是假设在一个更新过程中只调用一次的，有的话就要改了。</p><p>看看可能会重复调用的函数</p><p><code>componentWillReceiveProps</code>即使当前组件不更新，只要父组件更新也会引起和这个函数被调用多次，调用多次无妨</p><p><code>shouldComponentUpdate</code>这个函数的作用是返回一个 true 或者 false，不应该有任何副作用，调用多次无妨</p><p><code>render</code> 是纯函数，调用多次无妨</p><p>剩下 <code>componentWillMount</code> 和 <code>componentWillUpdate</code>这两个函数往往包含副作用，所以当使用 React Fiber 的时候一定要重点看这两个函数的实现。</p><h3 id="this-setState-异步原因以及更新机制"><a href="#this-setState-异步原因以及更新机制" class="headerlink" title="this.setState 异步原因以及更新机制"></a>this.setState 异步原因以及更新机制</h3><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a><strong>现象</strong></h4><p>在 React 中，如果是由 React 引发的事件处理（比如通过 onClick 引发的合成事件处理）和组件生命周期函数内（比如 <code>componentDidMount</code>），调用 <code>this.setState</code> 不会同步更新 <code>this.state</code>，除此之外的 <code>setState</code> 调用会同步执行 <code>this.state</code>。除此之外指的是绕过 React 通过 <code>addEventListener</code> 直接添加的事件处理函数，还有通过 <code>setTimeout</code>/<code>setInterval</code> 产生的异步调用。另外在合成事件和生命周期函数中的异步调用 <code>setState</code>（比如 <code>ajax</code> 和 <code>setTimeout</code>） 也是会同步更新 <code>this.setState</code></p><h4 id="保证内部（数据）的统一"><a href="#保证内部（数据）的统一" class="headerlink" title="保证内部（数据）的统一"></a>保证内部（数据）的统一</h4><p>假设 setState 是同步的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value); <span class="comment">//0</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>:<span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value); <span class="comment">//1</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>:<span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value); <span class="comment">//2</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>:<span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>这种只用到了 state 的情况下，同步 setState 是可以的。</p><p>然而这时需要将状态提升到父组件，以供多个兄弟组件共享：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.props.value) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">this</span>.props.onIncrement();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.props.value) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">this</span>.props.onIncrement();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.props.value) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">this</span>.props.onIncrement();</span><br></pre></td></tr></table></figure><p>在同步模型中，虽然 this.state 会立即更新，但是 this.props 并不会。而且在没有重渲染父组件的情况下，我们不能立即更新 this.props。如果要立即更新 this.props(立即重新渲染父组件)，必须放弃批处理（根据不同的情况，性能可能有显著下降）</p><p>所以为了解决这样的问题，在 React 中，this.state 和 this.props 都是异步更新的，在上面的例子中重构前后都会打印出0，这让状态提升更加安全。</p><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>我们通常认为状态更新会按照既定顺序被应用，无论 state 是同步更新还是异步更新，然而事实并不一定如此。</p><p>React 会依据不同的调用源，给不同的 setState 调用分配不同的优先级。调用源包括事件处理、网络请求、动画等。</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用法1</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;&#125;,()=&gt;&#123;&#125;)</span><br><span class="line"><span class="comment">// 用法2</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">()</span>=(<span class="params">&#123;&#125;</span>),<span class="params">()</span>=&gt;</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1：对象，key是 this.state 中key值，val 是修改后的值</span></span><br><span class="line"><span class="comment">// 参数2：函数，可查看数据是否更新完成，获取到数据更新后的最新 dom 结构</span></span><br></pre></td></tr></table></figure><p><strong>不要直接修改 state</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state.comment = <span class="string">'Hello'</span> (X)</span><br></pre></td></tr></table></figure><p><strong>state  更新可能会异步</strong></p><p>从上面也知道了，React 为了性能优化，有可能会将多个 setState 调用合并为一次更新，因为 this.props 与 this.state  可能是异步更新的，你不可能依赖他们的值进行下一个 state 的计算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">counter</span>:<span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment&#125;) (X)</span><br></pre></td></tr></table></figure><p>为了弥补这个问题，使用了另一种 setState 形式，接受一个函数。这个函数接收前一个状态作为第一个参数，应用更新时的 props 作为第二个参数，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState,props</span>)=&gt;</span>&#123;</span><br><span class="line">    counter:prevState.counter + props.increment</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>多次setState函数调用产生的效果会合并</strong></p><p>当调用 setState ,React 会合并你提供的对象到当前的状态。所以当 state 是一个多键值的结构，可以单独更新其中一个，此时会 差分 更新，不会影响到其他的属性值</p><p>总结起来就是：</p><ol><li>setState 不会立刻改变 React 组件中的 state</li><li>setState 通过触发一次组件的更新来引发重绘</li><li>多次 setState 函数嗲用产生的效果会合并</li></ol><p>重绘指的更新的生命周期函数：</p><ul><li><code>shouldComponentUpdate</code>:被调用时 this.state 没有更新，如果返回 false，生命周期被中断，虽然不调用之后的函数，但是 state 仍然会被更新</li><li><code>componentWillUpdate</code>：被调用时 this.state 没有更新</li><li><code>render</code>：被调用时 this.state 得到更新</li><li><code>componentDidUpdate</code></li></ul><p>React会将setState的效果放在队列中，积攒着一次引发更新过程。为的就是把Virtual DOM和DOM树操作降到最小，用于提高性能。</p><p><strong>执行setState 后拿到最新的 state</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">updateData = <span class="function">(<span class="params">newData</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(</span><br><span class="line">        &#123;<span class="attr">data</span>:newData&#125;,</span><br><span class="line">        () =&gt;&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.data)</span><br><span class="line">        &#125; </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="setState-更新机制"><a href="#setState-更新机制" class="headerlink" title="setState 更新机制"></a>setState 更新机制</h4><p><strong>循环调用风险</strong></p><p>不要在 <code>shouldComponentUpdate</code>和 <code>componentWillUpdate</code>中调用 <code>setState</code>，不然会出现死循环</p><p>在调用 <code>setState</code>时候实际上会执行 <code>enqueueSetState</code>方法，并对 <code>partialState</code>、<code>pendingStateQueue</code>更新队列进行合并操作，最终通过 <code>enqueueUpdate</code>执行 state 更新。</p><p>而 <code>performUpdateIfNecessary</code>方法会获取 <code>pendingElement</code>、<code>pendingStateQueue</code>、<code>pendingForceUpdate</code>并调用 <code>receiveComponent</code>和 <code>updateComponent</code>方法进行组件更新</p><p>如果在 <code>componentWillUpdate</code> 和 <code>shouldComponentUpdate</code> 中调用 <code>setState</code>，此时 <code>pendingStateQueue !== null</code>则 <code>performUpdateIfNessary</code> 会调用 <code>updateComponent</code> 进行组件更新，而 <code>updateComponent</code>又会调用 <code>shouldComponentUpdate</code> 和 <code>componentWillUpdate</code>这样就导致了循环调用</p><p>setState 源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React 组件继承自 React.Component，而 SetState 是 React.Component 的方法，对于组件来说，setState 属于其原型方法</span></span><br><span class="line"><span class="comment">// 在 React 中每个组件都拥有一个 this.updater，是用来驱动 state 更新的工具对象。当我们在构造函数中调用 super 的时实质调用的就是函数 ReactComponent</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactComponent</span>(<span class="params">props,context,updater</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.props = props;</span><br><span class="line">    <span class="keyword">this</span>.context = context;</span><br><span class="line">    <span class="keyword">this</span>.refs = emptyObject;</span><br><span class="line">    <span class="comment">// ReactNoopUpdateQueue 实际是没有什么意义的，只相当于是一个初始化的过程。而 ReactNoopUpdateQueue.enqueueSetState 主要起到一个在非生产版本中警告的作用。真正的 updater 是在 renderer 中注入（inject）。因此如果在 constructor 尝试调用 this.helper.isMount会返回 false，表示并没有安装（mount），如果你调用 setState，也会给出响应的警告</span></span><br><span class="line">    <span class="keyword">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line">ReactComponent.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">partialState,callback</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 调用 enqueueSetState 将 setState 事务放进队列中</span></span><br><span class="line">    <span class="comment">// partialState 可以传 Object,也可以传 function,会产生新的 state 以一种 Object.assign() 的方式跟旧的 state 进行合并</span></span><br><span class="line">    <span class="comment">// 参数 this 是组件的实例</span></span><br><span class="line">    <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>,partialState);</span><br><span class="line">    <span class="keyword">if</span>(callback)&#123;</span><br><span class="line">        <span class="keyword">this</span>.updater.enqueueCallback(<span class="keyword">this</span>,callback,<span class="string">'setState'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ReactUpdateQueue = &#123;</span><br><span class="line">    <span class="comment">// 实际通过 enqueueSetState 执行</span></span><br><span class="line">    <span class="comment">// 1.将新的 state 放进数组</span></span><br><span class="line">    <span class="comment">// 2.用 enqueueUpdate 来处理将要更新的实例对象</span></span><br><span class="line">    enqueueSetState：<span class="function"><span class="keyword">function</span>(<span class="params">publicInstance,partialState</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前组件的 instance，里面有很多属性，主要关注 pendingState(待更新队列)，pendingCallbacks(更新回调队列)</span></span><br><span class="line">        <span class="keyword">const</span> internalInstance = getInernalInstanceReadyForUpdate(</span><br><span class="line">            publickInstance,</span><br><span class="line">            <span class="string">'setState'</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span>(!inernalInstance) <span class="keyword">return</span></span><br><span class="line">        <span class="comment">// 更新队列合并操作</span></span><br><span class="line">        <span class="keyword">const</span> queue = internalInstance._pendingStateQueue || （internalInstance._pendingStateQueue = []）</span><br><span class="line">        <span class="comment">// partialState 可以理解为之前的 state</span></span><br><span class="line">        queue.push(partialState)</span><br><span class="line">        <span class="comment">// 最终通过 enqueueUpdate 更新，将新的 component instance 放入一个队列</span></span><br><span class="line">        enqueueUpdate(internalInstance)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在 _pendingElement、_pendingStateQueue 和 _pendingForceUpdate 则更新组件</span></span><br><span class="line">    performUpdateIfNessary:<span class="function"><span class="keyword">function</span>(<span class="params">transaction</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>._pendingElement != <span class="literal">null</span>)&#123;        ReactReconciler.receiveComponent(<span class="keyword">this</span>,<span class="keyword">this</span>._pendingElement,transaction,<span class="keyword">this</span>._context)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>._pendingStateQueue !== <span class="literal">null</span> || <span class="keyword">this</span>._pendingForceUpdate)&#123;        <span class="keyword">this</span>.updateComponent(transaction,<span class="keyword">this</span>._currentElement,<span class="keyword">this</span>._currentElement,<span class="keyword">this</span>._context)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>setState 调用栈</strong></p><pre class="mermaid">graph TDA[this.setState]B[newState存入pending队列]C{是否处于 batch update}D(保存组件在 dirtyComponent中)E(遍历所有的dirtyComponents 调用updateComponent 更新 pending state or props)F[调用enqueueUpdate]A --> BB --> FF --> CC == Y ==> DC == N ==> E</pre><p>React的setState函数实现中，会根据一个变量 <code>isBatchingUpdates</code> 判断是 直接更新 this.state还是 放到队列 中。</p><p><code>isBatchingUpdates</code>默认<code>false</code>，表示setState会同步更新this.state，但是函数<code>batchedUpdates</code>函数会把<code>isBatchingUpdates</code>修改为<code>true</code>。当React在调用事件处理函数之前就会调用<code>batchedUpdates</code>，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">internalInstance</span>)</span>&#123;</span><br><span class="line">    ReactUpdates.enqueueUpdate(internalInstance)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ReactUpdates = &#123;</span><br><span class="line">    enqueueUpdate:<span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">component</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 保证 ReactUpdates.ReactReconcileTransaction 与 batchingStrategy 是存在的，否则给出对应的警告</span></span><br><span class="line">        ensureInjected();</span><br><span class="line">        <span class="comment">// 如果不处于批量更新模式</span></span><br><span class="line">        <span class="keyword">if</span>(!batchingStrategy.isBatchingUpdates)&#123;</span><br><span class="line">            <span class="comment">// 调用事务</span></span><br><span class="line">            batchingStrategy.batchedUpdates(enqueueUpdate,component)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果处于批量更新模式,将组件放入脏组件队列，也就是待更新组件队列</span></span><br><span class="line">        dirtyComponents.psuh(component);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// batchingStrategy。实质上是一种批量更新策略</span></span><br><span class="line"><span class="keyword">const</span> ReactDefaultBatchingStrategy = &#123;</span><br><span class="line">    isBatchingupdates:<span class="literal">false</span>,</span><br><span class="line">    batchedUpdates:<span class="function"><span class="keyword">function</span>(<span class="params">callback,a,b,c,d,e</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates</span><br><span class="line">        ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span>(callback)&#123;</span><br><span class="line">            callback(a,b,c,d,e)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            transaction.perform(callback,<span class="literal">null</span>,a,b,c,d,e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Transaction</strong></p><p>关于 React 中的事务 Transaction,源码中有这样的 ASCII图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> *                       wrappers (injected at creation time)</span><br><span class="line"> *                                      +        +</span><br><span class="line"> *                                      |        |</span><br><span class="line"> *                    +-----------------|--------|--------------+</span><br><span class="line"> *                    |                 v        |              |</span><br><span class="line"> *                    |      +---------------+   |              |</span><br><span class="line"> *                    |   +--|    wrapper1   |---|----+         |</span><br><span class="line"> *                    |   |  +---------------+   v    |         |</span><br><span class="line"> *                    |   |          +-------------+  |         |</span><br><span class="line"> *                    |   |     +----|   wrapper2  |--------+   |</span><br><span class="line"> *                    |   |     |    +-------------+  |     |   |</span><br><span class="line"> *                    |   |     |                     |     |   |</span><br><span class="line"> *                    |   v     v                     v     v   | wrapper</span><br><span class="line"> *                    | +---+ +---+   +---------+   +---+ +---+ | invariants</span><br><span class="line"> * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained</span><br><span class="line"> * +-----------------&gt;|-|---|-|---|--&gt;|anyMethod|---|---|-|---|-|--------&gt;</span><br><span class="line"> *                    | |   | |   |   |         |   |   | |   | |</span><br><span class="line"> *                    | |   | |   |   |         |   |   | |   | |</span><br><span class="line"> *                    | |   | |   |   |         |   |   | |   | |</span><br><span class="line"> *                    | +---+ +---+   +---------+   +---+ +---+ |</span><br><span class="line"> *                    |  initialize                    close    |</span><br><span class="line"> *                    +-----------------------------------------+</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>React 中的事务 Transaction，会给方法包装一个个 wrapper，其中每个 wrapper 都有两个方法：initialize 与 close。当执行方法时，需要执行事务的 perform 方法。这个方法会首先一次执行 wrapper 的 initialize,然后执行函数本身，最后执行 wrapper 的 close 方法</p><p>定义 Transaction 需要给构造函数混入 Transaction.Mixin，并需要提供一个原型方法 getTransactionWrappers 用于返回 wrapper 数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> RESET_BATCHED_UPDATES = &#123;</span><br><span class="line">    initialize:emptyFuntion,</span><br><span class="line">    colse:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 重置为 false</span></span><br><span class="line">        ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> FLUSH_BATCHED_UPPDATES = &#123;</span><br><span class="line">    initialize:emptyFunction,</span><br><span class="line">    close:ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES,RESET_BATCHED_UPDATES]；</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactDefaultBatchingStrategyTransaction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.reinitializeTransaction();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(</span><br><span class="line">    ReactDefaultBatchingStrategyTransaction.prototype,</span><br><span class="line">    Transaction.Mixin,&#123;</span><br><span class="line">        getTransactionWrappers:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> TRANSACTION_WRAPPERS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> transaction = <span class="keyword">new</span> ReactDefaultBatchingStrategyTransaction();</span><br></pre></td></tr></table></figure><p>重新回顾一下更新的过程，如果处于批量更新的过程中（<code>isBatchingUpdates</code>为 true）的时候，则直接将组件传入 <code>dirtyComponents</code>。如果不是的话，就开启批量更新，用事务 <code>transaction.perform</code>执行 <code>enqueueUpdate</code>，这时候 <code>isBatchingUpdates</code>经过上次执行已经是 true，将直接传入 <code>dirtyComponents</code>。那么更新的组件传入 <code>dirtyComponent</code>会发生什么？</p><p><code>batchUpdates</code>是处于一个事务中的，该事务在 close 阶段做了两件事，首先是将 <code>ReactDefaultBatchingStrategy.isBatchingUpdates</code>设置为 false，即关闭批量更新的标志位，第二个就是调用方法 <code>ReactUpdates.flushBatchedUpdates</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码有省略</span></span><br><span class="line"><span class="keyword">var</span> flushBatchedUpdates = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(dirtyComponents.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dirtyComponents.length)&#123;</span><br><span class="line">            <span class="keyword">var</span> transaction = ReactUpdatesFlushTransaction.getPooled();</span><br><span class="line">            <span class="comment">// 以事务的方式执行了 runBatchedUpdates             </span></span><br><span class="line">            transaction.perform(runBatchedUpdates,<span class="literal">null</span>,transaction);</span><br><span class="line">            ReactUpdatesFlushTransaction.release(transaction)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runBatchedUpdates</span>(<span class="params">transaction</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = transactiono.dirtyComponentsLength;</span><br><span class="line">    <span class="comment">// 将组件中的 mountOrder 进行了递增排序，目的就是保证更新顺序，父组件保证其子组件之前更新。</span></span><br><span class="line">    dirtyComponents.sort(mountOrderComparator);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="comment">// 在组件中获得 setState 完成之后的回调函数</span></span><br><span class="line">        <span class="keyword">var</span> component = dirtyComponents[i];</span><br><span class="line">        <span class="keyword">var</span> callbacks = component._pendingCallbacks;</span><br><span class="line">        component._pendingCallbacks = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        ReactReconciler.performUpdateIfNessary(component,transaction.reconcileTransaction)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span>(callbacks)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;callbacks.length;j++)&#123;</span><br><span class="line">                transaction.callbackQueue.enqueue(</span><br><span class="line">                callbacks[j],</span><br><span class="line">                component.getPublickInstance()</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// performUpdateIfNessary 执行组件实例的原型方法performUpdateIfNecessary</span></span><br><span class="line">performUpdateIfNessary:<span class="function"><span class="keyword">function</span>(<span class="params">internalInstance,transaction</span>)</span>&#123;</span><br><span class="line">    interbalInstance.performUpdateIfNecessary(transaction)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略版本</span></span><br><span class="line"><span class="keyword">var</span> ReactCompositeComponentMixin = &#123;</span><br><span class="line">    performUpdateIfNecessary:<span class="function"><span class="keyword">function</span>(<span class="params">transaction</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>._pendingStateQueue !==<span class="literal">null</span> || <span class="keyword">this</span>._pendingForceUpdate)&#123;</span><br><span class="line">            <span class="keyword">this</span>.updateComponent(</span><br><span class="line">                transaction,</span><br><span class="line">                <span class="keyword">this</span>._currentElement,</span><br><span class="line">                <span class="keyword">this</span>._currentElement,</span><br><span class="line">                <span class="keyword">this</span>._context,</span><br><span class="line">                <span class="keyword">this</span>._context</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">updateComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">    prevParentElement,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextParentElement,</span></span></span><br><span class="line"><span class="function"><span class="params">    prevUnmaskedContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextUnmaskedContext</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inst = <span class="keyword">this</span>._instance;</span><br><span class="line">    <span class="keyword">var</span> willReceive = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> nextContext;</span><br><span class="line">    <span class="keyword">var</span> nextProps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证组件context是否改变</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证是否是props更新还是组件state更新</span></span><br><span class="line">    <span class="keyword">if</span> (prevParentElement === nextParentElement) &#123;</span><br><span class="line">      nextProps = nextParentElement.props;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//存在props的更新  </span></span><br><span class="line">      nextProps = <span class="keyword">this</span>._processProps(nextParentElement.props);</span><br><span class="line">      willReceive = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据条件判断是否调用钩子函数componentWillReceiveProps</span></span><br><span class="line">    <span class="keyword">if</span> (willReceive &amp;&amp; inst.componentWillReceiveProps) &#123;</span><br><span class="line">      inst.componentWillReceiveProps(nextProps, nextContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算新的state</span></span><br><span class="line">    <span class="keyword">var</span> nextState = <span class="keyword">this</span>._processPendingState(nextProps, nextContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> shouldUpdate =</span><br><span class="line">      <span class="keyword">this</span>._pendingForceUpdate ||</span><br><span class="line">      !inst.shouldComponentUpdate ||</span><br><span class="line">      inst.shouldComponentUpdate(nextProps, nextState, nextContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldUpdate) &#123;</span><br><span class="line">      <span class="keyword">this</span>._pendingForceUpdate = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">this</span>._performComponentUpdate(</span><br><span class="line">        nextParentElement,</span><br><span class="line">        nextProps,</span><br><span class="line">        nextState,</span><br><span class="line">        nextContext,</span><br><span class="line">        transaction,</span><br><span class="line">        nextUnmaskedContext</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._currentElement = nextParentElement;</span><br><span class="line">      <span class="keyword">this</span>._context = nextUnmaskedContext;</span><br><span class="line">      inst.props = nextProps;</span><br><span class="line">      inst.state = nextState;</span><br><span class="line">      inst.context = nextContext;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 计算新的 state 里面调用了 _processPending</span></span><br><span class="line">&#123;</span><br><span class="line">  _processPendingState: <span class="function"><span class="keyword">function</span>(<span class="params">props, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inst = <span class="keyword">this</span>._instance;</span><br><span class="line">    <span class="keyword">var</span> queue = <span class="keyword">this</span>._pendingStateQueue;</span><br><span class="line">    <span class="keyword">var</span> replace = <span class="keyword">this</span>._pendingReplaceState;</span><br><span class="line">    <span class="keyword">this</span>._pendingReplaceState = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>._pendingStateQueue = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!queue) &#123;</span><br><span class="line">      <span class="keyword">return</span> inst.state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replace &amp;&amp; queue.length === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> queue[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> nextState = <span class="built_in">Object</span>.assign(&#123;&#125;, replace ? queue[<span class="number">0</span>] : inst.state);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = replace ? <span class="number">1</span> : <span class="number">0</span>; i &lt; queue.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> partial = queue[i];</span><br><span class="line">      <span class="built_in">Object</span>.assign(</span><br><span class="line">        nextState,</span><br><span class="line">        <span class="keyword">typeof</span> partial === <span class="string">'function'</span> ?</span><br><span class="line">          partial.call(inst, nextState, props, context) :</span><br><span class="line">          partial</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nextState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一部分代码相对来说不算是很难，<code>replace</code>是存在是由于之前被废弃的API<code>this.replaceState</code>，我们现在不需要关心这一部分，现在我们可以知道为什么给 <code>setState</code> 传入的参数是函数时，就可以解决 <code>setState</code> 的潜在问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>:<span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>:<span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>调用 <code>setState</code>是批量更新，那么在第一次调用之后，this.state.value的值并没有发生拜年话。两次更新的指都是一样的。如果传递的是会调用函数形式，那么 <code>partial.call(inst,nextState,props,context)</code>接受的 state 都是上一轮更新之后的新值，因此可以达到我们想要的结果。</p><p><code>_processPendingState</code> 在计算完新的 state 之后会执行 <code>_performComponentUpdate</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_performComponentUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    nextElement,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextProps,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextState,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">    unmaskedContext</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inst = <span class="keyword">this</span>._instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> hasComponentDidUpdate = <span class="built_in">Boolean</span>(inst.componentDidUpdate);</span><br><span class="line">    <span class="keyword">var</span> prevProps;</span><br><span class="line">    <span class="keyword">var</span> prevState;</span><br><span class="line">    <span class="keyword">var</span> prevContext;</span><br><span class="line">    <span class="keyword">if</span> (hasComponentDidUpdate) &#123;</span><br><span class="line">      prevProps = inst.props;</span><br><span class="line">      prevState = inst.state;</span><br><span class="line">      prevContext = inst.context;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  在更新之前，调用钩子函数 componentWillUpdate，然后更新了属性（props,state,context）</span></span><br><span class="line">    <span class="keyword">if</span> (inst.componentWillUpdate) &#123;</span><br><span class="line">      inst.componentWillUpdate(nextProps, nextState, nextContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._currentElement = nextElement;</span><br><span class="line">    <span class="keyword">this</span>._context = unmaskedContext;</span><br><span class="line">    inst.props = nextProps;</span><br><span class="line">    inst.state = nextState;</span><br><span class="line">    inst.context = nextContext;</span><br><span class="line"><span class="comment">// 执行函数_updateRenderedComponent，涉及到 render 调用和相应的 DOM 更新</span></span><br><span class="line">    <span class="keyword">this</span>._updateRenderedComponent(transaction, unmaskedContext);</span><br><span class="line"><span class="comment">// 最后执行 componentDidUpdate</span></span><br><span class="line">    <span class="keyword">if</span> (hasComponentDidUpdate) &#123;</span><br><span class="line">      transaction.getReactMountReady().enqueue(</span><br><span class="line">        inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext),</span><br><span class="line">        inst</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前为止，我们已经基本介绍完了setState的更新过程，只剩一个部分没有介绍，那就是setState执行结束之后的回调函数。我们知道，setState函数中如果存在callback，则会有:　　</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (callback) &#123;</span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueCallback(<span class="keyword">this</span>, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　call函数会被传递给<code>this.updater</code>的函数<code>enqueueCallback</code>，然后非常类似于setState，<code>callback</code>会存储在组件内部实例中的<code>_pendingCallbacks</code>属性之中。我们知道，回调函数必须要setState真正完成之后才会调用，那么在代码中是怎么实现的。大家还记得在函数<code>flushBatchedUpdates</code>中有一个事务<code>ReactUpdatesFlushTransaction</code>:　　</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码有省略</span></span><br><span class="line"><span class="keyword">var</span> flushBatchedUpdates = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (dirtyComponents.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dirtyComponents.length) &#123;</span><br><span class="line">      <span class="comment">//从事务pool中获得事务实例</span></span><br><span class="line">      <span class="keyword">var</span> transaction = ReactUpdatesFlushTransaction.getPooled();</span><br><span class="line">      transaction.perform(runBatchedUpdates, <span class="literal">null</span>, transaction);</span><br><span class="line">      <span class="comment">//释放实例</span></span><br><span class="line">      ReactUpdatesFlushTransaction.release(transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　我们现在看看<code>ReactUpdatesFlushTransaction</code>的wrapper是怎么定义的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> UPDATE_QUEUEING = &#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackQueue.reset();</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackQueue.notifyAll();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　我们看到在事务的<code>close</code>阶段定义了<code>this.callbackQueue.notifyAll()</code>,即执行了回调函数，通过这种方法就能保证回调函数一定是在setState真正完成之后才执行的。</p><p>现在可以回答，为什么下面这两种改代码会产生不同的情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未按预期执行</span></span><br><span class="line">_addValue() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        value: <span class="keyword">this</span>.state.value + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        value: <span class="keyword">this</span>.state.value + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按预期执行</span></span><br><span class="line">_addValue() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            value: <span class="keyword">this</span>.state.value + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            value: <span class="keyword">this</span>.state.value + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一种情况下，如果打断点追踪你会发现，在第一次执行<code>setState</code>前，已经触发了一个 <code>batchedUpdates</code>，等到执行setState时已经处于一个较大的事务，因此两个setState都是会被批量更新的(相当于异步更新的过程，this.state.value值并没有立即改变)，执行setState只不过是将两者的<code>partialState</code>传入<code>dirtyComponents</code>，最后再通过事务的<code>close</code>阶段的<code>flushBatchedUpdates</code>方法去执行重新渲染。但是通过<code>setTimeout</code>函数的包装，两次setState都会在click触发的批量更新<code>batchedUpdates</code>结束之后执行，这两次setState会触发<strong>两次</strong>批量更新batchedUpdates，当然也会执行两个事务以及函数<code>flushBatchedUpdates</code>,这就相当于一个同步更新的过程，自然可以达到我们的目的，这也就解释了为什么React文档中既没有说setState是同步更新或者是异步更新，只是模糊地说到，setState并不保证同步更新。</p><h4 id="DOM事件和生命周期"><a href="#DOM事件和生命周期" class="headerlink" title="DOM事件和生命周期"></a>DOM事件和生命周期</h4><pre class="mermaid">graph TDA(DOM)B(生命周期)C[dispatchEvent-ReactEventListener.js]D[_renderNewRootComponent-ReactMount.js]E[ReactUpdates.batchedUpdates-ReactUpdates.js]F[isBatchingUpdates=true]G[transaction.perform 执行事件回调和生命周期进入事务]H[close isBatchingUpdates=false ReactUpdates.flushBatchedUpdates]I[检查 dirtyComponents 完成更新]A == type:'click' ==> CB == componentDidMount ==> DC --> ED --> EE --> FF --> GG --> HH --> I</pre><h3 id="React合成事件"><a href="#React合成事件" class="headerlink" title="React合成事件"></a>React合成事件</h3><h3 id="HOC-的应用"><a href="#HOC-的应用" class="headerlink" title="HOC 的应用"></a>HOC 的应用</h3><p>### </p><h3 id="中间件应用"><a href="#中间件应用" class="headerlink" title="中间件应用"></a>中间件应用</h3><h3 id="Redux-的应用和原理"><a href="#Redux-的应用和原理" class="headerlink" title="Redux 的应用和原理"></a>Redux 的应用和原理</h3><h3 id="Mobx-的应用和原理"><a href="#Mobx-的应用和原理" class="headerlink" title="Mobx 的应用和原理"></a>Mobx 的应用和原理</h3><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><ol><li><a href="https://segmentfault.com/a/1190000010522782">React 渲染机制解析</a></li><li><a href="https://www.jianshu.com/p/3ba0822018cf">React之diff算法</a></li><li><a href="https://www.runoob.com/react/react-jsx.html">React JSX</a></li><li><a href="http://huziketang.mangojuice.top/books/react/lesson6">使用 JSX 描述 UI 信息</a></li><li><a href="https://zhuanlan.zhihu.com/p/26027085">React Fiber 是什么？</a></li><li><a href="https://www.jianshu.com/p/cc12e9a8052c">为什么setState是异步的</a></li><li><a href="https://www.imooc.com/article/23912?block_id=tuijian_wz">React 中 setState() 为什么是异步的？</a></li><li><a href="https://www.cnblogs.com/t-sun-j/p/10300825.html">this.setState使用时的一些坑</a></li><li><a href="https://segmentfault.com/a/1190000015463599">React setState 简单整理总结</a></li><li><a href="https://segmentfault.com/a/1190000018615027">日常抄书之一次性弄懂setState</a></li><li><a href="https://segmentfault.com/a/1190000018499749">一次性搞懂解React生命周期</a></li><li><a href="https://segmentfault.com/a/1190000010785692">React技术内幕:setState的秘密</a></li><li><a href="https://segmentfault.com/a/1190000015821018">浅入深出setState（下篇）</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;温故而知新，保持空杯心态&lt;/p&gt;
&lt;h2 id=&quot;React-基础&quot;&gt;&lt;a href=&quot;#React-基础&quot; class=&quot;headerlink&quot; title=&quot;React  基础&quot;&gt;&lt;/a&gt;React  基础&lt;/h2&gt;&lt;h3 id=&quot;什么是-React&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="前端面试" scheme="http://laibh.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端面试题" scheme="http://laibh.top/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>React-SSR浅析</title>
    <link href="http://laibh.top/2019-05-11-React-SSR%E6%B5%85%E6%9E%90.html"/>
    <id>http://laibh.top/2019-05-11-React-SSR浅析.html</id>
    <published>2019-05-11T08:30:00.000Z</published>
    <updated>2022-03-04T10:00:38.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-SSR-同构浅析"><a href="#React-SSR-同构浅析" class="headerlink" title="React SSR 同构浅析"></a>React SSR 同构浅析</h2><h2 id="客户端渲染（CSR）"><a href="#客户端渲染（CSR）" class="headerlink" title="客户端渲染（CSR）"></a>客户端渲染（CSR）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>传统 react项目,在浏览器打开项目，查看源代码，可以看到 index.js 页面里面只有一个基本的 DOM 节点，下面引入了一个 js 文件。而项目的所有内容就是通过这个 js 来渲染，通过禁止浏览器的 javascript 功能可以看到浏览器提示要 开启 javascript 功能的提示，没有项目的内容生成。</p><p>CSR 过程:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浏览器发送请求 =&gt; 服务器返回HTML =&gt; 浏览器发送 bundle.js 请求 =&gt; 服务器返回 bundle.js =&gt; 浏览器运行 React 代码 =&gt; 页面准备就绪</span><br></pre></td></tr></table></figure><h3 id="优势与劣势"><a href="#优势与劣势" class="headerlink" title="优势与劣势"></a>优势与劣势</h3><p>优势：前后端分离，前端 ajax 请求数据，后端内部处理好逻辑返回 JSON 给前端处理。代码在客户端运行，性能良好</p><p>劣势：首屏加载速度慢。SEO 差（百度爬虫不能识别 js 文件）</p><h2 id="服务器渲染（SSR）"><a href="#服务器渲染（SSR）" class="headerlink" title="服务器渲染（SSR）"></a>服务器渲染（SSR）</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>SSR 过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浏览器发送请求 =&gt; 服务器运行 React 代码生成页面 =&gt; 服务器返回页面</span><br></pre></td></tr></table></figure><h3 id="优势与劣势-1"><a href="#优势与劣势-1" class="headerlink" title="优势与劣势"></a>优势与劣势</h3><p>优势：首屏速度快</p><p>劣势：服务器性能需求大</p><h3 id="renderToString"><a href="#renderToString" class="headerlink" title="renderToString"></a>renderToString</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;renderToString&#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span>;</span><br><span class="line"><span class="keyword">const</span> content = renderToString((</span><br><span class="line">    <span class="comment">// 组件</span></span><br><span class="line">))</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    res.send(</span><br><span class="line">        <span class="string">`&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;div&gt;<span class="subst">$&#123;content&#125;</span>&lt;/div&gt;</span></span><br><span class="line"><span class="string"> &lt;/html&gt;`</span></span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="路由-React-router-config"><a href="#路由-React-router-config" class="headerlink" title="路由 React-router-config"></a>路由 React-router-config</h2><p>可识别嵌套路由，内置 ssr 方案</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>服务器上呈现的路由都是无状态的，所以我们将应用程序包装在无状态的 <code>&lt;StaticRouter&gt;</code> e而不是<code>&lt;BrowserRouter&gt;</code>。从服务器传入请求的路由，以便路由可以匹配。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client</span></span><br><span class="line">&lt;BroswerRouter&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">&lt;<span class="regexp">/BroswerRouter&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ server </span></span><br><span class="line"><span class="regexp">&lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt;</span></span><br><span class="line"><span class="regexp">    &lt;App /</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/StaticRouter&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>&lt;Redirect&gt;</code>客户端呈现 a 标签的时候，浏览器历史记录会更改状态，我们获得新的屏幕。在静态服务器 换机中，我们无法更改应用程序的状态。我们可以使用 context 来找出需要渲染的结果。我们找到了 context.url 就知道应用是否被重定向了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> context = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> markup = ReactDOMServer.renderToString(</span><br><span class="line">    &lt;StaticRouter location=&#123;req.path&#125; context=&#123;context&#125;&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">    &lt;<span class="regexp">/StaticRouter&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">if(context.url)&#123;</span></span><br><span class="line"><span class="regexp">    redirect(301,context.url)</span></span><br><span class="line"><span class="regexp">&#125;else&#123;</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="添加应用特定上下文信息"><a href="#添加应用特定上下文信息" class="headerlink" title="添加应用特定上下文信息"></a>添加应用特定上下文信息</h3><p>路由器只会添加 context.url,如果希望重定向 301或者 302 可以在希望呈现的 UI 的某个特定分支发送 404 响应，或者如果未授权则发送 401。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RedirectWithStats</span>(<span class="params">&#123;from,to,status&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;Route render=&#123;(&#123;staticContext&#125;)=&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span>(staticContext) staticContext.status = status;</span><br><span class="line">                <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">from</span>=<span class="string">&#123;from&#125;</span> <span class="attr">to</span>=<span class="string">&#123;to&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            &#125;&#125; </span></span><br><span class="line"><span class="xml">            /&gt;</span></span><br><span class="line"><span class="xml">    )</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// somewhere in app</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function App()&#123;</span></span><br><span class="line"><span class="xml">return(</span></span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;RedirectWithStatus status=&#123;301&#125; from='/users' to='/profiles' /&gt;</span><br><span class="line">            &lt;RedirectWithStatus status=&#123;302&#125; from='/courses' to='/dashboard' /&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// server</span><br><span class="line">const context = &#123;&#125;;</span><br><span class="line">const markup = ReactDOMServer.renderToString(</span><br><span class="line">    &lt;StaticRouter context=&#123;context&#125;&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">    &lt;/StaticRouter&gt;</span><br><span class="line">)</span><br><span class="line">if(context.url)&#123;</span><br><span class="line">    redirect(context.status,context.url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="404-401-或者任何其他状态"><a href="#404-401-或者任何其他状态" class="headerlink" title="404,401 或者任何其他状态"></a>404,401 或者任何其他状态</h3><p>跟上面的操作差不多，可以创建一个组件，添加一些上下文并在应用程序中的任何位置呈现它以获取不同的状态码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Status</span>(<span class="params">&#123;code,children&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;Route </span><br><span class="line">            render=&#123;(&#123;staticContext&#125;)=&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span>(staticContext) staticContext.status = code</span><br><span class="line">                <span class="keyword">return</span> children;</span><br><span class="line">            &#125;&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NotFound</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;Status code=&#123;<span class="number">404</span>&#125;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;Sorry,can<span class="string">'t find that.&lt;/h1&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/Status&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// somewhere else</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;Switch&gt;</span></span><br><span class="line"><span class="string">    &lt;Route path='</span>/about<span class="string">' component=&#123;About&#125; /&gt;</span></span><br><span class="line"><span class="string">    &lt;Route path='</span>/dashboard<span class="string">' component=&#123;Dashboard&#125; /&gt;</span></span><br><span class="line"><span class="string">    &lt;Route component=&#123;NotFound&#125;&gt;</span></span><br><span class="line"><span class="string">&lt;/Switch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>这不是一个真正的应用程序，但是它显示了将所有这些组合在一起所需要的所有常规部分</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="keyword">import</span> &#123;createServer&#125; <span class="keyword">from</span> <span class="string">'http'</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOMServer <span class="keyword">from</span> <span class="string">'react-dom/server'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;StaticRouter&#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"></span><br><span class="line">createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> html = ReactDOMServer.renderToString(</span><br><span class="line">        &lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt;</span><br><span class="line">            &lt;App /&gt;</span><br><span class="line">        &lt;<span class="regexp">/StaticRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">    if(context.url)&#123;</span></span><br><span class="line"><span class="regexp">        res.writeHead(301,&#123;</span></span><br><span class="line"><span class="regexp">            Location:context.url</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">        res.send()</span></span><br><span class="line"><span class="regexp">    &#125;else&#123;</span></span><br><span class="line"><span class="regexp">        res.write(`&lt;!doctype html&gt;&lt;div id="app"&gt;$&#123;html&#125;&lt;/</span>div&gt;<span class="string">`)</span></span><br><span class="line"><span class="string">        res.send();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;).listen(3000)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// client</span></span><br><span class="line"><span class="string">import ReactDOM from 'react-dom';</span></span><br><span class="line"><span class="string">import &#123;BrowserRouter&#125; from 'react-router-dom';</span></span><br><span class="line"><span class="string">import App from './App';</span></span><br><span class="line"><span class="string">ReactDOM.render(</span></span><br><span class="line"><span class="string">    &lt;BrowserRouter&gt;</span></span><br><span class="line"><span class="string">        &lt;App /&gt;</span></span><br><span class="line"><span class="string">    &lt;/BrowserRouter&gt;</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure><h3 id="★数据的加载"><a href="#★数据的加载" class="headerlink" title="★数据的加载"></a>★数据的加载</h3><p>在页面呈现之前加载数据，React Router 导出 matchPath 它在内部使用的静态函数，以匹配路由的位置。可以在服务器上使用此功能来帮助确定在呈现之前数据的依赖项。</p><p>这种方法的要求是依赖于静态路由的配置，用于在呈现之前根据路由匹配来加载对应的数据</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// routes.js</span></span><br><span class="line"><span class="keyword">const</span> routes = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">    path:<span class="string">'/'</span>,</span><br><span class="line">    component:Root,</span><br><span class="line">    loadData:<span class="function"><span class="params">()</span>=&gt;</span> getSomeData()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;router&#125; <span class="keyword">from</span> <span class="string">'./routes'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &#123;routes.map(<span class="function"><span class="params">route</span>=&gt;</span>(</span><br><span class="line">                &lt;Route &#123;...route&#125;/&gt;</span><br><span class="line">            ))&#125;</span><br><span class="line">        &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ server </span></span><br><span class="line"><span class="regexp">import &#123;matchPath&#125; from 'react-router-dom';</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const promises = [];</span></span><br><span class="line"><span class="regexp">routers.some(route=&gt;&#123;</span></span><br><span class="line"><span class="regexp">    const match = matchPath(req.path,route);</span></span><br><span class="line"><span class="regexp">    if(match) promises.push(route.loadData(match))</span></span><br><span class="line"><span class="regexp">    return match</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Promise.all(promises).then(data=&gt;&#123;</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><h2 id="Webpack-配置"><a href="#Webpack-配置" class="headerlink" title="Webpack 配置"></a>Webpack 配置</h2><h3 id="公共部分"><a href="#公共部分" class="headerlink" title="公共部分"></a>公共部分</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.js?$/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        presets: [<span class="string">'react'</span>, <span class="string">'stage-0'</span>, [<span class="string">'env'</span>, &#123;</span><br><span class="line">          <span class="comment">// 版本兼容大部分浏览器最后2个</span></span><br><span class="line">          targets: &#123;</span><br><span class="line">            browsers: [<span class="string">'last 2 versions'</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 不打包 node modules</span></span><br><span class="line"><span class="keyword">const</span> nodeExternals = <span class="built_in">require</span>(<span class="string">'webpack-node-externals'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.base.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> serverConfig = &#123;</span><br><span class="line">  <span class="comment">// 指明服务器</span></span><br><span class="line">  target: <span class="string">'node'</span>,</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/server/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'build'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  externals: [nodeExternals()],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.css?$/</span>,</span><br><span class="line">      <span class="comment">// 在高阶组件中通过注水跟脱水 css 来获取 css 代码，这个loader 提供了 ._getCss() 函数</span></span><br><span class="line">      use: [<span class="string">'isomorphic-style-loader'</span>, &#123;</span><br><span class="line">        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          importLoaders: <span class="number">1</span>,</span><br><span class="line">          modules: <span class="literal">true</span>,</span><br><span class="line">          localIdentName: <span class="string">'[name]_[local]_[hash:base64:5]'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(config, serverConfig);</span><br></pre></td></tr></table></figure><h4 id="webpack-node-externals"><a href="#webpack-node-externals" class="headerlink" title="webpack-node-externals"></a>webpack-node-externals</h4><p>不打包引入 的 node modules</p><h4 id="isomorphic-style-loader"><a href="#isomorphic-style-loader" class="headerlink" title="isomorphic-style-loader"></a>isomorphic-style-loader</h4><p>服务端打包 CSS 可以通过这个插件在对应的 DOM 元素上生成 class 类名，然后返回 CSS 样式代码。在高阶组件中，利用插件内置 API <code>._getCss()</code>将CSS 数据通过注水与脱水的方式在服务端获取，将这些字符串格式的 css 添加到服务器渲染的 HTML 就可以完成 CSS 服务器渲染</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.base.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clientConfig = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/client/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'index.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'public'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.css?$/</span>,</span><br><span class="line">      use: [<span class="string">'style-loader'</span>, &#123;</span><br><span class="line">        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          importLoaders: <span class="number">1</span>,</span><br><span class="line">          modules: <span class="literal">true</span>,</span><br><span class="line">          localIdentName: <span class="string">'[name]_[local]_[hash:base64:5]'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(config, clientConfig);</span><br></pre></td></tr></table></figure><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"server"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"react-ssr"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"npm-run-all --parallel dev:**"</span>,</span><br><span class="line">    <span class="attr">"dev:start"</span>: <span class="string">"nodemon --watch build --exec node \"./build/bundle.js\""</span>,</span><br><span class="line">    <span class="attr">"dev:build:server"</span>: <span class="string">"webpack --config webpack.server.js --watch"</span>,</span><br><span class="line">    <span class="attr">"dev:build:client"</span>: <span class="string">"webpack --config webpack.client.js --watch"</span>,</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [</span><br><span class="line">    <span class="string">"react"</span>,</span><br><span class="line">    <span class="string">"ssr"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"lbh"</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"axios"</span>: <span class="string">"^0.18.0"</span>,</span><br><span class="line">    <span class="attr">"babel-core"</span>: <span class="string">"^6.26.3"</span>,</span><br><span class="line">    <span class="attr">"babel-loader"</span>: <span class="string">"^7.1.5"</span>,</span><br><span class="line">    <span class="attr">"babel-preset-env"</span>: <span class="string">"^1.7.0"</span>,</span><br><span class="line">    <span class="attr">"babel-preset-react"</span>: <span class="string">"^6.24.1"</span>,</span><br><span class="line">    <span class="attr">"babel-preset-stage-0"</span>: <span class="string">"^6.24.1"</span>,</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^2.1.1"</span>,</span><br><span class="line">    <span class="attr">"express"</span>: <span class="string">"^4.16.4"</span>,</span><br><span class="line">    <span class="attr">"express-http-proxy"</span>: <span class="string">"^1.5.1"</span>,</span><br><span class="line">    <span class="attr">"isomorphic-style-loader"</span>: <span class="string">"^5.0.1"</span>,</span><br><span class="line">    <span class="attr">"react"</span>: <span class="string">"^16.8.6"</span>,</span><br><span class="line">    <span class="attr">"react-dom"</span>: <span class="string">"^16.8.6"</span>,</span><br><span class="line">    <span class="attr">"react-helmet"</span>: <span class="string">"^5.2.0"</span>,</span><br><span class="line">    <span class="attr">"react-redux"</span>: <span class="string">"^7.0.1"</span>,</span><br><span class="line">    <span class="attr">"react-router-config"</span>: <span class="string">"^5.0.0"</span>,</span><br><span class="line">    <span class="attr">"react-router-dom"</span>: <span class="string">"^5.0.0"</span>,</span><br><span class="line">    <span class="attr">"redux"</span>: <span class="string">"^4.0.1"</span>,</span><br><span class="line">    <span class="attr">"redux-thunk"</span>: <span class="string">"^2.3.0"</span>,</span><br><span class="line">    <span class="attr">"style-loader"</span>: <span class="string">"^0.23.1"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.29.6"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.0"</span>,</span><br><span class="line">    <span class="attr">"webpack-merge"</span>: <span class="string">"^4.2.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-node-externals"</span>: <span class="string">"^1.7.2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nodemon"><a href="#nodemon" class="headerlink" title="nodemon"></a>nodemon</h4><p>一个本地服务器，可以监控文件的变化来重启服务器，全局安装</p><h4 id="npm-run-all"><a href="#npm-run-all" class="headerlink" title="npm-run-all"></a>npm-run-all</h4><p>并行运行同名前缀的所有 <code>script</code> 语句，全局安装</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-SSR-同构浅析&quot;&gt;&lt;a href=&quot;#React-SSR-同构浅析&quot; class=&quot;headerlink&quot; title=&quot;React SSR 同构浅析&quot;&gt;&lt;/a&gt;React SSR 同构浅析&lt;/h2&gt;&lt;h2 id=&quot;客户端渲染（CSR）&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="react" scheme="http://laibh.top/categories/react/"/>
    
    
      <category term="react" scheme="http://laibh.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题目汇总摘录（JS 基础篇3）</title>
    <link href="http://laibh.top/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E6%91%98%E5%BD%95-JS%20%E5%9F%BA%E7%A1%80%E7%AF%873.html"/>
    <id>http://laibh.top/前端面试题目汇总摘录-JS 基础篇3.html</id>
    <published>2019-04-23T01:30:54.000Z</published>
    <updated>2022-03-04T10:00:38.468Z</updated>
    
    <content type="html"><![CDATA[<p>温故而知新，保持空杯心态,复习到一半的时间，突然发现了 <a href="https://yuchengkai.cn/docs/frontend">前端面试之道</a>，按学习这本书的路径来</p><h2 id="JS-基础3"><a href="#JS-基础3" class="headerlink" title="JS 基础3"></a>JS 基础3</h2><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>前端监控一般分为三种，页面埋点、性能监控以及异常监控</p><h3 id="页面埋点"><a href="#页面埋点" class="headerlink" title="页面埋点"></a>页面埋点</h3><p>页面埋点一般会监控下面几个数据：</p><ul><li>PV/UV</li><li>停留时长</li><li>流量来源</li><li>用户交互</li></ul><p>实现的思路分成两种，手写埋点和无埋点的方式</p><p>第一种自主选择需要监控的数据然后在相应的地方写入代码，这种方式灵活性很大，唯一的缺点就是工作量大，每个需要监控的地方都要插入代码</p><p>另一种的无埋点的方式基本不需要开发者手写埋点，而是统计所有的事件并且定时上报，这种方式虽然没有前一种繁琐，但是因为统计的是所有事件，所以还需要后期过滤出需要的数据</p><h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><p>可以使用浏览器期自带的  <a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FPerformance">Performance API</a> 来实现功能。一行代码就可以获得页面中各种详细的性能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">performance.getEntriesByType(<span class="string">'navigation'</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">    PerformanceNavigationTiming:&#123;</span></span><br><span class="line"><span class="comment">        connectEnd: 3.9999999999906777</span></span><br><span class="line"><span class="comment">        connectStart: 3.9999999999906777</span></span><br><span class="line"><span class="comment">        decodedBodySize: 0</span></span><br><span class="line"><span class="comment">        domComplete: 22873.60000000001</span></span><br><span class="line"><span class="comment">        domContentLoadedEventEnd: 22690.200000000004</span></span><br><span class="line"><span class="comment">        domContentLoadedEventStart: 22689.999999999996</span></span><br><span class="line"><span class="comment">        domInteractive: 22689.999999999996</span></span><br><span class="line"><span class="comment">        domainLookupEnd: 3.9999999999906777</span></span><br><span class="line"><span class="comment">        domainLookupStart: 3.9999999999906777</span></span><br><span class="line"><span class="comment">        duration: 22873.700000000015</span></span><br><span class="line"><span class="comment">        encodedBodySize: 0</span></span><br><span class="line"><span class="comment">        entryType: "navigation"</span></span><br><span class="line"><span class="comment">        fetchStart: 3.9999999999906777</span></span><br><span class="line"><span class="comment">        initiatorType: "navigation"</span></span><br><span class="line"><span class="comment">        loadEventEnd: 22873.700000000015</span></span><br><span class="line"><span class="comment">        loadEventStart: 22873.60000000001</span></span><br><span class="line"><span class="comment">        name: ""</span></span><br><span class="line"><span class="comment">        nextHopProtocol: ""</span></span><br><span class="line"><span class="comment">        redirectCount: 0</span></span><br><span class="line"><span class="comment">        redirectEnd: 0</span></span><br><span class="line"><span class="comment">        redirectStart: 0</span></span><br><span class="line"><span class="comment">        requestStart: 3.9999999999906777</span></span><br><span class="line"><span class="comment">        responseEnd: 726.4000000000124</span></span><br><span class="line"><span class="comment">        responseStart: 3.9999999999906777</span></span><br><span class="line"><span class="comment">        secureConnectionStart: 0</span></span><br><span class="line"><span class="comment">        serverTiming: []</span></span><br><span class="line"><span class="comment">        startTime: 0</span></span><br><span class="line"><span class="comment">        transferSize: 0</span></span><br><span class="line"><span class="comment">        type: "back_forward"</span></span><br><span class="line"><span class="comment">        unloadEventEnd: 0</span></span><br><span class="line"><span class="comment">        unloadEventStart: 0</span></span><br><span class="line"><span class="comment">        workerStart: 0</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-性能监控.png" alt="性能监控"></p><h3 id="异常监控"><a href="#异常监控" class="headerlink" title="异常监控"></a>异常监控</h3><p>对于代码运行错误，通常的办法是使用 window.onerror 拦截报错，该方法能拦截到大部分的详细报错信息，但是也有例外的</p><ul><li>对于跨域的代码运行错误会显示 script error 对于这种情况需要给 script 标签添加 crossorigin 属性</li><li>对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 arguments.callee.caller 来做栈递归</li></ul><p>对于异步代码来说，可以使用 catch 的方式捕获错误。比如 Promise 可以直接使用 catch 函数，async await 可以使用 try catch</p><p>线上的代码是经过压缩的，打包的时候要设置 sourceMap</p><h2 id="常考的面试题目：UDP-与-TCP-的区别是什么？"><a href="#常考的面试题目：UDP-与-TCP-的区别是什么？" class="headerlink" title="常考的面试题目：UDP 与 TCP 的区别是什么？"></a>常考的面试题目：UDP 与 TCP 的区别是什么？</h2><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP 协议是面向无连接，不需要在正式传递数据之前先连接双方，然后 UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且 UDP 协议也没有任何控制流量的算法，总的来说 UDP 相较于 TCP 更加的轻便</p><h3 id="面向无连接"><a href="#面向无连接" class="headerlink" title="面向无连接"></a>面向无连接</h3><p>UDP 不要跟 TCP 一样在发送数据前进行三次握手建立连接，想发数据就可以发送了。</p><p>并且也只是数据的搬运工，不会对数据进行拆分和拼接操作。</p><p>具体来说：</p><ul><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给应用层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作。</li></ul><h3 id="不可靠性"><a href="#不可靠性" class="headerlink" title="不可靠性"></a>不可靠性</h3><p>不可靠性体现在无连接上，通信都不需要建立连接，想发就发。不用备份，也不用关心对方是否已经正确接收到数据。UDP 没有拥塞控制，一直会以恒定的速度发送数据，即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端是在网络条件不好的情况下可能会导致丢包，但是优点很明显是在某些实时性要求很高的场景（如电话会议）就需要使用 UDP 而不是 TCP</p><h3 id="高效"><a href="#高效" class="headerlink" title="高效"></a>高效</h3><p>UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要小得多，在传输数据报文时是很高效的。</p><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-UDP.png" alt="UDP"></p><p>UDP 头部包含了以下几个数据：</p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误</li></ul><h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对一的方式，也就说说 UDP 提供了单播，多播，广播的功能。</p><h3 id="适用的场景"><a href="#适用的场景" class="headerlink" title="适用的场景"></a>适用的场景</h3><p>在很多实时性要求很高的地方都可以看到 UDP 的身影</p><h4 id="直播"><a href="#直播" class="headerlink" title="直播"></a>直播</h4><p>如果使用基于 TCP 的协议，TCP 会严格控制传输的正确性，一旦有某个数据对端没有收到，就会停下来直到对端收到这个数据。这种问题在网络条件不错的情况下不会有问题，但是如果网络差就会变成画面卡着，然后在继续播放下一帧的情况。</p><p>TCP 这种情况下会降低用户体验，不适合</p><h4 id="王者荣耀"><a href="#王者荣耀" class="headerlink" title="王者荣耀"></a>王者荣耀</h4><p>作者说不知道王者荣耀底层是使用了什么协议，但是对于这种实时性很高的游戏来说，UDP 是跑不了的。用户体量相当大的情况下，如果使用 TCP 连接可能会出现服务器不够用情况，因为每台服务器可供支撑的 TCP 连接数据是有限制的。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-TCP.png" alt="TCP"></p><p>对于TCP 头部来说，以下几个字段是很重要的</p><ul><li>Sequence number，这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文</li><li>Acknowledgement Number，这个序号表示数据接收端期望接受的下一个字节编号是多少，同时也表示上一序号的数据已经收到</li><li>Window Size,窗口大小，表示还能接受多少字节的数据，用于流量控制</li><li>标识符<ul><li>UGR=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指标标明了紧急数据的尾部。</li><li>ACK=1：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须要把 ACK 置为一</li><li>PSH=1：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交</li><li>RST=1：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立连接，也可以用于拒绝非法的报文段和拒绝连接请求</li><li>SYN=1：当 SYN = 1,ACK=0时，表示当前报文段是一个连接请求报文。当 SYN=1,ACK=1时，表示当前报文daunt是一个同意连接的应答报文</li><li>FIN=1：该字段为一表示此报文是一个释放连接的请求报文</li></ul></li></ul><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p>TCP 的状态机是很复杂的，并且与建立连接时的握手息息相关</p><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-状态机.png" alt="状态机"></p><p>一个重要的性能指标 RTT.该指标表示发送端发送数据到接收到对端所需的往返时间</p><h3 id="建立连接三次握手"><a href="#建立连接三次握手" class="headerlink" title="建立连接三次握手"></a>建立连接三次握手</h3><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-三次握手.png" alt="三次握手"></p><p>首先假设主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP 连接建立完后都可以发送和接收数据，所以 TCP 是一个全双工的协议。</p><p>起初，两端都是 CLOSED 状态，在通信开始前，双方都会建立 TCB,服务端创建完TCB 后便进入 LISTEN 状态，此时开始等待客户端发送数据</p><h4 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h4><p>客户端向服务端发送连接请求报文段，该报文段中包含自身数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态</p><h4 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h4><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</p><h4 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h4><p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端接收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功</p><p>第三次握手中可以包含数据，通过快速打开（TFO）技术就可以实现这一功能。其中只要涉及到握手的协议，都可以使用类似 TFO 方式，客户端和服务端存储相同的 cookie ，下次握手发出 cookie 达到减少 RTT 的目的。</p><p><strong>为什么TCP 建立连接需要三次握手，明明两次就可以建立起连接？</strong></p><p>因为这是为了防止出现失效的连接请求报文段被服务端接收后，从而产生错误。</p><p>如果客户端发送了一个连接报文请求A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求报文B。此时请求顺利达到服务器，服务端应答完就建立了请求，然后接受数据后释放了连接。</p><p>假设这时候请求 A 在两端关闭后终于达到了服务端，那么此时服务端会认为客户端有需要建立 TCP 连接，从而应答了该请求并进入了 ESTABLISHED 状态，但是实际上客户端是 CLOSED 状态，那么就会导致服务端一直等待，造成资源的浪费。</p><p>在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试5次，在建立连接可能遇到 SYN Flood 攻击。遇到这种情况可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求。</p><h3 id="断开连接四次握手"><a href="#断开连接四次握手" class="headerlink" title="断开连接四次握手"></a>断开连接四次握手</h3><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-断开连接四次握手.png" alt="四次握手"></p><p>TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK</p><h4 id="第一次握手-1"><a href="#第一次握手-1" class="headerlink" title="第一次握手"></a>第一次握手</h4><p>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。</p><h4 id="第二次握手-1"><a href="#第二次握手-1" class="headerlink" title="第二次握手"></a>第二次握手</h4><p>B 收到连接释放请求后，会告诉应用层就要释放 TCP 连接，然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双工的，所以 B 依旧可以发送数据给 A</p><h4 id="第三次握手-1"><a href="#第三次握手-1" class="headerlink" title="第三次握手"></a>第三次握手</h4><p>B 如果此时还有没有发完的数据会继续发送，完毕后向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送</p><h4 id="第四次握手"><a href="#第四次握手" class="headerlink" title="第四次握手"></a>第四次握手</h4><p>A 收到释放请求后，向 B 发送确认应答，A 进入 TIME-WAIT 状态。该状态会持续 2MSL(最大生存期，指报文段在网络中生存的时间，超时会被抛弃)时间，若该时间段内没有 B 的重发请求的话，就会进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态</p><p><strong>为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后再进入CLOSED 状态？</strong></p><p>为了保证 B 能接受到 A 的确认应答，若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭</p><h2 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h2><p>ARQ 协议也就是超时重传机制。通过确认和超时机制保证了数据的正确送达，ARQ 协议包含停止等待 ARQ 和连续 ARQ 两种协议</p><h3 id="停止等待-ARQ"><a href="#停止等待-ARQ" class="headerlink" title="停止等待 ARQ"></a>停止等待 ARQ</h3><h4 id="正常传输协议"><a href="#正常传输协议" class="headerlink" title="正常传输协议"></a>正常传输协议</h4><p>只要 A 向 B 发送一段报文，都要停止发送并且启动一个定时器，等待对端应答，在定时器内接收到对端应答就取消定时器并发送下一段报文</p><h4 id="报文丢失或者出错"><a href="#报文丢失或者出错" class="headerlink" title="报文丢失或者出错"></a>报文丢失或者出错</h4><p>在报文传输过程中可能会出现丢包，这时候超过定时器设定的时间就会再次发送丢失的数据直到对端响应，所以需要每次都备份发送的数据</p><p>即使报文正常传输到对端，有可能出现在传输过程中的报文出错的问题。这时候对端会抛弃该报文并等待 A 端重传</p><p>一般定时器设定的时间会大于一个 RTT 的平均时间</p><h4 id="ACK-超时或者丢失"><a href="#ACK-超时或者丢失" class="headerlink" title="ACK 超时或者丢失"></a>ACK 超时或者丢失</h4><p>对端传输的应答也可能出现丢失或者超时的情况，那么超过定时器时间 A 端照样会重报文，这时候 B 端会接收到相同序号的报文之后丢弃该报文并重传应答，直到 A 端发送下一个序号的报文。</p><p>在超时的情况下也可能会出现应答很迟到达，这时候 A 端会判断该序号是否已经接收过，如果接收过只需要丢弃应答即可。</p><p>假设在良好的网络环境中，每次发送数据都需要等待片刻肯定是不能接受的，这个协议看起来不是很高效。</p><h3 id="连续ARQ"><a href="#连续ARQ" class="headerlink" title="连续ARQ"></a>连续ARQ</h3><p>在连续 ARQ 中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待 ARQ 协议来说减少了等待时间，提高了效率</p><h4 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h4><p>连续 ARQ 中，接收端会持续不断收到报文，如果和停止等待 ARQ 中接收一个报文就发送一个应答一样，就太浪费资源了。通过累计确认，可以在收到多个报文以后统一回复一个应答报文。报文中的 ACK 标示位可以用来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号后的数据。</p><p>但是累计确认也有一个弊端，在连续接收报文时，可能会遇到接收到序号5 的报文后，并未接收到序号6 的报文，然而序号7 的报文已经接收。遇到这种情况，ACK 只能回复 6，这样就会造成发送端重复发送数据的情况。</p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>TCP 中，两端其实都维护者窗口，分别为发送端窗口和接收端窗口</p><p>发送端窗口包含已经发送但未收到应答的数据和可以发送但是未发送的数据</p><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-滑动窗口1.png" alt="滑动窗口1"></p><p>发送端窗口是由接收端窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。</p><p>当发送端接收到应答报文后，会随着窗口进入滑动。</p><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-滑动窗口2.png" alt="滑动窗口2"></p><p>滑动窗口是一个很重要概念，它帮助了 TCP 实现了流量控制的功能。接收方通过报文告知发送方还可以发送多少数据，从而保证了接收方能够来得及接收数据，防止出现接收方带宽已满，但是发送方还是一直发送数据的情况。</p><h4 id="zero-窗口"><a href="#zero-窗口" class="headerlink" title="zero 窗口"></a>zero 窗口</h4><p>在发送报文的过程中，可能会遇到对端出现零窗口的情况，在该情况下，发送端会停止发送数据，并启动 persistent timer.该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断 TCP 链接。</p><h3 id="拥塞处理"><a href="#拥塞处理" class="headerlink" title="拥塞处理"></a>拥塞处理</h3><p>拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接收数据，而后者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</p><p>拥塞处理包括了四个算法，分别是：慢开始，拥塞避免，快速重传，快递恢复</p><h4 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h4><p>慢开始算法，就是在传输开始时将发送窗口慢慢指数等级扩大，从而避免一开始就传输最大量数据导致网络阻塞。</p><p>慢开始算法步骤具体如下：</p><ol><li>连接初始设置拥塞窗口（Congestion Window）为 1 MSS(一个分段的最大数据量)</li><li>每过一个 RTT 将窗口大小乘二</li><li>指数级增加肯定不能没有限制的，所以有一个阈值限制，当窗口大于阈值就会启动拥塞避免算法</li></ol><h4 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h4><p>拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加一，这样就能避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值</p><p>在传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞，会马上进行一下步骤：</p><ol><li>将阈值设定为当前拥塞窗口的一半</li><li>将拥塞窗口设定为 1MSS</li><li>启动拥塞避免算法</li></ol><h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号。如果发送端收到三个重复的 ACK ,无需等待定时器超时而是启动快速重传算法。具体是：<br>TCP Taho 的实现：</p><ul><li>将阈值设为当前阈值的一般</li><li>将拥塞窗口设为 1MSS</li><li>重新开始慢开始算法</li></ul><p>TCP Reno 实现：</p><ul><li>拥塞窗口减半</li><li>将阈值设定为当前拥塞窗口</li><li>进入块恢复阶段（重发对端需要的包，一旦接收到一个新的 ACK 答复就退出该阶段），这种方在丢失多个包的情况下就不那么友好了</li><li>使用拥塞避免算法</li></ul><h4 id="TCP-New-Ren-改进后的快恢复"><a href="#TCP-New-Ren-改进后的快恢复" class="headerlink" title="TCP New Ren 改进后的快恢复"></a>TCP New Ren 改进后的快恢复</h4><p><strong>TCP New Reno</strong> 算法改进了之前 <strong>TCP Reno</strong> 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。</p><p>在 <strong>TCP New Reno</strong> 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。</p><p>假如我有一个分段数据是 1 ~ 10 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收的话就会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>TCP建立连接需要三次握手，断开连接需要四次握手</li><li>滑动窗口解决了数据的丢包、顺序不对和流量控制的问题</li><li>拥塞窗口实现了对流量的控制，保证全天候环境下最优的传递数据</li></ul><h2 id="HTTP-以及-TLS"><a href="#HTTP-以及-TLS" class="headerlink" title="HTTP 以及 TLS"></a>HTTP 以及 TLS</h2><h3 id="HTTP-请求的内容"><a href="#HTTP-请求的内容" class="headerlink" title="HTTP 请求的内容"></a>HTTP 请求的内容</h3><p>HTTP 请求由三部分组成，分别是：</p><ul><li>请求行</li><li>首部</li><li>实体</li></ul><p>请求行基本由请求方法、URL、版本协议组成。</p><p>请求方法分很多种，POST,GET,HEAD,OPTION,等等，更多具体的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods">点击这里</a></p><h3 id="副作用和幂等"><a href="#副作用和幂等" class="headerlink" title="副作用和幂等"></a>副作用和幂等</h3><p>副作用是指对服务器上的资源做改变，搜素是无副作用的，注册是副作用的。</p><p>幂等指发送 M 和 N 次请求（两者不同且大于1），服务器上资源的状态一致，比如注册10个和11个账号是不幂等的，对文章进行更改10次和11次是幂等的。因为前者多了一个账号（资源），后者只是更新同一个资源</p><p>在规范的应用场景来说，Get 多用于无副作用的，幂等的场景，例如搜索关键字。Post 多用于副作用的，不幂等的场景，例如注册</p><p>技术上来说：</p><ul><li>Get 请求能缓存，Post 不能</li><li>Post 相对 Get 安全一点，因为GET 请求都包含在 URL 里面，且会被浏览器保存历史记录。而 Post 不会，但是在抓包的情况下是一样的。</li><li>URL 有长度限制，会影响 GET 请求，但是这个长度限制是浏览器限制的，不是 RFC 规定的</li><li>Post 支持更多的编码并且不对数据类型限制</li></ul><h3 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h3><p>首部分成请求首部和响应首部，并且部分首部两种通用。下面是常见的首部</p><h4 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h4><table><thead><tr><th>通用字段</th><th>作用</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制缓存的行为</td></tr><tr><td>Connection</td><td>浏览器想要优先使用的连接类型，比如 keep-alive</td></tr><tr><td>Date</td><td>创建报文的时间</td></tr><tr><td>Pragma</td><td>报文指令</td></tr><tr><td>Via</td><td>代理服务器相关信息</td></tr><tr><td>Transfer-Encoding</td><td>制定报文主体的传输编码方式</td></tr><tr><td>Upgrade</td><td>要求客户端升级协议</td></tr><tr><td>Warning</td><td>在内容中可能存在错误</td></tr></tbody></table><p>具体解释的可以<a href="http://laibh.top/2018-08-16-read-%E5%9B%BE%E8%A7%A3HTTP-Part6%E4%B8%8A.html">点击这里</a></p><h4 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h4><table><thead><tr><th>请求首部</th><th>作用</th></tr></thead><tbody><tr><td>Accept</td><td>能正确接收的媒体类型</td></tr><tr><td>Accept-Charset</td><td>能正确接收的字符集</td></tr><tr><td>Accept-Encoding</td><td>能正确接收的编码格式列表</td></tr><tr><td>Accept-Language</td><td>能正确接收的语言列表</td></tr><tr><td>Expect</td><td>期待服务端的指定行为</td></tr><tr><td>From</td><td>请求方邮箱地址</td></tr><tr><td>Host</td><td>服务器的域名</td></tr><tr><td>If-Match</td><td>两端资源标记比较</td></tr><tr><td>If-Modified-Since</td><td>本地资源未修改返回 304（比较时间）</td></tr><tr><td>If-None-Match</td><td>本地资源未修改返回 304（比较标记）</td></tr><tr><td>User-Agent</td><td>客户端信息</td></tr><tr><td>Max-Forwards</td><td>限制可被代理以及网关转发的次数</td></tr><tr><td>Proxy-Authorization</td><td>向代理服务器发送验证信息</td></tr><tr><td>Range</td><td>请求某个内容的一部分</td></tr><tr><td>Referer</td><td>表示浏览器所访问的前一个页面</td></tr><tr><td>TE</td><td>传输编码方式</td></tr></tbody></table><h4 id="响应首部"><a href="#响应首部" class="headerlink" title="响应首部"></a>响应首部</h4><table><thead><tr><th>响应头部</th><th>作用</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>是否支持某些种类的范围</td></tr><tr><td>Age</td><td>资源在代理缓存中存在的时间</td></tr><tr><td>ETag</td><td>资源标识</td></tr><tr><td>Location</td><td>客户端重定向到某个 URL</td></tr><tr><td>Proxy-Authenticate</td><td>想代理服务器发送验证信息</td></tr><tr><td>Server</td><td>服务器名字</td></tr><tr><td>WWW-Authenticate</td><td>获取资源需要的验证信息</td></tr></tbody></table><h4 id="实体首部"><a href="#实体首部" class="headerlink" title="实体首部"></a>实体首部</h4><table><thead><tr><th>实体首部</th><th>作用</th></tr></thead><tbody><tr><td>Allow</td><td>资源的正确请求方式</td></tr><tr><td>Content-Encoding</td><td>内容编码的格式</td></tr><tr><td>Content-Language</td><td>内容使用的语言</td></tr><tr><td>Content-Length</td><td>request body 长度</td></tr><tr><td>Content-Location</td><td>返回数据的备用地址</td></tr><tr><td>Content-MD5</td><td>Base64 加密格式的内容 MD5 校验值</td></tr><tr><td>Content-Range</td><td>内容的位置范围</td></tr><tr><td>Content-Type</td><td>内容的媒体类型</td></tr><tr><td>Expires</td><td>内容的过期时间</td></tr><tr><td>Last_modified</td><td>内容的最后修改时间</td></tr></tbody></table><h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3><p>状态码的责任是当客户端向服务端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务单是正常处理了请求，还是出现了错误。</p><h4 id="状态码的类别"><a href="#状态码的类别" class="headerlink" title="状态码的类别"></a>状态码的类别</h4><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">类别</th><th style="text-align:left">原因短语</th></tr></thead><tbody><tr><td style="text-align:left">1XX</td><td style="text-align:left">Information（信息性状态码）</td><td style="text-align:left">接受的请求正在处理</td></tr><tr><td style="text-align:left">2XX</td><td style="text-align:left">Success（成功状态码）</td><td style="text-align:left">请求正常处理完毕</td></tr><tr><td style="text-align:left">3XX</td><td style="text-align:left">Redirection（重定向状态码）</td><td style="text-align:left">需要进行附加操作以完成请求</td></tr><tr><td style="text-align:left">4XX</td><td style="text-align:left">Client Error（客户端错误状态码）</td><td style="text-align:left">服务器无法处理请求</td></tr><tr><td style="text-align:left">5XX</td><td style="text-align:left">Server Error（服务器错误状态码）</td><td style="text-align:left">服务器处理请求出错</td></tr></tbody></table><h4 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h4><ul><li>200 OK,表示从客户端发来的请求在服务端被正确处理</li><li>204，No content，表示请求成功，但响应报文不含实体的主体部分</li><li>205，Reset Content，表示请求成功，但响应报文不含实体的主体部分，与204响应不同的是要求请求方重置内容</li><li>206 Partial Content，表示对客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求，响应报文中由 Content-Range 指定范围的实体内容</li></ul><h4 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h4><ul><li>301 moved permanently,永久性重定向，表示资源已被分配到了新的 URL</li><li>302 found,临时重定向，表示资源临时被分配了新的 URL</li><li>303 see other，表示资源存在着另一个 URL应使用 GET 方法获取资源</li><li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li><li>307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求。</li></ul><h4 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h4><ul><li>400 bad request，请求报文存在语法错误</li><li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证消息</li><li>403 fobidden，表示对请求资源的访问被服务器拒绝</li><li>404 no found,表示在服务器上没有找到请求的资源</li></ul><h4 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h4><ul><li>500 internal server error,表示服务器端在执行请求时发生了错误</li><li>501 Not Implemented,表示服务器不支持当期请求所需要的某个功能</li><li>503 service unavaliable,表示服务器暂时处于超负载或者停机服务，无法处理请求</li></ul><h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><p>HTTPS 通过 HTTP 来传输信息，但是信息通过 TLS 协议进行了 加密</p><p>TLS 协议位于传输层之上，应用层之下。首先进行 TLS 协议传输需要两个 RTT,可以通过 Session Resumption 减少到一个 RTT</p><p>在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。</p><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>对称加密就是两边都拥有相同的密钥，两边都知道药怎么将密文加密解密</p><p>这种加密方式缺点在于因为传输数据走的都是网络，如果密钥被截获那就没有加密的意义了</p><h4 id="非对称机密"><a href="#非对称机密" class="headerlink" title="非对称机密"></a>非对称机密</h4><p>有公钥私钥之分，公钥所有人都可以知道，如果将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。</p><p>这种加密方式就可以完美解决对称加密存在的问题，假设两端都需要使用对称加密，那么在这之前，可以先使用非对称加密交换密钥。</p><p>简单流程化如下：服务端将公钥发布出去，那么客户端也知道公钥，就下来客户端创建了一个密钥，然后通过公钥加密后发送给服务端，服务端接收到私钥解密出正确的密钥，这时候两端就都知道密钥是什么了。</p><p>TLS 握手过程如下图：</p><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-TLS握手协议.png" alt="TLS 握手协议"></p><ol><li>客户端发送一个随机值以及需要的协议和加密方式</li><li>服务端收到客户端的随机值，自己也产生了一个随机值，并根据客户端的需求的协议和加密方式来使用对应的方式，并且发送自己的证书（如果需要验证客户端证书需要说明）</li><li>客户端收到服务端的证书验证是否有效，验证通过会生成一个随机值，通过服务端证书的公钥加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书</li><li>服务端收到加密过的随机值并使用私钥解密获得三个随机值，这时候两端都有三个随机值，可以通过这三个随机值按照之前的约定的加密方式生成密钥，接下来的通信既可以使用该密钥加密解密了。</li></ol><p>通过上面步骤，可以知道 TLS 握手阶段，两端使用非对称加密的方式进行通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据的时候，两端使用对称加密的方式进行通信。</p><p>关于 http 安全的具体可以<a href="http://laibh.top/2018-08-29-read-%E5%9B%BE%E8%A7%A3HTTP-Part7.html">点击这里</a></p><h3 id="HTTP-2-以及-HTTP-3"><a href="#HTTP-2-以及-HTTP-3" class="headerlink" title="HTTP/2 以及 HTTP/3"></a>HTTP/2 以及 HTTP/3</h3><p>HTTP/2 很好的解决了当下最常用的 HTTP/1 所存在的一些性能问题，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，当然兼容问题以及如何优雅降级应该是国内还不普遍使用的原因之一。</p><p>虽然 HTTP/2 已经解决了很多问题，但是并不代表它已经是完美的了，HTTP/3 就是为了解决 HTTP/2 所存在的一些问题而被推出来的。</p><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><p>HTTP/2 相比对 HTTP/1 可以说是大幅度提高了网页的性能。</p><p>在 HTTP/1 为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量（Chrome 下一般是限制六个连接），当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</p><p>在 HTTP/2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。</p><p>大家可以通过 <a href="https://link.juejin.im/?target=https%3A%2F%2Fhttp2.akamai.com%2Fdemo">该链接</a> 感受下 HTTP/2 比 HTTP/1 到底快了多少。</p><h3 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a>二进制传输</h3><p>HTTP/2 中所有加强性能的核心在于此，在之前的 HTTP 版本，我们是通过文本的方式传输数据，在 HTTP/2 中引入了新的编码机制，所有的传输数据都会被分割，并采用二进制格式编码。</p><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-二进制传输.png" alt="二进制传输"></p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>在 HTTP/2 中有两个非常重要的概念，分别是 帧（frame）和 流 （stream）</p><p>帧代表着最小的数据单位，每个帧都会标识出该帧属于哪个流，流也就是多个帧组成的数据流</p><p>多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的对头阻塞的问题，极大提高了传输的性能。</p><h3 id="Header-压缩"><a href="#Header-压缩" class="headerlink" title="Header 压缩"></a>Header 压缩</h3><p>在 HTTP/1 中使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千字节。</p><p>在 HTTP/2 中使用 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header。后面在传输过程中可以传输以及记录过的 header 的键名，对端收到的数据后就可以通过键名找到对应的值</p><h3 id="服务端-Push"><a href="#服务端-Push" class="headerlink" title="服务端 Push"></a>服务端 Push</h3><p>在 HTTP/2 中，服务端可以在客户端某个请求后，主动推送其他资源</p><p>某些资源客户端是一定会请求的，这时候可以采用服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下也可以使用 prefetch</p><h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h3><p>底层的 TCP 协议导致 HTTP/2 版本存在一个问题，因为使用了多路复用，一般来说同一个域名下面只需要一个 TCP 连接。当这个连接中出现了丢包的情况，就会导致 HTTP/2 的表现不如 HTTP/1</p><p>在丢包的情况下，整个 TCP 都要开始等待重传，就导致了后面的所有的数据都会被阻塞。但是对于 HTTP/1 来说可以开启多个 TCP 连接，出现这种情况只会影响一个连接，剩余的 TCP 连接可以正常传输数据</p><p>这个协议是由操作系统实现的，如果要去修改 TCP 协议看起来不怎么现实。</p><p>基于这个原因，Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上，</p><p>HTTP/3 之前名为 HTTP-over-QUIC</p><h4 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h4><p>UDP 协议虽然效率很高，但是并不是那么的可靠.QUIC 是基于 UDP ,在原生的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等功能。</p><h4 id="多路复用-1"><a href="#多路复用-1" class="headerlink" title="多路复用"></a>多路复用</h4><p>虽然 HTTP/2 支持多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 就原生实现了这个功能，并且传输的单个数据流可以保证有序交付但不会影响其他的数据流，这样的技术就解决了之前的 TCP 存在的问题。</p><p>并且 QUIC 在移动端会比 TCP 好，因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是因为 QUIC 是通过 ID 的方式去识别一个连接的，不会随着网络的变化而变化，可以迅速重连上。</p><h4 id="0-RRT"><a href="#0-RRT" class="headerlink" title="0-RRT"></a>0-RRT</h4><p>通过使用类似 TCP 的快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。</p><h4 id="纠错机制"><a href="#纠错机制" class="headerlink" title="纠错机制"></a>纠错机制</h4><p>假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。当出现其中的非校验丢包的 情况的时候，可以通过另外三个包计算出丢失的数据包的内容。</p><p>当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li>HTTP/2 通过多路复用、二进制流、header 压缩等技术，极大提高了性能，但是还是存在着问题</li><li>QUIC 基于 UDP 实现，是 HTTP/3 中底层支撑协议，该协议基于 UDP，而且拿了 TCP 中的精华，实现了又快有可靠的协议</li></ul><p>关于 HTTP/3 更多<a href="http://www.sohu.com/a/299243519_115128">点击这里</a></p><h2 id="输入-URL-到页面渲染的整个过程"><a href="#输入-URL-到页面渲染的整个过程" class="headerlink" title="输入 URL 到页面渲染的整个过程"></a>输入 URL 到页面渲染的整个过程</h2><p>首先是 DNS 查询，如果这一步做到了智能 DNS 解析的话，会提供速度最快的 IP 地址回来</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS 的作用就是通过域名查询到具体的 IP 地址</p><p>因为 IP 存在数据和英文的组合（IPv6），不利于记忆，所以就出现了域名，可以把它看成某个 IP 地址的别名，DNS 就是通过这个别名去查询真正的名字是什么</p><p>在 TCP 握手之前以及先进行了 DNS 查询，这个查询是操作系统自己做的，在浏览器中访问 <a href="http://www.googel.com">www.googel.com</a> 的时候，会进行以下的操作：</p><ol><li>操作系统会首先在本地缓存中查询 IP</li><li>没有的话就会去系统配置的 DNS 服务器中查询</li><li>如果这时候还没有找到，就会直接去 DNS 根服务器查询，这一步查询会找出负责 <code>com</code>这个域名的服务器</li><li>然后去该服务器查询  <code>google</code>这个二级域名</li><li>接下来是三级域名的查询，这个是我们自己配置的，可以给 <code>www</code> 这个域名配置一个IP,然后还可以给别的三级域名配置一个 IP</li></ol><p>上面是DNS 迭代查询，还有一种格式递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果将数据返回给客户端。</p><p>DNS 是基于 UDP 做的查询</p><p>接下来是 TCP 握手协议，应用层会下发数据给传输层，这里的 TCP 协议会指明两端的端口号，然后下发给网络层。网络层的 IP 协议会确定 IP 地址，并制定了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了。</p><p>在这一部分中，TCP 握手结束后，会进行 TLS 握手，然后开始正式的传输数据了。</p><p>数据在进入服务端之前，可能还会警告负责负载均衡的服务器，它的作用是将请求合理的分发到多态服务器上面，这时假设服务端会响应一个 HTML 文件</p><p>首先浏览器会判断状态码是什么，如果是200 就继续解析，如果是 400 或者 500 的话就会报错，如果是 300 就会重定向，这里会有一个 重定向计数器，避免多次的重定向，超过次数也会报错。</p><p>浏览器开始解析文件，如果是 gzip 格式的会先解压一下，然后通过文件的编码格式知道该如何取解码文件。</p><p>文件解码后就会正式开始渲染流程，先根据 HTML 创建 DOM 树，有 CSS 的话就是 CSSOM 树，如果遇到 script 标签的话，会判断是否存在 async 或者 defer,前者会并行进行下载并执行 JS,后者会先下载文件，然后等待 HTML 解析完成后顺序执行。</p><p>如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到下载文件就会去下载文件，如果使用 HTTP/2 协议的话就会极大提高多图的下载效率</p><p>CSSOM 树 和 DOM 树构建完成之后会生成 render 树，这一步就是确定页面布局、样式等诸多方面的东西。</p><p>在生成 Render 树的过程中，浏览器就会开始调用 GPU 绘制，合成图层，将内容显示在 屏幕上了。</p><p>关于这个流程，更多的可以<a href="https://github.com/skyline75489/what-happens-when-zh_CN">点击这里</a></p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>关于具体的设计模式我有过一些<a href="http://laibh.top/tags/javaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">笔记</a></p><p>下面还是根据作者的脚步来回顾这一点知识点</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>有一份很复杂的代码需要用户去调用，但是用户并不关心这些代码是怎么实现的，只需要提供一个接口去调用，用户只负责传递需要的参数。参数的使用都在内部逻辑去完成，不暴露出来给用户。只要给用户返回一个实例，这种构造过程就是工厂。</p><p>简而言之就是隐藏了创建实例的复杂度，只需要提供一个接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    alertName()&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> create(name)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Man(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Factory.create(<span class="string">'haha'</span>).alertName()</span><br></pre></td></tr></table></figure><p>Vue 源码中，也可以看到工厂模式的使用，比如创建异步组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export function createComponent(</span><br><span class="line">  Ctor: Class&lt;Component&gt; | Function | Object | void,</span><br><span class="line">  data: ?VNodeData,</span><br><span class="line">  context: Component,</span><br><span class="line">  children: ?Array&lt;VNode&gt;,</span><br><span class="line">  tag?: string</span><br><span class="line">): VNode | Array&lt;VNode&gt; | void &#123;</span><br><span class="line"></span><br><span class="line">  // 逻辑处理...</span><br><span class="line"></span><br><span class="line">  const vnode = new VNode(</span><br><span class="line">    `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : &apos;&apos;&#125;`,</span><br><span class="line">    data, undefined, undefined, undefined, context,</span><br><span class="line">    &#123; Ctor, propsData, listeners, tag, children &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  return vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们可以看到我们只需要调用 <code>createComponent</code> 传入参数就能创建一个组件实例，但是创建这个实例是很复杂的一个过程，工厂帮助我们隐藏了这个复杂的过程，只需要一句代码调用就能实现功能。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式很常用，比如全局缓存、全局状态管理等等只需要一个对象，就可以使用单例模式</p><p>单例模式的核心就是保证全局只有一个对象可以访问。因为 JS 是门无类的语言，所以别的语言实现单例的方式不能套入 JS 中，我们需要用一个变量确保值创建一次就可以了，下面是如何实现单例模式的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Singleton.getInstance = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Singleton()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> Singleton.getInstance();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> Singleton.getInstance();</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在 Vuex 源码中也可以看到单例模式的运用，虽然实现的方式不大一样，通过一个外部变量来控制只安装一次 Vuex</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue <span class="comment">// bind on install</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span> (<span class="params">_Vue</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Vue &amp;&amp; Vue === Vue)&#123;</span><br><span class="line">       <span class="comment">// 如果发现 Vue 有值，就不重新创建实例了</span></span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Vue = _Vue;</span><br><span class="line">    applyMixin(Vue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作</p><p>简单实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plug</span></span>&#123;</span><br><span class="line">    getName()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'港版插头'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.plug = <span class="keyword">new</span> Plug()</span><br><span class="line">    &#125;</span><br><span class="line">    getName()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.plug.getName() + <span class="string">' 适配转二脚插头'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> target = <span class="keyword">new</span> Target();</span><br><span class="line">target.getName(); <span class="comment">// 港版插头 适配转二脚插头</span></span><br></pre></td></tr></table></figure><p>在 Vue 中经常使用到适配器模式，比如父组件传递给子组件一个时间戳属性，组件内部需要将时间戳转为正常的日期显示，一般会使用 computed 来做转换这件事情，这个过程就是用到了适配器模式</p><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>装饰模式不需要改变已有的接口，作用是给对象添加功能，就像我们经常需要给手机戴个保护套防摔一样，不改变手机自身，给手机添加了保护套提供防摔的功能。</p><p>以下是如何实现装饰模式的例子，使用了 ES7 中的装饰器语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target,key,descriptor</span>)</span>&#123;</span><br><span class="line">    descriptor.writable = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> descriptor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    @readonly</span><br><span class="line">    name = <span class="string">'haha'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> Test();</span><br><span class="line">t.haha = <span class="string">'11'</span>; <span class="comment">// 不可修改</span></span><br></pre></td></tr></table></figure><p>在 React 中，装饰模式是随处可见的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(MyComponent)</span><br></pre></td></tr></table></figure><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理是为了控制对对象的访问，不让外部直接访问到对象，事件代理也是用到了代理模式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'#ul'</span>);</span></span><br><span class="line"><span class="javascript">    ul.addEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e.target);</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为存在太多 li，不可能每个都去绑定事件，这时候可以通过给父节点绑定一个事件，让父节点作为代理去拿到真实点击的节点。</p><h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h3><p>发布-订阅模式也叫做观察者模式，通过一对一或者一对多的依赖关系，当对象发生改变的时候，订阅方都会收到通知。现实生活中的例子是当我需要在购物网站购买一个产品的时候，但是发现该产品目前处于缺货状态，这时候我们可以点击有货通知的按钮，让网站在产品有货的时候通过短信通知我。</p><p>在实际代码中，其实发布-定于模式也很常见，比如我们点击一个按钮触发了点击事件其实就是使用了该模式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'#ul'</span>);</span></span><br><span class="line"><span class="javascript">    ul.addEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e.target);</span></span><br><span class="line"><span class="undefined">    &#125;)    </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 Vue 中，如何实现响应式也是使用了该模式，对于需要实现想爱你过隐式的对象来说，在 get 的时候会进行依赖手机，当改变了对象的属性的时候，就会触发派发更新</p><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>外观模式提供了一个接口，隐藏了内部的逻辑，更加方便外部的调用</p><p>我们需要实现一个兼容多种浏览器的添加事件方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">elm, evType, fn, useCapture</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (elm.addEventListener) &#123;</span><br><span class="line">    elm.addEventListener(evType, fn, useCapture);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (elm.attachEvent) &#123;</span><br><span class="line">    <span class="keyword">return</span> elm.attachEvent(<span class="string">'on'</span> + evType, fn)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    elm[<span class="string">"on"</span> + evType] = fn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于不同的浏览器，添加事件的方式可能会存在兼容问题，如果每次都要这样写一遍是不可能，我们将逻辑判断统一在一个接口里面，外部需要添加事件只需要调用 addEvent 就可以了</p><h2 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h2><p>关于数据结构我之前的笔记也有过记录，具体的可以<a href="http://laibh.top/tags/javaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">点击这里</a></p><p>下面还是跟着作者来重温一遍常见的数据结构</p><h3 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h3><p>如何衡量算法的效率？通常是用资源，例如CPU（时间）占用、内存占用、硬盘占用和网络占用。当讨论大O表示法时，一般考虑的是CPU（时间）占用。</p><p>分析算法时，时常遇到以下几类函数</p><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:left">名称</th></tr></thead><tbody><tr><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left">常数的</td></tr><tr><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left">对数的</td></tr><tr><td style="text-align:left"><em>O((log(n)c))</em></td><td style="text-align:left">对数多项式的</td></tr><tr><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left">线性的</td></tr><tr><td style="text-align:left"><em>O(n2)</em></td><td style="text-align:left">二次的</td></tr><tr><td style="text-align:left"><em>O(nc)</em></td><td style="text-align:left">多项式的</td></tr><tr><td style="text-align:left"><em>O(cn)</em></td><td style="text-align:left">指数的</td></tr></tbody></table><h3 id="常用数据结构的时间复杂度"><a href="#常用数据结构的时间复杂度" class="headerlink" title="常用数据结构的时间复杂度"></a>常用数据结构的时间复杂度</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><table><thead><tr><th style="text-align:left">数据结构</th><th style="text-align:left">一般情况</th><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left">最差情况</th><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left"></td><td style="text-align:left">插入</td><td style="text-align:left">删除</td><td style="text-align:left">搜索</td><td style="text-align:left">插入</td><td style="text-align:left">删除</td><td style="text-align:left">搜索</td></tr><tr><td style="text-align:left">数组-栈-队列</td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(n)</em></td></tr><tr><td style="text-align:left">链表</td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(n)</em></td></tr><tr><td style="text-align:left">双向链表</td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(n)</em></td></tr><tr><td style="text-align:left">散列表</td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(n)</em></td></tr><tr><td style="text-align:left">二分搜索树</td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(n)</em></td></tr><tr><td style="text-align:left">AVL树</td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(log(n))</em></td></tr></tbody></table><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><table><thead><tr><th style="text-align:left">算法（用于数组）</th><th style="text-align:left">最好情况</th><th style="text-align:left">一般情况</th><th style="text-align:left">最差情况</th></tr></thead><tbody><tr><td style="text-align:left">冒泡排序</td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(n2)</em></td><td style="text-align:left"><em>O(n2)</em></td></tr><tr><td style="text-align:left">选择排序</td><td style="text-align:left"><em>O(n2)</em></td><td style="text-align:left"><em>O(n2)</em></td><td style="text-align:left"><em>O(n2)</em></td></tr><tr><td style="text-align:left">插入排序</td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(n2)</em></td><td style="text-align:left"><em>O(n2)</em></td></tr><tr><td style="text-align:left">归并排序</td><td style="text-align:left"><em>O(nlog(n))</em></td><td style="text-align:left"><em>O(nlog(n))</em></td><td style="text-align:left"><em>O(nlog(n))</em></td></tr><tr><td style="text-align:left">快速排序</td><td style="text-align:left"><em>O(nlog(n))</em></td><td style="text-align:left"><em>O(nlog(n))</em></td><td style="text-align:left"><em>O(n2)</em></td></tr><tr><td style="text-align:left">堆排序</td><td style="text-align:left"><em>O(nlog(n))</em></td><td style="text-align:left"><em>O(nlog(n))</em></td><td style="text-align:left"><em>O(nlog(n))</em></td></tr><tr><td style="text-align:left">桶排序</td><td style="text-align:left"><em>O(n+k)</em></td><td style="text-align:left"><em>O(n+k)</em></td><td style="text-align:left"><em>O(n2)</em></td></tr><tr><td style="text-align:left">基数排序</td><td style="text-align:left"><em>O(nk)</em></td><td style="text-align:left"><em>O(nk)</em></td><td style="text-align:left"><em>O(nk)</em></td></tr></tbody></table><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一个线性结构，在计算机中是一个相当常见的数据结构，栈的特点是只能在某一端添加或者删除数据，遵循先进后出的规则（FILO）的原则</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加一个或者结构新元素到栈顶</span></span><br><span class="line">  push(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除栈顶的元素</span></span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回栈顶的元素</span></span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack[<span class="keyword">this</span>.size() - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack.length</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size() === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = [];</span><br><span class="line">  &#125;</span><br><span class="line">  getStack() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>题意是匹配括号，可以通过栈的特性来完成这道题目</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isVaild = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = &#123;</span><br><span class="line">    <span class="string">"("</span>: <span class="number">-1</span>,</span><br><span class="line">    <span class="string">")"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"["</span>: <span class="number">-2</span>,</span><br><span class="line">    <span class="string">"]"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">"&#123;"</span>: <span class="number">-3</span>,</span><br><span class="line">    <span class="string">"&#125;"</span>: <span class="number">3</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map[s[i]] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      stack.push(s[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> last = stack.pop()</span><br><span class="line">      <span class="keyword">if</span> (map[last] + map[s[i]] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (stack.size() === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Vue  中关于模板解析的代码，就有应用到匹配尖括号的内容</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一个线性结构，特点是在某一段添加数据，在另一端删除数据，遵循先进先出的原则（FIFO）</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>分成单链队列和循环队列</p><h5 id="单链队列"><a href="#单链队列" class="headerlink" title="单链队列"></a>单链队列</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = []</span><br><span class="line">  &#125;</span><br><span class="line">  enQueue(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  deQueue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.shift();</span><br><span class="line">  &#125;</span><br><span class="line">  front() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.length</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size() === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为单链队列在出队操作的时候㤇 O(n)的时间复杂度，所以引入了循环队列，循环队列的出队操作平均是 O(1)的时间复杂度</p><h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sqQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> <span class="built_in">Array</span>(length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 队头</span></span><br><span class="line">    <span class="keyword">this</span>.first = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 队尾</span></span><br><span class="line">    <span class="keyword">this</span>.last = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当前队列的大小</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  enQueue(item) &#123;</span><br><span class="line">    <span class="comment">// 如果队尾 +1 是否为队头，如果是就代表需要扩容数组，%this.queue.length 是为了防止数组越界</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.first === (<span class="keyword">this</span>.last + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length) &#123;</span><br><span class="line">      <span class="keyword">this</span>.resize(<span class="keyword">this</span>.size() * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.queue[<span class="keyword">this</span>.last] = item;</span><br><span class="line">    <span class="keyword">this</span>.size++;</span><br><span class="line">    <span class="keyword">this</span>.last = (<span class="keyword">this</span>.last + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length</span><br><span class="line">  &#125;</span><br><span class="line">  deQueue() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Queue is empty'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> r = <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first];</span><br><span class="line">    <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.first = (<span class="keyword">this</span>.first + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length;</span><br><span class="line">    <span class="keyword">this</span>.size--;</span><br><span class="line">    <span class="comment">// 判断当前队列是否过小，为了保证不浪费空间，在队列空间等于总长度四分之一的时候且不为2时缩小总长度为当前的一半</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size === <span class="keyword">this</span>.size() / <span class="number">4</span> &amp;&amp; <span class="keyword">this</span>.size() / <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.resize(<span class="keyword">this</span>.size() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  front() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Queue is empty'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first]</span><br><span class="line">  &#125;</span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.length - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.first === <span class="keyword">this</span>.last;</span><br><span class="line">  &#125;</span><br><span class="line">  resize(length) &#123;</span><br><span class="line">    <span class="keyword">let</span> q = <span class="keyword">new</span> <span class="built_in">Array</span>(length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      q[i] = <span class="keyword">this</span>.queue[(i + <span class="keyword">this</span>.first) % <span class="keyword">this</span>.queue.length]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.queue = q;</span><br><span class="line">    <span class="keyword">this</span>.first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.last = <span class="keyword">this</span>.size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是一个线性结构，同时也是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存活动管理。但是链表失去了数组随机读取的优点，同时链表也增加了结点的指针域，空间开销比较大。</p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>单向链表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 链表长度</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 虚拟头部</span></span><br><span class="line">    <span class="keyword">this</span>.dummyNode = <span class="keyword">new</span> Node(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  find(header, index, currentIndex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === currentIndex) <span class="keyword">return</span> header</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.find(header.next, index, currentIndex + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  addNode(v, index) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkIndex(index);</span><br><span class="line">    <span class="comment">// 当往链表末尾插入时，prev.next 为空，其他情况时，因为要插入节点，所以插入的节点的next 应该是 prev.next 然后设置 prev.next 为插入的节点</span></span><br><span class="line">    <span class="keyword">let</span> prev = <span class="keyword">this</span>.find(<span class="keyword">this</span>.dummyNode, index, <span class="number">0</span>);</span><br><span class="line">    prev.next = <span class="keyword">new</span> Node(v, prev.next);</span><br><span class="line">    <span class="keyword">this</span>.size++;</span><br><span class="line">    <span class="keyword">return</span> prev.next;</span><br><span class="line">  &#125;</span><br><span class="line">  insertNode(v, index) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.addNode(v, index);</span><br><span class="line">  &#125;</span><br><span class="line">  addToFirst(v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.addNode(v, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  addToLast(v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.addNode(v, <span class="keyword">this</span>.size);</span><br><span class="line">  &#125;</span><br><span class="line">  removeNode(index, isLast) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkIndex(index);</span><br><span class="line">    index = isLast ? index - <span class="number">1</span> : index;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="keyword">this</span>.find(<span class="keyword">this</span>.dummyNode, index, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> node = prev.next;</span><br><span class="line">    prev.next = node.next;</span><br><span class="line">    node.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.size--;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  removeFirstNode() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.removeNode(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  removeLastNode() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.removeNode(<span class="keyword">this</span>.size, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  checkIndex(index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="keyword">this</span>.size) <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Index error'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  getNode(index) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkIndex(index);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.find(<span class="keyword">this</span>.dummyNode, index, <span class="number">0</span>).next;</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>树拥有很多种结构，二叉树是树中最常见的结构，同时也是一个天然的递归结构</p><p>二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一棵树的数量为满，该树就可以称之为二叉树</p><pre class="mermaid">graph TDA[2] --> B[7]A[2] --> C[5]C[5] --> F[9]F[9] --> J[4]B[7] --> D[2]B[7] --> E[6]E[6] --> G[5]E[6] --> H[11]</pre><h4 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h4><p>二分搜索树也是二叉树，拥有二叉树的特性。但是区别于在二分搜索树每个节点的值都比它的左子树的值大，比右子树的值小。</p><p>这种存储方式很适合数据搜索。如下图显示，当需要查找6的时候，因为需要查找的值比根节点的值大，所以只需要在根节点的右子树上寻找，大大提高了搜索效率</p><pre class="mermaid">graph TDA[5] --> B[2]B[2] --> C[1]B[2] --> D[4]D[4] --> E[3]A[5] --> F[6]F[6] --> G[7]</pre><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>具体可以<a href="http://laibh.top/2018-11-05-JavaScipt%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Part8.html">点击这里</a></p><h2 id="CSS-常考面试题目资料"><a href="#CSS-常考面试题目资料" class="headerlink" title="CSS 常考面试题目资料"></a>CSS 常考面试题目资料</h2><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000013325778">50道CSS基础面试题（附答案）</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000013860482">《50道CSS基础面试题（附答案）》中的答案真的就只是答案吗？</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Ffunteas.com%2Ftopic%2F5ada8eac230d1e5e25e45b89">CSS 面试题总结</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fyangshun%2Ffront-end-interview-handbook%2Fblob%2Fmaster%2FTranslations%2FChinese%2Fquestions%2Fcss-questions.md">front-end-interview-handbook</a></li></ul><h2 id="推荐的资料"><a href="#推荐的资料" class="headerlink" title="推荐的资料"></a>推荐的资料</h2><h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fgetify%2FYou-Dont-Know-JS">You-Dont-Know-JS</a>，这套书深入的讲解很多 JS 的内容，英文版是开源免费阅读的，如果你英文不好的话，国内这套书已经有出版了，可以选择购买。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fgetify%2FFunctional-Light-JS">Functional-Light-JS</a>，这本书是讲解函数式编程的，函数式编程也是一种编程范式，轻量级的函数式可以很方便的解决很多问题，有兴趣的可以一读。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fleonardomso%2F33-js-concepts">33-js-concepts</a>，这份资料讲解了 33 个前端开发必须知道的 JS 概念，内容是英文的，如果你英文不好的话，可以寻找这份资料的中文版。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fdt-fe%2Fweekly">前端精读周刊</a>，这是一份前端好文集合，每周都会更新，目前已经更新了 84 篇文章。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FJohnsenZhou%2FFront-End-Performance-Checklist">前端性能清单</a>，这是一份前端性能清单，如果你需要优化一个项目的话，可以根据这份清单一个个来检查优化项。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2F30-seconds%2F30-seconds-of-code">30-seconds-of-code</a>，30 秒系列，很短的代码片段让你了解一个知识点。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FAllThingsSmitty%2Fmust-watch-javascript">must-watch-javascript</a>，这份资料包含了很多高质量的前端相关视频，值得一看。</li></ul><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FAllThingsSmitty%2Fcss-protips">css-protips</a>，通过这份资料你可以学习到很多 tips 来提高你的 CSS 技能。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2F30-seconds%2F30-seconds-of-css">30-seconds-of-css</a>，30 秒系列，很短的代码片段让你了解一个知识点</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fitem.jd.com%2F12262251.html">CSS 世界</a>，张鑫旭出版的书籍，没什么好说的了，看就是了。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fchokcoco%2FiCSS">一些有趣的 CSS 话题</a>，CSS 奇技淫巧，在这里，都有。</li></ul><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>React 核心团队成员 Dan Abramov 的 <a href="https://link.juejin.im/?target=https%3A%2F%2Foverreacted.io%2F">blog</a>。</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fnswbmw%2Fnode-in-debugging">Node.js 调试指南</a>，这是一本专注于讲解 Node 调试的书籍，已经出版了，但是可以开源免费阅读。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fitem.jd.com%2F12380404.html">Node.js：来一打 C++ 扩展</a>，死月出版的书籍，没什么好说的，看就是了。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fi0natan%2Fnodebestpractices%2Fblob%2Fmaster%2FREADME.chinese.md">Node.js 最佳实践</a>，这是对 Node.js 最佳实践中排名最高的内容的总结和分享</li></ul><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Ftrimstray%2Fthe-book-of-secret-knowledge">the-book-of-secret-knowledge</a>，这是一份安全领域的资料，如果你对安全感兴趣的话，可以阅读一下内容。</li></ul><h3 id="周报"><a href="#周报" class="headerlink" title="周报"></a>周报</h3><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fweekly.75team.com%2F">奇舞周刊</a>，每周都会整理一份不错的中文文章合集。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fweekly.techbridge.cc%2F">TechBridge Weekly</a>，这是一份台湾地区整理的一份多个技术领域的周报。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fjavascriptweekly.com%2F">JavaScript Weekly</a>，这是一份相当有名气的英文周报，整理的文章质量都很高，如果你只想订阅一份周报，那就是它了。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fponyfoo.com%2Fweekly">Pony Foo Weekly</a>，这也是一份不错的英文周报，文章质量也很高，并且和上一份周报重叠的内容不多。</li></ul><h3 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h3><p>Medium 上我并没有怎么固定阅读，更多的是订阅它的日报或者从别的周报上看到的 Medium 的文章，但是如果一定要推荐两个组织的话，我只推荐这两个，毕竟他们的文章质量都很高。</p><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fmedium.freecodecamp.org%2F">freecodecamp</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fhackernoon.com%2F">hackernoon</a></li></ul><h3 id="Youtube"><a href="#Youtube" class="headerlink" title="Youtube"></a>Youtube</h3><p>Youtube 有很多高质量的视频，但是门槛大家都知道，这里我推荐一些值得订阅的频道。</p><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.youtube.com%2Fchannel%2FUCzoVCacndDCfGDf41P-z0iA">JSConf</a>，很多会议的视频你都可以在这里找到。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.youtube.com%2Fchannel%2FUCnUYZLuoy1rq1aVMwx4aTzw">Google Chrome Developers</a>，Google 金字招牌，没啥好说的。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.youtube.com%2Fchannel%2FUC9-y-6csu5WGm29I7JiwpnA">Computerphile</a>，内容偏向于计算机领域。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.youtube.com%2Fchannel%2FUCtxCXg-UvSnTKPOzLH4wJaQ%2Fvideos">Coding Tech</a>，内容偏向于入门。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.youtube.com%2Fchannel%2FUCO1cgjhGzsSYb1rsB4bFe4Q">Fun Fun Function</a>，如果你想学习函数式编程的一些内容，这是一个值得订阅的频道。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.youtube.com%2Fuser%2FDevTipsForDesigners%2Fvideos">DevTips</a>，每周更新一个视频，能够学习到不少开发中的 Tips。</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fdavideuler%2Farchitecture.of.internet-product">互联网公司技术架构</a>，这份资料介绍了当下互联网公司的一个技术架构。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Ftrekhleb%2Fjavascript-algorithms">javascript-algorithms</a>，这份资料作者使用了 JS 来实现了大部分的数据结构和算法。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fjamiebuilds%2Fthe-super-tiny-compiler">小型编译器</a>，这份资料告诉了我们该如何去实现一个小型的编译器，很适合前端开发者阅读。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fmtdvio%2Fevery-programmer-should-know">every-programmer-should-know</a>，这份资料列举了很多每个开发者都应该知道的知识点。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;温故而知新，保持空杯心态,复习到一半的时间，突然发现了 &lt;a href=&quot;https://yuchengkai.cn/docs/frontend&quot;&gt;前端面试之道&lt;/a&gt;，按学习这本书的路径来&lt;/p&gt;
&lt;h2 id=&quot;JS-基础3&quot;&gt;&lt;a href=&quot;#JS-基础3&quot; cla
      
    
    </summary>
    
      <category term="前端面试" scheme="http://laibh.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端面试题" scheme="http://laibh.top/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>webpack4.x从基础到实战</title>
    <link href="http://laibh.top/2019-04-13-webpack4x%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98.html"/>
    <id>http://laibh.top/2019-04-13-webpack4x从基础到实战.html</id>
    <published>2019-04-13T08:30:00.000Z</published>
    <updated>2022-03-04T10:00:38.464Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://coding.imooc.com/learn/list/316.html">DellLee 老师的 webpack 学习与记录</a></p><p>知识点：</p><blockquote><p><code>Loader</code> <code>HMR</code> <code>Create React App</code> <code>Caching</code> <code>Plugin</code> <code>SourceMap</code> <code>Vue Cli 3.0</code> <code>Shimming</code> <code>WebpackDevServer</code> <code>TreeShaking</code>  <code>CodeSplitting</code> <code>Babel</code> <code>React</code> <code>Library</code> <code>Eslint</code> <code>PWA</code> <code>Vue</code> <code>Mode</code> <code>性能优化</code> <code>多页应用</code> <code>原理</code> <code>PreLoading</code> <code>PreFetching</code> <code>环境变量</code>  <code>TypeScript</code></p></blockquote><h2 id="Webpack-是什么"><a href="#Webpack-是什么" class="headerlink" title="Webpack 是什么"></a>Webpack 是什么</h2><p>本质上，<em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)</em>。当 webpack 处理应用程序时，它会递归地构建一个<em>依赖关系图(dependency graph)</em>，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <em>bundle</em>。</p><p><a href="https://webpack.js.org/concepts/modules/">扩展阅读-Modules</a></p><h2 id="webapack-打包浅析"><a href="#webapack-打包浅析" class="headerlink" title="webapack 打包浅析"></a>webapack 打包浅析</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// production 模式下代码压缩，development 代码不压缩</span></span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>module 处理方案，loader 有先后顺序，从下到上，从右到左</p><h3 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a><strong>file-loader</strong></h3><p>处理图片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 开发还是生产环境</span></span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  <span class="comment">// 进口</span></span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  <span class="comment">// 模块处理</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 规则</span></span><br><span class="line">    rules: [&#123;</span><br><span class="line">      <span class="comment">// 匹配</span></span><br><span class="line">      test: <span class="regexp">/\.jpg$/</span>,</span><br><span class="line">      <span class="comment">// loader 运用</span></span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span>,</span><br><span class="line">        <span class="comment">// 占位符</span></span><br><span class="line">        options: &#123;</span><br><span class="line">          <span class="comment">// 定义文件的名字：原来的名字_哈希值.原来的后缀</span></span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          <span class="comment">// 图片输出路径</span></span><br><span class="line">          outputPath:<span class="string">'./images/'</span></span><br><span class="line">        &#125;          </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者是用方法的方式</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 开发还是生产环境</span></span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  <span class="comment">// 进口</span></span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  <span class="comment">// 模块处理</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 规则</span></span><br><span class="line">    rules: [&#123;</span><br><span class="line">      <span class="comment">// 匹配</span></span><br><span class="line">      test: <span class="regexp">/\.jpg$/</span>,</span><br><span class="line">      <span class="comment">// loader 运用</span></span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span>,</span><br><span class="line">        <span class="comment">// 占位符</span></span><br><span class="line">        options: &#123;</span><br><span class="line">          <span class="comment">// 定义文件的名字：原来的名字_哈希值.原来的后缀</span></span><br><span class="line">        name(file)&#123;</span><br><span class="line">            <span class="keyword">if</span>(process.env.NODE_ENV === <span class="string">'development'</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="string">'[path][name].[ext]'</span>,</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'[hash][ext]'</span></span><br><span class="line">        &#125;,</span><br><span class="line">          <span class="comment">// 图片输出路径</span></span><br><span class="line">          outputPath:<span class="string">'./images/'</span></span><br><span class="line">        &#125;          </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a><strong>url-loader</strong></h3><p>会把图片打包到js 文件中，如果图片很小（1-2kb）的话就适合以base64的形式打包到js里面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          outputPath: <span class="string">'images/'</span>,</span><br><span class="line">          <span class="comment">// 限制图片的大小（Kb）,小于的会被打包到js里面，大于则打包到指定目录下</span></span><br><span class="line">          limit: <span class="number">2048</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用来处理字体文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [&#123;</span><br><span class="line">    test:<span class="regexp">/\.(eot|ttf|svg|woff)$/</span>,</span><br><span class="line">    use:&#123;</span><br><span class="line">      loader:<span class="string">'file-loader'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="style-loader、css-loader"><a href="#style-loader、css-loader" class="headerlink" title="style-loader、css-loader"></a><strong>style-loader</strong>、<strong>css-loader</strong></h3><p>处理css 样式</p><p>css-loader 分析有几个css文件以及它们之间的关系是怎么样的然后合并为一个css</p><p>style-loader 会把 css-loader 合并的内容挂载到页面上</p><p>node-sass、sass-loader：应对 sass 文件，上面的组合处理sass 文件不会报错，但是不会转义sass 特殊的语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [ &#123;</span><br><span class="line">    test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">    use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="postcss-loader、autoprefixer"><a href="#postcss-loader、autoprefixer" class="headerlink" title="postcss-loader、autoprefixer"></a><strong>postcss-loader</strong>、<strong>autoprefixer</strong></h3><p>自动添加css前缀</p><p>在文件的根目录配置 postcss.config.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webapck.config.js 更改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [ &#123;</span><br><span class="line">    test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">    use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>,<span class="string">'postcss-loader'</span>]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>如果有样式引用其他样式的情况要重新定义 css-loader 使得被引入的 scss 等有语义的css 文件可以重新跑多一次全部的 loader</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [ &#123;</span><br><span class="line">    test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      <span class="comment">// 当 loader 有参数配置的时候使用对象</span></span><br><span class="line">      use: [<span class="string">'style-loader'</span>, &#123;</span><br><span class="line">          loader:<span class="string">'css-loader'</span>,</span><br><span class="line">          options:&#123;</span><br><span class="line">              importLoaders:<span class="number">2</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, <span class="string">'sass-loader'</span>,<span class="string">'postcss-loader'</span>]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>开启模块化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [ &#123;</span><br><span class="line">    test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      <span class="comment">// 当 loader 有参数配置的时候使用对象</span></span><br><span class="line">      use: [<span class="string">'style-loader'</span>, &#123;</span><br><span class="line">          loader:<span class="string">'css-loader'</span>,</span><br><span class="line">          options:&#123;</span><br><span class="line">              importLoaders:<span class="number">2</span>,</span><br><span class="line">              <span class="comment">// css 模块化</span></span><br><span class="line">              modules:<span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, <span class="string">'sass-loader'</span>,<span class="string">'postcss-loader'</span>]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><a href="https://webpack.js.org/loaders">其他具体的loader</a></p><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>可以在webpack 运行打包到某个时刻帮你实现一些事情</p><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>会在打包结束后自动生成一个 html 文件，并把打包生成的 js 自动引入到这个 html 文件中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [<span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        <span class="comment">// 设置默认的模板</span></span><br><span class="line">        template: <span class="string">'src/index.html'</span></span><br><span class="line">    &#125;)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><p>打包之前去掉旧的dist 项目</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">'src/index.html'</span> &#125;),</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin()</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p><a href="https://github.com/johnagan/clean-webpack-plugin/blob/master/src/clean-webpack-plugin.ts#L315">clean-webpack-plugin2.0 的新参数</a></p><h2 id="Output、Entry"><a href="#Output、Entry" class="headerlink" title="Output、Entry"></a><strong>Output、Entry</strong></h2><p>多文件输出预设的名字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">    entry:&#123;</span><br><span class="line">        main:<span class="string">'./src/index.js'</span>,</span><br><span class="line">        sub:<span class="string">'./src/index.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        <span class="comment">// 可以定义输出的跟路径，如果图片是cdn上面的，可以在从这里设置，html 引入这个js会自动加上</span></span><br><span class="line">        publicPath:<span class="string">'xx'</span>,</span><br><span class="line">        filename:<span class="string">'[name].js'</span></span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'dist'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SouceMap"><a href="#SouceMap" class="headerlink" title="SouceMap"></a>SouceMap</h2><p>development  模式下 devtool 默认是true,开启souceMap 通过映射当代码出错的时候可以找到源文件是哪里出错而不是编译后的文件哪里出错.</p><p>当然建立这种映射会影响打包速度</p><p><a href="https://webpack.js.org/configuration/devtool#devtool">具体内容</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  <span class="comment">// 这里可以关闭 sourceMap，开启则是'source-map'</span></span><br><span class="line">  devtool: <span class="string">'none'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>souce-map会在dist 自动生成一个 js.map 映射文件，而inline-souce-map 则是将这个关系包含在 打包的js文件里面。</p><p>使用 cheap-xxx–xxx 的参数会加快打包方式，但是只会提示到几行不会精确到几列。</p><p>开发环境（development）推荐使用：cheap-module-eval-source-map（module代表module里面的错误也可以检测到，eval 可以加快编译速度）</p><p>生产环境（pruduction）则是：cheap-module-source-map</p><h2 id="WebpackDevServer"><a href="#WebpackDevServer" class="headerlink" title="WebpackDevServer"></a>WebpackDevServer</h2><p>webpack-dev-server 帮助打包后的运行在自动打开的服务器，并会跟随文件的改变而改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        <span class="comment">// 要打开的文件地址</span></span><br><span class="line">        contentBase:<span class="string">'./dist'</span>,</span><br><span class="line">        <span class="comment">// 是否自动打开默认浏览器</span></span><br><span class="line">        open:<span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 端口号，默认端口是8080</span></span><br><span class="line">        port:<span class="number">8080</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"webpack-dev-server"</span>,</span><br><span class="line">    <span class="string">"watch"</span>: <span class="string">"webpack --watch"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack-dev-server 打包的时候会把打包的 dist 目录内置到内存里面而不会显示出来，可以提高编译速度</p><p><a href="https://webpack.js.org/configuration/dev-server">相关内容</a></p><p>一开始的时候webpack-dev-server 因为配置不是很完善，一般人都会自己创建一个 server.js 文件来自己建一个服务器</p><p>这里使用 express 和 webpack-dev-middleware 来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="comment">// 中间件可以监听，随着页面内容的改变而更改</span></span><br><span class="line"><span class="keyword">const</span> webpackDevMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>);</span><br><span class="line"><span class="comment">// 使用 webpack 的配置来返回一个编译器</span></span><br><span class="line"><span class="keyword">const</span> complier = webpack(config);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(webpackDevMiddleware(complier,&#123;</span><br><span class="line">  publicPath:config.output.publicPath</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,()=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server is running on port 3000'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"middleware"</span>: <span class="string">"node server.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上面的内容是没有实现浏览器自动加载的。</p><h2 id="Hot-Module-Replacement-HMR"><a href="#Hot-Module-Replacement-HMR" class="headerlink" title="Hot Module Replacement(HMR)"></a>Hot Module Replacement(HMR)</h2><p>热模块更新，不刷新页面，重新加载css文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    <span class="comment">// 启动热模块加载</span></span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 即便 html 不生效也不会自动刷新</span></span><br><span class="line">    hotOnly: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins:[</span><br><span class="line"><span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只修改对应的 js 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">module</span>.hot)&#123;</span><br><span class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">'./文件名.js'</span>,()=&gt;&#123;</span><br><span class="line">        <span class="comment">// 运用页面的函数</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而css 对应的代码是在 css-loader 里面底层实现了，所以不用手写 module.hot</p><h2 id="Babel-处理-ES6-语法"><a href="#Babel-处理-ES6-语法" class="headerlink" title="Babel 处理 ES6 语法"></a>Babel 处理 ES6 语法</h2><p>babel-loader 与 @babel-core(webpack与 babel 桥梁)</p><p>@babel/preset-env</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            text:<span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">            loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">                presets:[<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以将 ES6 语法转换为 ES5 语法，但是还不完善，接着在index.js里面直接引入 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'@babel/polyfill'</span></span><br></pre></td></tr></table></figure><p>@babel/polyfill 可以自动添加内容实现兼容低版本的浏览器。打包之后会发现打包的js会很大，因为它把所有低版本可能要兼容的代码都写了进去，而不是按需要来增加内容。这个时候可以通过配置来达到按需</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            text:<span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">            loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">                presets:[[<span class="string">'@babel/preset-env'</span>],&#123;</span><br><span class="line">                    useBuiltIns:<span class="string">'usage'</span></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack 进行打包的时候发现会报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Module not found: Error: Can't resolve 'core-js/modules/es6.array.map'</span><br></pre></td></tr></table></figure><p>之类的错误，通过查阅发现要下载一个 core-js 的插件便可以解决问题，具体可以查看 <a href="https://www.npmjs.com/package/core-js">core-js</a></p><p>而当你使用这个按需加载的时候，就会提示你去掉文件中 import ‘@babel/polyfill’ ,因为会自动加载，另外可以配置要兼容的浏览器版本来判断需要引入那些兼容代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            text:<span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">            loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">                presets:[[<span class="string">'@babel/preset-env'</span>],&#123;</span><br><span class="line">                    useBuiltIns:<span class="string">'usage'</span>,</span><br><span class="line">                    targets:&#123;</span><br><span class="line">                        chrome:<span class="string">'67'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而上面的版本的谷歌浏览器是支持 ES6 语法的，因为打包出来的文件就会很小。可以看出来上面的方式有可能会全局污染(适合小项目)，可以使用另外一种方式去配置（适合多模块）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">            loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">                plugins:[[<span class="string">'@babel/plugin-transform-runtime'</span>,&#123;</span><br><span class="line">                    corejs:<span class="number">2</span>,</span><br><span class="line">                    helpers:<span class="literal">true</span>,</span><br><span class="line">                    regenerator:<span class="literal">true</span>,</span><br><span class="line">                    useESModules:<span class="literal">false</span></span><br><span class="line">                &#125;]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置上面的内容之前需要安装以下几个依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D @babel/runtime @babel/plugin-transfrom-runtime @babel/runtime-corejs2</span><br></pre></td></tr></table></figure><p>具体可以查看<a href="https://coding.imooc.com/lesson/316.html#mid=22337">这里</a></p><p>另外可以把 babel-loader options 里面的内容放在一个单独名为 .babelrc 的文件中</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/plugin-transform-runtime"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"corejs"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"helpers"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"regenerator"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"useESModules"</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打包-React-代码"><a href="#打包-React-代码" class="headerlink" title="打包 React 代码"></a>打包 React 代码</h2><p>安装依赖包 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D @babel/preset-react</span><br></pre></td></tr></table></figure><p>配置 .babelrc</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"targets"</span>: &#123;</span><br><span class="line">          <span class="attr">"chrome"</span>: <span class="string">"67"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"useBuiltIns"</span>: <span class="string">"usage"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-react"</span></span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的顺序也是从下往上</p><p><a href="https://babeljs.io/docs/en/babel-preset-react">具体点击这里</a></p><h2 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h2><p>development 环境，按需加载，只支持 ES Module ，底层是一个静态引入实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js 只引入 add 的打包结果</span></span><br><span class="line"><span class="comment">/*! exports provided: add, minus */</span></span><br><span class="line"><span class="comment">/*! exports used: add */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过下面的配置</span></span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    optimization:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 因为只是单纯引入，挂载在全局而不用去使用里面具体的，以防止被去掉，使用这个参数可以做一个过滤不作 tree Shaking</span></span><br><span class="line">    <span class="string">"sideEffects"</span>:[<span class="string">"@babel/polyi-fill"</span>,<span class="string">"*.css"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>production 环境甚至需要 optimization 配置，会自动配置，但是 package.json 中的 sideEffects 需要保留</p><h2 id="Development-和-Production-模式的区分打包"><a href="#Development-和-Production-模式的区分打包" class="headerlink" title="Development 和 Production 模式的区分打包"></a>Development 和 Production 模式的区分打包</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"webpack-dev-server --config webpack.dev.js"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --config webpack.prod.js"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.dev.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    hotOnly: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">      loader:<span class="string">'babel-loader'</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          outputPath: <span class="string">'images/'</span>,</span><br><span class="line">          limit: <span class="number">2048</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        <span class="string">'style-loader'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'css-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            importLoaders: <span class="number">2</span>,</span><br><span class="line">            <span class="comment">// modules: true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="string">'sass-loader'</span>,</span><br><span class="line">        <span class="string">'postcss-loader'</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.(eot|ttf|svg|woff)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">'src/index.html'</span> &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line">  optimization:&#123;</span><br><span class="line">    usedExports:<span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: <span class="string">'/'</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-source-map'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">      loader:<span class="string">'babel-loader'</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          outputPath: <span class="string">'images/'</span>,</span><br><span class="line">          limit: <span class="number">2048</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        <span class="string">'style-loader'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'css-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            importLoaders: <span class="number">2</span>,</span><br><span class="line">            <span class="comment">// modules: true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="string">'sass-loader'</span>,</span><br><span class="line">        <span class="string">'postcss-loader'</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.(eot|ttf|svg|woff)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">'src/index.html'</span> &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: <span class="string">'/'</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出上面有很多重复的代码，可以进行抽取优化，用 webpack-merge 进行合并</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">      loader:<span class="string">'babel-loader'</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          outputPath: <span class="string">'images/'</span>,</span><br><span class="line">          limit: <span class="number">2048</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        <span class="string">'style-loader'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'css-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            importLoaders: <span class="number">2</span>,</span><br><span class="line">            <span class="comment">// modules: true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="string">'sass-loader'</span>,</span><br><span class="line">        <span class="string">'postcss-loader'</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.(eot|ttf|svg|woff)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">'src/index.html'</span> &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: <span class="string">'/'</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// webpack.dev.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devConfig = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    hot: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line">  optimization:&#123;</span><br><span class="line">    usedExports:<span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig,devConfig);</span><br><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodConfig = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-source-map'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig,prodConfig);</span><br></pre></td></tr></table></figure><h2 id="Webpack-和-Code-Splitting"><a href="#Webpack-和-Code-Splitting" class="headerlink" title="Webpack 和 Code Splitting"></a>Webpack 和 Code Splitting</h2><h3 id="同步代码"><a href="#同步代码" class="headerlink" title="同步代码"></a>同步代码</h3><p>遇到公共类库，会自动打包出来一个文件，例如 vendors~main.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    splitChunks:&#123;</span><br><span class="line">        chunks:<span class="string">'all'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步代码"><a href="#异步代码" class="headerlink" title="异步代码"></a>异步代码</h3><p>安装 babel-plugin-dynamic-import-webpack 后在 .babelrc 里面配置,这个插件不是官方的，所以不支持魔法注释</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"targets"</span>: &#123;</span><br><span class="line">          <span class="attr">"chrome"</span>: <span class="string">"67"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"useBuiltIns"</span>: <span class="string">"usage"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-react"</span></span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>:[<span class="string">"dynamic-import-webpack"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方的 @babel/plugin-syntax-dynamic-import 可以支持魔术注释</p><p>重新配置 .babelrc</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"targets"</span>: &#123;</span><br><span class="line">          <span class="attr">"chrome"</span>: <span class="string">"67"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"useBuiltIns"</span>: <span class="string">"usage"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-react"</span></span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>:[<span class="string">"@babel/plugin-syntax-dynamic-import"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack.common.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    splitChunks:&#123;</span><br><span class="line">        chunks:<span class="string">'all'</span>,</span><br><span class="line">        cacheGroups:&#123;</span><br><span class="line">            <span class="comment">// 取消名字前面的默认名称</span></span><br><span class="line">            vendors:<span class="literal">false</span>,</span><br><span class="line">            <span class="keyword">default</span>:<span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用魔法注释</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"lodash" */</span><span class="string">'lodash'</span>).then(<span class="function">(<span class="params">&#123;<span class="keyword">default</span>:_&#125;</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    element.innerHTML = _.join([<span class="string">'Dell'</span>,<span class="string">'Lee'</span>],<span class="string">'_'</span>);</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getComponent().then(<span class="function"><span class="params">element</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打包编译之后就可以看到异步引入的库被自己定义的名字打包出来了</p><h3 id="splitChunksPlugins"><a href="#splitChunksPlugins" class="headerlink" title="splitChunksPlugins"></a>splitChunksPlugins</h3><p>默认配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      <span class="comment">// 只对异步代码生效 all 则是全部代码，inintal 则是同步代码</span></span><br><span class="line">      chunks: <span class="string">'async'</span>,</span><br><span class="line">      <span class="comment">// 引入的模块/包/库 大于 30kb 则会代码分割</span></span><br><span class="line">      minSize: <span class="number">30000</span>,</span><br><span class="line">      <span class="comment">// 会尝试将 大于这个尺寸的库重新拆分为n个 maxSize 大的库，但是一般这个参数不会生效</span></span><br><span class="line">      maxSize: <span class="number">0</span>,</span><br><span class="line">      <span class="comment">// 打包生成的库的次数少于 minChunks次 则不会分割</span></span><br><span class="line">      minChunks: <span class="number">1</span>,</span><br><span class="line">      maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">      maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">      <span class="comment">// 自动生成的文件的中间符</span></span><br><span class="line">      automaticNameDelimiter: <span class="string">'~'</span>,</span><br><span class="line">      name: <span class="literal">true</span>, <span class="comment">// 配合 cacheGroups 使用</span></span><br><span class="line">      <span class="comment">// 缓存组</span></span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          <span class="comment">// 如果引入的库在 node_modules 里面，符合这个组打包出来的文件前缀会有vendors~入口.js</span></span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          <span class="comment">// 优先级 符合 在 node_modules 优先级大于在默认的，那么打包就会打包在 vendors 这个相关配置里面</span></span><br><span class="line">          priority: <span class="number">-10</span>,</span><br><span class="line">          <span class="comment">// 强制定义在同一个文件里面，可以不配置</span></span><br><span class="line">          filename:<span class="string">'vendors.js'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 默认处理途径</span></span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          priority: <span class="number">-20</span>,</span><br><span class="line">          <span class="comment">// 如果 模块在前面打包过了就不会重复打包</span></span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span>，</span><br><span class="line">          filename:<span class="string">'common.js'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Lazy-loading-懒加载"><a href="#Lazy-loading-懒加载" class="headerlink" title="Lazy loading 懒加载"></a>Lazy loading 懒加载</h2><p>通过 import 语法来异步加载，什么时候要使用则是取决于个人</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"lodash" */</span><span class="string">'lodash'</span>).then(<span class="function">(<span class="params">&#123;<span class="keyword">default</span>:_&#125;</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    element.innerHTML = _.join([<span class="string">'Dell'</span>,<span class="string">'Lee'</span>],<span class="string">'_'</span>);</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">  getComponent().then(<span class="function"><span class="params">element</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// async await 改进</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;<span class="attr">default</span>:_&#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"lodash" */</span><span class="string">'lodash'</span>);</span><br><span class="line">  <span class="keyword">const</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  element.innerHTML = _.join([<span class="string">'Dell'</span>,<span class="string">'Lee'</span>],<span class="string">'_'</span>);</span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">  getComponent().then(<span class="function"><span class="params">element</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="打包分析"><a href="#打包分析" class="headerlink" title="打包分析"></a>打包分析</h2><p>配置 package.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"scripts"</span>:&#123;</span><br><span class="line">        <span class="attr">"dev-build"</span>:<span class="string">"webpack --profile --json &gt; stats.json --config ./build/webpack.dev.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的意思是分析webapck 打包的文件生成后生成 stats.json 。</p><p><a href="http://webpack.github.io/analyse/">点击这个网站</a>可以将这个json 文件上传，会帮你自动分析版本，时长以及相关错误，模块之间的关系等等</p><p><a href="https://webpack.js.org/guides/code-splitting/#bundle-analysis">更多相关工具</a></p><h2 id="Preloading-Prefetching"><a href="#Preloading-Prefetching" class="headerlink" title="Preloading,Prefetching"></a>Preloading,Prefetching</h2><p>在谷歌浏览器 ctrl+shift+p 输入show Coverage 点击录制后可以看到一个网站首屏加载 js 文件的利用率，以及可以优化的可能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当浏览器空闲的时候，可以先加载这个文件</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="comment">/* webpackPrefetch:true*/</span><span class="string">'./click.js'</span>).then(<span class="function">(<span class="params">&#123;<span class="keyword">default</span>:func&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    func();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个则是和核心文件一起加载</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="comment">/* webpackPreloading:true*/</span><span class="string">'./click.js'</span>).then(<span class="function">(<span class="params">&#123;<span class="keyword">default</span>:func&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    func();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>性能优化在缓存上面可以优化的地方有限，可以考虑更多是代码的使用率，将一开始不会用的代码尽量使用异步加载的方式来加载</p><h2 id="CSS-文件的代码分割"><a href="#CSS-文件的代码分割" class="headerlink" title="CSS 文件的代码分割"></a>CSS 文件的代码分割</h2><p>mini-css-extract-plugin,没有实现  HMR 需要手动配置，所以一般是适用在线上环境使用。</p><p>配置如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">      loader:<span class="string">'babel-loader'</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          outputPath: <span class="string">'images/'</span>,</span><br><span class="line">          limit: <span class="number">2048</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(eot|ttf|svg|woff)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">'src/index.html'</span> &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">      cleanOnceBeforeBuildPatterns:[path.resolve(__dirname,<span class="string">'../dist'</span>)],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  optimization:&#123;</span><br><span class="line">    usedExports:<span class="literal">true</span>,</span><br><span class="line">    splitChunks:&#123;</span><br><span class="line">      chunks:<span class="string">'all'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: <span class="string">'./'</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// webpack.dev.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devConfig = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    hot: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              importLoaders: <span class="number">2</span>,</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="string">'sass-loader'</span>,</span><br><span class="line">          <span class="string">'postcss-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line">  optimization:&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig,devConfig);</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodConfig = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-source-map'</span>,</span><br><span class="line">  plugins:[</span><br><span class="line">      <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">        <span class="comment">// template 要引入的</span></span><br><span class="line">      filename:<span class="string">'[name].css'</span>,</span><br><span class="line">        <span class="comment">// 间接引入的走这个</span></span><br><span class="line">      chunkFilename:<span class="string">'[name].chunk.css'</span>          </span><br><span class="line">      &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              importLoaders: <span class="number">2</span>,</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="string">'sass-loader'</span>,</span><br><span class="line">          <span class="string">'postcss-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig,prodConfig);</span><br></pre></td></tr></table></figure><p>将之前共同配置的 webpack,common.js  module rules 里面关于css 的配置移动到 webpack.dev.js 里面不作修改。然后同样复制一遍到 webpack.prod.js 里面，把关于css-loader 里面的的 style-loader 换成 MiniCssExtractPlugin.loader 作为最后一步来处理。</p><p>一个要注意的点是在公共的 optimization 里面加了一个 usedExports：true,同时也要在 package.json 里面配置 sideEffects：[‘@babel/polyfill’,’*.css’]</p><p>运行 npm run build 便可以打包分割开 css 文件了</p><h3 id="压缩-css-代码"><a href="#压缩-css-代码" class="headerlink" title="压缩 css 代码"></a>压缩 css 代码</h3><p>optimize-css-assets-webpack-plugin</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    optimization:&#123;</span><br><span class="line">        minimizer:[</span><br><span class="line">            <span class="keyword">new</span> OptimizeCSSAssetPlugin(&#123;&#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个css文件打包到同一个css里面"><a href="#多个css文件打包到同一个css里面" class="headerlink" title="多个css文件打包到同一个css里面"></a>多个css文件打包到同一个css里面</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    optimization:&#123;</span><br><span class="line">        <span class="comment">// 底层依旧是 splitChunks 实现的</span></span><br><span class="line">        splitChunks:&#123;</span><br><span class="line">            cacheGroups:&#123;</span><br><span class="line">                styles:&#123;</span><br><span class="line">                    name:<span class="string">'styles'</span>,</span><br><span class="line">                    test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">                    chunks:<span class="string">'all'</span>,</span><br><span class="line">                    enforce:<span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个css文件按入口文件来打包"><a href="#多个css文件按入口文件来打包" class="headerlink" title="多个css文件按入口文件来打包"></a>多个css文件按入口文件来打包</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    optimization:&#123;</span><br><span class="line">        splitChunks:&#123;</span><br><span class="line">            cacheGroups:&#123;</span><br><span class="line">                fooStyles:&#123;</span><br><span class="line">                    name:<span class="string">'foo'</span>,</span><br><span class="line">                    test: <span class="function">(<span class="params">m, c, entry = <span class="string">'foo'</span></span>) =&gt;</span> m.constructor.name === <span class="string">'CssModule'</span> &amp;&amp; recursiveIssuer(m) === entry,</span><br><span class="line">                    chunks:<span class="string">'all'</span>,</span><br><span class="line">                    enforce:<span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">                barStyles:&#123;</span><br><span class="line">                    name:<span class="string">'bar'</span>,</span><br><span class="line">                    test: <span class="function">(<span class="params">m, c, entry = <span class="string">'foo'</span></span>) =&gt;</span> m.constructor.name === <span class="string">'CssModule'</span> &amp;&amp; recursiveIssuer(m) === entry,</span><br><span class="line">                    chunks:<span class="string">'all'</span>,</span><br><span class="line">                    enforce:<span class="literal">true</span>                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Webpack-与浏览器缓存（Caching）"><a href="#Webpack-与浏览器缓存（Caching）" class="headerlink" title="Webpack 与浏览器缓存（Caching）"></a>Webpack 与浏览器缓存（Caching）</h2><p>增加 hash 值,如果文件没有改变的话，那么打包前后几次打包出来的文件里面的哈希值就不会发生变化，浏览器的缓存也就起到了作用。如果改变了，浏览器则会去请求先的文件而不是继续用原来的缓存文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:<span class="string">'[name].[contenthash].js'</span>,</span><br><span class="line">        chunkFilename:<span class="string">'[name].[contenthash].js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的配置是新版本的webpack直接有的，但是旧版本的 webpack 每次打包 hash 值都会发生变化，可以在 webpack.common.js 里面配置一个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    optimization:&#123;</span><br><span class="line">        runtimeChunk:&#123;</span><br><span class="line">            name:<span class="string">'runtime'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个参数会把旧版本中的 manifest 单独抽离出来一个 runtime 开头的 js文件里面，这个 文件主要描述的是库与业务逻辑代码之间的一些关系，旧版本webpack 中这个关系会因为每次打包而发生变化。</p><h2 id="Shimming"><a href="#Shimming" class="headerlink" title="Shimming"></a>Shimming</h2><h3 id="自动引入某个库"><a href="#自动引入某个库" class="headerlink" title="自动引入某个库"></a>自动引入某个库</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">            _:<span class="string">'lodash'</span>,</span><br><span class="line">            <span class="comment">// 花式引用</span></span><br><span class="line">            _join:[<span class="string">'lodash'</span>,<span class="string">'join'</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局this-指向-window"><a href="#全局this-指向-window" class="headerlink" title="全局this 指向 window"></a>全局this 指向 window</h3><p>imports-loader</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">            use:[&#123;</span><br><span class="line">                loader:<span class="string">'babel-loader'</span></span><br><span class="line">            &#125;,&#123;</span><br><span class="line">                loader:<span class="string">'imports-loader？this=&gt;window'</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>可以考虑使用，用个人，具体是在 package.json 里面传递一个 env 参数</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev-build"</span>: <span class="string">"webpack --profile --json &gt; stats.json --config ./build/webpack.common.js"</span>,</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"webpack-dev-server --config ./build/webpack.common.js"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --env.production --config ./build/webpack.common.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 开发与生产环境的webpack 则是都放到 common 里面来判断分发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.dev.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devConfig = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    hot: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              importLoaders: <span class="number">2</span>,</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="string">'sass-loader'</span>,</span><br><span class="line">          <span class="string">'postcss-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: <span class="string">'./'</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    chunkFilename:<span class="string">'[name].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = devConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodConfig = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-source-map'</span>,</span><br><span class="line">  <span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              importLoaders: <span class="number">2</span>,</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="string">'sass-loader'</span>,</span><br><span class="line">          <span class="string">'postcss-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization:&#123;</span><br><span class="line">    minimizer:[</span><br><span class="line">      <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename:<span class="string">'[name].css'</span>,</span><br><span class="line">      chunkFilename:<span class="string">'[name].chunk.css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: <span class="string">'./'</span>,</span><br><span class="line">    filename: <span class="string">'[name].[contenthash].js'</span>,</span><br><span class="line">    chunkFilename:<span class="string">'[name].[contenthash].js'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = prodConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> merge =<span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> devConfig = <span class="built_in">require</span>(<span class="string">'./webpack.dev.js'</span>);</span><br><span class="line"><span class="keyword">const</span> prodConfig = <span class="built_in">require</span>(<span class="string">'./webpack.prod.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commonConfig = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">      use:[&#123;</span><br><span class="line">        loader:<span class="string">'babel-loader'</span></span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        loader:<span class="string">'imports-loader?this=&gt;window'</span></span><br><span class="line">      &#125;]</span><br><span class="line">      </span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          outputPath: <span class="string">'images/'</span>,</span><br><span class="line">          limit: <span class="number">2048</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(eot|ttf|svg|woff)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">'src/index.html'</span> &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">      cleanOnceBeforeBuildPatterns:[path.resolve(__dirname,<span class="string">'../dist'</span>)],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">      _:<span class="string">'lodash'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  optimization:&#123;</span><br><span class="line">    usedExports:<span class="literal">true</span>,</span><br><span class="line">    splitChunks:&#123;</span><br><span class="line">      chunks:<span class="string">'all'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">env</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(env &amp;&amp; env.production)&#123;</span><br><span class="line">    <span class="keyword">return</span> merge(commonConfig,prodConfig)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> merge(commonConfig,devConfig)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Library-的打包"><a href="#Library-的打包" class="headerlink" title="Library 的打包"></a>Library 的打包</h2><p>简单配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  externals: [<span class="string">'lodash'</span>],</span><br><span class="line">  output: &#123;</span><br><span class="line">    path:path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">    filename:<span class="string">'library.js'</span>,</span><br><span class="line">    <span class="comment">// 可以通过 script src=library.js 来引用这个库</span></span><br><span class="line">    library:<span class="string">'library'</span>,</span><br><span class="line">    <span class="comment">// 通用打包 CommonJS 或者 UMD，上面文件的挂载处（可以为this 或者 window）</span></span><br><span class="line">    libraryTarget:<span class="string">'umd'</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PWA-Progressive-Web-Application-的打包"><a href="#PWA-Progressive-Web-Application-的打包" class="headerlink" title="PWA(Progressive Web Application) 的打包"></a>PWA(Progressive Web Application) 的打包</h2><p>网站在被访问过一次之后，如果服务器挂掉了，浏览器还可以利用缓存来访问这个网站。</p><p>workbox-webpack-plugin</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 webpack.prod.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> WorkboxPlugin.GenerateSW(&#123;</span><br><span class="line">            clientsClaim:<span class="literal">true</span>,</span><br><span class="line">            skipWaiting:<span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后打包编译的是时候会生成多一个 service-worker.js 文件，在项目中运用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator)&#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'/service-worker.js'</span>).then(<span class="function"><span class="params">registration</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'service-worker registed'</span>);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'service-worker register error'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样配置之后，当用户访问过一次网站之后便会进行缓存，如果当服务器挂掉的时候，用户还是可以在浏览器访问到网站</p><h2 id="TypeScript-的打包配置"><a href="#TypeScript-的打包配置" class="headerlink" title="TypeScript 的打包配置"></a>TypeScript 的打包配置</h2><p>webpack基本配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode:<span class="string">'production'</span>,</span><br><span class="line">    entry:<span class="string">'./src/index.tsx'</span>,</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            test:<span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">            use:<span class="string">'ts-loader'</span>,</span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:<span class="string">'bundle.js'</span>,</span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'dist'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了webpack 配置之后，在 打包 ts 的时候还必须要配置一个 tsconfig.json</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    // 出口</span><br><span class="line">    "outDir": "./dist",</span><br><span class="line">    // 要处理的模块</span><br><span class="line">    "module": "es6",</span><br><span class="line">    // 编译成es5的</span><br><span class="line">    "target": "es5",</span><br><span class="line">    // 运行在文件中引入其他的js</span><br><span class="line">    "allowJs": true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要引入其他的库，例如 lodash ，需要安装对应的说明，@types/lodash ，具体的可以<a href="https://github.com/DefinitelyTyped/DefinitelyTyped">查看这里</a></p><h2 id="WebpackDevServer-1"><a href="#WebpackDevServer-1" class="headerlink" title="WebpackDevServer"></a>WebpackDevServer</h2><h3 id="开发环境实现请求代理转发"><a href="#开发环境实现请求代理转发" class="headerlink" title="开发环境实现请求代理转发"></a>开发环境实现请求代理转发</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本配置</span></span><br><span class="line"><span class="built_in">module</span>.exports =  &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">        open: <span class="literal">true</span>,</span><br><span class="line">        port: <span class="number">8080</span>,</span><br><span class="line">        hot: <span class="literal">true</span>,</span><br><span class="line">        hotOnly: <span class="literal">true</span>,</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/react/api'</span>: &#123;</span><br><span class="line">                <span class="comment">// 代理转发的url</span></span><br><span class="line">                target: <span class="string">'https://www.dell-lee.com/'</span>,</span><br><span class="line">                <span class="comment">// 当是 https 的时候可以设置这个参数</span></span><br><span class="line">                secure: <span class="literal">false</span>,</span><br><span class="line">                <span class="comment">// 拦截</span></span><br><span class="line">                bypass: <span class="function"><span class="keyword">function</span> (<span class="params">req, res, proxyOptions</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (req.headers.accept.indexOf(<span class="string">'html'</span>) !== <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">'Shipping proxy for browser request'</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">'/index.html'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// 路径重写</span></span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    <span class="string">'header.json'</span>: <span class="string">'demo.json'</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// 配置 headers 主机名与cookie 等等</span></span><br><span class="line">                headers:&#123;</span><br><span class="line">                    host:<span class="string">'xx'</span>,</span><br><span class="line">                    cookie:<span class="string">''</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://webpack.js.org/configuration/dev-server/#devserver">具体文档</a></p><p>底层是 <a href="https://github.com/webpack/webpack-dev-middleware">webpack-dev-middleware</a></p><h3 id="解决单页面应用路由问题"><a href="#解决单页面应用路由问题" class="headerlink" title="解决单页面应用路由问题"></a>解决单页面应用路由问题</h3><p>当配置路由发现找不到内容的时候，可以配置 <a href="https://webpack.js.org/configuration/dev-server#devserverhistoryapifallback">historyApiFallback</a></p><h2 id="ESLint-的配置"><a href="#ESLint-的配置" class="headerlink" title="ESLint 的配置"></a>ESLint 的配置</h2><p>先安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i eslint -D</span><br></pre></td></tr></table></figure><p>接着是初始化配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eslint -init</span><br></pre></td></tr></table></figure><p>采用目前流行 airbnb 的方式</p><p>会看到项目生成一个 .eslintrc.js</p><p>如果没有使用vscode 只能用 eslint src 命令行来查看错误信息</p><p>可以进行基本配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="string">"extends"</span>: <span class="string">"airbnb"</span>,</span><br><span class="line">    <span class="string">"parser"</span>: <span class="string">"babel-eslint"</span>,</span><br><span class="line">    <span class="string">"rules"</span>: &#123;</span><br><span class="line">        <span class="string">""</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    globals:&#123;</span><br><span class="line">        <span class="built_in">document</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="eslint-loader"><a href="#eslint-loader" class="headerlink" title="eslint-loader"></a>eslint-loader</h3><p>webpack 也有先关的配置，但是会影响打包的速度，一般会建议使用这种方式来配置。还是使用 vscode 的插件式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: [</span><br><span class="line">            &#123; <span class="attr">loader</span>: <span class="string">'babel-loader'</span> &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    <span class="comment">// 自动修复</span></span><br><span class="line">                    fix: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://webpack.js.org/loaders/eslint-loader">具体点击</a></p><p>devServer 配置 overlay 可以在页面提示错误信息</p><h2 id="webpack-性能优化"><a href="#webpack-性能优化" class="headerlink" title="webpack 性能优化"></a>webpack 性能优化</h2><p>1.升级工具的版本（node,npm,yarn）</p><p>2.loader（include/exclude）在尽可能少的模块上使用</p><p>3.plugin 尽可能精简可靠</p><p>4.resolve 参数合理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    resolve:&#123;</span><br><span class="line">        extensions:[<span class="string">'.js'</span>,<span class="string">'.jsx'</span>],</span><br><span class="line">       <span class="comment">// 使用别名</span></span><br><span class="line">        alias:&#123;</span><br><span class="line">            haha:path.resolve(__dirname,<span class="string">'../src/child/'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.使用 DllPlugin 提高打包速度</p><p>add-asset-html-webpack-plugin</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.dll.js</span></span><br><span class="line"><span class="comment">// 将共用的库放到一个文件里面去单独打包，用 library 暴露出来。然后用 webpack.DllPlugin 这个插件对这些库分析出一种文件关系映射.json 文件</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack =<span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendors: [<span class="string">'lodash'</span>],</span><br><span class="line">    react: [<span class="string">'react'</span>, <span class="string">'react-dom'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].dll.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../dll'</span>),</span><br><span class="line">    library: <span class="string">'[name]'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      name:<span class="string">'[name]'</span>,</span><br><span class="line">      path:path.resolve(__dirname,<span class="string">'../dll/[name].manifest.json'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在webpack.common.js 文件里面配置（也可以只配置生产环境）,将上面生成文件挂载到 template index.html上面</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">            filepath:path.resolve(__dirname,<span class="string">'../dll/verndors.dll.js'</span>)</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">            filepath:path.resolve(__dirname,<span class="string">'../dll/react.dll.js'</span>)</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> webpack.DllRefercencePlugin(&#123;</span><br><span class="line">            mainfest:path.resolve(__dirname,<span class="string">'../dll/vendors.mainfest.json'</span>)</span><br><span class="line">        &#125;),</span><br><span class="line">                <span class="keyword">new</span> webpack.DllRefercencePlugin(&#123;</span><br><span class="line">            mainfest:path.resolve(__dirname,<span class="string">'../dll/react.mainfest.json'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进行优化自动注入</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> plugins = [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template:<span class="string">'src/index.html'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">      cleanOnceBeforeBuildPatterns: [path.resolve(__dirname, <span class="string">'../dist'</span>)],</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> files = fs.readdirSync(path.resolve(__dirname,<span class="string">'../dll'</span>))</span><br><span class="line">files.forEach(<span class="function"><span class="params">file</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/.*\.dll.js/</span>.test(file))&#123;</span><br><span class="line">        plugins.push(<span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">            filepath:path.resolve(__dirname,<span class="string">'../dll'</span>,file)</span><br><span class="line">        &#125;)) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/.*\.mainfest.json/</span>.test(file))&#123;</span><br><span class="line">        plugins.push(<span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">            filepath:path.resolve(__dirname,<span class="string">'../dll'</span>,file)</span><br><span class="line">        &#125;)) </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.控制包文件的大小</p><p>7.thread-loader,parallel-webpack,happypack 多进程打包</p><p>8.合理使用 sourceMap(信息越详细打包越久)</p><p>9.结合打包分析 stats.json 优化分析</p><p>10.开发环境内存编译，无用插件剔除</p><h2 id="多页面打包配置"><a href="#多页面打包配置" class="headerlink" title="多页面打包配置"></a>多页面打包配置</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">      main: <span class="string">'./src/index.js'</span>,</span><br><span class="line">      list: <span class="string">'./src/list.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123; </span><br><span class="line">          filename:<span class="string">'index.html'</span>,</span><br><span class="line">          template: <span class="string">'src/index.html'</span>,</span><br><span class="line">          chunks:[<span class="string">'runtime'</span>,<span class="string">'vendors'</span>,<span class="string">'main'</span>]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123; </span><br><span class="line">          filename:<span class="string">'list.html'</span>,</span><br><span class="line">          template: <span class="string">'src/index.html'</span>,</span><br><span class="line">          chunks:[<span class="string">'runtime'</span>,<span class="string">'vendors'</span>,<span class="string">'list'</span>]</span><br><span class="line">        &#125;),        </span><br><span class="line">    ] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="keyword">const</span> configs  = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    list: <span class="string">'./src/list.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 其他所有配置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> makePlugins = <span class="function">(<span class="params">configs</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> plugins = [<span class="string">'其他的plugins'</span>];</span><br><span class="line">    <span class="built_in">Object</span>.keys(configs.entry).forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        plugins.push(</span><br><span class="line">            <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">                template:<span class="string">'src/index.html'</span>,</span><br><span class="line">                filename:<span class="string">`<span class="subst">$&#123;item&#125;</span>.html`</span>,</span><br><span class="line">                chunks:[<span class="string">'runtime'</span>,<span class="string">'vendors'</span>,<span class="string">'item'</span>]</span><br><span class="line">            &#125;)</span><br><span class="line">        )</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上面优化的代码</span></span><br><span class="line">    <span class="keyword">const</span> files = fs.readdirSync(path.resolve(__dirname,<span class="string">'../dll'</span>))</span><br><span class="line">    files.forEach(<span class="function"><span class="params">file</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="regexp">/.*\.dll.js/</span>.test(file))&#123;</span><br><span class="line">            plugins.push(<span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">                filepath:path.resolve(__dirname,<span class="string">'../dll'</span>,file)</span><br><span class="line">            &#125;)) </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="regexp">/.*\.mainfest.json/</span>.test(file))&#123;</span><br><span class="line">            plugins.push(<span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">                filepath:path.resolve(__dirname,<span class="string">'../dll'</span>,file)</span><br><span class="line">            &#125;)) </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;)  </span><br><span class="line">    <span class="keyword">return</span> plugins;</span><br><span class="line">&#125;</span><br><span class="line">configs.plugins = makePlugins(configs);</span><br><span class="line"><span class="built_in">module</span>.export = configs;</span><br></pre></td></tr></table></figure><h2 id="如何编写一个-Loader"><a href="#如何编写一个-Loader" class="headerlink" title="如何编写一个 Loader"></a>如何编写一个 Loader</h2><h3 id="简单的实现"><a href="#简单的实现" class="headerlink" title="简单的实现"></a>简单的实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// replaceLoader.js </span></span><br><span class="line"><span class="comment">// loader-utils 是官方一个符合 loader 规范的工具</span></span><br><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> source.replace(<span class="string">'haha'</span>, <span class="string">'world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// replaceLoaderAsync.js </span></span><br><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options = loaderUtils.getOptions(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">const</span> callback = <span class="keyword">this</span>.async();</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = source.replace(<span class="string">'lbh'</span>, options.name);</span><br><span class="line">    callback(<span class="literal">null</span>, result);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello lbh'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// loader 的位置，先查找 node_modules 如果没有就往下找，那么自定义的 loader 就不用写全路径了</span></span><br><span class="line">  resolveLoader: &#123;</span><br><span class="line">    modules: [<span class="string">'node_modules'</span>, <span class="string">'./loaders'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js?$/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: <span class="string">'replaceLoader.js'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'replaceLoaderAsync.js'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">'haha'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义 loader 的用途很多，可以拿来做一个简单的错误检验</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> source.replace(<span class="string">'haha'</span>, <span class="string">'world'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者是国际化,在相关页面弄一个占位符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Node全局变量 === <span class="string">'中文'</span>)&#123;</span><br><span class="line">       source.replace(<span class="string">'&#123;&#123;title&#125;&#125;'</span>, <span class="string">'中文标题'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       source.replace(<span class="string">'&#123;&#123;title&#125;&#125;'</span>, <span class="string">'engilsh title'</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以具体参数可以<a href="https://webpack.js.org/api/loaders">点击这里</a></p><h2 id="如何编写一个-Plugin"><a href="#如何编写一个-Plugin" class="headerlink" title="如何编写一个 Plugin"></a>如何编写一个 Plugin</h2><p>简单的实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plugin/copyright-webpack-plugin</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CopyRightWebpackPlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//compiler:webpack 的实例</span></span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="comment">// 同步</span></span><br><span class="line">    compiler.hooks.compile.tap(<span class="string">'CopyRightWebpackPlugin'</span>, (compilation) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'compiler'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 异步</span></span><br><span class="line">    compiler.hooks.emit.tapAsync(<span class="string">'CopyRightWebpackPlugin'</span>, (compilation, cb) =&gt; &#123;</span><br><span class="line">      <span class="keyword">debugger</span>;</span><br><span class="line">      compilation.assets[<span class="string">'copyright.txt'</span>]=&#123;</span><br><span class="line">        source:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">'copyright by hahaha'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        size:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cb();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = CopyRightWebpackPlugin;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> CopyRightWebpackPlugin = <span class="built_in">require</span>(<span class="string">'./plugin/copyright-webpack-plugin.js'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">'main'</span>: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CopyRightWebpackPlugin(&#123;</span><br><span class="line">      name:<span class="string">'haha'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"plugin"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack"</span>,</span><br><span class="line">    <span class="attr">"debug"</span>: <span class="string">"node --inspect --inspect-brk node_modules/webpack/bin/webpack.js"</span>,</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.30.0"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>npm run debug </p><p>进入下一步，添加 watch compilation 可以对一些类似这样的参数进行调试观察</p><p>具体的可以<a href="https://webpack.js.org/api/compiler-hooks">点击这里</a></p><h2 id="Bundler-源码编写（模块分析）"><a href="#Bundler-源码编写（模块分析）" class="headerlink" title="Bundler 源码编写（模块分析）"></a>Bundler 源码编写（模块分析）</h2><p>文件目录src 下面有三个文件，分别是 index.js message.js word.js ，引用关系是从左到右导入下一个的文件，具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// word.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> word = <span class="string">'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// message.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; word &#125; <span class="keyword">from</span> <span class="string">'./word.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">`say <span class="subst">$&#123;word&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> message; </span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> message <span class="keyword">from</span> <span class="string">'./message.js'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(message);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本配置</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">'@babel/parser'</span>);</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">'@babel/traverse'</span>).default;</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'@babel/core'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口文件的分析</span></span><br><span class="line"><span class="keyword">const</span> moduleAnalyser = <span class="function">(<span class="params">filename</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> content = fs.readFileSync(filename, <span class="string">'utf-8'</span>);</span><br><span class="line">  <span class="comment">// 抽象语法树</span></span><br><span class="line">  <span class="keyword">const</span> ast = parser.parse(content, &#123;</span><br><span class="line">    sourceType: <span class="string">'module'</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 依赖文件，键值对，键：依赖文件的相对路径，值：依赖文件的相对于bundler 的路径（绝对路径）</span></span><br><span class="line">  <span class="keyword">const</span> dependencies = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 分析抽象语法树</span></span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    <span class="comment">// 入口声明</span></span><br><span class="line">    ImportDeclaration(&#123; node &#125;) &#123;</span><br><span class="line">      <span class="comment">// 路径转换</span></span><br><span class="line">      <span class="keyword">const</span> dirname = path.dirname(filename);</span><br><span class="line">      <span class="keyword">const</span> newFile = <span class="string">'./'</span> + path.join(dirname, node.source.value)</span><br><span class="line">      dependencies[node.source.value] = newFile</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 抽象语法树的转换，提取可以在浏览器运行的代码</span></span><br><span class="line">  <span class="keyword">const</span> &#123; code &#125; = babel.transformFromAst(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">    <span class="comment">// 插件的集合</span></span><br><span class="line">    presets: [<span class="string">"@babel/preset-env"</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    filename,</span><br><span class="line">    dependencies,</span><br><span class="line">    code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依赖图谱</span></span><br><span class="line"><span class="keyword">const</span> makeDependenciesGraph = <span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> entryModule = moduleAnalyser(entry)</span><br><span class="line">  <span class="keyword">const</span> graphArray = [entryModule];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; graphArray.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = graphArray[i];</span><br><span class="line">    <span class="comment">// 获取依赖关系</span></span><br><span class="line">    <span class="keyword">const</span> &#123; dependencies &#125; = item;</span><br><span class="line">    <span class="keyword">if</span> (dependencies) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j <span class="keyword">in</span> dependencies) &#123;</span><br><span class="line">        graphArray.push(</span><br><span class="line">          moduleAnalyser(dependencies[j])</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 格式转换</span></span><br><span class="line">  <span class="keyword">const</span> graph = &#123;&#125;</span><br><span class="line">  graphArray.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    graph[item.filename] = &#123;</span><br><span class="line">      dependencies: item.dependencies,</span><br><span class="line">      code: item.code</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成浏览器可以用的代码</span></span><br><span class="line"><span class="keyword">const</span> generateCode = <span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 转为字符串</span></span><br><span class="line">  <span class="keyword">const</span> graph = <span class="built_in">JSON</span>.stringify(makeDependenciesGraph(entry));</span><br><span class="line">  <span class="comment">// graph code 里面有 exports 跟 require 的方法,但是浏览器没有这两个函数，需要我们自己去实现</span></span><br><span class="line">  <span class="built_in">console</span>.log(graph);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">  (function (graph) &#123;</span></span><br><span class="line"><span class="string">    function require(module) &#123;</span></span><br><span class="line"><span class="string">      function localRequire(relativePath) &#123;</span></span><br><span class="line"><span class="string">        return require(graph[module].dependencies[relativePath])</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      var exports = &#123;&#125;;</span></span><br><span class="line"><span class="string">      (function (require, exports, code) &#123;</span></span><br><span class="line"><span class="string">        eval(code)</span></span><br><span class="line"><span class="string">      &#125;)(localRequire, exports, graph[module].code);</span></span><br><span class="line"><span class="string">      return exports;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    require('<span class="subst">$&#123;entry&#125;</span>')</span></span><br><span class="line"><span class="string">  &#125;)(<span class="subst">$&#123; graph&#125;</span>)</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Info = generateCode(<span class="string">'./src/index.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Info);</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node bundler.js | highlight</span><br></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">graph</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">module</span>) </span>&#123; <span class="comment">// ./message.js 通过相对路径来拿到绝对路径</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">localRequire</span>(<span class="params">relativePath</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">require</span>(graph[<span class="built_in">module</span>].dependencies[relativePath])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> exports = &#123;&#125;;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, code</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">eval</span>(code)</span><br><span class="line">    &#125;)(localRequire, exports, graph[<span class="built_in">module</span>].code);</span><br><span class="line">    <span class="keyword">return</span> exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./src/index.js'</span>)</span><br><span class="line">&#125;)(&#123;<span class="string">"./src/index.js"</span>:&#123;<span class="string">"dependencies"</span>:&#123;<span class="string">"./message.js"</span>:<span class="string">"./src\\message.js"</span>&#125;,<span class="string">"code"</span>:<span class="string">"\"use strict\";\n\nvar _message = _interopRequireDefault(require(\"./message.js\"));\n\nfunction _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; \"default\": obj &#125;; &#125;\n\nconsole.log(_message[\"default\"]);"</span>&#125;,<span class="string">"./src\\message.js"</span>:&#123;<span class="string">"dependencies"</span>:&#123;<span class="string">"./word.js"</span>:<span class="string">"./src\\word.js"</span>&#125;,<span class="string">"code"</span>:<span class="string">"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", &#123;\n  value: true\n&#125;);\nexports[\"default\"] = void 0;\n\nvar _word = require(\"./word.js\");\n\nvar message = \"say \".concat(_word.word);\nvar _default = message;\nexports[\"default\"] = _default;"</span>&#125;,<span class="string">"./src\\word.js"</span>:&#123;<span class="string">"dependencies"</span>:&#123;&#125;,<span class="string">"code"</span>:<span class="string">"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", &#123;\n  value: true\n&#125;);\nexports.word = void 0;\nvar word = 'hello';\nexports.word = word;"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>复制粘贴到浏览器便可以运行</p><p>graph 输出内容是</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"./src/index.js"</span>: &#123;</span><br><span class="line">    <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">      <span class="attr">"./message.js"</span>: <span class="string">"./src\\message.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"code"</span>: <span class="string">"\"use strict\";\n\nvar _message = _interopRequireDefault(require(\"./message.js\"));\n\nfunction _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; \"default\": obj &#125;; &#125;\n\nconsole.log(_message[\"default\"]);"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"./src\\message.js"</span>: &#123;</span><br><span class="line">    <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">      <span class="attr">"./word.js"</span>: <span class="string">"./src\\word.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"code"</span>: <span class="string">"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", &#123;\n  value: true\n&#125;);\nexports[\"default\"] = void 0;\n\nvar _word = require(\"./word.js\");\n\nvar message = \"say \".concat(_word.word);\nvar _default = message;\nexports[\"default\"] = _default;"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"./src\\word.js"</span>: &#123;</span><br><span class="line">    <span class="attr">"dependencies"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"code"</span>: <span class="string">"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", &#123;\n  value: true\n&#125;);\nexports.word = void 0;\nvar word = 'hello';\nexports.word = word;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 code 里面的内容有一个require 函数和一个 exports 对象，所以为了这些代码能够在浏览器运行，我们需要自己创建一个 require函数和exports 空对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://coding.imooc.com/learn/list/316.html&quot;&gt;DellLee 老师的 webpack 学习与记录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;知识点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Loader&lt;/code&gt; 
      
    
    </summary>
    
      <category term="webpack" scheme="http://laibh.top/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://laibh.top/tags/webpack/"/>
    
  </entry>
  
</feed>
